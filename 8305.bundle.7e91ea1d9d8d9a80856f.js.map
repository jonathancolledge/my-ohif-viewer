{"version":3,"file":"8305.bundle.7e91ea1d9d8d9a80856f.js","mappings":"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","sources":["webpack:///../../../extensions/cornerstone-dicom-seg/src/id.js","webpack:///../../../extensions/cornerstone-dicom-seg/src/getSopClassHandlerModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/utils/dicomlabToRGB.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/getHangingProtocolModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/commandsModule.ts","webpack:///../../../extensions/cornerstone-dicom-seg/src/components/LogicalContourOperationsOptions.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/components/SimplifyContourOptions.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/components/SmoothContoursOptions.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/index.tsx","webpack:///../../../extensions/cornerstone-dicom-seg/src/getToolbarModule.ts"],"sourcesContent":["import packageJson from '../package.json';\r\n\r\nconst id = packageJson.name;\r\nconst SOPClassHandlerName = 'dicom-seg';\r\nconst SOPClassHandlerId = `${id}.sopClassHandlerModule.${SOPClassHandlerName}`;\r\n\r\nexport { id, SOPClassHandlerId, SOPClassHandlerName };\r\n","import { utils, Types as OhifTypes } from '@ohif/core';\r\nimport i18n from '@ohif/i18n';\r\nimport { metaData, eventTarget } from '@cornerstonejs/core';\r\nimport { CONSTANTS, segmentation as cstSegmentation } from '@cornerstonejs/tools';\r\nimport { adaptersSEG, Enums } from '@cornerstonejs/adapters';\r\n\r\nimport { SOPClassHandlerId } from './id';\r\nimport { dicomlabToRGB } from './utils/dicomlabToRGB';\r\n\r\nconst sopClassUids = ['1.2.840.10008.5.1.4.1.1.66.4', '1.2.840.10008.5.1.4.1.1.66.7'];\r\n\r\nconst loadPromises = {};\r\n\r\nfunction _getDisplaySetsFromSeries(\r\n  instances,\r\n  servicesManager: AppTypes.ServicesManager,\r\n  extensionManager\r\n) {\r\n  utils.sortStudyInstances(instances);\r\n\r\n  // Choose the LAST instance in the list as the most recently created one.\r\n  const instance = instances[instances.length - 1];\r\n\r\n  const {\r\n    StudyInstanceUID,\r\n    SeriesInstanceUID,\r\n    SOPInstanceUID,\r\n    SeriesDescription = '',\r\n    SeriesNumber,\r\n    SeriesDate,\r\n    StructureSetDate,\r\n    SOPClassUID,\r\n    wadoRoot,\r\n    wadoUri,\r\n    wadoUriRoot,\r\n    imageId: predecessorImageId,\r\n  } = instance;\r\n\r\n  const displaySet = {\r\n    Modality: 'SEG',\r\n    loading: false,\r\n    isReconstructable: false,\r\n    displaySetInstanceUID: utils.guid(),\r\n    SeriesDescription,\r\n    SeriesNumber,\r\n    SeriesDate: SeriesDate || StructureSetDate || '',\r\n    SOPInstanceUID,\r\n    SeriesInstanceUID,\r\n    StudyInstanceUID,\r\n    SOPClassHandlerId,\r\n    SOPClassUID,\r\n    referencedImages: null,\r\n    referencedSeriesInstanceUID: null,\r\n    referencedDisplaySetInstanceUID: null,\r\n    isDerivedDisplaySet: true,\r\n    isLoaded: false,\r\n    isHydrated: false,\r\n    segments: {},\r\n    sopClassUids,\r\n    instance,\r\n    predecessorImageId,\r\n    instances: [instance],\r\n    wadoRoot,\r\n    wadoUriRoot,\r\n    wadoUri,\r\n    isOverlayDisplaySet: true,\r\n    label: SeriesDescription || `${i18n.t('Series')} ${SeriesNumber} - ${i18n.t('SEG')}`,\r\n  };\r\n\r\n  const referencedSeriesSequence = instance.ReferencedSeriesSequence;\r\n\r\n  if (!referencedSeriesSequence) {\r\n    console.error('ReferencedSeriesSequence is missing for the SEG');\r\n    return;\r\n  }\r\n\r\n  const referencedSeries = referencedSeriesSequence[0] || referencedSeriesSequence;\r\n\r\n  displaySet.referencedImages = instance.ReferencedSeriesSequence.ReferencedInstanceSequence;\r\n  displaySet.referencedSeriesInstanceUID = referencedSeries.SeriesInstanceUID;\r\n  const { displaySetService } = servicesManager.services;\r\n  const referencedDisplaySets = displaySetService.getDisplaySetsForReferences(\r\n    instance.ReferencedSeriesSequence\r\n  );\r\n\r\n  if (referencedDisplaySets?.length > 1) {\r\n    console.warn(\r\n      'Segmentation does not currently handle references to multiple series, defaulting to first series'\r\n    );\r\n  }\r\n\r\n  const referencedDisplaySet = referencedDisplaySets[0];\r\n\r\n  if (!referencedDisplaySet) {\r\n    // subscribe to display sets added which means at some point it will be available\r\n    const { unsubscribe } = displaySetService.subscribe(\r\n      displaySetService.EVENTS.DISPLAY_SETS_ADDED,\r\n      ({ displaySetsAdded }) => {\r\n        // here we can also do a little bit of search, since sometimes DICOM SEG\r\n        // does not contain the referenced display set uid , and we can just\r\n        // see which of the display sets added is more similar and assign it\r\n        // to the referencedDisplaySet\r\n        const addedDisplaySet = displaySetsAdded[0];\r\n        if (addedDisplaySet.SeriesInstanceUID === displaySet.referencedSeriesInstanceUID) {\r\n          displaySet.referencedDisplaySetInstanceUID = addedDisplaySet.displaySetInstanceUID;\r\n          displaySet.isReconstructable = addedDisplaySet.isReconstructable;\r\n          unsubscribe();\r\n        }\r\n      }\r\n    );\r\n  } else {\r\n    displaySet.referencedDisplaySetInstanceUID = referencedDisplaySet.displaySetInstanceUID;\r\n    displaySet.isReconstructable = referencedDisplaySet.isReconstructable;\r\n  }\r\n\r\n  displaySet.load = async ({ headers }) =>\r\n    await _load(displaySet, servicesManager, extensionManager, headers);\r\n\r\n  return [displaySet];\r\n}\r\n\r\nfunction _load(\r\n  segDisplaySet,\r\n  servicesManager: AppTypes.ServicesManager,\r\n  extensionManager,\r\n  headers\r\n) {\r\n  const { SOPInstanceUID } = segDisplaySet;\r\n  const { segmentationService } = servicesManager.services;\r\n\r\n  if (\r\n    (segDisplaySet.loading || segDisplaySet.isLoaded) &&\r\n    loadPromises[SOPInstanceUID] &&\r\n    _segmentationExists(segDisplaySet)\r\n  ) {\r\n    return loadPromises[SOPInstanceUID];\r\n  }\r\n\r\n  segDisplaySet.loading = true;\r\n\r\n  // We don't want to fire multiple loads, so we'll wait for the first to finish\r\n  // and also return the same promise to any other callers.\r\n  loadPromises[SOPInstanceUID] = new Promise(async (resolve, reject) => {\r\n    if (!segDisplaySet.segments || Object.keys(segDisplaySet.segments).length === 0) {\r\n      try {\r\n        await _loadSegments({\r\n          extensionManager,\r\n          servicesManager,\r\n          segDisplaySet,\r\n          headers,\r\n        });\r\n      } catch (e) {\r\n        segDisplaySet.loading = false;\r\n        return reject(e);\r\n      }\r\n    }\r\n\r\n    segmentationService\r\n      .createSegmentationForSEGDisplaySet(segDisplaySet)\r\n      .then(() => {\r\n        segDisplaySet.loading = false;\r\n        resolve();\r\n      })\r\n      .catch(error => {\r\n        segDisplaySet.loading = false;\r\n        reject(error);\r\n      });\r\n  });\r\n\r\n  return loadPromises[SOPInstanceUID];\r\n}\r\n\r\nasync function _loadSegments({\r\n  extensionManager,\r\n  servicesManager,\r\n  segDisplaySet,\r\n  headers,\r\n}: withAppTypes) {\r\n  const utilityModule = extensionManager.getModuleEntry(\r\n    '@ohif/extension-cornerstone.utilityModule.common'\r\n  );\r\n\r\n  const { segmentationService, uiNotificationService } = servicesManager.services;\r\n\r\n  const { dicomLoaderService } = utilityModule.exports;\r\n  const arrayBuffer = await dicomLoaderService.findDicomDataPromise(segDisplaySet, null, headers);\r\n\r\n  const referencedDisplaySet = servicesManager.services.displaySetService.getDisplaySetByUID(\r\n    segDisplaySet.referencedDisplaySetInstanceUID\r\n  );\r\n\r\n  if (!referencedDisplaySet) {\r\n    throw new Error('referencedDisplaySet is missing for SEG');\r\n  }\r\n\r\n  let { imageIds } = referencedDisplaySet;\r\n\r\n  if (!imageIds) {\r\n    // try images\r\n    const { images } = referencedDisplaySet;\r\n    imageIds = images.map(image => image.imageId);\r\n  }\r\n\r\n  // Todo: what should be defaults here\r\n  const tolerance = 0.001;\r\n  eventTarget.addEventListener(Enums.Events.SEGMENTATION_LOAD_PROGRESS, evt => {\r\n    const { percentComplete } = evt.detail;\r\n    segmentationService._broadcastEvent(segmentationService.EVENTS.SEGMENT_LOADING_COMPLETE, {\r\n      percentComplete,\r\n    });\r\n  });\r\n\r\n  const results = await adaptersSEG.Cornerstone3D.Segmentation.createFromDICOMSegBuffer(\r\n    imageIds,\r\n    arrayBuffer,\r\n    { metadataProvider: metaData, tolerance }\r\n  );\r\n\r\n  let usedRecommendedDisplayCIELabValue = true;\r\n  results.segMetadata.data.forEach((data, i) => {\r\n    if (i > 0) {\r\n      data.rgba = data.RecommendedDisplayCIELabValue;\r\n\r\n      if (data.rgba) {\r\n        data.rgba = dicomlabToRGB(data.rgba);\r\n      } else {\r\n        usedRecommendedDisplayCIELabValue = false;\r\n        data.rgba = CONSTANTS.COLOR_LUT[i % CONSTANTS.COLOR_LUT.length];\r\n      }\r\n    }\r\n  });\r\n\r\n  if (!usedRecommendedDisplayCIELabValue) {\r\n    // Display a notification about the non-utilization of RecommendedDisplayCIELabValue\r\n    uiNotificationService.show({\r\n      title: 'DICOM SEG import',\r\n      message:\r\n        'RecommendedDisplayCIELabValue not found for one or more segments. The default color was used instead.',\r\n      type: 'warning',\r\n      duration: 5000,\r\n    });\r\n  }\r\n\r\n  Object.assign(segDisplaySet, results);\r\n}\r\n\r\nfunction _segmentationExists(segDisplaySet) {\r\n  return cstSegmentation.state.getSegmentation(segDisplaySet.displaySetInstanceUID);\r\n}\r\n\r\nfunction getSopClassHandlerModule(params: OhifTypes.Extensions.ExtensionParams) {\r\n  const { servicesManager, extensionManager } = params;\r\n  const getDisplaySetsFromSeries = instances => {\r\n    return _getDisplaySetsFromSeries(instances, servicesManager, extensionManager);\r\n  };\r\n\r\n  return [\r\n    {\r\n      name: 'dicom-seg',\r\n      sopClassUids,\r\n      getDisplaySetsFromSeries,\r\n    },\r\n  ];\r\n}\r\n\r\nexport default getSopClassHandlerModule;\r\n","import dcmjs from 'dcmjs';\r\n\r\n/**\r\n * Converts a CIELAB color to an RGB color using the dcmjs library.\r\n * @param cielab - The CIELAB color to convert.\r\n * @returns The RGB color as an array of three integers between 0 and 255.\r\n */\r\nfunction dicomlabToRGB(cielab: number[]): number[] {\r\n  const rgb = dcmjs.data.Colors.dicomlab2RGB(cielab).map(x => Math.round(x * 255));\r\n\r\n  return rgb;\r\n}\r\n\r\nexport { dicomlabToRGB };\r\n","import { Types } from '@ohif/core';\r\n\r\nconst segProtocol: Types.HangingProtocol.Protocol = {\r\n  id: '@ohif/seg',\r\n  // Don't store this hanging protocol as it applies to the currently active\r\n  // display set by default\r\n  // cacheId: null,\r\n  name: 'Segmentations',\r\n  // Just apply this one when specifically listed\r\n  protocolMatchingRules: [],\r\n  toolGroupIds: ['default'],\r\n  // -1 would be used to indicate active only, whereas other values are\r\n  // the number of required priors referenced - so 0 means active with\r\n  // 0 or more priors.\r\n  numberOfPriorsReferenced: 0,\r\n  // Default viewport is used to define the viewport when\r\n  // additional viewports are added using the layout tool\r\n  defaultViewport: {\r\n    viewportOptions: {\r\n      viewportType: 'stack',\r\n      toolGroupId: 'default',\r\n      allowUnmatchedView: true,\r\n      syncGroups: [\r\n        {\r\n          type: 'hydrateseg',\r\n          id: 'sameFORId',\r\n          source: true,\r\n          target: true,\r\n          // options: {\r\n          //   matchingRules: ['sameFOR'],\r\n          // },\r\n        },\r\n      ],\r\n    },\r\n    displaySets: [\r\n      {\r\n        id: 'segDisplaySetId',\r\n        matchedDisplaySetsIndex: -1,\r\n      },\r\n    ],\r\n  },\r\n  displaySetSelectors: {\r\n    segDisplaySetId: {\r\n      seriesMatchingRules: [\r\n        {\r\n          attribute: 'Modality',\r\n          constraint: {\r\n            equals: 'SEG',\r\n          },\r\n        },\r\n      ],\r\n    },\r\n  },\r\n  stages: [\r\n    {\r\n      name: 'Segmentations',\r\n      viewportStructure: {\r\n        layoutType: 'grid',\r\n        properties: {\r\n          rows: 1,\r\n          columns: 1,\r\n        },\r\n      },\r\n      viewports: [\r\n        {\r\n          viewportOptions: {\r\n            allowUnmatchedView: true,\r\n            syncGroups: [\r\n              {\r\n                type: 'hydrateseg',\r\n                id: 'sameFORId',\r\n                source: true,\r\n                target: true,\r\n                // options: {\r\n                //   matchingRules: ['sameFOR'],\r\n                // },\r\n              },\r\n            ],\r\n          },\r\n          displaySets: [\r\n            {\r\n              id: 'segDisplaySetId',\r\n            },\r\n          ],\r\n        },\r\n      ],\r\n    },\r\n  ],\r\n};\r\n\r\nfunction getHangingProtocolModule() {\r\n  return [\r\n    {\r\n      name: segProtocol.id,\r\n      protocol: segProtocol,\r\n    },\r\n  ];\r\n}\r\n\r\nexport default getHangingProtocolModule;\r\nexport { segProtocol };\r\n","import dcmjs from 'dcmjs';\r\nimport { classes, Types, utils } from '@ohif/core';\r\nimport { cache, metaData } from '@cornerstonejs/core';\r\nimport { segmentation as cornerstoneToolsSegmentation } from '@cornerstonejs/tools';\r\nimport { adaptersRT, helpers, adaptersSEG } from '@cornerstonejs/adapters';\r\nimport { createReportDialogPrompt, useUIStateStore } from '@ohif/extension-default';\r\nimport { DicomMetadataStore } from '@ohif/core';\r\n\r\nimport PROMPT_RESPONSES from '../../default/src/utils/_shared/PROMPT_RESPONSES';\r\n\r\nconst getTargetViewport = ({ viewportId, viewportGridService }) => {\r\n  const { viewports, activeViewportId } = viewportGridService.getState();\r\n  const targetViewportId = viewportId || activeViewportId;\r\n\r\n  const viewport = viewports.get(targetViewportId);\r\n\r\n  return viewport;\r\n};\r\n\r\nconst {\r\n  Cornerstone3D: {\r\n    Segmentation: { generateSegmentation },\r\n  },\r\n} = adaptersSEG;\r\n\r\nconst {\r\n  Cornerstone3D: {\r\n    RTSS: { generateRTSSFromRepresentation },\r\n  },\r\n} = adaptersRT;\r\n\r\nconst { downloadDICOMData } = helpers;\r\n\r\nconst commandsModule = ({\r\n  servicesManager,\r\n  extensionManager,\r\n}: Types.Extensions.ExtensionParams): Types.Extensions.CommandsModule => {\r\n  const { segmentationService, displaySetService, viewportGridService } =\r\n    servicesManager.services as AppTypes.Services;\r\n\r\n  const actions = {\r\n    /**\r\n     * Loads segmentations for a specified viewport.\r\n     * The function prepares the viewport for rendering, then loads the segmentation details.\r\n     * Additionally, if the segmentation has scalar data, it is set for the corresponding label map volume.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.segmentations - Array of segmentations to be loaded.\r\n     * @param params.viewportId - the target viewport ID.\r\n     *\r\n     */\r\n    loadSegmentationsForViewport: async ({ segmentations, viewportId }) => {\r\n      // Todo: handle adding more than one segmentation\r\n      const viewport = getTargetViewport({ viewportId, viewportGridService });\r\n      const displaySetInstanceUID = viewport.displaySetInstanceUIDs[0];\r\n\r\n      const segmentation = segmentations[0];\r\n      const segmentationId = segmentation.segmentationId;\r\n      const label = segmentation.config.label;\r\n      const segments = segmentation.config.segments;\r\n\r\n      const displaySet = displaySetService.getDisplaySetByUID(displaySetInstanceUID);\r\n\r\n      await segmentationService.createLabelmapForDisplaySet(displaySet, {\r\n        segmentationId,\r\n        segments,\r\n        label,\r\n      });\r\n\r\n      segmentationService.addOrUpdateSegmentation(segmentation);\r\n\r\n      await segmentationService.addSegmentationRepresentation(viewport.viewportId, {\r\n        segmentationId,\r\n      });\r\n\r\n      return segmentationId;\r\n    },\r\n    /**\r\n     * Generates a segmentation from a given segmentation ID.\r\n     * This function retrieves the associated segmentation and\r\n     * its referenced volume, extracts label maps from the\r\n     * segmentation volume, and produces segmentation data\r\n     * alongside associated metadata.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.segmentationId - ID of the segmentation to be generated.\r\n     * @param params.options - Optional configuration for the generation process.\r\n     *\r\n     * @returns Returns the generated segmentation data.\r\n     */\r\n    generateSegmentation: ({ segmentationId, options = {} }) => {\r\n      const segmentation = cornerstoneToolsSegmentation.state.getSegmentation(segmentationId);\r\n      const predecessorImageId = options.predecessorImageId ?? segmentation.predecessorImageId;\r\n\r\n      const { imageIds } = segmentation.representationData.Labelmap;\r\n\r\n      const segImages = imageIds.map(imageId => cache.getImage(imageId));\r\n      const referencedImages = segImages.map(image => cache.getImage(image.referencedImageId));\r\n\r\n      const labelmaps2D = [];\r\n\r\n      let z = 0;\r\n\r\n      for (const segImage of segImages) {\r\n        const segmentsOnLabelmap = new Set();\r\n        const pixelData = segImage.getPixelData();\r\n        const { rows, columns } = segImage;\r\n\r\n        // Use a single pass through the pixel data\r\n        for (let i = 0; i < pixelData.length; i++) {\r\n          const segment = pixelData[i];\r\n          if (segment !== 0) {\r\n            segmentsOnLabelmap.add(segment);\r\n          }\r\n        }\r\n\r\n        labelmaps2D[z++] = {\r\n          segmentsOnLabelmap: Array.from(segmentsOnLabelmap),\r\n          pixelData,\r\n          rows,\r\n          columns,\r\n        };\r\n      }\r\n\r\n      const allSegmentsOnLabelmap = labelmaps2D.map(labelmap => labelmap.segmentsOnLabelmap);\r\n\r\n      const labelmap3D = {\r\n        segmentsOnLabelmap: Array.from(new Set(allSegmentsOnLabelmap.flat())),\r\n        metadata: [],\r\n        labelmaps2D,\r\n      };\r\n\r\n      const segmentationInOHIF = segmentationService.getSegmentation(segmentationId);\r\n      const representations = segmentationService.getRepresentationsForSegmentation(segmentationId);\r\n\r\n      Object.entries(segmentationInOHIF.segments).forEach(([segmentIndex, segment]) => {\r\n        // segmentation service already has a color for each segment\r\n        if (!segment) {\r\n          return;\r\n        }\r\n\r\n        const { label } = segment;\r\n\r\n        const firstRepresentation = representations[0];\r\n        const color = segmentationService.getSegmentColor(\r\n          firstRepresentation.viewportId,\r\n          segmentationId,\r\n          segment.segmentIndex\r\n        );\r\n\r\n        const RecommendedDisplayCIELabValue = dcmjs.data.Colors.rgb2DICOMLAB(\r\n          color.slice(0, 3).map(value => value / 255)\r\n        ).map(value => Math.round(value));\r\n\r\n        const segmentMetadata = {\r\n          SegmentNumber: segmentIndex.toString(),\r\n          SegmentLabel: label,\r\n          SegmentAlgorithmType: segment?.algorithmType || 'MANUAL',\r\n          SegmentAlgorithmName: segment?.algorithmName || 'OHIF Brush',\r\n          RecommendedDisplayCIELabValue,\r\n          SegmentedPropertyCategoryCodeSequence: {\r\n            CodeValue: 'T-D0050',\r\n            CodingSchemeDesignator: 'SRT',\r\n            CodeMeaning: 'Tissue',\r\n          },\r\n          SegmentedPropertyTypeCodeSequence: {\r\n            CodeValue: 'T-D0050',\r\n            CodingSchemeDesignator: 'SRT',\r\n            CodeMeaning: 'Tissue',\r\n          },\r\n        };\r\n        labelmap3D.metadata[segmentIndex] = segmentMetadata;\r\n      });\r\n\r\n      const generatedSegmentation = generateSegmentation(referencedImages, labelmap3D, metaData, {\r\n        predecessorImageId,\r\n        ...options,\r\n      });\r\n\r\n      return generatedSegmentation;\r\n    },\r\n    /**\r\n     * Downloads a segmentation based on the provided segmentation ID.\r\n     * This function retrieves the associated segmentation and\r\n     * uses it to generate the corresponding DICOM dataset, which\r\n     * is then downloaded with an appropriate filename.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.segmentationId - ID of the segmentation to be downloaded.\r\n     *\r\n     */\r\n    downloadSegmentation: ({ segmentationId }) => {\r\n      const segmentationInOHIF = segmentationService.getSegmentation(segmentationId);\r\n      const generatedSegmentation = actions.generateSegmentation({\r\n        segmentationId,\r\n      });\r\n\r\n      downloadDICOMData(generatedSegmentation.dataset, `${segmentationInOHIF.label}`);\r\n    },\r\n    /**\r\n     * Stores a segmentation based on the provided segmentationId into a specified data source.\r\n     * The SeriesDescription is derived from user input or defaults to the segmentation label,\r\n     * and in its absence, defaults to 'Research Derived Series'.\r\n     *\r\n     * @param {Object} params - Parameters for the function.\r\n     * @param params.segmentationId - ID of the segmentation to be stored.\r\n     * @param params.dataSource - Data source where the generated segmentation will be stored.\r\n     *\r\n     * @returns {Object|void} Returns the naturalized report if successfully stored,\r\n     * otherwise throws an error.\r\n     */\r\n    storeSegmentation: async ({ segmentationId, dataSource, modality = 'SEG' }) => {\r\n      const segmentation = segmentationService.getSegmentation(segmentationId);\r\n\r\n      if (!segmentation) {\r\n        throw new Error('No segmentation found');\r\n      }\r\n\r\n      const { label, predecessorImageId } = segmentation;\r\n      const defaultDataSource = dataSource ?? extensionManager.getActiveDataSource()[0];\r\n\r\n      const {\r\n        value: reportName,\r\n        dataSourceName: selectedDataSource,\r\n        series,\r\n        priorSeriesNumber,\r\n        action,\r\n      } = await createReportDialogPrompt({\r\n        servicesManager,\r\n        extensionManager,\r\n        predecessorImageId,\r\n        title: 'Store Segmentation',\r\n        modality,\r\n      });\r\n\r\n      if (action === PROMPT_RESPONSES.CREATE_REPORT) {\r\n        try {\r\n          const selectedDataSourceConfig = selectedDataSource\r\n            ? extensionManager.getDataSources(selectedDataSource)[0]\r\n            : defaultDataSource;\r\n\r\n          const args = {\r\n            segmentationId,\r\n            options: {\r\n              SeriesDescription: series ? undefined : reportName || label || 'Contour Series',\r\n              SeriesNumber: series ? undefined : 1 + priorSeriesNumber,\r\n              predecessorImageId: series,\r\n            },\r\n          };\r\n          const generatedDataAsync =\r\n            (modality === 'SEG' && actions.generateSegmentation(args)) ||\r\n            (modality === 'RTSTRUCT' && actions.generateContour(args));\r\n          const generatedData = await generatedDataAsync;\r\n\r\n          if (!generatedData || !generatedData.dataset) {\r\n            throw new Error('Error during segmentation generation');\r\n          }\r\n\r\n          const { dataset: naturalizedReport } = generatedData;\r\n\r\n          // DCMJS assigns a dummy study id during creation, and this can cause problems, so clearing it out\r\n          if (naturalizedReport.StudyID === 'No Study ID') {\r\n            naturalizedReport.StudyID = '';\r\n          }\r\n\r\n          await selectedDataSourceConfig.store.dicom(naturalizedReport);\r\n\r\n          // add the information for where we stored it to the instance as well\r\n          naturalizedReport.wadoRoot = selectedDataSourceConfig.getConfig().wadoRoot;\r\n\r\n          DicomMetadataStore.addInstances([naturalizedReport], true);\r\n\r\n          return naturalizedReport;\r\n        } catch (error) {\r\n          console.debug('Error storing segmentation:', error);\r\n          throw error;\r\n        }\r\n      }\r\n    },\r\n\r\n    generateContour: async args => {\r\n      const { segmentationId, options } = args;\r\n      const segmentations = segmentationService.getSegmentation(segmentationId);\r\n\r\n      // inject colors to the segmentIndex\r\n      const firstRepresentation =\r\n        segmentationService.getRepresentationsForSegmentation(segmentationId)[0];\r\n      Object.entries(segmentations.segments).forEach(([segmentIndex, segment]) => {\r\n        segment.color = segmentationService.getSegmentColor(\r\n          firstRepresentation.viewportId,\r\n          segmentationId,\r\n          Number(segmentIndex)\r\n        );\r\n      });\r\n      const predecessorImageId = options?.predecessorImageId ?? segmentations.predecessorImageId;\r\n      const dataset = await generateRTSSFromRepresentation(segmentations, {\r\n        predecessorImageId,\r\n        ...options,\r\n      });\r\n      return { dataset };\r\n    },\r\n\r\n    /**\r\n     * Downloads an RTSS instance from a segmentation or contour\r\n     * representation.\r\n     */\r\n    downloadRTSS: async args => {\r\n      const { dataset } = await actions.generateContour(args);\r\n      const { InstanceNumber: instanceNumber = 1, SeriesInstanceUID: seriesUID } = dataset;\r\n\r\n      try {\r\n        //Create a URL for the binary.\r\n        const filename = `rtss-${seriesUID}-${instanceNumber}.dcm`;\r\n        downloadDICOMData(dataset, filename);\r\n      } catch (e) {\r\n        console.warn(e);\r\n      }\r\n    },\r\n\r\n    toggleActiveSegmentationUtility: ({ itemId: buttonId }) => {\r\n      const { uiState, setUIState } = useUIStateStore.getState();\r\n      const isButtonActive = uiState['activeSegmentationUtility'] === buttonId;\r\n      console.log('toggleActiveSegmentationUtility', isButtonActive, buttonId);\r\n      // if the button is active, clear the active segmentation utility\r\n      if (isButtonActive) {\r\n        setUIState('activeSegmentationUtility', null);\r\n      } else {\r\n        setUIState('activeSegmentationUtility', buttonId);\r\n      }\r\n    },\r\n  };\r\n\r\n  const definitions = {\r\n    loadSegmentationsForViewport: actions.loadSegmentationsForViewport,\r\n    generateSegmentation: actions.generateSegmentation,\r\n    downloadSegmentation: actions.downloadSegmentation,\r\n    storeSegmentation: actions.storeSegmentation,\r\n    downloadRTSS: actions.downloadRTSS,\r\n    toggleActiveSegmentationUtility: actions.toggleActiveSegmentationUtility,\r\n  };\r\n\r\n  return {\r\n    actions,\r\n    definitions,\r\n    defaultContext: 'SEGMENTATION',\r\n  };\r\n};\r\n\r\nexport default commandsModule;\r\n","import React, { useCallback, useEffect, useState } from 'react';\r\nimport { useRunCommand, useSystem } from '@ohif/core';\r\nimport { useActiveViewportSegmentationRepresentations } from '@ohif/extension-cornerstone';\r\nimport {\r\n  Button,\r\n  cn,\r\n  Input,\r\n  Label,\r\n  Select,\r\n  SelectContent,\r\n  SelectItem,\r\n  SelectTrigger,\r\n  SelectValue,\r\n  Separator,\r\n  Switch,\r\n  Tabs,\r\n  TabsList,\r\n  TabsTrigger,\r\n} from '@ohif/ui-next';\r\nimport { Icons } from '@ohif/ui-next';\r\nimport { contourSegmentation } from '@cornerstonejs/tools/utilities';\r\nimport { Segment } from '@cornerstonejs/tools/types';\r\n\r\nconst { LogicalOperation } = contourSegmentation;\r\nconst options = [\r\n  {\r\n    value: 'merge',\r\n    logicalOperation: LogicalOperation.Union,\r\n    label: 'Merge',\r\n    icon: 'actions-combine-merge',\r\n    helperIcon: 'helper-combine-merge',\r\n  },\r\n  {\r\n    value: 'intersect',\r\n    logicalOperation: LogicalOperation.Intersect,\r\n    label: 'Intersect',\r\n    icon: 'actions-combine-intersect',\r\n    helperIcon: 'helper-combine-intersect',\r\n  },\r\n  {\r\n    value: 'subtract',\r\n    logicalOperation: LogicalOperation.Subtract,\r\n    label: 'Subtract',\r\n    icon: 'actions-combine-subtract',\r\n    helperIcon: 'helper-combine-subtract',\r\n  },\r\n];\r\n\r\n// Shared component for segment selection\r\nfunction SegmentSelector({\r\n  label,\r\n  value,\r\n  onValueChange,\r\n  segments,\r\n  placeholder = 'Select a segment',\r\n}: {\r\n  label: string;\r\n  value: string;\r\n  onValueChange: (value: string) => void;\r\n  segments: Segment[];\r\n  placeholder?: string;\r\n}) {\r\n  return (\r\n    <div className=\"flex justify-between gap-6\">\r\n      <div>{label}</div>\r\n      <Select\r\n        key={`select-segment-${label}`}\r\n        onValueChange={onValueChange}\r\n        value={value}\r\n      >\r\n        <SelectTrigger className=\"overflow-hidden\">\r\n          <SelectValue placeholder={placeholder} />\r\n        </SelectTrigger>\r\n        <SelectContent>\r\n          {segments.map(segment => (\r\n            <SelectItem\r\n              key={segment.segmentIndex}\r\n              value={segment.segmentIndex.toString()}\r\n            >\r\n              {segment.label}\r\n            </SelectItem>\r\n          ))}\r\n        </SelectContent>\r\n      </Select>\r\n    </div>\r\n  );\r\n}\r\n\r\nfunction LogicalContourOperationOptions() {\r\n  const { servicesManager } = useSystem();\r\n  const { segmentationService } = servicesManager.services;\r\n  const { segmentationsWithRepresentations } = useActiveViewportSegmentationRepresentations();\r\n\r\n  const activeRepresentation = segmentationsWithRepresentations?.find(\r\n    ({ representation }) => representation?.active\r\n  );\r\n\r\n  const segments = activeRepresentation\r\n    ? Object.values(activeRepresentation.segmentation.segments)\r\n    : [];\r\n\r\n  // Calculate the next available segment index\r\n  const nextSegmentIndex = activeRepresentation\r\n    ? segmentationService.getNextAvailableSegmentIndex(\r\n        activeRepresentation.segmentation.segmentationId\r\n      )\r\n    : 1;\r\n\r\n  const activeSegment = segments.find(segment => segment.active);\r\n\r\n  const activeSegmentIndex = activeSegment?.segmentIndex || 0;\r\n\r\n  const [operation, setOperation] = useState(options[0]);\r\n  const [segmentA, setSegmentA] = useState<string>(activeSegmentIndex?.toString() || '');\r\n  const [segmentB, setSegmentB] = useState<string>('');\r\n  const [createNewSegment, setCreateNewSegment] = useState<boolean>(false);\r\n  const [newSegmentName, setNewSegmentName] = useState<string>('');\r\n\r\n  useEffect(() => {\r\n    setSegmentA(activeSegmentIndex?.toString() || null);\r\n  }, [activeSegmentIndex]);\r\n\r\n  useEffect(() => {\r\n    setNewSegmentName(`Segment ${nextSegmentIndex}`);\r\n  }, [nextSegmentIndex]);\r\n\r\n  const runCommand = useRunCommand();\r\n\r\n  const applyLogicalContourOperation = useCallback(() => {\r\n    let resultSegmentIndex = segmentA;\r\n    if (createNewSegment) {\r\n      resultSegmentIndex = nextSegmentIndex.toString();\r\n      runCommand('addSegment', {\r\n        segmentationId: activeRepresentation.segmentation.segmentationId,\r\n        config: {\r\n          label: newSegmentName,\r\n          segmentIndex: nextSegmentIndex,\r\n        },\r\n      });\r\n    }\r\n    runCommand('applyLogicalContourOperation', {\r\n      segmentAInfo: {\r\n        segmentationId: activeRepresentation.segmentation.segmentationId,\r\n        segmentIndex: parseInt(segmentA),\r\n      },\r\n      segmentBInfo: {\r\n        segmentationId: activeRepresentation.segmentation.segmentationId,\r\n        segmentIndex: parseInt(segmentB),\r\n      },\r\n      resultSegmentInfo: {\r\n        segmentationId: activeRepresentation.segmentation.segmentationId,\r\n        segmentIndex: parseInt(resultSegmentIndex),\r\n      },\r\n      logicalOperation: operation.logicalOperation,\r\n    });\r\n  }, [\r\n    activeRepresentation?.segmentation?.segmentationId,\r\n    createNewSegment,\r\n    newSegmentName,\r\n    nextSegmentIndex,\r\n    operation.logicalOperation,\r\n    runCommand,\r\n    segmentA,\r\n    segmentB,\r\n  ]);\r\n\r\n  return (\r\n    <div className=\"flex w-[245px] flex-col gap-4\">\r\n      <div className=\"flex items-start justify-between\">\r\n        <div className=\"flex w-auto flex-col items-center gap-2 text-base font-normal leading-none\">\r\n          <Tabs value={operation.value}>\r\n            <TabsList className=\"inline-flex space-x-1\">\r\n              {options.map(option => {\r\n                const { value, icon } = option;\r\n                return (\r\n                  <TabsTrigger\r\n                    value={value}\r\n                    key={`logical-contour-operation-${value}`}\r\n                    onClick={() => setOperation(option)}\r\n                  >\r\n                    <Icons.ByName name={icon}></Icons.ByName>\r\n                  </TabsTrigger>\r\n                );\r\n              })}\r\n            </TabsList>\r\n          </Tabs>\r\n          <div>{operation.label}</div>\r\n        </div>\r\n        <div className=\"bg-primary-dark flex h-[62px] w-[88px] items-center justify-center rounded-lg\">\r\n          <Icons.ByName name={operation.helperIcon}></Icons.ByName>\r\n        </div>\r\n      </div>\r\n      <SegmentSelector\r\n        label=\"A\"\r\n        value={segmentA}\r\n        onValueChange={setSegmentA}\r\n        segments={segments}\r\n      />\r\n      <SegmentSelector\r\n        label=\"B\"\r\n        value={segmentB}\r\n        onValueChange={setSegmentB}\r\n        segments={segments}\r\n      />\r\n      <div className=\"flex justify-end pl-[34px]\">\r\n        <Button\r\n          className=\"border-primary/60 grow border\"\r\n          variant=\"ghost\"\r\n          onClick={() => {\r\n            applyLogicalContourOperation();\r\n          }}\r\n        >\r\n          {operation.label}\r\n        </Button>\r\n      </div>\r\n      <Separator className=\"bg-input mt-2 h-[1px]\" />\r\n      <div className=\"flex flex-col gap-2\">\r\n        <div className=\"flex items-center justify-start gap-2\">\r\n          <Switch\r\n            id=\"logical-contour-operations-create-new-segment-switch\"\r\n            onCheckedChange={setCreateNewSegment}\r\n          ></Switch>\r\n          <Label htmlFor=\"logical-contour-operations-create-new-segment-switch\">\r\n            Create a new segment\r\n          </Label>\r\n        </div>\r\n        <div className=\"pl-9\">\r\n          <Input\r\n            className={cn(createNewSegment ? 'visible' : 'hidden')}\r\n            disabled={!createNewSegment}\r\n            id=\"logical-contour-operations-create-new-segment-input\"\r\n            type=\"text\"\r\n            placeholder=\"New segment name\"\r\n            value={newSegmentName}\r\n            onChange={e => setNewSegmentName(e.target.value)}\r\n          />\r\n        </div>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default LogicalContourOperationOptions;\r\n","import React, { useState } from 'react';\r\nimport { Button, Input, Label, Separator } from '@ohif/ui-next';\r\nimport { useRunCommand } from '@ohif/core';\r\n\r\nfunction SimplifyContourOptions() {\r\n  const [areaThreshold, setAreaThreshold] = useState(10);\r\n\r\n  const runCommand = useRunCommand();\r\n\r\n  return (\r\n    <div className=\"flex w-auto w-[252px] flex-col gap-[8px] text-base font-normal leading-none\">\r\n      <div className=\"flex w-auto flex-col gap-[10px] text-base font-normal leading-none\">\r\n        <div>Fill contour holes</div>\r\n        <Button\r\n          className=\"border-primary/60 border\"\r\n          variant=\"ghost\"\r\n          onClick={() => {\r\n            runCommand('removeContourHoles');\r\n          }}\r\n        >\r\n          Fill Holes\r\n        </Button>\r\n        <Separator className=\"bg-input mt-[20px] h-[1px]\" />\r\n      </div>\r\n      <div className=\"flex w-auto flex-col gap-[10px] text-base font-normal leading-none\">\r\n        <div>Remove Small Contours</div>\r\n        <div className=\"flex items-center gap-2 self-end\">\r\n          <Label\r\n            htmlFor=\"simplify-contour-options\"\r\n            className=\"text-muted-foreground\"\r\n          >\r\n            Area Threshold\r\n          </Label>\r\n          <Input\r\n            id=\"simplify-contour-options\"\r\n            className=\"w-20\"\r\n            type=\"number\"\r\n            value={areaThreshold}\r\n            onChange={e => setAreaThreshold(Number(e.target.value))}\r\n          />\r\n        </div>\r\n        <Button\r\n          className=\"border-primary/60 border\"\r\n          variant=\"ghost\"\r\n          onClick={() => {\r\n            runCommand('removeSmallContours', {\r\n              areaThreshold,\r\n            });\r\n          }}\r\n        >\r\n          Remove Small Contours\r\n        </Button>\r\n        <Separator className=\"bg-input mt-[20px] h-[1px]\" />\r\n      </div>\r\n      <div className=\"flex w-auto flex-col gap-[10px] text-base font-normal leading-none\">\r\n        <div>Create New Segment from Holes</div>\r\n        <Button\r\n          className=\"border-primary/60 border\"\r\n          variant=\"ghost\"\r\n          onClick={() => {\r\n            runCommand('convertContourHoles');\r\n          }}\r\n        >\r\n          Create New Segment\r\n        </Button>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default SimplifyContourOptions;\r\n","import React from 'react';\r\nimport { Button, Separator } from '@ohif/ui-next';\r\nimport { useRunCommand } from '@ohif/core';\r\n\r\nfunction SmoothContoursOptions() {\r\n  const runCommand = useRunCommand();\r\n\r\n  return (\r\n    <div className=\"flex w-auto w-[245px] flex-col gap-[8px] text-base font-normal leading-none\">\r\n      <div className=\"flex w-auto flex-col gap-[10px] text-base font-normal leading-none\">\r\n        <div>Smooth all edges</div>\r\n        <Button\r\n          className=\"border-primary/60 border\"\r\n          variant=\"ghost\"\r\n          onClick={() => {\r\n            runCommand('smoothContours');\r\n          }}\r\n        >\r\n          Smooth Edges\r\n        </Button>\r\n        <Separator className=\"bg-input mt-[20px] h-[1px]\" />\r\n      </div>\r\n      <div className=\"flex w-auto flex-col gap-[10px] text-base font-normal leading-none\">\r\n        <div>Remove extra points</div>\r\n        <Button\r\n          className=\"border-primary/60 border\"\r\n          variant=\"ghost\"\r\n          onClick={() => {\r\n            runCommand('decimateContours');\r\n          }}\r\n        >\r\n          Remove Points\r\n        </Button>\r\n      </div>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default SmoothContoursOptions;\r\n","import { id } from './id';\r\nimport React from 'react';\r\n\r\nimport getSopClassHandlerModule from './getSopClassHandlerModule';\r\nimport getHangingProtocolModule from './getHangingProtocolModule';\r\nimport getCommandsModule from './commandsModule';\r\nimport { getToolbarModule } from './getToolbarModule';\r\n\r\nconst Component = React.lazy(() => {\r\n  return import(/* webpackPrefetch: true */ './viewports/OHIFCornerstoneSEGViewport');\r\n});\r\n\r\nconst OHIFCornerstoneSEGViewport = props => {\r\n  return (\r\n    <React.Suspense fallback={<div>Loading...</div>}>\r\n      <Component {...props} />\r\n    </React.Suspense>\r\n  );\r\n};\r\n\r\n/**\r\n * You can remove any of the following modules if you don't need them.\r\n */\r\nconst extension = {\r\n  /**\r\n   * Only required property. Should be a unique value across all extensions.\r\n   * You ID can be anything you want, but it should be unique.\r\n   */\r\n  id,\r\n  getCommandsModule,\r\n  getToolbarModule,\r\n  getViewportModule({ servicesManager, extensionManager, commandsManager }) {\r\n    const ExtendedOHIFCornerstoneSEGViewport = props => {\r\n      return (\r\n        <OHIFCornerstoneSEGViewport\r\n          servicesManager={servicesManager}\r\n          extensionManager={extensionManager}\r\n          commandsManager={commandsManager}\r\n          {...props}\r\n        />\r\n      );\r\n    };\r\n\r\n    return [{ name: 'dicom-seg', component: ExtendedOHIFCornerstoneSEGViewport }];\r\n  },\r\n  /**\r\n   * SopClassHandlerModule should provide a list of sop class handlers that will be\r\n   * available in OHIF for Modes to consume and use to create displaySets from Series.\r\n   * Each sop class handler is defined by a { name, sopClassUids, getDisplaySetsFromSeries}.\r\n   * Examples include the default sop class handler provided by the default extension\r\n   */\r\n  getSopClassHandlerModule,\r\n  getHangingProtocolModule,\r\n};\r\n\r\nexport default extension;\r\n","import { utilities as cstUtils } from '@cornerstonejs/tools';\r\nimport { useUIStateStore } from '@ohif/extension-default';\r\n\r\nimport LogicalContourOperationsOptions from './components/LogicalContourOperationsOptions';\r\nimport SimplifyContourOptions from './components/SimplifyContourOptions';\r\nimport SmoothContoursOptions from './components/SmoothContoursOptions';\r\n\r\nexport function getToolbarModule({ servicesManager }: withAppTypes) {\r\n  const { segmentationService, toolbarService, toolGroupService } = servicesManager.services;\r\n  return [\r\n    {\r\n      name: 'cornerstone.SimplifyContourOptions',\r\n      defaultComponent: SimplifyContourOptions,\r\n    },\r\n    {\r\n      name: 'cornerstone.LogicalContourOperationsOptions',\r\n      defaultComponent: LogicalContourOperationsOptions,\r\n    },\r\n    {\r\n      name: 'cornerstone.SmoothContoursOptions',\r\n      defaultComponent: SmoothContoursOptions,\r\n    },\r\n    {\r\n      name: 'cornerstone.isActiveSegmentationUtility',\r\n      evaluate: ({ button }) => {\r\n        const { uiState } = useUIStateStore.getState();\r\n        return {\r\n          isActive: uiState[`activeSegmentationUtility`] === button.id,\r\n        };\r\n      },\r\n    },\r\n    {\r\n      name: 'evaluate.cornerstone.hasSegmentation',\r\n      evaluate: ({ viewportId }) => {\r\n        const segmentations = segmentationService.getSegmentationRepresentations(viewportId);\r\n        return {\r\n          disabled: !segmentations?.length,\r\n        };\r\n      },\r\n    },\r\n    {\r\n      name: 'evaluate.cornerstone.hasSegmentationOfType',\r\n      evaluate: ({ viewportId, segmentationRepresentationType }) => {\r\n        const segmentations = segmentationService.getSegmentationRepresentations(viewportId);\r\n\r\n        if (!segmentations?.length) {\r\n          return {\r\n            disabled: true,\r\n            disabledText: 'No segmentations available',\r\n          };\r\n        }\r\n\r\n        if (\r\n          !segmentations.some(segmentation =>\r\n            Boolean(segmentation.type === segmentationRepresentationType)\r\n          )\r\n        ) {\r\n          return {\r\n            disabled: true,\r\n            disabledText: `No ${segmentationRepresentationType} segmentations available`,\r\n          };\r\n        }\r\n      },\r\n    },\r\n    {\r\n      name: 'evaluate.cornerstone.segmentation',\r\n      evaluate: ({ viewportId, button, toolNames, disabledText }) => {\r\n        // Todo: we need to pass in the button section Id since we are kind of\r\n        // forcing the button to have black background since initially\r\n        // it is designed for the toolbox not the toolbar on top\r\n        // we should then branch the buttonSectionId to have different styles\r\n        const segmentations = segmentationService.getSegmentationRepresentations(viewportId);\r\n        if (!segmentations?.length) {\r\n          return {\r\n            disabled: true,\r\n            disabledText: disabledText ?? 'No segmentations available',\r\n          };\r\n        }\r\n\r\n        const activeSegmentation = segmentationService.getActiveSegmentation(viewportId);\r\n        if (!Object.keys(activeSegmentation.segments).length) {\r\n          return {\r\n            disabled: true,\r\n            disabledText: 'Add segment to enable this tool',\r\n          };\r\n        }\r\n\r\n        const toolGroup = toolGroupService.getToolGroupForViewport(viewportId);\r\n\r\n        if (!toolGroup) {\r\n          return {\r\n            disabled: true,\r\n            disabledText: disabledText ?? 'Not available on the current viewport',\r\n          };\r\n        }\r\n\r\n        if (!toolNames) {\r\n          return {\r\n            disabled: false,\r\n            // isActive: false,\r\n          };\r\n        }\r\n\r\n        const toolName = toolbarService.getToolNameForButton(button);\r\n\r\n        if (!toolGroup.hasTool(toolName) && !toolNames) {\r\n          return {\r\n            disabled: true,\r\n            disabledText: disabledText ?? 'Not available on the current viewport',\r\n          };\r\n        }\r\n\r\n        const isPrimaryActive = toolNames\r\n          ? toolNames.includes(toolGroup.getActivePrimaryMouseButtonTool())\r\n          : toolGroup.getActivePrimaryMouseButtonTool() === toolName;\r\n\r\n        return {\r\n          disabled: false,\r\n          isActive: isPrimaryActive,\r\n        };\r\n      },\r\n    },\r\n    {\r\n      name: 'evaluate.cornerstone.segmentation.synchronizeDrawingRadius',\r\n      evaluate: ({ button, radiusOptionId }) => {\r\n        const toolGroupIds = toolGroupService.getToolGroupIds();\r\n        if (!toolGroupIds?.length) {\r\n          return;\r\n        }\r\n\r\n        for (const toolGroupId of toolGroupIds) {\r\n          const brushSize = cstUtils.segmentation.getBrushSizeForToolGroup(toolGroupId);\r\n\r\n          if (brushSize) {\r\n            const option = toolbarService.getOptionById(button, radiusOptionId);\r\n            option.value = brushSize;\r\n          }\r\n        }\r\n      },\r\n    },\r\n  ];\r\n}\r\n"],"names":["id","packageJson","SOPClassHandlerId","sopClassUids","loadPromises","_getDisplaySetsFromSeries","instances","servicesManager","extensionManager","utils","sortStudyInstances","instance","length","StudyInstanceUID","SeriesInstanceUID","SOPInstanceUID","SeriesDescription","SeriesNumber","SeriesDate","StructureSetDate","SOPClassUID","wadoRoot","wadoUri","wadoUriRoot","imageId","predecessorImageId","displaySet","Modality","loading","isReconstructable","displaySetInstanceUID","guid","referencedImages","referencedSeriesInstanceUID","referencedDisplaySetInstanceUID","isDerivedDisplaySet","isLoaded","isHydrated","segments","isOverlayDisplaySet","label","i18n","t","referencedSeriesSequence","ReferencedSeriesSequence","console","error","referencedSeries","ReferencedInstanceSequence","displaySetService","services","referencedDisplaySets","getDisplaySetsForReferences","warn","referencedDisplaySet","unsubscribe","subscribe","EVENTS","DISPLAY_SETS_ADDED","displaySetsAdded","addedDisplaySet","load","async","headers","segDisplaySet","segmentationService","cstSegmentation","_segmentationExists","Promise","resolve","reject","Object","keys","utilityModule","getModuleEntry","uiNotificationService","dicomLoaderService","exports","arrayBuffer","findDicomDataPromise","getDisplaySetByUID","Error","imageIds","images","map","image","tolerance","eventTarget","addEventListener","Enums","SEGMENTATION_LOAD_PROGRESS","evt","percentComplete","detail","_broadcastEvent","SEGMENT_LOADING_COMPLETE","results","adaptersSEG","Cornerstone3D","Segmentation","createFromDICOMSegBuffer","metadataProvider","metaData","usedRecommendedDisplayCIELabValue","segMetadata","data","forEach","i","cielab","rgba","RecommendedDisplayCIELabValue","dcmjs","Colors","dicomlab2RGB","x","Math","round","CONSTANTS","show","title","message","type","duration","assign","_loadSegments","e","createSegmentationForSEGDisplaySet","then","catch","_load","params","name","getDisplaySetsFromSeries","segProtocol","protocolMatchingRules","toolGroupIds","numberOfPriorsReferenced","defaultViewport","viewportOptions","viewportType","toolGroupId","allowUnmatchedView","syncGroups","source","target","displaySets","matchedDisplaySetsIndex","displaySetSelectors","segDisplaySetId","seriesMatchingRules","attribute","constraint","equals","stages","viewportStructure","layoutType","properties","rows","columns","viewports","protocol","generateSegmentation","RTSS","generateRTSSFromRepresentation","adaptersRT","downloadDICOMData","helpers","commandsModule","viewportGridService","actions","loadSegmentationsForViewport","segmentations","viewportId","viewport","getTargetViewport","activeViewportId","getState","targetViewportId","get","displaySetInstanceUIDs","segmentation","segmentationId","config","createLabelmapForDisplaySet","addOrUpdateSegmentation","addSegmentationRepresentation","options","cornerstoneToolsSegmentation","representationData","Labelmap","segImages","cache","getImage","referencedImageId","labelmaps2D","z","segImage","segmentsOnLabelmap","Set","pixelData","getPixelData","segment","add","Array","from","allSegmentsOnLabelmap","labelmap","labelmap3D","flat","metadata","segmentationInOHIF","getSegmentation","representations","getRepresentationsForSegmentation","entries","segmentIndex","firstRepresentation","color","getSegmentColor","rgb2DICOMLAB","slice","value","segmentMetadata","SegmentNumber","toString","SegmentLabel","SegmentAlgorithmType","algorithmType","SegmentAlgorithmName","algorithmName","SegmentedPropertyCategoryCodeSequence","CodeValue","CodingSchemeDesignator","CodeMeaning","SegmentedPropertyTypeCodeSequence","downloadSegmentation","generatedSegmentation","dataset","storeSegmentation","dataSource","modality","defaultDataSource","getActiveDataSource","reportName","dataSourceName","selectedDataSource","series","priorSeriesNumber","action","createReportDialogPrompt","PROMPT_RESPONSES","CREATE_REPORT","selectedDataSourceConfig","getDataSources","args","undefined","generatedDataAsync","generateContour","generatedData","naturalizedReport","StudyID","store","dicom","getConfig","DicomMetadataStore","addInstances","debug","Number","downloadRTSS","InstanceNumber","instanceNumber","seriesUID","toggleActiveSegmentationUtility","itemId","buttonId","uiState","setUIState","useUIStateStore","isButtonActive","log","definitions","defaultContext","LogicalOperation","contourSegmentation","logicalOperation","Union","icon","helperIcon","Intersect","Subtract","SegmentSelector","onValueChange","placeholder","React","className","Select","key","SelectTrigger","SelectValue","SelectContent","SelectItem","useSystem","segmentationsWithRepresentations","useActiveViewportSegmentationRepresentations","activeRepresentation","find","representation","active","values","nextSegmentIndex","getNextAvailableSegmentIndex","activeSegment","activeSegmentIndex","operation","setOperation","useState","segmentA","setSegmentA","segmentB","setSegmentB","createNewSegment","setCreateNewSegment","newSegmentName","setNewSegmentName","useEffect","runCommand","useRunCommand","applyLogicalContourOperation","useCallback","resultSegmentIndex","segmentAInfo","parseInt","segmentBInfo","resultSegmentInfo","Tabs","TabsList","option","TabsTrigger","onClick","Icons","ByName","Button","variant","Separator","Switch","onCheckedChange","Label","htmlFor","Input","cn","disabled","onChange","areaThreshold","setAreaThreshold","Component","OHIFCornerstoneSEGViewport","props","fallback","getCommandsModule","getToolbarModule","toolbarService","toolGroupService","defaultComponent","SimplifyContourOptions","LogicalContourOperationsOptions","SmoothContoursOptions","evaluate","button","isActive","getSegmentationRepresentations","segmentationRepresentationType","some","Boolean","disabledText","toolNames","activeSegmentation","getActiveSegmentation","toolGroup","getToolGroupForViewport","toolName","getToolNameForButton","hasTool","includes","getActivePrimaryMouseButtonTool","radiusOptionId","getToolGroupIds","brushSize","cstUtils","getOptionById","getViewportModule","commandsManager","component","_extends","getSopClassHandlerModule","getHangingProtocolModule"],"sourceRoot":""}