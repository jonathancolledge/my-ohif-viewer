{"version":3,"file":"5400.bundle.51f37ded1d4389a79947.js","mappings":"4IAEA,MAAMA,EAAmB,mBAwBzB,SAASC,EAAWC,EAAYC,GAC5B,GAAKC,EAAA,GAAMC,aAAaH,GAGxB,OAAIE,EAAA,GAAMC,aAAaH,GAAYC,GACxBC,EAAA,GAAMC,aAAaH,GAAYC,GAAUG,YADpD,CAGJ,CACA,SAASC,EAAWC,EAAiBN,EAAYO,EAASN,GACtD,IAAKC,EAAA,GAAMC,aAAaH,GACpB,OAAO,KAEXE,EAAA,GAAMC,aAAaH,GAAYC,GAAY,CACvCO,SAAS,EACTJ,OAAQG,GAEZD,EAAgBG,YAAYF,EAChC,CACA,SAASG,EAAeV,EAAYC,GAC3BC,EAAA,GAAMC,aAAaH,IAGpBE,EAAA,GAAMC,aAAaH,GAAYC,KAC/BC,EAAA,GAAMC,aAAaH,GAAYC,GAAUO,SAAU,EAE3D,CACA,SAASG,EAAeL,EAAiBN,GAChCE,EAAA,GAAMC,aAAaH,IAGxBY,OAAOC,KAAKX,EAAA,GAAMC,aAAaH,IAAac,QAASb,IACjD,MAAMc,EAAab,EAAA,GAAMC,aAAaH,GAAYC,IAC7Cc,EAAWP,SAAWO,EAAWX,SAClCE,EAAgBU,YAAYD,EAAWX,eAChCF,EAAA,GAAMC,aAAaH,GAAYC,KAGlD,CACA,QA7DA,SAA6BgB,GACzB,MAAMC,GAAiB,IAAAC,mBAAkBF,IACnC,WAAEG,EAAU,kBAAEC,GAAsBH,EACpClB,EAAa,GAAGoB,KAAcC,IAC9Bf,EAaV,SAAsBW,GAClB,MAAMK,EAAkB,IAAIxB,IACtByB,EAAqBN,EAAQO,cAAcF,GAC3CG,EAAWF,GAAoBC,cAAc,uBACnD,OAAOC,CACX,CAlB4BC,CAAaT,GAIrC,OAHAL,OAAOC,KAAKX,EAAA,GAAMC,aAAaH,IAAac,QAASb,IACjDC,EAAA,GAAMC,aAAaH,GAAYC,GAAUO,SAAU,IAEhD,CACHF,gBAAiBA,EACjBqB,sBAAuBzB,EAAA,GAAMC,aAC7BJ,WAAYA,EAAW6B,KAAKC,KAAM7B,GAClCK,WAAYA,EAAWuB,KAAKC,KAAMvB,EAAiBN,GACnDU,eAAgBA,EAAekB,KAAKC,KAAM7B,GAC1CW,eAAgBA,EAAeiB,KAAKC,KAAMvB,EAAiBN,GAEnE,ECbA,QALA,SAAciB,EAASa,GACnB,MAAMC,EAAmB,EAAoBd,GAC7Ca,EAAGC,GACHA,EAAiBpB,gBACrB,C,wECoCA,QAtCA,SAAoBoB,EAAkBC,EAAeC,EAAWC,EAAQC,EAAQC,EAAU,CAAC,EAAGC,EAAS,IACnG,MAAM,MAAEC,EAAK,KAAEC,EAAI,MAAEC,EAAK,UAAEC,EAAS,SAAEC,EAAQ,YAAEC,EAAW,cAAEC,GAAmBhC,OAAOiC,OAAO,CAC3FP,MAAO,iBACPC,KAAM,cACNC,MAAO,IACPE,cAAUI,EACVL,eAAWK,EACXF,cAAe,EACfD,YAAa,GACdP,GACGW,EAAcN,GAAaD,EAE3BQ,GAAc,OAAShB,EAAe,SAAUC,GAChDgB,EAAwBlB,EAAiBhC,WAAWiD,GACpDE,EAAa,CACfC,GAAI,GAAGjB,EAAO,KACdkB,GAAI,GAAGlB,EAAO,KACdmB,EAAG,GAAGlB,IACNmB,OAAQhB,EACRC,OACA,eAAgBQ,EAChB,mBAAoBL,EACpB,eAAgBC,EAChB,iBAAkBC,GAEtB,GAAIK,GACA,OAAyBC,EAAYD,GACrClB,EAAiBrB,eAAesC,OAE/B,CACD,MAAMO,EAAmBC,SAASC,gBAnBxB,6BAmB+C,UAC1C,KAAXpB,GACAkB,EAAiBG,aAAa,UAAWrB,IAE7C,OAAwBa,EAAYK,GACpCxB,EAAiB1B,WAAWkD,EAAkBP,EAClD,CACJ,C,kDClCA,QALA,SAAqBjB,EAAkBC,EAAe2B,EAAgBC,EAAcxB,EAAU,CAAC,GAC3FwB,EAAa9C,QAAQ,CAAC+C,EAAQC,MAC1B,OAAW/B,EAAkBC,EAAe2B,EAAgBE,EAAQzB,EAAS0B,IAErF,C,uECoBA,QAvBA,SAAkB/B,EAAkBC,EAAe+B,EAASC,EAAwBC,EAAUC,EAAa9B,EAAU,CAAC,GAClH,MAAM+B,EAAQH,EAAuBI,OAAS,GACxC,EAAAC,EAAA,GAAiBL,EAAwBC,GACzCA,EACAK,EASV,SAA4BJ,GACxB,MAAQK,EAAGC,EAAMC,EAAGC,EAAG,OAAEC,EAAM,MAAEnC,GAAU0B,EACrCU,EAAYpC,EAAQ,EACpBqC,EAAaF,EAAS,EAK5B,MAAO,CAJW,CAACH,EAAOI,EAAWF,GAClB,CAACF,EAAME,EAAMG,GACX,CAACL,EAAOI,EAAWF,EAAMC,GAC1B,CAACH,EAAOhC,EAAOkC,EAAMG,GAE7C,CAlB8BC,CAAmBZ,GACvCa,GAAM,EAAAV,EAAA,GAAiBC,EAAmBH,GAC1Ca,EAAgBpE,OAAOiC,OAAO,CAChCP,MAAO,mBACPG,UAAW,IACXC,SAAU,OACXN,IACH,EAAA6C,EAAA,GAASlD,EAAkBC,EAAe,QAAQ+B,IAAWI,EAAOY,EAAKC,EAC7E,ECAA,QAZA,SAA2BjD,EAAkBC,EAAekD,EAAYC,EAAWC,EAAiBpB,EAAwBqB,EAASjD,EAAU,CAAC,GAC5I,MAAM4C,EAAgBpE,OAAOiC,OAAO,CAChCyC,aAAc,IACdC,UAAW,CACPhB,GAAG,EACHE,GAAG,IAERrC,GACGoD,GAAoB,EAAAC,EAAA,GAAY1D,EAAkBC,EAAekD,EAAYC,EAAWC,EAAiBJ,GAE/G,OADA,EAASjD,EAAkBC,EAAekD,EAAYlB,EAAwBoB,EAAiBI,EAAmBR,GAC3GQ,CACX,C,2DCXe,SAASE,EAAS3D,EAAkBC,EAAe2D,EAAcxB,EAAOY,EAAK3C,EAAU,CAAC,EAAGC,EAAS,IAC/G,MAAMuD,EAAU,CAACzB,EAAM,GAAIA,EAAM,IAC3B0B,EAAW,CAACd,EAAI,GAAIZ,EAAM,IAC1B2B,EAAa,CAAC3B,EAAM,GAAIY,EAAI,IAC5BgB,EAAc,CAAChB,EAAI,GAAIA,EAAI,KACjC,OAAsBhD,EAAkBC,EAAe2D,EAAc,CAACC,EAASC,EAAUC,EAAYC,GAAc3D,EAASC,EAChI,C,mFCqNA,MAAM2D,EAAoB,IAzN1B,MACI,WAAAC,GACIpE,KAAKqE,OAAS,CACVC,OAAQ,CAAC,EACTC,cAAe,CAAC,EAChBC,eAAgB,CAAC,EAEzB,CACA,QAAAC,CAASC,EAAWC,GAChB,MAAM,WAAEpF,EAAU,eAAEqF,EAAc,KAAEC,EAAI,aAAEC,GAAiBJ,EACrDK,EAAgB/E,KAAKgF,SAASN,GACpC,IAAIO,EAaJ,GALIA,EAPC1F,GAAeqF,EAOA5E,KAAKkF,kCAAkC,IAChDH,KACAJ,GACJE,GATa,IACTE,KACAJ,IASNE,EACD,MAAM,IAAIM,MAAM,mCAEpB,GAAI5F,EAAY,CACPS,KAAKqE,OAAOG,eAAejF,KAC5BS,KAAKqE,OAAOG,eAAejF,GAAc,CACrC6F,6BAA6B,EAC7BC,gBAAiB,CAAC,IAG1B,MAAMA,EAAkBrF,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAC/D,GAAIT,EAAgB,CACXS,EAAgBT,KACjBS,EAAgBT,GAAkB,CAAC,GAElCS,EAAgBT,GAAgBC,KACjCQ,EAAgBT,GAAgBC,GAAQ,CAAC,GAE7C,MAAMS,EAAYD,EAAgBT,GAAgBC,QAC7B5D,IAAjB6D,GACKQ,EAAUC,aACXD,EAAUC,WAAa,CAAC,GAE5BD,EAAUC,WAAWT,GAAgBG,GAGrCK,EAAUE,YAAcP,CAEhC,KACK,CACD,MAAMQ,EAAwB,uBACzBJ,EAAgBI,KACjBJ,EAAgBI,GAAyB,CAAC,GAEzCJ,EAAgBI,GAAuBZ,KACxCQ,EAAgBI,GAAuBZ,GAAQ,CAAC,GAEpDQ,EAAgBI,GAAuBZ,GAAMW,YACzCP,CACR,CACJ,MACK,GAAIL,EAAgB,CAChB5E,KAAKqE,OAAOE,cAAcK,KAC3B5E,KAAKqE,OAAOE,cAAcK,GAAkB,CAAC,GAE5C5E,KAAKqE,OAAOE,cAAcK,GAAgBC,KAC3C7E,KAAKqE,OAAOE,cAAcK,GAAgBC,GAAQ,CAAC,GAEvD,MAAMa,EAAY1F,KAAKqE,OAAOE,cAAcK,GAAgBC,QACvC5D,IAAjB6D,GACKY,EAAUH,aACXG,EAAUH,WAAa,CAAC,GAE5BG,EAAUH,WAAWT,GAAgBG,GAGrCS,EAAUF,YAAcP,CAEhC,MAEIjF,KAAKqE,OAAOC,OAAOO,GAAQI,CAEnC,CACA,iCAAAC,CAAkCP,EAAQE,GACtC,MAAMc,EAAkB,IAAKhB,GAC7B,GAAIE,IAAS,8BAAkCe,SAAU,CACrD,MAAMC,EAAiBF,EACvBE,EAAeC,wBAA0BD,EAAeE,cACxDF,EAAeG,uBAAyBH,EAAeI,aACvDJ,EAAeK,qBAAuBL,EAAeM,WACrDN,EAAeO,oBAAsBP,EAAeQ,UACpDR,EAAeS,yBAA2BT,EAAeU,cAC7D,MACK,GAAI1B,IAAS,8BAAkC2B,QAAS,CACzD,MAAMC,EAAgBd,EACtBc,EAAcT,uBAAyBS,EAAcR,aACrDQ,EAAcH,yBAA2BG,EAAcF,eACvDE,EAAcC,sBAAwBD,EAAcE,YACpDF,EAAcX,wBAA0BW,EAAcV,cACtDU,EAAcP,qBAAuBO,EAAcN,WACnDM,EAAcL,oBAAsBK,EAAcJ,SACtD,CACA,OAAOV,CACX,CACA,QAAAX,CAASN,GACL,MAAM,WAAEnF,EAAU,eAAEqF,EAAc,KAAEC,EAAI,aAAEC,GAAiBJ,EAC3D,IAAIkC,EAAgB5G,KAAK6G,gBAAgBhC,GACrCO,GAA8B,EAoBlC,GAnBIpF,KAAKqE,OAAOC,OAAOO,KACnB+B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOC,OAAOO,KAG1B7E,KAAKqE,OAAOE,cAAcK,KAAkBC,KAC5C+B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOE,cAAcK,GAAgBC,GAAMW,kBAElCvE,IAAjB6D,GACA9E,KAAKqE,OAAOE,cAAcK,GAAgBC,GAAMU,aAAaT,KAC7D8B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOE,cAAcK,GAAgBC,GAAMU,WAAWT,MAItEvF,GAAcS,KAAKqE,OAAOG,eAAejF,GAAa,CACtD6F,EACIpF,KAAKqE,OAAOG,eAAejF,GAAY6F,4BAC3C,MAAM0B,EAAsB,uBACxB9G,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgByB,KAAuBjC,KAC9E+B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgByB,GAAqBjC,GAAMW,cAGzFZ,GACA5E,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgBT,KAAkBC,KACzE+B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgBT,GAAgBC,GAAMW,kBAE/DvE,IAAjB6D,GACA9E,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgBT,GAAgBC,GAAMU,aAAaT,KAC1F8B,EAAgB,IACTA,KACA5G,KAAKqE,OAAOG,eAAejF,GAAY8F,gBAAgBT,GAAgBC,GAAMU,WAAWT,KAI3G,CACA,OAAO8B,CACX,CACA,8BAAAG,CAA+BxH,GAC3B,OAAOS,KAAKqE,OAAOG,eAAejF,IAAa6F,2BACnD,CACA,8BAAA4B,CAA+BzH,EAAY6F,GAClCpF,KAAKqE,OAAOG,eAAejF,KAC5BS,KAAKqE,OAAOG,eAAejF,GAAc,CACrC6F,6BAA6B,EAC7BC,gBAAiB,CAAC,IAG1BrF,KAAKqE,OAAOG,eAAejF,GAAY6F,4BACnCA,CACR,CACA,eAAAyB,CAAgBhC,GACZ,OAAQA,GACJ,KAAK,8BAAkCe,SACnC,OAAO,SACX,KAAK,8BAAkCY,QACnC,OAAO,SACX,KAAK,8BAAkCS,QACnC,MAAO,CAAC,EACZ,QACI,MAAM,IAAI9B,MAAM,gCAAgCN,KAE5D,CACA,sBAAAqC,CAAuBtC,GACf5E,KAAKqE,OAAOE,cAAcK,WACnB5E,KAAKqE,OAAOE,cAAcK,EAEzC,CACA,0BAAAuC,GACInH,KAAKqE,OAAOE,cAAgB,CAAC,CACjC,CACA,kBAAA6C,CAAmB7H,GACXS,KAAKqE,OAAOG,eAAejF,WACpBS,KAAKqE,OAAOG,eAAejF,EAE1C,CACA,sBAAA8H,GACI,IAAK,MAAM9H,KAAcS,KAAKqE,OAAOG,eAAgB,CACjD,MACMY,EADgBpF,KAAKqE,OAAOG,eAAejF,GACC6F,4BAClDpF,KAAKqE,OAAOG,eAAejF,GAAc,CACrC6F,8BACAC,gBAAiB,CAAC,EAE1B,CACJ,CACA,kBAAAiC,GACItH,KAAKmH,6BACLnH,KAAKqH,wBACT,CACA,cAAAE,CAAe7C,GACX,MAAM,KAAEG,GAASH,EACX8C,EAAQxH,KAAKgF,SAASN,GACtB+C,EAAezH,KAAK6G,gBAAgBhC,GAC1C,OAAQ,EAAA6C,UAAA,UAAoBF,EAAOC,EACvC,E,wECxNG,SAASE,EAAgC/C,EAAgBgD,EAAqB9C,GACjF,MAAM+C,EAAc,CAChBjD,iBACAgD,sBACA9C,iBAEJ,QAAqBF,IACrB,IAAAkD,cAAa,EAAAC,YAAa,EAAAC,OAAOC,2BAA4BJ,EACjE,C,kDCVO,SAASK,EAAsB3I,GAElC,OADiC,KACD2I,sBAAsB3I,EAC1D,C,kDCHO,SAAS4I,EAAwC5I,EAAYmF,GAEhE,OADiC,KACDyD,wCAAwC5I,EAAYmF,EACxF,C,6DC2BA,QA7BA,UAAuC,eAAEE,EAAc,KAAEC,EAAI,KAAEuD,IAC3D,MAAMC,GAAe,OAAgBzD,GACrC,IAAKyD,EACD,MAAM,IAAIlD,MAAM,gBAAgBP,eAKpC,OAHIyD,EAAaC,mBAAmBzD,IAChC0D,QAAQC,KAAK,+BAA+B3D,qCAAwCD,sBAEhFC,GACJ,KAAK,IAA4Be,SAMjC,KAAK,IAA4BY,QAKjC,KAAK,IAA4BS,QACzBmB,IACAC,EAAaC,mBAAmBzD,GAAQuD,GAE5C,MACJ,QACI,MAAM,IAAIjD,MAAM,+BAA+BN,KAE3D,C,6DCbA,QAfA,SAAiCtF,EAAYC,GACpCA,IACDA,GAAoB,IAAAiJ,uBAAsBC,KAAMC,GAAOA,EAAGC,eAAeF,KAAMG,GAAOA,EAAGC,KAAOvJ,KAAcuJ,IAElH,MAAMC,EAAyB,KAAMC,WAAWC,OAAQC,GAAOA,EAAGC,cAAcC,KAAMP,GAAOA,EAAGrJ,oBAAsBA,KAChHqJ,EAAGtJ,YAAcsJ,EAAGtJ,aAAeA,KACzC,GAAKwJ,EAAuBxG,OAA5B,CAGA,GAAIwG,EAAuBxG,OAAS,EAChC,MAAM,IAAI4C,MAAM,qDAAqD3F,qBAAqCD,oFAG9G,OAAOwJ,EAAuB,EAL9B,CAMJ,C,wECbA,MAAMM,UAA8C,WACvCrJ,KAAKsJ,SAAW,uCAAyC,CAClE,WAAAlF,CAAYmF,GAORC,MANqB,EAAA9B,UAAA,UAAoB,CACrC+B,cAAe,CACXC,gBAAgB,EAChBC,mBAAmB,IAExBJ,GAEP,CACA,yBAAAK,GACI,OAAO,CACX,CACA,wBAAAC,CAAyBC,GACrB,MAAMC,EAAaD,EAAcC,YAC3B,YAAEC,GAAgBD,EAClBE,EAAeT,MAAMK,yBAAyBC,GACpD,GAAIE,EAAa,CACb,MAAM,eAAEpF,GAAmBmF,EAAW3B,KAAKC,cAC3C,IAAAV,iCAAgC/C,EACpC,CACA,OAAOqF,CACX,EAEJ,S,oTCFA,MAAM,sBAAEC,GAA0B,EAAAC,UAC5B,QAAEC,GAAY,EAAAC,UACdC,EAAqB,EAAIF,EAC/B,MAAMG,UAA8B,WACvBvK,KAAKsJ,SAAW,mBAAqB,CAC9C,WAAAlF,CAAYmF,EAAY,CAAC,EAAGiB,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrChB,cAAe,CACXiB,gBAAgB,EAChBC,QAAQ,EACRC,2BAA2B,EAC3BC,+BAAgC,EAAAC,iBAAiBC,MACjDC,+BAAgC,CAC5BC,SAAS,EACT3K,OAAQ,GAEZqJ,mBAAmB,EACnBuB,sBAAuB,GACvBC,iCAAkC,EAClCC,eAAe,EACfC,mBAAoB,EACpBC,UAAW,CACPC,aAAa,EACbC,cAAc,EACdC,0BAA2B,GAC3BC,2BAA4B,IAEhCC,cAAe,CACXV,SAAS,EACTW,wBAAyB,MAE7BC,SAAU,CACNZ,SAAS,EACTa,QAAS,IAEbC,6BAA6B,EAC7BrC,gBAAgB,EAChBsC,aAAcC,EACdC,gBAAiB,EAAAC,wBAGrB3C,MAAMD,EAAWiB,GACjBxK,KAAKoM,WAAY,EACjBpM,KAAKqM,iBAAkB,EACvBrM,KAAKsM,eAAgB,EACrBtM,KAAKuM,iBAAoBC,IACrB,MAAM3E,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,EACdkC,EAAa/J,KAAK0M,iBAAiBF,GACzCxM,KAAK2M,cAAc5C,EAAY3K,GAC/B,MAAMwN,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eAIzE,OAHA9M,KAAK+M,aAAaP,EAAKzC,EAAY6C,GACnCJ,EAAIQ,kBACJ,OAAsCJ,GAC/B7C,GAEX/J,KAAKiN,uBAAyB,CAACT,EAAKzC,EAAY/H,KAC5C,MAAM6F,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,EACd+E,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eACzE9M,KAAKkN,2BAA2BV,EAAKzC,EAAY6C,EAAqB5K,IAE1EhC,KAAKmN,qBAAuB,CAACX,EAAKzC,KAC9B,MAAMlC,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,EACd+E,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eACrE/C,EAAW3B,KAAKgF,QAAQC,OACxBrN,KAAKsN,0BAA0Bd,EAAKzC,EAAY6C,GAGhD5M,KAAKuN,wBAAwBf,EAAKzC,EAAY6C,GAElDJ,EAAIQ,kBAERhN,KAAKwN,gBAAkB,CAACpO,EAAS2K,EAAY0D,EAAcC,KACvD,MAAMrO,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,GACb8K,SAAUyD,GAAW7D,EAAW3B,KAAKgF,QAC7C,IAAIS,EAAgBF,EAASG,cAAcF,EAAO,IAClD,IAAK,IAAI3L,EAAI,EAAGA,EAAI2L,EAAOrL,OAAQN,IAAK,CACpC,MAAM8L,EAAKF,EACLG,EAAKL,EAASG,cAAcF,EAAO3L,IAEzC,GADmBiI,EAAsBuD,EAAcM,EAAIC,EAAIN,GAE3D,OAAO,EAEXG,EAAgBG,CACpB,CACA,IAAKjE,EAAW3B,KAAKgF,QAAQC,OACzB,OAAO,EAEX,MAAMY,EAASN,EAASG,cAAcF,EAAO,IACvCM,EAAOP,EAASG,cAAcF,EAAOA,EAAOrL,OAAS,IAC3D,OAAO2H,EAAsBuD,EAAcQ,EAAQC,EAAMR,IAE7D1N,KAAKmO,OAAU/O,IACX,MAAMgN,EAAYpM,KAAKoM,UACjBE,EAAgBtM,KAAKsM,cACrBD,EAAkBrM,KAAKqM,gBACzBD,EACApM,KAAKoO,cAAchP,GAEdkN,EACLtM,KAAKqO,sBAAsBjP,GAEtBiN,GACLrM,KAAKsO,wBAAwBlP,IAGrCY,KAAKuO,sBAAwB,CAACxE,EAAY4D,EAAUa,EAAiBnP,KACjE,MAAM,KAAE+I,GAAS2B,GACX,YAAE0E,GAAgBrG,GAChB+B,SAAUyD,EAAM,OAAEP,GAAWjF,EAAKgF,QACpCsB,EAAY3P,OAAOC,KAAKyP,GAC9B,IAAK,IAAIxM,EAAI,EAAGA,EAAIyM,EAAUnM,OAAQN,IAAK,CACvC,MAAM0M,EAAWD,EAAUzM,GACrB2M,EAAQ5O,KAAK6O,mBAAmBF,GACtC,IAAKC,EACD,SAEJ,MAAM,UAAEE,EAAS,SAAEC,GAAaH,EAC1BI,EAAoBpB,EAAOqB,IAAKC,GAAMvB,EAASG,cAAcoB,IAC7DC,EAAsB,CACxBC,aAAa,OAAoBzB,EAAUgB,GAC3CU,YAAarP,KAAKqP,YAAY1B,EAAUgB,EAAU5E,EAAWgF,SAASO,oBAEpEC,GAAe,OAAmBR,EAASS,SAAUzF,EAAWgF,SAASO,kBAAmBH,GAC5FM,GAAkB,QAAiCb,EAAO,KAC5D,MAAMzE,EAAW/B,EAAKgF,QAAQjD,SACxBuF,EAAYvF,EAAS5H,OACrBoN,EAAoB,IAAIC,MAAMF,GACpC,IAAK,IAAIzN,EAAI,EAAGA,EAAIyN,EAAWzN,IAC3B0N,EAAkB1N,GAAK0L,EAASG,cAAc3D,EAASlI,IAE3D,MAAQ4N,KAAMC,EAAYC,KAAMC,EAAYC,KAAMC,EAAYC,KAAMC,GAAgB,mBAAsBT,GACpGU,EAAiB1C,EAAS2C,cAAc,CAACJ,EAAYE,IACrDG,EAAiB,kCAA8BzB,EAAWuB,GAC1DG,EAAqB7C,EAAS2C,cAAc,CAC9CR,EACAE,IAGJ,MAAO,CAACO,EADmB,kCAA8BzB,EAAW0B,MAGlEC,EAAczB,EAAkB,GAChC0B,EAAqB/C,EAAS2C,cAAcG,GAC5CE,EAAchD,EAAS2C,cAAc,CACvCG,EAAY,GAAK,EACjBA,EAAY,KAEVG,EAAcjD,EAAS2C,cAAc,CACvCG,EAAY,GACZA,EAAY,GAAK,IAEfI,EAAW,cAAcH,EAAoBC,GAC7CG,EAAW,cAAcJ,EAAoBE,GAC/CvD,EACArN,KAAK+Q,wBAAwB,CACzBpC,WACAhB,WACAqB,oBACApB,SACAkB,YACAC,WACAN,cACAc,eACAE,kBACAoB,WACAC,aAIJ9Q,KAAKgR,sBAAsB,CACvBjC,WACAJ,WACAF,cACAc,eACAE,kBACA7B,UAGZ,CACA,MAAM5D,EAAcD,EAAWC,YAK/B,OAJAD,EAAWC,aAAc,EACrBA,IACA,IAAAiH,2BAA0BlH,EAAY1K,EAAesO,SAASvO,QAAS,EAAA8R,YAAYC,cAEhF1C,GAEXzO,KAAKoR,aAAe,CAACrH,EAAY4D,EAAUtO,EAAgBa,KACvD,MAAM,KAAEkI,GAAS2B,EACX4E,EAAW3O,KAAKqR,YAAY1D,GAC5B2D,EAAiB,CACnBC,YAAavR,KAAKuR,YAClBjI,SAAUtJ,KAAK8M,cACfvN,WAAYF,EAAesO,SAAS7E,GACpC3I,cAAe4J,EAAW5J,eAExBI,EAAUP,KAAKwR,sBAAsBF,EAAgBvH,GAC3D,IAAKxJ,EAAQkR,WACT,OAEJ,MAAMnO,EAAYtD,KAAKyJ,cAAcuC,aAAa5D,EAAMuG,GACxD,IAAKrL,GAAkC,IAArBA,EAAUf,OACxB,OAEJ,MAAMyM,EAAoB5G,EAAKgF,QAAQjD,SAAS8E,IAAKC,GAAMvB,EAASG,cAAcoB,IAClF,IAAK9G,EAAKsJ,QAAQlO,QAAQmO,SAAU,CAChC,MAAMC,GAAsB,IAAAC,wBAAuB7C,GACnD5G,EAAKsJ,QAAQlO,QAAQsO,cACjBnE,EAAS2C,cAAcsB,EAC/B,CACA,MAAMrO,EAAkBoK,EAASG,cAAc1F,EAAKsJ,QAAQlO,QAAQsO,eAE9DzP,GAAc,IAAA0P,mBAAkB7R,EAAkB6J,EAAW5J,eAAiB,GADjE,IACiFmD,EAAWC,EAAiByL,EAAmB,CAAC,EAAGzO,IAC/ImC,EAAGC,EAAMC,EAAGC,EAAG,MAAElC,EAAK,OAAEmC,GAAWT,EAC3C+F,EAAKsJ,QAAQlO,QAAQwO,iBAAmB,CACpCjO,QAAS4J,EAAS2C,cAAc,CAAC3N,EAAME,IACvCmB,SAAU2J,EAAS2C,cAAc,CAAC3N,EAAOhC,EAAOkC,IAChDoB,WAAY0J,EAAS2C,cAAc,CAAC3N,EAAME,EAAMC,IAChDoB,YAAayJ,EAAS2C,cAAc,CAAC3N,EAAOhC,EAAOkC,EAAMC,OAGjE,OAAiB9C,OACjB,OAAuBA,OACvB,OAA8BA,OAC9B,OAA4BA,OAC5B,OAA+BA,OAC/B,OAAsBA,MACtBA,KAAKiS,gCAAiC,OAASjS,KAAKuO,sBAAuB,IAAK,CAAE2D,UAAU,GAChG,CACA,uCAAAC,CAAwC/S,EAASgT,GAC7C,IAAKA,IAAgBA,EAAY7P,OAC7B,OAEJ,MAAM8P,EAA0B7I,MAAM2I,wCAAwC/S,EAASgT,GACvF,IAAKC,IAA4BA,EAAwB9P,OACrD,OAEJ,MAAMlD,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,EACrB,IAAIiT,EACJ,GAAI3E,aAAoB,EAAA4E,eAAgB,CACpC,MAAMC,EAAS7E,EAAS8E,aAClB,yBAAEC,GAA6B,iDAA6C/E,EAAU6E,GAC5FF,EAAuBtS,KAAK2S,6BAA6BN,EAAyBG,EAAQE,EAC9F,MAEIJ,GAAuB,IAAAM,6BAA4BjF,EAAUyE,GAEjE,OAAOE,CACX,CACA,4BAAAK,CAA6BP,EAAaI,EAAQE,GAC9C,MAAM,gBAAEG,GAAoBL,EACtBM,EAAiCV,EAAYnJ,OAAQ8J,IACvD,IAAIC,EAA4BD,EAAGhE,SAAS8D,gBAC5C,IAAKE,EAAGhE,SAASO,oBACZ0D,GACDD,EAAGhE,SAASkE,oBAAqB,CACjC,IAAK,MAAMC,KAASH,EAAG3K,KAAKgF,QAAQjD,SAAU,CAC1C,MAAMgJ,EAAS,SAAS,cAAeD,EAAOV,EAAOY,YAC/CC,EAAa,SAASF,EAAQX,EAAOK,iBAC3C,IAAK,oBAAgBQ,EAAY,GAC7B,OAAO,CAEf,CAGA,OAFAN,EAAGhE,SAAS8D,gBAAkBL,EAAOK,gBACrCE,EAAGhE,SAASuE,iBAAmBd,EAAOY,YAC/B,CACX,CACA,IAAKJ,EAA2B,CAC5B,MAAM,kBAAE1D,GAAsByD,EAAGhE,UAC3B,wBAAEwE,GAA4B,EAAAC,SAAA,IAAa,mBAAoBlE,GAC/DmE,EAAe,gBAAgBF,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IAC/GG,EAAe,gBAAgBH,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IACrHP,EAA4B,cAC5B,WAAWA,EAA2BS,EAAcC,GACpDX,EAAGhE,SAAS8D,gBAAkBG,CAClC,CACA,MAAMW,EAAaC,KAAKC,IAAI,SAAShB,EAAiBG,IAClD1I,EACJ,OAAO0I,GAA6BW,IAExC,IAAKb,EAA+BvQ,OAChC,MAAO,GAEX,MAAMuR,EAA+BpB,EAA2B,GAC1D,WAAEU,GAAeZ,EACjBuB,EAAyB,GAC/B,IAAK,MAAMhK,KAAc+I,EAAgC,CACrD,MACMI,EADOnJ,EAAW3B,KACLgF,QAAQjD,SAAS,GACpC,IAAKJ,EAAWiK,UACZ,SAEJ,MAAMC,EAAM,cACZ,SAASA,EAAKb,EAAYF,GAC1B,MAAMgB,EAAM,SAASD,EAAKpB,GACtBe,KAAKC,IAAIK,GAAOJ,GAChBC,EAAuBI,KAAKpK,EAEpC,CACA,OAAOgK,CACX,CACA,yBAAAnK,GACI,OAAO,CACX,CACA,gBAAA8C,CAAiBF,GACb,MAAM4H,EAAW5H,EAAIC,OAAO4H,cAAcC,MACpCC,EAAoB/K,MAAMkD,iBAAiBF,GAcjD,OAVmB,sBAAkB+H,EAAmB,CACpDnM,KAAM,CACFgF,QAAS,CACLjD,SAAU,CAAC,IAAIiK,KAEnBI,MAAO,GACP/F,YAAa,CAAC,GAElB7C,wBAX6B7B,IAC7BA,EAAW3B,KAAKsJ,QAAQ9D,OAAOrL,OAAS,IAahD,CACA,kBAAAkS,CAAmBC,GACf,OAAOlL,MAAMiL,mBAAmBC,EACpC,CACA,wBAAA7K,CAAyBC,GACrB,MAAM,eAAEzK,EAAc,SAAEsP,EAAQ,iBAAEzO,GAAqB4J,EACjDC,EAAaD,EAAcC,WACjC,IAAI4K,GAAe,EACnB,MAAM,SAAEhH,EAAQ,gBAAEa,GAAoBnP,EAChC+M,EAAYpM,KAAKoM,UACjBE,EAAgBtM,KAAKsM,cACrBD,EAAkBrM,KAAKqM,gBAC7B,GAAMD,GAAaE,GAAiBD,EAS/B,CACD,MAAMuI,EAAsB5U,KAAK6U,WAAW9K,WAAW5J,cACvD,GAAI4J,EAAW5J,gBAAkByU,EAC7B,GAAIxI,EACApM,KAAK8U,wBAAwBzV,EAAgBa,EAAkB6J,QAE9D,GAAIsC,EACLrM,KAAK+U,+BAA+B1V,EAAgBa,EAAkB6J,OAErE,KAAIuC,EAIL,MAAM,IAAInH,MAAM,WAAWnF,KAAK8M,4CAHhC9M,KAAKgV,6BAA6B3V,EAAgBa,EAAkB6J,EAIxE,MAGI/J,KAAKyJ,cAAcsC,6BACyB,IAA5ChC,EAAW3B,KAAKgF,QAAQjD,SAAS5H,OACjCvC,KAAKiV,6BAA6B5V,EAAgBa,EAAkB6J,GAGpE/J,KAAKkV,cAAc7V,EAAgBa,EAAkB6J,GAG7D4K,GAAe,CACnB,MAlCQ3U,KAAKyJ,cAAcsC,6BACyB,IAA5ChC,EAAW3B,KAAKgF,QAAQjD,SAAS5H,OACjCvC,KAAKiV,6BAA6B5V,EAAgBa,EAAkB6J,GAGpE/J,KAAKkV,cAAc7V,EAAgBa,EAAkB6J,GA8B7D,GAAK/J,KAAKyJ,cAAcC,eAOxB,OAJIK,EAAWC,aACXhK,KAAKmV,wBAAwBpL,EAAY4E,EAAUhB,EAAUa,EAAiBnP,GAElFW,KAAKoR,aAAarH,EAAY4D,EAAUtO,EAAgBa,GACjDyU,CACX,CACA,uBAAAQ,CAAwBpL,EAAY4E,EAAUhB,EAAUa,EAAiBnP,GACrE,MAAMuV,EAAsB5U,KAAK6U,YAAY9K,WAAW5J,cACxD,IAAI4J,EAAW5J,gBAAkByU,GAC5B5U,KAAK6U,YAAYO,iBAGjBpV,KAAK6U,YAAYO,cAAe,CACjC,MAAM,KAAEhN,GAAS2B,EACZ3B,EAAKqG,YAAYE,IAAW0G,KAYxBtL,EAAWC,aAChBhK,KAAKiS,+BAA+BlI,EAAY4D,EAAUa,EAAiBnP,IAZ3E+I,EAAKqG,YAAYE,GAAY,CACzBa,SAAU,KACV8F,KAAM,KACNC,IAAK,KACLC,KAAM,KACNC,OAAQ,KACRC,SAAU,KACVL,KAAM,MAEVrV,KAAKuO,sBAAsBxE,EAAY4D,EAAUa,EAAiBnP,GAK1E,CACJ,CACA,uBAAA0R,EAAwB,SAAEpD,EAAQ,OAAEC,EAAM,UAAEkB,EAAS,SAAEC,EAAQ,YAAEN,EAAW,SAAEE,EAAQ,aAAEY,EAAY,kBAAEP,EAAiB,gBAAES,EAAe,SAAEoB,EAAQ,SAAEC,IAChJ,MAAM,MAAE6E,EAAK,SAAED,EAAQ,KAAEL,GAAS5F,GAC5B,aAAEmG,GAAiBjI,EAASkI,eAC5BC,EAAgB,kCAA8BhH,EAAWlB,EAAO,IACtEkI,EAAc,GAAKlC,KAAKmC,MAAMD,EAAc,IAC5CA,EAAc,GAAKlC,KAAKmC,MAAMD,EAAc,IAC5CA,EAAc,GAAKlC,KAAKmC,MAAMD,EAAc,IAC5C,IAAIE,EAAOF,EAAc,GACrBG,EAAOH,EAAc,GACrBI,EAAOJ,EAAc,GACrBK,EAAOL,EAAc,GACrBM,EAAON,EAAc,GACrBO,EAAOP,EAAc,GACzB,IAAK,IAAIQ,EAAI,EAAGA,EAAI1I,EAAOrL,OAAQ+T,IAAK,CACpC,MAAMR,EAAgB,kCAA8BhH,EAAWlB,EAAO0I,IACtER,EAAc,GAAKlC,KAAKmC,MAAMD,EAAc,IAC5CA,EAAc,GAAKlC,KAAKmC,MAAMD,EAAc,IAC5CA,EAAc,GAAKlC,KAAKmC,MAAMD,EAAc,IAC5CE,EAAOpC,KAAK2C,IAAIP,EAAMF,EAAc,IACpCG,EAAOrC,KAAK2B,IAAIU,EAAMH,EAAc,IACpCI,EAAOtC,KAAK2C,IAAIL,EAAMJ,EAAc,IACpCK,EAAOvC,KAAK2B,IAAIY,EAAML,EAAc,IACpCM,EAAOxC,KAAK2C,IAAIH,EAAMN,EAAc,IACpCO,EAAOzC,KAAK2B,IAAIc,EAAMP,EAAc,GACxC,CACA,MAAMU,EAAiB,kCAA8B1H,EAAWlB,EAAO,IACvE4I,EAAe,GAAK5C,KAAKmC,MAAMS,EAAe,IAC9CA,EAAe,GAAK5C,KAAKmC,MAAMS,EAAe,IAC9CA,EAAe,GAAK5C,KAAKmC,MAAMS,EAAe,IAC9C,IAAIlB,EAAO,EAAAnL,SAAA,QAAiB6E,GAAqB2G,EAAQA,EACzDL,GAAQzE,EAAWC,EACnB,MAAM2F,GAAY,OAAmB7I,EAAQP,QAAUsI,EACjDe,EAAS,KAAQT,EAAOD,GACxBW,EAAS,KAAQR,EAAOD,GACxBU,EAAS,KAAQP,EAAOD,GAC9BJ,EAAOpC,KAAKmC,MAAMC,EAAOU,GACzBT,EAAOrC,KAAKiD,KAAKZ,EAAOS,GACxBR,EAAOtC,KAAKmC,MAAMG,EAAOS,GACzBR,EAAOvC,KAAKiD,KAAKV,EAAOQ,GACxBP,EAAOxC,KAAKmC,MAAMK,EAAOQ,GACzBP,EAAOzC,KAAKiD,KAAKR,EAAOO,GACxB,MAAME,EAAY,CACd,CAACd,EAAMC,GACP,CAACC,EAAMC,GACP,CAACC,EAAMC,IAELU,EAAcjI,EAAUkI,aAAa,CAACf,EAAME,EAAME,IAClDY,EAAetJ,EAASG,cAAciJ,GAC5C,IAGIG,EAHAC,EAAS,EACTC,EAAgB,GAChBC,EAAsB,EAEtBzB,IACAsB,EAAgBtB,EAAa3W,QAAQe,KAAKyJ,cAAcyC,gBAAgBoL,cAAe,CACnFxI,YACAyI,WAAY,CAACC,EAAUC,KACnB,IAAIC,GAAS,EACb,MAAMxE,EAAQvF,EAASG,cAAc0J,GAsBrC,OArBItE,EAAM,IAAMiE,IACZE,EAAsB,EACtBF,EAASjE,EAAM,GACfkE,GAAgB,IAAAO,wCAAuC3I,EAAmBkE,EAAO,CAAC+D,EAAa,GAAI/D,EAAM,KACzGkE,EAAcQ,KACH,SAAUC,EAAGC,GAChB,OAAOD,EAMZ,KANyBC,EAMzB,GALW,EACAD,EAIX,GAJsBC,EAItB,IAHgB,EACD,CACd,IAGJV,EAAc7U,QAAU2Q,EAAM,GAAKkE,EAAc,GAAG,KACpDA,EAAcW,QACdV,KAEAA,EAAsB,GAAM,IAC5BK,GAAS,GAENA,GAEXZ,YACAkB,aAAchY,KAAKyJ,cAAciB,kBAGzC,MAAMuN,EAAQjY,KAAKyJ,cAAcyC,gBAAgBgM,gBACjDzJ,EAAYE,GAAY,CACpBa,SAAUT,EAASS,SACnB8F,OACAmB,YACAjB,KAAMyC,EAAMzC,MAAM2C,MAClB5C,IAAK0C,EAAM1C,KAAK4C,MAChB5B,IAAK0B,EAAM1B,KAAK4B,MAChB1C,OAAQwC,EAAMxC,QAAQ0C,MACtBC,WAAYH,EAAMI,MAClBnB,cAAeA,EACfxB,WACAnG,eACA8F,OAER,CACA,qBAAArE,EAAsB,SAAErC,EAAQ,SAAEI,EAAQ,YAAEN,EAAW,aAAEc,EAAY,gBAAEE,EAAe,OAAE7B,IACpF,MAAM,MAAE+H,EAAK,KAAEN,GAAS5F,EAClBlN,GAAS,OAAmBqL,EAAQP,QAAUsI,EACpDlH,EAAYE,GAAY,CACpBa,SAAUT,EAASS,SACnBjN,SACAgN,eACA8F,OAER,EAEJ,SAASpJ,EAAoB7D,EAAMuG,GAC/B,MAAM2J,EAAoBlQ,EAAKqG,YAAYE,IACrC,KAAE2G,EAAI,KAAEE,EAAI,OAAEC,EAAM,OAAElT,EAAM,UAAEkU,EAAS,IAAElB,EAAG,IAAEgB,EAAG,YAAEgC,EAAW,KAAElD,EAAI,SAAEK,EAAQ,aAAEnG,GAAkB+I,GAAqB,CAAC,EACxHhV,EAAY,GAClB,GAAI,qBAAiBgS,GAAO,CACxB,MAAMkD,EAAWD,EACX,8BACA,SAAS,wBAAoBjD,MAASI,IAC5CpS,EAAU6Q,KAAKqE,EACnB,CAmBA,OAlBI,qBAAiBhD,IACjBlS,EAAU6Q,KAAK,SAAS,wBAAoBqB,MAASjG,KAErD,qBAAiBgG,IACjBjS,EAAU6Q,KAAK,QAAQ,wBAAoBoB,MAAQhG,KAEnD,qBAAiBgH,IACjBjT,EAAU6Q,KAAK,QAAQ,wBAAoBoC,MAAQhH,KAEnD,qBAAiBkG,IACjBnS,EAAU6Q,KAAK,YAAY,wBAAoBsB,MAAWlG,KAE1D,qBAAiBkH,IACjBnT,EAAU6Q,KAAK,cAAc,wBAAoBsC,MAAcpB,KAE/D,qBAAiB9S,IACjBe,EAAU6Q,KAAK,GAAG,wBAAoB5R,MAAW8S,KAE9C/R,CACX,CACA,S,uQCziBA,MAAM,sBAAEmV,GAA0B,YAClC,MAAMC,UAAyB,YAClB1Y,KAAKsJ,SAAW,cAAgB,CACzC,WAAAlF,CAAYmF,EAAY,CAAC,EAAGiB,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrChB,cAAe,CACXiB,gBAAgB,EAChBC,QAAQ,EACRC,2BAA2B,EAC3BlB,gBAAgB,EAChBsC,aAAcC,EACdC,gBAAiB,EAAAC,wBAGrB3C,MAAMD,EAAWiB,GACjBxK,KAAKuM,iBAAoBC,IACrB,MAAM3E,EAAc2E,EAAIC,QAClB,cAAE4H,EAAa,QAAEjV,GAAYyI,EAC7BuM,EAAWC,EAAcC,MACzBjV,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,EACrBW,KAAKoM,WAAY,EACjB,MAAMrC,EAAc/J,KAAgB,YAAE2Y,4BAA4BhL,EAAU,CACxEvF,KAAM,CACFsJ,QAAS,CACL9D,OAAQ,CACJ,IAAIwG,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAER5Q,QAAS,CACLmO,UAAU,EACVG,cAAe,CAAC,EAAG,EAAG,GACtBE,iBAAkB,CACdjO,QAAS,CAAC,EAAG,EAAG,GAChBC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnBC,YAAa,CAAC,EAAG,EAAG,MAIhCuK,YAAa,CAAC,MAGtB,QAAc1E,EAAY3K,GAC1B,MAAMwN,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eAazE,OAZA9M,KAAK4Y,SAAW,CACZ7O,aACA6C,sBACAiM,YAAa,EACbzD,eAAe,EACf0D,eAAe,EACfnH,UAAU,GAEd3R,KAAK+Y,cAAc3Z,IACnB,IAAA4Z,mBAAkB5Z,GAClBoN,EAAIQ,kBACJ,OAAsCJ,GAC/B7C,GAEX/J,KAAKwN,gBAAkB,CAACpO,EAAS2K,EAAY0D,EAAcC,KACvD,MAAMrO,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,GACf,KAAE+I,GAAS2B,GACX,OAAE6D,GAAWxF,EAAKsJ,QAClBuH,EAAetL,EAASG,cAAcF,EAAO,IAC7CsL,EAAevL,EAASG,cAAcF,EAAO,IAC7CuL,EAAOnZ,KAAKoZ,8BAA8B,CAC5CH,EACAC,IAEEhG,EAAQ,CAACzF,EAAa,GAAIA,EAAa,KACvC,KAAE9K,EAAI,IAAEE,EAAG,MAAElC,EAAK,OAAEmC,GAAWqW,EAErC,OADwB,kBAA0B,CAACxW,EAAME,EAAKlC,EAAOmC,GAASoQ,IACvDxF,GAK3B1N,KAAKmN,qBAAuB,CAACX,EAAKzC,KAC9B,MAAMlC,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,EACpBkC,EAAWsP,aAAc,EACzB,MAAMzM,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eACzE9M,KAAK4Y,SAAW,CACZ7O,aACA6C,sBACAwI,eAAe,GAEnBpV,KAAKsZ,gBAAgBla,IACrB,IAAA4Z,mBAAkB5Z,GAClB,MAAMC,GAAiB,IAAAC,mBAAkBF,IACnC,gBAAEoP,GAAoBnP,GAC5B,OAAsCuN,GACtCJ,EAAIQ,kBAERhN,KAAKiN,uBAAyB,CAACT,EAAKzC,EAAY/H,KAC5C,MAAM6F,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,GACd,KAAEO,GAAS2B,EACjBA,EAAWsP,aAAc,EACzB,IACIR,EADAzD,GAAgB,EAEhBpT,EAAO8P,cACPsD,GAAgB,EAGhByD,EAAczQ,EAAKsJ,QAAQ9D,OAAO2L,UAAWrK,GAAMA,IAAMlN,GAE7D,MAAM4K,GAAsB,IAAAC,gCAA+BzN,EAASY,KAAK8M,eACzE9M,KAAK4Y,SAAW,CACZ7O,aACA6C,sBACAiM,cACAzD,iBAEJpV,KAAKsZ,gBAAgBla,IACrB,IAAA4Z,mBAAkB5Z,GAClB,MAAMC,GAAiB,IAAAC,mBAAkBF,IACnC,gBAAEoP,GAAoBnP,GAC5B,OAAsCuN,GACtCJ,EAAIQ,kBAERhN,KAAKwZ,aAAgBhN,IACjB,MAAM3E,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,GACd,WAAEkC,EAAU,oBAAE6C,EAAmB,cAAEkM,EAAa,SAAEnH,GAAa3R,KAAK4Y,UACpE,KAAExQ,GAAS2B,EACb+O,IAAkBnH,IAGtBvJ,EAAKsJ,QAAQ+H,kBAAoB,KACjCzZ,KAAK0Z,kBAAkBta,GACvBY,KAAK2Z,gBAAgBva,IACrB,IAAAwa,oBAAmBxa,GACnBY,KAAK6Z,eACL7Z,KAAK4Y,SAAW,KAChB5Y,KAAKoM,WAAY,EACbpM,KAAK8Z,sBACL9Z,KAAKyJ,cAAcmB,4BACnB,QAAiBb,EAAW5J,gBAEhC,OAAsCyM,GAClCkM,IACA,IAAAiB,4BAA2BhQ,KAGnC/J,KAAKga,cAAiBxN,IAClBxM,KAAKoM,WAAY,EACjB,MAAMvE,EAAc2E,EAAIC,QAClB,QAAErN,GAAYyI,GACd,WAAEkC,EAAU,oBAAE6C,EAAmB,YAAEiM,EAAW,cAAEzD,EAAa,cAAE0D,GAAmB9Y,KAAK4Y,SAC7F5Y,KAAKia,WAAW7a,EAAS2K,EAAY,CAAE+O,kBACvC,MAAM,KAAE1Q,GAAS2B,EACjB,GAAIqL,EAAe,CACf,MAAM,YAAE8E,GAAgBrS,EAClBsS,EAAgBD,EAAY5F,OAC5B,QAAE9Q,GAAY4E,EAAKsJ,SACnB,cAAEI,GAAkBtO,EAC1BsO,EAAc,IAAMqI,EAAc,GAClCrI,EAAc,IAAMqI,EAAc,GAClCrI,EAAc,IAAMqI,EAAc,GAClC3W,EAAQmO,UAAW,CACvB,MACK,QAAoB1Q,IAAhB4X,EAA2B,CAChC,MAAM,YAAEqB,GAAgBrS,EAClBsS,EAAgBD,EAAY5F,OAC5B,OAAE1G,GAAWxF,EAAKsJ,QACxB9D,EAAO3O,QAASiU,IACZA,EAAM,IAAMiH,EAAc,GAC1BjH,EAAM,IAAMiH,EAAc,GAC1BjH,EAAM,IAAMiH,EAAc,KAE9BpQ,EAAWC,aAAc,CAC7B,KACK,CACD,MAAM,cAAEqK,GAAkBxM,EACpBxI,GAAiB,IAAAC,mBAAkBF,IACnC,cAAE0O,EAAa,cAAEwC,GAAkBjR,EAAesO,SAClDyG,EAAWC,EAAcC,OACzB,OAAE1G,GAAWxF,EAAKsJ,QAExB,IAAI0I,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACAC,EACJ,OATA/M,EAAOiL,GAAe,IAAIzE,GASlByE,GACJ,KAAK,EACL,KAAK,EACDuB,EAAmBtM,EAAcF,EAAO,IACxC2M,EAAiBzM,EAAcF,EAAO,IACtCyM,EAAoB,CAACE,EAAe,GAAIH,EAAiB,IACzDE,EAAgB,CAACF,EAAiB,GAAIG,EAAe,IACrDE,EAAmBnK,EAAc+J,GACjCK,EAAepK,EAAcgK,GAC7B1M,EAAO,GAAK6M,EACZ7M,EAAO,GAAK8M,EACZ,MACJ,KAAK,EACL,KAAK,EACDL,EAAoBvM,EAAcF,EAAO,IACzC0M,EAAgBxM,EAAcF,EAAO,IACrCwM,EAAmB,CACfE,EAAc,GACdD,EAAkB,IAEtBE,EAAiB,CACbF,EAAkB,GAClBC,EAAc,IAElBE,EAAkBlK,EAAc8J,GAChCO,EAAgBrK,EAAciK,GAC9B3M,EAAO,GAAK4M,EACZ5M,EAAO,GAAK+M,EAGpB5Q,EAAWC,aAAc,CAC7B,CACAhK,KAAK4Y,SAASjH,UAAW,GACF,IAAArS,mBAAkBF,IACzC,OAAsCwN,GAClC7C,EAAWC,cACX,IAAAiH,2BAA0BlH,EAAY3K,EAAS,EAAA8R,YAAY0J,iBAGnE5a,KAAKmO,OAAU/O,IACX,GAAIY,KAAKoM,UAAW,CAChBpM,KAAKoM,WAAY,EACjBpM,KAAK2Z,gBAAgBva,GACrBY,KAAK0Z,kBAAkBta,IACvB,IAAAwa,oBAAmBxa,GACnB,MAAM,WAAE2K,EAAU,oBAAE6C,EAAmB,cAAEkM,GAAkB9Y,KAAK4Y,UAC1D,KAAExQ,GAAS2B,EAQjB,OAPAA,EAAWsP,aAAc,EACzBjR,EAAKsJ,QAAQ+H,kBAAoB,MACjC,OAAsC7M,GAClCkM,IACA,IAAAiB,4BAA2BhQ,GAE/B/J,KAAK4Y,SAAW,KACT7O,EAAW5J,aACtB,GAEJH,KAAK+Y,cAAiB3Z,IAClB,KAAMyb,uBAAwB,EAC9Bzb,EAAQ0b,iBAAiB,EAAA9S,OAAO+S,SAAU/a,KAAKwZ,cAC/Cpa,EAAQ0b,iBAAiB,EAAA9S,OAAOgT,WAAYhb,KAAKga,eACjD5a,EAAQ0b,iBAAiB,EAAA9S,OAAOiT,WAAYjb,KAAKga,eACjD5a,EAAQ0b,iBAAiB,EAAA9S,OAAOkT,YAAalb,KAAKwZ,cAClDpa,EAAQ0b,iBAAiB,EAAA9S,OAAOmT,UAAWnb,KAAKwZ,cAChDpa,EAAQ0b,iBAAiB,EAAA9S,OAAOoT,WAAYpb,KAAKga,eACjD5a,EAAQ0b,iBAAiB,EAAA9S,OAAOqT,UAAWrb,KAAKwZ,eAEpDxZ,KAAK2Z,gBAAmBva,IACpB,KAAMyb,uBAAwB,EAC9Bzb,EAAQkc,oBAAoB,EAAAtT,OAAO+S,SAAU/a,KAAKwZ,cAClDpa,EAAQkc,oBAAoB,EAAAtT,OAAOgT,WAAYhb,KAAKga,eACpD5a,EAAQkc,oBAAoB,EAAAtT,OAAOiT,WAAYjb,KAAKga,eACpD5a,EAAQkc,oBAAoB,EAAAtT,OAAOkT,YAAalb,KAAKwZ,cACrDpa,EAAQkc,oBAAoB,EAAAtT,OAAOmT,UAAWnb,KAAKwZ,cACnDpa,EAAQkc,oBAAoB,EAAAtT,OAAOoT,WAAYpb,KAAKga,eACpD5a,EAAQkc,oBAAoB,EAAAtT,OAAOqT,UAAWrb,KAAKwZ,eAEvDxZ,KAAKsZ,gBAAmBla,IACpB,KAAMyb,uBAAwB,EAC9Bzb,EAAQ0b,iBAAiB,EAAA9S,OAAO+S,SAAU/a,KAAKwZ,cAC/Cpa,EAAQ0b,iBAAiB,EAAA9S,OAAOgT,WAAYhb,KAAKga,eACjD5a,EAAQ0b,iBAAiB,EAAA9S,OAAOkT,YAAalb,KAAKwZ,cAClDpa,EAAQ0b,iBAAiB,EAAA9S,OAAOmT,UAAWnb,KAAKwZ,cAChDpa,EAAQ0b,iBAAiB,EAAA9S,OAAOoT,WAAYpb,KAAKga,eACjD5a,EAAQ0b,iBAAiB,EAAA9S,OAAOqT,UAAWrb,KAAKwZ,eAEpDxZ,KAAK0Z,kBAAqBta,IACtB,KAAMyb,uBAAwB,EAC9Bzb,EAAQkc,oBAAoB,EAAAtT,OAAO+S,SAAU/a,KAAKwZ,cAClDpa,EAAQkc,oBAAoB,EAAAtT,OAAOgT,WAAYhb,KAAKga,eACpD5a,EAAQkc,oBAAoB,EAAAtT,OAAOkT,YAAalb,KAAKwZ,cACrDpa,EAAQkc,oBAAoB,EAAAtT,OAAOmT,UAAWnb,KAAKwZ,cACnDpa,EAAQkc,oBAAoB,EAAAtT,OAAOoT,WAAYpb,KAAKga,eACpD5a,EAAQkc,oBAAoB,EAAAtT,OAAOqT,UAAWrb,KAAKwZ,eAEvDxZ,KAAKub,iBAAmB,CAAClc,EAAgBa,KACrC,IAAIyU,GAAe,EACnB,MAAM,SAAEhH,GAAatO,GACf,QAAED,GAAYuO,EACpB,IAAIyE,GAAc,QAAepS,KAAK8M,cAAe1N,GACrD,IAAKgT,GAAa7P,OACd,OAAOoS,EAGX,GADAvC,EAAcpS,KAAKmS,wCAAwC/S,EAASgT,IAC/DA,GAAa7P,OACd,OAAOoS,EAEX,MAAMhG,EAAW3O,KAAKqR,YAAY1D,GAC5Ba,EAAkBb,EAAS6N,qBAC3BlK,EAAiB,CACnBC,YAAavR,KAAKuR,YAClBjI,SAAUtJ,KAAK8M,cACfvN,WAAYF,EAAesO,SAAS7E,IAExC,IAAK,IAAI7G,EAAI,EAAGA,EAAImQ,EAAY7P,OAAQN,IAAK,CACzC,MAAM8H,EAAaqI,EAAYnQ,IACzB,cAAE9B,EAAa,KAAEiI,GAAS2B,GAC1B,OAAE6D,EAAM,kBAAE6L,GAAsBrR,EAAKsJ,QACrC1C,EAAoBpB,EAAOqB,IAAKC,GAAMvB,EAASG,cAAcoB,IACnEoC,EAAenR,cAAgBA,EAC/B,MAAM,MAAEM,EAAK,UAAEG,EAAS,SAAEC,GAAab,KAAKyU,mBAAmB,CAC3D1K,aACAuH,oBAEE,gBAAEuB,EAAe,OAAE4I,GAAW9N,EAAS8E,YAC7C,GAAKrK,EAAKqG,YAAYE,IACqB,MAAvCvG,EAAKqG,YAAYE,GAAU+G,UAW1B,GAAI3L,EAAWC,cAChBhK,KAAKiS,+BAA+BlI,EAAY8I,EAAiB4I,EAAQjN,EAAiBnP,GACtFsO,aAAoB,EAAA4E,gBAAgB,CACpC,MAAM,kBAAEjD,GAAsBvF,EAAWgF,SACzC,IAAK,MAAMJ,KAAYvG,EAAKqG,YACxB,GAAIE,EAAS+M,WAAW,WAAY,CACdlN,EAAgBmN,oBACCjT,KAAMG,IACrC,MAAM+S,EAAqB,yBAAqBtM,GAC1CuM,EAAchT,EAAGgT,YAAYD,GAC7BE,EAAkB,yBAAqBjT,EAAGkT,qBAChD,OAAOF,GAAeC,IAAoBF,YAGnCxT,EAAKqG,YAAYE,EAEhC,CAER,OA5BAvG,EAAKqG,YAAYE,GAAY,CACzBa,SAAU,KACV8F,KAAM,KACNC,IAAK,KACLC,KAAM,KACNC,OAAQ,KACRC,SAAU,MAEd1V,KAAKuO,sBAAsBxE,EAAY8I,EAAiB4I,EAAQjN,EAAiBnP,GAsBrF,IAAKsO,EAAS6N,qBAEV,OADAjT,QAAQC,KAAK,uCACNmM,EAEX,IAAIqH,EACJ,KAAK,IAAAC,qBAAoB9b,GACrB,UAEC,IAAA+b,oBAAmB/b,IACnBH,KAAK4Y,UADN,MAEAa,IAEAuC,EAA2B,CAAChN,EAAkByK,KAElD,MAAM0C,EAAoBC,SAAQ,OAAiB,oBAAqB,CAAC,IACzE,GAAIJ,GAA4BG,EAAmB,CAC/C,MAAMra,EAAiB,KACvB,IAAAua,aAAenc,EAAkBC,EAAe2B,EAAgBqa,EAAoBnN,EAAoBgN,EAA0B,CAC9Hvb,SAER,CACA,MAAMD,EAAS,GAAGL,SACZ2D,EAAe,KACrB,2BAAY5D,EAAkBC,EAAe2D,EAAckL,EAAmB,CAC1EvO,QACAI,WACAD,aACDJ,GACHmU,GAAe,EACf,MAAMpU,EAAUP,KAAKwR,sBAAsBF,EAAgBvH,GAC3D,IAAKxJ,EAAQkR,WAAY,CACrBrJ,EAAKsJ,QAAQlO,QAAU,CACnBmO,UAAU,EACVG,cAAe,CAAC,EAAG,EAAG,GACtBE,iBAAkB,CACdjO,QAAS,CAAC,EAAG,EAAG,GAChBC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnBC,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAMZ,EAAYtD,KAAKyJ,cAAcuC,aAAa5D,EAAMuG,GACxD,IAAKrL,GAAkC,IAArBA,EAAUf,OACxB,SAEJ,IAAK6F,EAAKsJ,QAAQlO,QAAQmO,SAAU,CAChC,MAAMC,GAAsB,IAAAC,wBAAuB7C,GACnD5G,EAAKsJ,QAAQlO,QAAQsO,cACjBnE,EAAS2C,cAAcsB,EAC/B,CACA,MAAMrO,EAAkBoK,EAASG,cAAc1F,EAAKsJ,QAAQlO,QAAQsO,eAC9DzO,EAAa,IACbhB,GAAc,IAAA0P,mBAAqB7R,EAAkBC,EAAekD,EAAYC,EAAWC,EAAiByL,EAAmB,CAAC,EAAGzO,IACjImC,EAAGC,EAAMC,EAAGC,EAAG,MAAElC,EAAK,OAAEmC,GAAWT,EAC3C+F,EAAKsJ,QAAQlO,QAAQwO,iBAAmB,CACpCjO,QAAS4J,EAAS2C,cAAc,CAAC3N,EAAME,IACvCmB,SAAU2J,EAAS2C,cAAc,CAAC3N,EAAOhC,EAAOkC,IAChDoB,WAAY0J,EAAS2C,cAAc,CAAC3N,EAAME,EAAMC,IAChDoB,YAAayJ,EAAS2C,cAAc,CAAC3N,EAAOhC,EAAOkC,EAAMC,IAEjE,CACA,OAAO6R,GAEX3U,KAAKoZ,8BAAiCxL,IAClC,MAAO0O,EAAQC,GAAU3O,EACzB,MAAO,CACHjL,KAAMiR,KAAK2C,IAAI+F,EAAO,GAAIC,EAAO,IACjC1Z,IAAK+Q,KAAK2C,IAAI+F,EAAO,GAAIC,EAAO,IAChC5b,MAAOiT,KAAKC,IAAIyI,EAAO,GAAKC,EAAO,IACnCzZ,OAAQ8Q,KAAKC,IAAIyI,EAAO,GAAKC,EAAO,MAG5Cvc,KAAKuO,sBAAwB,CAACxE,EAAY8I,EAAiB4I,EAAQjN,EAAiBnP,KAChF,IAAKW,KAAKyJ,cAAcC,eACpB,OAEJ,MAAM,KAAEtB,GAAS2B,GACX,SAAE4D,GAAatO,GACf,QAAED,GAAYuO,EACd6O,EAAYpU,EAAKsJ,QAAQ9D,OAAO,GAChC6O,EAAYrU,EAAKsJ,QAAQ9D,OAAO,IAChC,YAAEa,GAAgBrG,EAClBsG,EAAY3P,OAAOC,KAAKyP,GAC9B,IAAK,IAAIxM,EAAI,EAAGA,EAAIyM,EAAUnM,OAAQN,IAAK,CACvC,MAAM0M,EAAWD,EAAUzM,GACrB2M,EAAQ5O,KAAK6O,mBAAmBF,GACtC,IAAKC,EACD,SAEJ,MAAM,WAAE8N,EAAU,UAAE5N,EAAS,SAAEC,EAAQ,aAAE6G,GAAiBhH,EACpD+N,EAAYlE,EAAsB3J,EAAW0N,GACnDG,EAAU,GAAK/I,KAAKmC,MAAM4G,EAAU,IACpCA,EAAU,GAAK/I,KAAKmC,MAAM4G,EAAU,IACpCA,EAAU,GAAK/I,KAAKmC,MAAM4G,EAAU,IACpC,MAAMC,EAAYnE,EAAsB3J,EAAW2N,GAInD,GAHAG,EAAU,GAAKhJ,KAAKmC,MAAM6G,EAAU,IACpCA,EAAU,GAAKhJ,KAAKmC,MAAM6G,EAAU,IACpCA,EAAU,GAAKhJ,KAAKmC,MAAM6G,EAAU,IAChC5c,KAAK6c,gBAAgBF,EAAWC,EAAWF,GAAa,CACxD1c,KAAK8Z,sBAAuB,EAC5B,MAMMhD,EAAY,CACd,CAPSlD,KAAK2C,IAAIoG,EAAU,GAAIC,EAAU,IACjChJ,KAAK2B,IAAIoH,EAAU,GAAIC,EAAU,KAO1C,CANShJ,KAAK2C,IAAIoG,EAAU,GAAIC,EAAU,IACjChJ,KAAK2B,IAAIoH,EAAU,GAAIC,EAAU,KAM1C,CALShJ,KAAK2C,IAAIoG,EAAU,GAAIC,EAAU,IACjChJ,KAAK2B,IAAIoH,EAAU,GAAIC,EAAU,OAMxC,WAAEE,EAAU,YAAEC,IAAgB,OAAkClK,EAAiB4I,EAAQe,EAAWC,GACpG/K,EAAU,CAACiL,EAAWC,IACtB,MAAEjH,EAAK,SAAED,IAAa,QAAiC9G,EAAO8C,GAC9D4D,EAAO1B,KAAKC,IAAIiJ,EAAaC,IAAgBpH,EAAQA,GACrDqH,EAAoB,CACtB5N,aAAa,OAAoBzB,EAAUgB,GAC3CU,YAAarP,KAAKqP,YAAY1B,EAAUgB,EAAU5E,EAAWgF,SAASO,oBAEpEC,GAAe,OAAmBR,EAASS,SAAUzF,EAAWgF,SAASO,kBAAmB0N,GAClG,IAAI9F,EACAtB,IACAsB,EAAgBtB,EAAa3W,QAAQe,KAAKyJ,cAAcyC,gBAAgBoL,cAAe,CACnFR,YACAhI,YACAkJ,aAAchY,KAAKyJ,cAAciB,kBAGzC,MAAMuN,EAAQjY,KAAKyJ,cAAcyC,gBAAgBgM,gBACjDzJ,EAAYE,GAAY,CACpBa,SAAUT,EAASS,SACnB8F,OACAE,KAAMyC,EAAMzC,MAAM2C,MAClB1C,OAAQwC,EAAMxC,QAAQ0C,MACtB5C,IAAK0C,EAAM1C,KAAK4C,MAChB5B,IAAK0B,EAAM1B,KAAK4B,MAChBC,WAAYH,EAAMI,MAClBnB,cAAeA,EACfxB,WACAnG,eAER,MAEIvP,KAAK8Z,sBAAuB,EAC5BrL,EAAYE,GAAY,CACpBa,SAAUT,EAASS,SAG/B,CACA,MAAMxF,EAAcD,EAAWC,YAK/B,OAJAD,EAAWC,aAAc,EACrBA,IACA,IAAAiH,2BAA0BlH,EAAY3K,EAAS,EAAA8R,YAAYC,cAExD1C,GAEXzO,KAAK6c,gBAAkB,CAACI,EAAQC,EAAQR,IAC5B,kCAA8BO,EAAQP,IAC1C,kCAA8BQ,EAAQR,GAE9C1c,KAAKiS,gCAAiC,OAASjS,KAAKuO,sBAAuB,IAAK,CAAE2D,UAAU,GAChG,QACSlS,KAAKmd,QAAU,CAAC5d,EAAYqO,EAAQrN,KACzC,MAAMlB,GAAiB,IAAA+d,+BAA8B7d,GACrD,IAAKF,EACD,OAEJ,MAAM,oBAAE4T,EAAmB,kBAAE3D,EAAiB,gBAAEuD,EAAe,SAAEwK,EAAQ,SAAE1P,GAAc3N,KAAKsd,YAAY5E,EAAkBrZ,EAAgBuO,EAAQrN,IAC9I,aAAEgd,KAAiBC,GAAwBjd,GAAW,CAAC,EACvDwJ,EAAa,CACf5J,cAAeI,GAASJ,eAAiB,qBACzCiI,KAAM,CACFsJ,QAAS,CACL9D,SACA6L,kBAAmB,MAEvBjF,MAAO,GACP/F,YAAa,CAAC,GAElB4K,aAAa,EACboE,eAAe,EACfzT,aAAa,EACb0T,UAAU,EACV1J,WAAW,EACXjF,SAAU,CACNzF,SAAU+T,EAASvQ,cACnB+F,kBACAI,sBACA3D,uBACGkO,KAGX,QAAczT,EAAY4D,EAASvO,UACnC,OAAsC,CAACuO,EAAS7E,KACjD,EAEP,SAASmD,EAAoB7D,EAAMuG,GAC/B,MAAM2J,EAAoBlQ,EAAKqG,YAAYE,IACrC,KAAE2G,EAAI,KAAEE,EAAI,IAAED,EAAG,OAAEE,EAAM,SAAEC,EAAQ,aAAEnG,EAAY,IAAEgH,GAAQ+B,EACjE,GAAI9C,QACA,OAEJ,MAAMlS,EAAY,GAgBlB,OAfI,qBAAiBgS,IACjBhS,EAAU6Q,KAAK,SAAS,wBAAoBmB,MAASI,KAErD,qBAAiBF,IACjBlS,EAAU6Q,KAAK,SAAS,wBAAoBqB,MAASjG,KAErD,qBAAiBgG,IACjBjS,EAAU6Q,KAAK,QAAQ,wBAAoBoB,MAAQhG,KAEnD,qBAAiBgH,IACjBjT,EAAU6Q,KAAK,QAAQ,wBAAoBoC,MAAQhH,KAEnD,qBAAiBkG,IACjBnS,EAAU6Q,KAAK,YAAY,wBAAoBsB,MAAWlG,KAEvDjM,CACX,CACA,S,sNC/jBe,MAAMqa,UAAyB,YACjC3d,KAAK4d,YAAc,CACxBC,QAAS,KACTze,QAAS,KACT0e,WAAY,EACZC,MAAO,KACPC,WAAY,CAACC,IAAKA,KAClBC,QAAQ,EACT,CACH,WAAA9Z,CAAYmF,EAAWiB,GACnBhB,MAAMD,EAAWiB,GACjBxK,KAAKme,QAAU,IAAIC,IACnBpe,KAAKqe,gBAAkB,IAAID,IAC3Bpe,KAAKse,uBAAyB,CAC1BxZ,aAAc,KACdyZ,iBAAiB,EACjBC,iBAAiB,EACjBC,eAAgB,GAExB,CACA,mBAAAC,CAAoBlS,GAChB,MAAM,GAAE1D,EAAE,cAAE6V,GAAkBnS,EAAIC,OAClC,GAAsB,aAAlBkS,EAAJ,CAGA,GAAI3e,KAAKqe,gBAAgBO,IAAI9V,GAAK,CAC9B9I,KAAK6e,WAAa,KAClB,MAAMC,EAAW9e,KAAKqe,gBAAgBU,IAAIjW,GACpC1J,EAAU0f,GAAU1f,QACpB4f,EAAgBhf,KAAKif,iBAAiB7f,GAC5C4f,EAAcla,aAAega,GAAUha,aACnC1F,GACAY,KAAKkf,6BAA4B,IAAA5f,mBAAkBF,GAAU4f,EAAe,EAAAG,kBAAkBC,cAEtG,CACApf,KAAKqf,aAAanB,QAAS,CAX3B,CAYJ,CACA,gBAAImB,GACA,OAAO1B,EAAiBC,WAC5B,CACA,cAAA0B,GACI,QAAStf,KAAKqf,aAAaxB,OAC/B,CACA,4BAAA0B,GACI,OAAuB,WAAdvf,KAAKwf,MAAmC,YAAdxf,KAAKwf,OACpCxf,KAAKsf,gBACb,CACA,UAAArF,CAAWrV,EAAgB6a,GACvB,MAAMC,EAAiBD,EAAyB3W,GAChD,GAAI9I,KAAK2f,MACL3f,KAAK2f,KAAKF,2BAA6BA,EACvC,OAAOzf,KAAK2f,KAEhB,IAAIA,EAAO3f,KAAKme,QAAQY,IAAIW,GAY5B,OAXKC,EAKGA,EAAKC,mBACLD,EAAO,qBAAgC/a,EAAgB6a,GACvDzf,KAAKme,QAAQ0B,IAAIH,EAAgBC,KANrCA,EAAO,qBAAgC/a,EAAgB6a,GACvDzf,KAAKme,QAAQ0B,IAAIH,EAAgBC,IAQrC3f,KAAK2f,KAAOA,EACLA,CACX,CACA,cAAAG,CAAe1gB,GACX,MAAMC,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,EACf0gB,GAAqB,OAAsBpS,EAAS7E,IAC1D,IAAKiX,EAAoB,CACrB,MAAMC,EAAQ,IAAIC,YAAY,EAAAC,MAAA,OAAaC,YAAa,CACpD1T,OAAQ,CACJ5H,KAAM,eACNub,QAAS,qGAEbC,YAAY,IAGhB,OADA,EAAAtY,YAAYuY,cAAcN,GACnB,IACX,CACA,MAAM,eAAEpb,GAAmBmb,EACrBQ,GAAiB,IAAAC,yBAAwB5b,IACzC,mBAAE0D,IAAuB,OAAgB1D,GAO/C,OANiB5E,KAAKygB,YAAY,CAC9B9S,WACArF,qBACAiY,iBACA3b,kBAGR,CACA,WAAA6b,EAAY,SAAE9S,EAAQ,mBAAErF,EAAkB,eAAEiY,EAAc,eAAE3b,IACxD,GAAI+I,aAAoB,EAAA+S,mBAAoB,CACxC,MAAM,SAAEC,GAAarY,EAAmB,IAA4B1C,UAC9Dgb,EAASjT,EAASkT,YAExB,GADwBlT,aAAoB,EAAAmT,cACvB,CACjB,MAAMd,EAAQ,IAAIC,YAAY,EAAAC,MAAA,OAAaC,YAAa,CACpD1T,OAAQ,CACJ5H,KAAM,eACNub,QAAS,2DAEbC,YAAY,IAGhB,OADA,EAAAtY,YAAYuY,cAAcN,GACnB,IACX,CACA,MAAMe,EAAUH,EAAO3R,IAAK+R,GAAe,EAAAC,MAAMC,UAAUF,EAAWG,eAChEC,EAAqB,EAAAH,MAAMC,UAAUP,GACrCU,EAAgCN,EAAQrY,KAAM4Y,GAAW,oBAAgBA,EAAO5E,WAAY0E,EAAmB1E,cAAciE,UAAYI,EAAQ,IAAIJ,SAC3J,MAAO,CACHA,WACAY,mBAAoBvhB,KAAKyJ,cAAc+X,WAAWb,UAC9CU,EACJd,iBAER,CACK,CACD,MAAMkB,GAAsB,QAAqC9T,EAAS7E,GAAIlE,GAC9E,IAAK6c,EACD,OAEJ,MAAO,CACHC,QAASD,EACTlB,iBAER,CACJ,CACA,eAAAoB,CAAgBviB,EAASwiB,GACrB,MAAMviB,GAAiB,IAAAC,mBAAkBF,IACnC,SAAEuO,GAAatO,EACfmT,EAAS7E,EAAS8E,aAClB,gBAAEI,EAAe,OAAE4I,GAAWjJ,EAC9B5F,EAAsB,CAACe,EAAS7E,KAChC,aAAEhE,EAAY,eAAEF,EAAc,aAAEid,GAAiB7hB,KAAK8hB,0BAA0BnU,IAAa,CAAC,EAYpG,MAAO,CACHoU,YAZgB,CAChBhT,SAAU,CACN8D,gBAAiB,IAAIA,GACrB4I,OAAQ,IAAIA,GACZxI,oBAAqBtF,EAASqU,yBAC9B1S,kBAAmB,GACnBhG,SAAUtJ,KAAK8M,cACf+U,gBAEJzZ,KAAM,CAAC,GAIPwZ,eACA9c,eACA6I,WACA/I,iBACAid,eACAjV,sBAER,CACA,yBAAAkV,CAA0BnU,GACtB,MAAMpO,EAAaoO,EAAS7E,GACtBmZ,GAAuB,OAAsB1iB,GACnD,IAAK0iB,EACD,OAEJ,MAAM,eAAErd,GAAmBqd,EACrBnd,GAAe,OAAsBF,GAC3C,IAAKE,EACD,OAGJ,MAAO,CACHA,eACAF,iBACAid,cAJiB,IAAAK,sBAAqB3iB,EAAYqF,EAAgBE,GAM1E,CACA,gBAAAma,CAAiB7f,GACb,MAAMwZ,EAAW5Y,KAAKmiB,WAAaniB,KAAK8f,eAAe1gB,IACjD,aAAE0F,EAAY,eAAEF,EAAc,YAAEmd,GAAgB/hB,KAAK6e,YAAc7e,KAAK2hB,gBAAgBviB,IACxF,KAAEgJ,EAAI,SAAE2G,EAAW,CAAC,GAAMgT,GAAe,CAAC,GAC1C,gBAAElP,EAAe,OAAE4I,GAAW1M,EAC9BqT,EAAcpiB,KAAKyJ,cAAcoU,SAASwE,gBAAgBvd,IAC1D,SAAE6I,IAAa,IAAArO,mBAAkBF,GACjCyiB,GAAe,IAAAK,sBAAqBvU,EAAS7E,GAAIlE,EAAgBE,GACvE,IAAKsd,IAAgBP,EACjB,OAEJ,IAAIS,EAAe,KAAMC,EAAsB,KAC3CviB,KAAKyJ,cAAcoU,SAAS5S,UAC5BqX,EAAeF,GAyJ3B,SAAsB5gB,EAAGghB,EAAG1K,EAAGD,EAAG4K,EAAS,IACvC,MAAO,CACH7O,KAAK8O,MAAMlhB,GAAK,IAAMA,GAAKihB,GAC3B7O,KAAK8O,MAAMF,GAAK,IAAMA,GAAKC,GAC3B7O,KAAK8O,MAAM5K,GAAK,IAAMA,GAAK2K,GAC3B5K,EAER,CAhK0C8K,IAAgBd,GAC9CU,EAAsB,KAkB1B,MAhBsB,IACf3J,EACHhL,OAAQxF,GAAMsJ,SAAS9D,OACvB9I,eACA+N,kBACA+P,gBAAiB5iB,KAAKqf,aAAanB,OACnC3M,YAAavR,KAAKuR,YAClB3M,iBACA6W,SACA6C,uBAAwBte,KAAKse,uBAC7BuE,eAAgB7iB,KAAKyJ,cAAcoZ,eACnCpZ,cAAezJ,KAAKyJ,cACpB6Y,eACAC,sBACAtI,WAAYja,KAAKia,WAAWla,KAAKC,MAGzC,CACA,UAAA8iB,CAAW1jB,EAAUY,KAAKqf,aAAajgB,QAASmB,GAC5C,MAAM,aAAE8e,GAAiBrf,KACnB+iB,EAAexiB,GAASwiB,cACT,IAAjBA,EACA/iB,KAAKgjB,cAAc5jB,IAEG,IAAjB2jB,GACL/iB,KAAKijB,cAAc7jB,GAEvB,MAAMC,GAAiB,IAAAC,mBAAkBF,GACnC8jB,EAAUljB,KAAKkf,4BAA4B7f,EAAgBW,KAAKif,iBAAiB7f,GAAU,EAAA+f,kBAAkBgE,YAMnH,OALA9D,EAAanB,QAAS,EAClBgF,GAASE,WACT/D,EAAaxB,QAAUqF,EACvB7D,EAAajgB,QAAUA,GAEpB8jB,CACX,CACA,aAAAD,CAAc7jB,EAAUY,KAAKqf,aAAajgB,SACtC,IAAKA,EACD,OAEJY,KAAK6Z,eACL,MAAMxa,GAAiB,IAAAC,mBAAkBF,GACzCY,KAAKkf,4BAA4B7f,EAAgBW,KAAKif,iBAAiB7f,GAAU,EAAA+f,kBAAkBkE,eACnGrjB,KAAKqf,aAAaxB,QAAU,KAC5B7d,KAAKqf,aAAanB,QAAS,CAC/B,CACA,aAAA8E,CAAc5jB,EAAUY,KAAKqf,aAAajgB,SACtC,IAAKA,EACD,OAEJ,MAAM4f,EAAgBhf,KAAKif,iBAAiB7f,GACxCY,KAAK2f,MAAQ3f,KAAK2f,KAAK7W,IACvB9I,KAAKqe,gBAAgBwB,IAAI7f,KAAK2f,KAAK7W,GAAI,CACnC1J,UACA0F,aAAcka,EAAcla,eAGpC,MAAMzF,GAAiB,IAAAC,mBAAkBF,GACzCY,KAAKkf,4BAA4B7f,EAAgB2f,EAAe,EAAAG,kBAAkBC,eAClFpf,KAAK6Z,eACL7Z,KAAKqf,aAAaxB,QAAU,KAC5B7d,KAAKqf,aAAanB,QAAS,CAC/B,CACA,iCAAOoF,CAA2B3V,EAAUpN,GACxC,MAAMgjB,EAAiBhjB,GAASgjB,iBAAkB,EAC5CnR,GAAc,IAAAoR,qBACdC,GAAkB,IAAA7Q,6BAA4BjF,EAAUyE,GAC9D,IAAKqR,GAAiBlhB,OAClB,OAEJ,MAAMmhB,EAAqBD,EAAgBxa,OAAQc,GAAeA,EAAW3B,KAAKgF,SAASjD,UAAU5H,QACrG,IAAKmhB,EAAmBnhB,OACpB,OAEJ,MAQMsb,EARgB,IAAIF,EAAiB,CAAC,EAAG,CAC3ClU,cAAe,CACXka,WAAY,CACRC,mBAAoB,EAAAC,kBAExBhB,eAAgB,wBAGMC,WAAWnV,EAASvO,UAC5C,KAAEugB,EAAI,eAAE/a,GAAmBiZ,EAC3BiG,EAAgBnE,GAAM/J,aACtBmO,EAAqBD,EAAcE,oBAAsBF,GACzD,WAAEpH,GAAeoH,EACjBhV,EAAYnB,EACbsW,kBACAC,MAAMC,YACNC,eACL,IAAK,MAAMra,KAAc2Z,EAAoB,CACzC,MAAM5M,EAAY,CACd,CAACuN,KAAWA,KACZ,CAACA,KAAWA,KACZ,CAACA,KAAWA,OAEV,SAAEla,GAAaJ,EAAW3B,KAAKgF,QACrC,IAAK,MAAM8F,KAAS/I,EAAU,CACP2E,EAAUwV,aAAapR,GAC/BjU,QAAQ,CAACslB,EAAGC,KACnB1N,EAAU0N,GAAK,GAAK5Q,KAAK2C,IAAIO,EAAU0N,GAAK,GAAID,GAChDzN,EAAU0N,GAAK,GAAK5Q,KAAK2B,IAAIuB,EAAU0N,GAAK,GAAID,IAExD,CACAzN,EAAU7X,QAAQ,CAACwlB,EAAOD,KACtBC,EAAM,GAAK7Q,KAAK8O,MAAM9O,KAAK2B,IAAI,EAAGkP,EAAM,KACxCA,EAAM,GAAK7Q,KAAK8O,MAAM9O,KAAK2C,IAAImG,EAAW8H,GAAO,EAAGC,EAAM,OAE9D,MAAMC,GAAc,OAAsB9f,GACpCoZ,EAAajU,EAAW3B,KAAKsJ,UAAU,IAAMvH,EAAS,GACtDwa,EAAa7V,EAAUwV,aAAatG,GAAY/O,IAAI2E,KAAK8O,OACzDkC,EAAab,EAAmBc,cAAcF,IAAe,EACnE,IAAIG,GAAe,EACfC,GAAmB,EACvB,IAAK,MAAMC,KAAa7a,EAAU,CAC9B,MAAM8a,EAAYnW,EAAUwV,aAAaU,GAAW/V,IAAI2E,KAAK8O,OACvDwC,EAAYnB,EAAmBc,cAAcI,GAC/CC,IAAcN,EACdE,GAAe,EAEVI,GAAa,IAClBH,GAAmB,EAE3B,CACA,MACMjgB,EADUggB,GAAgBC,EAE1BH,EACe,IAAfA,EACIF,EACA,EACV,IAAK,IAAIziB,EAAI6U,EAAU,GAAG,GAAI7U,GAAK6U,EAAU,GAAG,GAAI7U,IAChD,IAAK,IAAIqU,EAAIQ,EAAU,GAAG,GAAIR,GAAKQ,EAAU,GAAG,GAAIR,IAChD,IAAK,IAAI6O,EAAIrO,EAAU,GAAG,GAAIqO,GAAKrO,EAAU,GAAG,GAAIqO,IAAK,CACrD,MAAMC,EAAatW,EAAUkI,aAAa,CAAC/U,EAAGqU,EAAG6O,KAC7B,IAAAE,yBAAwBD,EAAYjb,IAEpD2Z,EAAcwB,SAASrjB,EAAGqU,EAAG6O,EAAGrgB,EAExC,CAGJye,IACA,IAAAgC,kBAAiBxb,EAAW5J,cAEpC,CACA,MAAMqlB,EAAS1B,EAAc2B,4BAC7B,IAAA9d,iCAAgC/C,EAAgB4gB,EACpD,E,kDCpPJ,QA/GA,SAAkBE,EAAMC,EAAMplB,GAC1B,IAAIqlB,EAAUC,EAAUC,EAASpO,EAAQqO,EAASC,EAC9CC,EAAiB,EACjBC,GAAU,EACVC,GAAS,EACTjU,GAAW,EACf,MAAMkU,GAAUT,GAAiB,IAATA,GAAsD,mBAAjCU,OAAOC,sBACpD,GAAoB,mBAATZ,EACP,MAAM,IAAIa,UAAU,uBASxB,SAASC,EAAWC,GAChB,MAAMC,EAAOd,EACPe,EAAUd,EAIhB,OAHAD,EAAWC,OAAW5kB,EACtBglB,EAAiBQ,EACjB/O,EAASgO,EAAKkB,MAAMD,EAASD,GACtBhP,CACX,CACA,SAASmP,EAAWC,EAAanB,GAC7B,OAAIS,EACOC,OAAOC,sBAAsBQ,GAEjCC,WAAWD,EAAanB,EACnC,CAoBA,SAASqB,EAAaP,GAClB,MAAMQ,EAAoBR,EAAOT,EAEjC,YAAyB/kB,IAAjB+kB,GACJiB,GAAqBtB,GACrBsB,EAAoB,GACnBd,GAJuBM,EAAOR,GAIGH,CAC1C,CACA,SAASoB,IACL,MAAMT,EAAOU,KAAKC,MAClB,GAAIJ,EAAaP,GACb,OAAOY,EAAaZ,GAExBV,EAAUc,EAAWK,EArBzB,SAAuBT,GACnB,MACMa,EAAsBb,EAAOR,EAC7BsB,EAAc5B,GAFMc,EAAOT,GAGjC,OAAOG,EACDvS,KAAK2C,IAAIgR,EAAazB,EAAUwB,GAChCC,CACV,CAcuCC,CAAcf,GACrD,CACA,SAASY,EAAaZ,GAElB,OADAV,OAAU9kB,EACNiR,GAAY0T,EACLY,EAAWC,IAEtBb,EAAWC,OAAW5kB,EACfyW,EACX,CAcA,SAAS+P,KAAaf,GAClB,MAAMD,EAAOU,KAAKC,MACZM,EAAaV,EAAaP,GAIhC,GAHAb,EAAWc,EACXb,EAAW7lB,KACXgmB,EAAeS,EACXiB,EAAY,CACZ,QAAgBzmB,IAAZ8kB,EACA,OAzDZ,SAAqBU,GAGjB,OAFAR,EAAiBQ,EACjBV,EAAUc,EAAWK,EAAcvB,GAC5BO,EAAUM,EAAWC,GAAQ/O,CACxC,CAqDmBiQ,CAAY3B,GAEvB,GAAIG,EAEA,OADAJ,EAAUc,EAAWK,EAAcvB,GAC5Ba,EAAWR,EAE1B,CAIA,YAHgB/kB,IAAZ8kB,IACAA,EAAUc,EAAWK,EAAcvB,IAEhCjO,CACX,CAIA,OAnGAiO,EAAOiC,OAAOjC,IAAS,GACnB,OAASplB,KACT2lB,EAAU9J,QAAQ7b,EAAQ2lB,SAC1BC,EAAS,YAAa5lB,EACtBulB,EAAUK,EAASvS,KAAK2B,IAAIqS,OAAOrnB,EAAQulB,UAAY,EAAGH,GAAQG,EAClE5T,EAAW,aAAc3R,EAAU6b,QAAQ7b,EAAQ2R,UAAYA,GA2FnEuV,EAAUtZ,OAjCV,gBACoBlN,IAAZ8kB,GA3CR,SAAqBjd,GACjB,GAAIsd,EACA,OAAOC,OAAOwB,qBAAqB/e,GAEvCgf,aAAahf,EACjB,CAuCQif,CAAYhC,GAEhBE,EAAiB,EACjBL,EAAWI,EAAeH,EAAWE,OAAU9kB,CACnD,EA4BAwmB,EAAUO,MA3BV,WACI,YAAmB/mB,IAAZ8kB,EAAwBrO,EAAS2P,EAAaF,KAAKC,MAC9D,EA0BAK,EAAUQ,QAzBV,WACI,YAAmBhnB,IAAZ8kB,CACX,EAwBO0B,CACX,C,iBC/Ge,SAAS5V,EAAuBqW,GAC3C,MAAMC,EAKV,SAA2BC,GACvB,MAAMC,EAAqB,CAACD,EAAa,GAAIA,EAAa,IAAIxQ,KAAK0Q,GAC7DC,EAAqB,CAACH,EAAa,GAAIA,EAAa,IAAIxQ,KAAK4Q,GAC7DC,EAAQJ,EAAmBA,EAAmB9lB,OAAS,GACvDM,EAAM0lB,EAAmB,GACzBG,EAASH,EAAmBA,EAAmBhmB,OAAS,GAC9D,MAAO,CACHM,MACA6lB,SACAD,SAEJ,SAASH,EAAUzQ,EAAGC,GAClB,OAAOD,EAAE,GAAKC,EAAE,IAAM,EAAI,CAC9B,CACA,SAAS0Q,EAAU3Q,EAAGC,GAClB,OAAOD,EAAE,GAAKC,EAAE,IAAM,EAAI,CAC9B,CACJ,CAtBoB6Q,CAAkBT,GAC5BU,GAAWT,EAAQtlB,IAAI,GAAKslB,EAAQO,OAAO,IAAM,EAEvD,MADsB,CAACP,EAAQM,MAAM,GAAIG,EAE7C,C,kECJe,SAASC,EAAyB9e,GAC7C,MAAM+e,GAAY,OAA0B/e,GAC5C,IAAK+e,GAAWvmB,OACZ,OAKJ,OAHiBumB,EAAUpgB,KAAMiF,GAAaA,EACzCob,cACA3f,KAAMsY,GAAYA,IAAY3X,EAAWgF,SAASO,qBACpCwZ,EAAU,EACjC,C,mCCNA,QAJA,SAAkB3Q,GACd,MAAMtT,SAAcsT,EACpB,OAAiB,OAAVA,IAA4B,WAATtT,GAA8B,aAATA,EACnD,C,kBCHe,SAASmkB,EAAcC,EAAQzR,GAC1C,MAAM,OAAEnX,EAAM,OAAEC,GAAW2oB,EACrBC,EAAUD,EAAOC,SAAW5oB,EAASA,EAC3C,OAASkX,EAAS,GAAKnX,EAAO,KAAOmX,EAAS,GAAKnX,EAAO,KACrDmX,EAAS,GAAKnX,EAAO,KAAOmX,EAAS,GAAKnX,EAAO,KACjDmX,EAAS,GAAKnX,EAAO,KAAOmX,EAAS,GAAKnX,EAAO,KAClD6oB,CACR,C,6ECWA,QAhBA,SAAkBxD,EAAMC,EAAMplB,GAC1B,IAAI2lB,GAAU,EACVhU,GAAW,EACf,GAAoB,mBAATwT,EACP,MAAM,IAAIa,UAAU,uBAMxB,OAJI,OAAShmB,KACT2lB,EAAU,YAAa3lB,EAAU6b,QAAQ7b,EAAQ2lB,SAAWA,EAC5DhU,EAAW,aAAc3R,EAAU6b,QAAQ7b,EAAQ2R,UAAYA,IAE5D,OAASwT,EAAMC,EAAM,CACxBO,UACAhU,WACA4T,QAASH,GAEjB,C,kDChBA,SAASwD,EAAoBxb,EAAUgB,GACnC,GAAIhB,aAAoB,EAAA+S,mBAAoB,CACxC,MAAMC,EAAW,EAAAjZ,UAAA,YAAsBiH,GACjC2S,EAAS,EAAAL,MAAMC,UAAUP,GAC/B,QAASW,GAAQ8H,SAAWrqB,OAAOC,KAAKsiB,EAAO8H,SAAS7mB,OAAS,CACrE,CACK,GAAIoL,aAAoB,EAAAmT,cAAe,CACxC,MAAM,SAAEuI,GAAa1b,EAASkI,gBAAkB,CAAC,EACjD,QAASwT,GAAUC,MACvB,CAEI,OAAO,CAEf,C","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/getSvgDrawingHelper.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/draw.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawCircle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLink.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLinkedTextBox.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRect.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationDataModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentationVisibility.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddRepresentationData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandContourSegmentationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RectangleROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapBaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/getTextBoxCoordsCanvas.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportForAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/isObject.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/pointInSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js"],"sourcesContent":["import { state } from '../store/state';\nimport { getEnabledElement } from '@cornerstonejs/core';\nconst VIEWPORT_ELEMENT = 'viewport-element';\nfunction getSvgDrawingHelper(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId, renderingEngineId } = enabledElement;\n    const canvasHash = `${viewportId}:${renderingEngineId}`;\n    const svgLayerElement = _getSvgLayer(element);\n    Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n        state.svgNodeCache[canvasHash][cacheKey].touched = false;\n    });\n    return {\n        svgLayerElement: svgLayerElement,\n        svgNodeCacheForCanvas: state.svgNodeCache,\n        getSvgNode: getSvgNode.bind(this, canvasHash),\n        appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\n        setNodeTouched: setNodeTouched.bind(this, canvasHash),\n        clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\n    };\n}\nfunction _getSvgLayer(element) {\n    const viewportElement = `.${VIEWPORT_ELEMENT}`;\n    const internalDivElement = element.querySelector(viewportElement);\n    const svgLayer = internalDivElement?.querySelector(':scope > .svg-layer');\n    return svgLayer;\n}\nfunction getSvgNode(canvasHash, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    if (state.svgNodeCache[canvasHash][cacheKey]) {\n        return state.svgNodeCache[canvasHash][cacheKey].domRef;\n    }\n}\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return null;\n    }\n    state.svgNodeCache[canvasHash][cacheKey] = {\n        touched: true,\n        domRef: svgNode,\n    };\n    svgLayerElement.appendChild(svgNode);\n}\nfunction setNodeTouched(canvasHash, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    if (state.svgNodeCache[canvasHash][cacheKey]) {\n        state.svgNodeCache[canvasHash][cacheKey].touched = true;\n    }\n}\nfunction clearUntouched(svgLayerElement, canvasHash) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n        const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\n        if (!cacheEntry.touched && cacheEntry.domRef) {\n            svgLayerElement.removeChild(cacheEntry.domRef);\n            delete state.svgNodeCache[canvasHash][cacheKey];\n        }\n    });\n}\nexport default getSvgDrawingHelper;\n","import getSvgDrawingHelper from './getSvgDrawingHelper';\nfunction draw(element, fn) {\n    const svgDrawingHelper = getSvgDrawingHelper(element);\n    fn(svgDrawingHelper);\n    svgDrawingHelper.clearUntouched();\n}\nexport default draw;\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nfunction drawCircle(svgDrawingHelper, annotationUID, circleUID, center, radius, options = {}, dataId = '') {\n    const { color, fill, width, lineWidth, lineDash, fillOpacity, strokeOpacity, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        fill: 'transparent',\n        width: '2',\n        lineDash: undefined,\n        lineWidth: undefined,\n        strokeOpacity: 1,\n        fillOpacity: 1,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'circle', circleUID);\n    const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const attributes = {\n        cx: `${center[0]}`,\n        cy: `${center[1]}`,\n        r: `${radius}`,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n        'fill-opacity': fillOpacity,\n        'stroke-opacity': strokeOpacity,\n    };\n    if (existingCircleElement) {\n        setAttributesIfNecessary(attributes, existingCircleElement);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newCircleElement = document.createElementNS(svgns, 'circle');\n        if (dataId !== '') {\n            newCircleElement.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, newCircleElement);\n        svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);\n    }\n}\nexport default drawCircle;\n","import drawHandle from './drawHandle';\nfunction drawHandles(svgDrawingHelper, annotationUID, handleGroupUID, handlePoints, options = {}) {\n    handlePoints.forEach((handle, i) => {\n        drawHandle(svgDrawingHelper, annotationUID, handleGroupUID, handle, options, i);\n    });\n}\nexport default drawHandles;\n","import drawLine from './drawLine';\nimport findClosestPoint from '../utilities/math/vec2/findClosestPoint';\nfunction drawLink(svgDrawingHelper, annotationUID, linkUID, annotationAnchorPoints, refPoint, boundingBox, options = {}) {\n    const start = annotationAnchorPoints.length > 0\n        ? findClosestPoint(annotationAnchorPoints, refPoint)\n        : refPoint;\n    const boundingBoxPoints = _boundingBoxPoints(boundingBox);\n    const end = findClosestPoint(boundingBoxPoints, start);\n    const mergedOptions = Object.assign({\n        color: 'rgb(255, 255, 0)',\n        lineWidth: '1',\n        lineDash: '2,3',\n    }, options);\n    drawLine(svgDrawingHelper, annotationUID, `link-${linkUID}`, start, end, mergedOptions);\n}\nfunction _boundingBoxPoints(boundingBox) {\n    const { x: left, y: top, height, width } = boundingBox;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const topMiddle = [left + halfWidth, top];\n    const leftMiddle = [left, top + halfHeight];\n    const bottomMiddle = [left + halfWidth, top + height];\n    const rightMiddle = [left + width, top + halfHeight];\n    return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];\n}\nexport default drawLink;\n","import drawTextBox from './drawTextBox';\nimport drawLink from './drawLink';\nfunction drawLinkedTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, annotationAnchorPoints, textBox, options = {}) {\n    const mergedOptions = Object.assign({\n        handleRadius: '6',\n        centering: {\n            x: false,\n            y: true,\n        },\n    }, options);\n    const canvasBoundingBox = drawTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, mergedOptions);\n    drawLink(svgDrawingHelper, annotationUID, textBoxUID, annotationAnchorPoints, textBoxPosition, canvasBoundingBox, mergedOptions);\n    return canvasBoundingBox;\n}\nexport default drawLinkedTextBox;\n","import _getHash from './_getHash';\nimport drawRectByCoordinates from './drawRectByCoordinates';\nexport default function drawRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}, dataId = '') {\n    const topLeft = [start[0], start[1]];\n    const topRight = [end[0], start[1]];\n    const bottomLeft = [start[0], end[1]];\n    const bottomRight = [end[0], end[1]];\n    drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, [topLeft, topRight, bottomLeft, bottomRight], options, dataId);\n}\n","import getDefaultContourConfig from '../../tools/displayTools/Contour/contourConfig';\nimport getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport * as Enums from '../../enums';\nimport { utilities } from '@cornerstonejs/core';\nclass SegmentationStyle {\n    constructor() {\n        this.config = {\n            global: {},\n            segmentations: {},\n            viewportsStyle: {},\n        };\n    }\n    setStyle(specifier, styles) {\n        const { viewportId, segmentationId, type, segmentIndex } = specifier;\n        const currentStyles = this.getStyle(specifier);\n        let updatedStyles;\n        if (!viewportId && !segmentationId) {\n            updatedStyles = {\n                ...currentStyles,\n                ...styles,\n            };\n        }\n        else {\n            updatedStyles = this.copyActiveToInactiveIfNotProvided({\n                ...currentStyles,\n                ...styles,\n            }, type);\n        }\n        if (!type) {\n            throw new Error('Type is required to set a style');\n        }\n        if (viewportId) {\n            if (!this.config.viewportsStyle[viewportId]) {\n                this.config.viewportsStyle[viewportId] = {\n                    renderInactiveSegmentations: false,\n                    representations: {},\n                };\n            }\n            const representations = this.config.viewportsStyle[viewportId].representations;\n            if (segmentationId) {\n                if (!representations[segmentationId]) {\n                    representations[segmentationId] = {};\n                }\n                if (!representations[segmentationId][type]) {\n                    representations[segmentationId][type] = {};\n                }\n                const repConfig = representations[segmentationId][type];\n                if (segmentIndex !== undefined) {\n                    if (!repConfig.perSegment) {\n                        repConfig.perSegment = {};\n                    }\n                    repConfig.perSegment[segmentIndex] = updatedStyles;\n                }\n                else {\n                    repConfig.allSegments = updatedStyles;\n                }\n            }\n            else {\n                const ALL_SEGMENTATIONS_KEY = '__allSegmentations__';\n                if (!representations[ALL_SEGMENTATIONS_KEY]) {\n                    representations[ALL_SEGMENTATIONS_KEY] = {};\n                }\n                if (!representations[ALL_SEGMENTATIONS_KEY][type]) {\n                    representations[ALL_SEGMENTATIONS_KEY][type] = {};\n                }\n                representations[ALL_SEGMENTATIONS_KEY][type].allSegments =\n                    updatedStyles;\n            }\n        }\n        else if (segmentationId) {\n            if (!this.config.segmentations[segmentationId]) {\n                this.config.segmentations[segmentationId] = {};\n            }\n            if (!this.config.segmentations[segmentationId][type]) {\n                this.config.segmentations[segmentationId][type] = {};\n            }\n            const segConfig = this.config.segmentations[segmentationId][type];\n            if (segmentIndex !== undefined) {\n                if (!segConfig.perSegment) {\n                    segConfig.perSegment = {};\n                }\n                segConfig.perSegment[segmentIndex] = updatedStyles;\n            }\n            else {\n                segConfig.allSegments = updatedStyles;\n            }\n        }\n        else {\n            this.config.global[type] = updatedStyles;\n        }\n    }\n    copyActiveToInactiveIfNotProvided(styles, type) {\n        const processedStyles = { ...styles };\n        if (type === Enums.SegmentationRepresentations.Labelmap) {\n            const labelmapStyles = processedStyles;\n            labelmapStyles.renderOutlineInactive ??= labelmapStyles.renderOutline;\n            labelmapStyles.outlineWidthInactive ??= labelmapStyles.outlineWidth;\n            labelmapStyles.renderFillInactive ??= labelmapStyles.renderFill;\n            labelmapStyles.fillAlphaInactive ??= labelmapStyles.fillAlpha;\n            labelmapStyles.outlineOpacityInactive ??= labelmapStyles.outlineOpacity;\n        }\n        else if (type === Enums.SegmentationRepresentations.Contour) {\n            const contourStyles = processedStyles;\n            contourStyles.outlineWidthInactive ??= contourStyles.outlineWidth;\n            contourStyles.outlineOpacityInactive ??= contourStyles.outlineOpacity;\n            contourStyles.outlineDashInactive ??= contourStyles.outlineDash;\n            contourStyles.renderOutlineInactive ??= contourStyles.renderOutline;\n            contourStyles.renderFillInactive ??= contourStyles.renderFill;\n            contourStyles.fillAlphaInactive ??= contourStyles.fillAlpha;\n        }\n        return processedStyles;\n    }\n    getStyle(specifier) {\n        const { viewportId, segmentationId, type, segmentIndex } = specifier;\n        let combinedStyle = this.getDefaultStyle(type);\n        let renderInactiveSegmentations = false;\n        if (this.config.global[type]) {\n            combinedStyle = {\n                ...combinedStyle,\n                ...this.config.global[type],\n            };\n        }\n        if (this.config.segmentations[segmentationId]?.[type]) {\n            combinedStyle = {\n                ...combinedStyle,\n                ...this.config.segmentations[segmentationId][type].allSegments,\n            };\n            if (segmentIndex !== undefined &&\n                this.config.segmentations[segmentationId][type].perSegment?.[segmentIndex]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.segmentations[segmentationId][type].perSegment[segmentIndex],\n                };\n            }\n        }\n        if (viewportId && this.config.viewportsStyle[viewportId]) {\n            renderInactiveSegmentations =\n                this.config.viewportsStyle[viewportId].renderInactiveSegmentations;\n            const allSegmentationsKey = '__allSegmentations__';\n            if (this.config.viewportsStyle[viewportId].representations[allSegmentationsKey]?.[type]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.viewportsStyle[viewportId].representations[allSegmentationsKey][type].allSegments,\n                };\n            }\n            if (segmentationId &&\n                this.config.viewportsStyle[viewportId].representations[segmentationId]?.[type]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].allSegments,\n                };\n                if (segmentIndex !== undefined &&\n                    this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment?.[segmentIndex]) {\n                    combinedStyle = {\n                        ...combinedStyle,\n                        ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment[segmentIndex],\n                    };\n                }\n            }\n        }\n        return combinedStyle;\n    }\n    getRenderInactiveSegmentations(viewportId) {\n        return this.config.viewportsStyle[viewportId]?.renderInactiveSegmentations;\n    }\n    setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {\n        if (!this.config.viewportsStyle[viewportId]) {\n            this.config.viewportsStyle[viewportId] = {\n                renderInactiveSegmentations: false,\n                representations: {},\n            };\n        }\n        this.config.viewportsStyle[viewportId].renderInactiveSegmentations =\n            renderInactiveSegmentations;\n    }\n    getDefaultStyle(type) {\n        switch (type) {\n            case Enums.SegmentationRepresentations.Labelmap:\n                return getDefaultLabelmapConfig();\n            case Enums.SegmentationRepresentations.Contour:\n                return getDefaultContourConfig();\n            case Enums.SegmentationRepresentations.Surface:\n                return {};\n            default:\n                throw new Error(`Unknown representation type: ${type}`);\n        }\n    }\n    clearSegmentationStyle(segmentationId) {\n        if (this.config.segmentations[segmentationId]) {\n            delete this.config.segmentations[segmentationId];\n        }\n    }\n    clearAllSegmentationStyles() {\n        this.config.segmentations = {};\n    }\n    clearViewportStyle(viewportId) {\n        if (this.config.viewportsStyle[viewportId]) {\n            delete this.config.viewportsStyle[viewportId];\n        }\n    }\n    clearAllViewportStyles() {\n        for (const viewportId in this.config.viewportsStyle) {\n            const viewportStyle = this.config.viewportsStyle[viewportId];\n            const renderInactiveSegmentations = viewportStyle.renderInactiveSegmentations;\n            this.config.viewportsStyle[viewportId] = {\n                renderInactiveSegmentations,\n                representations: {},\n            };\n        }\n    }\n    resetToGlobalStyle() {\n        this.clearAllSegmentationStyles();\n        this.clearAllViewportStyles();\n    }\n    hasCustomStyle(specifier) {\n        const { type } = specifier;\n        const style = this.getStyle(specifier);\n        const defaultStyle = this.getDefaultStyle(type);\n        return !utilities.deepEqual(style, defaultStyle);\n    }\n}\nconst segmentationStyle = new SegmentationStyle();\nexport { segmentationStyle };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nimport { setSegmentationDirty } from '../../../utilities/segmentation/utilities';\nexport function triggerSegmentationDataModified(segmentationId, modifiedSlicesToUse, segmentIndex) {\n    const eventDetail = {\n        segmentationId,\n        modifiedSlicesToUse,\n        segmentIndex,\n    };\n    setSegmentationDirty(segmentationId);\n    triggerEvent(eventTarget, Events.SEGMENTATION_DATA_MODIFIED, eventDetail);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getActiveSegmentation(viewportId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getActiveSegmentation(viewportId);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentationRepresentationVisibility(viewportId, specifier) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentationVisibility(viewportId, specifier);\n}\n","import { getSegmentation } from './getSegmentation';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nfunction internalAddRepresentationData({ segmentationId, type, data, }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`Segmentation ${segmentationId} not found`);\n    }\n    if (segmentation.representationData[type]) {\n        console.warn(`Representation data of type ${type} already exists for segmentation ${segmentationId}, overwriting it.`);\n    }\n    switch (type) {\n        case SegmentationRepresentations.Labelmap:\n            if (data) {\n                segmentation.representationData[type] =\n                    data;\n            }\n            break;\n        case SegmentationRepresentations.Contour:\n            if (data) {\n                segmentation.representationData[type] = data;\n            }\n            break;\n        case SegmentationRepresentations.Surface:\n            if (data) {\n                segmentation.representationData[type] = data;\n            }\n            break;\n        default:\n            throw new Error(`Invalid representation type ${type}`);\n    }\n}\nexport default internalAddRepresentationData;\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { state } from '../state';\nfunction getToolGroupForViewport(viewportId, renderingEngineId) {\n    if (!renderingEngineId) {\n        renderingEngineId = getRenderingEngines().find((re) => re.getViewports().find((vp) => vp.id === viewportId))?.id;\n    }\n    const toolGroupFilteredByIds = state.toolGroups.filter((tg) => tg.viewportsInfo.some((vp) => vp.renderingEngineId === renderingEngineId &&\n        (!vp.viewportId || vp.viewportId === viewportId)));\n    if (!toolGroupFilteredByIds.length) {\n        return;\n    }\n    if (toolGroupFilteredByIds.length > 1) {\n        throw new Error(`Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only\n      have one tool group per viewport in a renderingEngine.`);\n    }\n    return toolGroupFilteredByIds[0];\n}\nexport default getToolGroupForViewport;\n","import { utilities } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport PlanarFreehandROITool from './PlanarFreehandROITool';\nclass PlanarFreehandContourSegmentationTool extends PlanarFreehandROITool {\n    static { this.toolName = 'PlanarFreehandContourSegmentationTool'; }\n    constructor(toolProps) {\n        const initialProps = utilities.deepMerge({\n            configuration: {\n                calculateStats: false,\n                allowOpenContours: false,\n            },\n        }, toolProps);\n        super(initialProps);\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    renderAnnotationInstance(renderContext) {\n        const annotation = renderContext.annotation;\n        const { invalidated } = annotation;\n        const renderResult = super.renderAnnotationInstance(renderContext);\n        if (invalidated) {\n            const { segmentationId } = annotation.data.segmentation;\n            triggerSegmentationDataModified(segmentationId);\n        }\n        return renderResult;\n    }\n}\nexport default PlanarFreehandContourSegmentationTool;\n","import { AnnotationTool } from '../base';\nimport { CONSTANTS, getEnabledElement, VolumeViewport, utilities as csUtils, metaData, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport * as math from '../../utilities/math';\nimport { polyline } from '../../utilities/math';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { drawLinkedTextBox } from '../../drawingSvg';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getLineSegmentIntersectionsCoordinates } from '../../utilities/math/polyline';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport calculatePerimeter from '../../utilities/contours/calculatePerimeter';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { KeyboardBindings, ChangeTypes } from '../../enums';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nconst { pointCanProjectOnLine } = polyline;\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nclass PlanarFreehandROITool extends ContourSegmentationBaseTool {\n    static { this.toolName = 'PlanarFreehandROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            storePointData: false,\n            shadow: true,\n            preventHandleOutsideImage: false,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            alwaysRenderOpenContourHandles: {\n                enabled: false,\n                radius: 2,\n            },\n            allowOpenContours: true,\n            closeContourProximity: 10,\n            checkCanvasEditFallbackProximity: 6,\n            makeClockWise: true,\n            subPixelResolution: 4,\n            smoothing: {\n                smoothOnAdd: false,\n                smoothOnEdit: false,\n                knotsRatioPercentageOnAdd: 40,\n                knotsRatioPercentageOnEdit: 40,\n            },\n            interpolation: {\n                enabled: false,\n                onInterpolationComplete: null,\n            },\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            displayOnePointAsCrosshairs: false,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isDrawing = false;\n        this.isEditingClosed = false;\n        this.isEditingOpen = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const annotation = this.createAnnotation(evt);\n            this.addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.activateDraw(evt, annotation, viewportIdsToRender);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle);\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            if (annotation.data.contour.closed) {\n                this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n            }\n            else {\n                this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\n            }\n            evt.preventDefault();\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { polyline: points } = annotation.data.contour;\n            let previousPoint = viewport.worldToCanvas(points[0]);\n            for (let i = 1; i < points.length; i++) {\n                const p1 = previousPoint;\n                const p2 = viewport.worldToCanvas(points[i]);\n                const canProject = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\n                if (canProject) {\n                    return true;\n                }\n                previousPoint = p2;\n            }\n            if (!annotation.data.contour.closed) {\n                return false;\n            }\n            const pStart = viewport.worldToCanvas(points[0]);\n            const pEnd = viewport.worldToCanvas(points[points.length - 1]);\n            return pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);\n        };\n        this.cancel = (element) => {\n            const isDrawing = this.isDrawing;\n            const isEditingOpen = this.isEditingOpen;\n            const isEditingClosed = this.isEditingClosed;\n            if (isDrawing) {\n                this.cancelDrawing(element);\n            }\n            else if (isEditingOpen) {\n                this.cancelOpenContourEdit(element);\n            }\n            else if (isEditingClosed) {\n                this.cancelClosedContourEdit(element);\n            }\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { cachedStats } = data;\n            const { polyline: points, closed } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const modalityUnitOptions = {\n                    isPreScaled: isViewportPreScaled(viewport, targetId),\n                    isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                };\n                const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);\n                const calibratedScale = getCalibratedLengthUnitsAndScale(image, () => {\n                    const polyline = data.contour.polyline;\n                    const numPoints = polyline.length;\n                    const projectedPolyline = new Array(numPoints);\n                    for (let i = 0; i < numPoints; i++) {\n                        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n                    }\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(projectedPolyline);\n                    const topLeftBBWorld = viewport.canvasToWorld([canvasMinX, canvasMinY]);\n                    const topLeftBBIndex = csUtils.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = csUtils.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                const canvasPoint = canvasCoordinates[0];\n                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n                const deltaXPoint = viewport.canvasToWorld([\n                    canvasPoint[0] + 1,\n                    canvasPoint[1],\n                ]);\n                const deltaYPoint = viewport.canvasToWorld([\n                    canvasPoint[0],\n                    canvasPoint[1] + 1,\n                ]);\n                const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n                const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n                if (closed) {\n                    this.updateClosedCachedStats({\n                        targetId,\n                        viewport,\n                        canvasCoordinates,\n                        points,\n                        imageData,\n                        metadata,\n                        cachedStats,\n                        modalityUnit,\n                        calibratedScale,\n                        deltaInX,\n                        deltaInY,\n                    });\n                }\n                else {\n                    this.updateOpenCachedStats({\n                        metadata,\n                        targetId,\n                        cachedStats,\n                        modalityUnit,\n                        calibratedScale,\n                        points,\n                    });\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._renderStats = (annotation, viewport, enabledElement, svgDrawingHelper) => {\n            const { data } = annotation;\n            const targetId = this.getTargetId(viewport);\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n                annotationUID: annotation.annotationUID,\n            };\n            const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n            if (!options.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.contour.polyline.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = '1';\n            const boundingBox = drawLinkedTextBox(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        registerDrawLoop(this);\n        registerEditLoopCommon(this);\n        registerClosedContourEditLoop(this);\n        registerOpenContourEditLoop(this);\n        registerOpenContourEndEditLoop(this);\n        registerRenderMethods(this);\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!annotations || !annotations.length) {\n            return;\n        }\n        const baseFilteredAnnotations = super.filterInteractableAnnotationsForElement(element, annotations);\n        if (!baseFilteredAnnotations || !baseFilteredAnnotations.length) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let annotationsToDisplay;\n        if (viewport instanceof VolumeViewport) {\n            const camera = viewport.getCamera();\n            const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n            annotationsToDisplay = this.filterAnnotationsWithinSlice(baseFilteredAnnotations, camera, spacingInNormalDirection);\n        }\n        else {\n            annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\n        }\n        return annotationsToDisplay;\n    }\n    filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {\n        const { viewPlaneNormal } = camera;\n        const annotationsWithParallelNormals = annotations.filter((td) => {\n            let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n            if (!td.metadata.referencedImageId &&\n                !annotationViewPlaneNormal &&\n                td.metadata.FrameOfReferenceUID) {\n                for (const point of td.data.contour.polyline) {\n                    const vector = vec3.sub(vec3.create(), point, camera.focalPoint);\n                    const dotProduct = vec3.dot(vector, camera.viewPlaneNormal);\n                    if (!csUtils.isEqual(dotProduct, 0)) {\n                        return false;\n                    }\n                }\n                td.metadata.viewPlaneNormal = camera.viewPlaneNormal;\n                td.metadata.cameraFocalPoint = camera.focalPoint;\n                return true;\n            }\n            if (!annotationViewPlaneNormal) {\n                const { referencedImageId } = td.metadata;\n                const { imageOrientationPatient } = metaData.get('imagePlaneModule', referencedImageId);\n                const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n                const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n                annotationViewPlaneNormal = vec3.create();\n                vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n                td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n            }\n            const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n                PARALLEL_THRESHOLD;\n            return annotationViewPlaneNormal && isParallel;\n        });\n        if (!annotationsWithParallelNormals.length) {\n            return [];\n        }\n        const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n        const { focalPoint } = camera;\n        const annotationsWithinSlice = [];\n        for (const annotation of annotationsWithParallelNormals) {\n            const data = annotation.data;\n            const point = data.contour.polyline[0];\n            if (!annotation.isVisible) {\n                continue;\n            }\n            const dir = vec3.create();\n            vec3.sub(dir, focalPoint, point);\n            const dot = vec3.dot(dir, viewPlaneNormal);\n            if (Math.abs(dot) < halfSpacingInNormalDirection) {\n                annotationsWithinSlice.push(annotation);\n            }\n        }\n        return annotationsWithinSlice;\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    createAnnotation(evt) {\n        const worldPos = evt.detail.currentPoints.world;\n        const contourAnnotation = super.createAnnotation(evt);\n        const onInterpolationComplete = (annotation) => {\n            annotation.data.handles.points.length = 0;\n        };\n        const annotation = csUtils.deepMerge(contourAnnotation, {\n            data: {\n                contour: {\n                    polyline: [[...worldPos]],\n                },\n                label: '',\n                cachedStats: {},\n            },\n            onInterpolationComplete,\n        });\n        return annotation;\n    }\n    getAnnotationStyle(context) {\n        return super.getAnnotationStyle(context);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, targetId, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        let renderStatus = false;\n        const { viewport, renderingEngine } = enabledElement;\n        const isDrawing = this.isDrawing;\n        const isEditingOpen = this.isEditingOpen;\n        const isEditingClosed = this.isEditingClosed;\n        if (!(isDrawing || isEditingOpen || isEditingClosed)) {\n            if (this.configuration.displayOnePointAsCrosshairs &&\n                annotation.data.contour.polyline.length === 1) {\n                this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);\n            }\n            else {\n                this.renderContour(enabledElement, svgDrawingHelper, annotation);\n            }\n        }\n        else {\n            const activeAnnotationUID = this.commonData.annotation.annotationUID;\n            if (annotation.annotationUID === activeAnnotationUID) {\n                if (isDrawing) {\n                    this.renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation);\n                }\n                else if (isEditingClosed) {\n                    this.renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                }\n                else if (isEditingOpen) {\n                    this.renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                }\n                else {\n                    throw new Error(`Unknown ${this.getToolName()} annotation rendering state`);\n                }\n            }\n            else {\n                if (this.configuration.displayOnePointAsCrosshairs &&\n                    annotation.data.contour.polyline.length === 1) {\n                    this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);\n                }\n                else {\n                    this.renderContour(enabledElement, svgDrawingHelper, annotation);\n                }\n            }\n            renderStatus = true;\n        }\n        if (!this.configuration.calculateStats) {\n            return;\n        }\n        if (annotation.invalidated) {\n            this._calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement);\n        }\n        this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\n        return renderStatus;\n    }\n    _calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement) {\n        const activeAnnotationUID = this.commonData?.annotation.annotationUID;\n        if (annotation.annotationUID === activeAnnotationUID &&\n            !this.commonData?.movingTextBox) {\n            return;\n        }\n        if (!this.commonData?.movingTextBox) {\n            const { data } = annotation;\n            if (!data.cachedStats[targetId]?.unit) {\n                data.cachedStats[targetId] = {\n                    Modality: null,\n                    area: null,\n                    max: null,\n                    mean: null,\n                    stdDev: null,\n                    areaUnit: null,\n                    unit: null,\n                };\n                this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n            }\n            else if (annotation.invalidated) {\n                this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n            }\n        }\n    }\n    updateClosedCachedStats({ viewport, points, imageData, metadata, cachedStats, targetId, modalityUnit, canvasCoordinates, calibratedScale, deltaInX, deltaInY, }) {\n        const { scale, areaUnit, unit } = calibratedScale;\n        const { voxelManager } = viewport.getImageData();\n        const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\n        worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n        worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n        worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n        let iMin = worldPosIndex[0];\n        let iMax = worldPosIndex[0];\n        let jMin = worldPosIndex[1];\n        let jMax = worldPosIndex[1];\n        let kMin = worldPosIndex[2];\n        let kMax = worldPosIndex[2];\n        for (let j = 1; j < points.length; j++) {\n            const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[j]);\n            worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n            worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n            worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n            iMin = Math.min(iMin, worldPosIndex[0]);\n            iMax = Math.max(iMax, worldPosIndex[0]);\n            jMin = Math.min(jMin, worldPosIndex[1]);\n            jMax = Math.max(jMax, worldPosIndex[1]);\n            kMin = Math.min(kMin, worldPosIndex[2]);\n            kMax = Math.max(kMax, worldPosIndex[2]);\n        }\n        const worldPosIndex2 = csUtils.transformWorldToIndex(imageData, points[1]);\n        worldPosIndex2[0] = Math.floor(worldPosIndex2[0]);\n        worldPosIndex2[1] = Math.floor(worldPosIndex2[1]);\n        worldPosIndex2[2] = Math.floor(worldPosIndex2[2]);\n        let area = polyline.getArea(canvasCoordinates) / scale / scale;\n        area *= deltaInX * deltaInY;\n        const perimeter = calculatePerimeter(points, closed) / scale;\n        const iDelta = 0.01 * (iMax - iMin);\n        const jDelta = 0.01 * (jMax - jMin);\n        const kDelta = 0.01 * (kMax - kMin);\n        iMin = Math.floor(iMin - iDelta);\n        iMax = Math.ceil(iMax + iDelta);\n        jMin = Math.floor(jMin - jDelta);\n        jMax = Math.ceil(jMax + jDelta);\n        kMin = Math.floor(kMin - kDelta);\n        kMax = Math.ceil(kMax + kDelta);\n        const boundsIJK = [\n            [iMin, iMax],\n            [jMin, jMax],\n            [kMin, kMax],\n        ];\n        const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\n        const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\n        let curRow = 0;\n        let intersections = [];\n        let intersectionCounter = 0;\n        let pointsInShape;\n        if (voxelManager) {\n            pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                imageData,\n                isInObject: (pointLPS, _pointIJK) => {\n                    let result = true;\n                    const point = viewport.worldToCanvas(pointLPS);\n                    if (point[1] != curRow) {\n                        intersectionCounter = 0;\n                        curRow = point[1];\n                        intersections = getLineSegmentIntersectionsCoordinates(canvasCoordinates, point, [canvasPosEnd[0], point[1]]);\n                        intersections.sort((function (index) {\n                            return function (a, b) {\n                                return a[index] === b[index]\n                                    ? 0\n                                    : a[index] < b[index]\n                                        ? -1\n                                        : 1;\n                            };\n                        })(0));\n                    }\n                    if (intersections.length && point[0] > intersections[0][0]) {\n                        intersections.shift();\n                        intersectionCounter++;\n                    }\n                    if (intersectionCounter % 2 === 0) {\n                        result = false;\n                    }\n                    return result;\n                },\n                boundsIJK,\n                returnPoints: this.configuration.storePointData,\n            });\n        }\n        const stats = this.configuration.statsCalculator.getStatistics();\n        cachedStats[targetId] = {\n            Modality: metadata.Modality,\n            area,\n            perimeter,\n            mean: stats.mean?.value,\n            max: stats.max?.value,\n            min: stats.min?.value,\n            stdDev: stats.stdDev?.value,\n            statsArray: stats.array,\n            pointsInShape: pointsInShape,\n            areaUnit,\n            modalityUnit,\n            unit,\n        };\n    }\n    updateOpenCachedStats({ targetId, metadata, cachedStats, modalityUnit, calibratedScale, points, }) {\n        const { scale, unit } = calibratedScale;\n        const length = calculatePerimeter(points, closed) / scale;\n        cachedStats[targetId] = {\n            Modality: metadata.Modality,\n            length,\n            modalityUnit,\n            unit,\n        };\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, stdDev, length, perimeter, max, min, isEmptyArea, unit, areaUnit, modalityUnit, } = cachedVolumeStats || {};\n    const textLines = [];\n    if (csUtils.isNumber(area)) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (csUtils.isNumber(mean)) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(min)) {\n        textLines.push(`Min: ${csUtils.roundNumber(min)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(stdDev)) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(perimeter)) {\n        textLines.push(`Perimeter: ${csUtils.roundNumber(perimeter)} ${unit}`);\n    }\n    if (csUtils.isNumber(length)) {\n        textLines.push(`${csUtils.roundNumber(length)} ${unit}`);\n    }\n    return textLines;\n}\nexport default PlanarFreehandROITool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawRectByCoordinates as drawRectSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass RectangleROITool extends AnnotationTool {\n    static { this.toolName = 'RectangleROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            storePointData: false,\n            shadow: true,\n            preventHandleOutsideImage: false,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    cachedStats: {},\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasPoint1 = viewport.worldToCanvas(points[0]);\n            const canvasPoint2 = viewport.worldToCanvas(points[3]);\n            const rect = this._getRectangleImageCoordinates([\n                canvasPoint1,\n                canvasPoint2,\n            ]);\n            const point = [canvasCoords[0], canvasCoords[1]];\n            const { left, top, width, height } = rect;\n            const distanceToPoint = rectangle.distanceToPoint([left, top, width, height], point);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.doneEditMemo();\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { points } = data.handles;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const enabledElement = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n                const worldPos = currentPoints.world;\n                const { points } = data.handles;\n                points[handleIndex] = [...worldPos];\n                let bottomLeftCanvas;\n                let bottomRightCanvas;\n                let topLeftCanvas;\n                let topRightCanvas;\n                let bottomLeftWorld;\n                let bottomRightWorld;\n                let topLeftWorld;\n                let topRightWorld;\n                switch (handleIndex) {\n                    case 0:\n                    case 3:\n                        bottomLeftCanvas = worldToCanvas(points[0]);\n                        topRightCanvas = worldToCanvas(points[3]);\n                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                        topLeftWorld = canvasToWorld(topLeftCanvas);\n                        points[1] = bottomRightWorld;\n                        points[2] = topLeftWorld;\n                        break;\n                    case 1:\n                    case 2:\n                        bottomRightCanvas = worldToCanvas(points[1]);\n                        topLeftCanvas = worldToCanvas(points[2]);\n                        bottomLeftCanvas = [\n                            topLeftCanvas[0],\n                            bottomRightCanvas[1],\n                        ];\n                        topRightCanvas = [\n                            bottomRightCanvas[0],\n                            topLeftCanvas[1],\n                        ];\n                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                        topRightWorld = canvasToWorld(topRightCanvas);\n                        points[0] = bottomLeftWorld;\n                        points[3] = topRightWorld;\n                        break;\n                }\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const { viewPlaneNormal, viewUp } = viewport.getCamera();\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                    };\n                    this._calculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null &&\n                    activeHandleIndex !== undefined) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, showHandlesAlways ? canvasCoordinates : activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-rect`;\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._getRectangleImageCoordinates = (points) => {\n            const [point0, point1] = points;\n            return {\n                left: Math.min(point0[0], point1[0]),\n                top: Math.min(point0[1], point1[1]),\n                width: Math.abs(point0[0] - point1[0]),\n                height: Math.abs(point0[1] - point1[1]),\n            };\n        };\n        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const { data } = annotation;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const pos2Index = transformWorldToIndex(imageData, worldPos2);\n                pos2Index[0] = Math.floor(pos2Index[0]);\n                pos2Index[1] = Math.floor(pos2Index[1]);\n                pos2Index[2] = Math.floor(pos2Index[2]);\n                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n                    this.isHandleOutsideImage = false;\n                    const iMin = Math.min(pos1Index[0], pos2Index[0]);\n                    const iMax = Math.max(pos1Index[0], pos2Index[0]);\n                    const jMin = Math.min(pos1Index[1], pos2Index[1]);\n                    const jMax = Math.max(pos1Index[1], pos2Index[1]);\n                    const kMin = Math.min(pos1Index[2], pos2Index[2]);\n                    const kMax = Math.max(pos1Index[2], pos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const handles = [pos1Index, pos2Index];\n                    const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                    const area = Math.abs(worldWidth * worldHeight) / (scale * scale);\n                    const pixelUnitsOptions = {\n                        isPreScaled: isViewportPreScaled(viewport, targetId),\n                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                    };\n                    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                    let pointsInShape;\n                    if (voxelManager) {\n                        pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                            boundsIJK,\n                            imageData,\n                            returnPoints: this.configuration.storePointData,\n                        });\n                    }\n                    const stats = this.configuration.statsCalculator.getStatistics();\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean: stats.mean?.value,\n                        stdDev: stats.stdDev?.value,\n                        max: stats.max?.value,\n                        min: stats.min?.value,\n                        statsArray: stats.array,\n                        pointsInShape: pointsInShape,\n                        areaUnit,\n                        modalityUnit,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(RectangleROITool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, max, stdDev, areaUnit, modalityUnit, min } = cachedVolumeStats;\n    if (mean === undefined || mean === null) {\n        return;\n    }\n    const textLines = [];\n    if (csUtils.isNumber(area)) {\n        textLines.push(`Area: ${csUtils.roundNumber(area)} ${areaUnit}`);\n    }\n    if (csUtils.isNumber(mean)) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(min)) {\n        textLines.push(`Min: ${csUtils.roundNumber(min)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(stdDev)) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default RectangleROITool;\n","import { getEnabledElement, cache, utilities as csUtils, Enums, eventTarget, BaseVolumeViewport, StackViewport, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getLockedSegmentIndices } from '../../stateManagement/segmentation/segmentLocking';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { getCurrentLabelmapImageIdForViewport } from '../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { StrategyCallbacks } from '../../enums';\nimport * as LabelmapMemo from '../../utilities/segmentation/createLabelmapMemo';\nimport { getAllAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport { isPointInsidePolyline3D } from '../../utilities/math/polyline';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { fillInsideCircle } from './strategies';\nexport default class LabelmapBaseTool extends BaseTool {\n    static { this.previewData = {\n        preview: null,\n        element: null,\n        timerStart: 0,\n        timer: null,\n        startPoint: [NaN, NaN],\n        isDrag: false,\n    }; }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        this.memoMap = new Map();\n        this.acceptedMemoIds = new Map();\n        this.centerSegmentIndexInfo = {\n            segmentIndex: null,\n            hasSegmentIndex: false,\n            hasPreviewIndex: false,\n            changedIndices: [],\n        };\n    }\n    _historyRedoHandler(evt) {\n        const { id, operationType } = evt.detail;\n        if (operationType !== 'labelmap') {\n            return;\n        }\n        if (this.acceptedMemoIds.has(id)) {\n            this._hoverData = null;\n            const memoData = this.acceptedMemoIds.get(id);\n            const element = memoData?.element;\n            const operationData = this.getOperationData(element);\n            operationData.segmentIndex = memoData?.segmentIndex;\n            if (element) {\n                this.applyActiveStrategyCallback(getEnabledElement(element), operationData, StrategyCallbacks.AcceptPreview);\n            }\n        }\n        this._previewData.isDrag = true;\n    }\n    get _previewData() {\n        return LabelmapBaseTool.previewData;\n    }\n    hasPreviewData() {\n        return !!this._previewData.preview;\n    }\n    shouldResolvePreviewRequests() {\n        return ((this.mode === 'Active' || this.mode === 'Enabled') &&\n            this.hasPreviewData());\n    }\n    createMemo(segmentationId, segmentationVoxelManager) {\n        const voxelManagerId = segmentationVoxelManager.id;\n        if (this.memo &&\n            this.memo.segmentationVoxelManager === segmentationVoxelManager) {\n            return this.memo;\n        }\n        let memo = this.memoMap.get(voxelManagerId);\n        if (!memo) {\n            memo = LabelmapMemo.createLabelmapMemo(segmentationId, segmentationVoxelManager);\n            this.memoMap.set(voxelManagerId, memo);\n        }\n        else {\n            if (memo.redoVoxelManager) {\n                memo = LabelmapMemo.createLabelmapMemo(segmentationId, segmentationVoxelManager);\n                this.memoMap.set(voxelManagerId, memo);\n            }\n        }\n        this.memo = memo;\n        return memo;\n    }\n    createEditData(element) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const activeSegmentation = getActiveSegmentation(viewport.id);\n        if (!activeSegmentation) {\n            const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n                detail: {\n                    type: 'Segmentation',\n                    message: 'No active segmentation detected, create a segmentation representation before using the brush tool',\n                },\n                cancelable: true,\n            });\n            eventTarget.dispatchEvent(event);\n            return null;\n        }\n        const { segmentationId } = activeSegmentation;\n        const segmentsLocked = getLockedSegmentIndices(segmentationId);\n        const { representationData } = getSegmentation(segmentationId);\n        const editData = this.getEditData({\n            viewport,\n            representationData,\n            segmentsLocked,\n            segmentationId,\n        });\n        return editData;\n    }\n    getEditData({ viewport, representationData, segmentsLocked, segmentationId, }) {\n        if (viewport instanceof BaseVolumeViewport) {\n            const { volumeId } = representationData[SegmentationRepresentations.Labelmap];\n            const actors = viewport.getActors();\n            const isStackViewport = viewport instanceof StackViewport;\n            if (isStackViewport) {\n                const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n                    detail: {\n                        type: 'Segmentation',\n                        message: 'Cannot perform brush operation on the selected viewport',\n                    },\n                    cancelable: true,\n                });\n                eventTarget.dispatchEvent(event);\n                return null;\n            }\n            const volumes = actors.map((actorEntry) => cache.getVolume(actorEntry.referencedId));\n            const segmentationVolume = cache.getVolume(volumeId);\n            const referencedVolumeIdToThreshold = volumes.find((volume) => csUtils.isEqual(volume.dimensions, segmentationVolume.dimensions))?.volumeId || volumes[0]?.volumeId;\n            return {\n                volumeId,\n                referencedVolumeId: this.configuration.threshold?.volumeId ??\n                    referencedVolumeIdToThreshold,\n                segmentsLocked,\n            };\n        }\n        else {\n            const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n            if (!segmentationImageId) {\n                return;\n            }\n            return {\n                imageId: segmentationImageId,\n                segmentsLocked,\n            };\n        }\n    }\n    createHoverData(element, centerCanvas) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const viewportIdsToRender = [viewport.id];\n        const { segmentIndex, segmentationId, segmentColor } = this.getActiveSegmentationData(viewport) || {};\n        const brushCursor = {\n            metadata: {\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                referencedImageId: '',\n                toolName: this.getToolName(),\n                segmentColor,\n            },\n            data: {},\n        };\n        return {\n            brushCursor,\n            centerCanvas,\n            segmentIndex,\n            viewport,\n            segmentationId,\n            segmentColor,\n            viewportIdsToRender,\n        };\n    }\n    getActiveSegmentationData(viewport) {\n        const viewportId = viewport.id;\n        const activeRepresentation = getActiveSegmentation(viewportId);\n        if (!activeRepresentation) {\n            return;\n        }\n        const { segmentationId } = activeRepresentation;\n        const segmentIndex = getActiveSegmentIndex(segmentationId);\n        if (!segmentIndex) {\n            return;\n        }\n        const segmentColor = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n        return {\n            segmentIndex,\n            segmentationId,\n            segmentColor,\n        };\n    }\n    getOperationData(element) {\n        const editData = this._editData || this.createEditData(element);\n        const { segmentIndex, segmentationId, brushCursor } = this._hoverData || this.createHoverData(element);\n        const { data, metadata = {} } = brushCursor || {};\n        const { viewPlaneNormal, viewUp } = metadata;\n        const configColor = this.configuration.preview?.previewColors?.[segmentIndex];\n        const { viewport } = getEnabledElement(element);\n        const segmentColor = getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n        if (!configColor && !segmentColor) {\n            return;\n        }\n        let previewColor = null, previewSegmentIndex = null;\n        if (this.configuration.preview?.enabled) {\n            previewColor = configColor || lightenColor(...segmentColor);\n            previewSegmentIndex = 255;\n        }\n        const operationData = {\n            ...editData,\n            points: data?.handles?.points,\n            segmentIndex,\n            viewPlaneNormal,\n            previewOnHover: !this._previewData.isDrag,\n            toolGroupId: this.toolGroupId,\n            segmentationId,\n            viewUp,\n            centerSegmentIndexInfo: this.centerSegmentIndexInfo,\n            activeStrategy: this.configuration.activeStrategy,\n            configuration: this.configuration,\n            previewColor,\n            previewSegmentIndex,\n            createMemo: this.createMemo.bind(this),\n        };\n        return operationData;\n    }\n    addPreview(element = this._previewData.element, options) {\n        const { _previewData } = this;\n        const acceptReject = options?.acceptReject;\n        if (acceptReject === true) {\n            this.acceptPreview(element);\n        }\n        else if (acceptReject === false) {\n            this.rejectPreview(element);\n        }\n        const enabledElement = getEnabledElement(element);\n        const results = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.AddPreview);\n        _previewData.isDrag = true;\n        if (results?.modified) {\n            _previewData.preview = results;\n            _previewData.element = element;\n        }\n        return results;\n    }\n    rejectPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        this.doneEditMemo();\n        const enabledElement = getEnabledElement(element);\n        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.RejectPreview);\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    acceptPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        const operationData = this.getOperationData(element);\n        if (this.memo && this.memo.id) {\n            this.acceptedMemoIds.set(this.memo.id, {\n                element,\n                segmentIndex: operationData.segmentIndex,\n            });\n        }\n        const enabledElement = getEnabledElement(element);\n        this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.AcceptPreview);\n        this.doneEditMemo();\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    static viewportContoursToLabelmap(viewport, options) {\n        const removeContours = options?.removeContours ?? true;\n        const annotations = getAllAnnotations();\n        const viewAnnotations = filterAnnotationsForDisplay(viewport, annotations);\n        if (!viewAnnotations?.length) {\n            return;\n        }\n        const contourAnnotations = viewAnnotations.filter((annotation) => annotation.data.contour?.polyline?.length);\n        if (!contourAnnotations.length) {\n            return;\n        }\n        const brushInstance = new LabelmapBaseTool({}, {\n            configuration: {\n                strategies: {\n                    FILL_INSIDE_CIRCLE: fillInsideCircle,\n                },\n                activeStrategy: 'FILL_INSIDE_CIRCLE',\n            },\n        });\n        const preview = brushInstance.addPreview(viewport.element);\n        const { memo, segmentationId } = preview;\n        const previewVoxels = memo?.voxelManager;\n        const segmentationVoxels = previewVoxels.sourceVoxelManager || previewVoxels;\n        const { dimensions } = previewVoxels;\n        const imageData = viewport\n            .getDefaultActor()\n            .actor.getMapper()\n            .getInputData();\n        for (const annotation of contourAnnotations) {\n            const boundsIJK = [\n                [Infinity, -Infinity],\n                [Infinity, -Infinity],\n                [Infinity, -Infinity],\n            ];\n            const { polyline } = annotation.data.contour;\n            for (const point of polyline) {\n                const indexPoint = imageData.worldToIndex(point);\n                indexPoint.forEach((v, idx) => {\n                    boundsIJK[idx][0] = Math.min(boundsIJK[idx][0], v);\n                    boundsIJK[idx][1] = Math.max(boundsIJK[idx][1], v);\n                });\n            }\n            boundsIJK.forEach((bound, idx) => {\n                bound[0] = Math.round(Math.max(0, bound[0]));\n                bound[1] = Math.round(Math.min(dimensions[idx] - 1, bound[1]));\n            });\n            const activeIndex = getActiveSegmentIndex(segmentationId);\n            const startPoint = annotation.data.handles?.[0] || polyline[0];\n            const startIndex = imageData.worldToIndex(startPoint).map(Math.round);\n            const startValue = segmentationVoxels.getAtIJKPoint(startIndex) || 0;\n            let hasZeroIndex = false;\n            let hasPositiveIndex = false;\n            for (const polyPoint of polyline) {\n                const polyIndex = imageData.worldToIndex(polyPoint).map(Math.round);\n                const polyValue = segmentationVoxels.getAtIJKPoint(polyIndex);\n                if (polyValue === startValue) {\n                    hasZeroIndex = true;\n                }\n                else if (polyValue >= 0) {\n                    hasPositiveIndex = true;\n                }\n            }\n            const hasBoth = hasZeroIndex && hasPositiveIndex;\n            const segmentIndex = hasBoth\n                ? startValue\n                : startValue === 0\n                    ? activeIndex\n                    : 0;\n            for (let i = boundsIJK[0][0]; i <= boundsIJK[0][1]; i++) {\n                for (let j = boundsIJK[1][0]; j <= boundsIJK[1][1]; j++) {\n                    for (let k = boundsIJK[2][0]; k <= boundsIJK[2][1]; k++) {\n                        const worldPoint = imageData.indexToWorld([i, j, k]);\n                        const isContained = isPointInsidePolyline3D(worldPoint, polyline);\n                        if (isContained) {\n                            previewVoxels.setAtIJK(i, j, k, segmentIndex);\n                        }\n                    }\n                }\n            }\n            if (removeContours) {\n                removeAnnotation(annotation.annotationUID);\n            }\n        }\n        const slices = previewVoxels.getArrayOfModifiedSlices();\n        triggerSegmentationDataModified(segmentationId, slices);\n    }\n}\nfunction lightenColor(r, g, b, a, factor = 0.4) {\n    return [\n        Math.round(r + (255 - r) * factor),\n        Math.round(g + (255 - g) * factor),\n        Math.round(b + (255 - b) * factor),\n        a,\n    ];\n}\n","import isObject from './isObject';\nfunction debounce(func, wait, options) {\n    let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n    let lastInvokeTime = 0;\n    let leading = false;\n    let maxing = false;\n    let trailing = true;\n    const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n    wait = Number(wait) || 0;\n    if (isObject(options)) {\n        leading = Boolean(options.leading);\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n    }\n    function invokeFunc(time) {\n        const args = lastArgs;\n        const thisArg = lastThis;\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n    function startTimer(pendingFunc, wait) {\n        if (useRAF) {\n            return window.requestAnimationFrame(pendingFunc);\n        }\n        return setTimeout(pendingFunc, wait);\n    }\n    function cancelTimer(id) {\n        if (useRAF) {\n            return window.cancelAnimationFrame(id);\n        }\n        clearTimeout(id);\n    }\n    function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = startTimer(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n    }\n    function remainingWait(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        const timeWaiting = wait - timeSinceLastCall;\n        return maxing\n            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n            : timeWaiting;\n    }\n    function shouldInvoke(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        return (lastCallTime === undefined ||\n            timeSinceLastCall >= wait ||\n            timeSinceLastCall < 0 ||\n            (maxing && timeSinceLastInvoke >= maxWait));\n    }\n    function timerExpired() {\n        const time = Date.now();\n        if (shouldInvoke(time)) {\n            return trailingEdge(time);\n        }\n        timerId = startTimer(timerExpired, remainingWait(time));\n    }\n    function trailingEdge(time) {\n        timerId = undefined;\n        if (trailing && lastArgs) {\n            return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n    function cancel() {\n        if (timerId !== undefined) {\n            cancelTimer(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n    function flush() {\n        return timerId === undefined ? result : trailingEdge(Date.now());\n    }\n    function pending() {\n        return timerId !== undefined;\n    }\n    function debounced(...args) {\n        const time = Date.now();\n        const isInvoking = shouldInvoke(time);\n        lastArgs = args;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n            if (timerId === undefined) {\n                return leadingEdge(lastCallTime);\n            }\n            if (maxing) {\n                timerId = startTimer(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) {\n            timerId = startTimer(timerExpired, wait);\n        }\n        return result;\n    }\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    debounced.pending = pending;\n    return debounced;\n}\nexport default debounce;\n","export default function getTextBoxCoordsCanvas(annotationCanvasPoints) {\n    const corners = _determineCorners(annotationCanvasPoints);\n    const centerY = (corners.top[1] + corners.bottom[1]) / 2;\n    const textBoxCanvas = [corners.right[0], centerY];\n    return textBoxCanvas;\n}\nfunction _determineCorners(canvasPoints) {\n    const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\n    const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\n    const right = handlesLeftToRight[handlesLeftToRight.length - 1];\n    const top = handlesTopToBottom[0];\n    const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\n    return {\n        top,\n        bottom,\n        right,\n    };\n    function _compareX(a, b) {\n        return a[0] < b[0] ? -1 : 1;\n    }\n    function _compareY(a, b) {\n        return a[1] < b[1] ? -1 : 1;\n    }\n}\n","import getViewportsForAnnotation from './getViewportsForAnnotation';\nexport default function getViewportForAnnotation(annotation) {\n    const viewports = getViewportsForAnnotation(annotation);\n    if (!viewports?.length) {\n        return undefined;\n    }\n    const viewport = viewports.find((viewport) => viewport\n        .getImageIds()\n        .some((imageId) => imageId === annotation.metadata.referencedImageId));\n    return viewport ?? viewports[0];\n}\n","function isObject(value) {\n    const type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n}\nexport default isObject;\n","export default function pointInSphere(sphere, pointLPS) {\n    const { center, radius } = sphere;\n    const radius2 = sphere.radius2 || radius * radius;\n    return ((pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +\n        (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +\n        (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=\n        radius2);\n}\n","import debounce from './debounce';\nimport isObject from './isObject';\nfunction throttle(func, wait, options) {\n    let leading = true;\n    let trailing = true;\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n    if (isObject(options)) {\n        leading = 'leading' in options ? Boolean(options.leading) : leading;\n        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n    }\n    return debounce(func, wait, {\n        leading,\n        trailing,\n        maxWait: wait,\n    });\n}\nexport default throttle;\n","import { cache, StackViewport, BaseVolumeViewport, utilities, } from '@cornerstonejs/core';\nfunction isViewportPreScaled(viewport, targetId) {\n    if (viewport instanceof BaseVolumeViewport) {\n        const volumeId = utilities.getVolumeId(targetId);\n        const volume = cache.getVolume(volumeId);\n        return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\n    }\n    else if (viewport instanceof StackViewport) {\n        const { preScale } = viewport.getImageData() || {};\n        return !!preScale?.scaled;\n    }\n    else {\n        return false;\n    }\n}\nexport { isViewportPreScaled };\n"],"names":["VIEWPORT_ELEMENT","getSvgNode","canvasHash","cacheKey","state","svgNodeCache","domRef","appendNode","svgLayerElement","svgNode","touched","appendChild","setNodeTouched","clearUntouched","Object","keys","forEach","cacheEntry","removeChild","element","enabledElement","getEnabledElement","viewportId","renderingEngineId","viewportElement","internalDivElement","querySelector","svgLayer","_getSvgLayer","svgNodeCacheForCanvas","bind","this","fn","svgDrawingHelper","annotationUID","circleUID","center","radius","options","dataId","color","fill","width","lineWidth","lineDash","fillOpacity","strokeOpacity","assign","undefined","strokeWidth","svgNodeHash","existingCircleElement","attributes","cx","cy","r","stroke","newCircleElement","document","createElementNS","setAttribute","handleGroupUID","handlePoints","handle","i","linkUID","annotationAnchorPoints","refPoint","boundingBox","start","length","findClosestPoint","boundingBoxPoints","x","left","y","top","height","halfWidth","halfHeight","_boundingBoxPoints","end","mergedOptions","drawLine","textBoxUID","textLines","textBoxPosition","textBox","handleRadius","centering","canvasBoundingBox","drawTextBox","drawRect","rectangleUID","topLeft","topRight","bottomLeft","bottomRight","segmentationStyle","constructor","config","global","segmentations","viewportsStyle","setStyle","specifier","styles","segmentationId","type","segmentIndex","currentStyles","getStyle","updatedStyles","copyActiveToInactiveIfNotProvided","Error","renderInactiveSegmentations","representations","repConfig","perSegment","allSegments","ALL_SEGMENTATIONS_KEY","segConfig","processedStyles","Labelmap","labelmapStyles","renderOutlineInactive","renderOutline","outlineWidthInactive","outlineWidth","renderFillInactive","renderFill","fillAlphaInactive","fillAlpha","outlineOpacityInactive","outlineOpacity","Contour","contourStyles","outlineDashInactive","outlineDash","combinedStyle","getDefaultStyle","allSegmentationsKey","getRenderInactiveSegmentations","setRenderInactiveSegmentations","Surface","clearSegmentationStyle","clearAllSegmentationStyles","clearViewportStyle","clearAllViewportStyles","resetToGlobalStyle","hasCustomStyle","style","defaultStyle","utilities","triggerSegmentationDataModified","modifiedSlicesToUse","eventDetail","triggerEvent","eventTarget","Events","SEGMENTATION_DATA_MODIFIED","getActiveSegmentation","getSegmentationRepresentationVisibility","data","segmentation","representationData","console","warn","getRenderingEngines","find","re","getViewports","vp","id","toolGroupFilteredByIds","toolGroups","filter","tg","viewportsInfo","some","PlanarFreehandContourSegmentationTool","toolName","toolProps","super","configuration","calculateStats","allowOpenContours","isContourSegmentationTool","renderAnnotationInstance","renderContext","annotation","invalidated","renderResult","pointCanProjectOnLine","polyline","EPSILON","CONSTANTS","PARALLEL_THRESHOLD","PlanarFreehandROITool","defaultToolProps","supportedInteractionTypes","storePointData","shadow","preventHandleOutsideImage","contourHoleAdditionModifierKey","KeyboardBindings","Shift","alwaysRenderOpenContourHandles","enabled","closeContourProximity","checkCanvasEditFallbackProximity","makeClockWise","subPixelResolution","smoothing","smoothOnAdd","smoothOnEdit","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","interpolation","onInterpolationComplete","decimate","epsilon","displayOnePointAsCrosshairs","getTextLines","defaultGetTextLines","statsCalculator","BasicStatsCalculator","isDrawing","isEditingClosed","isEditingOpen","addNewAnnotation","evt","detail","createAnnotation","addAnnotation","viewportIdsToRender","getViewportIdsWithToolToRender","getToolName","activateDraw","preventDefault","handleSelectedCallback","activateOpenContourEndEdit","toolSelectedCallback","contour","closed","activateClosedContourEdit","activateOpenContourEdit","isPointNearTool","canvasCoords","proximity","viewport","points","previousPoint","worldToCanvas","p1","p2","pStart","pEnd","cancel","cancelDrawing","cancelOpenContourEdit","cancelClosedContourEdit","_calculateCachedStats","renderingEngine","cachedStats","targetIds","targetId","image","getTargetImageData","imageData","metadata","canvasCoordinates","map","p","modalityUnitOptions","isPreScaled","isSuvScaled","referencedImageId","modalityUnit","Modality","calibratedScale","numPoints","projectedPolyline","Array","maxX","canvasMaxX","maxY","canvasMaxY","minX","canvasMinX","minY","canvasMinY","topLeftBBWorld","canvasToWorld","topLeftBBIndex","bottomRightBBWorld","canvasPoint","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","updateClosedCachedStats","updateOpenCachedStats","triggerAnnotationModified","ChangeTypes","StatsUpdated","_renderStats","getTargetId","styleSpecifier","toolGroupId","getLinkedTextBoxStyle","visibility","handles","hasMoved","canvasTextBoxCoords","getTextBoxCoordsCanvas","worldPosition","drawLinkedTextBox","worldBoundingBox","_throttledCalculateCachedStats","trailing","filterInteractableAnnotationsForElement","annotations","baseFilteredAnnotations","annotationsToDisplay","VolumeViewport","camera","getCamera","spacingInNormalDirection","filterAnnotationsWithinSlice","filterAnnotationsForDisplay","viewPlaneNormal","annotationsWithParallelNormals","td","annotationViewPlaneNormal","FrameOfReferenceUID","point","vector","focalPoint","dotProduct","cameraFocalPoint","imageOrientationPatient","metaData","rowCosineVec","colCosineVec","isParallel","Math","abs","halfSpacingInNormalDirection","annotationsWithinSlice","isVisible","dir","dot","push","worldPos","currentPoints","world","contourAnnotation","label","getAnnotationStyle","context","renderStatus","activeAnnotationUID","commonData","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","renderPointContourWithMarker","renderContour","_calculateStatsIfActive","movingTextBox","unit","area","max","mean","stdDev","areaUnit","scale","voxelManager","getImageData","worldPosIndex","floor","iMin","iMax","jMin","jMax","kMin","kMax","j","min","worldPosIndex2","perimeter","iDelta","jDelta","kDelta","ceil","boundsIJK","worldPosEnd","indexToWorld","canvasPosEnd","pointsInShape","curRow","intersections","intersectionCounter","statsCallback","isInObject","pointLPS","_pointIJK","result","getLineSegmentIntersectionsCoordinates","sort","a","b","shift","returnPoints","stats","getStatistics","value","statsArray","array","cachedVolumeStats","isEmptyArea","areaLine","transformWorldToIndex","RectangleROITool","createAnnotationForViewport","editData","handleIndex","newAnnotation","_activateDraw","hideElementCursor","canvasPoint1","canvasPoint2","rect","_getRectangleImageCoordinates","highlighted","_activateModify","findIndex","_endCallback","activeHandleIndex","_deactivateModify","_deactivateDraw","resetElementCursor","doneEditMemo","isHandleOutsideImage","triggerAnnotationCompleted","_dragCallback","createMemo","deltaPoints","worldPosDelta","bottomLeftCanvas","bottomRightCanvas","topLeftCanvas","topRightCanvas","bottomLeftWorld","bottomRightWorld","topLeftWorld","topRightWorld","HandlesUpdated","isInteractingWithTool","addEventListener","MOUSE_UP","MOUSE_DRAG","MOUSE_MOVE","MOUSE_CLICK","TOUCH_END","TOUCH_DRAG","TOUCH_TAP","removeEventListener","renderAnnotation","getRenderingEngine","viewUp","startsWith","getStackViewports","referencedImageURI","hasImageURI","currentImageURI","getCurrentImageId","activeHandleCanvasCoords","isAnnotationVisible","isAnnotationLocked","showHandlesAlways","Boolean","drawHandles","point0","point1","worldPos1","worldPos2","dimensions","pos1Index","pos2Index","_isInsideVolume","worldWidth","worldHeight","pixelUnitsOptions","index1","index2","hydrate","getEnabledElementByViewportId","instance","hydrateBase","toolInstance","serializableOptions","autoGenerated","isLocked","LabelmapBaseTool","previewData","preview","timerStart","timer","startPoint","NaN","isDrag","memoMap","Map","acceptedMemoIds","centerSegmentIndexInfo","hasSegmentIndex","hasPreviewIndex","changedIndices","_historyRedoHandler","operationType","has","_hoverData","memoData","get","operationData","getOperationData","applyActiveStrategyCallback","StrategyCallbacks","AcceptPreview","_previewData","hasPreviewData","shouldResolvePreviewRequests","mode","segmentationVoxelManager","voxelManagerId","memo","redoVoxelManager","set","createEditData","activeSegmentation","event","CustomEvent","Enums","ERROR_EVENT","message","cancelable","dispatchEvent","segmentsLocked","getLockedSegmentIndices","getEditData","BaseVolumeViewport","volumeId","actors","getActors","StackViewport","volumes","actorEntry","cache","getVolume","referencedId","segmentationVolume","referencedVolumeIdToThreshold","volume","referencedVolumeId","threshold","segmentationImageId","imageId","createHoverData","centerCanvas","segmentColor","getActiveSegmentationData","brushCursor","getFrameOfReferenceUID","activeRepresentation","getSegmentIndexColor","_editData","configColor","previewColors","previewColor","previewSegmentIndex","g","factor","round","lightenColor","previewOnHover","activeStrategy","addPreview","acceptReject","acceptPreview","rejectPreview","results","AddPreview","modified","RejectPreview","viewportContoursToLabelmap","removeContours","getAllAnnotations","viewAnnotations","contourAnnotations","strategies","FILL_INSIDE_CIRCLE","fillInsideCircle","previewVoxels","segmentationVoxels","sourceVoxelManager","getDefaultActor","actor","getMapper","getInputData","Infinity","worldToIndex","v","idx","bound","activeIndex","startIndex","startValue","getAtIJKPoint","hasZeroIndex","hasPositiveIndex","polyPoint","polyIndex","polyValue","k","worldPoint","isPointInsidePolyline3D","setAtIJK","removeAnnotation","slices","getArrayOfModifiedSlices","func","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","useRAF","window","requestAnimationFrame","TypeError","invokeFunc","time","args","thisArg","apply","startTimer","pendingFunc","setTimeout","shouldInvoke","timeSinceLastCall","timerExpired","Date","now","trailingEdge","timeSinceLastInvoke","timeWaiting","remainingWait","debounced","isInvoking","leadingEdge","Number","cancelAnimationFrame","clearTimeout","cancelTimer","flush","pending","annotationCanvasPoints","corners","canvasPoints","handlesLeftToRight","_compareX","handlesTopToBottom","_compareY","right","bottom","_determineCorners","centerY","getViewportForAnnotation","viewports","getImageIds","pointInSphere","sphere","radius2","isViewportPreScaled","scaling","preScale","scaled"],"sourceRoot":""}