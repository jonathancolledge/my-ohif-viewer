{"version":3,"file":"7412.bundle.860a0c9c02c12624144c.js","mappings":"uJAEA,IAAIA,EAAS,CAAC,EACP,SAASC,IACZ,OAAOD,CACX,CACO,SAASE,EAAUC,GACtBH,EAASG,CACb,CAIA,IAAIC,GAAqB,EAClB,SAASC,IACZ,IAAKL,EAAOM,QAAQC,QAEhB,OADAC,QAAQC,KAAK,6SACN,KAEX,MAAMC,EAAUV,EAAOM,OAAOC,QAK9B,OAJKH,IACDM,EAAQC,OACRP,GAAqB,GAElBM,CACX,C,gDCxBA,MAiQA,EAjQ8B,CAC1B,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,I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","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/config.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/constants/COLOR_LUT.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/MouseCursor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/elementCursor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/ImageMouseCursor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGCursorDescriptor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/SVGMouseCursor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/setCursorForElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/cursors/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipse.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipseByCoordinates.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPath.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawPolyline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRectByCoordinates.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawTextBox.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHeight.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawFan.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawArrow.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRedactionRect.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setAttributesIfNecessary.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/setNewAttributesIfValid.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/annotationInterpolationEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraModifiedEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraResetEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageRenderedEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageSpacingCalibratedEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/keyboardToolEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/mouseToolEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/touchToolEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/mouse/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/touch/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/wheel/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/onLabelmapSegmentationDataModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/performVolumeLabelmapUpdate.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/labelmap/performStackLabelmapUpdate.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationDataModifiedEventListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationModifiedEventListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/imageChangeEventListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationCompleted.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationCompletedListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationSelectionListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationModifiedListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/annotationRemovedListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/annotations/contourSegmentation/contourSegmentationRemoved.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationRemovedEventListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/segmentationRepresentationModifiedListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/init.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationRenderingEngine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/FrameOfReferenceSpecificAnnotationManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationLocking.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationSelection.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationState.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/annotationVisibility.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/ToolStyle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/helpers.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getState.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/config/getFont.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/helpers/state.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/AnnotationGroup.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setActiveSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addColorLUT.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentationRepresentationsToViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/normalizeSegmentationInput.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getColorLUT.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getCurrentLabelmapImageIdForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getNextColorLUTIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportIdsWithSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportSegmentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeStackLabelmapFromVolume.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeVolumeLabelmapFromStack.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/getSegmentationActor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateSegmentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationVisibility.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setSegmentationRepresentationVisibility.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/styleHelpers.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/clearSegmentValue.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegment.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/removeSegmentAnnotations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getLabelmapImageIds.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddSegmentationRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentLocking.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationEventManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeColorLUT.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getStackSegmentationImageIdsForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateLabelmapSegmentationImageReferences.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/convertContourHoles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/decimateContours.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/getPolylineMap.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/extractSegmentPolylines.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/getAnnotationMapFromSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/getAnnotationsUIDMapFromSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/getViewportAssociatedToSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/removeCompleteContourAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/removeContourHoles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/removeContourIslands.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/smoothContours.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/Synchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/createSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroy.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/destroySynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getAllSynchronizers.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/SynchronizerManager/getSynchronizersForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroup.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/ToolGroup.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/createToolGroup.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroyToolGroup.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/destroy.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getAllToolGroups.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/addEnabledElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/addTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/cancelActiveManipulations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/removeEnabledElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/state.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/svgNodeCache.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/areViewportsCoplanar.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/cameraSyncCallback.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/imageSliceSyncCallback.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/presentationViewSyncCallback.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/slabThicknessSyncCallback.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/voiSyncCallback.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/callbacks/zoomPanSyncCallback.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createCameraPositionSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createImageSliceSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createPresentationViewSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createSlabThicknessSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createVOISynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createZoomPanSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AdvancedMagnifyTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AnnotationEraserTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/CrosshairsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MIPJumpToClickTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MagnifyTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OrientationMarkerTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OverlayGridTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PanTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PlanarRotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceCursors.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceLinesTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ScaleOverlayTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SculptorTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SegmentationIntersectionTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/StackScrollTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/TrackballRotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeCroppingControlTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeCroppingTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeRotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelRegionTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ZoomTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/AngleTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ArrowAnnotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/BidirectionalTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CircleROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CobbAngleTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/DragProbeTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ETDRSGridTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/EllipticalROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/HeightTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/KeyImageTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LabelTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LengthTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourSegmentationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ProbeTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentPlusTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineContourSegmentationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundDirectionalTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/UltrasoundPleuraBLineTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/calculateFanShapeCorners.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/deriveFanGeometry.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/fanExtraction.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/generateConvexHullFromContour.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/segmentLargestUSOutlineFromBuffer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/VideoRedactionTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/WholeBodySegmentTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/BSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CardinalSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CatmullRomSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CubicSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/LinearSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/QuadraticBezier.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/QuadraticSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/Spline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationDisplayTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/BaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourDisplay.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapDisplay.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/surfaceDisplay.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/BrushTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleROIStartEndThresholdTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleScissorsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapEditWithContour.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/PaintFillTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIStartEndThresholdTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleROIThresholdTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleScissorsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentBidirectionalTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentLabelTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentSelectTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SphereScissorsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/ensureImageVolume.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/ensureSegmentationVolume.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillCircle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillRectangle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/getStrategyData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/types/ContourAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/AnnotationMultiSlice.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/annotationHydration.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/extend2DBoundingBoxInViewAxis.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/getBoundingBoxAroundShape.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/calibrateImageSpacing.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/events.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/playClip.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/state.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/addContourSegmentationAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/areSameSegment.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/areViewReferencesEqual.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/contourSegmentationOperation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/copyAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/getIntersectingAnnotations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/getViewReferenceFromAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/convertContourSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/isContourSegmentationAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/addPolylinesToSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/logicalOperators.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/mergeMultipleAnnotations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/polylineIntersect.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/polylineSubtract.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/polylineUnify.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/polylineXor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/removeContourSegmentationAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/sharedOperations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/AnnotationToPointData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/calculatePerimeter.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/contourFinder.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findHandlePolylineIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findIslands.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataCanvas.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getContourHolesDataWorld.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getDeduplicatedVTKPolyDataPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/areCoplanarContours.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/detectContourHoles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findContourHoles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/generateContourSetsFromLabelmap.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/acceptAutogeneratedInterpolations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/updateContourPolyline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/generateImageFromTimeData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/getDataInTime.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getAnnotationNearPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getPixelValueUnits.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getSphereBoundsInfo.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportsForAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/arePolylinesIdentical.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/containsPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/decimate.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getSignedArea.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/isClosed.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/vec2/findClosestPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/moveAnnotationToViewPlane.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/normalizeViewportPlane.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/getOrientationStringLPS.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/orientation/invertOrientationStringLPS.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointInSurroundingSphereCallback.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointToString.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/polyData/utils.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/getBoundsIJKFromRectangleAnnotations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/isAxisAlignedRectangle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/registerComputeWorker.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/InterpolationManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/SegmentStatsCalculator.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/VolumetricCalculator.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/brushSizeForToolGroup.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/brushThresholdForToolGroup.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/computeMetabolicStats.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getReferenceVolumeForSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/contourAndFindLargestBidirectional.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createBidirectionalToolData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createLabelmapMemo.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createLabelmapVolumeForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/createMergedLabelmapForIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/findLargestBidirectional.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/floodFill.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getBrushToolInstances.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getHoveredContourSegmentationAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateImageVolume.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getOrCreateSegmentationVolume.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getReferenceVolumeForSegmentationVolume.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtLabelmapBorder.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtWorldPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentLargestBidirectional.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getStatistics.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getUniqueSegmentIndices.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/growCutShader.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCut.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForBoundingBox.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runOneClickGrowCut.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/invalidateBrushCursor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/isLineInSegment.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/islandRemoval.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/rectangleROIThresholdVolumeByRange.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/segmentContourAction.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/thresholdSegmentationByRange.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/thresholdVolumeByRange.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilities.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/utilsForWorker.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/validateLabelmap.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/setAnnotationLabel.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackContextPrefetch.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackPrefetch.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/touch/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRender.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForToolGroupIds.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithFrameOfReferenceUID.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithParallelNormals.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/filterViewportsWithToolEnabled.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/Colorbar.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ViewportColorbar.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/calculateMinMaxMean.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/extractWindowLevelRegionToolData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/getLuminanceFromRegion.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/version.js","webpack:///../../../node_modules/lodash.get/index.js"],"sourcesContent":["import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport Events from './enums/Events';\nlet config = {};\nexport function getConfig() {\n    return config;\n}\nexport function setConfig(newConfig) {\n    config = newConfig;\n}\nexport function getAddOns() {\n    return config.addons;\n}\nlet polysegInitialized = false;\nexport function getPolySeg() {\n    if (!config.addons?.polySeg) {\n        console.warn('PolySeg add-on not configured. This will prevent automatic conversion between segmentation representations (labelmap, contour, surface). To enable these features, install @cornerstonejs/polymorphic-segmentation and register it during initialization: cornerstoneTools.init({ addons: { polySeg } }).');\n        return null;\n    }\n    const polyseg = config.addons.polySeg;\n    if (!polysegInitialized) {\n        polyseg.init();\n        polysegInitialized = true;\n    }\n    return polyseg;\n}\n","const CORNERSTONE_COLOR_LUT = [\n    [0, 0, 0, 0],\n    [221, 84, 84, 255],\n    [77, 228, 121, 255],\n    [166, 70, 235, 255],\n    [189, 180, 116, 255],\n    [109, 182, 196, 255],\n    [204, 101, 157, 255],\n    [123, 211, 94, 255],\n    [93, 87, 218, 255],\n    [225, 128, 80, 255],\n    [73, 232, 172, 255],\n    [181, 119, 186, 255],\n    [176, 193, 112, 255],\n    [105, 153, 200, 255],\n    [208, 97, 120, 255],\n    [90, 215, 101, 255],\n    [135, 83, 222, 255],\n    [229, 178, 76, 255],\n    [122, 183, 181, 255],\n    [190, 115, 171, 255],\n    [149, 197, 108, 255],\n    [100, 118, 205, 255],\n    [212, 108, 93, 255],\n    [86, 219, 141, 255],\n    [183, 79, 226, 255],\n    [233, 233, 72, 255],\n    [118, 167, 187, 255],\n    [194, 111, 146, 255],\n    [116, 201, 104, 255],\n    [115, 96, 209, 255],\n    [216, 147, 89, 255],\n    [82, 223, 188, 255],\n    [230, 75, 224, 255],\n    [163, 184, 121, 255],\n    [114, 143, 191, 255],\n    [198, 107, 114, 255],\n    [99, 206, 122, 255],\n    [153, 92, 213, 255],\n    [220, 192, 85, 255],\n    [78, 215, 227, 255],\n    [234, 71, 173, 255],\n    [141, 188, 117, 255],\n    [110, 113, 195, 255],\n    [202, 128, 103, 255],\n    [95, 210, 157, 255],\n    [195, 88, 217, 255],\n    [206, 224, 81, 255],\n    [74, 166, 231, 255],\n    [185, 120, 139, 255],\n    [113, 192, 113, 255],\n    [133, 106, 199, 255],\n    [207, 162, 98, 255],\n    [91, 214, 198, 255],\n    [221, 84, 198, 255],\n    [159, 228, 77, 255],\n    [70, 111, 235, 255],\n    [189, 119, 116, 255],\n    [109, 196, 138, 255],\n    [165, 101, 204, 255],\n    [211, 201, 94, 255],\n    [87, 191, 218, 255],\n    [225, 80, 153, 255],\n    [106, 232, 73, 255],\n    [124, 119, 186, 255],\n    [193, 142, 112, 255],\n    [105, 200, 168, 255],\n    [203, 97, 208, 255],\n    [184, 215, 90, 255],\n    [83, 147, 222, 255],\n    [229, 76, 101, 255],\n    [122, 183, 130, 255],\n    [146, 115, 190, 255],\n    [197, 171, 108, 255],\n    [100, 205, 205, 255],\n    [212, 93, 177, 255],\n    [141, 219, 86, 255],\n    [79, 97, 226, 255],\n    [233, 99, 72, 255],\n    [118, 187, 150, 255],\n    [173, 111, 194, 255],\n    [197, 201, 104, 255],\n    [96, 171, 209, 255],\n    [216, 89, 137, 255],\n    [94, 223, 82, 255],\n    [107, 75, 230, 255],\n    [184, 153, 121, 255],\n    [114, 191, 175, 255],\n    [198, 107, 191, 255],\n    [166, 206, 99, 255],\n    [92, 132, 213, 255],\n    [220, 85, 91, 255],\n    [78, 227, 115, 255],\n    [159, 71, 234, 255],\n    [188, 176, 117, 255],\n    [110, 185, 195, 255],\n    [202, 103, 161, 255],\n    [129, 210, 95, 255],\n    [88, 88, 217, 255],\n    [224, 123, 81, 255],\n    [74, 231, 166, 255],\n    [177, 120, 185, 255],\n    [179, 192, 113, 255],\n    [106, 156, 199, 255],\n    [207, 98, 125, 255],\n    [91, 214, 96, 255],\n    [130, 84, 221, 255],\n    [228, 171, 77, 255],\n    [70, 235, 221, 255],\n    [189, 116, 174, 255],\n    [153, 196, 109, 255],\n    [101, 123, 204, 255],\n    [211, 104, 94, 255],\n    [87, 218, 136, 255],\n    [177, 80, 225, 255],\n    [232, 225, 73, 255],\n    [119, 169, 186, 255],\n    [193, 112, 149, 255],\n    [121, 200, 105, 255],\n    [111, 97, 208, 255],\n    [215, 142, 90, 255],\n    [83, 222, 181, 255],\n    [229, 76, 229, 255],\n    [165, 183, 122, 255],\n    [115, 146, 190, 255],\n    [197, 108, 119, 255],\n    [100, 205, 118, 255],\n    [148, 93, 212, 255],\n    [219, 186, 86, 255],\n    [79, 220, 226, 255],\n    [233, 72, 179, 255],\n    [144, 187, 118, 255],\n    [111, 118, 194, 255],\n    [201, 124, 104, 255],\n    [96, 209, 153, 255],\n    [189, 89, 216, 255],\n    [211, 223, 82, 255],\n    [75, 172, 230, 255],\n    [184, 121, 142, 255],\n    [117, 191, 114, 255],\n    [130, 107, 198, 255],\n    [206, 157, 99, 255],\n    [92, 213, 193, 255],\n    [220, 85, 203, 255],\n    [165, 227, 78, 255],\n    [71, 118, 234, 255],\n    [188, 117, 117, 255],\n    [110, 195, 135, 255],\n    [161, 103, 202, 255],\n    [210, 195, 95, 255],\n    [88, 195, 217, 255],\n    [224, 81, 158, 255],\n    [113, 231, 74, 255],\n    [123, 120, 185, 255],\n    [192, 139, 113, 255],\n    [106, 199, 164, 255],\n    [198, 98, 207, 255],\n    [188, 214, 91, 255],\n    [84, 153, 221, 255],\n    [228, 77, 108, 255],\n    [70, 235, 84, 255],\n    [143, 116, 189, 255],\n    [196, 167, 109, 255],\n    [101, 204, 199, 255],\n    [211, 94, 182, 255],\n    [147, 218, 87, 255],\n    [80, 104, 225, 255],\n    [232, 93, 73, 255],\n    [119, 186, 147, 255],\n    [170, 112, 193, 255],\n    [200, 200, 105, 255],\n    [97, 175, 208, 255],\n    [215, 90, 142, 255],\n    [100, 222, 83, 255],\n    [101, 76, 229, 255],\n    [183, 150, 122, 255],\n    [115, 190, 171, 255],\n    [197, 108, 194, 255],\n    [170, 205, 100, 255],\n    [93, 138, 212, 255],\n    [219, 86, 97, 255],\n    [79, 226, 110, 255],\n    [153, 72, 233, 255],\n    [187, 173, 118, 255],\n    [111, 187, 194, 255],\n    [201, 104, 165, 255],\n    [134, 209, 96, 255],\n    [89, 95, 216, 255],\n    [223, 117, 82, 255],\n    [75, 230, 159, 255],\n    [174, 121, 184, 255],\n    [182, 191, 114, 255],\n    [107, 160, 198, 255],\n    [206, 99, 130, 255],\n    [92, 213, 92, 255],\n    [124, 85, 220, 255],\n    [227, 165, 78, 255],\n    [71, 234, 214, 255],\n    [188, 117, 176, 255],\n    [156, 195, 110, 255],\n    [103, 128, 202, 255],\n    [210, 100, 95, 255],\n    [88, 217, 131, 255],\n    [170, 81, 224, 255],\n    [231, 218, 74, 255],\n    [120, 172, 185, 255],\n    [192, 113, 153, 255],\n    [125, 199, 106, 255],\n    [107, 98, 207, 255],\n    [214, 137, 91, 255],\n    [84, 221, 175, 255],\n    [222, 77, 228, 255],\n    [194, 235, 70, 255],\n    [116, 149, 189, 255],\n    [196, 109, 123, 255],\n    [101, 204, 114, 255],\n    [143, 94, 211, 255],\n    [218, 180, 87, 255],\n    [80, 225, 225, 255],\n    [232, 73, 186, 255],\n    [147, 186, 119, 255],\n    [112, 122, 193, 255],\n    [200, 121, 105, 255],\n    [97, 208, 148, 255],\n    [184, 90, 215, 255],\n    [216, 222, 83, 255],\n    [76, 178, 229, 255],\n    [183, 122, 145, 255],\n    [121, 190, 115, 255],\n    [126, 108, 197, 255],\n    [205, 153, 100, 255],\n    [93, 212, 187, 255],\n    [219, 86, 208, 255],\n    [171, 226, 79, 255],\n    [72, 126, 233, 255],\n    [187, 118, 121, 255],\n    [111, 194, 132, 255],\n    [157, 104, 201, 255],\n    [209, 190, 96, 255],\n    [89, 200, 216, 255],\n    [223, 82, 164, 255],\n    [120, 230, 75, 255],\n    [121, 121, 184, 255],\n    [191, 136, 114, 255],\n    [107, 198, 160, 255],\n    [192, 99, 206, 255],\n    [193, 213, 92, 255],\n    [85, 158, 220, 255],\n    [227, 78, 115, 255],\n    [71, 234, 78, 255],\n    [141, 117, 188, 255],\n    [195, 163, 110, 255],\n    [103, 202, 194, 255],\n    [210, 95, 186, 255],\n    [153, 217, 88, 255],\n    [81, 111, 224, 255],\n];\nexport default CORNERSTONE_COLOR_LUT;\n","const DEFINED_CURSORS = Symbol('DefinedCursors');\nconst STANDARD_CURSORS = new Set([\n    'alias',\n    'all-scroll',\n    'auto',\n    'cell',\n    'col-resize',\n    'context-menu',\n    'copy',\n    'crosshair',\n    'default',\n    'e-resize',\n    'ew-resize',\n    'grab',\n    'grabbing',\n    'help',\n    'move',\n    'ne-resize',\n    'nesw-resize',\n    'no-drop',\n    'none',\n    'not-allowed',\n    'n-resize',\n    'ns-resize',\n    'nw-resize',\n    'nwse-resize',\n    'pointer',\n    'progress',\n    'row-resize',\n    'se-resize',\n    's-resize',\n    'sw-resize',\n    'text',\n    'vertical-text',\n    'wait',\n    'w-resize',\n    'zoom-in',\n    'zoom-out',\n]);\nexport default class MouseCursor {\n    constructor(name, fallback) {\n        this.name = name + '';\n        this.fallback = fallback;\n    }\n    getName() {\n        return this.name + '';\n    }\n    addFallbackStyleProperty(style) {\n        const { fallback } = this;\n        if (fallback instanceof MouseCursor) {\n            return `${style}, ${fallback.getStyleProperty()}`;\n        }\n        return style + '';\n    }\n    getStyleProperty() {\n        return this.addFallbackStyleProperty(this.name) + '';\n    }\n    static getDefinedCursor(name) {\n        const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);\n        let mouseCursor = definedCursors.get(name);\n        if (mouseCursor instanceof MouseCursor) {\n            return mouseCursor;\n        }\n        if (STANDARD_CURSORS.has(name)) {\n            mouseCursor = new MouseCursor(name);\n            definedCursors.set(name, mouseCursor);\n            return mouseCursor;\n        }\n    }\n    static setDefinedCursor(name, cursor) {\n        if (cursor instanceof MouseCursor) {\n            const definedCursors = getDefinedCursors(MouseCursor, DEFINED_CURSORS);\n            definedCursors.set(name, cursor);\n            return true;\n        }\n        return false;\n    }\n}\nfunction getDefinedCursors(context, symbol) {\n    let definedCursors = context[symbol];\n    if (!(definedCursors instanceof Map)) {\n        definedCursors = new Map();\n        Object.defineProperty(context, symbol, { value: definedCursors });\n    }\n    return definedCursors;\n}\nconst standardCursorNames = STANDARD_CURSORS.values();\nexport { standardCursorNames };\n","import MouseCursor from './MouseCursor';\nconst ELEMENT_CURSORS_MAP = Symbol('ElementCursorsMap');\nfunction initElementCursor(element, cursor) {\n    _getElementCursors(element)[0] = cursor;\n    _setElementCursor(element, cursor);\n}\nfunction _setElementCursor(element, cursor) {\n    const cursors = _getElementCursors(element);\n    cursors[1] = cursors[0];\n    cursors[0] = cursor;\n    element.style.cursor = (cursor instanceof MouseCursor\n        ? cursor\n        : MouseCursor.getDefinedCursor('auto')).getStyleProperty();\n}\nfunction resetElementCursor(element) {\n    _setElementCursor(element, _getElementCursors(element)[1]);\n}\nfunction hideElementCursor(element) {\n    _setElementCursor(element, MouseCursor.getDefinedCursor('none'));\n}\nfunction _getElementCursors(element) {\n    let map = _getElementCursors[ELEMENT_CURSORS_MAP];\n    if (!(map instanceof WeakMap)) {\n        map = new WeakMap();\n        Object.defineProperty(_getElementCursors, ELEMENT_CURSORS_MAP, {\n            value: map,\n        });\n    }\n    let cursors = map.get(element);\n    if (!cursors) {\n        cursors = [null, null];\n        map.set(element, cursors);\n    }\n    return cursors;\n}\nexport { initElementCursor, resetElementCursor, hideElementCursor, _setElementCursor as setElementCursor, };\n","import { utilities } from '@cornerstonejs/core';\nimport MouseCursor from './MouseCursor';\nconst DEFAULT_NAME = 'image-cursor';\nexport default class ImageMouseCursor extends MouseCursor {\n    constructor(url, x, y, name, fallback) {\n        super(name || ImageMouseCursor.getUniqueInstanceName(DEFAULT_NAME), fallback);\n        this.url = url;\n        this.x = Number(x) || 0;\n        this.y = Number(y) || 0;\n    }\n    getStyleProperty() {\n        const { url, x, y } = this;\n        let style = `url('${url}')`;\n        if (x >= 0 && y >= 0 && (x > 0 || y > 0)) {\n            style += ` ${x} ${y}`;\n        }\n        return this.addFallbackStyleProperty(style);\n    }\n    static getUniqueInstanceName(prefix) {\n        return `${prefix}-${utilities.getRuntimeId(ImageMouseCursor)}`;\n    }\n}\n","const BASE = {\n    iconContent: '',\n    iconSize: 16,\n    viewBox: {\n        x: 16,\n        y: 16,\n    },\n    mousePoint: {\n        x: 8,\n        y: 8,\n    },\n    mousePointerGroupString: `\n    <path stroke=\"{{color}}\" d=\"M8 16L8 0\"></path>\n    <path stroke=\"{{color}}\" d=\"M16 8L0 8\"></path>\n  `,\n};\nconst SEGMENTATION_CURSOR_BOUNDARIES = {\n    x: 127,\n    y: 60,\n};\nconst MINUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n`;\nconst PLUS_RECT = `\n<rect fill=\"{{color}}\" x=\"80.19\" y=\"25.03\" width=\"47.14\" height=\"15.85\"/>\n<rect fill=\"{{color}}\" x=\"95.84\" y=\"9.38\" width=\"15.85\" height=\"47.14\"/>\n`;\nconst SCISSOR_ICON = `<path fill=\"{{color}}\" d=\"M82.89,10a12.09,12.09,0,0,0-16.8-2.5l-27.5,20.4-8.5-6.3a2.93,2.93,0,0,1-1.1-3,14.66,14.66,0,0,0,.1-6.6,14.08,14.08,0,1,0-6.5,15.2,2.87,2.87,0,0,1,3.2.2l8.2,6.1-8.2,6.1a2.87,2.87,0,0,1-3.2.2,14.16,14.16,0,1,0,6.7,14.4,14,14,0,0,0-.3-5.8,2.93,2.93,0,0,1,1.1-3l8.5-6.3,27.5,20.4A11.91,11.91,0,0,0,82.89,57l-31.7-23.5ZM15.29,21a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,21Zm0,36.8a5.9,5.9,0,1,1,5.9-5.9A5.91,5.91,0,0,1,15.29,57.77Zm28.3-21.5a2.8,2.8,0,1,1,2.8-2.8A2.8,2.8,0,0,1,43.59,36.27Z\" transform=\"translate(-1.17 -0.96)\"/>`;\nconst RECTANGLE_ICON = `<path fill=\"{{color}}\" d=\"M8.86,2.25V66.08H72.69V2.25H8.86ZM65.28,58.67h-49v-49h49v49Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CIRCLE_ICON = `<path fill=\"{{color}}\" d=\"M40.77,2.25A31.92,31.92,0,1,0,72.69,34.16,31.92,31.92,0,0,0,40.77,2.25Zm0,57.63A25.71,25.71,0,1,1,66.48,34.16,25.71,25.71,0,0,1,40.77,59.87Z\" transform=\"translate(-8.86 -2.25)\"/>`;\nconst CursorSVG = {\n    Angle: extend(BASE, {\n        name: 'Angle',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1203 544q0 13-10 23l-393 393 393 393q10 10 10 23t-10 23l-50\n    50q-10 10-23 10t-23-10l-466-466q-10-10-10-23t10-23l466-466q10-10 23-10t23\n    10l50 50q10 10 10 23z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    ArrowAnnotate: extend(BASE, {\n        name: 'ArrowAnnotate',\n        iconContent: `<g id=\"arrowAnnotate-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"arrowAnnotate-arrow\" d=\"M23,7 l-15,15 M7,17 l0,6 6,0\" stroke-width=\"2\" />\n  </g>`,\n        viewBox: {\n            x: 24,\n            y: 24,\n        },\n    }),\n    Bidirectional: extend(BASE, {\n        name: 'Bidirectional',\n        iconContent: `<g fill=\"{{color}}\" stroke-width=\"3\" stroke=\"{{color}}\">\n    <path d=\"M27.63 3.21L3.12 28.81\"></path>\n    <path d=\"M27.63 15.75L15.27 4.43\"></path>\n    <path d=\"M16.5 4.28C16.5 4.96 15.95 5.51 15.27 5.51C14.59 5.51 14.03 4.96 14.03 4.28C14.03 3.59 14.59 3.04 15.27 3.04C15.95 3.04 16.5 3.59 16.5 4.28Z\" ></path>\n    <path d=\"M28.87 3.19C28.87 3.87 28.31 4.43 27.63 4.43C26.95 4.43 26.4 3.87 26.4 3.19C26.4 2.51 26.95 1.95 27.63 1.95C28.31 1.95 28.87 2.51 28.87 3.19Z\"></path>\n    <path d=\"M28.87 15.75C28.87 16.43 28.31 16.99 27.63 16.99C26.95 16.99 26.4 16.43 26.4 15.75C26.4 15.07 26.95 14.51 27.63 14.51C28.31 14.51 28.87 15.07 28.87 15.75Z\"></path>\n    <path d=\"M4.73 28.44C4.73 29.12 4.17 29.68 3.49 29.68C2.81 29.68 2.25 29.12 2.25 28.44C2.25 27.76 2.81 27.2 3.49 27.2C4.17 27.2 4.73 27.76 4.73 28.44Z\"></path>\n  </g>`,\n        viewBox: {\n            x: 48,\n            y: 48,\n        },\n    }),\n    CobbAngle: extend(BASE, {\n        name: 'CobbAngle',\n        iconContent: `<g stroke=\"{{color}}\" stroke-width=\"3\">\n    <path d=\"M28.59 2.34L3.82 12.32\"></path>\n    <path d=\"M28.59 29.66L3.82 19.68\"></path>\n    <path stroke-dasharray=\"2\" fill-opacity=\"0\" d=\"M12.37\n      23.06C12.67 22.36 12.85 21.93 12.92 21.76C14.6 17.8 14.68 13.35 13.15\n      9.33C13.11 9.24 13.02 9 12.88 8.63\">\n    </path>\n  </g>`,\n        viewBox: {\n            x: 32,\n            y: 32,\n        },\n    }),\n    CircleROI: extend(BASE, {\n        name: 'CircleROI',\n        iconContent: `<circle stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" cx=\"16\" cy=\"16\" r=\"14\" />`,\n        viewBox: {\n            x: 32,\n            y: 32,\n        },\n    }),\n    EllipticalROI: extend(BASE, {\n        name: 'EllipticalROI',\n        iconContent: `<path stroke=\"{{color}}\" fill=\"none\" stroke-width=\"3\" d=\"M30.74 15.76C30.74 20.99 24.14 25.23 16\n    25.23C7.86 25.23 1.26 20.99 1.26 15.76C1.26 10.54 7.86 6.3 16 6.3C24.14\n    6.3 30.74 10.54 30.74 15.76Z\" />`,\n        viewBox: {\n            x: 32,\n            y: 32,\n        },\n    }),\n    FreehandROI: extend(BASE, {\n        name: 'FreehandROI',\n        iconContent: `<g fill=\"{{color}}\" stroke=\"{{color}}\" stroke-width=\"2\">\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_3\" cy=\"4.240343\" cx=\"14.306499\"/>\n    <line id=\"svg_4\" y2=\"3.58462\" x2=\"12.242186\" y1=\"3.997482\" x1=\"13.432202\"/>\n    <line id=\"svg_5\" y2=\"3.268901\" x2=\"10.857882\" y1=\"3.608906\" x1=\"12.387902\"/>\n    <line id=\"svg_6\" y2=\"3.147471\" x2=\"9.740724\" y1=\"3.293187\" x1=\"10.955026\"/>\n    <line id=\"svg_7\" y2=\"3.147471\" x2=\"8.089274\" y1=\"3.196043\" x1=\"9.983585\"/>\n    <line id=\"svg_8\" y2=\"3.268901\" x2=\"6.874972\" y1=\"3.123185\" x1=\"8.307848\"/>\n    <line id=\"svg_9\" y2=\"3.657478\" x2=\"5.587812\" y1=\"3.220329\" x1=\"7.020688\"/>\n    <line id=\"svg_10\" y2=\"4.046054\" x2=\"4.737801\" y1=\"3.560334\" x1=\"5.854959\"/>\n    <line id=\"svg_11\" y2=\"4.337487\" x2=\"4.300652\" y1=\"3.997482\" x1=\"4.834945\"/>\n    <line id=\"svg_12\" y2=\"4.726063\" x2=\"3.88779\" y1=\"4.191771\" x1=\"4.470655\"/>\n    <line id=\"svg_15\" y2=\"5.3575\" x2=\"3.377783\" y1=\"4.604633\" x1=\"3.960648\"/>\n    <line id=\"svg_16\" y2=\"6.183226\" x2=\"2.916348\" y1=\"5.138926\" x1=\"3.547785\"/>\n    <line id=\"svg_17\" y2=\"6.960379\" x2=\"2.770632\" y1=\"5.867507\" x1=\"3.037779\"/>\n    <line id=\"svg_18\" y2=\"7.713246\" x2=\"2.673488\" y1=\"6.741804\" x1=\"2.819204\"/>\n    <line id=\"svg_19\" y2=\"8.684687\" x2=\"2.697774\" y1=\"7.616102\" x1=\"2.673488\"/>\n    <line id=\"svg_20\" y2=\"9.753273\" x2=\"2.892062\" y1=\"8.611829\" x1=\"2.697774\"/>\n    <line id=\"svg_21\" y2=\"10.724714\" x2=\"3.134923\" y1=\"9.534698\" x1=\"2.84349\"/>\n    <line id=\"svg_23\" y2=\"11.647583\" x2=\"3.596357\" y1=\"10.578998\" x1=\"3.086351\"/>\n    <line id=\"svg_25\" y2=\"12.521881\" x2=\"4.276366\" y1=\"11.501867\" x1=\"3.499213\"/>\n    <line id=\"svg_26\" y2=\"13.930471\" x2=\"5.830673\" y1=\"12.376165\" x1=\"4.13065\"/>\n    <line id=\"svg_28\" y2=\"14.707624\" x2=\"7.263549\" y1=\"13.881899\" x1=\"5.733528\"/>\n    <line id=\"svg_29\" y2=\"15.339061\" x2=\"8.963571\" y1=\"14.61048\" x1=\"7.06926\"/>\n    <line id=\"svg_30\" y2=\"15.581921\" x2=\"10.882168\" y1=\"15.314775\" x1=\"8.817855\"/>\n    <line id=\"svg_31\" y2=\"15.460491\" x2=\"12.023612\" y1=\"15.581921\" x1=\"10.785024\"/>\n    <line id=\"svg_33\" y2=\"15.120487\" x2=\"13.092197\" y1=\"15.484777\" x1=\"11.877895\"/>\n    <line id=\"svg_34\" y2=\"14.586194\" x2=\"13.86935\" y1=\"15.217631\" x1=\"12.897909\"/>\n    <line id=\"svg_35\" y2=\"13.833327\" x2=\"14.597931\" y1=\"14.756196\" x1=\"13.699348\"/>\n    <line id=\"svg_37\" y2=\"12.716169\" x2=\"15.180796\" y1=\"13.881899\" x1=\"14.549359\"/>\n    <line id=\"svg_39\" y2=\"11.429009\" x2=\"15.520801\" y1=\"12.813313\" x1=\"15.15651\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_40\" cy=\"10.967574\" cx=\"15.520801\"/>\n  </g>`,\n        viewBox: {\n            x: 18,\n            y: 18,\n        },\n    }),\n    FreehandROISculptor: extend(BASE, {\n        name: 'FreehandROISculptor',\n        iconContent: `<g id=\"icon-freehand-sculpt\" fill=\"none\" stroke-width=\"1.5\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <line id=\"svg_1\" y2=\"2.559367\" x2=\"10.184807\" y1=\"4.467781\" x1=\"8.81711\"/>\n    <line id=\"svg_4\" y2=\"1.493836\" x2=\"11.727442\" y1=\"2.766112\" x1=\"10.089386\"/>\n    <line id=\"svg_7\" y2=\"1.080346\" x2=\"13.047428\" y1=\"1.748291\" x1=\"11.345759\"/>\n    <line id=\"svg_8\" y2=\"1.000829\" x2=\"14.351511\" y1=\"1.112153\" x1=\"12.77707\"/>\n    <line id=\"svg_9\" y2=\"1.350705\" x2=\"15.242104\" y1=\"0.905408\" x1=\"13.969828\"/>\n    <line id=\"svg_10\" y2=\"2.098167\" x2=\"15.862339\" y1=\"1.14396\" x1=\"14.955842\"/>\n    <line id=\"svg_11\" y2=\"3.195505\" x2=\"16.41896\" y1=\"1.939133\" x1=\"15.766918\"/>\n    <line id=\"svg_12\" y2=\"4.292843\" x2=\"16.530284\" y1=\"2.925147\" x1=\"16.387153\"/>\n    <line id=\"svg_16\" y2=\"5.644637\" x2=\"16.196311\" y1=\"3.831643\" x1=\"16.593898\"/>\n    <line id=\"svg_18\" y2=\"7.266789\" x2=\"15.623787\" y1=\"5.19934\" x1=\"16.275829\"/>\n    <line id=\"svg_19\" y2=\"10.813258\" x2=\"14.526449\" y1=\"6.726071\" x1=\"15.766918\"/>\n    <line id=\"svg_20\" y2=\"5.056209\" x2=\"8.085552\" y1=\"4.181519\" x1=\"8.976145\"/>\n    <line id=\"svg_23\" y2=\"5.326568\" x2=\"7.481221\" y1=\"4.78585\" x1=\"8.403621\"/>\n    <line id=\"svg_24\" y2=\"5.565119\" x2=\"6.749662\" y1=\"5.294761\" x1=\"7.624352\"/>\n    <line id=\"svg_25\" y2=\"5.994512\" x2=\"5.429675\" y1=\"5.533312\" x1=\"6.956407\"/>\n    <line id=\"svg_27\" y2=\"6.551133\" x2=\"4.284627\" y1=\"5.962706\" x1=\"5.572807\"/>\n    <line id=\"svg_28\" y2=\"7.584858\" x2=\"3.044158\" y1=\"6.392099\" x1=\"4.427758\"/>\n    <line id=\"svg_29\" y2=\"8.84123\" x2=\"2.185372\" y1=\"7.489437\" x1=\"3.219096\"/>\n    <line id=\"svg_31\" y2=\"10.606513\" x2=\"1.644654\" y1=\"8.602678\" x1=\"2.280792\"/>\n    <line id=\"svg_32\" y2=\"13.214679\" x2=\"1.48562\" y1=\"10.352058\" x1=\"1.724171\"/>\n    <line id=\"svg_33\" y2=\"14.375631\" x2=\"1.676461\" y1=\"12.992031\" x1=\"1.453813\"/>\n    <line id=\"svg_34\" y2=\"15.298031\" x2=\"2.264889\" y1=\"14.152983\" x1=\"1.517427\"/>\n    <line id=\"svg_35\" y2=\"16.172721\" x2=\"3.521261\" y1=\"14.948155\" x1=\"1.915013\"/>\n    <line id=\"svg_36\" y2=\"16.824762\" x2=\"5.207027\" y1=\"15.997783\" x1=\"3.28271\"/>\n    <line id=\"svg_38\" y2=\"17.063314\" x2=\"7.035924\" y1=\"16.745245\" x1=\"4.968475\"/>\n    <line id=\"svg_39\" y2=\"16.888376\" x2=\"9.278311\" y1=\"17.047411\" x1=\"6.733758\"/>\n    <line id=\"svg_40\" y2=\"16.284045\" x2=\"10.661911\" y1=\"16.983797\" x1=\"8.992048\"/>\n    <line id=\"svg_41\" y2=\"15.313934\" x2=\"11.647925\" y1=\"16.395369\" x1=\"10.455166\"/>\n    <line id=\"svg_44\" y2=\"13.898527\" x2=\"12.82478\" y1=\"15.425259\" x1=\"11.504794\"/>\n    <line id=\"svg_45\" y2=\"12.037824\" x2=\"14.144766\" y1=\"14.312017\" x1=\"12.522614\"/>\n    <line id=\"svg_47\" y2=\"10.59061\" x2=\"14.605966\" y1=\"12.228665\" x1=\"13.953925\"/>\n    <ellipse ry=\"1\" rx=\"1\" id=\"svg_48\" cy=\"3.982726\" cx=\"13.460918\"/>\n  </g>`,\n        viewBox: {\n            x: 18,\n            y: 18,\n        },\n    }),\n    Length: extend(BASE, {\n        name: 'Length',\n        iconContent: `<g id=\"length-group\" fill=\"none\" stroke-width=\"1\" stroke=\"{{color}}\" stroke-linecap=\"round\" stroke-linejoin=\"round\">\n    <path id=\"length-dashes\" d=\"m22.5,6 -16.5,16.5\" stroke-width=\"3\" stroke-dasharray=\"0.6666,5\" />\n  </g>`,\n        viewBox: {\n            x: 24,\n            y: 24,\n        },\n    }),\n    Height: extend(BASE, {\n        name: 'Height',\n        iconContent: `<path d=\"m 6 22 l 8.5 0 v -16 h 8\" stroke-width=\"3\" fill=\"none\" stroke=\"{{color}}\" />`,\n        viewBox: {\n            x: 24,\n            y: 24,\n        },\n    }),\n    Probe: extend(BASE, {\n        name: 'Probe',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1152 896q0 106-75 181t-181 75-181-75-75-181 75-181 181-75 181 75\n    75 181zm-256-544q-148 0-273 73t-198 198-73 273 73 273 198 198 273 73 273-73\n    198-198 73-273-73-273-198-198-273-73zm768 544q0 209-103 385.5t-279.5\n    279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5\n    385.5-103 385.5 103 279.5 279.5 103 385.5z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    RectangleROI: extend(BASE, {\n        name: 'RectangleROI',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1312 256h-832q-66 0-113 47t-47 113v832q0 66 47\n    113t113 47h832q66 0 113-47t47-113v-832q0-66-47-113t-113-47zm288 160v832q0\n    119-84.5 203.5t-203.5 84.5h-832q-119 0-203.5-84.5t-84.5-203.5v-832q0-119\n    84.5-203.5t203.5-84.5h832q119 0 203.5 84.5t84.5 203.5z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Label: extend(BASE, {\n        name: 'Label',\n        iconContent: `<path fill=\"{{color}}\" d=\"M789 559l-170 450q33 0 136.5 2t160.5 2q19 0\n    57-2-87-253-184-452zm-725 1105l2-79q23-7 56-12.5t57-10.5 49.5-14.5 44.5-29\n    31-50.5l237-616 280-724h128q8 14 11 21l205 480q33 78 106 257.5t114 274.5q15\n    34 58 144.5t72 168.5q20 45 35 57 19 15 88 29.5t84 20.5q6 38 6 57 0 5-.5\n    13.5t-.5 12.5q-63 0-190-8t-191-8q-76 0-215 7t-178 8q0-43 4-78l131-28q1 0\n    12.5-2.5t15.5-3.5 14.5-4.5 15-6.5 11-8 9-11\n    2.5-14q0-16-31-96.5t-72-177.5-42-100l-450-2q-26 58-76.5 195.5t-50.5 162.5q0\n    22 14 37.5t43.5 24.5 48.5 13.5 57 8.5 41 4q1 19 1 58 0 9-2 27-58\n    0-174.5-10t-174.5-10q-8 0-26.5 4t-21.5 4q-80 14-188 14z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Crosshairs: extend(BASE, {\n        name: 'Crosshairs',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1325 1024h-109q-26 0-45-19t-19-45v-128q0-26\n    19-45t45-19h109q-32-108-112.5-188.5t-188.5-112.5v109q0 26-19 45t-45\n    19h-128q-26 0-45-19t-19-45v-109q-108 32-188.5 112.5t-112.5 188.5h109q26\n    0 45 19t19 45v128q0 26-19 45t-45 19h-109q32 108 112.5 188.5t188.5\n    112.5v-109q0-26 19-45t45-19h128q26 0 45 19t19 45v109q108-32\n    188.5-112.5t112.5-188.5zm339-192v128q0 26-19 45t-45 19h-143q-37 161-154.5\n    278.5t-278.5 154.5v143q0 26-19 45t-45 19h-128q-26\n    0-45-19t-19-45v-143q-161-37-278.5-154.5t-154.5-278.5h-143q-26\n    0-45-19t-19-45v-128q0-26 19-45t45-19h143q37-161\n    154.5-278.5t278.5-154.5v-143q0-26 19-45t45-19h128q26 0 45 19t19 45v143q161\n    37 278.5 154.5t154.5 278.5h143q26 0 45 19t19 45z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Eraser: extend(BASE, {\n        name: 'Eraser',\n        iconContent: `<path transform=\"translate(0,1792) scale(1,-1)\" fill=\"{{color}}\" d=\"M960 1408l336-384h-768l-336 384h768zm1013-1077q15\n    34 9.5 71.5t-30.5 65.5l-896 1024q-38 44-96 44h-768q-38\n    0-69.5-20.5t-47.5-54.5q-15-34-9.5-71.5t30.5-65.5l896-1024q38-44 96-44h768q38\n    0 69.5 20.5t47.5 54.5z\" />`,\n        viewBox: {\n            x: 2048,\n            y: 1792,\n        },\n    }),\n    Magnify: extend(BASE, {\n        name: 'Magnify',\n        iconContent: `<path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />`,\n        viewBox: {\n            x: 512,\n            y: 512,\n        },\n    }),\n    Pan: extend(BASE, {\n        name: 'Pan',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1411 541l-355 355 355 355 144-144q29-31 70-14 39 17\n    39 59v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39 14-69l144-144-355-355-355\n    355 144 144q31 30 14 69-17 40-59 40h-448q-26 0-45-19t-19-45v-448q0-42 40-59\n    39-17 69 14l144 144 355-355-355-355-144 144q-19 19-45 19-12\n    0-24-5-40-17-40-59v-448q0-26 19-45t45-19h448q42 0 59 40 17 39-14 69l-144\n    144 355 355 355-355-144-144q-31-30-14-69 17-40 59-40h448q26 0 45 19t19\n    45v448q0 42-39 59-13 5-25 5-26 0-45-19z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    Rotate: extend(BASE, {\n        name: 'Rotate',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1664 256v448q0 26-19 45t-45 19h-448q-42 0-59-40-17-39\n    14-69l138-138q-148-137-349-137-104 0-198.5 40.5t-163.5 109.5-109.5\n    163.5-40.5 198.5 40.5 198.5 109.5 163.5 163.5 109.5 198.5 40.5q119 0\n    225-52t179-147q7-10 23-12 15 0 25 9l137 138q9 8 9.5 20.5t-7.5 22.5q-109\n    132-264 204.5t-327 72.5q-156 0-298-61t-245-164-164-245-61-298 61-298\n    164-245 245-164 298-61q147 0 284.5 55.5t244.5 156.5l130-129q29-31 70-14\n    39 17 39 59z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    StackScroll: extend(BASE, {\n        name: 'StackScroll',\n        iconContent: `<path fill=\"{{color}}\" d=\"M24 21v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1zM24 13v2c0\n    0.547-0.453 1-1 1h-22c-0.547 0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547\n    0 1 0.453 1 1zM24 5v2c0 0.547-0.453 1-1 1h-22c-0.547\n    0-1-0.453-1-1v-2c0-0.547 0.453-1 1-1h22c0.547 0 1 0.453 1 1z\" />`,\n        viewBox: {\n            x: 24,\n            y: 28,\n        },\n    }),\n    WindowLevelRegion: extend(BASE, {\n        name: 'WindowLevelRegion',\n        iconContent: `<path fill=\"{{color}}\" d=\"M1664 416v960q0 119-84.5 203.5t-203.5 84.5h-960q-119\n    0-203.5-84.5t-84.5-203.5v-960q0-119 84.5-203.5t203.5-84.5h960q119 0 203.5\n    84.5t84.5 203.5z\" />`,\n        viewBox: {\n            x: 1792,\n            y: 1792,\n        },\n    }),\n    WindowLevel: extend(BASE, {\n        name: 'WindowLevel',\n        iconContent: `\n    <path fill=\"{{color}}\" d=\"M14.5,3.5 a1 1 0 0 1 -11,11 Z\" stroke=\"none\" opacity=\"0.8\" />\n    <circle cx=\"9\" cy=\"9\" r=\"8\" fill=\"none\" stroke-width=\"2\" stroke=\"{{color}}\" />`,\n        viewBox: {\n            x: 18,\n            y: 18,\n        },\n    }),\n    Zoom: extend(BASE, {\n        name: 'Zoom',\n        iconContent: `\n  <path fill=\"{{color}}\" d=\"M508.5 481.6l-129-129c-2.3-2.3-5.3-3.5-8.5-3.5h-10.3C395\n    312 416 262.5 416 208 416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c54.5\n    0 104-21 141.1-55.2V371c0 3.2 1.3 6.2 3.5 8.5l129 129c4.7 4.7 12.3 4.7 17\n    0l9.9-9.9c4.7-4.7 4.7-12.3 0-17zM208 384c-97.3 0-176-78.7-176-176S110.7 32 208\n    32s176 78.7 176 176-78.7 176-176 176z\" />\n  <path fill=\"{{color}}\" transform=\"scale(0.22,0.22) translate(1400,0)\" d=\"M1216\n    320q0 26-19 45t-45 19h-128v1024h128q26 0 45 19t19 45-19 45l-256 256q-19\n    19-45 19t-45-19l-256-256q-19-19-19-45t19-45 45-19h128v-1024h-128q-26\n    0-45-19t-19-45 19-45l256-256q19-19 45-19t45 19l256 256q19 19 19 45z\" />`,\n        viewBox: {\n            x: 640,\n            y: 512,\n        },\n    }),\n    SegmentationFreeHandEraseInside: extend(BASE, {\n        name: 'SegmentationFreeHandEraseInside',\n        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationFreeHandFillInside: extend(BASE, {\n        name: 'SegmentationFreeHandFillInside',\n        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationFreeHandEraseOutside: extend(BASE, {\n        name: 'SegmentationFreeHandEraseOutside',\n        iconContent: `${SCISSOR_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationFreeHandFillOutside: extend(BASE, {\n        name: 'SegmentationFreeHandFillOutside',\n        iconContent: `${SCISSOR_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    SegmentationRectangleEraseInside: extend(BASE, {\n        name: 'SegmentationRectangleEraseInside',\n        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    RectangleScissor: extend(BASE, {\n        name: 'RectangleScissor',\n        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.FILL_INSIDE': extend(BASE, {\n        name: 'RectangleScissor.FILL_INSIDE',\n        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.FILL_OUTSIDE': extend(BASE, {\n        name: 'RectangleScissor.FILL_OUTSIDE',\n        iconContent: `${RECTANGLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.ERASE_OUTSIDE': extend(BASE, {\n        name: 'RectangleScissor.ERASE_OUTSIDE',\n        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'RectangleScissor.ERASE_INSIDE': extend(BASE, {\n        name: 'RectangleScissor.ERASE_INSIDE',\n        iconContent: `${RECTANGLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    CircleScissor: extend(BASE, {\n        name: 'CircleScissor',\n        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'CircleScissor.FILL_INSIDE': extend(BASE, {\n        name: 'CircleScissor.FILL_INSIDE',\n        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'CircleScissor.ERASE_OUTSIDE': extend(BASE, {\n        name: 'CircleScissor.ERASE_OUTSIDE',\n        iconContent: `${CIRCLE_ICON} ${MINUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n    'CircleScissor.FILL_OUTSIDE': extend(BASE, {\n        name: 'CircleScissor.FILL_OUTSIDE',\n        iconContent: `${CIRCLE_ICON} ${PLUS_RECT}`,\n        viewBox: SEGMENTATION_CURSOR_BOUNDARIES,\n    }),\n};\nfunction extend(base, values) {\n    return Object.assign(Object.create(base), {\n        ...values,\n        name: values.name || base.name,\n    });\n}\nfunction registerCursor(toolName, iconContent, viewBox) {\n    CursorSVG[toolName] = extend(BASE, {\n        iconContent,\n        viewBox,\n    });\n}\nfunction getDefinedSVGCursorDescriptor(name) {\n    return CursorSVG[name];\n}\nconst svgCursorNames = Object.keys(CursorSVG);\nexport { getDefinedSVGCursorDescriptor, registerCursor, svgCursorNames, CursorSVG, };\n","import { ToolModes, AnnotationStyleStates } from '../enums';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport { getDefinedSVGCursorDescriptor } from './SVGCursorDescriptor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\nconst PROPERTY = 'color';\nconst STATE = AnnotationStyleStates.Highlighted;\nconst MODE = ToolModes.Active;\nexport default class SVGMouseCursor extends ImageMouseCursor {\n    constructor(url, x, y, name, fallback) {\n        super(url, x, y, name, fallback);\n    }\n    static getDefinedCursor(name, pointer = false, color) {\n        if (!color) {\n            color = getStyleProperty(PROPERTY, {}, STATE, MODE);\n        }\n        const urn = getCursorURN(name, pointer, color);\n        let cursor = super.getDefinedCursor(urn);\n        const pointerStrokeWidth = Number(getStyleProperty('pointerStrokeWidth', {}));\n        if (!cursor) {\n            const descriptor = getDefinedSVGCursorDescriptor(name);\n            if (descriptor) {\n                cursor = createSVGMouseCursor(descriptor, urn, pointer, color, pointerStrokeWidth, super.getDefinedCursor('default'));\n                super.setDefinedCursor(urn, cursor);\n            }\n        }\n        return cursor;\n    }\n}\nfunction format(template, dictionary) {\n    const dict = Object(dictionary);\n    const defined = Object.prototype.hasOwnProperty.bind(dict);\n    return (template + '').replace(/\\{\\{(\\w+)\\}\\}/g, (match, key) => {\n        return defined(key) ? dict[key] + '' : '';\n    });\n}\nfunction getCursorURN(name, pointer, color) {\n    const type = pointer ? 'pointer' : 'cursor';\n    return `${type}:${name}/${color}`;\n}\nfunction createSVGMouseCursor(descriptor, name, pointer, color, pointerStrokeWidth, fallback) {\n    const { x, y } = descriptor.mousePoint;\n    return new SVGMouseCursor(createSVGIconUrl(descriptor, pointer, { color, pointerStrokeWidth }), x, y, name, fallback);\n}\nfunction createSVGIconUrl(descriptor, pointer, options) {\n    const blob = createSVGIconBlob(descriptor, pointer, options);\n    const url = URL.createObjectURL(blob);\n    const urn = `${url}#${descriptor.name || 'unknown'}-${pointer ? 'pointer' : 'cursor'}`;\n    return urn;\n}\nfunction createSVGIconBlob(descriptor, pointer, options) {\n    const svgString = (pointer ? createSVGIconWithPointer : createSVGIcon)(descriptor, options);\n    return new Blob([svgString], { type: 'image/svg+xml' });\n}\nfunction createSVGIcon(descriptor, options) {\n    const { iconContent, iconSize, viewBox } = descriptor;\n    const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${iconSize}\" height=\"${iconSize}\" viewBox=\"0 0\n      ${viewBox.x} ${viewBox.y}\">\n      ${iconContent}\n    </svg>`;\n    return format(svgString, options);\n}\nfunction createSVGIconWithPointer(descriptor, options) {\n    const { iconContent, iconSize, viewBox, mousePointerGroupString } = descriptor;\n    const scale = iconSize / Math.max(viewBox.x, viewBox.y, 1);\n    const svgSize = 16 + iconSize;\n    const pointerStrokeWidth = options.pointerStrokeWidth || 1;\n    const svgString = `\n    <svg data-icon=\"cursor\" role=\"img\" xmlns=\"http://www.w3.org/2000/svg\"\n      width=\"${svgSize}\" height=\"${svgSize}\" viewBox=\"0 0 ${svgSize} ${svgSize}\">\n      <g stroke-width=\"${pointerStrokeWidth}\">${mousePointerGroupString}</g>\n      <g transform=\"translate(16, 16) scale(${scale})\">${iconContent}</g>\n    </svg>`;\n    return format(svgString, options);\n}\n","import { setElementCursor } from './elementCursor';\nimport MouseCursor from './MouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\nfunction setCursorForElement(element, cursorName) {\n    let cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n    if (!cursor) {\n        cursor = MouseCursor.getDefinedCursor(cursorName);\n    }\n    if (!cursor) {\n        console.log(`Cursor ${cursorName} is not defined either as SVG or as a standard cursor.`);\n        cursor = MouseCursor.getDefinedCursor(cursorName);\n    }\n    setElementCursor(element, cursor);\n}\nexport default setCursorForElement;\n","import MouseCursor, { standardCursorNames } from './MouseCursor';\nimport ImageMouseCursor from './ImageMouseCursor';\nimport SVGMouseCursor from './SVGMouseCursor';\nimport * as elementCursor from './elementCursor';\nimport setCursorForElement from './setCursorForElement';\nimport { registerCursor, svgCursorNames, CursorSVG, } from './SVGCursorDescriptor';\nconst CursorNames = [...svgCursorNames, ...standardCursorNames];\nexport { MouseCursor, ImageMouseCursor, SVGMouseCursor, elementCursor, registerCursor, CursorNames, CursorSVG, setCursorForElement, };\n","import _getHash from './_getHash';\nimport drawEllipseByCoordinates from './drawEllipseByCoordinates';\nfunction drawEllipse(svgDrawingHelper, annotationUID, ellipseUID, corner1, corner2, options = {}, dataId = '') {\n    const top = [(corner1[0] + corner2[0]) / 2, corner1[1]];\n    const bottom = [(corner1[0] + corner2[0]) / 2, corner2[1]];\n    const left = [corner1[0], (corner1[1] + corner2[1]) / 2];\n    const right = [corner2[0], (corner1[1] + corner2[1]) / 2];\n    drawEllipseByCoordinates(svgDrawingHelper, annotationUID, ellipseUID, [bottom, top, left, right], (options = {}), (dataId = ''));\n}\nexport default drawEllipse;\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nfunction drawEllipseByCoordinates(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, options = {}, dataId = '') {\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'ellipse', ellipseUID);\n    const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const [bottom, top, left, right] = canvasCoordinates;\n    const w = Math.hypot(left[0] - right[0], left[1] - right[1]);\n    const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);\n    const angle = (Math.atan2(left[1] - right[1], left[0] - right[0]) * 180) / Math.PI;\n    const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];\n    const radiusX = w / 2;\n    const radiusY = h / 2;\n    const attributes = {\n        cx: `${center[0]}`,\n        cy: `${center[1]}`,\n        rx: `${radiusX}`,\n        ry: `${radiusY}`,\n        stroke: color,\n        fill: 'transparent',\n        transform: `rotate(${angle} ${center[0]} ${center[1]})`,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingEllipse) {\n        setAttributesIfNecessary(attributes, existingEllipse);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgEllipseElement = document.createElementNS(svgns, 'ellipse');\n        if (dataId !== '') {\n            svgEllipseElement.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, svgEllipseElement);\n        svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);\n    }\n}\nexport default drawEllipseByCoordinates;\n","import _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nfunction drawHandle(svgDrawingHelper, annotationUID, handleGroupUID, handle, options = {}, uniqueIndex) {\n    const { color, handleRadius, width, lineWidth, fill, type, opacity } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        handleRadius: '6',\n        width: '2',\n        lineWidth: undefined,\n        fill: 'transparent',\n        type: 'circle',\n        opacity: 1,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'handle', `hg-${handleGroupUID}-index-${uniqueIndex}`);\n    let attributes;\n    if (type === 'circle') {\n        attributes = {\n            cx: `${handle[0]}`,\n            cy: `${handle[1]}`,\n            r: handleRadius,\n            stroke: color,\n            fill,\n            'stroke-width': strokeWidth,\n            opacity: opacity,\n        };\n    }\n    else if (type === 'rect') {\n        const handleRadiusFloat = parseFloat(handleRadius);\n        const side = handleRadiusFloat * 1.5;\n        const x = handle[0] - side * 0.5;\n        const y = handle[1] - side * 0.5;\n        attributes = {\n            x: `${x}`,\n            y: `${y}`,\n            width: `${side}`,\n            height: `${side}`,\n            stroke: color,\n            fill,\n            'stroke-width': strokeWidth,\n            rx: `${side * 0.1}`,\n            opacity: opacity,\n        };\n    }\n    else {\n        throw new Error(`Unsupported handle type: ${type}`);\n    }\n    const existingHandleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n    if (existingHandleElement) {\n        setAttributesIfNecessary(attributes, existingHandleElement);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newHandleElement = document.createElementNS(svgns, type);\n        setNewAttributesIfValid(attributes, newHandleElement);\n        svgDrawingHelper.appendNode(newHandleElement, svgNodeHash);\n    }\n}\nexport default drawHandle;\n","import _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nexport default function drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, options = {}, dataId = '') {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { color = 'rgb(0, 255, 0)', width = 10, lineWidth, lineDash, markerStartId = null, markerEndId = null, shadow = false, strokeOpacity = 1, textBoxLinkLineColor, } = options;\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'line', lineUID);\n    const existingLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const layerId = svgDrawingHelper.svgLayerElement.id;\n    const dropShadowStyle = shadow ? `filter:url(#shadow-${layerId});` : '';\n    const attributes = {\n        x1: `${start[0]}`,\n        y1: `${start[1]}`,\n        x2: `${end[0]}`,\n        y2: `${end[1]}`,\n        stroke: textBoxLinkLineColor || color,\n        style: dropShadowStyle,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n        'marker-start': markerStartId ? `url(#${markerStartId})` : '',\n        'marker-end': markerEndId ? `url(#${markerEndId})` : '',\n        'stroke-opacity': strokeOpacity,\n    };\n    if (existingLine) {\n        setAttributesIfNecessary(attributes, existingLine);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newLine = document.createElementNS(svgns, 'line');\n        if (dataId !== '') {\n            newLine.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, newLine);\n        svgDrawingHelper.appendNode(newLine, svgNodeHash);\n    }\n}\n","import _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nexport default function drawPath(svgDrawingHelper, annotationUID, pathUID, points, options) {\n    const hasSubArrays = points.length && points[0].length && Array.isArray(points[0][0]);\n    const pointsArrays = hasSubArrays ? points : [points];\n    const { color = 'rgb(0, 255, 0)', width = 10, fillColor = 'none', fillOpacity = 0, lineWidth, lineDash, closePath = false, } = options;\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'path', pathUID);\n    const existingNode = svgDrawingHelper.getSvgNode(svgNodeHash);\n    let pointsAttribute = '';\n    for (let i = 0, numArrays = pointsArrays.length; i < numArrays; i++) {\n        const points = pointsArrays[i];\n        const numPoints = points.length;\n        if (numPoints < 2) {\n            continue;\n        }\n        for (let j = 0; j < numPoints; j++) {\n            const point = points[j];\n            const cmd = j ? 'L' : 'M';\n            pointsAttribute += `${cmd} ${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;\n        }\n        if (closePath) {\n            pointsAttribute += 'Z ';\n        }\n    }\n    if (!pointsAttribute) {\n        return;\n    }\n    const attributes = {\n        d: pointsAttribute,\n        stroke: color,\n        fill: fillColor,\n        'fill-opacity': fillOpacity,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingNode) {\n        setAttributesIfNecessary(attributes, existingNode);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newNode = document.createElementNS(svgns, 'path');\n        setNewAttributesIfValid(attributes, newNode);\n        svgDrawingHelper.appendNode(newNode, svgNodeHash);\n    }\n}\n","import _getHash from './_getHash';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nexport default function drawPolyline(svgDrawingHelper, annotationUID, polylineUID, points, options) {\n    if (points.length < 2) {\n        return;\n    }\n    const { color = 'rgb(0, 255, 0)', width = 10, fillColor = 'none', fillOpacity = 0, lineWidth, lineDash, closePath = false, markerStartId = null, markerEndId = null, } = options;\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'polyline', polylineUID);\n    const existingPolyLine = svgDrawingHelper.getSvgNode(svgNodeHash);\n    let pointsAttribute = '';\n    for (const point of points) {\n        pointsAttribute += `${point[0].toFixed(1)}, ${point[1].toFixed(1)} `;\n    }\n    if (closePath) {\n        const firstPoint = points[0];\n        pointsAttribute += `${firstPoint[0]}, ${firstPoint[1]}`;\n    }\n    const attributes = {\n        points: pointsAttribute,\n        stroke: color,\n        fill: fillColor,\n        'fill-opacity': fillOpacity,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n        'marker-start': markerStartId ? `url(#${markerStartId})` : '',\n        'marker-end': markerEndId ? `url(#${markerEndId})` : '',\n    };\n    if (existingPolyLine) {\n        setAttributesIfNecessary(attributes, existingPolyLine);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newPolyLine = document.createElementNS(svgns, 'polyline');\n        setNewAttributesIfValid(attributes, newPolyLine);\n        svgDrawingHelper.appendNode(newPolyLine, svgNodeHash);\n    }\n}\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nexport default function drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, options = {}, dataId = '') {\n    const { color, width: _width, lineWidth, lineDash, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || _width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const [topLeft, topRight, bottomLeft, bottomRight] = canvasCoordinates;\n    const width = Math.hypot(topLeft[0] - topRight[0], topLeft[1] - topRight[1]);\n    const height = Math.hypot(topLeft[0] - bottomLeft[0], topLeft[1] - bottomLeft[1]);\n    const center = [\n        (bottomRight[0] + topLeft[0]) / 2,\n        (bottomRight[1] + topLeft[1]) / 2,\n    ];\n    const leftEdgeCenter = [\n        (bottomLeft[0] + topLeft[0]) / 2,\n        (bottomLeft[1] + topLeft[1]) / 2,\n    ];\n    const angle = (Math.atan2(center[1] - leftEdgeCenter[1], center[0] - leftEdgeCenter[0]) *\n        180) /\n        Math.PI;\n    const attributes = {\n        x: `${center[0] - width / 2}`,\n        y: `${center[1] - height / 2}`,\n        width: `${width}`,\n        height: `${height}`,\n        stroke: color,\n        fill: 'transparent',\n        transform: `rotate(${angle} ${center[0]} ${center[1]})`,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingRect) {\n        setAttributesIfNecessary(attributes, existingRect);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgRectElement = document.createElementNS(svgns, 'rect');\n        if (dataId !== '') {\n            svgRectElement.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, svgRectElement);\n        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n    }\n}\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nfunction drawTextBox(svgDrawingHelper, annotationUID, textUID, textLines, position, options = {}) {\n    const mergedOptions = Object.assign({\n        fontFamily: 'Helvetica, Arial, sans-serif',\n        fontSize: '14px',\n        color: 'rgb(255, 255, 0)',\n        background: '',\n        padding: 25,\n        centerX: false,\n        centerY: true,\n    }, options);\n    const textGroupBoundingBox = _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines, position, mergedOptions);\n    return textGroupBoundingBox;\n}\nfunction _drawTextGroup(svgDrawingHelper, annotationUID, textUID, textLines = [''], position, options) {\n    const { padding, color, fontFamily, fontSize, background, textBoxBorderRadius, textBoxMargin, } = options;\n    let textGroupBoundingBox;\n    const [x, y] = [position[0] + padding, position[1] + padding];\n    const backgroundStyles = {\n        color: background,\n        textBoxBorderRadius,\n        textBoxMargin,\n    };\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'text', textUID);\n    const existingTextGroup = svgDrawingHelper.getSvgNode(svgNodeHash);\n    if (existingTextGroup) {\n        const textElement = existingTextGroup.querySelector('text');\n        const textSpans = Array.from(textElement.children);\n        for (let i = 0; i < textSpans.length; i++) {\n            const textSpanElement = textSpans[i];\n            const text = textLines[i] || '';\n            textSpanElement.textContent = text;\n        }\n        if (textLines.length > textSpans.length) {\n            for (let i = 0; i < textLines.length - textSpans.length; i++) {\n                const textLine = textLines[i + textSpans.length];\n                const textSpan = _createTextSpan(textLine);\n                textElement.appendChild(textSpan);\n            }\n            existingTextGroup.appendChild(textElement);\n            svgDrawingHelper.appendNode(existingTextGroup, svgNodeHash);\n        }\n        const textAttributes = {\n            fill: color,\n            'font-size': fontSize,\n            'font-family': fontFamily,\n        };\n        const textGroupAttributes = {\n            transform: `translate(${x} ${y})`,\n        };\n        setAttributesIfNecessary(textAttributes, textElement);\n        setAttributesIfNecessary(textGroupAttributes, existingTextGroup);\n        existingTextGroup.setAttribute('data-annotation-uid', annotationUID);\n        textGroupBoundingBox = _drawTextBackground(existingTextGroup, backgroundStyles);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const textGroup = document.createElementNS(svgns, 'g');\n        textGroup.setAttribute('data-annotation-uid', annotationUID);\n        textGroup.setAttribute('transform', `translate(${x} ${y})`);\n        const textElement = _createTextElement(svgDrawingHelper, options);\n        for (let i = 0; i < textLines.length; i++) {\n            const textLine = textLines[i];\n            const textSpan = _createTextSpan(textLine);\n            textElement.appendChild(textSpan);\n        }\n        textGroup.appendChild(textElement);\n        svgDrawingHelper.appendNode(textGroup, svgNodeHash);\n        textGroupBoundingBox = _drawTextBackground(textGroup, background);\n    }\n    return Object.assign({}, textGroupBoundingBox, {\n        x,\n        y,\n        height: textGroupBoundingBox.height + padding,\n        width: textGroupBoundingBox.width + padding,\n    });\n}\nfunction _createTextElement(svgDrawingHelper, options) {\n    const { color, fontFamily, fontSize } = options;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const textElement = document.createElementNS(svgns, 'text');\n    const noSelectStyle = 'user-select: none; pointer-events: none; -webkit-tap-highlight-color:  rgba(255, 255, 255, 0);';\n    const dropShadowStyle = `filter:url(#shadow-${svgDrawingHelper.svgLayerElement.id});`;\n    const combinedStyle = `${noSelectStyle}${dropShadowStyle}`;\n    textElement.setAttribute('x', '0');\n    textElement.setAttribute('y', '0');\n    textElement.setAttribute('fill', color);\n    textElement.setAttribute('font-family', fontFamily);\n    textElement.setAttribute('font-size', fontSize);\n    textElement.setAttribute('style', combinedStyle);\n    textElement.setAttribute('pointer-events', 'visible');\n    return textElement;\n}\nfunction _createTextSpan(text) {\n    const svgns = 'http://www.w3.org/2000/svg';\n    const textSpanElement = document.createElementNS(svgns, 'tspan');\n    textSpanElement.setAttribute('x', '0');\n    textSpanElement.setAttribute('dy', '1.2em');\n    textSpanElement.textContent = text;\n    return textSpanElement;\n}\nfunction _drawTextBackground(group, backgroundStyles) {\n    const { color, textBoxBorderRadius = 0, textBoxMargin = 0, } = backgroundStyles;\n    let element = group.querySelector('rect.background');\n    const textElement = group.querySelector('text').getBBox();\n    if (!color) {\n        if (element) {\n            group.removeChild(element);\n        }\n        return group.getBBox();\n    }\n    if (!element) {\n        element = document.createElementNS('http://www.w3.org/2000/svg', 'rect');\n        element.setAttribute('class', 'background');\n        group.insertBefore(element, group.firstChild);\n    }\n    const bBox = group.getBBox();\n    const attributes = {\n        x: `${bBox.x}`,\n        y: `${bBox.y}`,\n        width: `${textElement.width + Number(textBoxMargin) * 2}`,\n        height: `${textElement.height + Number(textBoxMargin) * 2}`,\n        fill: color,\n        rx: textBoxBorderRadius,\n        ry: textBoxBorderRadius,\n    };\n    if (textBoxMargin) {\n        const tSpans = Array.from(group.querySelector('text').querySelectorAll('tspan'));\n        tSpans.forEach((tspan, i) => {\n            i === 0 && tspan.setAttribute('y', textBoxMargin);\n            tspan.setAttribute('x', textBoxMargin);\n        });\n    }\n    setAttributesIfNecessary(attributes, element);\n    return bBox;\n}\nexport default drawTextBox;\n","import drawLine from './drawLine';\nexport default function drawHeight(svgDrawingHelper, annotationUID, heightUID, start, end, options = {}) {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const midX = end[0] + (start[0] - end[0]) / 2;\n    const endfirstLine = [midX, start[1]];\n    const endsecondLine = [midX, end[1]];\n    const firstLine = {\n        start: start,\n        end: endfirstLine,\n    };\n    const secondLine = {\n        start: endfirstLine,\n        end: endsecondLine,\n    };\n    const threeLine = {\n        start: endsecondLine,\n        end: end,\n    };\n    drawLine(svgDrawingHelper, annotationUID, '1', firstLine.start, firstLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '2', secondLine.start, secondLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '3', threeLine.start, threeLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n}\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nfunction drawFan(svgDrawingHelper, annotationUID, fanUID, center, innerRadius, outerRadius, startAngle, endAngle, options = {}, dataId = '', zIndex) {\n    const { color, fill, width, lineWidth, lineDash, fillOpacity, strokeOpacity, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        fill: 'transparent',\n        width: '2',\n        lineDash: undefined,\n        lineWidth: undefined,\n        strokeOpacity: 1,\n        fillOpacity: 1,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'fan', fanUID);\n    const existingFanElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const startRad = (startAngle * Math.PI) / 180;\n    const endRad = (endAngle * Math.PI) / 180;\n    const centerX = center[0];\n    const centerY = center[1];\n    const outerStartX = centerX + outerRadius * Math.cos(startRad);\n    const outerStartY = centerY + outerRadius * Math.sin(startRad);\n    const outerEndX = centerX + outerRadius * Math.cos(endRad);\n    const outerEndY = centerY + outerRadius * Math.sin(endRad);\n    const innerStartX = centerX + innerRadius * Math.cos(startRad);\n    const innerStartY = centerY + innerRadius * Math.sin(startRad);\n    const innerEndX = centerX + innerRadius * Math.cos(endRad);\n    const innerEndY = centerY + innerRadius * Math.sin(endRad);\n    const largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1;\n    let pathData = `M ${outerStartX} ${outerStartY}`;\n    pathData += ` A ${outerRadius} ${outerRadius} 0 ${largeArcFlag} 1 ${outerEndX} ${outerEndY}`;\n    pathData += ` L ${innerEndX} ${innerEndY}`;\n    pathData += ` A ${innerRadius} ${innerRadius} 0 ${largeArcFlag} 0 ${innerStartX} ${innerStartY}`;\n    pathData += ` Z`;\n    const attributes = {\n        d: pathData,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n        'fill-opacity': fillOpacity,\n        'stroke-opacity': strokeOpacity,\n        'mix-blend-mode': 'normal',\n    };\n    if (existingFanElement) {\n        setAttributesIfNecessary(attributes, existingFanElement);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newFanElement = document.createElementNS(svgns, 'path');\n        if (dataId !== '') {\n            newFanElement.setAttribute('data-id', dataId);\n        }\n        if (zIndex !== undefined) {\n            newFanElement.style.zIndex = zIndex.toString();\n        }\n        setNewAttributesIfValid(attributes, newFanElement);\n        svgDrawingHelper.appendNode(newFanElement, svgNodeHash);\n    }\n}\nexport default drawFan;\n","import drawLine from './drawLine';\nconst svgns = 'http://www.w3.org/2000/svg';\nexport default function drawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { viaMarker = false, color = 'rgb(0, 255, 0)', markerSize = 10, } = options;\n    if (!viaMarker) {\n        legacyDrawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options);\n        return;\n    }\n    const layerId = svgDrawingHelper.svgLayerElement.id;\n    const markerBaseId = `arrow-${annotationUID}`;\n    const markerFullId = `${markerBaseId}-${layerId}`;\n    const defs = svgDrawingHelper.svgLayerElement.querySelector('defs');\n    let arrowMarker = defs.querySelector(`#${markerFullId}`);\n    if (!arrowMarker) {\n        arrowMarker = document.createElementNS(svgns, 'marker');\n        arrowMarker.setAttribute('id', markerFullId);\n        arrowMarker.setAttribute('viewBox', '0 0 10 10');\n        arrowMarker.setAttribute('refX', '8');\n        arrowMarker.setAttribute('refY', '5');\n        arrowMarker.setAttribute('markerWidth', `${markerSize}`);\n        arrowMarker.setAttribute('markerHeight', `${markerSize}`);\n        arrowMarker.setAttribute('orient', 'auto');\n        const arrowPath = document.createElementNS(svgns, 'path');\n        arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');\n        arrowPath.setAttribute('fill', color);\n        arrowMarker.appendChild(arrowPath);\n        defs.appendChild(arrowMarker);\n    }\n    else {\n        arrowMarker.setAttribute('markerWidth', `${markerSize}`);\n        arrowMarker.setAttribute('markerHeight', `${markerSize}`);\n        const arrowPath = arrowMarker.querySelector('path');\n        if (arrowPath) {\n            arrowPath.setAttribute('fill', color);\n        }\n    }\n    options.markerEndId = markerFullId;\n    drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, options);\n}\nfunction legacyDrawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {\n    const { color = 'rgb(0, 255, 0)', width = 2, lineWidth, lineDash } = options;\n    const headLength = 10;\n    const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);\n    const firstLine = {\n        start: [\n            end[0] - headLength * Math.cos(angle - Math.PI / 7),\n            end[1] - headLength * Math.sin(angle - Math.PI / 7),\n        ],\n        end: end,\n    };\n    const secondLine = {\n        start: [\n            end[0] - headLength * Math.cos(angle + Math.PI / 7),\n            end[1] - headLength * Math.sin(angle + Math.PI / 7),\n        ],\n        end: end,\n    };\n    drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '2', firstLine.start, firstLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '3', secondLine.start, secondLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n}\n","import _getHash from './_getHash';\nimport _setAttributesIfNecessary from './setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './setNewAttributesIfValid';\nexport default function drawRedactionRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}) {\n    const { color, width: _width, lineWidth, lineDash, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || _width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n    const width = Math.abs(start[0] - end[0]);\n    const height = Math.abs(start[1] - end[1]);\n    const attributes = {\n        x: `${tlhc[0]}`,\n        y: `${tlhc[1]}`,\n        width: `${width}`,\n        height: `${height}`,\n        stroke: color,\n        fill: 'black',\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingRect) {\n        _setAttributesIfNecessary(attributes, existingRect);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgRectElement = document.createElementNS(svgns, 'rect');\n        _setNewAttributesIfValid(attributes, svgRectElement);\n        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n    }\n}\n","export function setAttributesIfNecessary(attributes, svgNode) {\n    Object.keys(attributes).forEach((key) => {\n        const currentValue = svgNode.getAttribute(key);\n        const newValue = attributes[key];\n        if (newValue === undefined || newValue === '') {\n            svgNode.removeAttribute(key);\n        }\n        else if (currentValue !== newValue) {\n            svgNode.setAttribute(key, newValue);\n        }\n    });\n}\nexport default setAttributesIfNecessary;\n","export function setNewAttributesIfValid(attributes, svgNode) {\n    Object.keys(attributes).forEach((key) => {\n        const newValue = attributes[key];\n        if (newValue !== undefined && newValue !== '') {\n            svgNode.setAttribute(key, newValue);\n        }\n    });\n}\nexport default setNewAttributesIfValid;\n","import { eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport InterpolationManager from '../utilities/segmentation/InterpolationManager/InterpolationManager';\nconst enable = function () {\n    eventTarget.addEventListener(Events.ANNOTATION_COMPLETED, InterpolationManager.handleAnnotationCompleted);\n    eventTarget.addEventListener(Events.ANNOTATION_MODIFIED, InterpolationManager.handleAnnotationUpdate);\n    eventTarget.addEventListener(Events.ANNOTATION_REMOVED, InterpolationManager.handleAnnotationDelete);\n};\nconst disable = function () {\n    eventTarget.removeEventListener(Events.ANNOTATION_COMPLETED, InterpolationManager.handleAnnotationCompleted);\n    eventTarget.removeEventListener(Events.ANNOTATION_MODIFIED, InterpolationManager.handleAnnotationUpdate);\n    eventTarget.removeEventListener(Events.ANNOTATION_REMOVED, InterpolationManager.handleAnnotationDelete);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onCameraModified = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onCameraModified) {\n            tool.onCameraModified(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onCameraReset = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onResetCamera) {\n            tool.onResetCamera(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.CAMERA_RESET, onCameraReset);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.CAMERA_RESET, onCameraReset);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { Enums } from '@cornerstonejs/core';\nimport triggerAnnotationRender from '../utilities/triggerAnnotationRender';\nconst onImageRendered = function (evt) {\n    triggerAnnotationRender(evt.detail.element);\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.IMAGE_RENDERED, onImageRendered);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.IMAGE_RENDERED, onImageRendered);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onImageSpacingCalibrated = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onImageSpacingCalibrated) {\n            tool.onImageSpacingCalibrated(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);\n};\nexport default {\n    enable,\n    disable,\n};\n","import Events from '../enums/Events';\nimport { keyDown, keyUp } from './keyboardEventHandlers';\nconst enable = function (element) {\n    element.addEventListener(Events.KEY_DOWN, keyDown);\n    element.addEventListener(Events.KEY_UP, keyUp);\n};\nconst disable = function (element) {\n    element.removeEventListener(Events.KEY_DOWN, keyDown);\n    element.removeEventListener(Events.KEY_UP, keyUp);\n};\nconst keyboardToolEventDispatcher = {\n    enable,\n    disable,\n};\nexport default keyboardToolEventDispatcher;\n","import Events from '../enums/Events';\nimport { mouseClick, mouseDown, mouseDownActivate, mouseDoubleClick, mouseDrag, mouseMove, mouseUp, mouseWheel, } from './mouseEventHandlers';\nconst enable = function (element) {\n    element.addEventListener(Events.MOUSE_CLICK, mouseClick);\n    element.addEventListener(Events.MOUSE_DOWN, mouseDown);\n    element.addEventListener(Events.MOUSE_DOWN_ACTIVATE, mouseDownActivate);\n    element.addEventListener(Events.MOUSE_DOUBLE_CLICK, mouseDoubleClick);\n    element.addEventListener(Events.MOUSE_DRAG, mouseDrag);\n    element.addEventListener(Events.MOUSE_MOVE, mouseMove);\n    element.addEventListener(Events.MOUSE_UP, mouseUp);\n    element.addEventListener(Events.MOUSE_WHEEL, mouseWheel);\n};\nconst disable = function (element) {\n    element.removeEventListener(Events.MOUSE_CLICK, mouseClick);\n    element.removeEventListener(Events.MOUSE_DOWN, mouseDown);\n    element.removeEventListener(Events.MOUSE_DOWN_ACTIVATE, mouseDownActivate);\n    element.removeEventListener(Events.MOUSE_DOUBLE_CLICK, mouseDoubleClick);\n    element.removeEventListener(Events.MOUSE_DRAG, mouseDrag);\n    element.removeEventListener(Events.MOUSE_MOVE, mouseMove);\n    element.removeEventListener(Events.MOUSE_UP, mouseUp);\n    element.removeEventListener(Events.MOUSE_WHEEL, mouseWheel);\n};\nconst mouseToolEventDispatcher = {\n    enable,\n    disable,\n};\nexport default mouseToolEventDispatcher;\n","import Events from '../enums/Events';\nimport { touchStart, touchStartActivate, touchDrag, touchEnd, touchTap, touchPress, } from './touchEventHandlers';\nconst enable = function (element) {\n    element.addEventListener(Events.TOUCH_START, touchStart);\n    element.addEventListener(Events.TOUCH_START_ACTIVATE, touchStartActivate);\n    element.addEventListener(Events.TOUCH_DRAG, touchDrag);\n    element.addEventListener(Events.TOUCH_END, touchEnd);\n    element.addEventListener(Events.TOUCH_TAP, touchTap);\n    element.addEventListener(Events.TOUCH_PRESS, touchPress);\n};\nconst disable = function (element) {\n    element.removeEventListener(Events.TOUCH_START, touchStart);\n    element.removeEventListener(Events.TOUCH_START_ACTIVATE, touchStartActivate);\n    element.removeEventListener(Events.TOUCH_DRAG, touchDrag);\n    element.removeEventListener(Events.TOUCH_END, touchEnd);\n    element.removeEventListener(Events.TOUCH_PRESS, touchPress);\n};\nconst touchToolEventDispatcher = {\n    enable,\n    disable,\n};\nexport default touchToolEventDispatcher;\n","import mouseDoubleClickListener from './mouseDoubleClickListener';\nimport mouseDownListener, { mouseDoubleClickIgnoreListener, } from './mouseDownListener';\nimport mouseMoveListener from './mouseMoveListener';\nfunction disable(element) {\n    element.removeEventListener('dblclick', mouseDoubleClickListener);\n    element.removeEventListener('mousedown', mouseDownListener);\n    element.removeEventListener('mousemove', mouseMoveListener);\n    element.removeEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n        capture: true,\n    });\n}\nfunction enable(element) {\n    disable(element);\n    element.addEventListener('dblclick', mouseDoubleClickListener);\n    element.addEventListener('mousedown', mouseDownListener);\n    element.addEventListener('mousemove', mouseMoveListener);\n    element.addEventListener('dblclick', mouseDoubleClickIgnoreListener, {\n        capture: true,\n    });\n}\nexport default {\n    enable,\n    disable,\n};\n","import preventGhostClick from './preventGhostClick';\nimport touchStartListener from './touchStartListener';\nfunction disable(element) {\n    preventGhostClick.disable(element);\n    element.removeEventListener('touchstart', touchStartListener);\n}\nfunction enable(element) {\n    disable(element);\n    preventGhostClick.enable(element);\n    element.addEventListener('touchstart', touchStartListener, {\n        passive: false,\n    });\n}\nexport default {\n    enable,\n    disable,\n};\n","import wheelListener from './wheelListener';\nfunction enable(element) {\n    disable(element);\n    element.addEventListener('wheel', wheelListener, { passive: false });\n}\nfunction disable(element) {\n    element.removeEventListener('wheel', wheelListener);\n}\nexport default {\n    enable,\n    disable,\n};\n","import { VolumeViewport, getEnabledElementByViewportId, StackViewport, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../../enums';\nimport { performVolumeLabelmapUpdate } from './performVolumeLabelmapUpdate';\nimport { performStackLabelmapUpdate } from './performStackLabelmapUpdate';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { getViewportIdsWithSegmentation } from '../../../stateManagement/segmentation/getViewportIdsWithSegmentation';\nconst onLabelmapSegmentationDataModified = function (evt) {\n    const { segmentationId, modifiedSlicesToUse } = evt.detail;\n    const { representationData } = getSegmentation(segmentationId);\n    const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n    const hasVolumeViewport = viewportIds.some((viewportId) => {\n        const { viewport } = getEnabledElementByViewportId(viewportId);\n        return viewport instanceof VolumeViewport;\n    });\n    const hasStackViewport = viewportIds.some((viewportId) => {\n        const { viewport } = getEnabledElementByViewportId(viewportId);\n        return viewport instanceof StackViewport;\n    });\n    const hasBothStackAndVolume = hasVolumeViewport && hasStackViewport;\n    viewportIds.forEach((viewportId) => {\n        const { viewport } = getEnabledElementByViewportId(viewportId);\n        if (viewport instanceof VolumeViewport) {\n            performVolumeLabelmapUpdate({\n                modifiedSlicesToUse: hasBothStackAndVolume ? [] : modifiedSlicesToUse,\n                representationData,\n                type: SegmentationRepresentations.Labelmap,\n            });\n        }\n        if (viewport instanceof StackViewport) {\n            performStackLabelmapUpdate({\n                viewportIds,\n                segmentationId,\n            });\n        }\n    });\n};\nexport default onLabelmapSegmentationDataModified;\n","import { cache } from '@cornerstonejs/core';\nexport function performVolumeLabelmapUpdate({ modifiedSlicesToUse, representationData, type, }) {\n    const segmentationVolume = cache.getVolume(representationData[type].volumeId);\n    if (!segmentationVolume) {\n        console.warn('segmentation not found in cache');\n        return;\n    }\n    const { imageData, vtkOpenGLTexture } = segmentationVolume;\n    let slicesToUpdate;\n    if (modifiedSlicesToUse?.length > 0) {\n        slicesToUpdate = modifiedSlicesToUse;\n    }\n    else {\n        const numSlices = imageData.getDimensions()[2];\n        slicesToUpdate = [...Array(numSlices).keys()];\n    }\n    slicesToUpdate.forEach((i) => {\n        vtkOpenGLTexture.setUpdatedFrame(i);\n    });\n    imageData.modified();\n}\n","import { cache, utilities as csUtils, VolumeViewport, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../../enums';\nimport { getLabelmapActorEntries } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nimport { getSegmentationRepresentations } from '../../../stateManagement/segmentation/getSegmentationRepresentation';\nimport { getCurrentLabelmapImageIdsForViewport } from '../../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nexport function performStackLabelmapUpdate({ viewportIds, segmentationId, }) {\n    viewportIds.forEach((viewportId) => {\n        let representations = getSegmentationRepresentations(viewportId, {\n            segmentationId,\n        });\n        representations = representations.filter((representation) => representation.type === SegmentationRepresentations.Labelmap);\n        representations.forEach((representation) => {\n            if (representation.segmentationId !== segmentationId) {\n                return;\n            }\n            const enabledElement = getEnabledElementByViewportId(viewportId);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            if (viewport instanceof VolumeViewport) {\n                return;\n            }\n            const actorEntries = getLabelmapActorEntries(viewportId, segmentationId);\n            if (!actorEntries?.length) {\n                return;\n            }\n            actorEntries.forEach((actorEntry, i) => {\n                const segImageData = actorEntry.actor.getMapper().getInputData();\n                const currentSegmentationImageIds = getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);\n                const segmentationImage = cache.getImage(currentSegmentationImageIds[i]);\n                segImageData.modified();\n                csUtils.updateVTKImageDataWithCornerstoneImage(segImageData, segmentationImage);\n            });\n        });\n    });\n}\n","import { triggerSegmentationRenderBySegmentationId } from '../../stateManagement/segmentation/SegmentationRenderingEngine';\nimport onLabelmapSegmentationDataModified from './labelmap/onLabelmapSegmentationDataModified';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nconst onSegmentationDataModified = function (evt) {\n    const { segmentationId } = evt.detail;\n    const { representationData } = getSegmentation(segmentationId);\n    if (representationData.Labelmap) {\n        onLabelmapSegmentationDataModified(evt);\n    }\n    triggerSegmentationRenderBySegmentationId(segmentationId);\n};\nexport default onSegmentationDataModified;\n","import { triggerSegmentationRenderBySegmentationId } from '../../stateManagement/segmentation/SegmentationRenderingEngine';\nconst segmentationModifiedListener = function (evt) {\n    const { segmentationId } = evt.detail;\n    triggerSegmentationRenderBySegmentationId(segmentationId);\n};\nexport default segmentationModifiedListener;\n","import vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { BaseVolumeViewport, getEnabledElement, Enums, getEnabledElementByIds, cache, utilities, } from '@cornerstonejs/core';\nimport { triggerSegmentationRender } from '../../stateManagement/segmentation/SegmentationRenderingEngine';\nimport { updateLabelmapSegmentationImageReferences } from '../../stateManagement/segmentation/updateLabelmapSegmentationImageReferences';\nimport { getCurrentLabelmapImageIdsForViewport } from '../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { SegmentationRepresentations } from '../../enums';\nimport { getLabelmapActorEntries } from '../../stateManagement/segmentation/helpers/getSegmentationActor';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/getSegmentationRepresentation';\nconst enable = function (element) {\n    if (!element) {\n        return;\n    }\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    if (viewport instanceof BaseVolumeViewport) {\n        return;\n    }\n    element.addEventListener(Enums.Events.PRE_STACK_NEW_IMAGE, _imageChangeEventListener);\n    element.addEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.PRE_STACK_NEW_IMAGE, _imageChangeEventListener);\n    element.removeEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n};\nconst perViewportManualTriggers = new Map();\nfunction _imageChangeEventListener(evt) {\n    const eventData = evt.detail;\n    const { viewportId, renderingEngineId } = eventData;\n    const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n    const representations = getSegmentationRepresentations(viewportId);\n    if (!representations?.length) {\n        return;\n    }\n    const labelmapRepresentations = representations.filter((representation) => representation.type === SegmentationRepresentations.Labelmap);\n    const actors = viewport.getActors();\n    labelmapRepresentations.forEach((representation) => {\n        const { segmentationId } = representation;\n        updateLabelmapSegmentationImageReferences(viewportId, segmentationId);\n    });\n    const labelmapActors = labelmapRepresentations\n        .flatMap((representation) => {\n        return getLabelmapActorEntries(viewportId, representation.segmentationId);\n    })\n        .filter((actor) => actor !== undefined);\n    if (!labelmapActors.length) {\n        return;\n    }\n    labelmapActors.forEach((actor) => {\n        const validActor = labelmapRepresentations.find((representation) => {\n            const derivedImageIds = getCurrentLabelmapImageIdsForViewport(viewportId, representation.segmentationId);\n            return derivedImageIds?.includes(actor.referencedId);\n        });\n        if (!validActor) {\n            viewport.removeActors([actor.uid]);\n        }\n    });\n    labelmapRepresentations.forEach((representation) => {\n        const { segmentationId } = representation;\n        const currentImageId = viewport.getCurrentImageId();\n        const derivedImageIds = getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);\n        if (!derivedImageIds) {\n            return;\n        }\n        let shouldTriggerSegmentationRender = false;\n        const updateSegmentationActor = (derivedImageId) => {\n            const derivedImage = cache.getImage(derivedImageId);\n            if (!derivedImage) {\n                console.warn('No derived image found in the cache for segmentation representation', representation);\n                return;\n            }\n            const segmentationActorInput = actors.find((actor) => actor.referencedId === derivedImageId);\n            if (!segmentationActorInput) {\n                const { dimensions, spacing, direction } = viewport.getImageDataMetadata(derivedImage);\n                const currentImage = cache.getImage(currentImageId) ||\n                    {\n                        imageId: currentImageId,\n                    };\n                const { origin: currentOrigin } = viewport.getImageDataMetadata(currentImage);\n                const originToUse = currentOrigin;\n                const constructor = derivedImage.voxelManager.getConstructor();\n                const newPixelData = derivedImage.voxelManager.getScalarData();\n                const scalarArray = vtkDataArray.newInstance({\n                    name: 'Pixels',\n                    numberOfComponents: 1,\n                    values: new constructor(newPixelData),\n                });\n                const imageData = vtkImageData.newInstance();\n                imageData.setDimensions(dimensions[0], dimensions[1], 1);\n                imageData.setSpacing(spacing);\n                imageData.setDirection(direction);\n                imageData.setOrigin(originToUse);\n                imageData.getPointData().setScalars(scalarArray);\n                imageData.modified();\n                viewport.addImages([\n                    {\n                        imageId: derivedImageId,\n                        representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}-${derivedImage.imageId}`,\n                        callback: ({ imageActor }) => {\n                            imageActor.getMapper().setInputData(imageData);\n                        },\n                    },\n                ]);\n                shouldTriggerSegmentationRender = true;\n                return;\n            }\n            else {\n                const segmentationImageData = segmentationActorInput.actor\n                    .getMapper()\n                    .getInputData();\n                if (segmentationImageData.setDerivedImage) {\n                    segmentationImageData.setDerivedImage(derivedImage);\n                }\n                else {\n                    utilities.updateVTKImageDataWithCornerstoneImage(segmentationImageData, derivedImage);\n                }\n            }\n        };\n        derivedImageIds.forEach(updateSegmentationActor);\n        if (shouldTriggerSegmentationRender) {\n            triggerSegmentationRender(viewportId);\n        }\n        viewport.render();\n        if (evt.type === Enums.Events.IMAGE_RENDERED) {\n            viewport.element.removeEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n        }\n    });\n}\nexport default {\n    enable,\n    disable,\n};\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport getViewportsForAnnotation from '../../../utilities/getViewportsForAnnotation';\nimport { getAllAnnotations } from '../../../stateManagement/annotation/annotationState';\nimport { areSameSegment, isContourSegmentationAnnotation, } from '../../../utilities/contourSegmentation';\nimport { getToolGroupForViewport } from '../../../store/ToolGroupManager';\nimport { findAllIntersectingContours } from '../../../utilities/contourSegmentation/getIntersectingAnnotations';\nimport { processMultipleIntersections } from '../../../utilities/contourSegmentation/mergeMultipleAnnotations';\nimport { convertContourPolylineToCanvasSpace, createPolylineHole, combinePolylines, } from '../../../utilities/contourSegmentation/sharedOperations';\nimport { Events } from '../../../enums';\nconst DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';\nexport default async function contourSegmentationCompletedListener(evt) {\n    const sourceAnnotation = evt.detail\n        .annotation;\n    if (!isContourSegmentationAnnotation(sourceAnnotation)) {\n        return;\n    }\n    const viewport = getViewport(sourceAnnotation);\n    const contourSegmentationAnnotations = getValidContourSegmentationAnnotations(viewport, sourceAnnotation);\n    if (!contourSegmentationAnnotations.length) {\n        triggerEvent(eventTarget, Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, {\n            element: viewport.element,\n            sourceAnnotation,\n        });\n        return;\n    }\n    const sourcePolyline = convertContourPolylineToCanvasSpace(sourceAnnotation.data.contour.polyline, viewport);\n    const intersectingContours = findAllIntersectingContours(viewport, sourcePolyline, contourSegmentationAnnotations);\n    if (!intersectingContours.length) {\n        triggerEvent(eventTarget, Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, {\n            element: viewport.element,\n            sourceAnnotation,\n        });\n        return;\n    }\n    if (intersectingContours.length > 1) {\n        processMultipleIntersections(viewport, sourceAnnotation, sourcePolyline, intersectingContours);\n        return;\n    }\n    const { targetAnnotation, targetPolyline, isContourHole } = intersectingContours[0];\n    if (isContourHole) {\n        const { contourHoleProcessingEnabled = false } = evt.detail;\n        if (!contourHoleProcessingEnabled) {\n            return;\n        }\n        createPolylineHole(viewport, targetAnnotation, sourceAnnotation);\n    }\n    else {\n        combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline);\n    }\n}\nfunction isFreehandContourSegToolRegisteredForViewport(viewport, silent = false) {\n    const toolName = 'PlanarFreehandContourSegmentationTool';\n    const toolGroup = getToolGroupForViewport(viewport.id, viewport.renderingEngineId);\n    let errorMessage;\n    if (!toolGroup) {\n        errorMessage = `ToolGroup not found for viewport ${viewport.id}`;\n    }\n    else if (!toolGroup.hasTool(toolName)) {\n        errorMessage = `Tool ${toolName} not added to ${toolGroup.id} toolGroup`;\n    }\n    else if (!toolGroup.getToolOptions(toolName)) {\n        errorMessage = `Tool ${toolName} must be in active/passive state in ${toolGroup.id} toolGroup`;\n    }\n    if (errorMessage && !silent) {\n        console.warn(errorMessage);\n    }\n    return !errorMessage;\n}\nfunction getViewport(annotation) {\n    const viewports = getViewportsForAnnotation(annotation);\n    const viewportWithToolRegistered = viewports.find((viewport) => isFreehandContourSegToolRegisteredForViewport(viewport, true));\n    return viewportWithToolRegistered ?? viewports[0];\n}\nfunction getValidContourSegmentationAnnotations(viewport, sourceAnnotation) {\n    const { annotationUID: sourceAnnotationUID } = sourceAnnotation;\n    const allAnnotations = getAllAnnotations();\n    return allAnnotations.filter((targetAnnotation) => targetAnnotation.annotationUID &&\n        targetAnnotation.annotationUID !== sourceAnnotationUID &&\n        isContourSegmentationAnnotation(targetAnnotation) &&\n        areSameSegment(targetAnnotation, sourceAnnotation) &&\n        viewport.isReferenceViewable(targetAnnotation.metadata));\n}\n","import * as contourSegUtils from '../../utilities/contourSegmentation';\nimport { contourSegmentationCompleted } from './contourSegmentation';\nexport default function annotationCompletedListener(evt) {\n    const annotation = evt.detail.annotation;\n    if (contourSegUtils.isContourSegmentationAnnotation(annotation)) {\n        contourSegmentationCompleted(evt);\n    }\n}\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities/triggerAnnotationRenderForViewportIds';\nfunction annotationSelectionListener(evt) {\n    const deselectedAnnotation = evt.detail.removed;\n    if (!deselectedAnnotation.length) {\n        return;\n    }\n    const renderingEngines = getRenderingEngines();\n    renderingEngines.forEach((renderingEngine) => {\n        const viewports = renderingEngine.getViewports();\n        const viewportIds = viewports.map((vp) => vp.id);\n        triggerAnnotationRenderForViewportIds(viewportIds);\n    });\n}\nexport default annotationSelectionListener;\n","import triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nfunction annotationModifiedListener(evt) {\n    const { viewportId } = evt.detail;\n    triggerAnnotationRenderForViewportIds([viewportId]);\n}\nexport default annotationModifiedListener;\n","import * as contourSegUtils from '../../utilities/contourSegmentation';\nimport { contourSegmentationRemoved } from './contourSegmentation';\nexport default function annotationRemovedListener(evt) {\n    const annotation = evt.detail.annotation;\n    if (contourSegUtils.isContourSegmentationAnnotation(annotation)) {\n        contourSegmentationRemoved(evt);\n    }\n}\n","import { removeContourSegmentationAnnotation } from '../../../utilities/contourSegmentation';\nexport default function contourSegmentationRemovedListener(evt) {\n    const annotation = evt.detail.annotation;\n    removeContourSegmentationAnnotation(annotation);\n}\n","import { getAllAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nconst segmentationRemovedListener = function (evt) {\n    const { segmentationId } = evt.detail;\n    const annotationsToRemove = getAllAnnotations().filter((annotation) => segmentationId ===\n        annotation?.data?.segmentation\n            ?.segmentationId);\n    annotationsToRemove.forEach((annotation) => {\n        removeAnnotation(annotation.annotationUID);\n    });\n};\nexport default segmentationRemovedListener;\n","import { triggerSegmentationRender } from '../../stateManagement/segmentation/SegmentationRenderingEngine';\nconst segmentationRepresentationModifiedListener = function (evt) {\n    const { viewportId } = evt.detail;\n    triggerSegmentationRender(viewportId);\n};\nexport default segmentationRepresentationModifiedListener;\n","import { eventTarget, Enums } from '@cornerstonejs/core';\nimport { getAnnotationManager } from './stateManagement/annotation/annotationState';\nimport { Events as TOOLS_EVENTS } from './enums';\nimport { addEnabledElement, removeEnabledElement } from './store';\nimport { resetCornerstoneToolsState } from './store/state';\nimport { annotationCompletedListener, annotationRemovedListener, annotationSelectionListener, annotationModifiedListener, segmentationDataModifiedEventListener, segmentationModifiedListener, } from './eventListeners';\nimport { annotationInterpolationEventDispatcher } from './eventDispatchers';\nimport * as ToolGroupManager from './store/ToolGroupManager';\nimport { defaultSegmentationStateManager } from './stateManagement/segmentation/SegmentationStateManager';\nimport segmentationRepresentationModifiedListener from './eventListeners/segmentation/segmentationRepresentationModifiedListener';\nimport { setConfig } from './config';\nimport segmentationRemovedListener from './eventListeners/segmentation/segmentationRemovedEventListener';\nlet csToolsInitialized = false;\nexport function init(defaultConfiguration = {}) {\n    if (csToolsInitialized) {\n        return;\n    }\n    setConfig(defaultConfiguration);\n    _addCornerstoneEventListeners();\n    _addCornerstoneToolsEventListeners();\n    csToolsInitialized = true;\n}\nexport function destroy() {\n    _removeCornerstoneEventListeners();\n    _removeCornerstoneToolsEventListeners();\n    ToolGroupManager.destroy();\n    resetCornerstoneToolsState();\n    const annotationManager = getAnnotationManager();\n    const segmentationStateManager = defaultSegmentationStateManager;\n    annotationManager.restoreAnnotations({});\n    segmentationStateManager.resetState();\n    csToolsInitialized = false;\n}\nfunction _addCornerstoneEventListeners() {\n    _removeCornerstoneEventListeners();\n    const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n    const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n    eventTarget.addEventListener(elementEnabledEvent, addEnabledElement);\n    eventTarget.addEventListener(elementDisabledEvent, removeEnabledElement);\n    annotationInterpolationEventDispatcher.enable();\n}\nfunction _removeCornerstoneEventListeners() {\n    const elementEnabledEvent = Enums.Events.ELEMENT_ENABLED;\n    const elementDisabledEvent = Enums.Events.ELEMENT_DISABLED;\n    eventTarget.removeEventListener(elementEnabledEvent, addEnabledElement);\n    eventTarget.removeEventListener(elementDisabledEvent, removeEnabledElement);\n    annotationInterpolationEventDispatcher.disable();\n}\nfunction _addCornerstoneToolsEventListeners() {\n    _removeCornerstoneToolsEventListeners();\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_COMPLETED, annotationCompletedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_MODIFIED, annotationModifiedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.ANNOTATION_REMOVED, annotationRemovedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_MODIFIED, segmentationModifiedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED, segmentationDataModifiedEventListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED, segmentationRepresentationModifiedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_ADDED, segmentationRepresentationModifiedListener);\n    eventTarget.addEventListener(TOOLS_EVENTS.SEGMENTATION_REMOVED, segmentationRemovedListener);\n}\nfunction _removeCornerstoneToolsEventListeners() {\n    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_COMPLETED, annotationCompletedListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_MODIFIED, annotationModifiedListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_SELECTION_CHANGE, annotationSelectionListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.ANNOTATION_REMOVED, annotationRemovedListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_MODIFIED, segmentationModifiedListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_DATA_MODIFIED, segmentationDataModifiedEventListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_MODIFIED, segmentationRepresentationModifiedListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_REPRESENTATION_ADDED, segmentationRepresentationModifiedListener);\n    eventTarget.removeEventListener(TOOLS_EVENTS.SEGMENTATION_REMOVED, segmentationRemovedListener);\n}\nexport default init;\n","import { getEnabledElement, triggerEvent, getRenderingEngine, } from '@cornerstonejs/core';\nimport { Events, ToolModes } from '../../enums';\nimport { draw as drawSvg } from '../../drawingSvg';\nimport getToolsWithModesForElement from '../../utilities/getToolsWithModesForElement';\nconst { Active, Passive, Enabled } = ToolModes;\nclass AnnotationRenderingEngine {\n    constructor() {\n        this._needsRender = new Set();\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._renderFlaggedViewports = () => {\n            this._throwIfDestroyed();\n            const elements = Array.from(this._viewportElements.values());\n            for (let i = 0; i < elements.length; i++) {\n                const element = elements[i];\n                if (this._needsRender.has(element)) {\n                    this._triggerRender(element);\n                    this._needsRender.delete(element);\n                    if (this._needsRender.size === 0) {\n                        break;\n                    }\n                }\n            }\n            this._animationFrameSet = false;\n            this._animationFrameHandle = null;\n            this._render();\n        };\n        this._viewportElements = new Map();\n    }\n    addViewportElement(viewportId, element) {\n        this._viewportElements.set(viewportId, element);\n    }\n    removeViewportElement(viewportId, element) {\n        this._viewportElements.delete(viewportId);\n        this._needsRender.delete(element);\n        this._reset();\n    }\n    renderViewport(element) {\n        this._setViewportsToBeRenderedNextFrame([element]);\n    }\n    _throwIfDestroyed() {\n        if (this.hasBeenDestroyed) {\n            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');\n        }\n    }\n    _setAllViewportsToBeRenderedNextFrame() {\n        const elements = [...this._viewportElements.values()];\n        elements.forEach((element) => {\n            this._needsRender.add(element);\n        });\n        this._renderFlaggedViewports();\n    }\n    _setViewportsToBeRenderedNextFrame(elements) {\n        const elementsEnabled = [...this._viewportElements.values()];\n        elements.forEach((element) => {\n            if (elementsEnabled.indexOf(element) !== -1) {\n                this._needsRender.add(element);\n            }\n        });\n        this._render();\n    }\n    _render() {\n        if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedViewports);\n            this._animationFrameSet = true;\n        }\n    }\n    _triggerRender(element) {\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const renderingEngine = getRenderingEngine(enabledElement.renderingEngineId);\n        if (!renderingEngine) {\n            console.warn('rendering Engine has been destroyed');\n            return;\n        }\n        const enabledTools = getToolsWithModesForElement(element, [\n            Active,\n            Passive,\n            Enabled,\n        ]);\n        const { renderingEngineId, viewportId } = enabledElement;\n        const eventDetail = {\n            element,\n            renderingEngineId,\n            viewportId,\n        };\n        drawSvg(element, (svgDrawingHelper) => {\n            let anyRendered = false;\n            const handleDrawSvg = (tool) => {\n                if (tool.renderAnnotation) {\n                    const rendered = tool.renderAnnotation(enabledElement, svgDrawingHelper);\n                    anyRendered = anyRendered || rendered;\n                }\n            };\n            enabledTools.forEach(handleDrawSvg);\n            if (anyRendered) {\n                triggerEvent(element, Events.ANNOTATION_RENDERED, { ...eventDetail });\n            }\n        });\n    }\n    _reset() {\n        window.cancelAnimationFrame(this._animationFrameHandle);\n        this._needsRender.clear();\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._setAllViewportsToBeRenderedNextFrame();\n    }\n}\nconst annotationRenderingEngine = new AnnotationRenderingEngine();\nexport { annotationRenderingEngine };\n","import { Enums, eventTarget, getEnabledElement, utilities, } from '@cornerstonejs/core';\nclass FrameOfReferenceSpecificAnnotationManager {\n    constructor(uid) {\n        this.getGroupKey = (annotationGroupSelector) => {\n            if (typeof annotationGroupSelector === 'string') {\n                return annotationGroupSelector;\n            }\n            const element = annotationGroupSelector;\n            const enabledElement = getEnabledElement(element);\n            if (!enabledElement) {\n                throw new Error('Element not enabled, you must have an enabled element if you are not providing a FrameOfReferenceUID');\n            }\n            return enabledElement.FrameOfReferenceUID;\n        };\n        this._imageVolumeModifiedHandler = (evt) => {\n            const eventDetail = evt.detail;\n            const { FrameOfReferenceUID } = eventDetail;\n            const annotations = this.annotations;\n            const frameOfReferenceSpecificAnnotations = annotations[FrameOfReferenceUID];\n            if (!frameOfReferenceSpecificAnnotations) {\n                return;\n            }\n            Object.keys(frameOfReferenceSpecificAnnotations).forEach((toolName) => {\n                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n                toolSpecificAnnotations.forEach((annotation) => {\n                    const invalidated = annotation.invalidated;\n                    if (invalidated !== undefined) {\n                        annotation.invalidated = true;\n                    }\n                });\n            });\n        };\n        this.getFramesOfReference = () => {\n            return Object.keys(this.annotations);\n        };\n        this.getAnnotations = (groupKey, toolName) => {\n            const annotations = this.annotations;\n            if (!annotations[groupKey]) {\n                return [];\n            }\n            if (toolName) {\n                return annotations[groupKey][toolName]\n                    ? annotations[groupKey][toolName]\n                    : [];\n            }\n            return annotations[groupKey];\n        };\n        this.getAnnotation = (annotationUID) => {\n            const annotations = this.annotations;\n            for (const frameOfReferenceUID in annotations) {\n                const frameOfReferenceAnnotations = annotations[frameOfReferenceUID];\n                for (const toolName in frameOfReferenceAnnotations) {\n                    const toolSpecificAnnotations = frameOfReferenceAnnotations[toolName];\n                    for (const annotation of toolSpecificAnnotations) {\n                        if (annotationUID === annotation.annotationUID) {\n                            return annotation;\n                        }\n                    }\n                }\n            }\n        };\n        this.getNumberOfAnnotations = (groupKey, toolName) => {\n            const annotations = this.getAnnotations(groupKey, toolName);\n            if (!annotations.length) {\n                return 0;\n            }\n            if (toolName) {\n                return annotations.length;\n            }\n            let total = 0;\n            for (const toolName in annotations) {\n                total += annotations[toolName].length;\n            }\n            return total;\n        };\n        this.addAnnotation = (annotation, groupKey) => {\n            const { metadata } = annotation;\n            const { FrameOfReferenceUID, toolName } = metadata;\n            groupKey = groupKey || FrameOfReferenceUID;\n            const annotations = this.annotations;\n            let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n            if (!frameOfReferenceSpecificAnnotations) {\n                annotations[groupKey] = {};\n                frameOfReferenceSpecificAnnotations = annotations[groupKey];\n            }\n            let toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n            if (!toolSpecificAnnotations) {\n                frameOfReferenceSpecificAnnotations[toolName] = [];\n                toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n            }\n            if (this.preprocessingFn) {\n                annotation = this.preprocessingFn(annotation);\n            }\n            toolSpecificAnnotations.push(annotation);\n        };\n        this.removeAnnotation = (annotationUID) => {\n            const { annotations } = this;\n            for (const groupKey in annotations) {\n                const groupAnnotations = annotations[groupKey];\n                for (const toolName in groupAnnotations) {\n                    const toolAnnotations = groupAnnotations[toolName];\n                    const index = toolAnnotations.findIndex((annotation) => annotation.annotationUID === annotationUID);\n                    if (index !== -1) {\n                        toolAnnotations.splice(index, 1);\n                        if (toolAnnotations.length === 0) {\n                            delete groupAnnotations[toolName];\n                        }\n                    }\n                }\n                if (Object.keys(groupAnnotations).length === 0) {\n                    delete annotations[groupKey];\n                }\n            }\n        };\n        this.removeAnnotations = (groupKey, toolName) => {\n            const annotations = this.annotations;\n            const removedAnnotations = [];\n            if (!annotations[groupKey]) {\n                return removedAnnotations;\n            }\n            if (toolName) {\n                const annotationsForTool = annotations[groupKey][toolName];\n                if (annotationsForTool) {\n                    for (const annotation of annotationsForTool) {\n                        this.removeAnnotation(annotation.annotationUID);\n                        removedAnnotations.push(annotation);\n                    }\n                }\n            }\n            else {\n                for (const toolName in annotations[groupKey]) {\n                    const annotationsForTool = annotations[groupKey][toolName];\n                    for (const annotation of annotationsForTool) {\n                        this.removeAnnotation(annotation.annotationUID);\n                        removedAnnotations.push(annotation);\n                    }\n                }\n            }\n            return removedAnnotations;\n        };\n        this.saveAnnotations = (groupKey, toolName) => {\n            const annotations = this.annotations;\n            if (groupKey && toolName) {\n                const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                if (!frameOfReferenceSpecificAnnotations) {\n                    return;\n                }\n                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n                return structuredClone(toolSpecificAnnotations);\n            }\n            else if (groupKey) {\n                const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                return structuredClone(frameOfReferenceSpecificAnnotations);\n            }\n            return structuredClone(annotations);\n        };\n        this.restoreAnnotations = (state, groupKey, toolName) => {\n            const annotations = this.annotations;\n            if (groupKey && toolName) {\n                let frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                if (!frameOfReferenceSpecificAnnotations) {\n                    annotations[groupKey] = {};\n                    frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                }\n                frameOfReferenceSpecificAnnotations[toolName] = state;\n            }\n            else if (groupKey) {\n                annotations[groupKey] = state;\n            }\n            else {\n                this.annotations = structuredClone(state);\n            }\n        };\n        this.getAllAnnotations = () => {\n            return Object.values(this.annotations)\n                .map((frameOfReferenceSpecificAnnotations) => Object.values(frameOfReferenceSpecificAnnotations))\n                .flat(2);\n        };\n        this.getNumberOfAllAnnotations = () => {\n            let count = 0;\n            const annotations = this.annotations;\n            for (const groupKey in annotations) {\n                const frameOfReferenceSpecificAnnotations = annotations[groupKey];\n                for (const toolName in frameOfReferenceSpecificAnnotations) {\n                    const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[toolName];\n                    count += toolSpecificAnnotations.length;\n                }\n            }\n            return count;\n        };\n        this.removeAllAnnotations = () => {\n            const removedAnnotations = [];\n            for (const annotation of this.getAllAnnotations()) {\n                this.removeAnnotation(annotation.annotationUID);\n                removedAnnotations.push(annotation);\n            }\n            return removedAnnotations;\n        };\n        if (!uid) {\n            uid = utilities.uuidv4();\n        }\n        this.annotations = {};\n        this.uid = uid;\n        eventTarget.addEventListener(Enums.Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedHandler);\n    }\n    setPreprocessingFn(preprocessingFn) {\n        this.preprocessingFn = preprocessingFn;\n    }\n}\nconst defaultFrameOfReferenceSpecificAnnotationManager = new FrameOfReferenceSpecificAnnotationManager('DEFAULT');\nexport { defaultFrameOfReferenceSpecificAnnotationManager };\nexport default FrameOfReferenceSpecificAnnotationManager;\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { getAnnotation } from './annotationState';\nconst globalLockedAnnotationUIDsSet = new Set();\nfunction setAnnotationLocked(annotationUID, locked = true) {\n    const detail = makeEventDetail();\n    if (annotationUID) {\n        if (locked) {\n            lock(annotationUID, globalLockedAnnotationUIDsSet, detail);\n        }\n        else {\n            unlock(annotationUID, globalLockedAnnotationUIDsSet, detail);\n        }\n    }\n    publish(detail, globalLockedAnnotationUIDsSet);\n}\nfunction unlockAllAnnotations() {\n    const detail = makeEventDetail();\n    clearLockedAnnotationsSet(globalLockedAnnotationUIDsSet, detail);\n    publish(detail, globalLockedAnnotationUIDsSet);\n}\nfunction getAnnotationsLocked() {\n    return Array.from(globalLockedAnnotationUIDsSet);\n}\nfunction isAnnotationLocked(annotationUID) {\n    return globalLockedAnnotationUIDsSet.has(annotationUID);\n}\nfunction getAnnotationsLockedCount() {\n    return globalLockedAnnotationUIDsSet.size;\n}\nfunction checkAndSetAnnotationLocked(annotationUID) {\n    const isLocked = isAnnotationLocked(annotationUID);\n    setAnnotationLocked(annotationUID, isLocked);\n    return isLocked;\n}\nfunction makeEventDetail() {\n    return Object.freeze({\n        added: [],\n        removed: [],\n        locked: [],\n    });\n}\nfunction lock(annotationUID, lockedAnnotationUIDsSet, detail) {\n    if (!lockedAnnotationUIDsSet.has(annotationUID)) {\n        lockedAnnotationUIDsSet.add(annotationUID);\n        detail.added.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        if (annotation) {\n            annotation.isLocked = true;\n        }\n    }\n}\nfunction unlock(annotationUID, lockedAnnotationUIDsSet, detail) {\n    if (lockedAnnotationUIDsSet.delete(annotationUID)) {\n        detail.removed.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        if (annotation) {\n            annotation.isLocked = false;\n        }\n    }\n}\nfunction clearLockedAnnotationsSet(lockedAnnotationUIDsSet, detail) {\n    lockedAnnotationUIDsSet.forEach((annotationUID) => {\n        unlock(annotationUID, lockedAnnotationUIDsSet, detail);\n    });\n}\nfunction publish(detail, lockedAnnotationUIDsSet) {\n    if (detail.added.length > 0 || detail.removed.length > 0) {\n        lockedAnnotationUIDsSet.forEach((item) => void detail.locked.push(item));\n        triggerEvent(eventTarget, Events.ANNOTATION_LOCK_CHANGE, detail);\n    }\n}\nexport { setAnnotationLocked, getAnnotationsLocked, getAnnotationsLockedCount, unlockAllAnnotations, isAnnotationLocked, checkAndSetAnnotationLocked, };\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { getAnnotation } from './annotationState';\nconst selectedAnnotationUIDs = new Set();\nfunction setAnnotationSelected(annotationUID, selected = true, preserveSelected = false) {\n    if (selected) {\n        selectAnnotation(annotationUID, preserveSelected);\n    }\n    else {\n        deselectAnnotation(annotationUID);\n    }\n}\nfunction selectAnnotation(annotationUID, preserveSelected = false) {\n    const detail = makeEventDetail();\n    if (!preserveSelected) {\n        clearSelectionSet(selectedAnnotationUIDs, detail);\n        const annotation = getAnnotation(annotationUID);\n        if (annotation) {\n            annotation.isSelected = true;\n        }\n    }\n    if (annotationUID && !selectedAnnotationUIDs.has(annotationUID)) {\n        selectedAnnotationUIDs.add(annotationUID);\n        detail.added.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        if (annotation) {\n            annotation.isSelected = true;\n        }\n    }\n    publish(detail, selectedAnnotationUIDs);\n}\nfunction deselectAnnotation(annotationUID) {\n    const detail = makeEventDetail();\n    if (annotationUID) {\n        if (selectedAnnotationUIDs.delete(annotationUID)) {\n            detail.removed.push(annotationUID);\n            const annotation = getAnnotation(annotationUID);\n            annotation.isSelected = false;\n        }\n    }\n    else {\n        clearSelectionSet(selectedAnnotationUIDs, detail);\n    }\n    publish(detail, selectedAnnotationUIDs);\n}\nfunction getAnnotationsSelected() {\n    return Array.from(selectedAnnotationUIDs);\n}\nfunction getAnnotationsSelectedByToolName(toolName) {\n    return getAnnotationsSelected().filter((annotationUID) => {\n        const annotation = getAnnotation(annotationUID);\n        return annotation?.metadata?.toolName === toolName;\n    });\n}\nfunction isAnnotationSelected(annotationUID) {\n    return selectedAnnotationUIDs.has(annotationUID);\n}\nfunction getAnnotationsSelectedCount() {\n    return selectedAnnotationUIDs.size;\n}\nfunction makeEventDetail() {\n    return Object.freeze({\n        added: [],\n        removed: [],\n        selection: [],\n    });\n}\nfunction clearSelectionSet(selectionSet, detail) {\n    selectionSet.forEach((value) => {\n        if (selectionSet.delete(value)) {\n            detail.removed.push(value);\n            const annotation = getAnnotation(value);\n            if (annotation) {\n                annotation.isSelected = false;\n            }\n        }\n    });\n}\nfunction publish(detail, selectionSet) {\n    if (detail.added.length > 0 || detail.removed.length > 0) {\n        selectionSet.forEach((item) => void detail.selection.push(item));\n        triggerEvent(eventTarget, Events.ANNOTATION_SELECTION_CHANGE, detail);\n    }\n}\nexport { setAnnotationSelected, getAnnotationsSelected, getAnnotationsSelectedByToolName, getAnnotationsSelectedCount, deselectAnnotation, isAnnotationSelected, };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { triggerAnnotationAddedForElement, triggerAnnotationAddedForFOR, triggerAnnotationRemoved, } from './helpers/state';\nlet defaultManager;\nfunction getAnnotationManager() {\n    return defaultManager;\n}\nfunction setAnnotationManager(annotationManager) {\n    defaultManager = annotationManager;\n}\nfunction getAnnotations(toolName, annotationGroupSelector) {\n    const manager = getAnnotationManager();\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    return manager.getAnnotations(groupKey, toolName);\n}\nfunction getAnnotation(annotationUID) {\n    const manager = getAnnotationManager();\n    return manager.getAnnotation(annotationUID);\n}\nfunction getAllAnnotations() {\n    const manager = getAnnotationManager();\n    return manager.getAllAnnotations();\n}\nfunction clearParentAnnotation(annotation) {\n    const { annotationUID: childUID, parentAnnotationUID } = annotation;\n    if (!parentAnnotationUID) {\n        return;\n    }\n    const parentAnnotation = getAnnotation(parentAnnotationUID);\n    const childUIDIndex = parentAnnotation.childAnnotationUIDs.indexOf(childUID);\n    parentAnnotation.childAnnotationUIDs.splice(childUIDIndex, 1);\n    annotation.parentAnnotationUID = undefined;\n}\nfunction addChildAnnotation(parentAnnotation, childAnnotation) {\n    const { annotationUID: parentUID } = parentAnnotation;\n    const { annotationUID: childUID } = childAnnotation;\n    clearParentAnnotation(childAnnotation);\n    if (!parentAnnotation.childAnnotationUIDs) {\n        parentAnnotation.childAnnotationUIDs = [];\n    }\n    if (parentAnnotation.childAnnotationUIDs.includes(childUID)) {\n        return;\n    }\n    parentAnnotation.childAnnotationUIDs.push(childUID);\n    childAnnotation.parentAnnotationUID = parentUID;\n}\nfunction getParentAnnotation(annotation) {\n    return annotation.parentAnnotationUID\n        ? getAnnotation(annotation.parentAnnotationUID)\n        : undefined;\n}\nfunction getChildAnnotations(annotation) {\n    return (annotation.childAnnotationUIDs?.map((childAnnotationUID) => getAnnotation(childAnnotationUID)) ?? []);\n}\nfunction addAnnotation(annotation, annotationGroupSelector) {\n    if (!annotation.annotationUID) {\n        annotation.annotationUID = csUtils.uuidv4();\n    }\n    const manager = getAnnotationManager();\n    if (annotationGroupSelector instanceof HTMLDivElement) {\n        const groupKey = manager.getGroupKey(annotationGroupSelector);\n        manager.addAnnotation(annotation, groupKey);\n        triggerAnnotationAddedForElement(annotation, annotationGroupSelector);\n    }\n    else {\n        manager.addAnnotation(annotation, undefined);\n        triggerAnnotationAddedForFOR(annotation);\n    }\n    return annotation.annotationUID;\n}\nfunction getNumberOfAnnotations(toolName, annotationGroupSelector) {\n    const manager = getAnnotationManager();\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    return manager.getNumberOfAnnotations(groupKey, toolName);\n}\nfunction removeAnnotation(annotationUID) {\n    if (!annotationUID) {\n        return;\n    }\n    const manager = getAnnotationManager();\n    const annotation = manager.getAnnotation(annotationUID);\n    if (!annotation) {\n        return;\n    }\n    annotation.childAnnotationUIDs?.forEach((childAnnotationUID) => removeAnnotation(childAnnotationUID));\n    manager.removeAnnotation(annotationUID);\n    triggerAnnotationRemoved({ annotation, annotationManagerUID: manager.uid });\n}\nfunction removeAllAnnotations() {\n    const manager = getAnnotationManager();\n    const removedAnnotations = manager.removeAllAnnotations();\n    for (const annotation of removedAnnotations) {\n        triggerAnnotationRemoved({\n            annotation,\n            annotationManagerUID: manager.uid,\n        });\n    }\n}\nfunction removeAnnotations(toolName, annotationGroupSelector) {\n    const manager = getAnnotationManager();\n    const groupKey = manager.getGroupKey(annotationGroupSelector);\n    const removedAnnotations = manager.removeAnnotations(groupKey, toolName);\n    for (const annotation of removedAnnotations) {\n        triggerAnnotationRemoved({\n            annotation,\n            annotationManagerUID: manager.uid,\n        });\n    }\n}\nfunction invalidateAnnotation(annotation) {\n    let currAnnotation = annotation;\n    while (currAnnotation) {\n        currAnnotation.invalidated = true;\n        currAnnotation = currAnnotation.parentAnnotationUID\n            ? getAnnotation(currAnnotation.parentAnnotationUID)\n            : undefined;\n    }\n}\nexport { getAllAnnotations, getAnnotations, getParentAnnotation, getChildAnnotations, clearParentAnnotation, addChildAnnotation, getNumberOfAnnotations, addAnnotation, removeAnnotation, removeAnnotations, removeAllAnnotations, setAnnotationManager, getAnnotationManager, invalidateAnnotation, getAnnotation, };\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport { isAnnotationSelected, deselectAnnotation, } from './annotationSelection';\nimport { getAnnotation } from './annotationState';\nconst globalHiddenAnnotationUIDsSet = new Set();\nfunction setAnnotationVisibility(annotationUID, visible = true) {\n    const detail = makeEventDetail();\n    if (annotationUID) {\n        if (visible) {\n            show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n        }\n        else {\n            hide(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n        }\n    }\n    publish(detail);\n}\nfunction showAllAnnotations() {\n    const detail = makeEventDetail();\n    globalHiddenAnnotationUIDsSet.forEach((annotationUID) => {\n        show(annotationUID, globalHiddenAnnotationUIDsSet, detail);\n    });\n    publish(detail);\n}\nfunction isAnnotationVisible(annotationUID) {\n    const annotation = getAnnotation(annotationUID);\n    if (annotation) {\n        return !globalHiddenAnnotationUIDsSet.has(annotationUID);\n    }\n}\nfunction makeEventDetail() {\n    return Object.freeze({\n        lastVisible: [],\n        lastHidden: [],\n        hidden: [],\n    });\n}\nfunction show(annotationUID, annotationUIDsSet, detail) {\n    if (annotationUIDsSet.delete(annotationUID)) {\n        detail.lastVisible.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        annotation.isVisible = true;\n    }\n}\nfunction hide(annotationUID, annotationUIDsSet, detail) {\n    if (!annotationUIDsSet.has(annotationUID)) {\n        annotationUIDsSet.add(annotationUID);\n        if (isAnnotationSelected(annotationUID)) {\n            deselectAnnotation(annotationUID);\n        }\n        detail.lastHidden.push(annotationUID);\n        const annotation = getAnnotation(annotationUID);\n        annotation.isVisible = false;\n    }\n}\nfunction publish(detail) {\n    if (detail.lastHidden.length > 0 || detail.lastVisible.length > 0) {\n        globalHiddenAnnotationUIDsSet.forEach((item) => void detail.hidden.push(item));\n        triggerEvent(eventTarget, Events.ANNOTATION_VISIBILITY_CHANGE, detail);\n    }\n}\nfunction checkAndSetAnnotationVisibility(annotationUID) {\n    const isVisible = !globalHiddenAnnotationUIDsSet.has(annotationUID);\n    setAnnotationVisibility(annotationUID, isVisible);\n    return isVisible;\n}\nexport { setAnnotationVisibility, showAllAnnotations, isAnnotationVisible, checkAndSetAnnotationVisibility, };\n","class ToolStyle {\n    constructor() {\n        const defaultConfig = {\n            color: 'rgb(255, 255, 0)',\n            colorHighlighted: 'rgb(0, 255, 0)',\n            colorSelected: 'rgb(0, 220, 0)',\n            colorLocked: 'rgb(209, 193, 90)',\n            lineWidth: '1',\n            lineDash: '',\n            shadow: true,\n            textBoxVisibility: true,\n            textBoxFontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n            textBoxFontSize: '14px',\n            textBoxColor: 'rgb(255, 255, 0)',\n            textBoxColorHighlighted: 'rgb(0, 255, 0)',\n            textBoxColorSelected: 'rgb(0, 255, 0)',\n            textBoxColorLocked: 'rgb(209, 193, 90)',\n            textBoxBackground: '',\n            textBoxLinkLineWidth: '1',\n            textBoxLinkLineDash: '2,3',\n            textBoxShadow: true,\n            markerSize: '10',\n            angleArcLineDash: '',\n        };\n        this._initializeConfig(defaultConfig);\n    }\n    getAnnotationToolStyles(annotationUID) {\n        return this.config.annotations && this.config.annotations[annotationUID];\n    }\n    getViewportToolStyles(viewportId) {\n        return this.config.viewports && this.config.viewports[viewportId];\n    }\n    getToolGroupToolStyles(toolGroupId) {\n        return this.config.toolGroups && this.config.toolGroups[toolGroupId];\n    }\n    getDefaultToolStyles() {\n        return this.config.default;\n    }\n    setAnnotationStyles(annotationUID, styles) {\n        let annotationSpecificStyles = this.config.annotations;\n        if (!annotationSpecificStyles) {\n            this.config = {\n                ...this.config,\n                annotations: {},\n            };\n            annotationSpecificStyles = this.config.annotations;\n        }\n        annotationSpecificStyles[annotationUID] = styles;\n    }\n    setViewportToolStyles(viewportId, styles) {\n        let viewportSpecificStyles = this.config.viewports;\n        if (!viewportSpecificStyles) {\n            this.config = {\n                ...this.config,\n                viewports: {},\n            };\n            viewportSpecificStyles = this.config.viewports;\n        }\n        viewportSpecificStyles[viewportId] = styles;\n    }\n    setToolGroupToolStyles(toolGroupId, styles) {\n        let toolGroupSpecificStyles = this.config.toolGroups;\n        if (!toolGroupSpecificStyles) {\n            this.config = {\n                ...this.config,\n                toolGroups: {},\n            };\n            toolGroupSpecificStyles = this.config.toolGroups;\n        }\n        toolGroupSpecificStyles[toolGroupId] = styles;\n    }\n    setDefaultToolStyles(styles) {\n        this.config.default = styles;\n    }\n    getStyleProperty(toolStyle, specifications) {\n        const { annotationUID, viewportId, toolGroupId, toolName } = specifications;\n        return this._getToolStyle(toolStyle, annotationUID, viewportId, toolGroupId, toolName);\n    }\n    _getToolStyle(property, annotationUID, viewportId, toolGroupId, toolName) {\n        if (annotationUID) {\n            const annotationToolStyles = this.getAnnotationToolStyles(annotationUID);\n            if (annotationToolStyles) {\n                if (annotationToolStyles[property] !== undefined) {\n                    return annotationToolStyles[property];\n                }\n            }\n        }\n        if (viewportId) {\n            const viewportToolStyles = this.getViewportToolStyles(viewportId);\n            if (viewportToolStyles) {\n                if (viewportToolStyles[toolName] &&\n                    viewportToolStyles[toolName][property] !== undefined) {\n                    return viewportToolStyles[toolName][property];\n                }\n                if (viewportToolStyles.global &&\n                    viewportToolStyles.global[property] !== undefined) {\n                    return viewportToolStyles.global[property];\n                }\n            }\n        }\n        if (toolGroupId) {\n            const toolGroupToolStyles = this.getToolGroupToolStyles(toolGroupId);\n            if (toolGroupToolStyles) {\n                if (toolGroupToolStyles[toolName] &&\n                    toolGroupToolStyles[toolName][property] !== undefined) {\n                    return toolGroupToolStyles[toolName][property];\n                }\n                if (toolGroupToolStyles.global &&\n                    toolGroupToolStyles.global[property] !== undefined) {\n                    return toolGroupToolStyles.global[property];\n                }\n            }\n        }\n        const globalStyles = this.getDefaultToolStyles();\n        if (globalStyles[toolName] &&\n            globalStyles[toolName][property] !== undefined) {\n            return globalStyles[toolName][property];\n        }\n        if (globalStyles.global && globalStyles.global[property] !== undefined) {\n            return globalStyles.global[property];\n        }\n    }\n    _initializeConfig(config) {\n        const toolStyles = {};\n        for (const name in config) {\n            toolStyles[name] = config[name];\n        }\n        this.config = {\n            default: {\n                global: toolStyles,\n            },\n        };\n    }\n}\nconst toolStyle = new ToolStyle();\nexport default toolStyle;\n","import toolStyle from './ToolStyle';\nfunction getHierarchalPropertyStyles(property, state, mode) {\n    const list = [`${property}`];\n    if (state) {\n        list.push(`${list[0]}${state}`);\n    }\n    if (mode) {\n        list.push(`${list[list.length - 1]}${mode}`);\n    }\n    return list;\n}\nfunction getStyleProperty(property, styleSpecifier, state, mode) {\n    const alternatives = getHierarchalPropertyStyles(property, state, mode);\n    for (let i = alternatives.length - 1; i >= 0; --i) {\n        const style = toolStyle.getStyleProperty(alternatives[i], styleSpecifier);\n        if (style !== undefined) {\n            return style;\n        }\n    }\n}\nexport { getStyleProperty };\n","import { isAnnotationLocked } from '../annotationLocking';\nimport { isAnnotationSelected } from '../annotationSelection';\nimport { AnnotationStyleStates } from '../../../enums';\nfunction getState(annotation) {\n    if (annotation) {\n        if (annotation.data && annotation.highlighted) {\n            return AnnotationStyleStates.Highlighted;\n        }\n        if (isAnnotationSelected(annotation.annotationUID)) {\n            return AnnotationStyleStates.Selected;\n        }\n        if (isAnnotationLocked(annotation.annotationUID)) {\n            return AnnotationStyleStates.Locked;\n        }\n        if (annotation.data && annotation.autoGenerated) {\n            return AnnotationStyleStates.AutoGenerated;\n        }\n    }\n    return AnnotationStyleStates.Default;\n}\nexport default getState;\n","import { getStyleProperty } from './helpers';\nfunction getFont(styleSpecifier, state, mode) {\n    const fontSize = getStyleProperty('textBoxFontSize', styleSpecifier, state, mode);\n    const fontFamily = getStyleProperty('textBoxFontFamily', styleSpecifier, state, mode);\n    return `${fontSize}px ${fontFamily}`;\n}\nexport default getFont;\n","import { getEnabledElement, triggerEvent, eventTarget, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { Events, ChangeTypes } from '../../../enums';\nimport { getToolGroupsWithToolName } from '../../../store/ToolGroupManager';\nfunction triggerAnnotationAddedForElement(annotation, element) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewportId } = enabledElement;\n    const eventType = Events.ANNOTATION_ADDED;\n    const eventDetail = {\n        annotation,\n        viewportId,\n        renderingEngineId: renderingEngine.id,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nfunction triggerAnnotationAddedForFOR(annotation) {\n    const { toolName } = annotation.metadata;\n    const toolGroups = getToolGroupsWithToolName(toolName);\n    if (!toolGroups.length) {\n        return;\n    }\n    const viewportsToRender = [];\n    toolGroups.forEach((toolGroup) => {\n        toolGroup.viewportsInfo.forEach((viewportInfo) => {\n            const { renderingEngineId, viewportId } = viewportInfo;\n            const { FrameOfReferenceUID } = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (annotation.metadata.FrameOfReferenceUID === FrameOfReferenceUID) {\n                viewportsToRender.push(viewportInfo);\n            }\n        });\n    });\n    const eventType = Events.ANNOTATION_ADDED;\n    const eventDetail = { annotation };\n    if (!viewportsToRender.length) {\n        triggerEvent(eventTarget, eventType, eventDetail);\n        return;\n    }\n    viewportsToRender.forEach(({ renderingEngineId, viewportId }) => {\n        eventDetail.viewportId = viewportId;\n        eventDetail.renderingEngineId = renderingEngineId;\n        triggerEvent(eventTarget, eventType, eventDetail);\n    });\n}\nfunction triggerAnnotationRemoved(eventDetail) {\n    const eventType = Events.ANNOTATION_REMOVED;\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nfunction triggerAnnotationModified(annotation, element, changeType = ChangeTypes.HandlesUpdated) {\n    const enabledElement = element && getEnabledElement(element);\n    const { viewportId, renderingEngineId } = enabledElement || {};\n    const eventType = Events.ANNOTATION_MODIFIED;\n    const eventDetail = {\n        annotation,\n        viewportId,\n        renderingEngineId,\n        changeType,\n    };\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nfunction triggerAnnotationCompleted(annotation) {\n    const eventDetail = {\n        annotation,\n    };\n    _triggerAnnotationCompleted(eventDetail);\n}\nfunction triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled = false) {\n    const eventDetail = {\n        annotation,\n        contourHoleProcessingEnabled,\n    };\n    _triggerAnnotationCompleted(eventDetail);\n}\nfunction _triggerAnnotationCompleted(eventDetail) {\n    const eventType = Events.ANNOTATION_COMPLETED;\n    triggerEvent(eventTarget, eventType, eventDetail);\n}\nexport { triggerAnnotationAddedForElement, triggerAnnotationAddedForFOR, triggerAnnotationRemoved, triggerAnnotationModified, triggerAnnotationCompleted, triggerContourAnnotationCompleted, };\n","import { eventTarget, triggerEvent } from '@cornerstonejs/core';\nimport Events from '../../enums/Events';\nimport { getAnnotation } from './annotationState';\nexport default class AnnotationGroup {\n    constructor() {\n        this.annotationUIDs = new Set();\n        this._isVisible = true;\n        this.visibleFilter = this.unboundVisibleFilter.bind(this);\n    }\n    unboundVisibleFilter(uid) {\n        return !this._isVisible || !this.annotationUIDs.has(uid);\n    }\n    has(uid) {\n        return this.annotationUIDs.has(uid);\n    }\n    setVisible(isVisible = true, baseEvent, filter) {\n        if (this._isVisible === isVisible) {\n            return;\n        }\n        this._isVisible = isVisible;\n        this.annotationUIDs.forEach((uid) => {\n            const annotation = getAnnotation(uid);\n            if (!annotation) {\n                this.annotationUIDs.delete(uid);\n                return;\n            }\n            if (annotation.isVisible === isVisible) {\n                return;\n            }\n            if (!isVisible && filter?.(uid) === false) {\n                return;\n            }\n            annotation.isVisible = isVisible;\n            const eventDetail = {\n                ...baseEvent,\n                annotation,\n            };\n            triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n        });\n    }\n    get isVisible() {\n        return this._isVisible;\n    }\n    findNearby(uid, direction) {\n        const uids = [...this.annotationUIDs];\n        if (uids.length === 0) {\n            return null;\n        }\n        if (!uid) {\n            return uids[direction === 1 ? 0 : uids.length - 1];\n        }\n        const index = uids.indexOf(uid);\n        if (index === -1 ||\n            index + direction < 0 ||\n            index + direction >= uids.length) {\n            return null;\n        }\n        return uids[index + direction];\n    }\n    add(...annotationUIDs) {\n        annotationUIDs.forEach((annotationUID) => this.annotationUIDs.add(annotationUID));\n    }\n    remove(...annotationUIDs) {\n        annotationUIDs.forEach((annotationUID) => this.annotationUIDs.delete(annotationUID));\n    }\n    clear() {\n        this.annotationUIDs.clear();\n    }\n}\n","import * as config from './config';\nimport * as locking from './annotationLocking';\nimport * as selection from './annotationSelection';\nimport * as annotationState from './annotationState';\nimport * as annotationStateHelpers from './helpers/state';\nimport * as visibility from './annotationVisibility';\nimport FrameOfReferenceSpecificAnnotationManager from './FrameOfReferenceSpecificAnnotationManager';\nimport AnnotationGroup from './AnnotationGroup';\nimport { resetAnnotationManager } from './resetAnnotationManager';\nconst state = {\n    ...annotationState,\n    ...annotationStateHelpers,\n    resetAnnotationManager,\n};\nexport { config, locking, selection, state, visibility, FrameOfReferenceSpecificAnnotationManager, AnnotationGroup, };\n","import { triggerEvent, eventTarget, Enums, getRenderingEngines, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations, Events as csToolsEvents, } from '../../enums';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { getSegmentation } from './getSegmentation';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nimport surfaceDisplay from '../../tools/displayTools/Surface/surfaceDisplay';\nimport contourDisplay from '../../tools/displayTools/Contour/contourDisplay';\nimport labelmapDisplay from '../../tools/displayTools/Labelmap/labelmapDisplay';\nimport { addTool } from '../../store/addTool';\nimport { state } from '../../store/state';\nimport PlanarFreehandContourSegmentationTool from '../../tools/annotation/PlanarFreehandContourSegmentationTool';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport { addDefaultSegmentationListener } from './segmentationEventManager';\nconst renderers = {\n    [Representations.Labelmap]: labelmapDisplay,\n    [Representations.Contour]: contourDisplay,\n    [Representations.Surface]: surfaceDisplay,\n};\nconst planarContourToolName = PlanarFreehandContourSegmentationTool.toolName;\nclass SegmentationRenderingEngine {\n    constructor() {\n        this._needsRender = new Set();\n        this._pendingRenderQueue = [];\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._getAllViewports = () => {\n            const renderingEngine = getRenderingEngines();\n            return renderingEngine.flatMap((renderingEngine) => renderingEngine.getViewports());\n        };\n        this._renderFlaggedSegmentations = () => {\n            this._throwIfDestroyed();\n            const viewportIds = Array.from(this._needsRender);\n            viewportIds.forEach((viewportId) => {\n                this._triggerRender(viewportId);\n            });\n            this._needsRender.clear();\n            this._animationFrameSet = false;\n            this._animationFrameHandle = null;\n            if (this._pendingRenderQueue.length > 0) {\n                const nextViewportIds = this._pendingRenderQueue.shift();\n                if (nextViewportIds && nextViewportIds.length > 0) {\n                    this._setViewportsToBeRenderedNextFrame(nextViewportIds);\n                }\n            }\n        };\n    }\n    renderSegmentationsForViewport(viewportId) {\n        const viewportIds = viewportId\n            ? [viewportId]\n            : this._getViewportIdsForSegmentation();\n        this._setViewportsToBeRenderedNextFrame(viewportIds);\n    }\n    renderSegmentation(segmentationId) {\n        const viewportIds = this._getViewportIdsForSegmentation(segmentationId);\n        this._setViewportsToBeRenderedNextFrame(viewportIds);\n    }\n    _getViewportIdsForSegmentation(segmentationId) {\n        const viewports = this._getAllViewports();\n        const viewportIds = [];\n        for (const viewport of viewports) {\n            const viewportId = viewport.id;\n            if (segmentationId) {\n                const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n                if (segmentationRepresentations?.length > 0) {\n                    viewportIds.push(viewportId);\n                }\n            }\n            else {\n                const segmentationRepresentations = getSegmentationRepresentations(viewportId);\n                if (segmentationRepresentations?.length > 0) {\n                    viewportIds.push(viewportId);\n                }\n            }\n        }\n        return viewportIds;\n    }\n    _throwIfDestroyed() {\n        if (this.hasBeenDestroyed) {\n            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');\n        }\n    }\n    _setViewportsToBeRenderedNextFrame(viewportIds) {\n        if (this._animationFrameSet) {\n            this._pendingRenderQueue.push(viewportIds);\n            return;\n        }\n        viewportIds.forEach((viewportId) => {\n            this._needsRender.add(viewportId);\n        });\n        this._render();\n    }\n    _render() {\n        if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedSegmentations);\n            this._animationFrameSet = true;\n        }\n    }\n    _triggerRender(viewportId) {\n        const segmentationRepresentations = getSegmentationRepresentations(viewportId);\n        if (!segmentationRepresentations?.length) {\n            return;\n        }\n        const { viewport } = getEnabledElementByViewportId(viewportId) || {};\n        if (!viewport) {\n            return;\n        }\n        const segmentationRenderList = segmentationRepresentations.map((representation) => {\n            if (representation.type === SegmentationRepresentations.Contour) {\n                this._addPlanarFreeHandToolIfAbsent(viewport);\n            }\n            const display = renderers[representation.type];\n            const segmentation = getSegmentation(representation.segmentationId);\n            const existingRepresentation = segmentation.representationData[representation.type] !== undefined;\n            try {\n                display.render(viewport, representation).then(() => {\n                    if (!existingRepresentation) {\n                        addDefaultSegmentationListener(viewport, representation.segmentationId, representation.type);\n                    }\n                });\n            }\n            catch (error) {\n                console.error(error);\n            }\n            return Promise.resolve({\n                segmentationId: representation.segmentationId,\n                type: representation.type,\n            });\n        });\n        Promise.allSettled(segmentationRenderList).then((results) => {\n            const segmentationDetails = results\n                .filter((r) => r.status === 'fulfilled')\n                .map((r) => r.value);\n            function onSegmentationRender(evt) {\n                const { element, viewportId } = evt.detail;\n                element.removeEventListener(Enums.Events.IMAGE_RENDERED, onSegmentationRender);\n                segmentationDetails.forEach((detail) => {\n                    const eventDetail = {\n                        viewportId,\n                        segmentationId: detail.segmentationId,\n                        type: detail.type,\n                    };\n                    triggerEvent(eventTarget, csToolsEvents.SEGMENTATION_RENDERED, {\n                        ...eventDetail,\n                    });\n                });\n            }\n            const element = viewport.element;\n            element.addEventListener(Enums.Events.IMAGE_RENDERED, onSegmentationRender);\n            viewport.render();\n        });\n    }\n    _addPlanarFreeHandToolIfAbsent(viewport) {\n        if (!(planarContourToolName in state.tools)) {\n            addTool(PlanarFreehandContourSegmentationTool);\n        }\n        const toolGroup = getToolGroupForViewport(viewport.id);\n        if (!toolGroup.hasTool(planarContourToolName)) {\n            toolGroup.addTool(planarContourToolName);\n            toolGroup.setToolPassive(planarContourToolName);\n        }\n    }\n}\nfunction triggerSegmentationRender(viewportId) {\n    segmentationRenderingEngine.renderSegmentationsForViewport(viewportId);\n}\nfunction triggerSegmentationRenderBySegmentationId(segmentationId) {\n    segmentationRenderingEngine.renderSegmentation(segmentationId);\n}\nconst segmentationRenderingEngine = new SegmentationRenderingEngine();\nexport { triggerSegmentationRender, triggerSegmentationRenderBySegmentationId, segmentationRenderingEngine, };\n","import { BaseVolumeViewport, cache, utilities as csUtils, getEnabledElementByViewportId, volumeLoader, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nimport { triggerSegmentationModified, triggerSegmentationRemoved, triggerSegmentationRepresentationModified, triggerSegmentationRepresentationRemoved, } from './triggerSegmentationEvents';\nimport { segmentationStyle } from './SegmentationStyle';\nimport { triggerSegmentationAdded } from './events/triggerSegmentationAdded';\nconst initialDefaultState = {\n    colorLUT: [],\n    segmentations: [],\n    viewportSegRepresentations: {},\n};\nexport default class SegmentationStateManager {\n    constructor(uid) {\n        this._stackLabelmapImageIdReferenceMap = new Map();\n        this._labelmapImageIdReferenceMap = new Map();\n        uid ||= csUtils.uuidv4();\n        this.state = Object.freeze(csUtils.deepClone(initialDefaultState));\n        this.uid = uid;\n    }\n    getState() {\n        return this.state;\n    }\n    updateState(updater) {\n        const newState = csUtils.deepClone(this.state);\n        updater(newState);\n        this.state = Object.freeze(newState);\n    }\n    getColorLUT(lutIndex) {\n        return this.state.colorLUT[lutIndex];\n    }\n    getNextColorLUTIndex() {\n        return this.state.colorLUT.length;\n    }\n    resetState() {\n        this._stackLabelmapImageIdReferenceMap.clear();\n        this._labelmapImageIdReferenceMap.clear();\n        this.state = Object.freeze(csUtils.deepClone(initialDefaultState));\n    }\n    getSegmentation(segmentationId) {\n        return this.state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n    }\n    updateSegmentation(segmentationId, payload) {\n        this.updateState((draftState) => {\n            const segmentation = draftState.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n            if (!segmentation) {\n                console.warn(`Segmentation with id ${segmentationId} not found. Update aborted.`);\n                return;\n            }\n            Object.assign(segmentation, payload);\n        });\n        triggerSegmentationModified(segmentationId);\n    }\n    addSegmentation(segmentation) {\n        if (this.getSegmentation(segmentation.segmentationId)) {\n            throw new Error(`Segmentation with id ${segmentation.segmentationId} already exists`);\n        }\n        this.updateState((state) => {\n            const newSegmentation = csUtils.deepClone(segmentation);\n            if (newSegmentation.representationData.Labelmap &&\n                'volumeId' in newSegmentation.representationData.Labelmap &&\n                !('imageIds' in newSegmentation.representationData.Labelmap)) {\n                const imageIds = this.getLabelmapImageIds(newSegmentation.representationData);\n                newSegmentation.representationData\n                    .Labelmap.imageIds = imageIds;\n            }\n            state.segmentations.push(newSegmentation);\n        });\n        triggerSegmentationAdded(segmentation.segmentationId);\n    }\n    removeSegmentation(segmentationId) {\n        this.updateState((state) => {\n            const filteredSegmentations = state.segmentations.filter((segmentation) => segmentation.segmentationId !== segmentationId);\n            state.segmentations.splice(0, state.segmentations.length, ...filteredSegmentations);\n        });\n        triggerSegmentationRemoved(segmentationId);\n    }\n    addSegmentationRepresentation(viewportId, segmentationId, type, renderingConfig) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const existingRepresentations = this.getSegmentationRepresentations(viewportId, {\n            type: type,\n            segmentationId,\n        });\n        if (existingRepresentations.length > 0) {\n            console.debug('A segmentation representation of type', type, 'already exists in viewport', viewportId, 'for segmentation', segmentationId);\n            return;\n        }\n        this.updateState((state) => {\n            if (!state.viewportSegRepresentations[viewportId]) {\n                state.viewportSegRepresentations[viewportId] = [];\n                segmentationStyle.setRenderInactiveSegmentations(viewportId, true);\n            }\n            if (type !== SegmentationRepresentations.Labelmap) {\n                this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig);\n            }\n            else {\n                this.addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig);\n            }\n        });\n        triggerSegmentationRepresentationModified(viewportId, segmentationId, type);\n    }\n    addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig) {\n        const segmentation = state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const segmentReps = {};\n        Object.keys(segmentation.segments).forEach((segmentIndex) => {\n            segmentReps[Number(segmentIndex)] = {\n                visible: true,\n            };\n        });\n        state.viewportSegRepresentations[viewportId].push({\n            segmentationId,\n            type,\n            active: true,\n            visible: true,\n            colorLUTIndex: renderingConfig?.colorLUTIndex || 0,\n            segments: segmentReps,\n            config: {\n                ...getDefaultRenderingConfig(type),\n                ...renderingConfig,\n            },\n        });\n        this._setActiveSegmentation(state, viewportId, segmentationId);\n    }\n    addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig = getDefaultRenderingConfig(SegmentationRepresentations.Labelmap)) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, SegmentationRepresentations.Labelmap, renderingConfig);\n        }\n        this.processLabelmapRepresentationAddition(viewportId, segmentationId);\n        this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, SegmentationRepresentations.Labelmap, renderingConfig);\n    }\n    async processLabelmapRepresentationAddition(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const volumeViewport = enabledElement.viewport instanceof BaseVolumeViewport;\n        const { representationData } = segmentation;\n        const isBaseVolumeSegmentation = 'volumeId' in representationData.Labelmap;\n        const viewport = enabledElement.viewport;\n        if (!volumeViewport && !isBaseVolumeSegmentation) {\n            !this.updateLabelmapSegmentationImageReferences(viewportId, segmentation.segmentationId);\n        }\n    }\n    _updateLabelmapSegmentationReferences(segmentationId, viewport, labelmapImageIds, updateCallback) {\n        const referenceImageId = viewport.getCurrentImageId();\n        let viewableLabelmapImageIdFound = false;\n        for (const labelmapImageId of labelmapImageIds) {\n            const viewableImageId = viewport.isReferenceViewable({ referencedImageId: labelmapImageId }, { asOverlay: true });\n            if (viewableImageId) {\n                viewableLabelmapImageIdFound = true;\n                this._stackLabelmapImageIdReferenceMap\n                    .get(segmentationId)\n                    .set(referenceImageId, labelmapImageId);\n                this._updateLabelmapImageIdReferenceMap({\n                    segmentationId,\n                    referenceImageId,\n                    labelmapImageId,\n                });\n            }\n        }\n        if (updateCallback) {\n            updateCallback(viewport, segmentationId, labelmapImageIds);\n        }\n        return viewableLabelmapImageIdFound\n            ? this._stackLabelmapImageIdReferenceMap\n                .get(segmentationId)\n                .get(referenceImageId)\n            : undefined;\n    }\n    updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return;\n        }\n        const labelmapImageIds = this.getLabelmapImageIds(representationData);\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        const stackViewport = enabledElement.viewport;\n        return this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, null);\n    }\n    _updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return;\n        }\n        const labelmapImageIds = this.getLabelmapImageIds(representationData);\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        const stackViewport = enabledElement.viewport;\n        this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, (stackViewport, segmentationId, labelmapImageIds) => {\n            const imageIds = stackViewport.getImageIds();\n            imageIds.forEach((referenceImageId, index) => {\n                for (const labelmapImageId of labelmapImageIds) {\n                    const viewableImageId = stackViewport.isReferenceViewable({ referencedImageId: labelmapImageId, sliceIndex: index }, { asOverlay: true, withNavigation: true });\n                    if (viewableImageId) {\n                        this._stackLabelmapImageIdReferenceMap\n                            .get(segmentationId)\n                            .set(referenceImageId, labelmapImageId);\n                        this._updateLabelmapImageIdReferenceMap({\n                            segmentationId,\n                            referenceImageId,\n                            labelmapImageId,\n                        });\n                    }\n                }\n            });\n        });\n    }\n    getLabelmapImageIds(representationData) {\n        const labelmapData = representationData.Labelmap;\n        let labelmapImageIds;\n        if (labelmapData.imageIds) {\n            labelmapImageIds = labelmapData\n                .imageIds;\n        }\n        else if (!labelmapImageIds &&\n            labelmapData.volumeId) {\n            const volumeId = labelmapData\n                .volumeId;\n            const volume = cache.getVolume(volumeId);\n            labelmapImageIds = volume.imageIds;\n        }\n        return labelmapImageIds;\n    }\n    getLabelmapImageIdsForImageId(imageId, segmentationId) {\n        const key = this._generateMapKey({\n            segmentationId,\n            referenceImageId: imageId,\n        });\n        return this._labelmapImageIdReferenceMap.get(key);\n    }\n    getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const stackViewport = enabledElement.viewport;\n        const referenceImageId = stackViewport.getCurrentImageId();\n        return this.getLabelmapImageIdsForImageId(referenceImageId, segmentationId);\n    }\n    getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            return;\n        }\n        const stackViewport = enabledElement.viewport;\n        const currentImageId = stackViewport.getCurrentImageId();\n        const imageIdReferenceMap = this._stackLabelmapImageIdReferenceMap.get(segmentationId);\n        return imageIdReferenceMap.get(currentImageId);\n    }\n    getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return [];\n        }\n        this._updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId);\n        const { viewport } = getEnabledElementByViewportId(viewportId);\n        const imageIds = viewport.getImageIds();\n        const associatedReferenceImageAndLabelmapImageIds = this._stackLabelmapImageIdReferenceMap.get(segmentationId);\n        return imageIds.map((imageId) => {\n            return associatedReferenceImageAndLabelmapImageIds.get(imageId);\n        });\n    }\n    removeSegmentationRepresentationsInternal(viewportId, specifier) {\n        const removedRepresentations = [];\n        this.updateState((state) => {\n            if (!state.viewportSegRepresentations[viewportId]) {\n                return;\n            }\n            const currentRepresentations = state.viewportSegRepresentations[viewportId];\n            let activeRepresentationRemoved = false;\n            if (!specifier ||\n                Object.values(specifier).every((value) => value === undefined)) {\n                removedRepresentations.push(...currentRepresentations);\n                delete state.viewportSegRepresentations[viewportId];\n            }\n            else {\n                const { segmentationId, type } = specifier;\n                state.viewportSegRepresentations[viewportId] =\n                    currentRepresentations.filter((representation) => {\n                        const shouldRemove = (segmentationId &&\n                            type &&\n                            representation.segmentationId === segmentationId &&\n                            representation.type === type) ||\n                            (segmentationId &&\n                                !type &&\n                                representation.segmentationId === segmentationId) ||\n                            (!segmentationId && type && representation.type === type);\n                        if (shouldRemove) {\n                            removedRepresentations.push(representation);\n                            if (representation.active) {\n                                activeRepresentationRemoved = true;\n                            }\n                        }\n                        return !shouldRemove;\n                    });\n                if (state.viewportSegRepresentations[viewportId].length === 0) {\n                    delete state.viewportSegRepresentations[viewportId];\n                }\n                else if (activeRepresentationRemoved) {\n                    state.viewportSegRepresentations[viewportId][0].active = true;\n                }\n            }\n        });\n        return removedRepresentations;\n    }\n    removeSegmentationRepresentations(viewportId, specifier) {\n        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);\n        removedRepresentations.forEach((representation) => {\n            triggerSegmentationRepresentationRemoved(viewportId, representation.segmentationId, representation.type);\n        });\n        const remainingRepresentations = this.getSegmentationRepresentations(viewportId);\n        if (remainingRepresentations.length > 0 &&\n            remainingRepresentations[0].active) {\n            triggerSegmentationRepresentationModified(viewportId, remainingRepresentations[0].segmentationId, remainingRepresentations[0].type);\n        }\n        return removedRepresentations;\n    }\n    removeSegmentationRepresentation(viewportId, specifier, suppressEvent) {\n        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);\n        if (!suppressEvent) {\n            removedRepresentations.forEach(({ segmentationId, type }) => {\n                triggerSegmentationRepresentationRemoved(viewportId, segmentationId, type);\n            });\n        }\n        return removedRepresentations;\n    }\n    _updateLabelmapImageIdReferenceMap({ segmentationId, referenceImageId, labelmapImageId, }) {\n        const key = this._generateMapKey({ segmentationId, referenceImageId });\n        if (!this._labelmapImageIdReferenceMap.has(key)) {\n            this._labelmapImageIdReferenceMap.set(key, [labelmapImageId]);\n            return;\n        }\n        const currentValues = this._labelmapImageIdReferenceMap.get(key);\n        const newValues = Array.from(new Set([...currentValues, labelmapImageId]));\n        this._labelmapImageIdReferenceMap.set(key, newValues);\n    }\n    _setActiveSegmentation(state, viewportId, segmentationId) {\n        const viewport = state.viewportSegRepresentations[viewportId];\n        if (!viewport) {\n            return;\n        }\n        viewport.forEach((value) => {\n            value.active = value.segmentationId === segmentationId;\n        });\n    }\n    setActiveSegmentation(viewportId, segmentationId) {\n        this.updateState((state) => {\n            const viewport = state.viewportSegRepresentations[viewportId];\n            if (!viewport) {\n                return;\n            }\n            viewport.forEach((value) => {\n                value.active = value.segmentationId === segmentationId;\n            });\n        });\n        triggerSegmentationRepresentationModified(viewportId, segmentationId);\n    }\n    getActiveSegmentation(viewportId) {\n        if (!this.state.viewportSegRepresentations[viewportId]) {\n            return;\n        }\n        const activeSegRep = this.state.viewportSegRepresentations[viewportId].find((segRep) => segRep.active);\n        if (!activeSegRep) {\n            return;\n        }\n        return this.getSegmentation(activeSegRep.segmentationId);\n    }\n    getSegmentationRepresentations(viewportId, specifier = {}) {\n        const viewportRepresentations = this.state.viewportSegRepresentations[viewportId];\n        if (!viewportRepresentations) {\n            return [];\n        }\n        if (!specifier.type && !specifier.segmentationId) {\n            return viewportRepresentations;\n        }\n        return viewportRepresentations.filter((representation) => {\n            const typeMatch = specifier.type\n                ? representation.type === specifier.type\n                : true;\n            const idMatch = specifier.segmentationId\n                ? representation.segmentationId === specifier.segmentationId\n                : true;\n            return typeMatch && idMatch;\n        });\n    }\n    getSegmentationRepresentation(viewportId, specifier) {\n        return this.getSegmentationRepresentations(viewportId, specifier)[0];\n    }\n    getSegmentationRepresentationVisibility(viewportId, specifier) {\n        const viewportRepresentation = this.getSegmentationRepresentation(viewportId, specifier);\n        return viewportRepresentation?.visible;\n    }\n    setSegmentationRepresentationVisibility(viewportId, specifier, visible) {\n        this.updateState((state) => {\n            const viewportRepresentations = this.getSegmentationRepresentations(viewportId, specifier);\n            if (!viewportRepresentations) {\n                return;\n            }\n            viewportRepresentations.forEach((representation) => {\n                representation.visible = visible;\n                Object.entries(representation.segments).forEach(([segmentIndex, segment]) => {\n                    segment.visible = visible;\n                });\n            });\n        });\n        triggerSegmentationRepresentationModified(viewportId, specifier.segmentationId, specifier.type);\n    }\n    addColorLUT(colorLUT, lutIndex) {\n        this.updateState((state) => {\n            if (state.colorLUT[lutIndex]) {\n                console.warn('Color LUT table already exists, overwriting');\n            }\n            state.colorLUT[lutIndex] = csUtils.deepClone(colorLUT);\n        });\n    }\n    removeColorLUT(colorLUTIndex) {\n        this.updateState((state) => {\n            delete state.colorLUT[colorLUTIndex];\n        });\n    }\n    _getStackIdForImageIds(imageIds) {\n        return imageIds\n            .map((imageId) => imageId.slice(-Math.round(imageId.length * 0.15)))\n            .join('_');\n    }\n    getAllViewportSegmentationRepresentations() {\n        return Object.entries(this.state.viewportSegRepresentations).map(([viewportId, representations]) => ({\n            viewportId,\n            representations,\n        }));\n    }\n    getSegmentationRepresentationsBySegmentationId(segmentationId) {\n        const result = [];\n        Object.entries(this.state.viewportSegRepresentations).forEach(([viewportId, viewportReps]) => {\n            const filteredReps = viewportReps.filter((representation) => representation.segmentationId === segmentationId);\n            if (filteredReps.length > 0) {\n                result.push({ viewportId, representations: filteredReps });\n            }\n        });\n        return result;\n    }\n    _generateMapKey({ segmentationId, referenceImageId }) {\n        return `${segmentationId}-${referenceImageId}`;\n    }\n}\nasync function internalComputeVolumeLabelmapFromStack({ imageIds, options, }) {\n    const segmentationImageIds = imageIds;\n    const volumeId = options?.volumeId || csUtils.uuidv4();\n    await volumeLoader.createAndCacheVolumeFromImages(volumeId, segmentationImageIds);\n    return { volumeId };\n}\nasync function internalConvertStackToVolumeLabelmap({ segmentationId, options, }) {\n    const segmentation = defaultSegmentationStateManager.getSegmentation(segmentationId);\n    const data = segmentation.representationData\n        .Labelmap;\n    const { volumeId } = await internalComputeVolumeLabelmapFromStack({\n        imageIds: data.imageIds,\n        options,\n    });\n    segmentation.representationData.Labelmap.volumeId = volumeId;\n}\nfunction getDefaultRenderingConfig(type) {\n    const cfun = vtkColorTransferFunction.newInstance();\n    const ofun = vtkPiecewiseFunction.newInstance();\n    ofun.addPoint(0, 0);\n    if (type === SegmentationRepresentations.Labelmap) {\n        return {\n            cfun,\n            ofun,\n        };\n    }\n    else {\n        return {};\n    }\n}\nconst defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');\nexport { internalConvertStackToVolumeLabelmap, internalComputeVolumeLabelmapFromStack, defaultSegmentationStateManager, };\n","import { getActiveSegmentation as _getActiveSegmentation } from './getActiveSegmentation';\nimport { setActiveSegmentation as _setActiveSegmentation } from './setActiveSegmentation';\nfunction getActiveSegmentation(viewportId) {\n    return _getActiveSegmentation(viewportId);\n}\nfunction setActiveSegmentation(viewportId, segmentationId) {\n    _setActiveSegmentation(viewportId, segmentationId);\n}\nexport { getActiveSegmentation, setActiveSegmentation, };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function setActiveSegmentation(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationStateManager.setActiveSegmentation(viewportId, segmentationId);\n}\n","import { utilities } from '@cornerstonejs/core';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { getNextColorLUTIndex } from './getNextColorLUTIndex';\nimport CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\nexport function addColorLUT(colorLUT, index) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const indexToUse = index ?? getNextColorLUTIndex();\n    let colorLUTToUse = [...colorLUT];\n    if (!utilities.isEqual(colorLUTToUse[0], [0, 0, 0, 0])) {\n        console.warn('addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it');\n        colorLUTToUse = [[0, 0, 0, 0], ...colorLUTToUse];\n    }\n    colorLUTToUse = colorLUTToUse.map((color) => {\n        if (color.length === 3) {\n            return [color[0], color[1], color[2], 255];\n        }\n        return color;\n    });\n    if (colorLUTToUse.length < 255) {\n        const missingColorLUTs = CORNERSTONE_COLOR_LUT.slice(colorLUTToUse.length);\n        colorLUTToUse = [...colorLUTToUse, ...missingColorLUTs];\n    }\n    segmentationStateManager.addColorLUT(colorLUTToUse, indexToUse);\n    return indexToUse;\n}\n","import { SegmentationRepresentations } from '../../enums';\nimport { internalAddSegmentationRepresentation } from './internalAddSegmentationRepresentation';\nexport function addSegmentationRepresentations(viewportId, segmentationInputArray) {\n    segmentationInputArray.map((segmentationInput) => {\n        return internalAddSegmentationRepresentation(viewportId, segmentationInput);\n    });\n}\nfunction addContourRepresentationToViewport(viewportId, contourInputArray) {\n    return addSegmentationRepresentations(viewportId, contourInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Contour,\n    })));\n}\nfunction addContourRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addContourRepresentationToViewport(viewportId, inputArray);\n    }\n    return results;\n}\nfunction addLabelmapRepresentationToViewport(viewportId, labelmapInputArray) {\n    return addSegmentationRepresentations(viewportId, labelmapInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Labelmap,\n    })));\n}\nfunction addLabelmapRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addLabelmapRepresentationToViewport(viewportId, inputArray.map((input) => ({\n            ...input,\n            type: SegmentationRepresentations.Labelmap,\n        })));\n    }\n}\nfunction addSurfaceRepresentationToViewport(viewportId, surfaceInputArray) {\n    return addSegmentationRepresentations(viewportId, surfaceInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Surface,\n    })));\n}\nfunction addSurfaceRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addSurfaceRepresentationToViewport(viewportId, inputArray);\n    }\n    return results;\n}\nexport { addContourRepresentationToViewport, addLabelmapRepresentationToViewport, addSurfaceRepresentationToViewport, addContourRepresentationToViewportMap, addLabelmapRepresentationToViewportMap, addSurfaceRepresentationToViewportMap, };\n","import { SegmentationRepresentations } from '../../../enums';\nimport { cache } from '@cornerstonejs/core';\nfunction normalizeSegmentationInput(segmentationInput) {\n    const { segmentationId, representation, config } = segmentationInput;\n    const { type, data: inputData } = representation;\n    const data = inputData ? { ...inputData } : {};\n    if (!data) {\n        throw new Error('Segmentation representation data may not be undefined');\n    }\n    if (type === SegmentationRepresentations.Contour) {\n        normalizeContourData(data);\n    }\n    const normalizedSegments = normalizeSegments(config?.segments, type, data);\n    delete config?.segments;\n    return {\n        segmentationId,\n        label: config?.label ?? null,\n        cachedStats: config?.cachedStats ?? {},\n        segments: normalizedSegments,\n        representationData: {\n            [type]: {\n                ...data,\n            },\n        },\n    };\n}\nfunction normalizeContourData(contourData) {\n    contourData.geometryIds = contourData.geometryIds ?? [];\n    contourData.annotationUIDsMap = contourData.annotationUIDsMap ?? new Map();\n}\nfunction normalizeSegments(segmentsConfig, type, data) {\n    const normalizedSegments = {};\n    if (segmentsConfig) {\n        Object.entries(segmentsConfig).forEach(([segmentIndex, segment]) => {\n            const { label, locked, cachedStats, active, ...rest } = segment;\n            const normalizedSegment = {\n                segmentIndex: Number(segmentIndex),\n                label: label ?? `Segment ${segmentIndex}`,\n                locked: locked ?? false,\n                cachedStats: cachedStats ?? {},\n                active: active ?? false,\n                ...rest,\n            };\n            normalizedSegments[segmentIndex] = normalizedSegment;\n        });\n    }\n    else if (type === SegmentationRepresentations.Contour) {\n        normalizeContourSegments(normalizedSegments, data);\n    }\n    else if (type === SegmentationRepresentations.Surface) {\n        normalizeSurfaceSegments(normalizedSegments, data);\n    }\n    else {\n        normalizedSegments[1] = createDefaultSegment();\n    }\n    return normalizedSegments;\n}\nfunction normalizeContourSegments(normalizedSegments, contourData) {\n    const { geometryIds } = contourData;\n    geometryIds?.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (geometry?.data) {\n            const { segmentIndex } = geometry.data;\n            normalizedSegments[segmentIndex] = { segmentIndex };\n        }\n    });\n}\nfunction normalizeSurfaceSegments(normalizedSegments, surfaceData) {\n    const { geometryIds } = surfaceData;\n    geometryIds?.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (geometry?.data) {\n            const { segmentIndex } = geometry.data;\n            normalizedSegments[segmentIndex] = { segmentIndex };\n        }\n    });\n}\nfunction createDefaultSegment() {\n    return {\n        segmentIndex: 1,\n        label: 'Segment 1',\n        locked: false,\n        cachedStats: {},\n        active: true,\n    };\n}\nexport default normalizeSegmentationInput;\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport normalizeSegmentationInput from './helpers/normalizeSegmentationInput';\nexport function addSegmentations(segmentationInputArray, suppressEvents) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationInputArray.forEach((segmentationInput) => {\n        const segmentation = normalizeSegmentationInput(segmentationInput);\n        segmentationStateManager.addSegmentation(segmentation);\n        if (!suppressEvents) {\n            triggerSegmentationModified(segmentation.segmentationId);\n        }\n    });\n}\nexport default addSegmentations;\n","import { addColorLUT as _addColorLUT } from '../addColorLUT';\nimport { getColorLUT as _getColorLUT } from '../getColorLUT';\nimport { getSegmentationRepresentations } from '../getSegmentationRepresentation';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nfunction addColorLUT(colorLUT, colorLUTIndex) {\n    if (!colorLUT) {\n        throw new Error('addColorLUT: colorLUT is required');\n    }\n    return _addColorLUT(colorLUT, colorLUTIndex);\n}\nfunction setColorLUT(viewportId, segmentationId, colorLUTsIndex) {\n    if (!_getColorLUT(colorLUTsIndex)) {\n        throw new Error(`setColorLUT: could not find colorLUT with index ${colorLUTsIndex}`);\n    }\n    const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n    if (!segmentationRepresentations) {\n        throw new Error(`viewport specific state for viewport ${viewportId} does not exist`);\n    }\n    segmentationRepresentations.forEach((segmentationRepresentation) => {\n        segmentationRepresentation.colorLUTIndex = colorLUTsIndex;\n    });\n    triggerSegmentationRepresentationModified(viewportId, segmentationId);\n}\nfunction getSegmentIndexColor(viewportId, segmentationId, segmentIndex) {\n    const representations = getSegmentationRepresentations(viewportId, {\n        segmentationId,\n    });\n    if (!representations || representations.length === 0) {\n        return null;\n    }\n    const representation = representations[0];\n    const { colorLUTIndex } = representation;\n    const colorLUT = _getColorLUT(colorLUTIndex);\n    let colorValue = colorLUT[segmentIndex];\n    if (!colorValue) {\n        if (typeof segmentIndex !== 'number') {\n            console.warn(`Can't create colour for LUT index ${segmentIndex}`);\n            return null;\n        }\n        colorValue = colorLUT[segmentIndex] = [0, 0, 0, 0];\n    }\n    return colorValue;\n}\nfunction setSegmentIndexColor(viewportId, segmentationId, segmentIndex, color) {\n    const colorReference = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n    for (let i = 0; i < color.length; i++) {\n        colorReference[i] = color[i];\n    }\n    triggerSegmentationRepresentationModified(viewportId, segmentationId);\n}\nexport { getSegmentIndexColor, addColorLUT, setColorLUT, setSegmentIndexColor };\n","import { getSegmentation } from './getSegmentation';\nexport function getActiveSegmentIndex(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (segmentation) {\n        const activeSegmentIndex = Object.keys(segmentation.segments).find((segmentIndex) => segmentation.segments[segmentIndex].active);\n        return activeSegmentIndex ? Number(activeSegmentIndex) : undefined;\n    }\n    return undefined;\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getColorLUT(index) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getColorLUT(index);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {\n    const imageIds = getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);\n    return imageIds[0];\n}\nexport function getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);\n}\nexport function getLabelmapImageIdsForImageId(imageId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getLabelmapImageIdsForImageId(imageId, segmentationId);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getNextColorLUTIndex() {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getNextColorLUTIndex();\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentationRepresentations(viewportId, specifier = {}) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);\n}\nexport function getSegmentationRepresentation(viewportId, specifier) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    if (!specifier.segmentationId || !specifier.type) {\n        throw new Error('getSegmentationRepresentation: No segmentationId or type provided, you need to provide at least one of them');\n    }\n    const representations = segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);\n    return representations?.[0];\n}\nexport function getSegmentationRepresentationsBySegmentationId(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentationsBySegmentationId(segmentationId);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentations() {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const state = segmentationStateManager.getState();\n    return state.segmentations;\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getViewportIdsWithSegmentation(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const state = segmentationStateManager.getState();\n    const viewportSegRepresentations = state.viewportSegRepresentations;\n    const viewportIdsWithSegmentation = Object.entries(viewportSegRepresentations)\n        .filter(([, viewportSegmentations]) => viewportSegmentations.some((segRep) => segRep.segmentationId === segmentationId))\n        .map(([viewportId]) => viewportId);\n    return viewportIdsWithSegmentation;\n}\n","import { getSegmentation } from './getSegmentation';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getViewportSegmentations(viewportId, type) {\n    const viewportRepresentations = getViewportSegmentationRepresentations(viewportId);\n    const segmentations = viewportRepresentations.map((representation) => {\n        if (type && representation.type === type) {\n            return getSegmentation(representation.segmentationId);\n        }\n        return getSegmentation(representation.segmentationId);\n    });\n    const filteredSegmentations = segmentations.filter((segmentation) => segmentation !== undefined);\n    return filteredSegmentations;\n}\nexport function getViewportSegmentationRepresentations(viewportId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const state = segmentationStateManager.getState();\n    const viewportRepresentations = state.viewportSegRepresentations[viewportId];\n    return viewportRepresentations;\n}\n","import { cache } from '@cornerstonejs/core';\nimport { getSegmentation } from '../getSegmentation';\nimport { updateStackSegmentationState } from '../helpers/updateStackSegmentationState';\nexport async function computeStackLabelmapFromVolume({ volumeId, }) {\n    const segmentationVolume = cache.getVolume(volumeId);\n    return { imageIds: segmentationVolume.imageIds };\n}\nexport function convertVolumeToStackLabelmap({ segmentationId, options, }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    const { volumeId } = segmentation.representationData\n        .Labelmap;\n    const segmentationVolume = cache.getVolume(volumeId);\n    return updateStackSegmentationState({\n        segmentationId,\n        viewportId: options.viewportId,\n        imageIds: segmentationVolume.imageIds,\n        options,\n    });\n}\n","import { internalComputeVolumeLabelmapFromStack } from '../SegmentationStateManager';\nexport async function computeVolumeLabelmapFromStack(args) {\n    return internalComputeVolumeLabelmapFromStack(args);\n}\n","import { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../../enums';\nfunction getActorEntry(viewportId, segmentationId, filterFn) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    if (!enabledElement) {\n        return;\n    }\n    const { renderingEngine, viewport } = enabledElement;\n    if (!renderingEngine || !viewport) {\n        return;\n    }\n    const actors = viewport.getActors();\n    const filteredActors = actors.filter(filterFn);\n    return filteredActors.length > 0 ? filteredActors[0] : undefined;\n}\nfunction getActorEntries(viewportId, filterFn) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    if (!enabledElement) {\n        return;\n    }\n    const { renderingEngine, viewport } = enabledElement;\n    if (!renderingEngine || !viewport) {\n        return;\n    }\n    const actors = viewport.getActors();\n    const filteredActors = actors.filter(filterFn);\n    return filteredActors.length > 0 ? filteredActors : undefined;\n}\nexport function getLabelmapActorUID(viewportId, segmentationId) {\n    const actorEntry = getLabelmapActorEntry(viewportId, segmentationId);\n    return actorEntry?.uid;\n}\nexport function getLabelmapActorEntries(viewportId, segmentationId) {\n    return getActorEntries(viewportId, (actor) => actor.representationUID?.startsWith(`${segmentationId}-${SegmentationRepresentations.Labelmap}`));\n}\nexport function getLabelmapActorEntry(viewportId, segmentationId) {\n    return getActorEntry(viewportId, segmentationId, (actor) => actor.representationUID?.startsWith(`${segmentationId}-${SegmentationRepresentations.Labelmap}`));\n}\nexport function getSurfaceActorEntry(viewportId, segmentationId, segmentIndex) {\n    return getActorEntry(viewportId, segmentationId, (actor) => actor.representationUID ===\n        getSurfaceRepresentationUID(segmentationId, segmentIndex));\n}\nexport function getSurfaceRepresentationUID(segmentationId, segmentIndex) {\n    return `${segmentationId}-${SegmentationRepresentations.Surface}-${segmentIndex}`;\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nexport function updateSegmentations(segmentationUpdateArray, suppressEvents) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationUpdateArray.forEach((segmentationUpdate) => {\n        segmentationStateManager.updateSegmentation(segmentationUpdate.segmentationId, segmentationUpdate.payload);\n        if (!suppressEvents) {\n            triggerSegmentationModified(segmentationUpdate.segmentationId);\n        }\n    });\n}\n","import { getSegmentationRepresentation, getSegmentationRepresentations, } from '../getSegmentationRepresentation';\nimport { setSegmentationRepresentationVisibility as _setSegmentationRepresentationVisibility } from '../setSegmentationRepresentationVisibility';\nimport { getSegmentationRepresentationVisibility as _getSegmentationRepresentationVisibility } from '../getSegmentationRepresentationVisibility';\nimport { triggerSegmentationRenderBySegmentationId } from '../SegmentationRenderingEngine';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nfunction setSegmentationRepresentationVisibility(viewportId, specifier, visibility) {\n    const representations = getSegmentationRepresentations(viewportId, specifier);\n    if (!representations) {\n        return;\n    }\n    representations.forEach((representation) => {\n        _setSegmentationRepresentationVisibility(viewportId, {\n            segmentationId: representation.segmentationId,\n            type: representation.type,\n        }, visibility);\n    });\n}\nfunction getSegmentationRepresentationVisibility(viewportId, specifier) {\n    return _getSegmentationRepresentationVisibility(viewportId, specifier);\n}\nfunction setSegmentIndexVisibility(viewportId, specifier, segmentIndex, visibility) {\n    const representations = getSegmentationRepresentations(viewportId, specifier);\n    if (!representations) {\n        return;\n    }\n    representations.forEach((representation) => {\n        if (!representation.segments || !representation.segments[segmentIndex]) {\n            return;\n        }\n        representation.segments[segmentIndex].visible = visibility;\n    });\n    triggerSegmentationRenderBySegmentationId(specifier.segmentationId);\n    triggerSegmentationRepresentationModified(viewportId, specifier.segmentationId);\n}\nfunction getSegmentIndexVisibility(viewportId, specifier, segmentIndex) {\n    const hiddenSegments = getHiddenSegmentIndices(viewportId, specifier);\n    return !hiddenSegments.has(segmentIndex);\n}\nfunction getHiddenSegmentIndices(viewportId, specifier) {\n    const representation = getSegmentationRepresentation(viewportId, specifier);\n    if (!representation) {\n        return new Set();\n    }\n    const segmentsHidden = Object.entries(representation.segments).reduce((acc, [segmentIndex, segment]) => {\n        if (!segment.visible) {\n            acc.add(Number(segmentIndex));\n        }\n        return acc;\n    }, new Set());\n    return segmentsHidden;\n}\nexport { setSegmentationRepresentationVisibility, getSegmentationRepresentationVisibility, setSegmentIndexVisibility, getSegmentIndexVisibility, getHiddenSegmentIndices, };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function setSegmentationRepresentationVisibility(viewportId, specifier, visible) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationStateManager.setSegmentationRepresentationVisibility(viewportId, specifier, visible);\n}\n","import { getSegmentations } from '../getSegmentations';\nimport { getViewportSegmentations } from '../getViewportSegmentations';\nimport { triggerSegmentationRender } from '../SegmentationRenderingEngine';\nimport { segmentationStyle } from '../SegmentationStyle';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nfunction getStyle(specifier) {\n    return segmentationStyle.getStyle(specifier);\n}\nfunction setStyle(specifier, style, merge) {\n    segmentationStyle.setStyle(specifier, style, merge);\n    if (!specifier.viewportId && !specifier.segmentationId) {\n        const segmentations = getSegmentations();\n        segmentations.forEach((segmentation) => {\n            triggerSegmentationRender(segmentation.segmentationId);\n        });\n    }\n    triggerSegmentationRepresentationModified(specifier.viewportId, specifier.segmentationId, specifier.type);\n}\nfunction setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {\n    segmentationStyle.setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations);\n    triggerSegmentationRender(viewportId);\n    const segmentations = getViewportSegmentations(viewportId);\n    segmentations.forEach((segmentation) => {\n        triggerSegmentationRepresentationModified(viewportId, segmentation.segmentationId);\n    });\n}\nfunction getRenderInactiveSegmentations(viewportId) {\n    return segmentationStyle.getRenderInactiveSegmentations(viewportId);\n}\nfunction resetToGlobalStyle() {\n    segmentationStyle.resetToGlobalStyle();\n    triggerSegmentationRender();\n}\nfunction hasCustomStyle(specifier) {\n    return segmentationStyle.hasCustomStyle(specifier);\n}\nexport { getStyle, setStyle, setRenderInactiveSegmentations, getRenderInactiveSegmentations, resetToGlobalStyle, hasCustomStyle, };\n","import { cache } from '@cornerstonejs/core';\nimport { getSegmentation } from '../getSegmentation';\nimport { triggerSegmentationDataModified } from '../triggerSegmentationEvents';\nexport function clearSegmentValue(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (segmentation.representationData.Labelmap) {\n        const { representationData } = segmentation;\n        const labelmapData = representationData.Labelmap;\n        if ('imageIds' in labelmapData || 'volumeId' in labelmapData) {\n            const items = 'imageIds' in labelmapData\n                ? labelmapData.imageIds.map((imageId) => cache.getImage(imageId))\n                : [cache.getVolume(labelmapData.volumeId)];\n            items.forEach((item) => {\n                if (!item) {\n                    return;\n                }\n                const { voxelManager } = item;\n                voxelManager.forEach(({ value, index }) => {\n                    if (value === segmentIndex) {\n                        voxelManager.setAtIndex(index, 0);\n                    }\n                });\n            });\n        }\n        triggerSegmentationDataModified(segmentationId);\n    }\n    else {\n        throw new Error('Invalid segmentation type, only labelmap is supported right now');\n    }\n}\n","import { getActiveSegmentIndex } from './getActiveSegmentIndex';\nimport { getSegmentation } from './getSegmentation';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nimport { getViewportIdsWithSegmentation } from './getViewportIdsWithSegmentation';\nimport { removeContourSegmentAnnotations } from './helpers/removeSegmentAnnotations';\nimport { clearSegmentValue } from './helpers/clearSegmentValue';\nimport { setActiveSegmentIndex } from './segmentIndex';\nimport { updateSegmentations } from './updateSegmentations';\nexport function removeSegment(segmentationId, segmentIndex, options = {\n    setNextSegmentAsActive: true,\n}) {\n    const segmentation = getSegmentation(segmentationId);\n    if (segmentation?.representationData.Contour) {\n        removeContourSegmentAnnotations(segmentationId, segmentIndex);\n    }\n    else if (segmentation?.representationData.Labelmap) {\n        clearSegmentValue(segmentationId, segmentIndex);\n    }\n    else {\n        throw new Error('Invalid segmentation type');\n    }\n    const isThisSegmentActive = getActiveSegmentIndex(segmentationId) === segmentIndex;\n    const { segments } = segmentation;\n    delete segments[segmentIndex];\n    const updatedSegments = {\n        ...segments,\n    };\n    updateSegmentations([\n        {\n            segmentationId,\n            payload: {\n                segments: updatedSegments,\n            },\n        },\n    ]);\n    if (isThisSegmentActive && options.setNextSegmentAsActive) {\n        const segmentIndices = Object.keys(segments)\n            .map(Number)\n            .sort((a, b) => a - b);\n        const currentIndex = segmentIndices.indexOf(segmentIndex);\n        const nextSegmentIndex = segmentIndices[currentIndex + 1];\n        const previousSegmentIndex = segmentIndices[currentIndex - 1];\n        if (nextSegmentIndex !== undefined) {\n            setActiveSegmentIndex(segmentationId, nextSegmentIndex);\n        }\n        else if (previousSegmentIndex !== undefined) {\n            setActiveSegmentIndex(segmentationId, previousSegmentIndex);\n        }\n    }\n    const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n    viewportIds.forEach((viewportId) => {\n        const representations = getSegmentationRepresentations(viewportId, {\n            segmentationId,\n        });\n        representations.forEach((representation) => {\n            delete representation.segments[segmentIndex];\n        });\n    });\n}\n","import { getAnnotation } from '../../annotation/annotationState';\nimport { getAnnotationsUIDMapFromSegmentation, removeCompleteContourAnnotation, } from '../utilities';\nimport { isContourSegmentationAnnotation } from '../../../utilities/contourSegmentation';\nexport function removeContourSegmentAnnotations(segmentationId, segmentIndex) {\n    const annotationUIDsMap = getAnnotationsUIDMapFromSegmentation(segmentationId);\n    if (!annotationUIDsMap) {\n        return;\n    }\n    const annotationUIDs = annotationUIDsMap.get(segmentIndex);\n    if (!annotationUIDs) {\n        return;\n    }\n    annotationUIDs.forEach((annotationUID) => {\n        const annotation = getAnnotation(annotationUID);\n        if (isContourSegmentationAnnotation(annotation)) {\n            removeCompleteContourAnnotation(annotation);\n        }\n    });\n}\n","import { getSegmentation } from './getSegmentation';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getLabelmapImageIds(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const segmentation = getSegmentation(segmentationId);\n    return segmentationStateManager.getLabelmapImageIds(segmentation.representationData);\n}\n","import { removeContourRepresentation, removeLabelmapRepresentation, removeSegmentationRepresentation, removeSurfaceRepresentation, removeSegmentationRepresentations, removeAllSegmentationRepresentations, } from './removeSegmentationRepresentations';\nimport { addContourRepresentationToViewport, addContourRepresentationToViewportMap, addSurfaceRepresentationToViewport, addSurfaceRepresentationToViewportMap, addLabelmapRepresentationToViewport, addLabelmapRepresentationToViewportMap, addSegmentationRepresentations, } from './addSegmentationRepresentationsToViewport';\nimport { addSegmentations } from './addSegmentations';\nimport addRepresentationData from './internalAddRepresentationData';\nimport { updateSegmentations } from './updateSegmentations';\nimport * as activeSegmentation from './activeSegmentation';\nimport * as segmentLocking from './segmentLocking';\nimport * as state from './segmentationState';\nimport * as config from './config';\nimport * as segmentIndex from './segmentIndex';\nimport * as triggerSegmentationEvents from './triggerSegmentationEvents';\nimport * as utilities from './utilities';\nimport { convertStackToVolumeLabelmap } from './helpers/convertStackToVolumeLabelmap';\nimport { computeVolumeLabelmapFromStack } from './helpers/computeVolumeLabelmapFromStack';\nimport { clearSegmentValue } from './helpers/clearSegmentValue';\nimport { convertVolumeToStackLabelmap } from './helpers/computeStackLabelmapFromVolume';\nimport { removeSegment } from './removeSegment';\nimport { getLabelmapImageIds } from './getLabelmapImageIds';\nimport * as strategies from './../../tools/segmentation/strategies';\nimport { removeAllSegmentations, removeSegmentation, } from './removeSegmentation';\nimport { segmentationStyle } from './SegmentationStyle';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { getCurrentLabelmapImageIdsForViewport, getLabelmapImageIdsForImageId, } from './getCurrentLabelmapImageIdForViewport';\nimport { getActiveSegmentation } from './getActiveSegmentation';\nimport { addSegmentationListener, addDefaultSegmentationListener, removeSegmentationListener, removeAllSegmentationListeners, } from './segmentationEventManager';\nconst helpers = {\n    clearSegmentValue,\n    convertStackToVolumeLabelmap,\n    computeVolumeLabelmapFromStack,\n    convertVolumeToStackLabelmap,\n};\nexport { removeSegmentationRepresentation, removeContourRepresentation, removeLabelmapRepresentation, removeSurfaceRepresentation, removeAllSegmentations, removeSegmentation, removeSegmentationRepresentations, addLabelmapRepresentationToViewport, addLabelmapRepresentationToViewportMap, addSegmentationRepresentations, removeAllSegmentationRepresentations, addContourRepresentationToViewport, addContourRepresentationToViewportMap, addSurfaceRepresentationToViewport, addSurfaceRepresentationToViewportMap, addSegmentations, updateSegmentations, addSegmentationListener, addDefaultSegmentationListener, removeSegmentationListener, removeAllSegmentationListeners, state, activeSegmentation, segmentLocking, config, segmentIndex, triggerSegmentationEvents, utilities, helpers, removeSegment, getLabelmapImageIds, addRepresentationData, strategies, segmentationStyle, defaultSegmentationStateManager, getCurrentLabelmapImageIdsForViewport, getLabelmapImageIdsForImageId, getActiveSegmentation, };\n","import { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationModified, triggerSegmentationDataModified, } from './triggerSegmentationEvents';\nimport { addColorLUT } from './addColorLUT';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { addDefaultSegmentationListener } from './segmentationEventManager';\nimport { getActiveSegmentIndex, setActiveSegmentIndex } from './segmentIndex';\nfunction internalAddSegmentationRepresentation(viewportId, representationInput) {\n    const { segmentationId, config } = representationInput;\n    const renderingConfig = {\n        colorLUTIndex: getColorLUTIndex(config),\n        ...config,\n    };\n    defaultSegmentationStateManager.addSegmentationRepresentation(viewportId, segmentationId, representationInput.type, renderingConfig);\n    const { viewport } = getEnabledElementByViewportId(viewportId) || {};\n    if (viewport) {\n        addDefaultSegmentationListener(viewport, segmentationId, representationInput.type);\n    }\n    if (!getActiveSegmentIndex(segmentationId)) {\n        let firstSegmentIndex = 1;\n        const segmentation = defaultSegmentationStateManager.getSegmentation(segmentationId);\n        if (segmentation) {\n            const segmentKeys = Object.keys(segmentation.segments);\n            if (segmentKeys.length > 0) {\n                firstSegmentIndex = segmentKeys.map((k) => Number(k)).sort()[0];\n            }\n            setActiveSegmentIndex(segmentationId, firstSegmentIndex);\n        }\n    }\n    if (representationInput.type === SegmentationRepresentations.Contour) {\n        triggerAnnotationRenderForViewportIds([viewportId]);\n    }\n    if (representationInput.type === SegmentationRepresentations.Surface) {\n        triggerSegmentationDataModified(segmentationId);\n    }\n    triggerSegmentationModified(segmentationId);\n}\nfunction getColorLUTIndex(config) {\n    const { colorLUTOrIndex } = config || {};\n    if (colorLUTOrIndex === undefined) {\n        const index = addColorLUT(JSON.parse(JSON.stringify(CORNERSTONE_COLOR_LUT)));\n        return index;\n    }\n    if (typeof colorLUTOrIndex === 'number') {\n        return colorLUTOrIndex;\n    }\n    if (Array.isArray(colorLUTOrIndex) &&\n        colorLUTOrIndex.every((item) => Array.isArray(item) && item.length === 4)) {\n        const index = addColorLUT(colorLUTOrIndex);\n        return index;\n    }\n    const index = addColorLUT(JSON.parse(JSON.stringify(CORNERSTONE_COLOR_LUT)));\n    return index;\n}\nexport { internalAddSegmentationRepresentation };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { triggerSegmentationRemoved } from './triggerSegmentationEvents';\nimport { removeSegmentationRepresentations } from './removeSegmentationRepresentations';\nexport function removeSegmentation(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const viewportsWithSegmentation = segmentationStateManager\n        .getAllViewportSegmentationRepresentations()\n        .filter(({ representations }) => representations.some((rep) => rep.segmentationId === segmentationId))\n        .map(({ viewportId }) => viewportId);\n    viewportsWithSegmentation.forEach((viewportId) => {\n        removeSegmentationRepresentations(viewportId, { segmentationId });\n    });\n    segmentationStateManager.removeSegmentation(segmentationId);\n    triggerSegmentationRemoved(segmentationId);\n}\nexport function removeAllSegmentations() {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const segmentations = segmentationStateManager.getState().segmentations;\n    const segmentationIds = segmentations.map((segmentation) => segmentation.segmentationId);\n    segmentationIds.forEach((segmentationId) => {\n        removeSegmentation(segmentationId);\n    });\n    segmentationStateManager.resetState();\n}\n","import SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport labelmapDisplay from '../../tools/displayTools/Labelmap/labelmapDisplay';\nimport contourDisplay from '../../tools/displayTools/Contour/contourDisplay';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nimport { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { surfaceDisplay } from '../../tools/displayTools/Surface';\nimport { removeSegmentationListener } from './segmentationEventManager';\nfunction removeSegmentationRepresentation(viewportId, specifier, immediate) {\n    return _removeSegmentationRepresentations(viewportId, specifier, immediate);\n}\nfunction removeSegmentationRepresentations(viewportId, specifier, immediate) {\n    return _removeSegmentationRepresentations(viewportId, specifier, immediate);\n}\nfunction _removeSegmentationRepresentations(viewportId, specifier, immediate) {\n    const { segmentationId, type } = specifier;\n    _removeRepresentationObject(viewportId, segmentationId, type, immediate);\n    return defaultSegmentationStateManager.removeSegmentationRepresentations(viewportId, {\n        segmentationId,\n        type,\n    });\n}\nfunction removeAllSegmentationRepresentations() {\n    const state = defaultSegmentationStateManager.getAllViewportSegmentationRepresentations();\n    state.forEach(({ viewportId, representations }) => {\n        representations.forEach(({ segmentationId, type }) => {\n            removeSegmentationRepresentation(viewportId, {\n                segmentationId,\n                type,\n            });\n        });\n    });\n    defaultSegmentationStateManager.resetState();\n}\nfunction removeLabelmapRepresentation(viewportId, segmentationId, immediate) {\n    removeSegmentationRepresentation(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Labelmap,\n    }, immediate);\n}\nfunction removeContourRepresentation(viewportId, segmentationId, immediate) {\n    removeSegmentationRepresentation(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n    }, immediate);\n}\nfunction removeSurfaceRepresentation(viewportId, segmentationId, immediate) {\n    removeSegmentationRepresentation(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Surface,\n    }, immediate);\n}\nfunction _removeRepresentationObject(viewportId, segmentationId, type, immediate) {\n    const representations = getSegmentationRepresentations(viewportId, {\n        segmentationId,\n        type,\n    });\n    representations.forEach((representation) => {\n        if (representation.type === SegmentationRepresentations.Labelmap) {\n            labelmapDisplay.removeRepresentation(viewportId, representation.segmentationId, immediate);\n        }\n        else if (representation.type === SegmentationRepresentations.Contour) {\n            contourDisplay.removeRepresentation(viewportId, representation.segmentationId, immediate);\n        }\n        else if (representation.type === SegmentationRepresentations.Surface) {\n            surfaceDisplay.removeRepresentation(viewportId, representation.segmentationId, immediate);\n        }\n        removeSegmentationListener(representation.segmentationId, representation.type);\n    });\n    const { viewport } = getEnabledElementByViewportId(viewportId) || {};\n    if (viewport) {\n        viewport.render();\n    }\n}\nexport { removeSegmentationRepresentation, removeSegmentationRepresentations, removeAllSegmentationRepresentations, removeLabelmapRepresentation, removeContourRepresentation, removeSurfaceRepresentation, };\n","import { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport { invalidateBrushCursor } from '../../utilities/segmentation/invalidateBrushCursor';\nimport { getSegmentation } from './getSegmentation';\nimport { getViewportIdsWithSegmentation } from './getViewportIdsWithSegmentation';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport { getActiveSegmentIndex } from './getActiveSegmentIndex';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nfunction setActiveSegmentIndex(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (typeof segmentIndex === 'string') {\n        console.warn('segmentIndex is a string, converting to number');\n        segmentIndex = Number(segmentIndex);\n    }\n    Object.values(segmentation.segments).forEach((segment) => {\n        segment.active = false;\n    });\n    if (!segmentation.segments[segmentIndex]) {\n        segmentation.segments[segmentIndex] = {\n            segmentIndex,\n            label: '',\n            locked: false,\n            cachedStats: {},\n            active: false,\n        };\n    }\n    if (segmentation.segments[segmentIndex].active !== true) {\n        segmentation.segments[segmentIndex].active = true;\n        triggerSegmentationModified(segmentationId);\n    }\n    const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n    viewportIds.forEach((viewportId) => {\n        const representations = getSegmentationRepresentations(viewportId, {\n            segmentationId,\n        });\n        representations.forEach((representation) => {\n            if (!representation.segments[segmentIndex]) {\n                representation.segments[segmentIndex] = {\n                    visible: true,\n                };\n            }\n        });\n    });\n    viewportIds.forEach((viewportId) => {\n        const toolGroup = getToolGroupForViewport(viewportId);\n        invalidateBrushCursor(toolGroup.id);\n    });\n}\nexport { setActiveSegmentIndex, getActiveSegmentIndex };\n","import { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { setAnnotationLocked } from '../annotation/annotationLocking';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport { getAnnotationsUIDMapFromSegmentation } from './utilities';\nfunction _setContourSegmentationSegmentAnnotationsLocked(segmentation, segmentIndex, locked) {\n    const annotationUIDsMap = getAnnotationsUIDMapFromSegmentation(segmentation.segmentationId);\n    if (!annotationUIDsMap) {\n        return;\n    }\n    const annotationUIDs = annotationUIDsMap.get(segmentIndex);\n    if (!annotationUIDs) {\n        return;\n    }\n    annotationUIDs.forEach((annotationUID) => {\n        setAnnotationLocked(annotationUID, locked);\n    });\n}\nfunction isSegmentIndexLocked(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    return segments[segmentIndex].locked;\n}\nfunction setSegmentIndexLocked(segmentationId, segmentIndex, locked = true) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    segments[segmentIndex].locked = locked;\n    if (segmentation?.representationData?.Contour) {\n        _setContourSegmentationSegmentAnnotationsLocked(segmentation, segmentIndex, locked);\n    }\n    triggerSegmentationModified(segmentationId);\n}\nfunction getLockedSegmentIndices(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    const lockedSegmentIndices = Object.keys(segments).filter((segmentIndex) => segments[segmentIndex].locked);\n    return lockedSegmentIndices.map((segmentIndex) => parseInt(segmentIndex));\n}\nexport { isSegmentIndexLocked, setSegmentIndexLocked, getLockedSegmentIndices };\n","import { eventTarget } from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport debounce from '../../utilities/debounce';\nimport surfaceDisplay from '../../tools/displayTools/Surface/surfaceDisplay';\nimport contourDisplay from '../../tools/displayTools/Contour/contourDisplay';\nimport labelmapDisplay from '../../tools/displayTools/Labelmap/labelmapDisplay';\nimport { getSegmentation } from './getSegmentation';\nconst renderers = {\n    [SegmentationRepresentations.Labelmap]: labelmapDisplay,\n    [SegmentationRepresentations.Contour]: contourDisplay,\n    [SegmentationRepresentations.Surface]: surfaceDisplay,\n};\nconst segmentationListeners = new Map();\nexport function addDefaultSegmentationListener(viewport, segmentationId, representationType) {\n    const updateFunction = renderers[representationType].getUpdateFunction(viewport);\n    if (updateFunction) {\n        addSegmentationListener(segmentationId, representationType, updateFunction);\n    }\n}\nfunction addSegmentationListener(segmentationId, representationType, updateFunction) {\n    if (!segmentationListeners.has(segmentationId)) {\n        segmentationListeners.set(segmentationId, new Map());\n    }\n    const listenerMap = segmentationListeners.get(segmentationId);\n    if (listenerMap.has(representationType)) {\n        removeSegmentationListener(segmentationId, representationType);\n    }\n    const listener = createDebouncedSegmentationListener(segmentationId, representationType, updateFunction);\n    eventTarget.addEventListener(Events.SEGMENTATION_DATA_MODIFIED, listener);\n    listenerMap.set(representationType, listener);\n}\nfunction removeSegmentationListener(segmentationId, representationType) {\n    const listenerMap = segmentationListeners.get(segmentationId);\n    if (!listenerMap) {\n        return;\n    }\n    const listener = listenerMap.get(representationType);\n    if (!listener) {\n        return;\n    }\n    eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, listener);\n    listenerMap.delete(representationType);\n}\nfunction removeAllSegmentationListeners(segmentationId) {\n    const listenerMap = segmentationListeners.get(segmentationId);\n    if (!listenerMap) {\n        return;\n    }\n    for (const listener of listenerMap.values()) {\n        eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, listener);\n    }\n    segmentationListeners.delete(segmentationId);\n}\nfunction createDebouncedSegmentationListener(segmentationId, representationType, updateFunction) {\n    const debouncedHandler = debounce((event) => {\n        const eventSegmentationId = event.detail?.segmentationId;\n        const segmentation = getSegmentation(eventSegmentationId);\n        if (eventSegmentationId === segmentationId &&\n            !!segmentation?.representationData?.[representationType]) {\n            updateFunction(segmentationId);\n            triggerSegmentationModified(segmentationId);\n        }\n    }, 300);\n    return ((event) => {\n        debouncedHandler(event);\n    });\n}\nexport { addSegmentationListener, removeSegmentationListener, removeAllSegmentationListeners, };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function removeColorLUT(colorLUTIndex) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationStateManager.removeColorLUT(colorLUTIndex);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getStackSegmentationImageIdsForViewport(viewportId, segmentationId);\n}\n","import { getSegmentation } from './getSegmentation';\nimport { getSegmentations } from './getSegmentations';\nimport { addSegmentations } from './addSegmentations';\nimport { removeAllSegmentations, removeSegmentation, } from './removeSegmentation';\nimport { removeLabelmapRepresentation, removeContourRepresentation, removeSurfaceRepresentation, removeSegmentationRepresentation, removeAllSegmentationRepresentations, } from './removeSegmentationRepresentations';\nimport { addColorLUT } from './addColorLUT';\nimport { getColorLUT } from './getColorLUT';\nimport { getNextColorLUTIndex } from './getNextColorLUTIndex';\nimport { removeColorLUT } from './removeColorLUT';\nimport { getViewportSegmentations, getViewportSegmentationRepresentations, } from './getViewportSegmentations';\nimport { getViewportIdsWithSegmentation } from './getViewportIdsWithSegmentation';\nimport { getCurrentLabelmapImageIdForViewport, getCurrentLabelmapImageIdsForViewport, } from './getCurrentLabelmapImageIdForViewport';\nimport { updateLabelmapSegmentationImageReferences } from './updateLabelmapSegmentationImageReferences';\nimport { getStackSegmentationImageIdsForViewport } from './getStackSegmentationImageIdsForViewport';\nimport { getSegmentationRepresentation, getSegmentationRepresentations, getSegmentationRepresentationsBySegmentationId, } from './getSegmentationRepresentation';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nfunction destroy() {\n    defaultSegmentationStateManager.resetState();\n}\nexport { getColorLUT, getCurrentLabelmapImageIdForViewport, getCurrentLabelmapImageIdsForViewport, getNextColorLUTIndex, getSegmentation, getSegmentations, getStackSegmentationImageIdsForViewport, getViewportIdsWithSegmentation, getSegmentationRepresentation, getSegmentationRepresentations, getViewportSegmentationRepresentations, removeColorLUT, getViewportSegmentations, removeSegmentation, removeLabelmapRepresentation, removeContourRepresentation, removeSurfaceRepresentation, removeSegmentationRepresentation, removeAllSegmentationRepresentations, removeAllSegmentations, addColorLUT, addSegmentations, updateLabelmapSegmentationImageReferences, getSegmentationRepresentationsBySegmentationId, destroy, };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.updateLabelmapSegmentationImageReferences(viewportId, segmentationId);\n}\n","import { findContourHoles } from '../../../utilities/contours';\nimport { getAnnotation, clearParentAnnotation, } from '../../annotation/annotationState';\nimport { getSegmentation } from '../getSegmentation';\nimport { extractSegmentPolylines } from './extractSegmentPolylines';\nexport default function convertContourHoles(segmentationId, segmentIndex, targetSegmentationId, targetSegmentationIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn(`Invalid segmentation given ${segmentationId}`);\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        console.warn(`No contour representation found for segmentation ${segmentationId}`);\n        return;\n    }\n    const { annotationUIDsMap } = segmentation?.representationData.Contour || {};\n    if (!annotationUIDsMap) {\n        console.warn(`No annotation map found for segmentation ${segmentationId}`);\n        return;\n    }\n    const annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\n    if (!annotationsUIDsSet) {\n        console.warn(`Segmentation index ${segmentIndex} has no annotations in segmentation ${segmentationId}`);\n        return;\n    }\n    let targetUIDsSet;\n    if (targetSegmentationId && typeof targetSegmentationIndex === 'number') {\n        const targetSegmentation = getSegmentation(targetSegmentationId);\n        if (!targetSegmentation) {\n            console.warn(`Target segmentation ${targetSegmentationId} does not exist.`);\n            return;\n        }\n        if (!targetSegmentation.representationData.Contour) {\n            console.warn(`No contour representation found for target segmentation ${targetSegmentationId}`);\n            return;\n        }\n        targetUIDsSet =\n            targetSegmentation.representationData.Contour.annotationUIDsMap.get(targetSegmentationIndex);\n        if (!targetUIDsSet) {\n            targetUIDsSet = new Set();\n            targetSegmentation.representationData.Contour.annotationUIDsMap.set(targetSegmentationIndex, targetUIDsSet);\n        }\n    }\n    const polylinesCanvasMap = extractSegmentPolylines(segmentationId, segmentIndex);\n    if (!polylinesCanvasMap) {\n        console.warn(`Error extracting contour data from segment ${segmentIndex} in segmentation ${segmentationId}`);\n        return;\n    }\n    const keys = Array.from(polylinesCanvasMap?.keys());\n    const polylines = keys.map((key) => polylinesCanvasMap.get(key));\n    const holeDetectionResults = findContourHoles(polylines);\n    if (holeDetectionResults?.length > 0) {\n        holeDetectionResults.forEach((hole) => {\n            hole.holeIndexes.forEach((index) => {\n                const annotation = getAnnotation(keys[index]);\n                clearParentAnnotation(annotation);\n                if (targetSegmentationId &&\n                    typeof targetSegmentationIndex === 'number') {\n                    targetUIDsSet.add(annotation.annotationUID);\n                }\n                else {\n                    annotationsUIDsSet.add(annotation.annotationUID);\n                }\n            });\n        });\n    }\n}\n","import { getAnnotation, invalidateAnnotation, } from '../../annotation/annotationState';\nimport { getSegmentation } from '../getSegmentation';\nimport { extractSegmentPolylines } from './extractSegmentPolylines';\nimport decimate from '../../../utilities/math/polyline/decimate';\nimport { getViewportsAssociatedToSegmentation, getViewportWithMatchingViewPlaneNormal, } from './getViewportAssociatedToSegmentation';\nexport default function decimateContours(segmentationId, segmentIndex, options = { epsilon: 0.1 }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn(`Invalid segmentation given ${segmentationId}`);\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        console.warn(`No contour representation found for segmentation ${segmentationId}`);\n        return;\n    }\n    const viewports = getViewportsAssociatedToSegmentation(segmentationId);\n    if (!viewports) {\n        console.warn('No viewport associated to the segmentation found');\n        return;\n    }\n    const polylinesCanvasMap = extractSegmentPolylines(segmentationId, segmentIndex);\n    if (!polylinesCanvasMap) {\n        console.warn(`Error extracting contour data from segment ${segmentIndex} in segmentation ${segmentationId}`);\n        return;\n    }\n    const keys = Array.from(polylinesCanvasMap?.keys());\n    for (const annotationUID of keys) {\n        const annotation = getAnnotation(annotationUID);\n        if (!annotation) {\n            continue;\n        }\n        const polylineCanvas = polylinesCanvasMap.get(annotationUID);\n        const decimatedPolyline2D = decimate(polylineCanvas, options.epsilon);\n        const viewport = getViewportWithMatchingViewPlaneNormal(viewports, annotation);\n        if (viewport) {\n            annotation.data.contour.polyline = decimatedPolyline2D.map((point2D) => viewport.canvasToWorld(point2D));\n            invalidateAnnotation(annotation);\n        }\n    }\n}\n","import { getAnnotationMapFromSegmentation, } from './getAnnotationMapFromSegmentation';\nfunction closePolyline(polyline, closed) {\n    if (!polyline || polyline.length === 0) {\n        return [];\n    }\n    if (!closed) {\n        return [...polyline];\n    }\n    const firstPoint = polyline[0];\n    const lastPoint = polyline[polyline.length - 1];\n    const isAlreadyClosed = firstPoint[0] === lastPoint[0] &&\n        firstPoint[1] === lastPoint[1] &&\n        firstPoint[2] === lastPoint[2];\n    if (isAlreadyClosed) {\n        return [...polyline];\n    }\n    return [...polyline, firstPoint];\n}\nexport function getPolylinesMap(contourRepresentationData, segmentIndex) {\n    const { annotationUIDsInSegmentMap } = getAnnotationMapFromSegmentation(contourRepresentationData);\n    if (!annotationUIDsInSegmentMap.has(segmentIndex)) {\n        console.warn(`No contour information found for segmentIndex ${segmentIndex}`);\n        return;\n    }\n    const polylines = new Map();\n    const annotationsInfo = annotationUIDsInSegmentMap.get(segmentIndex);\n    for (const annotationInfo of annotationsInfo) {\n        polylines.set(annotationInfo.annotationUID, closePolyline(annotationInfo.polyline, annotationInfo.isClosed));\n        for (let i = 0; i < annotationInfo.holesUIDs?.length; i++) {\n            polylines.set(annotationInfo.holesUIDs[i], closePolyline(annotationInfo.holesPolyline[i], annotationInfo.holesClosed[i]));\n        }\n    }\n    return polylines;\n}\n","import { getSegmentation } from '../getSegmentation';\nimport { convertContourPolylineToCanvasSpace } from '../../../utilities/contourSegmentation';\nimport { getViewportsAssociatedToSegmentation, getViewportWithMatchingViewPlaneNormal, } from './getViewportAssociatedToSegmentation';\nimport { getPolylinesMap } from './getPolylineMap';\nimport { getAnnotation } from '../../annotation/annotationState';\nexport function extractSegmentPolylines(segmentationId, segmentIndex) {\n    const viewports = getViewportsAssociatedToSegmentation(segmentationId);\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        return;\n    }\n    const contourRepresentationData = segmentation.representationData\n        .Contour;\n    const { annotationUIDsMap } = contourRepresentationData;\n    if (!annotationUIDsMap) {\n        return;\n    }\n    if (!annotationUIDsMap.get(segmentIndex)) {\n        return;\n    }\n    const polyLinesMap = getPolylinesMap(contourRepresentationData, segmentIndex);\n    if (!polyLinesMap) {\n        return;\n    }\n    const keys = Array.from(polyLinesMap?.keys());\n    const polylinesCanvasMap = new Map();\n    for (const key of keys) {\n        const annotation = getAnnotation(key);\n        const viewport = getViewportWithMatchingViewPlaneNormal(viewports, annotation);\n        polylinesCanvasMap.set(key, convertContourPolylineToCanvasSpace(polyLinesMap.get(key), viewport));\n    }\n    return polylinesCanvasMap;\n}\n","import { getAnnotation } from '../../annotation/annotationState';\nexport function getAnnotationMapFromSegmentation(contourRepresentationData, options = {}) {\n    const annotationMap = contourRepresentationData.annotationUIDsMap;\n    const segmentIndices = options.segmentIndices?.length\n        ? options.segmentIndices\n        : Array.from(annotationMap.keys());\n    const annotationUIDsInSegmentMap = new Map();\n    segmentIndices.forEach((index) => {\n        const annotationUIDsInSegment = annotationMap.get(index);\n        let uids = Array.from(annotationUIDsInSegment);\n        uids = uids.filter((uid) => !getAnnotation(uid).parentAnnotationUID);\n        const annotations = uids.map((uid) => {\n            const annotation = getAnnotation(uid);\n            const hasChildAnnotations = annotation.childAnnotationUIDs?.length;\n            const childPolylinesInformation = hasChildAnnotations &&\n                annotation.childAnnotationUIDs.map((childUID) => {\n                    const childAnnotation = getAnnotation(childUID);\n                    return {\n                        polyline: childAnnotation.data.contour.polyline,\n                        isClosed: childAnnotation.data.contour.closed,\n                    };\n                });\n            const holesClosed = hasChildAnnotations &&\n                childPolylinesInformation.map((childInfo) => childInfo.isClosed);\n            const childPolylines = hasChildAnnotations &&\n                childPolylinesInformation.map((childInfo) => childInfo.polyline);\n            return {\n                polyline: annotation.data.contour.polyline,\n                isClosed: annotation.data.contour.closed,\n                annotationUID: annotation.annotationUID,\n                referencedImageId: annotation.metadata.referencedImageId,\n                holesPolyline: childPolylines,\n                holesUIDs: annotation.childAnnotationUIDs,\n                holesClosed,\n            };\n        });\n        annotationUIDsInSegmentMap.set(index, annotations);\n    });\n    return { segmentIndices, annotationUIDsInSegmentMap };\n}\n","import { getSegmentation } from '../getSegmentation';\nexport function getAnnotationsUIDMapFromSegmentation(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    const contourRepresentationData = segmentation.representationData\n        ?.Contour;\n    if (!contourRepresentationData) {\n        return;\n    }\n    const { annotationUIDsMap } = contourRepresentationData;\n    if (!annotationUIDsMap) {\n        return;\n    }\n    return annotationUIDsMap;\n}\n","import { vec3 } from 'gl-matrix';\nimport { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport { getViewportIdsWithSegmentation } from '../getViewportIdsWithSegmentation';\nexport function getViewportsAssociatedToSegmentation(segmentationId) {\n    const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n    if (viewportIds?.length === 0) {\n        return [];\n    }\n    const viewports = [];\n    for (const viewportId of viewportIds) {\n        const { viewport } = getEnabledElementByViewportId(viewportId) || {};\n        if (viewport) {\n            viewports.push(viewport);\n        }\n    }\n    return viewports;\n}\nexport function getViewportAssociatedToSegmentation(segmentationId) {\n    const viewports = getViewportsAssociatedToSegmentation(segmentationId);\n    return viewports.length > 0 ? viewports[0] : undefined;\n}\nexport function getViewportWithMatchingViewPlaneNormal(viewports, annotation, dotThreshold = 0.99) {\n    const annotationViewPlaneNormal = annotation.metadata?.viewPlaneNormal;\n    if (!annotationViewPlaneNormal || !Array.isArray(annotationViewPlaneNormal)) {\n        return undefined;\n    }\n    const normalizedAnnotationNormal = vec3.create();\n    vec3.normalize(normalizedAnnotationNormal, annotationViewPlaneNormal);\n    for (const viewport of viewports) {\n        const camera = viewport.getCamera();\n        if (!camera?.viewPlaneNormal) {\n            continue;\n        }\n        const normalizedCameraNormal = vec3.create();\n        vec3.normalize(normalizedCameraNormal, camera.viewPlaneNormal);\n        const dotProduct = vec3.dot(normalizedAnnotationNormal, normalizedCameraNormal);\n        if (Math.abs(dotProduct) >= dotThreshold) {\n            return viewport;\n        }\n    }\n    return undefined;\n}\n","import { removeContourSegmentationAnnotation } from '../../../utilities/contourSegmentation';\nimport { clearParentAnnotation, removeAnnotation, } from '../../annotation/annotationState';\nexport function removeCompleteContourAnnotation(annotation) {\n    if (!annotation) {\n        return;\n    }\n    if (annotation.parentAnnotationUID) {\n        clearParentAnnotation(annotation);\n    }\n    removeAnnotation(annotation.annotationUID);\n    removeContourSegmentationAnnotation(annotation);\n}\n","import { findContourHoles } from '../../../utilities/contours';\nimport { getAnnotation } from '../../annotation/annotationState';\nimport { getSegmentation } from '../getSegmentation';\nimport { extractSegmentPolylines } from './extractSegmentPolylines';\nimport { removeCompleteContourAnnotation } from './removeCompleteContourAnnotation';\nexport default function removeContourHoles(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn(`Invalid segmentation given ${segmentationId}`);\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        console.warn(`No contour representation found for segmentation ${segmentationId}`);\n        return;\n    }\n    const polylinesCanvasMap = extractSegmentPolylines(segmentationId, segmentIndex);\n    if (!polylinesCanvasMap) {\n        console.warn(`Error extracting contour data from segment ${segmentIndex} in segmentation ${segmentationId}`);\n        return;\n    }\n    const keys = Array.from(polylinesCanvasMap?.keys());\n    const polylines = keys.map((key) => polylinesCanvasMap.get(key));\n    const holeDetectionResults = findContourHoles(polylines);\n    if (holeDetectionResults?.length > 0) {\n        holeDetectionResults.forEach((hole) => {\n            hole.holeIndexes.forEach((index) => {\n                const annotation = getAnnotation(keys[index]);\n                removeCompleteContourAnnotation(annotation);\n            });\n        });\n    }\n}\n","import { getAnnotation } from '../../annotation/annotationState';\nimport { getSegmentation } from '../getSegmentation';\nimport { extractSegmentPolylines } from './extractSegmentPolylines';\nimport findIslands from '../../../utilities/contours/findIslands';\nimport { removeCompleteContourAnnotation } from './removeCompleteContourAnnotation';\nexport default function removeContourIslands(segmentationId, segmentIndex, options = { threshold: 3 }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn(`Invalid segmentation given ${segmentationId}`);\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        console.warn(`No contour representation found for segmentation ${segmentationId}`);\n        return;\n    }\n    const polylinesCanvasMap = extractSegmentPolylines(segmentationId, segmentIndex);\n    if (!polylinesCanvasMap) {\n        console.warn(`Error extracting contour data from segment ${segmentIndex} in segmentation ${segmentationId}`);\n        return;\n    }\n    const keys = Array.from(polylinesCanvasMap?.keys());\n    const polylines = keys.map((key) => polylinesCanvasMap.get(key));\n    const islands = findIslands(polylines, options.threshold);\n    if (islands?.length > 0) {\n        islands.forEach((index) => {\n            const annotation = getAnnotation(keys[index]);\n            removeCompleteContourAnnotation(annotation);\n        });\n    }\n}\n","import { getAnnotation } from '../../annotation/annotationState';\nimport { getSegmentation } from '../getSegmentation';\nimport interpolateSegmentPoints from '../../../utilities/planarFreehandROITool/interpolation/interpolateSegmentPoints';\nexport default function smoothContours(segmentationId, segmentIndex, options = { knotsRatioPercentage: 30 }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn(`Invalid segmentation given ${segmentationId}`);\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        console.warn(`No contour representation found for segmentation ${segmentationId}`);\n        return;\n    }\n    const contourRepresentationData = segmentation.representationData\n        .Contour;\n    const { annotationUIDsMap } = contourRepresentationData;\n    if (!annotationUIDsMap) {\n        console.warn(`No contours found for segmentation ${segmentationId}`);\n        return;\n    }\n    if (!annotationUIDsMap.has(segmentIndex)) {\n        console.warn(`Error extracting contour data from segment ${segmentIndex} in segmentation ${segmentationId}`);\n        return;\n    }\n    const annotationList = annotationUIDsMap.get(segmentIndex);\n    annotationList.forEach((annotationUID) => {\n        const annotation = getAnnotation(annotationUID);\n        if (!annotation) {\n            return;\n        }\n        const polyline = annotation.data.contour.polyline;\n        if (!polyline || polyline.length < 3) {\n            return;\n        }\n        const smoothedPolyline = interpolateSegmentPoints(polyline, 0, polyline.length - 1, options.knotsRatioPercentage);\n        annotation.data.contour.polyline = smoothedPolyline;\n    });\n}\n","import { getRenderingEngine, getEnabledElement, eventTarget, Enums, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nclass Synchronizer {\n    constructor(synchronizerId, eventName, eventHandler, options) {\n        this._viewportOptions = {};\n        this._onEvent = (evt) => {\n            if (this._ignoreFiredEvents === true) {\n                return;\n            }\n            if (!this._targetViewports.length) {\n                return;\n            }\n            const enabledElement = this._eventSource === 'element'\n                ? getEnabledElement(evt.currentTarget)\n                : getEnabledElementByViewportId(evt.detail?.viewportId);\n            if (!enabledElement) {\n                return;\n            }\n            const { renderingEngineId, viewportId } = enabledElement;\n            if (!this._sourceViewports.find((s) => s.viewportId === viewportId)) {\n                return;\n            }\n            this.fireEvent({\n                renderingEngineId,\n                viewportId,\n            }, evt);\n        };\n        this._enabled = true;\n        this._eventName = eventName;\n        this._eventHandler = eventHandler;\n        this._ignoreFiredEvents = false;\n        this._sourceViewports = [];\n        this._targetViewports = [];\n        this._options = options || {};\n        this._eventSource = this._options.eventSource || 'element';\n        this._auxiliaryEvents = this._options.auxiliaryEvents || [];\n        this.id = synchronizerId;\n    }\n    isDisabled() {\n        return !this._enabled || !this._hasSourceElements();\n    }\n    setOptions(viewportId, options = {}) {\n        this._viewportOptions[viewportId] = options;\n    }\n    setEnabled(enabled) {\n        this._enabled = enabled;\n    }\n    getOptions(viewportId) {\n        return this._viewportOptions[viewportId];\n    }\n    add(viewportInfo) {\n        this.addTarget(viewportInfo);\n        this.addSource(viewportInfo);\n    }\n    addSource(viewportInfo) {\n        if (_containsViewport(this._sourceViewports, viewportInfo)) {\n            return;\n        }\n        const { renderingEngineId, viewportId } = viewportInfo;\n        const viewport = getRenderingEngine(renderingEngineId).getViewport(viewportId);\n        if (!viewport) {\n            console.warn(`Synchronizer.addSource: No viewport for ${renderingEngineId} ${viewportId}`);\n            return;\n        }\n        const eventSource = this._eventSource === 'element' ? viewport.element : eventTarget;\n        eventSource.addEventListener(this._eventName, this._onEvent.bind(this));\n        this._auxiliaryEvents.forEach(({ name, source }) => {\n            const target = source === 'element' ? viewport.element : eventTarget;\n            target.addEventListener(name, this._onEvent.bind(this));\n        });\n        this._updateDisableHandlers();\n        this._sourceViewports.push(viewportInfo);\n    }\n    addTarget(viewportInfo) {\n        if (_containsViewport(this._targetViewports, viewportInfo)) {\n            return;\n        }\n        this._targetViewports.push(viewportInfo);\n        this._updateDisableHandlers();\n    }\n    getSourceViewports() {\n        return this._sourceViewports;\n    }\n    getTargetViewports() {\n        return this._targetViewports;\n    }\n    destroy() {\n        this._sourceViewports.forEach((s) => this.removeSource(s));\n        this._targetViewports.forEach((t) => this.removeTarget(t));\n    }\n    remove(viewportInfo) {\n        this.removeTarget(viewportInfo);\n        this.removeSource(viewportInfo);\n    }\n    removeSource(viewportInfo) {\n        const index = _getViewportIndex(this._sourceViewports, viewportInfo);\n        if (index === -1) {\n            return;\n        }\n        const eventSource = this._eventSource === 'element'\n            ? this.getViewportElement(viewportInfo)\n            : eventTarget;\n        this._sourceViewports.splice(index, 1);\n        eventSource.removeEventListener(this._eventName, this._eventHandler);\n        this._auxiliaryEvents.forEach(({ name, source }) => {\n            const target = source === 'element'\n                ? this.getViewportElement(viewportInfo)\n                : eventTarget;\n            target.removeEventListener(name, this._eventHandler);\n        });\n        this._updateDisableHandlers();\n    }\n    removeTarget(viewportInfo) {\n        const index = _getViewportIndex(this._targetViewports, viewportInfo);\n        if (index === -1) {\n            return;\n        }\n        this._targetViewports.splice(index, 1);\n        this._updateDisableHandlers();\n    }\n    hasSourceViewport(renderingEngineId, viewportId) {\n        return _containsViewport(this._sourceViewports, {\n            renderingEngineId,\n            viewportId,\n        });\n    }\n    hasTargetViewport(renderingEngineId, viewportId) {\n        return _containsViewport(this._targetViewports, {\n            renderingEngineId,\n            viewportId,\n        });\n    }\n    fireEvent(sourceViewport, sourceEvent) {\n        if (this.isDisabled() || this._ignoreFiredEvents) {\n            return;\n        }\n        this._ignoreFiredEvents = true;\n        const promises = [];\n        try {\n            for (let i = 0; i < this._targetViewports.length; i++) {\n                const targetViewport = this._targetViewports[i];\n                const targetIsSource = sourceViewport.viewportId === targetViewport.viewportId;\n                if (targetIsSource) {\n                    continue;\n                }\n                const result = this._eventHandler(this, sourceViewport, targetViewport, sourceEvent, this._options);\n                if (result instanceof Promise) {\n                    promises.push(result);\n                }\n            }\n        }\n        catch (ex) {\n            console.warn(`Synchronizer, for: ${this._eventName}`, ex);\n        }\n        finally {\n            if (promises.length) {\n                Promise.allSettled(promises).then(() => {\n                    this._ignoreFiredEvents = false;\n                });\n            }\n            else {\n                this._ignoreFiredEvents = false;\n            }\n        }\n    }\n    _hasSourceElements() {\n        return this._sourceViewports.length !== 0;\n    }\n    _updateDisableHandlers() {\n        const viewports = _getUniqueViewports(this._sourceViewports, this._targetViewports);\n        const _remove = this.remove.bind(this);\n        const disableHandler = (elementDisabledEvent) => {\n            _remove(elementDisabledEvent.detail.element);\n        };\n        viewports.forEach((vp) => {\n            const eventSource = this.getEventSource(vp);\n            if (!eventSource) {\n                return;\n            }\n            eventSource.removeEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);\n            eventSource.addEventListener(Enums.Events.ELEMENT_DISABLED, disableHandler);\n        });\n    }\n    getEventSource(viewportInfo) {\n        return this._eventSource === 'element'\n            ? this.getViewportElement(viewportInfo)\n            : eventTarget;\n    }\n    getViewportElement(viewportInfo) {\n        const { renderingEngineId, viewportId } = viewportInfo;\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n        if (!renderingEngine) {\n            return null;\n        }\n        const viewport = renderingEngine.getViewport(viewportId);\n        if (!viewport) {\n            return null;\n        }\n        return viewport.element;\n    }\n}\nfunction _getUniqueViewports(vp1, vp2) {\n    const unique = [];\n    const vps = vp1.concat(vp2);\n    for (let i = 0; i < vps.length; i++) {\n        const vp = vps[i];\n        if (!unique.some((u) => vp.renderingEngineId === u.renderingEngineId &&\n            vp.viewportId === u.viewportId)) {\n            unique.push(vp);\n        }\n    }\n    return unique;\n}\nfunction _getViewportIndex(arr, vp) {\n    return arr.findIndex((ar) => vp.renderingEngineId === ar.renderingEngineId &&\n        vp.viewportId === ar.viewportId);\n}\nfunction _containsViewport(arr, vp) {\n    return arr.some((ar) => ar.renderingEngineId === vp.renderingEngineId &&\n        ar.viewportId === vp.viewportId);\n}\nexport default Synchronizer;\n","import { state } from '../state';\nimport Synchronizer, {} from './Synchronizer';\nfunction createSynchronizer(synchronizerId, eventName, eventHandler, options) {\n    const synchronizerWithSameIdExists = state.synchronizers.some((sync) => sync.id === synchronizerId);\n    if (synchronizerWithSameIdExists) {\n        throw new Error(`Synchronizer with id '${synchronizerId}' already exists.`);\n    }\n    const synchronizer = new Synchronizer(synchronizerId, eventName, eventHandler, options);\n    state.synchronizers.push(synchronizer);\n    return synchronizer;\n}\nexport default createSynchronizer;\n","import { state } from '../state';\nfunction destroy() {\n    while (state.synchronizers.length > 0) {\n        const synchronizer = state.synchronizers.pop();\n        synchronizer.destroy();\n    }\n}\nexport default destroy;\n","import { state } from '../state';\nfunction destroySynchronizer(synchronizerId) {\n    const synchronizerIndex = state.synchronizers.findIndex((sync) => sync.id === synchronizerId);\n    if (synchronizerIndex > -1) {\n        const synchronizer = state.synchronizers[synchronizerIndex];\n        synchronizer.destroy();\n        state.synchronizers.splice(synchronizerIndex, 1);\n    }\n}\nexport default destroySynchronizer;\n","import { state } from '../state';\nfunction getAllSynchronizers() {\n    return state.synchronizers;\n}\nexport default getAllSynchronizers;\n","import { state } from '../state';\nfunction getSynchronizer(synchronizerId) {\n    return state.synchronizers.find((s) => s.id === synchronizerId);\n}\nexport default getSynchronizer;\n","import { state } from '../state';\nfunction getSynchronizersForViewport(viewportId, renderingEngineId) {\n    const synchronizersFilteredByIds = [];\n    if (!renderingEngineId && !viewportId) {\n        throw new Error('At least one of renderingEngineId or viewportId should be given');\n    }\n    for (let i = 0; i < state.synchronizers.length; i++) {\n        const synchronizer = state.synchronizers[i];\n        const notDisabled = !synchronizer.isDisabled();\n        const hasSourceViewport = synchronizer.hasSourceViewport(renderingEngineId, viewportId);\n        const hasTargetViewport = synchronizer.hasTargetViewport(renderingEngineId, viewportId);\n        if (notDisabled && (hasSourceViewport || hasTargetViewport)) {\n            synchronizersFilteredByIds.push(synchronizer);\n        }\n    }\n    return synchronizersFilteredByIds;\n}\nexport default getSynchronizersForViewport;\n","import { state } from '../state';\nfunction getToolGroup(toolGroupId) {\n    return state.toolGroups.find((s) => s.id === toolGroupId);\n}\nexport default getToolGroup;\n","import { MouseBindings, ToolModes, Events } from '../../enums';\nimport get from 'lodash.get';\nimport { triggerEvent, eventTarget, getRenderingEngine, getRenderingEngines, getEnabledElementByIds, Settings, } from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/core';\nimport { state } from '../state';\nimport { MouseCursor, SVGMouseCursor } from '../../cursors';\nimport { initElementCursor } from '../../cursors/elementCursor';\nimport getToolGroup from './getToolGroup';\nconst { Active, Passive, Enabled, Disabled } = ToolModes;\nconst PRIMARY_BINDINGS = [{ mouseButton: MouseBindings.Primary }];\nexport default class ToolGroup {\n    constructor(id) {\n        this.viewportsInfo = [];\n        this.toolOptions = {};\n        this.currentActivePrimaryToolName = null;\n        this.prevActivePrimaryToolName = null;\n        this.restoreToolOptions = {};\n        this._toolInstances = {};\n        this.id = id;\n    }\n    getViewportIds() {\n        return this.viewportsInfo.map(({ viewportId }) => viewportId);\n    }\n    getViewportsInfo() {\n        return this.viewportsInfo.slice();\n    }\n    getToolInstance(toolInstanceName) {\n        const toolInstance = this._toolInstances[toolInstanceName];\n        if (!toolInstance) {\n            console.warn(`'${toolInstanceName}' is not registered with this toolGroup (${this.id}).`);\n            return;\n        }\n        return toolInstance;\n    }\n    getToolInstances() {\n        return this._toolInstances;\n    }\n    hasTool(toolName) {\n        return !!this._toolInstances[toolName];\n    }\n    addTool(toolName, configuration = {}) {\n        const toolDefinition = state.tools[toolName];\n        const hasToolName = typeof toolName !== 'undefined' && toolName !== '';\n        const localToolInstance = this.toolOptions[toolName];\n        if (!hasToolName) {\n            console.warn('Tool with configuration did not produce a toolName: ', configuration);\n            return;\n        }\n        if (!toolDefinition) {\n            console.warn(`'${toolName}' is not registered with the library. You need to use cornerstoneTools.addTool to register it.`);\n            return;\n        }\n        if (localToolInstance) {\n            console.warn(`'${toolName}' is already registered for ToolGroup ${this.id}.`);\n            return;\n        }\n        const { toolClass: ToolClass } = toolDefinition;\n        const toolProps = {\n            name: toolName,\n            toolGroupId: this.id,\n            configuration,\n        };\n        const instantiatedTool = new ToolClass(toolProps);\n        this._toolInstances[toolName] = instantiatedTool;\n    }\n    addToolInstance(toolName, parentClassName, configuration = {}) {\n        let ToolClassToUse = state.tools[toolName]\n            ?.toolClass;\n        if (!ToolClassToUse) {\n            const ParentClass = state.tools[parentClassName]\n                .toolClass;\n            class ToolInstance extends ParentClass {\n            }\n            ToolInstance.toolName = toolName;\n            ToolClassToUse = ToolInstance;\n            state.tools[toolName] = {\n                toolClass: ToolInstance,\n            };\n        }\n        this.addTool(ToolClassToUse.toolName, configuration);\n    }\n    addViewport(viewportId, renderingEngineId) {\n        if (typeof viewportId !== 'string') {\n            throw new Error('viewportId must be defined and be a string');\n        }\n        const renderingEngineUIDToUse = this._findRenderingEngine(viewportId, renderingEngineId);\n        if (!this.viewportsInfo.some(({ viewportId: vpId }) => vpId === viewportId)) {\n            this.viewportsInfo.push({\n                viewportId,\n                renderingEngineId: renderingEngineUIDToUse,\n            });\n        }\n        const toolName = this.getActivePrimaryMouseButtonTool();\n        this.setViewportsCursorByToolName(toolName);\n        const eventDetail = {\n            toolGroupId: this.id,\n            viewportId,\n            renderingEngineId: renderingEngineUIDToUse,\n        };\n        triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_ADDED, eventDetail);\n    }\n    removeViewports(renderingEngineId, viewportId) {\n        const indices = [];\n        this.viewportsInfo.forEach((vpInfo, index) => {\n            let match = false;\n            if (vpInfo.renderingEngineId === renderingEngineId) {\n                match = true;\n                if (viewportId && vpInfo.viewportId !== viewportId) {\n                    match = false;\n                }\n            }\n            if (match) {\n                indices.push(index);\n            }\n        });\n        if (indices.length) {\n            for (let i = indices.length - 1; i >= 0; i--) {\n                this.viewportsInfo.splice(indices[i], 1);\n            }\n        }\n        const eventDetail = {\n            toolGroupId: this.id,\n            viewportId,\n            renderingEngineId,\n        };\n        triggerEvent(eventTarget, Events.TOOLGROUP_VIEWPORT_REMOVED, eventDetail);\n    }\n    setActiveStrategy(toolName, strategyName) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool configuration.`);\n            return;\n        }\n        toolInstance.setActiveStrategy(strategyName);\n    }\n    setToolMode(toolName, mode, options = {}) {\n        if (!toolName) {\n            console.warn('setToolMode: toolName must be defined');\n            return;\n        }\n        if (mode === ToolModes.Active) {\n            this.setToolActive(toolName, options || this.restoreToolOptions[toolName]);\n            return;\n        }\n        if (mode === ToolModes.Passive) {\n            this.setToolPassive(toolName);\n            return;\n        }\n        if (mode === ToolModes.Enabled) {\n            this.setToolEnabled(toolName);\n            return;\n        }\n        if (mode === ToolModes.Disabled) {\n            this.setToolDisabled(toolName);\n            return;\n        }\n        console.warn('setToolMode: mode must be defined');\n    }\n    setToolActive(toolName, toolBindingsOptions = {}) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        if (!toolInstance) {\n            console.warn(`'${toolName}' instance ${toolInstance} is not registered with this toolGroup, can't set tool mode.`);\n            return;\n        }\n        const prevBindings = this.toolOptions[toolName]\n            ? this.toolOptions[toolName].bindings\n            : [];\n        const newBindings = toolBindingsOptions.bindings\n            ? toolBindingsOptions.bindings\n            : [];\n        const bindingsToUse = [...prevBindings, ...newBindings].reduce((unique, binding) => {\n            const TouchBinding = binding.numTouchPoints !== undefined;\n            const MouseBinding = binding.mouseButton !== undefined;\n            if (!unique.some((obj) => hasSameBinding(obj, binding)) &&\n                (TouchBinding || MouseBinding)) {\n                unique.push(binding);\n            }\n            return unique;\n        }, []);\n        const toolOptions = {\n            bindings: bindingsToUse,\n            mode: Active,\n        };\n        this.toolOptions[toolName] = toolOptions;\n        this._toolInstances[toolName].mode = Active;\n        if (!this._hasMousePrimaryButtonBinding(toolBindingsOptions)) {\n            const activeToolIdentifier = this.getActivePrimaryMouseButtonTool();\n            if (!activeToolIdentifier) {\n                const cursor = MouseCursor.getDefinedCursor('default');\n                this._setCursorForViewports(cursor);\n            }\n        }\n        else {\n            this.setViewportsCursorByToolName(toolName);\n        }\n        if (this._hasMousePrimaryButtonBinding(toolBindingsOptions)) {\n            if (this.prevActivePrimaryToolName === null) {\n                this.prevActivePrimaryToolName = toolName;\n            }\n            else {\n                this.prevActivePrimaryToolName = this.currentActivePrimaryToolName;\n            }\n            this.currentActivePrimaryToolName = toolName;\n        }\n        if (typeof toolInstance.onSetToolActive === 'function') {\n            toolInstance.onSetToolActive();\n        }\n        this._renderViewports();\n        const eventDetail = {\n            toolGroupId: this.id,\n            toolName,\n            toolBindingsOptions,\n        };\n        triggerEvent(eventTarget, Events.TOOL_ACTIVATED, eventDetail);\n        this._triggerToolModeChangedEvent(toolName, Active, toolBindingsOptions);\n    }\n    setToolPassive(toolName, options) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        const prevToolOptions = this.getToolOptions(toolName);\n        const toolOptions = Object.assign({\n            bindings: prevToolOptions ? prevToolOptions.bindings : [],\n        }, prevToolOptions, {\n            mode: Passive,\n        });\n        const matchBindings = Array.isArray(options?.removeAllBindings)\n            ? options.removeAllBindings\n            : this.getDefaultPrimaryBindings();\n        toolOptions.bindings = toolOptions.bindings.filter((binding) => options?.removeAllBindings !== true &&\n            !matchBindings.some((matchBinding) => hasSameBinding(binding, matchBinding)));\n        let mode = Passive;\n        if (toolOptions.bindings.length !== 0) {\n            mode = Active;\n            toolOptions.mode = mode;\n        }\n        this.toolOptions[toolName] = toolOptions;\n        toolInstance.mode = mode;\n        if (typeof toolInstance.onSetToolPassive === 'function') {\n            toolInstance.onSetToolPassive();\n        }\n        this._renderViewports();\n        this._triggerToolModeChangedEvent(toolName, Passive);\n    }\n    setToolEnabled(toolName) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        const toolOptions = {\n            bindings: [],\n            mode: Enabled,\n        };\n        this.toolOptions[toolName] = toolOptions;\n        toolInstance.mode = Enabled;\n        if (typeof toolInstance.onSetToolEnabled === 'function') {\n            toolInstance.onSetToolEnabled();\n        }\n        this._renderViewports();\n        this._triggerToolModeChangedEvent(toolName, Enabled);\n    }\n    setToolDisabled(toolName) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not added to toolGroup, can't set tool mode.`);\n            return;\n        }\n        const toolOptions = {\n            bindings: [],\n            mode: Disabled,\n        };\n        this.restoreToolOptions[toolName] = this.toolOptions[toolName];\n        this.toolOptions[toolName] = toolOptions;\n        toolInstance.mode = Disabled;\n        if (typeof toolInstance.onSetToolDisabled === 'function') {\n            toolInstance.onSetToolDisabled();\n        }\n        this._renderViewports();\n        this._triggerToolModeChangedEvent(toolName, Disabled);\n    }\n    getToolOptions(toolName) {\n        const toolOptionsForTool = this.toolOptions[toolName];\n        if (toolOptionsForTool === undefined) {\n            return;\n        }\n        return toolOptionsForTool;\n    }\n    getActivePrimaryMouseButtonTool() {\n        return Object.keys(this.toolOptions).find((toolName) => {\n            const toolOptions = this.toolOptions[toolName];\n            return (toolOptions.mode === Active &&\n                this._hasMousePrimaryButtonBinding(toolOptions));\n        });\n    }\n    setViewportsCursorByToolName(toolName, strategyName) {\n        const cursor = this._getCursor(toolName, strategyName);\n        this._setCursorForViewports(cursor);\n    }\n    _getCursor(toolName, strategyName) {\n        let cursorName;\n        let cursor;\n        if (strategyName) {\n            cursorName = `${toolName}.${strategyName}`;\n            cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n            if (cursor) {\n                return cursor;\n            }\n        }\n        cursorName = `${toolName}`;\n        cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n        if (cursor) {\n            return cursor;\n        }\n        cursorName = toolName;\n        cursor = SVGMouseCursor.getDefinedCursor(cursorName, true);\n        if (cursor) {\n            return cursor;\n        }\n        return MouseCursor.getDefinedCursor('default');\n    }\n    _setCursorForViewports(cursor) {\n        const runtimeSettings = Settings.getRuntimeSettings();\n        if (!runtimeSettings.get('useCursors')) {\n            return;\n        }\n        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            initElementCursor(viewport.element, cursor);\n        });\n    }\n    setToolConfiguration(toolName, configuration, overwrite) {\n        const toolInstance = this._toolInstances[toolName];\n        if (toolInstance === undefined) {\n            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);\n            return false;\n        }\n        let _configuration;\n        if (overwrite) {\n            _configuration = configuration;\n        }\n        else {\n            _configuration = Object.assign(toolInstance.configuration, configuration);\n        }\n        toolInstance.configuration = _configuration;\n        if (typeof toolInstance.onSetToolConfiguration === 'function') {\n            toolInstance.onSetToolConfiguration();\n        }\n        this._renderViewports();\n        return true;\n    }\n    getDefaultMousePrimary() {\n        return MouseBindings.Primary;\n    }\n    getDefaultPrimaryBindings() {\n        return PRIMARY_BINDINGS;\n    }\n    getToolConfiguration(toolName, configurationPath) {\n        if (this._toolInstances[toolName] === undefined) {\n            console.warn(`Tool ${toolName} not present, can't set tool configuration.`);\n            return;\n        }\n        const _configuration = get(this._toolInstances[toolName].configuration, configurationPath) ||\n            this._toolInstances[toolName].configuration;\n        return utilities.deepClone(_configuration);\n    }\n    getPrevActivePrimaryToolName() {\n        return this.prevActivePrimaryToolName;\n    }\n    setActivePrimaryTool(toolName) {\n        const activeToolName = this.getCurrentActivePrimaryToolName();\n        this.setToolDisabled(activeToolName);\n        this.setToolActive(toolName, {\n            bindings: [{ mouseButton: MouseBindings.Primary }],\n        });\n    }\n    getCurrentActivePrimaryToolName() {\n        return this.currentActivePrimaryToolName;\n    }\n    clone(newToolGroupId, fnToolFilter = null) {\n        let toolGroup = getToolGroup(newToolGroupId);\n        if (toolGroup) {\n            console.debug(`ToolGroup ${newToolGroupId} already exists`);\n            return toolGroup;\n        }\n        toolGroup = new ToolGroup(newToolGroupId);\n        state.toolGroups.push(toolGroup);\n        fnToolFilter = fnToolFilter ?? (() => true);\n        Object.keys(this._toolInstances)\n            .filter(fnToolFilter)\n            .forEach((toolName) => {\n            const sourceToolInstance = this._toolInstances[toolName];\n            const sourceToolOptions = this.toolOptions[toolName];\n            const sourceToolMode = sourceToolInstance.mode;\n            toolGroup.addTool(toolName);\n            toolGroup.setToolMode(toolName, sourceToolMode, {\n                bindings: sourceToolOptions.bindings ?? [],\n            });\n        });\n        return toolGroup;\n    }\n    _hasMousePrimaryButtonBinding(toolOptions) {\n        const primaryBindings = this.getDefaultPrimaryBindings();\n        return toolOptions?.bindings?.some((binding) => primaryBindings.some((primary) => hasSameBinding(binding, primary)));\n    }\n    _renderViewports() {\n        this.viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            getRenderingEngine(renderingEngineId).renderViewport(viewportId);\n        });\n    }\n    _triggerToolModeChangedEvent(toolName, mode, toolBindingsOptions) {\n        const eventDetail = {\n            toolGroupId: this.id,\n            toolName,\n            mode,\n            toolBindingsOptions,\n        };\n        triggerEvent(eventTarget, Events.TOOL_MODE_CHANGED, eventDetail);\n    }\n    _findRenderingEngine(viewportId, renderingEngineId) {\n        const renderingEngines = getRenderingEngines();\n        if (renderingEngines?.length === 0) {\n            throw new Error('No rendering engines found.');\n        }\n        if (renderingEngineId) {\n            return renderingEngineId;\n        }\n        const matchingEngines = renderingEngines.filter((engine) => engine.getViewport(viewportId));\n        if (matchingEngines.length === 0) {\n            if (renderingEngines.length === 1) {\n                return renderingEngines[0].id;\n            }\n            throw new Error('No rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.');\n        }\n        if (matchingEngines.length > 1) {\n            throw new Error('Multiple rendering engines found that contain the viewport with the same viewportId, you must specify a renderingEngineId.');\n        }\n        return matchingEngines[0].id;\n    }\n}\nfunction hasSameBinding(binding1, binding2) {\n    if (binding1.mouseButton !== binding2.mouseButton) {\n        return false;\n    }\n    if (binding1.numTouchPoints !== binding2.numTouchPoints) {\n        return false;\n    }\n    return binding1.modifierKey === binding2.modifierKey;\n}\n","import { state } from '../state';\nimport ToolGroup from './ToolGroup';\nfunction createToolGroup(toolGroupId) {\n    const toolGroupWithIdExists = state.toolGroups.some((tg) => tg.id === toolGroupId);\n    if (toolGroupWithIdExists) {\n        console.warn(`'${toolGroupId}' already exists.`);\n        return;\n    }\n    const toolGroup = new ToolGroup(toolGroupId);\n    state.toolGroups.push(toolGroup);\n    return toolGroup;\n}\nexport default createToolGroup;\n","import { state } from '../state';\nfunction destroyToolGroup(toolGroupId) {\n    const toolGroupIndex = state.toolGroups.findIndex((tg) => tg.id === toolGroupId);\n    if (toolGroupIndex > -1) {\n        state.toolGroups.splice(toolGroupIndex, 1);\n    }\n}\nexport default destroyToolGroup;\n","import { state } from '../state';\nimport destroyToolGroup from './destroyToolGroup';\nfunction destroy() {\n    const toolGroups = [...state.toolGroups];\n    for (const toolGroup of toolGroups) {\n        destroyToolGroup(toolGroup.id);\n    }\n    state.toolGroups = [];\n}\nexport default destroy;\n","import { state } from '../state';\nfunction getAllToolGroups() {\n    return state.toolGroups;\n}\nexport default getAllToolGroups;\n","import { mouseEventListeners, wheelEventListener, touchEventListeners, keyEventListener, imageChangeEventListener, } from '../eventListeners';\nimport { imageRenderedEventDispatcher, cameraModifiedEventDispatcher, mouseToolEventDispatcher, touchToolEventDispatcher, keyboardToolEventDispatcher, imageSpacingCalibratedEventDispatcher, cameraResetEventDispatcher, } from '../eventDispatchers';\nimport { state } from './state';\nimport { annotationRenderingEngine } from '../stateManagement/annotation/AnnotationRenderingEngine';\nexport default function addEnabledElement(evt) {\n    const { element, viewportId } = evt.detail;\n    const svgLayer = _createSvgAnnotationLayer(viewportId);\n    _setSvgNodeCache(element);\n    _appendChild(svgLayer, element);\n    annotationRenderingEngine.addViewportElement(viewportId, element);\n    mouseEventListeners.enable(element);\n    wheelEventListener.enable(element);\n    touchEventListeners.enable(element);\n    keyEventListener.enable(element);\n    imageChangeEventListener.enable(element);\n    imageRenderedEventDispatcher.enable(element);\n    cameraModifiedEventDispatcher.enable(element);\n    imageSpacingCalibratedEventDispatcher.enable(element);\n    cameraResetEventDispatcher.enable(element);\n    mouseToolEventDispatcher.enable(element);\n    keyboardToolEventDispatcher.enable(element);\n    touchToolEventDispatcher.enable(element);\n    state.enabledElements.push(element);\n}\nfunction _createSvgAnnotationLayer(viewportId) {\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgLayer = document.createElementNS(svgns, 'svg');\n    const svgLayerId = `svg-layer-${viewportId}`;\n    svgLayer.classList.add('svg-layer');\n    svgLayer.setAttribute('id', svgLayerId);\n    svgLayer.setAttribute('xmlns', 'http://www.w3.org/2000/svg');\n    svgLayer.style.width = '100%';\n    svgLayer.style.height = '100%';\n    svgLayer.style.pointerEvents = 'none';\n    svgLayer.style.position = 'absolute';\n    const defs = document.createElementNS(svgns, 'defs');\n    const filter = document.createElementNS(svgns, 'filter');\n    const feOffset = document.createElementNS(svgns, 'feOffset');\n    const feColorMatrix = document.createElementNS(svgns, 'feColorMatrix');\n    const feBlend = document.createElementNS(svgns, 'feBlend');\n    filter.setAttribute('id', `shadow-${svgLayerId}`);\n    filter.setAttribute('filterUnits', 'userSpaceOnUse');\n    feOffset.setAttribute('result', 'offOut');\n    feOffset.setAttribute('in', 'SourceGraphic');\n    feOffset.setAttribute('dx', '0.5');\n    feOffset.setAttribute('dy', '0.5');\n    feColorMatrix.setAttribute('result', 'matrixOut');\n    feColorMatrix.setAttribute('in', 'offOut');\n    feColorMatrix.setAttribute('in2', 'matrix');\n    feColorMatrix.setAttribute('values', '0.2 0 0 0 0 0 0.2 0 0 0 0 0 0.2 0 0 0 0 0 1 0');\n    feBlend.setAttribute('in', 'SourceGraphic');\n    feBlend.setAttribute('in2', 'matrixOut');\n    feBlend.setAttribute('mode', 'normal');\n    filter.appendChild(feOffset);\n    filter.appendChild(feColorMatrix);\n    filter.appendChild(feBlend);\n    defs.appendChild(filter);\n    svgLayer.appendChild(defs);\n    return svgLayer;\n}\nfunction _setSvgNodeCache(element) {\n    const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;\n    const elementHash = `${viewportId}:${renderingEngineId}`;\n    state.svgNodeCache[elementHash] = {};\n}\nfunction _appendChild(newNode, referenceNode) {\n    referenceNode.querySelector('div.viewport-element').appendChild(newNode);\n}\n","import { state } from './state';\nexport function addTool(ToolClass) {\n    const toolName = ToolClass.toolName;\n    if (!toolName) {\n        throw new Error(`No Tool Found for the ToolClass ${ToolClass.name}`);\n    }\n    if (!state.tools[toolName]) {\n        state.tools[toolName] = {\n            toolClass: ToolClass,\n        };\n    }\n}\nexport function hasTool(ToolClass) {\n    const toolName = ToolClass.toolName;\n    return !!(toolName && state.tools[toolName]);\n}\nexport function hasToolByName(toolName) {\n    return !!(toolName && state.tools[toolName]);\n}\nexport function removeTool(ToolClass) {\n    const toolName = ToolClass.toolName;\n    if (!toolName) {\n        throw new Error(`No tool found for: ${ToolClass.name}`);\n    }\n    if (!state.tools[toolName] !== undefined) {\n        delete state.tools[toolName];\n    }\n    else {\n        throw new Error(`${toolName} cannot be removed because it has not been added`);\n    }\n}\nexport default addTool;\n","import { ToolModes } from '../enums';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\nexport default function cancelActiveManipulations(element) {\n    const tools = getToolsWithModesForElement(element, [\n        ToolModes.Active,\n        ToolModes.Passive,\n    ]);\n    const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n    for (const { tool } of toolsWithData) {\n        const annotationUID = tool.cancel(element);\n        if (annotationUID) {\n            return annotationUID;\n        }\n    }\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { mouseEventListeners, wheelEventListener, touchEventListeners, keyEventListener, imageChangeEventListener, } from '../eventListeners';\nimport { imageRenderedEventDispatcher, cameraModifiedEventDispatcher, mouseToolEventDispatcher, keyboardToolEventDispatcher, imageSpacingCalibratedEventDispatcher, touchToolEventDispatcher, cameraResetEventDispatcher, } from '../eventDispatchers';\nimport filterToolsWithAnnotationsForElement from './filterToolsWithAnnotationsForElement';\nimport { state } from './state';\nimport getToolsWithModesForElement from '../utilities/getToolsWithModesForElement';\nimport { ToolModes } from '../enums';\nimport { removeAnnotation } from '../stateManagement';\nimport getSynchronizersForViewport from './SynchronizerManager/getSynchronizersForViewport';\nimport getToolGroupForViewport from './ToolGroupManager/getToolGroupForViewport';\nimport { annotationRenderingEngine } from '../stateManagement/annotation/AnnotationRenderingEngine';\nconst VIEWPORT_ELEMENT = 'viewport-element';\nfunction removeEnabledElement(elementDisabledEvt) {\n    const { element, viewportId } = elementDisabledEvt.detail;\n    _resetSvgNodeCache(element);\n    _removeSvgNode(element);\n    annotationRenderingEngine.removeViewportElement(viewportId, element);\n    mouseEventListeners.disable(element);\n    wheelEventListener.disable(element);\n    touchEventListeners.disable(element);\n    keyEventListener.disable(element);\n    imageChangeEventListener.disable(element);\n    imageRenderedEventDispatcher.disable(element);\n    cameraModifiedEventDispatcher.disable(element);\n    imageSpacingCalibratedEventDispatcher.disable(element);\n    cameraResetEventDispatcher.disable(element);\n    mouseToolEventDispatcher.disable(element);\n    keyboardToolEventDispatcher.disable(element);\n    touchToolEventDispatcher.disable(element);\n    _removeViewportFromSynchronizers(element);\n    _removeViewportFromToolGroup(element);\n    _removeEnabledElement(element);\n}\nconst _removeViewportFromSynchronizers = (element) => {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const synchronizers = getSynchronizersForViewport(enabledElement.viewportId, enabledElement.renderingEngineId);\n    synchronizers.forEach((sync) => {\n        sync.remove(enabledElement);\n    });\n};\nconst _removeViewportFromToolGroup = (element) => {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { renderingEngineId, viewportId } = enabledElement;\n    const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n    if (toolGroup) {\n        toolGroup.removeViewports(renderingEngineId, viewportId);\n    }\n};\nconst _removeAllToolsForElement = function (element) {\n    const tools = getToolsWithModesForElement(element, [\n        ToolModes.Active,\n        ToolModes.Passive,\n    ]);\n    const toolsWithData = filterToolsWithAnnotationsForElement(element, tools);\n    toolsWithData.forEach(({ annotations }) => {\n        annotations.forEach((annotation) => {\n            removeAnnotation(annotation.annotationUID);\n        });\n    });\n};\nfunction _resetSvgNodeCache(element) {\n    const { viewportUid: viewportId, renderingEngineUid: renderingEngineId } = element.dataset;\n    const elementHash = `${viewportId}:${renderingEngineId}`;\n    delete state.svgNodeCache[elementHash];\n}\nfunction _removeSvgNode(element) {\n    const internalViewportNode = element.querySelector(`div.${VIEWPORT_ELEMENT}`);\n    const svgLayer = internalViewportNode.querySelector('svg');\n    if (svgLayer) {\n        internalViewportNode.removeChild(svgLayer);\n    }\n}\nconst _removeEnabledElement = function (element) {\n    const foundElementIndex = state.enabledElements.findIndex((el) => el === element);\n    if (foundElementIndex > -1) {\n        state.enabledElements.splice(foundElementIndex, 1);\n    }\n};\nexport default removeEnabledElement;\n","import svgNodeCache, { resetSvgNodeCache } from './svgNodeCache';\nconst defaultState = {\n    isInteractingWithTool: false,\n    isMultiPartToolActive: false,\n    tools: {},\n    toolGroups: [],\n    synchronizers: [],\n    svgNodeCache: svgNodeCache,\n    enabledElements: [],\n    handleRadius: 6,\n};\nlet state = {\n    isInteractingWithTool: false,\n    isMultiPartToolActive: false,\n    tools: {},\n    toolGroups: [],\n    synchronizers: [],\n    svgNodeCache: svgNodeCache,\n    enabledElements: [],\n    handleRadius: 6,\n};\nfunction resetCornerstoneToolsState() {\n    resetSvgNodeCache();\n    state = {\n        ...structuredClone({\n            ...defaultState,\n            svgNodeCache: {},\n        }),\n        svgNodeCache: {\n            ...defaultState.svgNodeCache,\n        },\n    };\n}\nexport { resetCornerstoneToolsState, state, state as default };\n","let svgNodeCache = {};\nexport function resetSvgNodeCache() {\n    svgNodeCache = {};\n}\nexport default svgNodeCache;\n","import { vec3 } from 'gl-matrix';\nexport default function areViewportsCoplanar(viewport1, viewport2) {\n    const { viewPlaneNormal: viewPlaneNormal1 } = viewport1.getCamera();\n    const { viewPlaneNormal: viewPlaneNormal2 } = viewport2.getCamera();\n    const dotProducts = vec3.dot(viewPlaneNormal1, viewPlaneNormal2);\n    return Math.abs(dotProducts) > 0.9;\n}\n","import { getRenderingEngine } from '@cornerstonejs/core';\nexport default function cameraSyncCallback(synchronizerInstance, sourceViewport, targetViewport, cameraModifiedEvent) {\n    const { camera } = cameraModifiedEvent.detail;\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    tViewport.setCamera(camera);\n    tViewport.render();\n}\n","import { vec3, mat4 } from 'gl-matrix';\nimport { getRenderingEngine, metaData, utilities, VolumeViewport, } from '@cornerstonejs/core';\nimport areViewportsCoplanar from './areViewportsCoplanar';\nconst getSpatialRegistration = (targetId, sourceId) => utilities.spatialRegistrationMetadataProvider.get('spatialRegistrationModule', targetId, sourceId);\nexport default async function imageSliceSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n    const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n    if (options?.disabled) {\n        return;\n    }\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    const imageId1 = sViewport.getCurrentImageId();\n    const imagePlaneModule1 = metaData.get('imagePlaneModule', imageId1);\n    const sourceImagePositionPatient = imagePlaneModule1.imagePositionPatient;\n    const targetImageIds = tViewport.getImageIds();\n    if (!areViewportsCoplanar(sViewport, tViewport)) {\n        return;\n    }\n    let registrationMatrixMat4 = getSpatialRegistration(targetViewport.viewportId, sourceViewport.viewportId);\n    if (!registrationMatrixMat4) {\n        const frameOfReferenceUID1 = sViewport.getFrameOfReferenceUID();\n        const frameOfReferenceUID2 = tViewport.getFrameOfReferenceUID();\n        if (frameOfReferenceUID1 === frameOfReferenceUID2 &&\n            options?.useInitialPosition !== false) {\n            registrationMatrixMat4 = mat4.identity(mat4.create());\n        }\n        else {\n            utilities.calculateViewportsSpatialRegistration(sViewport, tViewport);\n            registrationMatrixMat4 = getSpatialRegistration(targetViewport.viewportId, sourceViewport.viewportId);\n        }\n        if (!registrationMatrixMat4) {\n            return;\n        }\n    }\n    const targetImagePositionPatientWithRegistrationMatrix = vec3.transformMat4(vec3.create(), sourceImagePositionPatient, registrationMatrixMat4);\n    const closestImageIdIndex2 = _getClosestImageIdIndex(targetImagePositionPatientWithRegistrationMatrix, targetImageIds);\n    let imageIndexToSet = closestImageIdIndex2.index;\n    if (tViewport instanceof VolumeViewport) {\n        imageIndexToSet = targetImageIds.length - closestImageIdIndex2.index - 1;\n    }\n    if (closestImageIdIndex2.index !== -1 &&\n        tViewport.getCurrentImageIdIndex() !== closestImageIdIndex2.index) {\n        await utilities.jumpToSlice(tViewport.element, {\n            imageIndex: imageIndexToSet,\n        });\n    }\n}\nfunction _getClosestImageIdIndex(targetPoint, imageIds) {\n    return imageIds.reduce((closestImageIdIndex, imageId, index) => {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const distance = vec3.distance(imagePositionPatient, targetPoint);\n        if (distance < closestImageIdIndex.distance) {\n            return {\n                distance,\n                index,\n            };\n        }\n        return closestImageIdIndex;\n    }, {\n        distance: Infinity,\n        index: -1,\n    });\n}\n","import { getRenderingEngine } from '@cornerstonejs/core';\nexport default function presentationViewSyncCallback(_synchronizerInstance, sourceViewport, targetViewport, _sourceEvent, options) {\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n    const presentationView = sViewport.getViewPresentation(options);\n    tViewport.setViewPresentation(presentationView);\n    tViewport.render();\n}\n","import { getRenderingEngine } from '@cornerstonejs/core';\nexport default function slabThicknessSyncCallback(_synchronizerInstance, sourceViewport, targetViewport) {\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n    const slabThickness = sViewport.getSlabThickness?.();\n    if (!slabThickness) {\n        return;\n    }\n    tViewport.setSlabThickness?.(slabThickness);\n    tViewport.render();\n}\n","import { BaseVolumeViewport, getRenderingEngine, StackViewport, } from '@cornerstonejs/core';\nexport default function voiSyncCallback(synchronizerInstance, sourceViewport, targetViewport, modifiedEvent, options) {\n    const eventDetail = modifiedEvent.detail;\n    const { volumeId, range, invertStateChanged, invert, colormap } = eventDetail;\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`Rendering Engine does not exist: ${targetViewport.renderingEngineId}`);\n    }\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    const tProperties = {\n        voiRange: range,\n    };\n    if (options?.syncInvertState && invertStateChanged) {\n        tProperties.invert = invert;\n    }\n    if (options?.syncColormap && colormap) {\n        tProperties.colormap = colormap;\n    }\n    if (tViewport instanceof BaseVolumeViewport) {\n        const isFusion = tViewport._actors && tViewport._actors.size > 1;\n        if (isFusion) {\n            tViewport.setProperties(tProperties, volumeId);\n        }\n        else {\n            tViewport.setProperties(tProperties);\n        }\n    }\n    else if (tViewport instanceof StackViewport) {\n        tViewport.setProperties(tProperties);\n    }\n    else {\n        throw new Error('Viewport type not supported.');\n    }\n    tViewport.render();\n}\n","import { getRenderingEngine } from '@cornerstonejs/core';\nexport default function zoomPanSyncCallback(synchronizerInstance, sourceViewport, targetViewport) {\n    const renderingEngine = getRenderingEngine(targetViewport.renderingEngineId);\n    if (!renderingEngine) {\n        throw new Error(`No RenderingEngine for Id: ${targetViewport.renderingEngineId}`);\n    }\n    const options = synchronizerInstance.getOptions(targetViewport.viewportId);\n    const tViewport = renderingEngine.getViewport(targetViewport.viewportId);\n    const sViewport = renderingEngine.getViewport(sourceViewport.viewportId);\n    if (options?.syncZoom !== false) {\n        const srcZoom = sViewport.getZoom();\n        tViewport.setZoom(srcZoom);\n    }\n    if (options?.syncPan !== false) {\n        const srcPan = sViewport.getPan();\n        tViewport.setPan(srcPan);\n    }\n    tViewport.render();\n}\n","import createCameraPositionSynchronizer from './synchronizers/createCameraPositionSynchronizer';\nimport createPresentationViewSynchronizer from './synchronizers/createPresentationViewSynchronizer';\nimport createVOISynchronizer from './synchronizers/createVOISynchronizer';\nimport createZoomPanSynchronizer from './synchronizers/createZoomPanSynchronizer';\nimport createImageSliceSynchronizer from './synchronizers/createImageSliceSynchronizer';\nimport createSlabThicknessSynchronizer from './synchronizers/createSlabThicknessSynchronizer';\nimport imageSliceSyncCallback from './callbacks/imageSliceSyncCallback';\nconst createStackImageSynchronizer = createImageSliceSynchronizer;\nexport { createCameraPositionSynchronizer, createPresentationViewSynchronizer, createVOISynchronizer, createZoomPanSynchronizer, createImageSliceSynchronizer, createStackImageSynchronizer, createSlabThicknessSynchronizer, imageSliceSyncCallback, };\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport cameraSyncCallback from '../callbacks/cameraSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createCameraPositionSynchronizer(synchronizerName) {\n    const cameraPositionSynchronizer = createSynchronizer(synchronizerName, CAMERA_MODIFIED, cameraSyncCallback);\n    return cameraPositionSynchronizer;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport imageSliceSyncCallback from '../callbacks/imageSliceSyncCallback';\nconst { STACK_NEW_IMAGE, VOLUME_NEW_IMAGE } = Enums.Events;\nexport default function createImageSliceSynchronizer(synchronizerName) {\n    const stackImageSynchronizer = createSynchronizer(synchronizerName, STACK_NEW_IMAGE, imageSliceSyncCallback, {\n        auxiliaryEvents: [\n            {\n                name: 'VOLUME_NEW_IMAGE',\n            },\n        ],\n    });\n    return stackImageSynchronizer;\n}\n","import { Enums } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport presentationViewSyncCallback from '../callbacks/presentationViewSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createPresentationViewSynchronizer(synchronizerName, options) {\n    const presentationView = createSynchronizer(synchronizerName, CAMERA_MODIFIED, presentationViewSyncCallback, { viewPresentation: options });\n    return presentationView;\n}\n","import { Enums } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport slabThicknessSyncCallback from '../callbacks/slabThicknessSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createPresentationViewSynchronizer(synchronizerName) {\n    const presentationView = createSynchronizer(synchronizerName, CAMERA_MODIFIED, slabThicknessSyncCallback);\n    return presentationView;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport voiSyncCallback from '../callbacks/voiSyncCallback';\nexport default function createVOISynchronizer(synchronizerName, options) {\n    options = Object.assign({ syncInvertState: true, syncColormap: true }, options);\n    const VOISynchronizer = createSynchronizer(synchronizerName, Enums.Events.VOI_MODIFIED, voiSyncCallback, {\n        auxiliaryEvents: [\n            {\n                name: Enums.Events.COLORMAP_MODIFIED,\n            },\n        ],\n        ...options,\n    });\n    return VOISynchronizer;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport zoomPanSyncCallback from '../callbacks/zoomPanSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createZoomPanSynchronizer(synchronizerName) {\n    const zoomPanSynchronizer = createSynchronizer(synchronizerName, CAMERA_MODIFIED, zoomPanSyncCallback);\n    return zoomPanSynchronizer;\n}\n","import { AnnotationTool } from './base';\nimport { getEnabledElement, utilities as csUtils, eventTarget, Enums, getRenderingEngine, CONSTANTS, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { addAnnotation, getAllAnnotations, getAnnotations, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events, MouseBindings, KeyboardBindings, Events as cstEvents, SegmentationRepresentations, ToolModes, } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { getCanvasCircleRadius } from '../utilities/math/circle';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nimport debounce from '../utilities/debounce';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { addSegmentationRepresentations } from '../stateManagement/segmentation';\nconst MAGNIFY_CLASSNAME = 'advancedMagnifyTool';\nconst MAGNIFY_VIEWPORT_INITIAL_RADIUS = 125;\nconst { Events: csEvents } = Enums;\nconst isSegmentation = (actor) => !!actor.representationUID;\nvar AdvancedMagnifyToolActions;\n(function (AdvancedMagnifyToolActions) {\n    AdvancedMagnifyToolActions[\"ShowZoomFactorsList\"] = \"showZoomFactorsList\";\n})(AdvancedMagnifyToolActions || (AdvancedMagnifyToolActions = {}));\nconst ADVANCED_MAGNIFY_TOOL_NAME = 'AdvancedMagnify';\nconst PARALLEL_THRESHOLD = 1 - CONSTANTS.EPSILON;\nclass AdvancedMagnifyTool extends AnnotationTool {\n    static { this.Actions = AdvancedMagnifyToolActions; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            magnifyingGlass: {\n                radius: 125,\n                zoomFactor: 3,\n                zoomFactorList: [1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5],\n                autoPan: {\n                    enabled: true,\n                    padding: 10,\n                },\n            },\n            actions: {\n                showZoomFactorsList: {\n                    method: 'showZoomFactorsList',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Secondary,\n                            modifierKey: KeyboardBindings.Shift,\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const { magnifyingGlass: config } = this.configuration;\n            const { radius, zoomFactor, autoPan } = config;\n            const canvasHandlePoints = this._getCanvasHandlePoints(canvasPos, radius);\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotationUID = csUtils.uuidv4();\n            const magnifyViewportId = csUtils.uuidv4();\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                annotationUID,\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    sourceViewportId: viewport.id,\n                    magnifyViewportId,\n                    zoomFactor,\n                    isCanvasAnnotation: true,\n                    handles: {\n                        points: canvasHandlePoints,\n                        activeHandleIndex: null,\n                    },\n                },\n            };\n            this.magnifyViewportManager.createViewport(annotation, {\n                magnifyViewportId,\n                sourceEnabledElement: enabledElement,\n                position: canvasPos,\n                radius,\n                zoomFactor,\n                autoPan: {\n                    enabled: autoPan.enabled,\n                    padding: autoPan.padding,\n                    callback: (data) => {\n                        const annotationPoints = annotation.data.handles.points;\n                        const { canvas: canvasDelta } = data.delta;\n                        for (let i = 0, len = annotationPoints.length; i < len; i++) {\n                            const point = annotationPoints[i];\n                            point[0] += canvasDelta[0];\n                            point[1] += canvasDelta[1];\n                            annotation.invalidated = true;\n                        }\n                    },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.onSetToolDisabled = () => {\n            this.magnifyViewportManager.dispose();\n            const annotations = getAllAnnotations();\n            annotations.forEach((annotation) => {\n                if (annotation.metadata.toolName === this.getToolName()) {\n                    removeAnnotation(annotation.annotationUID);\n                }\n            });\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points;\n            const canvasTop = canvasCoordinates[0];\n            const canvasBottom = canvasCoordinates[2];\n            const canvasLeft = canvasCoordinates[3];\n            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n            const center = [\n                canvasLeft[0] + radius,\n                canvasTop[1] + radius,\n            ];\n            const radiusPoint = getCanvasCircleRadius([center, canvasCoords]);\n            if (Math.abs(radiusPoint - radius) < proximity * 2) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            const { points } = data.handles;\n            const handleIndex = points.findIndex((p) => p === handle);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { deltaPoints } = eventDetail;\n            const canvasDelta = deltaPoints?.canvas ?? [0, 0, 0];\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { points } = annotation.data.handles;\n            points.forEach((point) => {\n                point[0] += canvasDelta[0];\n                point[1] += canvasDelta[1];\n            });\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n            const { data } = annotation;\n            if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const canvasDelta = deltaPoints.canvas;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += canvasDelta[0];\n                    point[1] += canvasDelta[1];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points;\n            const canvasTop = canvasCoordinates[0];\n            const canvasBottom = canvasCoordinates[2];\n            const canvasLeft = canvasCoordinates[3];\n            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n            const canvasCenter = [\n                canvasLeft[0] + radius,\n                canvasTop[1] + radius,\n            ];\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const newRadius = getCanvasCircleRadius([\n                canvasCenter,\n                currentCanvasPoints,\n            ]);\n            const newCanvasHandlePoints = this._getCanvasHandlePoints(canvasCenter, newRadius);\n            points[0] = newCanvasHandlePoints[0];\n            points[1] = newCanvasHandlePoints[1];\n            points[2] = newCanvasHandlePoints[2];\n            points[3] = newCanvasHandlePoints[3];\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = annotations?.filter((annotation) => annotation.data.sourceViewportId ===\n                viewport.id);\n            const filteredAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!filteredAnnotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < filteredAnnotations.length; i++) {\n                const annotation = filteredAnnotations[i];\n                const { annotationUID, data } = annotation;\n                const { magnifyViewportId, zoomFactor, handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points;\n                const canvasTop = canvasCoordinates[0];\n                const canvasBottom = canvasCoordinates[2];\n                const canvasLeft = canvasCoordinates[3];\n                const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n                const center = [\n                    canvasLeft[0] + radius,\n                    canvasTop[1] + radius,\n                ];\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-advancedMagnify`;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineWidth: 5,\n                }, dataId);\n                const magnifyViewport = this.magnifyViewportManager.getViewport(magnifyViewportId);\n                magnifyViewport.position = center;\n                magnifyViewport.radius = radius;\n                magnifyViewport.zoomFactor = zoomFactor;\n                magnifyViewport.update();\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this._getCanvasHandlePoints = (canvasCenterPos, canvasRadius) => {\n            return [\n                [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius, 0],\n                [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1], 0],\n                [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius, 0],\n                [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1], 0],\n            ];\n        };\n        this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();\n    }\n    showZoomFactorsList(evt, annotation) {\n        const { element, currentPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { canvas: canvasPoint } = currentPoints;\n        const viewportElement = element.querySelector(':scope .viewport-element');\n        const currentZoomFactor = annotation.data.zoomFactor;\n        const remove = () => dropdown.parentElement.removeChild(dropdown);\n        const dropdown = this._getZoomFactorsListDropdown(currentZoomFactor, (newZoomFactor) => {\n            if (newZoomFactor !== undefined) {\n                annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);\n                annotation.invalidated = true;\n            }\n            remove();\n            viewport.render();\n        });\n        Object.assign(dropdown.style, {\n            left: `${canvasPoint[0]}px`,\n            top: `${canvasPoint[1]}px`,\n        });\n        viewportElement.appendChild(dropdown);\n        dropdown.focus();\n    }\n    _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {\n        const { zoomFactorList } = this.configuration.magnifyingGlass;\n        const dropdown = document.createElement('select');\n        dropdown.size = 5;\n        Object.assign(dropdown.style, {\n            width: '50px',\n            position: 'absolute',\n        });\n        ['mousedown', 'mouseup', 'mousemove', 'click'].forEach((eventName) => {\n            dropdown.addEventListener(eventName, (evt) => evt.stopPropagation());\n        });\n        dropdown.addEventListener('change', (evt) => {\n            evt.stopPropagation();\n            onChangeCallback(dropdown.value);\n        });\n        dropdown.addEventListener('keydown', (evt) => {\n            const shouldCancel = (evt.keyCode ?? evt.which === 27) ||\n                evt.key?.toLowerCase() === 'escape';\n            if (shouldCancel) {\n                evt.stopPropagation();\n                onChangeCallback();\n            }\n        });\n        zoomFactorList.forEach((zoomFactor) => {\n            const option = document.createElement('option');\n            option.label = zoomFactor;\n            option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;\n            option.value = zoomFactor;\n            option.defaultSelected = zoomFactor === currentZoomFactor;\n            dropdown.add(option);\n        });\n        return dropdown;\n    }\n}\nclass AdvancedMagnifyViewportManager {\n    constructor() {\n        this.createViewport = (annotation, viewportInfo) => {\n            const { magnifyViewportId, sourceEnabledElement, position, radius, zoomFactor, autoPan, } = viewportInfo;\n            const { viewport: sourceViewport } = sourceEnabledElement;\n            const { element: sourceElement } = sourceViewport;\n            const magnifyViewport = new AdvancedMagnifyViewport({\n                magnifyViewportId,\n                sourceEnabledElement,\n                radius,\n                position,\n                zoomFactor,\n                autoPan,\n            });\n            this._addSourceElementEventListener(sourceElement);\n            this._magnifyViewportsMap.set(magnifyViewport.viewportId, {\n                annotation,\n                magnifyViewport,\n                magnifyViewportInfo: viewportInfo,\n            });\n            return magnifyViewport;\n        };\n        this._annotationRemovedCallback = (evt) => {\n            const { annotation } = evt.detail;\n            if (annotation.metadata.toolName !== ADVANCED_MAGNIFY_TOOL_NAME) {\n                return;\n            }\n            this.destroyViewport(annotation.data.magnifyViewportId);\n        };\n        this._newStackImageCallback = (evt) => {\n            const { viewportId: sourceViewportId, imageId } = evt.detail;\n            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n            const { viewport } = getEnabledElementByViewportId(sourceViewportId);\n            if (viewport.stackActorReInitialized) {\n                this._reset(sourceViewportId);\n            }\n            magnifyViewportsMapEntries.forEach(({ annotation }) => {\n                annotation.metadata.referencedImageId = imageId;\n                annotation.invalidated = true;\n            });\n        };\n        this._newVolumeImageCallback = (evt) => {\n            const { renderingEngineId, viewportId: sourceViewportId } = evt.detail;\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            const sourceViewport = renderingEngine.getViewport(sourceViewportId);\n            const { viewPlaneNormal: currentViewPlaneNormal } = sourceViewport.getCamera();\n            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n            magnifyViewportsMapEntries.forEach(({ annotation }) => {\n                const { viewPlaneNormal } = annotation.metadata;\n                const isParallel = Math.abs(vec3.dot(viewPlaneNormal, currentViewPlaneNormal)) >\n                    PARALLEL_THRESHOLD;\n                if (!isParallel) {\n                    return;\n                }\n                const { handles } = annotation.data;\n                const worldImagePlanePoint = sourceViewport.canvasToWorld([0, 0]);\n                const vecHandleToImagePlane = vec3.sub(vec3.create(), worldImagePlanePoint, handles.points[0]);\n                const worldDist = vec3.dot(vecHandleToImagePlane, currentViewPlaneNormal);\n                const worldDelta = vec3.scale(vec3.create(), currentViewPlaneNormal, worldDist);\n                for (let i = 0, len = handles.points.length; i < len; i++) {\n                    const point = handles.points[i];\n                    point[0] += worldDelta[0];\n                    point[1] += worldDelta[1];\n                    point[2] += worldDelta[2];\n                }\n                annotation.invalidated = true;\n            });\n        };\n        this._magnifyViewportsMap = new Map();\n        this._initialize();\n    }\n    static getInstance() {\n        AdvancedMagnifyViewportManager._singleton =\n            AdvancedMagnifyViewportManager._singleton ??\n                new AdvancedMagnifyViewportManager();\n        return AdvancedMagnifyViewportManager._singleton;\n    }\n    getViewport(magnifyViewportId) {\n        return this._magnifyViewportsMap.get(magnifyViewportId)?.magnifyViewport;\n    }\n    dispose() {\n        this._removeEventListeners();\n        this._destroyViewports();\n    }\n    destroyViewport(magnifyViewportId) {\n        const magnifyViewportMapEntry = this._magnifyViewportsMap.get(magnifyViewportId);\n        if (magnifyViewportMapEntry) {\n            const { magnifyViewport } = magnifyViewportMapEntry;\n            const { viewport: sourceViewport } = magnifyViewport.sourceEnabledElement;\n            const { element: sourceElement } = sourceViewport;\n            this._removeSourceElementEventListener(sourceElement);\n            magnifyViewport.dispose();\n            this._magnifyViewportsMap.delete(magnifyViewportId);\n        }\n    }\n    _destroyViewports() {\n        const magnifyViewportIds = Array.from(this._magnifyViewportsMap.keys());\n        magnifyViewportIds.forEach((magnifyViewportId) => this.destroyViewport(magnifyViewportId));\n    }\n    _getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId) {\n        const magnifyViewportsMapEntries = Array.from(this._magnifyViewportsMap.values());\n        return magnifyViewportsMapEntries.filter(({ magnifyViewport }) => {\n            const { viewport } = magnifyViewport.sourceEnabledElement;\n            return viewport.id === sourceViewportId;\n        });\n    }\n    _reset(sourceViewportId) {\n        const magnifyViewports = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n        magnifyViewports.forEach(({ magnifyViewport, annotation, magnifyViewportInfo }) => {\n            this.destroyViewport(magnifyViewport.viewportId);\n            const newEnabledElement = getEnabledElementByViewportId(sourceViewportId);\n            this.createViewport(annotation, {\n                ...magnifyViewportInfo,\n                sourceEnabledElement: {\n                    ...newEnabledElement,\n                },\n            });\n        });\n    }\n    _addEventListeners() {\n        eventTarget.addEventListener(cstEvents.ANNOTATION_REMOVED, this._annotationRemovedCallback);\n    }\n    _removeEventListeners() {\n        eventTarget.removeEventListener(cstEvents.ANNOTATION_REMOVED, this._annotationRemovedCallback);\n    }\n    _addSourceElementEventListener(element) {\n        element.addEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);\n        const newStackHandler = (evt) => {\n            const { viewportId: sourceViewportId } = evt.detail;\n            this._reset(sourceViewportId);\n        };\n        element.addEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, newStackHandler);\n        const newVolumeHandler = (evt) => {\n            const { viewportId: sourceViewportId } = evt.detail;\n            this._reset(sourceViewportId);\n        };\n        element.addEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, newVolumeHandler);\n        element.addEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);\n        element.newStackHandler = newStackHandler;\n        element.newVolumeHandler = newVolumeHandler;\n    }\n    _removeSourceElementEventListener(element) {\n        element.removeEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);\n        element.removeEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);\n        element.removeEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, element.newStackHandler);\n        element.removeEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, element.newVolumeHandler);\n        delete element.newStackHandler;\n        delete element.newVolumeHandler;\n    }\n    _initialize() {\n        this._addEventListeners();\n    }\n}\nclass AdvancedMagnifyViewport {\n    constructor({ magnifyViewportId, sourceEnabledElement, radius = MAGNIFY_VIEWPORT_INITIAL_RADIUS, position = [0, 0], zoomFactor, autoPan, }) {\n        this._enabledElement = null;\n        this._sourceToolGroup = null;\n        this._magnifyToolGroup = null;\n        this._isViewportReady = false;\n        this._radius = 0;\n        this._resized = false;\n        this._canAutoPan = false;\n        this._viewportId = magnifyViewportId ?? csUtils.uuidv4();\n        this._sourceEnabledElement = sourceEnabledElement;\n        this._autoPan = autoPan;\n        this.radius = radius;\n        this.position = position;\n        this.zoomFactor = zoomFactor;\n        this.visible = true;\n        this._browserMouseDownCallback = this._browserMouseDownCallback.bind(this);\n        this._browserMouseUpCallback = this._browserMouseUpCallback.bind(this);\n        this._handleToolModeChanged = this._handleToolModeChanged.bind(this);\n        this._mouseDragCallback = this._mouseDragCallback.bind(this);\n        this._resizeViewportAsync = (debounce(this._resizeViewport.bind(this), 1));\n        this._initialize();\n    }\n    get sourceEnabledElement() {\n        return this._sourceEnabledElement;\n    }\n    get viewportId() {\n        return this._viewportId;\n    }\n    get radius() {\n        return this._radius;\n    }\n    set radius(radius) {\n        if (Math.abs(this._radius - radius) > 0.00001) {\n            this._radius = radius;\n            this._resized = true;\n        }\n    }\n    update() {\n        const { radius, position, visible } = this;\n        const { viewport } = this._enabledElement;\n        const { element } = viewport;\n        const size = 2 * radius;\n        const [x, y] = position;\n        if (this._resized) {\n            this._resizeViewportAsync();\n            this._resized = false;\n        }\n        Object.assign(element.style, {\n            display: visible ? 'block' : 'hidden',\n            width: `${size}px`,\n            height: `${size}px`,\n            left: `${-radius}px`,\n            top: `${-radius}px`,\n            transform: `translate(${x}px, ${y}px)`,\n        });\n        if (this._isViewportReady) {\n            this._syncViewports();\n            viewport.render();\n        }\n    }\n    dispose() {\n        const { viewport } = this._enabledElement;\n        const { element } = viewport;\n        const renderingEngine = viewport.getRenderingEngine();\n        this._removeEventListeners(element);\n        renderingEngine.disableElement(viewport.id);\n        if (element.parentNode) {\n            element.parentNode.removeChild(element);\n        }\n    }\n    _handleToolModeChanged(evt) {\n        const { _magnifyToolGroup: magnifyToolGroup } = this;\n        const { toolGroupId, toolName, mode, toolBindingsOptions } = evt.detail;\n        if (this._sourceToolGroup?.id !== toolGroupId) {\n            return;\n        }\n        switch (mode) {\n            case ToolModes.Active:\n                magnifyToolGroup.setToolActive(toolName, toolBindingsOptions);\n                break;\n            case ToolModes.Passive:\n                magnifyToolGroup.setToolPassive(toolName);\n                break;\n            case ToolModes.Enabled:\n                magnifyToolGroup.setToolEnabled(toolName);\n                break;\n            case ToolModes.Disabled:\n                magnifyToolGroup.setToolDisabled(toolName);\n                break;\n            default:\n                throw new Error(`Unknow tool mode (${mode})`);\n        }\n    }\n    _inheritBorderRadius(magnifyElement) {\n        const viewport = magnifyElement.querySelector('.viewport-element');\n        const canvas = magnifyElement.querySelector('.cornerstone-canvas');\n        viewport.style.borderRadius = 'inherit';\n        canvas.style.borderRadius = 'inherit';\n    }\n    _createViewportNode() {\n        const magnifyElement = document.createElement('div');\n        const { radius } = this;\n        const size = radius * 2;\n        magnifyElement.classList.add(MAGNIFY_CLASSNAME);\n        Object.assign(magnifyElement.style, {\n            display: 'block',\n            width: `${size}px`,\n            height: `${size}px`,\n            position: 'absolute',\n            overflow: 'hidden',\n            borderRadius: '50%',\n            boxSizing: 'border-box',\n            left: `${-radius}px`,\n            top: `${-radius}px`,\n            transform: `translate(-1000px, -1000px)`,\n        });\n        return magnifyElement;\n    }\n    _convertZoomFactorToParallelScale(viewport, magnifyViewport, zoomFactor) {\n        const { parallelScale } = viewport.getCamera();\n        const canvasRatio = magnifyViewport.canvas.offsetWidth / viewport.canvas.offsetWidth;\n        return parallelScale * (1 / zoomFactor) * canvasRatio;\n    }\n    _isStackViewport(viewport) {\n        return 'setStack' in viewport;\n    }\n    _isVolumeViewport(viewport) {\n        return 'addVolumes' in viewport;\n    }\n    _cloneToolGroups(sourceViewport, magnifyViewport) {\n        const sourceActors = sourceViewport.getActors();\n        const magnifyToolGroupId = `${magnifyViewport.id}-toolGroup`;\n        const sourceToolGroup = getToolGroupForViewport(sourceViewport.id, sourceViewport.renderingEngineId);\n        const magnifyToolGroup = sourceToolGroup.clone(magnifyToolGroupId, (toolName) => {\n            const toolInstance = sourceToolGroup.getToolInstance(toolName);\n            const isAnnotationTool = toolInstance instanceof AnnotationTool &&\n                !(toolInstance instanceof AdvancedMagnifyTool);\n            return isAnnotationTool;\n        });\n        magnifyToolGroup.addViewport(magnifyViewport.id, magnifyViewport.renderingEngineId);\n        sourceActors.filter(isSegmentation).forEach((actor) => {\n            addSegmentationRepresentations(this.viewportId, [\n                {\n                    segmentationId: actor.referencedId,\n                    type: SegmentationRepresentations.Labelmap,\n                },\n            ]);\n        });\n        return { sourceToolGroup, magnifyToolGroup };\n    }\n    _cloneStack(sourceViewport, magnifyViewport) {\n        const imageIds = sourceViewport.getImageIds();\n        magnifyViewport.setStack(imageIds).then(() => {\n            this._isViewportReady = true;\n            this.update();\n        });\n    }\n    _cloneVolumes(sourceViewport, magnifyViewport) {\n        const actors = sourceViewport.getActors();\n        const volumeInputArray = actors\n            .filter((actor) => !isSegmentation(actor))\n            .map((actor) => ({ volumeId: actor.referencedId }));\n        magnifyViewport.setVolumes(volumeInputArray).then(() => {\n            this._isViewportReady = true;\n            this.update();\n        });\n        return magnifyViewport;\n    }\n    _cloneViewport(sourceViewport, magnifyElement) {\n        const { viewportId: magnifyViewportId } = this;\n        const renderingEngine = sourceViewport.getRenderingEngine();\n        const { options: sourceViewportOptions } = sourceViewport;\n        const viewportInput = {\n            element: magnifyElement,\n            viewportId: magnifyViewportId,\n            type: sourceViewport.type,\n            defaultOptions: { ...sourceViewportOptions },\n        };\n        renderingEngine.enableElement(viewportInput);\n        const magnifyViewport = (renderingEngine.getViewport(magnifyViewportId));\n        if (this._isStackViewport(sourceViewport)) {\n            this._cloneStack(sourceViewport, magnifyViewport);\n        }\n        else if (this._isVolumeViewport(sourceViewport)) {\n            this._cloneVolumes(sourceViewport, magnifyViewport);\n        }\n        this._inheritBorderRadius(magnifyElement);\n        const toolGroups = this._cloneToolGroups(sourceViewport, magnifyViewport);\n        this._sourceToolGroup = toolGroups.sourceToolGroup;\n        this._magnifyToolGroup = toolGroups.magnifyToolGroup;\n    }\n    _cancelMouseEventCallback(evt) {\n        evt.stopPropagation();\n        evt.preventDefault();\n    }\n    _browserMouseUpCallback(evt) {\n        const { element } = this._enabledElement.viewport;\n        document.removeEventListener('mouseup', this._browserMouseUpCallback);\n        element.addEventListener('mouseup', this._cancelMouseEventCallback);\n        element.addEventListener('mousemove', this._cancelMouseEventCallback);\n    }\n    _browserMouseDownCallback(evt) {\n        const { element } = this._enabledElement.viewport;\n        this._canAutoPan = !!evt.target?.closest('.advancedMagnifyTool');\n        document.addEventListener('mouseup', this._browserMouseUpCallback);\n        element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n        element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n    }\n    _mouseDragCallback(evt) {\n        if (!state.isInteractingWithTool) {\n            return;\n        }\n        const { _autoPan: autoPan } = this;\n        if (!autoPan.enabled || !this._canAutoPan) {\n            return;\n        }\n        const { currentPoints } = evt.detail;\n        const { viewport } = this._enabledElement;\n        const { canvasToWorld } = viewport;\n        const { canvas: canvasCurrent } = currentPoints;\n        const { radius: magnifyRadius } = this;\n        const canvasCenter = [magnifyRadius, magnifyRadius];\n        const dist = distanceToPoint(canvasCenter, canvasCurrent);\n        const maxDist = magnifyRadius - autoPan.padding;\n        if (dist <= maxDist) {\n            return;\n        }\n        const panDist = dist - maxDist;\n        const canvasDeltaPos = vec2.sub(vec2.create(), canvasCurrent, canvasCenter);\n        vec2.normalize(canvasDeltaPos, canvasDeltaPos);\n        vec2.scale(canvasDeltaPos, canvasDeltaPos, panDist);\n        const newCanvasPosition = vec2.add(vec2.create(), this.position, canvasDeltaPos);\n        const currentWorldPos = canvasToWorld(this.position);\n        const newWorldPos = canvasToWorld(newCanvasPosition);\n        const worldDeltaPos = vec3.sub(vec3.create(), newWorldPos, currentWorldPos);\n        const autoPanCallbackData = {\n            points: {\n                currentPosition: {\n                    canvas: this.position,\n                    world: currentWorldPos,\n                },\n                newPosition: {\n                    canvas: newCanvasPosition,\n                    world: newWorldPos,\n                },\n            },\n            delta: {\n                canvas: canvasDeltaPos,\n                world: worldDeltaPos,\n            },\n        };\n        autoPan.callback(autoPanCallbackData);\n    }\n    _addBrowserEventListeners(element) {\n        document.addEventListener('mousedown', this._browserMouseDownCallback, true);\n        element.addEventListener('mousedown', this._cancelMouseEventCallback);\n        element.addEventListener('mouseup', this._cancelMouseEventCallback);\n        element.addEventListener('mousemove', this._cancelMouseEventCallback);\n        element.addEventListener('dblclick', this._cancelMouseEventCallback);\n    }\n    _removeBrowserEventListeners(element) {\n        document.removeEventListener('mousedown', this._browserMouseDownCallback, true);\n        document.removeEventListener('mouseup', this._browserMouseUpCallback);\n        element.removeEventListener('mousedown', this._cancelMouseEventCallback);\n        element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n        element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n        element.removeEventListener('dblclick', this._cancelMouseEventCallback);\n    }\n    _addEventListeners(element) {\n        eventTarget.addEventListener(cstEvents.TOOL_MODE_CHANGED, this._handleToolModeChanged);\n        element.addEventListener(cstEvents.MOUSE_MOVE, this._mouseDragCallback);\n        element.addEventListener(cstEvents.MOUSE_DRAG, this._mouseDragCallback);\n        this._addBrowserEventListeners(element);\n    }\n    _removeEventListeners(element) {\n        eventTarget.removeEventListener(cstEvents.TOOL_MODE_CHANGED, this._handleToolModeChanged);\n        element.addEventListener(cstEvents.MOUSE_MOVE, this._mouseDragCallback);\n        element.addEventListener(cstEvents.MOUSE_DRAG, this._mouseDragCallback);\n        this._removeBrowserEventListeners(element);\n    }\n    _initialize() {\n        const { _sourceEnabledElement: sourceEnabledElement } = this;\n        const { viewport: sourceViewport } = sourceEnabledElement;\n        const { canvas: sourceCanvas } = sourceViewport;\n        const magnifyElement = this._createViewportNode();\n        sourceCanvas.parentNode.appendChild(magnifyElement);\n        this._addEventListeners(magnifyElement);\n        this._cloneViewport(sourceViewport, magnifyElement);\n        this._enabledElement = getEnabledElement(magnifyElement);\n    }\n    _syncViewportsCameras(sourceViewport, magnifyViewport) {\n        const worldPos = sourceViewport.canvasToWorld(this.position);\n        const parallelScale = this._convertZoomFactorToParallelScale(sourceViewport, magnifyViewport, this.zoomFactor);\n        const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();\n        const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +\n            Math.pow(focalPoint[1] - position[1], 2) +\n            Math.pow(focalPoint[2] - position[2], 2));\n        const updatedFocalPoint = [\n            worldPos[0],\n            worldPos[1],\n            worldPos[2],\n        ];\n        const updatedPosition = [\n            updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n            updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n            updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n        ];\n        magnifyViewport.setCamera({\n            parallelScale,\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n    }\n    _syncStackViewports(sourceViewport, magnifyViewport) {\n        magnifyViewport.setImageIdIndex(sourceViewport.getCurrentImageIdIndex());\n    }\n    _syncViewports() {\n        const { viewport: sourceViewport } = this._sourceEnabledElement;\n        const { viewport: magnifyViewport } = this._enabledElement;\n        const sourceProperties = sourceViewport.getProperties();\n        const imageData = magnifyViewport.getImageData();\n        if (!imageData) {\n            return;\n        }\n        magnifyViewport.setProperties(sourceProperties);\n        this._syncViewportsCameras(sourceViewport, magnifyViewport);\n        if (this._isStackViewport(sourceViewport)) {\n            this._syncStackViewports(sourceViewport, magnifyViewport);\n        }\n        this._syncViewportsCameras(sourceViewport, magnifyViewport);\n        magnifyViewport.render();\n    }\n    _resizeViewport() {\n        const { viewport } = this._enabledElement;\n        const renderingEngine = viewport.getRenderingEngine();\n        renderingEngine.resize();\n    }\n}\nAdvancedMagnifyTool.toolName = 'AdvancedMagnify';\nexport { AdvancedMagnifyTool as default };\n","import { BaseTool, AnnotationTool } from './base';\nimport { getAnnotations, getAnnotation, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { setAnnotationSelected } from '../stateManagement/annotation/annotationSelection';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass AnnotationEraserTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            return this._deleteNearbyAnnotations(evt, 'mouse');\n        };\n        this.preTouchStartCallback = (evt) => {\n            return this._deleteNearbyAnnotations(evt, 'touch');\n        };\n    }\n    _deleteNearbyAnnotations(evt, interactionType) {\n        const { renderingEngineId, viewportId, element, currentPoints } = evt.detail;\n        const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n        if (!toolGroup) {\n            return false;\n        }\n        const tools = toolGroup._toolInstances;\n        const annotationsToRemove = [];\n        for (const toolName in tools) {\n            const toolInstance = tools[toolName];\n            if (typeof toolInstance.isPointNearTool !== 'function' ||\n                typeof toolInstance.filterInteractableAnnotationsForElement !==\n                    'function') {\n                continue;\n            }\n            const annotations = getAnnotations(toolName, element);\n            const interactableAnnotations = toolInstance.filterInteractableAnnotationsForElement(element, annotations);\n            if (!interactableAnnotations) {\n                continue;\n            }\n            for (const annotation of interactableAnnotations) {\n                if (toolInstance.isPointNearTool(element, annotation, currentPoints.canvas, 10, interactionType)) {\n                    annotationsToRemove.push(annotation.annotationUID);\n                }\n            }\n        }\n        for (const annotationUID of annotationsToRemove) {\n            setAnnotationSelected(annotationUID);\n            const annotation = getAnnotation(annotationUID);\n            AnnotationTool.createAnnotationMemo(element, annotation, {\n                deleting: true,\n            });\n            removeAnnotation(annotationUID);\n        }\n        evt.preventDefault();\n        return true;\n    }\n}\nAnnotationEraserTool.toolName = 'Eraser';\nexport default AnnotationEraserTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\nimport { AnnotationTool } from './base';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getEnabledElementByIds, getEnabledElement, utilities as csUtils, Enums, CONSTANTS, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { getToolGroup, getToolGroupForViewport, } from '../store/ToolGroupManager';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLine as drawLineSvg, } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\nimport * as lineSegment from '../utilities/math/line';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nconst { RENDERING_DEFAULTS } = CONSTANTS;\nfunction defaultReferenceLineColor() {\n    return 'rgb(0, 200, 0)';\n}\nfunction defaultReferenceLineControllable() {\n    return true;\n}\nfunction defaultReferenceLineDraggableRotatable() {\n    return true;\n}\nfunction defaultReferenceLineSlabThicknessControlsOn() {\n    return true;\n}\nconst OPERATION = {\n    DRAG: 1,\n    ROTATE: 2,\n    SLAB: 3,\n};\nclass CrosshairsTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse'],\n        configuration: {\n            shadow: true,\n            viewportIndicators: false,\n            viewportIndicatorsConfig: {\n                radius: 5,\n                x: null,\n                y: null,\n            },\n            autoPan: {\n                enabled: false,\n                panSize: 10,\n            },\n            handleRadius: 3,\n            enableHDPIHandles: false,\n            referenceLinesCenterGapRadius: 20,\n            referenceLinesCenterGapRatio: null,\n            filterActorUIDsToSetSlabThickness: [],\n            slabThicknessBlendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n            centerPoint: {\n                enabled: false,\n                color: 'rgba(255, 255, 0, 0.5)',\n                size: 2,\n            },\n            mobile: {\n                enabled: false,\n                opacity: 0.8,\n                handleRadius: 9,\n                referenceLinesCenterGapRatio: 0.05,\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.toolCenter = [0, 0, 0];\n        this.initializeViewport = ({ renderingEngineId, viewportId, }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const { FrameOfReferenceUID, viewport } = enabledElement;\n            const { element } = viewport;\n            const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\n            let annotations = this._getAnnotations(enabledElement);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (annotations?.length) {\n                removeAnnotation(annotations[0].annotationUID);\n            }\n            const annotation = {\n                highlighted: false,\n                metadata: {\n                    cameraPosition: [...position],\n                    cameraFocalPoint: [...focalPoint],\n                    FrameOfReferenceUID,\n                    toolName: this.getToolName(),\n                },\n                data: {\n                    handles: {\n                        rotationPoints: [],\n                        slabThicknessPoints: [],\n                        toolCenter: this.toolCenter,\n                    },\n                    activeOperation: null,\n                    activeViewportIds: [],\n                    viewportId,\n                },\n            };\n            addAnnotation(annotation, element);\n            return {\n                normal: viewPlaneNormal,\n                point: viewport.canvasToWorld([\n                    viewport.canvas.clientWidth / 2,\n                    viewport.canvas.clientHeight / 2,\n                ]),\n            };\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.resetCrosshairs = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            for (const viewportInfo of viewportsInfo) {\n                const { viewportId, renderingEngineId } = viewportInfo;\n                const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n                const viewport = enabledElement.viewport;\n                const resetPan = true;\n                const resetZoom = true;\n                const resetToCenter = true;\n                const resetRotation = true;\n                const suppressEvents = true;\n                viewport.resetCamera({\n                    resetPan,\n                    resetZoom,\n                    resetToCenter,\n                    resetRotation,\n                    suppressEvents,\n                });\n                viewport.resetSlabThickness();\n                const { element } = viewport;\n                let annotations = this._getAnnotations(enabledElement);\n                annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n                if (annotations.length) {\n                    removeAnnotation(annotations[0].annotationUID);\n                }\n                viewport.render();\n            }\n            this._computeToolCenter(viewportsInfo);\n        };\n        this.computeToolCenter = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            this._computeToolCenter(viewportsInfo);\n        };\n        this._computeToolCenter = (viewportsInfo) => {\n            if (!viewportsInfo.length || viewportsInfo.length === 1) {\n                console.warn('For crosshairs to operate, at least two viewports must be given.');\n                return;\n            }\n            const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;\n            const { normal: normal1, point: point1 } = this.initializeViewport(firstViewport);\n            const { normal: normal2, point: point2 } = this.initializeViewport(secondViewport);\n            let normal3 = [0, 0, 0];\n            let point3 = vec3.create();\n            if (thirdViewport) {\n                ({ normal: normal3, point: point3 } =\n                    this.initializeViewport(thirdViewport));\n            }\n            else {\n                vec3.add(point3, point1, point2);\n                vec3.scale(point3, point3, 0.5);\n                vec3.cross(normal3, normal1, normal2);\n            }\n            const firstPlane = csUtils.planar.planeEquation(normal1, point1);\n            const secondPlane = csUtils.planar.planeEquation(normal2, point2);\n            const thirdPlane = csUtils.planar.planeEquation(normal3, point3);\n            const toolCenter = csUtils.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane);\n            this.setToolCenter(toolCenter);\n        };\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const jumpWorld = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this._jump(enabledElement, jumpWorld);\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredAnnotations = this.filterInteractableAnnotationsForElement(viewport.element, annotations);\n            const { data } = filteredAnnotations[0];\n            const { rotationPoints } = data.handles;\n            const viewportIdArray = [];\n            for (let i = 0; i < rotationPoints.length - 1; ++i) {\n                const otherViewport = rotationPoints[i][1];\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                if (!viewportControllable || !viewportDraggableRotatable) {\n                    continue;\n                }\n                viewportIdArray.push(otherViewport.id);\n                i++;\n            }\n            data.activeViewportIds = [...viewportIdArray];\n            data.handles.activeOperation = OPERATION.DRAG;\n            evt.preventDefault();\n            hideElementCursor(element);\n            this._activateModify(element);\n            return filteredAnnotations[0];\n        };\n        this.cancel = () => {\n            console.log('Not implemented yet');\n        };\n        this.handleSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.onCameraModified = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const viewport = enabledElement.viewport;\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation) {\n                return;\n            }\n            const currentCamera = viewport.getCamera();\n            const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;\n            const deltaCameraPosition = [0, 0, 0];\n            vtkMath.subtract(currentCamera.position, oldCameraPosition, deltaCameraPosition);\n            const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;\n            const deltaCameraFocalPoint = [0, 0, 0];\n            vtkMath.subtract(currentCamera.focalPoint, oldCameraFocalPoint, deltaCameraFocalPoint);\n            viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];\n            viewportAnnotation.metadata.cameraFocalPoint = [\n                ...currentCamera.focalPoint,\n            ];\n            const viewportControllable = this._getReferenceLineControllable(viewport.id);\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(viewport.id);\n            if (!csUtils.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&\n                viewportControllable &&\n                viewportDraggableRotatable) {\n                let isRotation = false;\n                const cameraModifiedSameForPosAndFocalPoint = csUtils.isEqual(deltaCameraPosition, deltaCameraFocalPoint, 1e-3);\n                if (!cameraModifiedSameForPosAndFocalPoint) {\n                    isRotation = true;\n                }\n                const cameraModifiedInPlane = Math.abs(vtkMath.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)) < 1e-2;\n                if (!isRotation && !cameraModifiedInPlane) {\n                    this.toolCenter[0] += deltaCameraPosition[0];\n                    this.toolCenter[1] += deltaCameraPosition[1];\n                    this.toolCenter[2] += deltaCameraPosition[2];\n                    triggerEvent(eventTarget, Events.CROSSHAIR_TOOL_CENTER_CHANGED, {\n                        toolGroupId: this.toolGroupId,\n                        toolCenter: this.toolCenter,\n                    });\n                }\n            }\n            if (this.configuration.autoPan?.enabled) {\n                const toolGroup = getToolGroupForViewport(viewport.id, renderingEngine.id);\n                const otherViewportIds = toolGroup\n                    .getViewportIds()\n                    .filter((id) => id !== viewport.id);\n                otherViewportIds.forEach((viewportId) => {\n                    this._autoPanViewportIfNecessary(viewportId, renderingEngine);\n                });\n            }\n            const requireSameOrientation = false;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.onResetCamera = (evt) => {\n            this.resetCrosshairs();\n        };\n        this.mouseMoveCallback = (evt, filteredToolAnnotations) => {\n            const { element, currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            let imageNeedsUpdate = false;\n            for (let i = 0; i < filteredToolAnnotations.length; i++) {\n                const annotation = filteredToolAnnotations[i];\n                if (isAnnotationLocked(annotation.annotationUID)) {\n                    continue;\n                }\n                const { data, highlighted } = annotation;\n                if (!data.handles) {\n                    continue;\n                }\n                const previousActiveOperation = data.handles.activeOperation;\n                const previousActiveViewportIds = data.activeViewportIds && data.activeViewportIds.length > 0\n                    ? [...data.activeViewportIds]\n                    : [];\n                data.activeViewportIds = [];\n                data.handles.activeOperation = null;\n                const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, 6);\n                let near = false;\n                if (handleNearImagePoint) {\n                    near = true;\n                }\n                else {\n                    near = this._pointNearTool(element, annotation, canvasCoords, 6);\n                }\n                const nearToolAndNotMarkedActive = near && !highlighted;\n                const notNearToolAndMarkedActive = !near && highlighted;\n                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n                    annotation.highlighted = !highlighted;\n                    imageNeedsUpdate = true;\n                }\n                else if (data.handles.activeOperation !== previousActiveOperation ||\n                    !this._areViewportIdArraysEqual(data.activeViewportIds, previousActiveViewportIds)) {\n                    imageNeedsUpdate = true;\n                }\n            }\n            return imageNeedsUpdate;\n        };\n        this.filterInteractableAnnotationsForElement = (element, annotations) => {\n            if (!annotations || !annotations.length) {\n                return [];\n            }\n            const enabledElement = getEnabledElement(element);\n            const { viewportId } = enabledElement;\n            const viewportUIDSpecificCrosshairs = annotations.filter((annotation) => annotation.data.viewportId === viewportId);\n            return viewportUIDSpecificCrosshairs;\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport, renderingEngine } = enabledElement;\n            const { element } = viewport;\n            const annotations = this._getAnnotations(enabledElement);\n            const camera = viewport.getCamera();\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!annotations?.length || !viewportAnnotation?.data) {\n                return renderStatus;\n            }\n            const annotationUID = viewportAnnotation.annotationUID;\n            const { clientWidth, clientHeight } = viewport.canvas;\n            const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n            const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);\n            const data = viewportAnnotation.data;\n            const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n            const otherViewportAnnotations = this._filterAnnotationsByUniqueViewportOrientations(enabledElement, annotations);\n            const referenceLines = [];\n            const canvasBox = [0, 0, clientWidth, clientHeight];\n            otherViewportAnnotations.forEach((annotation) => {\n                const { data } = annotation;\n                data.handles.toolCenter = this.toolCenter;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n                const { clientWidth, clientHeight } = otherViewport.canvas;\n                const otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n                const otherCanvasCenter = [\n                    clientWidth * 0.5,\n                    clientHeight * 0.5,\n                ];\n                const otherViewportCenterWorld = otherViewport.canvasToWorld(otherCanvasCenter);\n                const direction = [0, 0, 0];\n                vtkMath.cross(camera.viewPlaneNormal, otherCamera.viewPlaneNormal, direction);\n                vtkMath.normalize(direction);\n                vtkMath.multiplyScalar(direction, otherCanvasDiagonalLength);\n                const pointWorld0 = [0, 0, 0];\n                vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\n                const pointWorld1 = [0, 0, 0];\n                vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\n                const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\n                const otherViewportCenterCanvas = viewport.worldToCanvas(otherViewportCenterWorld);\n                const canvasUnitVectorFromCenter = vec2.create();\n                vec2.subtract(canvasUnitVectorFromCenter, pointCanvas0, otherViewportCenterCanvas);\n                vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n                const canvasVectorFromCenterLong = vec2.create();\n                vec2.scale(canvasVectorFromCenterLong, canvasUnitVectorFromCenter, canvasDiagonalLength * 100);\n                const canvasVectorFromCenterMid = vec2.create();\n                vec2.scale(canvasVectorFromCenterMid, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.4);\n                const canvasVectorFromCenterShort = vec2.create();\n                vec2.scale(canvasVectorFromCenterShort, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.2);\n                const canvasVectorFromCenterStart = vec2.create();\n                const mobileConfig = this.configuration.mobile;\n                const { referenceLinesCenterGapRatio } = mobileConfig?.enabled\n                    ? mobileConfig\n                    : this.configuration;\n                const centerGap = referenceLinesCenterGapRatio > 0\n                    ? canvasMinDimensionLength * referenceLinesCenterGapRatio\n                    : this.configuration.referenceLinesCenterGapRadius;\n                vec2.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, otherViewportAnnotations.length === 2 ? centerGap : 0);\n                const refLinePointOne = vec2.create();\n                const refLinePointTwo = vec2.create();\n                const refLinePointThree = vec2.create();\n                const refLinePointFour = vec2.create();\n                let refLinesCenter = vec2.clone(crosshairCenterCanvas);\n                if (!otherViewportDraggableRotatable || !otherViewportControllable) {\n                    refLinesCenter = vec2.clone(otherViewportCenterCanvas);\n                }\n                vec2.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);\n                vec2.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);\n                vec2.subtract(refLinePointThree, refLinesCenter, canvasVectorFromCenterStart);\n                vec2.subtract(refLinePointFour, refLinesCenter, canvasVectorFromCenterLong);\n                liangBarksyClip(refLinePointOne, refLinePointTwo, canvasBox);\n                liangBarksyClip(refLinePointThree, refLinePointFour, canvasBox);\n                const rotHandleOne = vec2.create();\n                vec2.subtract(rotHandleOne, crosshairCenterCanvas, canvasVectorFromCenterMid);\n                const rotHandleTwo = vec2.create();\n                vec2.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);\n                let stHandlesCenterCanvas = vec2.clone(crosshairCenterCanvas);\n                if (!otherViewportDraggableRotatable &&\n                    otherViewportSlabThicknessControlsOn) {\n                    stHandlesCenterCanvas = vec2.clone(otherViewportCenterCanvas);\n                }\n                let stHandlesCenterWorld = [...this.toolCenter];\n                if (!otherViewportDraggableRotatable &&\n                    otherViewportSlabThicknessControlsOn) {\n                    stHandlesCenterWorld = [...otherViewportCenterWorld];\n                }\n                const worldUnitVectorFromCenter = [0, 0, 0];\n                vtkMath.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);\n                vtkMath.normalize(worldUnitVectorFromCenter);\n                const { viewPlaneNormal } = camera;\n                const { matrix } = vtkMatrixBuilder\n                    .buildFromDegree()\n                    .rotate(90, viewPlaneNormal);\n                const worldUnitOrthoVectorFromCenter = [0, 0, 0];\n                vec3.transformMat4(worldUnitOrthoVectorFromCenter, worldUnitVectorFromCenter, matrix);\n                const slabThicknessValue = otherViewport.getSlabThickness();\n                const worldOrthoVectorFromCenter = [\n                    ...worldUnitOrthoVectorFromCenter,\n                ];\n                vtkMath.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);\n                const worldVerticalRefPoint = [0, 0, 0];\n                vtkMath.add(stHandlesCenterWorld, worldOrthoVectorFromCenter, worldVerticalRefPoint);\n                const canvasVerticalRefPoint = viewport.worldToCanvas(worldVerticalRefPoint);\n                const canvasOrthoVectorFromCenter = vec2.create();\n                vec2.subtract(canvasOrthoVectorFromCenter, stHandlesCenterCanvas, canvasVerticalRefPoint);\n                const stLinePointOne = vec2.create();\n                vec2.subtract(stLinePointOne, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);\n                const stLinePointTwo = vec2.create();\n                vec2.add(stLinePointTwo, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);\n                liangBarksyClip(stLinePointOne, stLinePointTwo, canvasBox);\n                const stLinePointThree = vec2.create();\n                vec2.add(stLinePointThree, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.subtract(stLinePointThree, stLinePointThree, canvasOrthoVectorFromCenter);\n                const stLinePointFour = vec2.create();\n                vec2.subtract(stLinePointFour, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.subtract(stLinePointFour, stLinePointFour, canvasOrthoVectorFromCenter);\n                liangBarksyClip(stLinePointThree, stLinePointFour, canvasBox);\n                const stHandleOne = vec2.create();\n                const stHandleTwo = vec2.create();\n                const stHandleThree = vec2.create();\n                const stHandleFour = vec2.create();\n                vec2.subtract(stHandleOne, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);\n                vec2.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);\n                vec2.subtract(stHandleThree, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);\n                vec2.add(stHandleFour, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);\n                referenceLines.push([\n                    otherViewport,\n                    refLinePointOne,\n                    refLinePointTwo,\n                    refLinePointThree,\n                    refLinePointFour,\n                    stLinePointOne,\n                    stLinePointTwo,\n                    stLinePointThree,\n                    stLinePointFour,\n                    rotHandleOne,\n                    rotHandleTwo,\n                    stHandleOne,\n                    stHandleTwo,\n                    stHandleThree,\n                    stHandleFour,\n                ]);\n            });\n            const newRtpoints = [];\n            const newStpoints = [];\n            const viewportColor = this._getReferenceLineColor(viewport.id);\n            const color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n            referenceLines.forEach((line, lineIndex) => {\n                const otherViewport = line[0];\n                const viewportColor = this._getReferenceLineColor(otherViewport.id);\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id) ||\n                    this.configuration.mobile?.enabled;\n                const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||\n                    this.configuration.mobile?.enabled;\n                const selectedViewportId = data.activeViewportIds.find((id) => id === otherViewport.id);\n                let color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n                let lineWidth = 1;\n                const lineActive = data.handles.activeOperation !== null &&\n                    data.handles.activeOperation === OPERATION.DRAG &&\n                    selectedViewportId;\n                if (lineActive) {\n                    lineWidth = 2.5;\n                }\n                let lineUID = `${lineIndex}`;\n                if (viewportControllable && viewportDraggableRotatable) {\n                    lineUID = `${lineIndex}One`;\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[1], line[2], {\n                        color,\n                        lineWidth,\n                    });\n                    lineUID = `${lineIndex}Two`;\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[3], line[4], {\n                        color,\n                        lineWidth,\n                    });\n                }\n                else {\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[2], line[4], {\n                        color,\n                        lineWidth,\n                    });\n                }\n                if (viewportControllable) {\n                    color =\n                        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n                    const rotHandlesActive = data.handles.activeOperation === OPERATION.ROTATE;\n                    const rotationHandles = [line[9], line[10]];\n                    const rotHandleWorldOne = [\n                        viewport.canvasToWorld(line[9]),\n                        otherViewport,\n                        line[1],\n                        line[2],\n                    ];\n                    const rotHandleWorldTwo = [\n                        viewport.canvasToWorld(line[10]),\n                        otherViewport,\n                        line[3],\n                        line[4],\n                    ];\n                    newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);\n                    const slabThicknessHandlesActive = data.handles.activeOperation === OPERATION.SLAB;\n                    const slabThicknessHandles = [line[11], line[12], line[13], line[14]];\n                    const slabThicknessHandleWorldOne = [\n                        viewport.canvasToWorld(line[11]),\n                        otherViewport,\n                        line[5],\n                        line[6],\n                    ];\n                    const slabThicknessHandleWorldTwo = [\n                        viewport.canvasToWorld(line[12]),\n                        otherViewport,\n                        line[5],\n                        line[6],\n                    ];\n                    const slabThicknessHandleWorldThree = [\n                        viewport.canvasToWorld(line[13]),\n                        otherViewport,\n                        line[7],\n                        line[8],\n                    ];\n                    const slabThicknessHandleWorldFour = [\n                        viewport.canvasToWorld(line[14]),\n                        otherViewport,\n                        line[7],\n                        line[8],\n                    ];\n                    newStpoints.push(slabThicknessHandleWorldOne, slabThicknessHandleWorldTwo, slabThicknessHandleWorldThree, slabThicknessHandleWorldFour);\n                    let handleRadius = this.configuration.handleRadius *\n                        (this.configuration.enableHDPIHandles ? window.devicePixelRatio : 1);\n                    let opacity = 1;\n                    if (this.configuration.mobile?.enabled) {\n                        handleRadius = this.configuration.mobile.handleRadius;\n                        opacity = this.configuration.mobile.opacity;\n                    }\n                    if ((lineActive || this.configuration.mobile?.enabled) &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportDraggableRotatable &&\n                        viewportSlabThicknessControlsOn) {\n                        let handleUID = `${lineIndex}One`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'circle',\n                        });\n                        handleUID = `${lineIndex}Two`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'rect',\n                        });\n                    }\n                    else if (lineActive &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportDraggableRotatable) {\n                        const handleUID = `${lineIndex}`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'circle',\n                        });\n                    }\n                    else if (selectedViewportId &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportSlabThicknessControlsOn) {\n                        const handleUID = `${lineIndex}`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'rect',\n                        });\n                    }\n                    else if (rotHandlesActive && viewportDraggableRotatable) {\n                        const handleUID = `${lineIndex}`;\n                        const handleRadius = this.configuration.handleRadius *\n                            (this.configuration.enableHDPIHandles\n                                ? window.devicePixelRatio\n                                : 1);\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius,\n                            fill: color,\n                            type: 'circle',\n                        });\n                    }\n                    else if (slabThicknessHandlesActive &&\n                        selectedViewportId &&\n                        viewportSlabThicknessControlsOn) {\n                        const handleRadius = this.configuration.handleRadius *\n                            (this.configuration.enableHDPIHandles\n                                ? window.devicePixelRatio\n                                : 1);\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, lineUID, slabThicknessHandles, {\n                            color,\n                            handleRadius,\n                            fill: color,\n                            type: 'rect',\n                        });\n                    }\n                    const slabThicknessValue = otherViewport.getSlabThickness();\n                    if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {\n                        lineUID = `${lineIndex}STOne`;\n                        drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[5], line[6], {\n                            color,\n                            width: 1,\n                            lineDash: [2, 3],\n                        });\n                        lineUID = `${lineIndex}STTwo`;\n                        drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[7], line[8], {\n                            color,\n                            width: line,\n                            lineDash: [2, 3],\n                        });\n                    }\n                }\n            });\n            renderStatus = true;\n            data.handles.rotationPoints = newRtpoints;\n            data.handles.slabThicknessPoints = newStpoints;\n            if (this.configuration.viewportIndicators) {\n                const { viewportIndicatorsConfig } = this.configuration;\n                const xOffset = viewportIndicatorsConfig?.xOffset || 0.95;\n                const yOffset = viewportIndicatorsConfig?.yOffset || 0.05;\n                const referenceColorCoordinates = [\n                    clientWidth * xOffset,\n                    clientHeight * yOffset,\n                ];\n                const circleRadius = viewportIndicatorsConfig?.circleRadius || canvasDiagonalLength * 0.01;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, referenceColorCoordinates, circleRadius, { color, fill: color });\n            }\n            if (this.configuration.centerPoint?.enabled) {\n                const defaultColor = 'rgba(255, 255, 0, 0.5)';\n                const defaultSize = 2;\n                const maxAllowedSize = 5;\n                const centerPointColor = this.configuration.centerPoint.color || defaultColor;\n                const centerPointSize = Math.min(this.configuration.centerPoint.size || defaultSize, maxAllowedSize);\n                drawCircleSvg(svgDrawingHelper, annotationUID, 'centerPoint', crosshairCenterCanvas, centerPointSize, {\n                    color: centerPointColor,\n                    fill: centerPointColor,\n                });\n            }\n            return renderStatus;\n        };\n        this._getAnnotations = (enabledElement) => {\n            const { viewport } = enabledElement;\n            const annotations = getAnnotations(this.getToolName(), viewport.element) || [];\n            const viewportIds = this._getViewportsInfo().map(({ viewportId }) => viewportId);\n            const toolGroupAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                return viewportIds.includes(data.viewportId);\n            });\n            return toolGroupAnnotations;\n        };\n        this._onNewVolume = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            this._computeToolCenter(viewportsInfo);\n        };\n        this._areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {\n            if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {\n                return false;\n            }\n            viewportIdArrayOne.forEach((id) => {\n                let itemFound = false;\n                for (let i = 0; i < viewportIdArrayTwo.length; ++i) {\n                    if (id === viewportIdArrayTwo[i]) {\n                        itemFound = true;\n                        break;\n                    }\n                }\n                if (itemFound === false) {\n                    return false;\n                }\n            });\n            return true;\n        };\n        this._getAnnotationsForViewportsWithDifferentCameras = (enabledElement, annotations) => {\n            const { viewportId, renderingEngine, viewport } = enabledElement;\n            const otherViewportAnnotations = annotations.filter((annotation) => annotation.data.viewportId !== viewportId);\n            if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, position } = camera;\n            const viewportsWithDifferentCameras = otherViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const targetViewport = renderingEngine.getViewport(viewportId);\n                const cameraOfTarget = targetViewport.getCamera();\n                return !(csUtils.isEqual(cameraOfTarget.viewPlaneNormal, viewPlaneNormal, 1e-2) && csUtils.isEqual(cameraOfTarget.position, position, 1));\n            });\n            return viewportsWithDifferentCameras;\n        };\n        this._filterViewportWithSameOrientation = (enabledElement, referenceAnnotation, annotations) => {\n            const { renderingEngine } = enabledElement;\n            const { data } = referenceAnnotation;\n            const viewport = renderingEngine.getViewport(data.viewportId);\n            const linkedViewportAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return otherViewportControllable === true;\n            });\n            if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const viewPlaneNormal = camera.viewPlaneNormal;\n            vtkMath.normalize(viewPlaneNormal);\n            const otherViewportsAnnotationsWithSameCameraDirection = linkedViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                return (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\n                    csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2));\n            });\n            return otherViewportsAnnotationsWithSameCameraDirection;\n        };\n        this._filterAnnotationsByUniqueViewportOrientations = (enabledElement, annotations) => {\n            const { renderingEngine, viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const viewPlaneNormal = camera.viewPlaneNormal;\n            vtkMath.normalize(viewPlaneNormal);\n            const otherLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return (viewport !== otherViewport &&\n                    otherViewportControllable === true);\n            });\n            const otherViewportsAnnotationsWithUniqueCameras = [];\n            for (let i = 0; i < otherLinkedViewportAnnotationsFromSameScene.length; ++i) {\n                const annotation = otherLinkedViewportAnnotationsFromSameScene[i];\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return (viewport !== otherViewport &&\n                    otherViewportControllable !== true);\n            });\n            for (let i = 0; i < otherNonLinkedViewportAnnotationsFromSameScene.length; ++i) {\n                const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n            for (let i = 0; i < otherViewportAnnotations.length; ++i) {\n                const annotation = otherViewportAnnotations[i];\n                if (otherViewportsAnnotationsWithUniqueCameras.some((element) => element === annotation)) {\n                    continue;\n                }\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            return otherViewportsAnnotationsWithUniqueCameras;\n        };\n        this._checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {\n            const volumeIds = viewport.getAllVolumeIds();\n            const otherVolumeIds = otherViewport.getAllVolumeIds();\n            return (volumeIds.length === otherVolumeIds.length &&\n                volumeIds.every((id) => otherVolumeIds.includes(id)));\n        };\n        this._jump = (enabledElement, jumpWorld) => {\n            state.isInteractingWithTool = true;\n            const { viewport, renderingEngine } = enabledElement;\n            const annotations = this._getAnnotations(enabledElement);\n            const delta = [0, 0, 0];\n            vtkMath.subtract(jumpWorld, this.toolCenter, delta);\n            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n            const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const sameScene = this._checkIfViewportsRenderingSameScene(viewport, otherViewport);\n                return (this._getReferenceLineControllable(otherViewport.id) &&\n                    this._getReferenceLineDraggableRotatable(otherViewport.id) &&\n                    sameScene);\n            });\n            if (viewportsAnnotationsToUpdate.length === 0) {\n                state.isInteractingWithTool = false;\n                return false;\n            }\n            this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);\n            state.isInteractingWithTool = false;\n            return true;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = !this.configuration.mobile?.enabled;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            this.editData.annotation.data.handles.activeOperation = null;\n            this.editData.annotation.data.activeViewportIds = [];\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            const requireSameOrientation = false;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const delta = eventDetail.deltaPoints.world;\n            if (Math.abs(delta[0]) < 1e-3 &&\n                Math.abs(delta[1]) < 1e-3 &&\n                Math.abs(delta[2]) < 1e-3) {\n                return;\n            }\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation) {\n                return;\n            }\n            const { handles } = viewportAnnotation.data;\n            const { currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            if (handles.activeOperation === OPERATION.DRAG) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportDraggableRotatable === true &&\n                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));\n                });\n                this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);\n            }\n            else if (handles.activeOperation === OPERATION.ROTATE) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportDraggableRotatable === true);\n                });\n                const dir1 = vec2.create();\n                const dir2 = vec2.create();\n                const center = [\n                    this.toolCenter[0],\n                    this.toolCenter[1],\n                    this.toolCenter[2],\n                ];\n                const centerCanvas = viewport.worldToCanvas(center);\n                const finalPointCanvas = eventDetail.currentPoints.canvas;\n                const originalPointCanvas = vec2.create();\n                vec2.sub(originalPointCanvas, finalPointCanvas, eventDetail.deltaPoints.canvas);\n                vec2.sub(dir1, originalPointCanvas, centerCanvas);\n                vec2.sub(dir2, finalPointCanvas, centerCanvas);\n                let angle = vec2.angle(dir1, dir2);\n                if (this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)) {\n                    angle *= -1;\n                }\n                angle = Math.round(angle * 100) / 100;\n                const rotationAxis = viewport.getCamera().viewPlaneNormal;\n                const { matrix } = vtkMatrixBuilder\n                    .buildFromRadian()\n                    .translate(center[0], center[1], center[2])\n                    .rotate(angle, rotationAxis)\n                    .translate(-center[0], -center[1], -center[2]);\n                const otherViewportsIds = [];\n                viewportsAnnotationsToUpdate.forEach((annotation) => {\n                    const { data } = annotation;\n                    data.handles.toolCenter = center;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const camera = otherViewport.getCamera();\n                    const { viewUp, position, focalPoint } = camera;\n                    viewUp[0] += position[0];\n                    viewUp[1] += position[1];\n                    viewUp[2] += position[2];\n                    vec3.transformMat4(focalPoint, focalPoint, matrix);\n                    vec3.transformMat4(position, position, matrix);\n                    vec3.transformMat4(viewUp, viewUp, matrix);\n                    viewUp[0] -= position[0];\n                    viewUp[1] -= position[1];\n                    viewUp[2] -= position[2];\n                    otherViewport.setCamera({\n                        position,\n                        viewUp,\n                        focalPoint,\n                    });\n                    otherViewportsIds.push(otherViewport.id);\n                });\n                renderingEngine.renderViewports(otherViewportsIds);\n            }\n            else if (handles.activeOperation === OPERATION.SLAB) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const referenceAnnotations = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportSlabThicknessControlsOn === true &&\n                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));\n                });\n                if (referenceAnnotations.length === 0) {\n                    return;\n                }\n                const viewportsAnnotationsToUpdate = this._filterViewportWithSameOrientation(enabledElement, referenceAnnotations[0], annotations);\n                const viewportsIds = [];\n                viewportsIds.push(viewport.id);\n                viewportsAnnotationsToUpdate.forEach((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const camera = otherViewport.getCamera();\n                    const normal = camera.viewPlaneNormal;\n                    const dotProd = vtkMath.dot(delta, normal);\n                    const projectedDelta = [...normal];\n                    vtkMath.multiplyScalar(projectedDelta, dotProd);\n                    if (Math.abs(projectedDelta[0]) > 1e-3 ||\n                        Math.abs(projectedDelta[1]) > 1e-3 ||\n                        Math.abs(projectedDelta[2]) > 1e-3) {\n                        const mod = Math.sqrt(projectedDelta[0] * projectedDelta[0] +\n                            projectedDelta[1] * projectedDelta[1] +\n                            projectedDelta[2] * projectedDelta[2]);\n                        const currentPoint = eventDetail.lastPoints.world;\n                        const direction = [0, 0, 0];\n                        const currentCenter = [\n                            this.toolCenter[0],\n                            this.toolCenter[1],\n                            this.toolCenter[2],\n                        ];\n                        const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                        if (!viewportDraggableRotatable) {\n                            const { rotationPoints } = (this.editData.annotation.data).handles;\n                            const otherViewportRotationPoints = rotationPoints.filter((point) => point[1].uid === otherViewport.id);\n                            if (otherViewportRotationPoints.length === 2) {\n                                const point1 = viewport.canvasToWorld(otherViewportRotationPoints[0][3]);\n                                const point2 = viewport.canvasToWorld(otherViewportRotationPoints[1][3]);\n                                vtkMath.add(point1, point2, currentCenter);\n                                vtkMath.multiplyScalar(currentCenter, 0.5);\n                            }\n                        }\n                        vtkMath.subtract(currentPoint, currentCenter, direction);\n                        const dotProdDirection = vtkMath.dot(direction, normal);\n                        const projectedDirection = [...normal];\n                        vtkMath.multiplyScalar(projectedDirection, dotProdDirection);\n                        const normalizedProjectedDirection = [\n                            projectedDirection[0],\n                            projectedDirection[1],\n                            projectedDirection[2],\n                        ];\n                        vec3.normalize(normalizedProjectedDirection, normalizedProjectedDirection);\n                        const normalizedProjectedDelta = [\n                            projectedDelta[0],\n                            projectedDelta[1],\n                            projectedDelta[2],\n                        ];\n                        vec3.normalize(normalizedProjectedDelta, normalizedProjectedDelta);\n                        let slabThicknessValue = otherViewport.getSlabThickness();\n                        if (csUtils.isOpposite(normalizedProjectedDirection, normalizedProjectedDelta, 1e-3)) {\n                            slabThicknessValue -= mod;\n                        }\n                        else {\n                            slabThicknessValue += mod;\n                        }\n                        slabThicknessValue = Math.abs(slabThicknessValue);\n                        slabThicknessValue = Math.max(RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, slabThicknessValue);\n                        const near = this._pointNearReferenceLine(viewportAnnotation, canvasCoords, 6, otherViewport);\n                        if (near) {\n                            slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;\n                        }\n                        const toolGroup = getToolGroupForViewport(otherViewport.id, renderingEngine.id);\n                        const crosshairsInstance = toolGroup.getToolInstance(this.getToolName());\n                        crosshairsInstance.setSlabThickness(otherViewport, slabThicknessValue);\n                        viewportsIds.push(otherViewport.id);\n                    }\n                });\n                renderingEngine.renderViewports(viewportsIds);\n            }\n        };\n        this._pointNearReferenceLine = (annotation, canvasCoords, proximity, lineViewport) => {\n            const { data } = annotation;\n            const { rotationPoints } = data.handles;\n            for (let i = 0; i < rotationPoints.length - 1; ++i) {\n                const otherViewport = rotationPoints[i][1];\n                if (otherViewport.id !== lineViewport.id) {\n                    continue;\n                }\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                if (!viewportControllable) {\n                    continue;\n                }\n                const lineSegment1 = {\n                    start: {\n                        x: rotationPoints[i][2][0],\n                        y: rotationPoints[i][2][1],\n                    },\n                    end: {\n                        x: rotationPoints[i][3][0],\n                        y: rotationPoints[i][3][1],\n                    },\n                };\n                const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n                const lineSegment2 = {\n                    start: {\n                        x: rotationPoints[i + 1][2][0],\n                        y: rotationPoints[i + 1][2][1],\n                    },\n                    end: {\n                        x: rotationPoints[i + 1][3][0],\n                        y: rotationPoints[i + 1][3][1],\n                    },\n                };\n                const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n                if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                    return true;\n                }\n                i++;\n            }\n            return false;\n        };\n        this._getReferenceLineColor =\n            toolProps.configuration?.getReferenceLineColor ||\n                defaultReferenceLineColor;\n        this._getReferenceLineControllable =\n            toolProps.configuration?.getReferenceLineControllable ||\n                defaultReferenceLineControllable;\n        this._getReferenceLineDraggableRotatable =\n            toolProps.configuration?.getReferenceLineDraggableRotatable ||\n                defaultReferenceLineDraggableRotatable;\n        this._getReferenceLineSlabThicknessControlsOn =\n            toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||\n                defaultReferenceLineSlabThicknessControlsOn;\n    }\n    onSetToolActive() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n        this._subscribeToViewportNewVolumeSet(viewportsInfo);\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolPassive() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolEnabled() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolDisabled() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n        viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const annotations = this._getAnnotations(enabledElement);\n            if (annotations?.length) {\n                annotations.forEach((annotation) => {\n                    removeAnnotation(annotation.annotationUID);\n                });\n            }\n        });\n    }\n    setToolCenter(toolCenter, suppressEvents = false) {\n        const viewportsInfo = this._getViewportsInfo();\n        viewportsInfo.map(({ renderingEngineId, viewportId }) => {\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            const viewport = renderingEngine.getViewport(viewportId);\n            const camera = viewport.getCamera();\n            const { focalPoint, position, viewPlaneNormal } = camera;\n            const delta = [\n                toolCenter[0] - focalPoint[0],\n                toolCenter[1] - focalPoint[1],\n                toolCenter[2] - focalPoint[2],\n            ];\n            const scroll = delta[0] * viewPlaneNormal[0] +\n                delta[1] * viewPlaneNormal[1] +\n                delta[2] * viewPlaneNormal[2];\n            const scrollDelta = [\n                scroll * viewPlaneNormal[0],\n                scroll * viewPlaneNormal[1],\n                scroll * viewPlaneNormal[2],\n            ];\n            const newFocalPoint = [\n                focalPoint[0] + scrollDelta[0],\n                focalPoint[1] + scrollDelta[1],\n                focalPoint[2] + scrollDelta[2],\n            ];\n            const newPosition = [\n                position[0] + scrollDelta[0],\n                position[1] + scrollDelta[1],\n                position[2] + scrollDelta[2],\n            ];\n            viewport.setCamera({\n                focalPoint: newFocalPoint,\n                position: newPosition,\n            });\n            viewport.render();\n        });\n        this.toolCenter = toolCenter;\n        if (!suppressEvents) {\n            triggerEvent(eventTarget, Events.CROSSHAIR_TOOL_CENTER_CHANGED, {\n                toolGroupId: this.toolGroupId,\n                toolCenter: this.toolCenter,\n            });\n        }\n    }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let point = this._getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);\n        if (point !== null) {\n            return point;\n        }\n        point = this._getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);\n        if (point !== null) {\n            return point;\n        }\n    }\n    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _subscribeToViewportNewVolumeSet(viewports) {\n        viewports.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _autoPanViewportIfNecessary(viewportId, renderingEngine) {\n        const viewport = renderingEngine.getViewport(viewportId);\n        const { clientWidth, clientHeight } = viewport.canvas;\n        const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n        const pan = this.configuration.autoPan.panSize;\n        const visiblePointCanvas = [\n            toolCenterCanvas[0],\n            toolCenterCanvas[1],\n        ];\n        if (toolCenterCanvas[0] < 0) {\n            visiblePointCanvas[0] = pan;\n        }\n        else if (toolCenterCanvas[0] > clientWidth) {\n            visiblePointCanvas[0] = clientWidth - pan;\n        }\n        if (toolCenterCanvas[1] < 0) {\n            visiblePointCanvas[1] = pan;\n        }\n        else if (toolCenterCanvas[1] > clientHeight) {\n            visiblePointCanvas[1] = clientHeight - pan;\n        }\n        if (visiblePointCanvas[0] === toolCenterCanvas[0] &&\n            visiblePointCanvas[1] === toolCenterCanvas[1]) {\n            return;\n        }\n        const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);\n        const deltaPointsWorld = [\n            visiblePointWorld[0] - this.toolCenter[0],\n            visiblePointWorld[1] - this.toolCenter[1],\n            visiblePointWorld[2] - this.toolCenter[2],\n        ];\n        const camera = viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        viewport.render();\n    }\n    setSlabThickness(viewport, slabThickness) {\n        let actorUIDs;\n        const { filterActorUIDsToSetSlabThickness } = this.configuration;\n        if (filterActorUIDsToSetSlabThickness &&\n            filterActorUIDsToSetSlabThickness.length > 0) {\n            actorUIDs = filterActorUIDsToSetSlabThickness;\n        }\n        let blendModeToUse = this.configuration.slabThicknessBlendMode;\n        if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {\n            blendModeToUse = Enums.BlendModes.COMPOSITE;\n        }\n        const immediate = false;\n        viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);\n        viewport.setSlabThickness(slabThickness, actorUIDs);\n    }\n    _isClockWise(a, b, c) {\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;\n    }\n    _applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta) {\n        viewportsAnnotationsToUpdate.forEach((annotation) => {\n            this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\n        });\n    }\n    _applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta) {\n        const { data } = annotation;\n        const viewport = renderingEngine.getViewport(data.viewportId);\n        const camera = viewport.getCamera();\n        const normal = camera.viewPlaneNormal;\n        const dotProd = vtkMath.dot(delta, normal);\n        const projectedDelta = [...normal];\n        vtkMath.multiplyScalar(projectedDelta, dotProd);\n        if (Math.abs(projectedDelta[0]) > 1e-3 ||\n            Math.abs(projectedDelta[1]) > 1e-3 ||\n            Math.abs(projectedDelta[2]) > 1e-3) {\n            const newFocalPoint = [0, 0, 0];\n            const newPosition = [0, 0, 0];\n            vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\n            vtkMath.add(camera.position, projectedDelta, newPosition);\n            viewport.setCamera({\n                focalPoint: newFocalPoint,\n                position: newPosition,\n            });\n            viewport.render();\n        }\n    }\n    _getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {\n        const { data } = annotation;\n        const { rotationPoints } = data.handles;\n        for (let i = 0; i < rotationPoints.length; i++) {\n            const point = rotationPoints[i][0];\n            const otherViewport = rotationPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            if (!viewportControllable) {\n                continue;\n            }\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportDraggableRotatable) {\n                continue;\n            }\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n                data.handles.activeOperation = OPERATION.ROTATE;\n                this.editData = {\n                    annotation,\n                };\n                return point;\n            }\n        }\n        return null;\n    }\n    _getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {\n        const { data } = annotation;\n        const { slabThicknessPoints } = data.handles;\n        for (let i = 0; i < slabThicknessPoints.length; i++) {\n            const point = slabThicknessPoints[i][0];\n            const otherViewport = slabThicknessPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            if (!viewportControllable) {\n                continue;\n            }\n            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n            if (!viewportSlabThicknessControlsOn) {\n                continue;\n            }\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n                data.handles.activeOperation = OPERATION.SLAB;\n                data.activeViewportIds = [otherViewport.id];\n                this.editData = {\n                    annotation,\n                };\n                return point;\n            }\n        }\n        return null;\n    }\n    _pointNearTool(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { clientWidth, clientHeight } = viewport.canvas;\n        const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n        const { data } = annotation;\n        const { rotationPoints } = data.handles;\n        const { slabThicknessPoints } = data.handles;\n        const viewportIdArray = [];\n        for (let i = 0; i < rotationPoints.length - 1; ++i) {\n            const otherViewport = rotationPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportControllable || !viewportDraggableRotatable) {\n                continue;\n            }\n            const lineSegment1 = {\n                start: {\n                    x: rotationPoints[i][2][0],\n                    y: rotationPoints[i][2][1],\n                },\n                end: {\n                    x: rotationPoints[i][3][0],\n                    y: rotationPoints[i][3][1],\n                },\n            };\n            const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const lineSegment2 = {\n                start: {\n                    x: rotationPoints[i + 1][2][0],\n                    y: rotationPoints[i + 1][2][1],\n                },\n                end: {\n                    x: rotationPoints[i + 1][3][0],\n                    y: rotationPoints[i + 1][3][1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                viewportIdArray.push(otherViewport.id);\n                data.handles.activeOperation = OPERATION.DRAG;\n            }\n            i++;\n        }\n        for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {\n            const otherViewport = slabThicknessPoints[i][1];\n            if (viewportIdArray.find((id) => id === otherViewport.id)) {\n                continue;\n            }\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n            if (!viewportControllable || !viewportSlabThicknessControlsOn) {\n                continue;\n            }\n            const stPointLineCanvas1 = slabThicknessPoints[i][2];\n            const stPointLineCanvas2 = slabThicknessPoints[i][3];\n            const centerCanvas = vec2.create();\n            vec2.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);\n            vec2.scale(centerCanvas, centerCanvas, 0.5);\n            const canvasUnitVectorFromCenter = vec2.create();\n            vec2.subtract(canvasUnitVectorFromCenter, stPointLineCanvas1, centerCanvas);\n            vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n            const canvasVectorFromCenterStart = vec2.create();\n            vec2.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, canvasDiagonalLength * 0.05);\n            const stPointLineCanvas1Start = vec2.create();\n            const stPointLineCanvas2Start = vec2.create();\n            vec2.add(stPointLineCanvas1Start, centerCanvas, canvasVectorFromCenterStart);\n            vec2.subtract(stPointLineCanvas2Start, centerCanvas, canvasVectorFromCenterStart);\n            const lineSegment1 = {\n                start: {\n                    x: stPointLineCanvas1Start[0],\n                    y: stPointLineCanvas1Start[1],\n                },\n                end: {\n                    x: stPointLineCanvas1[0],\n                    y: stPointLineCanvas1[1],\n                },\n            };\n            const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const lineSegment2 = {\n                start: {\n                    x: stPointLineCanvas2Start[0],\n                    y: stPointLineCanvas2Start[1],\n                },\n                end: {\n                    x: stPointLineCanvas2[0],\n                    y: stPointLineCanvas2[1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                viewportIdArray.push(otherViewport.id);\n                data.handles.activeOperation = null;\n            }\n            i++;\n        }\n        data.activeViewportIds = [...viewportIdArray];\n        this.editData = {\n            annotation,\n        };\n        return data.handles.activeOperation === OPERATION.DRAG ? true : false;\n    }\n}\nCrosshairsTool.toolName = 'Crosshairs';\nexport default CrosshairsTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport } from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/core';\nimport { getPointInLineOfSightWithCriteria } from '../utilities/planar';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass MIPJumpToClickTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            targetViewportIds: [],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    mouseClickCallback(evt) {\n        const { element, currentPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        const volumeId = viewport.getVolumeId();\n        if (!volumeId) {\n            throw new Error(`MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`);\n        }\n        let maxIntensity = -Infinity;\n        const maxFn = (intensity, point) => {\n            if (intensity > maxIntensity) {\n                maxIntensity = intensity;\n                return point;\n            }\n        };\n        const brightestPoint = getPointInLineOfSightWithCriteria(viewport, currentPoints.world, volumeId, maxFn);\n        if (!brightestPoint || !brightestPoint.length) {\n            return;\n        }\n        const { targetViewportIds, toolGroupId } = this.configuration;\n        const viewports = renderingEngine.getViewports().filter((vp) => {\n            if (targetViewportIds?.indexOf(vp.id) >= 0) {\n                return true;\n            }\n            const foundToolGroup = getToolGroupForViewport(vp.id, renderingEngine.id);\n            if (toolGroupId && toolGroupId === foundToolGroup?.id) {\n                return true;\n            }\n            return false;\n        });\n        viewports.forEach((viewport) => {\n            if (viewport instanceof VolumeViewport) {\n                viewport.jumpToWorld(brightestPoint);\n            }\n            else {\n                console.warn('Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport');\n            }\n        });\n    }\n}\nMIPJumpToClickTool.toolName = 'MIPJumpToClickTool';\nexport default MIPJumpToClickTool;\n","import { BaseTool } from './base';\nimport { Events } from '../enums';\nimport { getEnabledElement, StackViewport, Enums } from '@cornerstonejs/core';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { state } from '../store/state';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nconst MAGNIFY_VIEWPORT_ID = 'magnify-viewport';\nclass MagnifyTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            magnifySize: 10,\n            magnifyWidth: 250,\n            magnifyHeight: 250,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._hasBeenRemoved = false;\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            if (!(viewport instanceof StackViewport)) {\n                throw new Error('MagnifyTool only works on StackViewports');\n            }\n            const referencedImageId = this._getReferencedImageId(viewport);\n            if (!referencedImageId) {\n                throw new Error('MagnifyTool: No referenced image id found, reconstructed planes not supported yet');\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                referencedImageId,\n                viewportIdsToRender,\n                enabledElement,\n                renderingEngine,\n                currentPoints,\n            };\n            this._createMagnificationViewport();\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this.preTouchStartCallback = (evt) => {\n            this.preMouseDownCallback(evt);\n        };\n        this._createMagnificationViewport = () => {\n            const { enabledElement, referencedImageId, viewportIdsToRender, renderingEngine, currentPoints, } = this.editData;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const viewportProperties = viewport.getProperties();\n            const { rotation: originalViewportRotation } = viewport.getViewPresentation();\n            const { canvas: canvasPos, world: worldPos } = currentPoints;\n            let magnifyToolElement;\n            magnifyToolElement = element.querySelector('.magnifyTool');\n            if (magnifyToolElement === null) {\n                const magnifyElement = document.createElement('div');\n                magnifyElement.classList.add('magnifyTool');\n                magnifyElement.style.display = 'block';\n                magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;\n                magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;\n                magnifyElement.style.position = 'absolute';\n                magnifyToolElement = magnifyElement;\n                const viewportElement = element.querySelector('.viewport-element');\n                viewportElement.appendChild(magnifyElement);\n                const viewportInput = {\n                    viewportId: MAGNIFY_VIEWPORT_ID,\n                    type: Enums.ViewportType.STACK,\n                    element: magnifyToolElement,\n                };\n                renderingEngine.enableElement(viewportInput);\n            }\n            magnifyToolElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;\n            magnifyToolElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;\n            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n            magnifyViewport.setStack([referencedImageId]).then(() => {\n                if (this._hasBeenRemoved) {\n                    return;\n                }\n                magnifyViewport.setProperties(viewportProperties);\n                magnifyViewport.setViewPresentation({\n                    rotation: originalViewportRotation,\n                });\n                const { parallelScale } = viewport.getCamera();\n                const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();\n                const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +\n                    Math.pow(focalPoint[1] - position[1], 2) +\n                    Math.pow(focalPoint[2] - position[2], 2));\n                const updatedFocalPoint = [\n                    worldPos[0],\n                    worldPos[1],\n                    worldPos[2],\n                ];\n                const updatedPosition = [\n                    updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n                    updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n                    updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n                ];\n                magnifyViewport.setCamera({\n                    parallelScale: parallelScale * (1 / this.configuration.magnifySize),\n                    focalPoint: updatedFocalPoint,\n                    position: updatedPosition,\n                });\n                magnifyViewport.render();\n            });\n            magnifyToolElement.style.display = 'block';\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._cancelCallback = (evt) => {\n            evt.preventDefault();\n            evt.stopPropagation();\n            this._dragEndCallback(evt);\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { deltaPoints, element, currentPoints } = eventDetail;\n            const deltaPointsWorld = deltaPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n            const magnifyElement = element.querySelector('.magnifyTool');\n            if (!magnifyElement) {\n                return;\n            }\n            magnifyElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;\n            magnifyElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;\n            const { focalPoint, position } = magnifyViewport.getCamera();\n            const updatedPosition = [\n                position[0] + deltaPointsWorld[0],\n                position[1] + deltaPointsWorld[1],\n                position[2] + deltaPointsWorld[2],\n            ];\n            const updatedFocalPoint = [\n                focalPoint[0] + deltaPointsWorld[0],\n                focalPoint[1] + deltaPointsWorld[1],\n                focalPoint[2] + deltaPointsWorld[2],\n            ];\n            magnifyViewport.setCamera({\n                focalPoint: updatedFocalPoint,\n                position: updatedPosition,\n            });\n            magnifyViewport.render();\n        };\n        this._dragEndCallback = (evt) => {\n            let { element } = evt.detail;\n            if (element === undefined) {\n                const { enabledElement } = this.editData;\n                const { viewport } = enabledElement;\n                element = viewport.element;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);\n            const viewportElement = element.querySelector('.viewport-element');\n            const magnifyToolElement = viewportElement.querySelector('.magnifyTool');\n            viewportElement.removeChild(magnifyToolElement);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this._hasBeenRemoved = true;\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            this._hasBeenRemoved = false;\n            element.addEventListener(Events.MOUSE_UP, this._dragEndCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._dragEndCallback);\n            element.addEventListener('contextmenu', this._cancelCallback);\n            element.addEventListener(Events.TOUCH_END, this._dragEndCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._dragEndCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._dragEndCallback);\n            element.removeEventListener('contextmenu', this._cancelCallback);\n            element.removeEventListener(Events.TOUCH_END, this._dragEndCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n    }\n    _getReferencedImageId(viewport) {\n        const targetId = this.getTargetId(viewport);\n        let referencedImageId;\n        if (viewport instanceof StackViewport) {\n            referencedImageId = targetId.split('imageId:')[1];\n        }\n        return referencedImageId;\n    }\n}\nMagnifyTool.toolName = 'Magnify';\nexport default MagnifyTool;\n","import vtkOrientationMarkerWidget from '@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget';\nimport vtkAnnotatedCubeActor from '@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor';\nimport vtkAxesActor from '@kitware/vtk.js/Rendering/Core/AxesActor';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkXMLPolyDataReader from '@kitware/vtk.js/IO/XML/XMLPolyDataReader';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport { BaseTool } from './base';\nimport { Enums, eventTarget, getEnabledElementByIds, getRenderingEngines, } from '@cornerstonejs/core';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport { Events } from '../enums';\nvar OverlayMarkerType;\n(function (OverlayMarkerType) {\n    OverlayMarkerType[OverlayMarkerType[\"ANNOTATED_CUBE\"] = 1] = \"ANNOTATED_CUBE\";\n    OverlayMarkerType[OverlayMarkerType[\"AXES\"] = 2] = \"AXES\";\n    OverlayMarkerType[OverlayMarkerType[\"CUSTOM\"] = 3] = \"CUSTOM\";\n})(OverlayMarkerType || (OverlayMarkerType = {}));\nclass OrientationMarkerTool extends BaseTool {\n    static { this.CUBE = 1; }\n    static { this.AXIS = 2; }\n    static { this.VTPFILE = 3; }\n    static { this.OVERLAY_MARKER_TYPES = OverlayMarkerType; }\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            orientationWidget: {\n                enabled: true,\n                viewportCorner: vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT,\n                viewportSize: 0.15,\n                minPixelSize: 100,\n                maxPixelSize: 300,\n            },\n            overlayMarkerType: OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,\n            overlayConfiguration: {\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {\n                    faceProperties: {\n                        xPlus: { text: 'L', faceColor: '#ffff00', faceRotation: 90 },\n                        xMinus: { text: 'R', faceColor: '#ffff00', faceRotation: 270 },\n                        yPlus: {\n                            text: 'P',\n                            faceColor: '#00ffff',\n                            fontColor: 'white',\n                            faceRotation: 180,\n                        },\n                        yMinus: { text: 'A', faceColor: '#00ffff', fontColor: 'white' },\n                        zPlus: { text: 'S' },\n                        zMinus: { text: 'I' },\n                    },\n                    defaultStyle: {\n                        fontStyle: 'bold',\n                        fontFamily: 'Arial',\n                        fontColor: 'black',\n                        fontSizeScale: (res) => res / 2,\n                        faceColor: '#0000ff',\n                        edgeThickness: 0.1,\n                        edgeColor: 'black',\n                        resolution: 400,\n                    },\n                },\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {\n                    polyDataURL: 'https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp',\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._resizeObservers = new Map();\n        this.onSetToolEnabled = () => {\n            this.initViewports();\n            this._subscribeToViewportEvents();\n        };\n        this.onSetToolActive = () => {\n            this.initViewports();\n            this._subscribeToViewportEvents();\n        };\n        this.onSetToolDisabled = () => {\n            this.cleanUpData();\n            this._unsubscribeToViewportNewVolumeSet();\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.resize = (viewportId) => {\n            const orientationMarker = this.orientationMarkers[viewportId];\n            if (!orientationMarker) {\n                return;\n            }\n            const { orientationWidget } = orientationMarker;\n            orientationWidget.updateViewport();\n        };\n        this.orientationMarkers = {};\n        this.updatingOrientationMarker = {};\n    }\n    _unsubscribeToViewportNewVolumeSet() {\n        const unsubscribe = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n                const { element } = viewport;\n                element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));\n                const resizeObserver = this._resizeObservers.get(viewportId);\n                resizeObserver.unobserve(element);\n            });\n        };\n        eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\n            if (evt.detail.toolGroupId !== this.toolGroupId) {\n                return;\n            }\n            unsubscribe();\n            this.initViewports();\n        });\n    }\n    _subscribeToViewportEvents() {\n        const subscribeToElementResize = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n                const { element } = viewport;\n                this.initViewports();\n                element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));\n                const resizeObserver = new ResizeObserver(() => {\n                    setTimeout(() => {\n                        const element = getEnabledElementByIds(viewportId, renderingEngineId);\n                        if (!element) {\n                            return;\n                        }\n                        const { viewport } = element;\n                        this.resize(viewportId);\n                        viewport.render();\n                    }, 100);\n                });\n                resizeObserver.observe(element);\n                this._resizeObservers.set(viewportId, resizeObserver);\n            });\n        };\n        subscribeToElementResize();\n        eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\n            if (evt.detail.toolGroupId !== this.toolGroupId) {\n                return;\n            }\n            subscribeToElementResize();\n            this.initViewports();\n        });\n    }\n    cleanUpData() {\n        const renderingEngines = getRenderingEngines();\n        const renderingEngine = renderingEngines[0];\n        const viewports = renderingEngine.getViewports();\n        viewports.forEach((viewport) => {\n            const orientationMarker = this.orientationMarkers[viewport.id];\n            if (!orientationMarker) {\n                return;\n            }\n            const { actor, orientationWidget } = orientationMarker;\n            orientationWidget?.setEnabled(false);\n            orientationWidget?.delete();\n            actor?.delete();\n            const renderWindow = viewport\n                .getRenderingEngine()\n                .getOffscreenMultiRenderWindow(viewport.id)\n                .getRenderWindow();\n            renderWindow.render();\n            viewport.getRenderingEngine().render();\n            delete this.orientationMarkers[viewport.id];\n        });\n    }\n    initViewports() {\n        const renderingEngines = getRenderingEngines();\n        const renderingEngine = renderingEngines[0];\n        if (!renderingEngine) {\n            return;\n        }\n        let viewports = renderingEngine.getViewports();\n        viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n        viewports.forEach((viewport) => {\n            const widget = viewport.getWidget(this.getToolName());\n            if (!widget || widget.isDeleted()) {\n                this.addAxisActorInViewport(viewport);\n            }\n        });\n    }\n    async addAxisActorInViewport(viewport) {\n        const viewportId = viewport.id;\n        if (!this.updatingOrientationMarker[viewportId]) {\n            this.updatingOrientationMarker[viewportId] = true;\n            const type = this.configuration.overlayMarkerType;\n            const overlayConfiguration = this.configuration.overlayConfiguration[type];\n            if (this.orientationMarkers[viewportId]) {\n                const { actor, orientationWidget } = this.orientationMarkers[viewportId];\n                viewport.getRenderer().removeActor(actor);\n                orientationWidget.setEnabled(false);\n            }\n            let actor;\n            if (type === 1) {\n                actor = this.createAnnotationCube(overlayConfiguration);\n            }\n            else if (type === 2) {\n                actor = vtkAxesActor.newInstance();\n            }\n            else if (type === 3) {\n                actor = await this.createCustomActor();\n            }\n            const renderer = viewport.getRenderer();\n            const renderWindow = viewport\n                .getRenderingEngine()\n                .getOffscreenMultiRenderWindow(viewportId)\n                .getRenderWindow();\n            const { enabled, viewportCorner, viewportSize, minPixelSize, maxPixelSize, } = this.configuration.orientationWidget;\n            const orientationWidget = vtkOrientationMarkerWidget.newInstance({\n                actor,\n                interactor: renderWindow.getInteractor(),\n                parentRenderer: renderer,\n            });\n            orientationWidget.setEnabled(enabled);\n            orientationWidget.setViewportCorner(viewportCorner);\n            orientationWidget.setViewportSize(viewportSize);\n            orientationWidget.setMinPixelSize(minPixelSize);\n            orientationWidget.setMaxPixelSize(maxPixelSize);\n            orientationWidget.updateMarkerOrientation();\n            this.orientationMarkers[viewportId] = {\n                orientationWidget,\n                actor,\n            };\n            viewport.addWidget(this.getToolName(), orientationWidget);\n            renderWindow.render();\n            viewport.getRenderingEngine().render();\n            this.updatingOrientationMarker[viewportId] = false;\n        }\n    }\n    async createCustomActor() {\n        const url = this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM]\n            .polyDataURL;\n        const response = await fetch(url);\n        const arrayBuffer = await response.arrayBuffer();\n        const vtpReader = vtkXMLPolyDataReader.newInstance();\n        vtpReader.parseAsArrayBuffer(arrayBuffer);\n        vtpReader.update();\n        const polyData = vtkPolyData.newInstance();\n        polyData.shallowCopy(vtpReader.getOutputData());\n        polyData.getPointData().setActiveScalars('Color');\n        const mapper = vtkMapper.newInstance();\n        mapper.setInputData(polyData);\n        mapper.setColorModeToDirectScalars();\n        const actor = vtkActor.newInstance();\n        actor.setMapper(mapper);\n        actor.rotateZ(180);\n        return actor;\n    }\n    createAnnotationCube(overlayConfiguration) {\n        const actor = vtkAnnotatedCubeActor.newInstance();\n        actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });\n        actor.setXPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.xPlus,\n        });\n        actor.setXMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.xMinus,\n        });\n        actor.setYPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.yPlus,\n        });\n        actor.setYMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.yMinus,\n        });\n        actor.setZPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.zPlus,\n        });\n        actor.setZMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.zMinus,\n        });\n        return actor;\n    }\n    async createAnnotatedCubeActor() {\n        const axes = vtkAnnotatedCubeActor.newInstance();\n        const { faceProperties, defaultStyle } = this.configuration.annotatedCube;\n        axes.setDefaultStyle(defaultStyle);\n        Object.keys(faceProperties).forEach((key) => {\n            const methodName = `set${key.charAt(0).toUpperCase() + key.slice(1)}FaceProperty`;\n            axes[methodName](faceProperties[key]);\n        });\n        return axes;\n    }\n}\nOrientationMarkerTool.toolName = 'OrientationMarker';\nexport default OrientationMarkerTool;\n","import { vec3 } from 'gl-matrix';\nimport { metaData, CONSTANTS, getRenderingEngine, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nconst { EPSILON } = CONSTANTS;\nclass OverlayGridTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            sourceImageIds: [],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onSetToolActive = () => {\n            this._init();\n        };\n        this._init = () => {\n            const sourceImageIds = this.configuration.sourceImageIds;\n            if (!sourceImageIds?.length) {\n                console.warn('OverlayGridTool: No sourceImageIds provided in configuration');\n                return;\n            }\n            const imagePlaneModule = metaData.get('imagePlaneModule', sourceImageIds[0]);\n            if (!imagePlaneModule) {\n                console.warn('OverlayGridTool: No imagePlaneModule found for sourceImageIds');\n                return;\n            }\n            const { frameOfReferenceUID } = imagePlaneModule;\n            const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportsInfo?.length) {\n                console.warn('OverlayGridTool: No viewports found');\n                return;\n            }\n            const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n            if (!annotations?.length) {\n                const pointSets = sourceImageIds.map((id) => {\n                    return this.calculateImageIdPointSets(id);\n                });\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        FrameOfReferenceUID: frameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        viewportData: new Map(),\n                        pointSets,\n                    },\n                };\n                addAnnotation(newAnnotation, frameOfReferenceUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        };\n        this.calculateImageIdPointSets = (imageId) => {\n            const { imagePositionPatient, rows, columns, rowCosines, columnCosines, rowPixelSpacing, columnPixelSpacing, } = metaData.get('imagePlaneModule', imageId);\n            const topLeft = [...imagePositionPatient];\n            const topRight = [...imagePositionPatient];\n            const bottomLeft = [...imagePositionPatient];\n            const bottomRight = [...imagePositionPatient];\n            vec3.scaleAndAdd(topRight, imagePositionPatient, columnCosines, columns * columnPixelSpacing);\n            vec3.scaleAndAdd(bottomLeft, imagePositionPatient, rowCosines, rows * rowPixelSpacing);\n            vec3.scaleAndAdd(bottomRight, bottomLeft, columnCosines, columns * columnPixelSpacing);\n            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n            return { pointSet1, pointSet2 };\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const sourceImageIds = this.configuration.sourceImageIds;\n            let renderStatus = false;\n            if (!sourceImageIds?.length) {\n                return renderStatus;\n            }\n            const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;\n            const targetImageIds = targetViewport.getImageIds();\n            if (targetImageIds.length < 2) {\n                return renderStatus;\n            }\n            const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const annotation = annotations[0];\n            const { annotationUID } = annotation;\n            const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const imageIdNormal = (this.getImageIdNormal(sourceImageIds[0]));\n            if (this.isParallel(viewPlaneNormal, imageIdNormal)) {\n                return renderStatus;\n            }\n            const targetViewportPlane = csUtils.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const pointSets = annotation.data.pointSets;\n            const viewportData = annotation.data.viewportData;\n            for (let i = 0; i < sourceImageIds.length; i++) {\n                const { pointSet1, pointSet2 } = pointSets[i];\n                const targetData = viewportData.get(targetViewport.id) ||\n                    this.initializeViewportData(viewportData, targetViewport.id);\n                if (!targetData.pointSetsToUse[i]) {\n                    let pointSetToUse = pointSet1;\n                    let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n                    topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n                    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n                        pointSetToUse = pointSet2;\n                    }\n                    targetData.pointSetsToUse[i] = pointSetToUse;\n                    targetData.lineStartsWorld[i] = csUtils.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);\n                    targetData.lineEndsWorld[i] = csUtils.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);\n                }\n                const lineStartWorld = targetData.lineStartsWorld[i];\n                const lineEndWorld = targetData.lineEndsWorld[i];\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n                const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));\n                const dataId = `${annotationUID}-line`;\n                const lineUID = `${i}`;\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n            }\n            renderStatus = true;\n            return renderStatus;\n        };\n        this.initializeViewportData = (viewportData, id) => {\n            viewportData.set(id, {\n                pointSetsToUse: [],\n                lineStartsWorld: [],\n                lineEndsWorld: [],\n            });\n            return viewportData.get(id);\n        };\n        this.isPerpendicular = (vec1, vec2) => {\n            const dot = vec3.dot(vec1, vec2);\n            return Math.abs(dot) < EPSILON;\n        };\n    }\n    isParallel(vec1, vec2) {\n        return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n    }\n    getImageIdNormal(imageId) {\n        const { imageOrientationPatient } = metaData.get('imagePlaneModule', imageId);\n        const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n        const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n        return vec3.cross(vec3.create(), rowCosineVec, colCosineVec);\n    }\n}\nOverlayGridTool.toolName = 'OverlayGrid';\nexport default OverlayGridTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nclass PanTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            limitToViewport: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    touchDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    mouseDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    _checkImageInViewport(viewport, deltaPointsCanvas) {\n        const { canvas } = viewport;\n        const ratio = window.devicePixelRatio;\n        const viewportLeft = 0;\n        const viewportRight = canvas.width / ratio;\n        const viewportTop = 0;\n        const viewportBottom = canvas.height / ratio;\n        const defaultActor = viewport.getDefaultActor();\n        const renderer = viewport.getRenderer();\n        let bounds;\n        if (defaultActor && csUtils.isImageActor(defaultActor)) {\n            const imageData = defaultActor.actor.getMapper().getInputData();\n            bounds = imageData.getBounds();\n        }\n        else {\n            bounds = renderer.computeVisiblePropBounds();\n        }\n        const [imageLeft, imageTop] = viewport.worldToCanvas([\n            bounds[0],\n            bounds[2],\n            bounds[4],\n        ]);\n        const [imageRight, imageBottom] = viewport.worldToCanvas([\n            bounds[1],\n            bounds[3],\n            bounds[5],\n        ]);\n        const zoom = viewport.getZoom();\n        if (zoom <= 1) {\n            if ((imageLeft + deltaPointsCanvas[0] < viewportLeft &&\n                deltaPointsCanvas[0] < 0) ||\n                (imageRight + deltaPointsCanvas[0] > viewportRight &&\n                    deltaPointsCanvas[0] > 0) ||\n                (imageTop + deltaPointsCanvas[1] < viewportTop &&\n                    deltaPointsCanvas[1] < 0) ||\n                (imageBottom + deltaPointsCanvas[1] > viewportBottom &&\n                    deltaPointsCanvas[1] > 0)) {\n                return false;\n            }\n        }\n        else {\n            if ((imageLeft + deltaPointsCanvas[0] > viewportLeft &&\n                deltaPointsCanvas[0] > 0) ||\n                (imageRight + deltaPointsCanvas[0] < viewportRight &&\n                    deltaPointsCanvas[0] < 0) ||\n                (imageTop + deltaPointsCanvas[1] > viewportTop &&\n                    deltaPointsCanvas[1] > 0) ||\n                (imageBottom + deltaPointsCanvas[1] < viewportBottom &&\n                    deltaPointsCanvas[1] < 0)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _dragCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const deltaPointsWorld = deltaPoints.world;\n        const deltaPointsCanvas = deltaPoints.canvas;\n        if (deltaPointsWorld[0] === 0 &&\n            deltaPointsWorld[1] === 0 &&\n            deltaPointsWorld[2] === 0) {\n            return;\n        }\n        const viewport = enabledElement.viewport;\n        const camera = viewport.getCamera();\n        const { focalPoint, position } = camera;\n        if (this.configuration.limitToViewport &&\n            !this._checkImageInViewport(viewport, deltaPointsCanvas)) {\n            return;\n        }\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        viewport.render();\n    }\n}\nPanTool.toolName = 'Pan';\nexport default PanTool;\n","import { BaseVolumeViewport, getEnabledElement } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport angleBetweenLines from '../utilities/math/angle/angleBetweenLines';\nclass PlanarRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseWheelCallback = (evt) => {\n            const { element, wheel } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { invert } = this.configuration;\n            const angle = wheel.direction * 10 * (invert ? -1 : 1);\n            this.setAngle(viewport, angle);\n        };\n        this.touchDragCallback = this._dragCallback.bind(this);\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    _dragCallback(evt) {\n        const { element, currentPoints, startPoints } = evt.detail;\n        const currentPointWorld = currentPoints.world;\n        const startPointWorld = startPoints.world;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const width = element.clientWidth;\n        const height = element.clientHeight;\n        const centerCanvas = [width * 0.5, height * 0.5];\n        const centerWorld = viewport.canvasToWorld(centerCanvas);\n        let angle = angleBetweenLines([startPointWorld, centerWorld], [centerWorld, currentPointWorld]);\n        const { viewPlaneNormal } = camera;\n        const v1 = vec3.sub(vec3.create(), centerWorld, startPointWorld);\n        const v2 = vec3.sub(vec3.create(), centerWorld, currentPointWorld);\n        const cross = vec3.cross(vec3.create(), v1, v2);\n        if (vec3.dot(viewPlaneNormal, cross) > 0) {\n            angle = -angle;\n        }\n        if (Number.isNaN(angle)) {\n            return;\n        }\n        this.setAngle(viewport, angle);\n    }\n    setAngle(viewport, angle) {\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        if (viewport instanceof BaseVolumeViewport) {\n            const rotAngle = (((angle + 360) % 360) * Math.PI) / 180;\n            const rotMat = mat4.identity(new Float32Array(16));\n            mat4.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);\n            const rotatedViewUp = vec3.transformMat4(vec3.create(), viewUp, rotMat);\n            viewport.setCamera({ viewUp: rotatedViewUp });\n        }\n        else {\n            const { rotation } = viewport.getViewPresentation();\n            viewport.setViewPresentation({\n                rotation: (rotation + angle + 360) % 360,\n            });\n        }\n        viewport.render();\n    }\n}\nPlanarRotateTool.toolName = 'PlanarRotate';\nexport default PlanarRotateTool;\n","import { getEnabledElement, StackViewport, VolumeViewport, utilities, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { drawLine } from '../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { vec3 } from 'gl-matrix';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nimport { getToolGroup } from '../store/ToolGroupManager';\nclass ReferenceCursors extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            displayThreshold: 5,\n            positionSync: true,\n            disableCursor: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isDrawing = false;\n        this.isHandleOutsideImage = false;\n        this._elementWithCursor = null;\n        this._currentCursorWorldPosition = null;\n        this._currentCanvasPosition = null;\n        this._disableCursorEnabled = false;\n        this.mouseMoveCallback = (evt) => {\n            const { detail } = evt;\n            const { element, currentPoints } = detail;\n            this._currentCursorWorldPosition = currentPoints.world;\n            this._currentCanvasPosition = currentPoints.canvas;\n            this._elementWithCursor = element;\n            const annotation = this.getActiveAnnotation(element);\n            if (annotation === null) {\n                this.createInitialAnnotation(currentPoints.world, element);\n                return false;\n            }\n            this.updateAnnotationPosition(element, annotation);\n            return false;\n        };\n        this.createInitialAnnotation = (worldPos, element) => {\n            const enabledElement = getEnabledElement(element);\n            if (!enabledElement) {\n                throw new Error('No enabled element found');\n            }\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            if (!viewPlaneNormal || !viewUp) {\n                throw new Error('Camera not found');\n            }\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        points: [[...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                },\n            };\n            const annotations = getAnnotations(this.getToolName(), element);\n            if (annotations.length > 0) {\n                return null;\n            }\n            const annotationId = addAnnotation(annotation, element);\n            if (annotationId === null) {\n                return;\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.onCameraModified = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, previousCamera, camera } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const viewport = enabledElement.viewport;\n            if (element !== this._elementWithCursor) {\n                return;\n            }\n            const oldFocalPoint = previousCamera.focalPoint;\n            const cameraNormal = camera.viewPlaneNormal;\n            const newFocalPoint = camera.focalPoint;\n            const deltaCameraFocalPoint = [0, 0, 0];\n            vtkMath.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);\n            if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {\n                return;\n            }\n            const dotProduct = vtkMath.dot(deltaCameraFocalPoint, cameraNormal);\n            if (Math.abs(dotProduct) < 1e-2) {\n                return;\n            }\n            if (!this._currentCanvasPosition) {\n                return;\n            }\n            const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);\n            this._currentCursorWorldPosition = newWorldPos;\n            this.updateAnnotationPosition(element, this.getActiveAnnotation(element));\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport, FrameOfReferenceUID } = enabledElement;\n            const isElementWithCursor = this._elementWithCursor === viewport.element;\n            if (this.configuration.positionSync && !isElementWithCursor) {\n                this.updateViewportImage(viewport);\n            }\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points } = handles;\n                if (!annotationUID) {\n                    return renderStatus;\n                }\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidthBase = parseFloat(this.getStyle('lineWidth', styleSpecifier, annotation));\n                const lineWidth = typeof lineWidthBase === 'number' && isElementWithCursor\n                    ? lineWidthBase\n                    : lineWidthBase;\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (points[0].some((e) => isNaN(e))) {\n                    return renderStatus;\n                }\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const crosshairUIDs = {\n                    upper: 'upper',\n                    right: 'right',\n                    lower: 'lower',\n                    left: 'left',\n                };\n                const [x, y] = canvasCoordinates[0];\n                const centerSpace = isElementWithCursor ? 20 : 7;\n                const lineLength = isElementWithCursor ? 5 : 7;\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.upper, [x, y - (centerSpace / 2 + lineLength)], [x, y - centerSpace / 2], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.lower, [x, y + (centerSpace / 2 + lineLength)], [x, y + centerSpace / 2], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.right, [x + (centerSpace / 2 + lineLength), y], [x + centerSpace / 2, y], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.left, [x - (centerSpace / 2 + lineLength), y], [x - centerSpace / 2, y], { color, lineDash, lineWidth });\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this._disableCursorEnabled = this.configuration.disableCursor;\n    }\n    onSetToolActive() {\n        this._disableCursorEnabled = this.configuration.disableCursor;\n        if (!this._disableCursorEnabled) {\n            return;\n        }\n        const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n        if (!viewportIds) {\n            return;\n        }\n        const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n        enabledElements.forEach((element) => {\n            if (element) {\n                hideElementCursor(element.viewport.element);\n            }\n        });\n    }\n    onSetToolDisabled() {\n        if (!this._disableCursorEnabled) {\n            return;\n        }\n        const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n        if (!viewportIds) {\n            return;\n        }\n        const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n        enabledElements.forEach((element) => {\n            if (element) {\n                resetElementCursor(element.viewport.element);\n            }\n        });\n    }\n    getActiveAnnotation(element) {\n        const annotations = getAnnotations(this.getToolName(), element);\n        if (!annotations.length) {\n            return null;\n        }\n        const targetAnnotation = annotations[0];\n        return targetAnnotation;\n    }\n    updateAnnotationPosition(element, annotation) {\n        const worldPos = this._currentCursorWorldPosition;\n        if (!worldPos) {\n            return;\n        }\n        if (!annotation.data?.handles?.points) {\n            return;\n        }\n        annotation.data.handles.points = [[...worldPos]];\n        annotation.invalidated = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!(annotations instanceof Array) || annotations.length === 0) {\n            return [];\n        }\n        const annotation = annotations[0];\n        const viewport = getEnabledElement(element)?.viewport;\n        if (!viewport) {\n            return [];\n        }\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, focalPoint } = camera;\n        if (!viewPlaneNormal || !focalPoint) {\n            return [];\n        }\n        const points = annotation.data?.handles?.points;\n        if (!(points instanceof Array) || points.length !== 1) {\n            return [];\n        }\n        const worldPos = points[0];\n        const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n        const distance = utilities.planar.planeDistanceToPoint(plane, worldPos);\n        return distance < this.configuration.displayThreshold ? [annotation] : [];\n    }\n    updateViewportImage(viewport) {\n        const currentMousePosition = this._currentCursorWorldPosition;\n        if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {\n            return;\n        }\n        if (viewport instanceof StackViewport) {\n            const closestIndex = utilities.getClosestStackImageIndexForPoint(currentMousePosition, viewport);\n            if (closestIndex === null) {\n                return;\n            }\n            if (closestIndex !== viewport.getCurrentImageIdIndex()) {\n                viewport.setImageIdIndex(closestIndex);\n            }\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const { focalPoint, viewPlaneNormal } = viewport.getCamera();\n            if (!focalPoint || !viewPlaneNormal) {\n                return;\n            }\n            const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const currentDistance = utilities.planar.planeDistanceToPoint(plane, currentMousePosition, true);\n            if (Math.abs(currentDistance) < 0.5) {\n                return;\n            }\n            const normalizedViewPlane = vec3.normalize(vec3.create(), vec3.fromValues(...viewPlaneNormal));\n            const scaledPlaneNormal = vec3.scale(vec3.create(), normalizedViewPlane, currentDistance);\n            const newFocalPoint = vec3.add(vec3.create(), vec3.fromValues(...focalPoint), scaledPlaneNormal);\n            const isInBounds = true;\n            if (isInBounds) {\n                viewport.setCamera({ focalPoint: newFocalPoint });\n                const renderingEngine = viewport.getRenderingEngine();\n                if (renderingEngine) {\n                    renderingEngine.renderViewport(viewport.id);\n                }\n            }\n        }\n    }\n}\nReferenceCursors.toolName = 'ReferenceCursors';\nexport default ReferenceCursors;\n","import { vec3 } from 'gl-matrix';\nimport { getRenderingEngines, CONSTANTS, utilities as csUtils, } from '@cornerstonejs/core';\nimport { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nconst { EPSILON } = CONSTANTS;\nclass ReferenceLines extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            sourceViewportId: '',\n            enforceSameFrameOfReference: true,\n            showFullDimension: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.editData = null;\n        this._init = () => {\n            const renderingEngines = getRenderingEngines();\n            const renderingEngine = renderingEngines[0];\n            if (!renderingEngine) {\n                return;\n            }\n            let viewports = renderingEngine.getViewports();\n            viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n            const sourceViewport = renderingEngine.getViewport(this.configuration.sourceViewportId);\n            if (!sourceViewport?.getImageData()) {\n                return;\n            }\n            const { element } = sourceViewport;\n            const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();\n            const sourceViewportCanvasCornersInWorld = csUtils.getViewportImageCornersInWorld(sourceViewport);\n            let annotation = this.editData?.annotation;\n            const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();\n            if (!annotation) {\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        viewPlaneNormal: [...viewPlaneNormal],\n                        viewUp: [...viewUp],\n                        FrameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        handles: {\n                            points: sourceViewportCanvasCornersInWorld,\n                        },\n                    },\n                };\n                addAnnotation(newAnnotation, element);\n                annotation = newAnnotation;\n            }\n            else {\n                this.editData.annotation.data.handles.points =\n                    sourceViewportCanvasCornersInWorld;\n            }\n            this.editData = {\n                sourceViewportId: sourceViewport.id,\n                renderingEngine,\n                annotation,\n            };\n            triggerAnnotationRenderForViewportIds(viewports\n                .filter((viewport) => viewport.id !== sourceViewport.id)\n                .map((viewport) => viewport.id));\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onSetToolConfiguration = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this._init();\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const { viewport: targetViewport } = enabledElement;\n            if (!this.editData) {\n                return false;\n            }\n            const { annotation, sourceViewportId } = this.editData;\n            let renderStatus = false;\n            const { viewport: sourceViewport } = getEnabledElementByViewportId(sourceViewportId) || {};\n            if (!sourceViewport) {\n                return renderStatus;\n            }\n            if (sourceViewport.id === targetViewport.id) {\n                return renderStatus;\n            }\n            if (!annotation || !annotation?.data?.handles?.points) {\n                return renderStatus;\n            }\n            if (this.configuration.enforceSameFrameOfReference &&\n                sourceViewport.getFrameOfReferenceUID() !==\n                    targetViewport.getFrameOfReferenceUID()) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const topLeft = annotation.data.handles.points[0];\n            const topRight = annotation.data.handles.points[1];\n            const bottomLeft = annotation.data.handles.points[2];\n            const bottomRight = annotation.data.handles.points[3];\n            const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();\n            const { viewPlaneNormal: sourceViewPlaneNormal } = sourceViewport.getCamera();\n            if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {\n                return renderStatus;\n            }\n            const targetViewportPlane = csUtils.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n            let pointSetToUse = pointSet1;\n            let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n            topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n            let topRightVec = vec3.subtract(vec3.create(), pointSet1[2], pointSet1[0]);\n            topRightVec = vec3.normalize(vec3.create(), topRightVec);\n            const newNormal = vec3.cross(vec3.create(), topBottomVec, topRightVec);\n            if (this.isParallel(newNormal, viewPlaneNormal)) {\n                return renderStatus;\n            }\n            if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n                pointSetToUse = pointSet2;\n            }\n            const lineStartWorld = csUtils.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);\n            const lineEndWorld = csUtils.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);\n            const { annotationUID } = annotation;\n            styleSpecifier.annotationUID = annotationUID;\n            const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n            const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n            const color = this.getStyle('color', styleSpecifier, annotation);\n            const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n            let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));\n            if (this.configuration.showFullDimension) {\n                canvasCoordinates = this.handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates);\n            }\n            if (canvasCoordinates.length < 2) {\n                return renderStatus;\n            }\n            const dataId = `${annotationUID}-line`;\n            const lineUID = '1';\n            drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                color,\n                width: lineWidth,\n                lineDash,\n                shadow,\n            }, dataId);\n            renderStatus = true;\n            return renderStatus;\n        };\n        this.isPerpendicular = (vec1, vec2) => {\n            const dot = vec3.dot(vec1, vec2);\n            return Math.abs(dot) < EPSILON;\n        };\n    }\n    handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates) {\n        const renderingEngine = targetViewport.getRenderingEngine();\n        const targetId = this.getTargetId(targetViewport);\n        const targetImage = this.getTargetImageData(targetId);\n        const referencedImageId = this.getReferencedImageId(targetViewport, lineStartWorld, viewPlaneNormal, viewUp);\n        if (referencedImageId && targetImage) {\n            try {\n                const { imageData, dimensions } = targetImage;\n                const [topLeftImageCoord, topRightImageCoord, bottomRightImageCoord, bottomLeftImageCoord,] = [\n                    imageData.indexToWorld([0, 0, 0]),\n                    imageData.indexToWorld([dimensions[0] - 1, 0, 0]),\n                    imageData.indexToWorld([\n                        dimensions[0] - 1,\n                        dimensions[1] - 1,\n                        0,\n                    ]),\n                    imageData.indexToWorld([0, dimensions[1] - 1, 0]),\n                ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n                const [lineStartImageCoord, lineEndImageCoord] = [\n                    lineStartWorld,\n                    lineEndWorld,\n                ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n                canvasCoordinates = [\n                    [topLeftImageCoord, topRightImageCoord],\n                    [topRightImageCoord, bottomRightImageCoord],\n                    [bottomLeftImageCoord, bottomRightImageCoord],\n                    [topLeftImageCoord, bottomLeftImageCoord],\n                ]\n                    .map(([start, end]) => this.intersectInfiniteLines(start, end, lineStartImageCoord, lineEndImageCoord))\n                    .filter((point) => point && this.isInBound(point, dimensions))\n                    .map((point) => {\n                    const world = csUtils.imageToWorldCoords(referencedImageId, point);\n                    return targetViewport.worldToCanvas(world);\n                });\n            }\n            catch (err) {\n                console.log(err);\n            }\n        }\n        return canvasCoordinates;\n    }\n    intersectInfiniteLines(line1Start, line1End, line2Start, line2End) {\n        const [x1, y1] = line1Start;\n        const [x2, y2] = line1End;\n        const [x3, y3] = line2Start;\n        const [x4, y4] = line2End;\n        const a1 = y2 - y1;\n        const b1 = x1 - x2;\n        const c1 = x2 * y1 - x1 * y2;\n        const a2 = y4 - y3;\n        const b2 = x3 - x4;\n        const c2 = x4 * y3 - x3 * y4;\n        if (Math.abs(a1 * b2 - a2 * b1) < EPSILON) {\n            return;\n        }\n        const x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n        const y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);\n        return [x, y];\n    }\n    isParallel(vec1, vec2) {\n        return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n    }\n    isInBound(point, dimensions) {\n        return (point[0] >= 0 &&\n            point[0] <= dimensions[0] &&\n            point[1] >= 0 &&\n            point[1] <= dimensions[1]);\n    }\n}\nReferenceLines.toolName = 'ReferenceLines';\nexport default ReferenceLines;\n","import AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { vec3 } from 'gl-matrix';\nimport { getEnabledElementByIds, getRenderingEngines, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { drawLine as drawLineSvg, drawTextBox as drawTextBoxSvg, } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nconst viewportsWithAnnotations = [];\nclass ScaleOverlayTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            viewportId: '',\n            scaleLocation: 'bottom',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.editData = null;\n        this._init = () => {\n            const renderingEngines = getRenderingEngines();\n            const renderingEngine = renderingEngines[0];\n            if (!renderingEngine) {\n                return;\n            }\n            const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportIds) {\n                return;\n            }\n            const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n            let { viewport } = enabledElements[0];\n            const { FrameOfReferenceUID } = enabledElements[0];\n            if (this.configuration.viewportId) {\n                enabledElements.forEach((element) => {\n                    if (element.viewport.id == this.configuration.viewportId) {\n                        viewport = element.viewport;\n                    }\n                });\n            }\n            if (!viewport) {\n                return;\n            }\n            const { viewUp, viewPlaneNormal } = viewport.getCamera();\n            const viewportCanvasCornersInWorld = csUtils.getViewportImageCornersInWorld(viewport);\n            let annotation = this.editData?.annotation;\n            const annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (annotations.length) {\n                annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];\n            }\n            enabledElements.forEach((element) => {\n                const { viewport } = element;\n                if (!viewportsWithAnnotations.includes(viewport.id)) {\n                    const newAnnotation = {\n                        metadata: {\n                            toolName: this.getToolName(),\n                            viewPlaneNormal: [...viewPlaneNormal],\n                            viewUp: [...viewUp],\n                            FrameOfReferenceUID,\n                            referencedImageId: null,\n                        },\n                        data: {\n                            handles: {\n                                points: csUtils.getViewportImageCornersInWorld(viewport),\n                            },\n                            viewportId: viewport.id,\n                        },\n                    };\n                    viewportsWithAnnotations.push(viewport.id);\n                    addAnnotation(newAnnotation, viewport.element);\n                    annotation = newAnnotation;\n                }\n            });\n            if (this.editData?.annotation &&\n                this.editData.annotation.data.viewportId == viewport.id) {\n                this.editData.annotation.data.handles.points =\n                    viewportCanvasCornersInWorld;\n                this.editData.annotation.data.viewportId = viewport.id;\n            }\n            this.editData = {\n                viewport,\n                renderingEngine,\n                annotation,\n            };\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this.configuration.viewportId = evt.detail.viewportId;\n            this._init();\n        };\n        this.computeScaleSize = (worldWidthViewport, worldHeightViewport, location) => {\n            const scaleSizes = [\n                16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,\n            ];\n            let currentScaleSize;\n            if (location == 'top' || location == 'bottom') {\n                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldWidthViewport * 0.6 &&\n                    scaleSize > worldWidthViewport * 0.2);\n            }\n            else {\n                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldHeightViewport * 0.6 &&\n                    scaleSize > worldHeightViewport * 0.2);\n            }\n            return currentScaleSize[0];\n        };\n        this.computeEndScaleTicks = (canvasCoordinates, location) => {\n            const locationTickOffset = {\n                bottom: [\n                    [0, -10],\n                    [0, -10],\n                ],\n                top: [\n                    [0, 10],\n                    [0, 10],\n                ],\n                left: [\n                    [0, 0],\n                    [10, 0],\n                ],\n                right: [\n                    [0, 0],\n                    [-10, 0],\n                ],\n            };\n            const endTick1 = [\n                [\n                    canvasCoordinates[1][0] + locationTickOffset[location][0][0],\n                    canvasCoordinates[1][1] + locationTickOffset[location][0][0],\n                ],\n                [\n                    canvasCoordinates[1][0] + locationTickOffset[location][1][0],\n                    canvasCoordinates[1][1] + locationTickOffset[location][1][1],\n                ],\n            ];\n            const endTick2 = [\n                [\n                    canvasCoordinates[0][0] + locationTickOffset[location][0][0],\n                    canvasCoordinates[0][1] + locationTickOffset[location][0][0],\n                ],\n                [\n                    canvasCoordinates[0][0] + locationTickOffset[location][1][0],\n                    canvasCoordinates[0][1] + locationTickOffset[location][1][1],\n                ],\n            ];\n            return {\n                endTick1: endTick1,\n                endTick2: endTick2,\n            };\n        };\n        this.computeInnerScaleTicks = (scaleSize, location, annotationUID, leftTick, rightTick) => {\n            let canvasScaleSize;\n            if (location == 'bottom' || location == 'top') {\n                canvasScaleSize = rightTick[0][0] - leftTick[0][0];\n            }\n            else if (location == 'left' || location == 'right') {\n                canvasScaleSize = rightTick[0][1] - leftTick[0][1];\n            }\n            const tickIds = [];\n            const tickUIDs = [];\n            const tickCoordinates = [];\n            let numberSmallTicks = scaleSize;\n            if (scaleSize >= 50) {\n                numberSmallTicks = scaleSize / 10;\n            }\n            const tickSpacing = canvasScaleSize / numberSmallTicks;\n            for (let i = 0; i < numberSmallTicks - 1; i++) {\n                const locationOffset = {\n                    bottom: [\n                        [tickSpacing * (i + 1), 0],\n                        [tickSpacing * (i + 1), 5],\n                    ],\n                    top: [\n                        [tickSpacing * (i + 1), 0],\n                        [tickSpacing * (i + 1), -5],\n                    ],\n                    left: [\n                        [0, tickSpacing * (i + 1)],\n                        [-5, tickSpacing * (i + 1)],\n                    ],\n                    right: [\n                        [0, tickSpacing * (i + 1)],\n                        [5, tickSpacing * (i + 1)],\n                    ],\n                };\n                tickIds.push(`${annotationUID}-tick${i}`);\n                tickUIDs.push(`tick${i}`);\n                if ((i + 1) % 5 == 0) {\n                    tickCoordinates.push([\n                        [\n                            leftTick[0][0] + locationOffset[location][0][0],\n                            leftTick[0][1] + locationOffset[location][0][1],\n                        ],\n                        [\n                            leftTick[1][0] + locationOffset[location][0][0],\n                            leftTick[1][1] + locationOffset[location][0][1],\n                        ],\n                    ]);\n                }\n                else {\n                    tickCoordinates.push([\n                        [\n                            leftTick[0][0] + locationOffset[location][0][0],\n                            leftTick[0][1] + locationOffset[location][0][1],\n                        ],\n                        [\n                            leftTick[1][0] + locationOffset[location][1][0],\n                            leftTick[1][1] + locationOffset[location][1][1],\n                        ],\n                    ]);\n                }\n            }\n            return { tickIds, tickUIDs, tickCoordinates };\n        };\n        this.computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {\n            let worldCoordinates;\n            let topBottomVec = vec3.subtract(vec3.create(), pointSet[0], pointSet[1]);\n            topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n            let topRightVec = vec3.subtract(vec3.create(), pointSet[2], pointSet[0]);\n            topRightVec = vec3.normalize(vec3.create(), topRightVec);\n            const midpointLocation = {\n                bottom: [pointSet[1], pointSet[2]],\n                top: [pointSet[0], pointSet[3]],\n                right: [pointSet[2], pointSet[3]],\n                left: [pointSet[0], pointSet[1]],\n            };\n            const midpoint = vec3\n                .add(vec3.create(), midpointLocation[location][0], midpointLocation[location][0])\n                .map((i) => i / 2);\n            const offset = scaleSize /\n                2 /\n                Math.sqrt(Math.pow(topBottomVec[0], 2) +\n                    Math.pow(topBottomVec[1], 2) +\n                    Math.pow(topBottomVec[2], 2));\n            if (location == 'top' || location == 'bottom') {\n                worldCoordinates = [\n                    vec3.subtract(vec3.create(), midpoint, topRightVec.map((i) => i * offset)),\n                    vec3.add(vec3.create(), midpoint, topRightVec.map((i) => i * offset)),\n                ];\n            }\n            else if (location == 'left' || location == 'right') {\n                worldCoordinates = [\n                    vec3.add(vec3.create(), midpoint, topBottomVec.map((i) => i * offset)),\n                    vec3.subtract(vec3.create(), midpoint, topBottomVec.map((i) => i * offset)),\n                ];\n            }\n            return worldCoordinates;\n        };\n        this.computeCanvasScaleCoordinates = (canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location) => {\n            let scaleCanvasCoordinates;\n            if (location == 'top' || location == 'bottom') {\n                const worldDistanceOnCanvas = canvasCoordinates[0][0] - canvasCoordinates[1][0];\n                scaleCanvasCoordinates = [\n                    [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],\n                    [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],\n                ];\n            }\n            else if (location == 'left' || location == 'right') {\n                const worldDistanceOnCanvas = canvasCoordinates[0][1] - canvasCoordinates[1][1];\n                scaleCanvasCoordinates = [\n                    [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],\n                    [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],\n                ];\n            }\n            return scaleCanvasCoordinates;\n        };\n        this.computeScaleBounds = (canvasSize, horizontalReduction, verticalReduction, location) => {\n            const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);\n            const vReduction = verticalReduction * Math.min(1000, canvasSize.height);\n            const locationBounds = {\n                bottom: [-vReduction, -hReduction],\n                top: [vReduction, hReduction],\n                left: [vReduction, hReduction],\n                right: [-vReduction, -hReduction],\n            };\n            const canvasBounds = {\n                bottom: [canvasSize.height, canvasSize.width],\n                top: [0, canvasSize.width],\n                left: [canvasSize.height, 0],\n                right: [canvasSize.height, canvasSize.width],\n            };\n            return {\n                height: canvasBounds[location][0] + locationBounds[location][0],\n                width: canvasBounds[location][1] + locationBounds[location][1],\n            };\n        };\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this.editData || !this.editData.viewport) {\n            return;\n        }\n        const location = this.configuration.scaleLocation;\n        const { viewport } = enabledElement;\n        const annotations = getAnnotations(this.getToolName(), viewport.element);\n        const annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];\n        const canvas = enabledElement.viewport.canvas;\n        const renderStatus = false;\n        if (!viewport) {\n            return renderStatus;\n        }\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        const canvasSize = {\n            width: canvas.width / window.devicePixelRatio || 1,\n            height: canvas.height / window.devicePixelRatio || 1,\n        };\n        const topLeft = annotation.data.handles.points[0];\n        const topRight = annotation.data.handles.points[1];\n        const bottomLeft = annotation.data.handles.points[2];\n        const bottomRight = annotation.data.handles.points[3];\n        const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n        const worldWidthViewport = vec3.distance(bottomLeft, bottomRight);\n        const worldHeightViewport = vec3.distance(topLeft, bottomLeft);\n        const hscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);\n        const vscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);\n        const scaleSize = this.computeScaleSize(worldWidthViewport, worldHeightViewport, location);\n        const canvasCoordinates = this.computeWorldScaleCoordinates(scaleSize, location, pointSet1).map((world) => viewport.worldToCanvas(world));\n        const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location);\n        const scaleTicks = this.computeEndScaleTicks(scaleCanvasCoordinates, location);\n        const { annotationUID } = annotation;\n        styleSpecifier.annotationUID = annotationUID;\n        const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n        const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n        const color = this.getStyle('color', styleSpecifier, annotation);\n        const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n        const scaleId = `${annotationUID}-scaleline`;\n        const scaleLineUID = '1';\n        drawLineSvg(svgDrawingHelper, annotationUID, scaleLineUID, scaleCanvasCoordinates[0], scaleCanvasCoordinates[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, scaleId);\n        const leftTickId = `${annotationUID}-left`;\n        const leftTickUID = '2';\n        drawLineSvg(svgDrawingHelper, annotationUID, leftTickUID, scaleTicks.endTick1[0], scaleTicks.endTick1[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, leftTickId);\n        const rightTickId = `${annotationUID}-right`;\n        const rightTickUID = '3';\n        drawLineSvg(svgDrawingHelper, annotationUID, rightTickUID, scaleTicks.endTick2[0], scaleTicks.endTick2[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, rightTickId);\n        const locationTextOffest = {\n            bottom: [-10, -42],\n            top: [-12, -35],\n            left: [-40, -20],\n            right: [-50, -20],\n        };\n        const textCanvasCoordinates = [\n            scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],\n            scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],\n        ];\n        const textBoxLines = this._getTextLines(scaleSize);\n        const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(scaleSize, location, annotationUID, scaleTicks.endTick1, scaleTicks.endTick2);\n        for (let i = 0; i < tickUIDs.length; i++) {\n            drawLineSvg(svgDrawingHelper, annotationUID, tickUIDs[i], tickCoordinates[i][0], tickCoordinates[i][1], {\n                color,\n                width: lineWidth,\n                lineDash,\n                shadow,\n            }, tickIds[i]);\n        }\n        const textUID = 'text0';\n        drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textBoxLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], {\n            fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n            fontSize: '14px',\n            lineDash: '2,3',\n            lineWidth: '1',\n            shadow: true,\n            color: color,\n        });\n        return renderStatus;\n    }\n    _getTextLines(scaleSize) {\n        let scaleSizeDisplayValue;\n        let scaleSizeUnits;\n        if (scaleSize >= 50) {\n            scaleSizeDisplayValue = scaleSize / 10;\n            scaleSizeUnits = ' cm';\n        }\n        else {\n            scaleSizeDisplayValue = scaleSize;\n            scaleSizeUnits = ' mm';\n        }\n        const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];\n        return textLines;\n    }\n}\nScaleOverlayTool.toolName = 'ScaleOverlay';\nexport default ScaleOverlayTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { getAnnotations } from '../stateManagement';\nimport { point } from '../utilities/math';\nimport { Events, ToolModes, AnnotationStyleStates, ChangeTypes, } from '../enums';\nimport { triggerAnnotationRenderForViewportIds } from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\nimport { triggerAnnotationModified } from '../stateManagement/annotation/helpers/state';\nimport CircleSculptCursor from './SculptorTool/CircleSculptCursor';\nimport { distancePointToContour } from './distancePointToContour';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass SculptorTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            minSpacing: 1,\n            referencedToolNames: [\n                'PlanarFreehandROI',\n                'PlanarFreehandContourSegmentationTool',\n            ],\n            toolShape: 'circle',\n            referencedToolName: 'PlanarFreehandROI',\n            updateCursorSize: 'dynamic',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.registeredShapes = new Map();\n        this.isActive = false;\n        this.commonData = {\n            activeAnnotationUID: null,\n            viewportIdsToRender: [],\n            isEditingOpenContour: false,\n            canvasLocation: undefined,\n        };\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const element = eventData.element;\n            this.configureToolSize(evt);\n            this.selectFreehandTool(eventData);\n            if (this.commonData.activeAnnotationUID === null) {\n                return;\n            }\n            this.isActive = true;\n            hideElementCursor(element);\n            this.activateModify(element);\n            return true;\n        };\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode === ToolModes.Active) {\n                this.configureToolSize(evt);\n                this.updateCursor(evt);\n            }\n            else {\n                this.commonData.canvasLocation = undefined;\n            }\n        };\n        this.endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const config = this.configuration;\n            const enabledElement = getEnabledElement(element);\n            this.isActive = false;\n            this.deactivateModify(element);\n            resetElementCursor(element);\n            const { renderingEngineId, viewportId } = enabledElement;\n            const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n            const toolInstance = toolGroup.getToolInstance(config.referencedToolName);\n            const annotations = this.filterSculptableAnnotationsForElement(element);\n            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n            if (toolInstance.configuration.calculateStats) {\n                activeAnnotation.invalidated = true;\n            }\n            triggerAnnotationModified(activeAnnotation, element, ChangeTypes.HandlesUpdated);\n        };\n        this.dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const element = eventData.element;\n            this.updateCursor(evt);\n            const annotations = this.filterSculptableAnnotationsForElement(element);\n            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n            if (!annotations?.length || !this.isActive) {\n                return;\n            }\n            const points = activeAnnotation.data.contour.polyline;\n            this.sculpt(eventData, points);\n        };\n        this.registerShapes(CircleSculptCursor.shapeName, CircleSculptCursor);\n        this.setToolShape(this.configuration.toolShape);\n    }\n    registerShapes(shapeName, shapeClass) {\n        const shape = new shapeClass();\n        this.registeredShapes.set(shapeName, shape);\n    }\n    sculpt(eventData, points) {\n        const config = this.configuration;\n        const element = eventData.element;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        this.sculptData = {\n            mousePoint: eventData.currentPoints.world,\n            mouseCanvasPoint: eventData.currentPoints.canvas,\n            deltaWorld: eventData.deltaPoints.world,\n            points,\n            maxSpacing: cursorShape.getMaxSpacing(config.minSpacing),\n            element: element,\n        };\n        const pushedHandles = cursorShape.pushHandles(viewport, this.sculptData);\n        if (pushedHandles.first !== undefined) {\n            this.insertNewHandles(pushedHandles);\n        }\n    }\n    interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing) {\n        const { element } = this.sculptData;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const nextHandleIndex = contourIndex(i + 1, points.length);\n        const currentCanvasPoint = viewport.worldToCanvas(points[i]);\n        const nextCanvasPoint = viewport.worldToCanvas(points[nextHandleIndex]);\n        const distanceToNextHandle = point.distanceToPoint(currentCanvasPoint, nextCanvasPoint);\n        if (distanceToNextHandle > maxSpacing) {\n            indicesToInsertAfter.push(i);\n        }\n    }\n    updateCursor(evt) {\n        const eventData = evt.detail;\n        const element = eventData.element;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine, viewport } = enabledElement;\n        this.commonData.viewportIdsToRender = [viewport.id];\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n        this.commonData.canvasLocation = eventData.currentPoints.canvas;\n        if (this.isActive) {\n            activeAnnotation.highlighted = true;\n        }\n        else {\n            const cursorShape = this.registeredShapes.get(this.selectedShape);\n            const canvasCoords = eventData.currentPoints.canvas;\n            if (this.configuration.updateCursorSize === 'dynamic') {\n                cursorShape.updateToolSize(canvasCoords, viewport, activeAnnotation);\n            }\n        }\n        triggerAnnotationRenderForViewportIds(this.commonData.viewportIdsToRender);\n    }\n    filterSculptableAnnotationsForElement(element) {\n        const config = this.configuration;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngineId, viewportId } = enabledElement;\n        const sculptableAnnotations = [];\n        const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n        const toolInstance = toolGroup.getToolInstance(config.referencedToolName);\n        config.referencedToolNames.forEach((referencedToolName) => {\n            const annotations = getAnnotations(referencedToolName, element);\n            if (annotations) {\n                sculptableAnnotations.push(...annotations);\n            }\n        });\n        return toolInstance.filterInteractableAnnotationsForElement(element, sculptableAnnotations);\n    }\n    configureToolSize(evt) {\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        cursorShape.configureToolSize(evt);\n    }\n    insertNewHandles(pushedHandles) {\n        const indicesToInsertAfter = this.findNewHandleIndices(pushedHandles);\n        let newIndexModifier = 0;\n        for (let i = 0; i < indicesToInsertAfter?.length; i++) {\n            const insertIndex = indicesToInsertAfter[i] + 1 + newIndexModifier;\n            this.insertHandleRadially(insertIndex);\n            newIndexModifier++;\n        }\n    }\n    findNewHandleIndices(pushedHandles) {\n        const { points, maxSpacing } = this.sculptData;\n        const indicesToInsertAfter = [];\n        for (let i = pushedHandles.first; i <= pushedHandles.last; i++) {\n            this.interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing);\n        }\n        return indicesToInsertAfter;\n    }\n    insertHandleRadially(insertIndex) {\n        const { points } = this.sculptData;\n        if (insertIndex > points.length - 1 &&\n            this.commonData.isEditingOpenContour) {\n            return;\n        }\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        const previousIndex = insertIndex - 1;\n        const nextIndex = contourIndex(insertIndex, points.length);\n        const insertPosition = cursorShape.getInsertPosition(previousIndex, nextIndex, this.sculptData);\n        const handleData = insertPosition;\n        points.splice(insertIndex, 0, handleData);\n    }\n    selectFreehandTool(eventData) {\n        const closestAnnotationUID = this.getClosestFreehandToolOnElement(eventData);\n        if (closestAnnotationUID === undefined) {\n            return;\n        }\n        this.commonData.activeAnnotationUID = closestAnnotationUID;\n    }\n    getClosestFreehandToolOnElement(eventData) {\n        const { element } = eventData;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const config = this.configuration;\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const canvasPoints = eventData.currentPoints.canvas;\n        const closest = {\n            distance: Infinity,\n            toolIndex: undefined,\n            annotationUID: undefined,\n        };\n        for (let i = 0; i < annotations?.length; i++) {\n            if (annotations[i].isLocked || !annotations[i].isVisible) {\n                continue;\n            }\n            const distanceFromTool = distancePointToContour(viewport, annotations[i], canvasPoints);\n            if (distanceFromTool === -1) {\n                continue;\n            }\n            if (distanceFromTool < closest.distance) {\n                closest.distance = distanceFromTool;\n                closest.toolIndex = i;\n                closest.annotationUID = annotations[i].annotationUID;\n            }\n        }\n        this.commonData.isEditingOpenContour =\n            !annotations[closest.toolIndex].data.contour.closed;\n        config.referencedToolName =\n            annotations[closest.toolIndex].metadata.toolName;\n        return closest.annotationUID;\n    }\n    activateModify(element) {\n        element.addEventListener(Events.MOUSE_UP, this.endCallback);\n        element.addEventListener(Events.MOUSE_CLICK, this.endCallback);\n        element.addEventListener(Events.MOUSE_DRAG, this.dragCallback);\n        element.addEventListener(Events.TOUCH_TAP, this.endCallback);\n        element.addEventListener(Events.TOUCH_END, this.endCallback);\n        element.addEventListener(Events.TOUCH_DRAG, this.dragCallback);\n    }\n    deactivateModify(element) {\n        element.removeEventListener(Events.MOUSE_UP, this.endCallback);\n        element.removeEventListener(Events.MOUSE_CLICK, this.endCallback);\n        element.removeEventListener(Events.MOUSE_DRAG, this.dragCallback);\n        element.removeEventListener(Events.TOUCH_TAP, this.endCallback);\n        element.removeEventListener(Events.TOUCH_END, this.endCallback);\n        element.removeEventListener(Events.TOUCH_DRAG, this.dragCallback);\n    }\n    setToolShape(toolShape) {\n        this.selectedShape =\n            this.registeredShapes.get(toolShape) ?? CircleSculptCursor.shapeName;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const viewportIdsToRender = this.commonData.viewportIdsToRender;\n        if (!this.commonData.canvasLocation ||\n            this.mode !== ToolModes.Active ||\n            !viewportIdsToRender.includes(viewport.id)) {\n            return;\n        }\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        let color = getStyleProperty('color', styleSpecifier, AnnotationStyleStates.Default, this.mode);\n        if (this.isActive) {\n            color = getStyleProperty('color', styleSpecifier, AnnotationStyleStates.Highlighted, this.mode);\n        }\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        cursorShape.renderShape(svgDrawingHelper, this.commonData.canvasLocation, {\n            color,\n        });\n    }\n}\nexport const contourIndex = (i, length) => {\n    return (i + length) % length;\n};\nSculptorTool.toolName = 'SculptorTool';\nexport default SculptorTool;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { drawPath } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { pointToString } from '../utilities/pointToString';\nimport { polyDataUtils } from '../utilities';\nclass SegmentationIntersectionTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            opacity: 0.5,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._init = () => {\n            const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportsInfo?.length) {\n                console.warn(this.getToolName() + 'Tool: No viewports found');\n                return;\n            }\n            const firstViewport = getRenderingEngine(viewportsInfo[0].renderingEngineId)?.getViewport(viewportsInfo[0].viewportId);\n            if (!firstViewport) {\n                return;\n            }\n            const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();\n            const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n            if (!annotations?.length) {\n                const actorsWorldPointsMap = new Map();\n                calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo);\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        FrameOfReferenceUID: frameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        actorsWorldPointsMap,\n                    },\n                };\n                addAnnotation(newAnnotation, frameOfReferenceUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this._init();\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const { viewport, FrameOfReferenceUID } = enabledElement;\n            let renderStatus = false;\n            const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const annotation = annotations[0];\n            const { annotationUID } = annotation;\n            const actorsWorldPointsMap = (annotation).data.actorsWorldPointsMap;\n            calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);\n            const actorEntries = viewport.getActors();\n            const cacheId = getCacheId(viewport);\n            actorEntries.forEach((actorEntry) => {\n                if (!actorEntry?.clippingFilter) {\n                    return;\n                }\n                const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);\n                if (!actorWorldPointMap) {\n                    return;\n                }\n                if (!actorWorldPointMap.get(cacheId)) {\n                    return;\n                }\n                let polyLineIdx = 1;\n                const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);\n                for (let i = 0; i < worldPointsSet.length; i++) {\n                    const worldPoints = worldPointsSet[i];\n                    const canvasPoints = worldPoints.map((point) => viewport.worldToCanvas(point));\n                    const options = {\n                        color: color,\n                        fillColor: color,\n                        fillOpacity: this.configuration.opacity,\n                        closePath: true,\n                        lineWidth: 2,\n                    };\n                    const polyLineUID = actorEntry.uid + '#' + polyLineIdx;\n                    drawPath(svgDrawingHelper, annotationUID, polyLineUID, canvasPoints, options);\n                    polyLineIdx++;\n                }\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nfunction calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo) {\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n        const viewport = getRenderingEngine(renderingEngineId)?.getViewport(viewportId);\n        calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);\n    });\n}\nfunction calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport) {\n    const actorEntries = viewport.getActors();\n    const cacheId = getCacheId(viewport);\n    actorEntries.forEach((actorEntry) => {\n        if (!actorEntry?.clippingFilter) {\n            return;\n        }\n        let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);\n        if (!actorWorldPointsMap) {\n            actorWorldPointsMap = new Map();\n            actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);\n        }\n        if (!actorWorldPointsMap.get(cacheId)) {\n            const polyData = actorEntry.clippingFilter.getOutputData();\n            const worldPointsSet = polyDataUtils.getPolyDataPoints(polyData);\n            if (!worldPointsSet) {\n                return;\n            }\n            const colorArray = actorEntry.actor.getProperty().getColor();\n            const color = colorToString(colorArray);\n            actorWorldPointsMap.set(cacheId, { worldPointsSet, color });\n        }\n    });\n}\nfunction getCacheId(viewport) {\n    const { viewPlaneNormal } = viewport.getCamera();\n    const imageIndex = viewport.getCurrentImageIdIndex();\n    return `${viewport.id}-${pointToString(viewPlaneNormal)}-${imageIndex}`;\n}\nfunction colorToString(colorArray) {\n    function colorComponentToString(component) {\n        let componentString = Math.floor(component * 255).toString(16);\n        if (componentString.length === 1) {\n            componentString = '0' + componentString;\n        }\n        return componentString;\n    }\n    return ('#' +\n        colorComponentToString(colorArray[0]) +\n        colorComponentToString(colorArray[1]) +\n        colorComponentToString(colorArray[2]));\n}\nfunction removeExtraPoints(viewport, worldPointsSet) {\n    return worldPointsSet.map((worldPoints) => {\n        const canvasPoints = worldPoints.map((point) => {\n            const canvasPoint = viewport.worldToCanvas(point);\n            return [Math.floor(canvasPoint[0]), Math.floor(canvasPoint[1])];\n        });\n        let lastPoint;\n        const newWorldPoints = [];\n        let newCanvasPoints = [];\n        for (let i = 0; i < worldPoints.length; i++) {\n            if (lastPoint) {\n                if (distanceToPoint(lastPoint, canvasPoints[i]) > 0) {\n                    newWorldPoints.push(worldPoints[i]);\n                    newCanvasPoints.push(canvasPoints[i]);\n                }\n            }\n            lastPoint = canvasPoints[i];\n        }\n        const firstPoint = newCanvasPoints[0];\n        for (let j = Math.min(30, newCanvasPoints.length); j < newCanvasPoints.length; j++) {\n            if (distanceToPoint(firstPoint, newCanvasPoints[j]) < 0.5) {\n                newCanvasPoints = newCanvasPoints.slice(0, j);\n                return newWorldPoints.slice(0, j);\n            }\n        }\n        return newWorldPoints;\n    });\n}\nSegmentationIntersectionTool.toolName = 'SegmentationIntersection';\nexport default SegmentationIntersectionTool;\n","import { getEnabledElementByIds, getEnabledElement, VolumeViewport, BaseVolumeViewport, utilities, } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nclass StackScrollTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            invert: false,\n            debounceIfNotLoaded: true,\n            loop: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.deltaY = 1;\n    }\n    mouseWheelCallback(evt) {\n        this._scroll(evt);\n    }\n    mouseDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    touchDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    _dragCallback(evt) {\n        this._scrollDrag(evt);\n    }\n    _scrollDrag(evt) {\n        const { deltaPoints, viewportId, renderingEngineId } = evt.detail;\n        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n        const { debounceIfNotLoaded, invert, loop } = this.configuration;\n        const deltaPointY = deltaPoints.canvas[1];\n        let volumeId;\n        if (viewport instanceof VolumeViewport) {\n            volumeId = viewport.getVolumeId();\n        }\n        const pixelsPerImage = this._getPixelPerImage(viewport);\n        const deltaY = deltaPointY + this.deltaY;\n        if (!pixelsPerImage) {\n            return;\n        }\n        if (Math.abs(deltaY) >= pixelsPerImage) {\n            const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);\n            utilities.scroll(viewport, {\n                delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,\n                volumeId,\n                debounceLoading: debounceIfNotLoaded,\n                loop: loop,\n            });\n            this.deltaY = deltaY % pixelsPerImage;\n        }\n        else {\n            this.deltaY = deltaY;\n        }\n    }\n    _scroll(evt) {\n        const { wheel, element } = evt.detail;\n        const { direction } = wheel;\n        const { invert } = this.configuration;\n        const { viewport } = getEnabledElement(element);\n        const delta = direction * (invert ? -1 : 1);\n        utilities.scroll(viewport, {\n            delta,\n            debounceLoading: this.configuration.debounceIfNotLoaded,\n            loop: this.configuration.loop,\n            volumeId: viewport instanceof BaseVolumeViewport\n                ? viewport.getVolumeId()\n                : undefined,\n            scrollSlabs: this.configuration.scrollSlabs,\n        });\n    }\n    _getPixelPerImage(viewport) {\n        const { element } = viewport;\n        const numberOfSlices = viewport.getNumberOfSlices();\n        return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));\n    }\n}\nStackScrollTool.toolName = 'StackScroll';\nexport default StackScrollTool;\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { Events } from '../enums';\nimport { eventTarget, getEnabledElement, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport { getToolGroup } from '../store/ToolGroupManager';\nclass TrackballRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            rotateIncrementDegrees: 2,\n            rotateSampleDistanceFactor: 2,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._resizeObservers = new Map();\n        this._hasResolutionChanged = false;\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const actorEntry = viewport.getDefaultActor();\n            const actor = actorEntry.actor;\n            const mapper = actor.getMapper();\n            const hasSampleDistance = 'getSampleDistance' in mapper || 'getCurrentSampleDistance' in mapper;\n            if (!hasSampleDistance) {\n                return true;\n            }\n            const originalSampleDistance = mapper.getSampleDistance();\n            if (!this._hasResolutionChanged) {\n                const { rotateSampleDistanceFactor } = this.configuration;\n                mapper.setSampleDistance(originalSampleDistance * rotateSampleDistanceFactor);\n                this._hasResolutionChanged = true;\n                if (this.cleanUp !== null) {\n                    document.removeEventListener('mouseup', this.cleanUp);\n                }\n                this.cleanUp = () => {\n                    mapper.setSampleDistance(originalSampleDistance);\n                    viewport.render();\n                    this._hasResolutionChanged = false;\n                };\n                document.addEventListener('mouseup', this.cleanUp, { once: true });\n            }\n            return true;\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.onSetToolActive = () => {\n            const subscribeToElementResize = () => {\n                const viewportsInfo = this._getViewportsInfo();\n                viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                    if (!this._resizeObservers.has(viewportId)) {\n                        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId) || { viewport: null };\n                        if (!viewport) {\n                            return;\n                        }\n                        const { element } = viewport;\n                        const resizeObserver = new ResizeObserver(() => {\n                            const element = getEnabledElementByIds(viewportId, renderingEngineId);\n                            if (!element) {\n                                return;\n                            }\n                            const { viewport } = element;\n                            const viewPresentation = viewport.getViewPresentation();\n                            viewport.resetCamera();\n                            viewport.setViewPresentation(viewPresentation);\n                            viewport.render();\n                        });\n                        resizeObserver.observe(element);\n                        this._resizeObservers.set(viewportId, resizeObserver);\n                    }\n                });\n            };\n            subscribeToElementResize();\n            this._viewportAddedListener = (evt) => {\n                if (evt.detail.toolGroupId === this.toolGroupId) {\n                    subscribeToElementResize();\n                }\n            };\n            eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n        };\n        this.onSetToolDisabled = () => {\n            this._resizeObservers.forEach((resizeObserver, viewportId) => {\n                resizeObserver.disconnect();\n                this._resizeObservers.delete(viewportId);\n            });\n            if (this._viewportAddedListener) {\n                eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n                this._viewportAddedListener = null;\n            }\n        };\n        this.rotateCamera = (viewport, centerWorld, axis, angle) => {\n            const vtkCamera = viewport.getVtkActiveCamera();\n            const viewUp = vtkCamera.getViewUp();\n            const focalPoint = vtkCamera.getFocalPoint();\n            const position = vtkCamera.getPosition();\n            const newPosition = [0, 0, 0];\n            const newFocalPoint = [0, 0, 0];\n            const newViewUp = [0, 0, 0];\n            const transform = mat4.identity(new Float32Array(16));\n            mat4.translate(transform, transform, centerWorld);\n            mat4.rotate(transform, transform, angle, axis);\n            mat4.translate(transform, transform, [\n                -centerWorld[0],\n                -centerWorld[1],\n                -centerWorld[2],\n            ]);\n            vec3.transformMat4(newPosition, position, transform);\n            vec3.transformMat4(newFocalPoint, focalPoint, transform);\n            mat4.identity(transform);\n            mat4.rotate(transform, transform, angle, axis);\n            vec3.transformMat4(newViewUp, viewUp, transform);\n            viewport.setCamera({\n                position: newPosition,\n                viewUp: newViewUp,\n                focalPoint: newFocalPoint,\n            });\n        };\n        this.touchDragCallback = this._dragCallback.bind(this);\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    _dragCallback(evt) {\n        const { element, currentPoints, lastPoints } = evt.detail;\n        const currentPointsCanvas = currentPoints.canvas;\n        const lastPointsCanvas = lastPoints.canvas;\n        const { rotateIncrementDegrees } = this.configuration;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const width = element.clientWidth;\n        const height = element.clientHeight;\n        const normalizedPosition = [\n            currentPointsCanvas[0] / width,\n            currentPointsCanvas[1] / height,\n        ];\n        const normalizedPreviousPosition = [\n            lastPointsCanvas[0] / width,\n            lastPointsCanvas[1] / height,\n        ];\n        const center = [width * 0.5, height * 0.5];\n        const centerWorld = viewport.canvasToWorld(center);\n        const normalizedCenter = [0.5, 0.5];\n        const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n        const op = [normalizedPreviousPosition[0], 0, 0];\n        const oe = [normalizedPosition[0], 0, 0];\n        const opsq = op[0] ** 2;\n        const oesq = oe[0] ** 2;\n        const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n        const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n        const nop = [op[0], 0, lop];\n        vtkMath.normalize(nop);\n        const noe = [oe[0], 0, loe];\n        vtkMath.normalize(noe);\n        const dot = vtkMath.dot(nop, noe);\n        if (Math.abs(dot) > 0.0001) {\n            const angleX = -2 *\n                Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\n                Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\n                rotateIncrementDegrees;\n            const upVec = camera.viewUp;\n            const atV = camera.viewPlaneNormal;\n            const rightV = [0, 0, 0];\n            const forwardV = [0, 0, 0];\n            vtkMath.cross(upVec, atV, rightV);\n            vtkMath.normalize(rightV);\n            vtkMath.cross(atV, rightV, forwardV);\n            vtkMath.normalize(forwardV);\n            vtkMath.normalize(upVec);\n            this.rotateCamera(viewport, centerWorld, forwardV, angleX);\n            const angleY = (normalizedPreviousPosition[1] - normalizedPosition[1]) *\n                rotateIncrementDegrees;\n            this.rotateCamera(viewport, centerWorld, rightV, angleY);\n            viewport.render();\n        }\n    }\n}\nTrackballRotateTool.toolName = 'TrackballRotate';\nexport default TrackballRotateTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { AnnotationTool } from './base';\nimport { getRenderingEngine, getEnabledElementByIds, getEnabledElement, utilities as csUtils, Enums, CONSTANTS, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { getToolGroup, getToolGroupForViewport, } from '../store/ToolGroupManager';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { drawCircle as drawCircleSvg, drawLine as drawLineSvg, } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\nimport * as lineSegment from '../utilities/math/line';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nconst { RENDERING_DEFAULTS } = CONSTANTS;\nfunction defaultReferenceLineColor() {\n    return 'rgb(0, 200, 0)';\n}\nfunction defaultReferenceLineControllable() {\n    return true;\n}\nconst OPERATION = {\n    DRAG: 1,\n    ROTATE: 2,\n    SLAB: 3,\n};\nclass VolumeCroppingControlTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse'],\n        configuration: {\n            viewportIndicators: false,\n            viewportIndicatorsConfig: {\n                radius: 5,\n                x: null,\n                y: null,\n            },\n            extendReferenceLines: true,\n            initialCropFactor: 0.2,\n            mobile: {\n                enabled: false,\n                opacity: 0.8,\n            },\n            lineColors: {\n                AXIAL: [1.0, 0.0, 0.0],\n                CORONAL: [0.0, 1.0, 0.0],\n                SAGITTAL: [1.0, 1.0, 0.0],\n                UNKNOWN: [0.0, 0.0, 1.0],\n            },\n            lineWidth: 1.5,\n            lineWidthActive: 2.5,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._virtualAnnotations = [];\n        this.sphereStates = [];\n        this.draggingSphereIndex = null;\n        this.toolCenter = [0, 0, 0];\n        this.toolCenterMin = [0, 0, 0];\n        this.toolCenterMax = [0, 0, 0];\n        this.initializeViewport = ({ renderingEngineId, viewportId, }) => {\n            if (!renderingEngineId || !viewportId) {\n                console.warn('VolumeCroppingControlTool: Missing renderingEngineId or viewportId');\n                return;\n            }\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            this._updateToolCentersFromViewport(viewport);\n            const { element } = viewport;\n            const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\n            let annotations = this._getAnnotations(enabledElement);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (annotations?.length) {\n                removeAnnotation(annotations[0].annotationUID);\n            }\n            const orientation = this._getOrientationFromNormal(viewport.getCamera().viewPlaneNormal);\n            const annotation = {\n                highlighted: false,\n                metadata: {\n                    cameraPosition: [...position],\n                    cameraFocalPoint: [...focalPoint],\n                    toolName: this.getToolName(),\n                },\n                data: {\n                    handles: {\n                        toolCenter: this.toolCenter,\n                        toolCenterMin: this.toolCenterMin,\n                        toolCenterMax: this.toolCenterMax,\n                    },\n                    activeOperation: null,\n                    activeViewportIds: [],\n                    viewportId,\n                    referenceLines: [],\n                    orientation,\n                },\n            };\n            addAnnotation(annotation, element);\n            return {\n                normal: viewPlaneNormal,\n                point: viewport.canvasToWorld([100, 100]),\n            };\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.resetCroppingSpheres = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            for (const viewportInfo of viewportsInfo) {\n                const { viewportId, renderingEngineId } = viewportInfo;\n                const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n                const viewport = enabledElement.viewport;\n                const resetPan = true;\n                const resetZoom = true;\n                const resetToCenter = true;\n                const resetRotation = true;\n                const suppressEvents = true;\n                viewport.resetCamera({\n                    resetPan,\n                    resetZoom,\n                    resetToCenter,\n                    resetRotation,\n                    suppressEvents,\n                });\n                viewport.resetSlabThickness();\n                const { element } = viewport;\n                let annotations = this._getAnnotations(enabledElement);\n                annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n                if (annotations.length) {\n                    removeAnnotation(annotations[0].annotationUID);\n                }\n                viewport.render();\n            }\n            this._computeToolCenter(viewportsInfo);\n        };\n        this.computeToolCenter = () => {\n            const viewportsInfo = this._getViewportsInfo();\n        };\n        this._computeToolCenter = (viewportsInfo) => {\n            if (!viewportsInfo || !viewportsInfo[0]) {\n                console.warn('  _computeToolCenter : No valid viewportsInfo for computeToolCenter.');\n                return;\n            }\n            const orientationIds = ['AXIAL', 'CORONAL', 'SAGITTAL'];\n            const presentOrientations = viewportsInfo\n                .map((vp) => {\n                if (vp.renderingEngineId) {\n                    const renderingEngine = getRenderingEngine(vp.renderingEngineId);\n                    const viewport = renderingEngine.getViewport(vp.viewportId);\n                    if (viewport && viewport.getCamera) {\n                        const orientation = this._getOrientationFromNormal(viewport.getCamera().viewPlaneNormal);\n                        if (orientation) {\n                            return orientation;\n                        }\n                    }\n                }\n                return null;\n            })\n                .filter(Boolean);\n            const missingOrientation = orientationIds.find((id) => !presentOrientations.includes(id));\n            const presentNormals = [];\n            const presentCenters = [];\n            const presentViewportInfos = viewportsInfo.filter((vp) => {\n                let orientation = null;\n                if (vp.renderingEngineId) {\n                    const renderingEngine = getRenderingEngine(vp.renderingEngineId);\n                    const viewport = renderingEngine.getViewport(vp.viewportId);\n                    if (viewport && viewport.getCamera) {\n                        orientation = this._getOrientationFromNormal(viewport.getCamera().viewPlaneNormal);\n                    }\n                }\n                return orientation && orientationIds.includes(orientation);\n            });\n            presentViewportInfos.forEach((vpInfo) => {\n                const { normal, point } = this.initializeViewport(vpInfo);\n                presentNormals.push(normal);\n                presentCenters.push(point);\n            });\n            if (presentViewportInfos.length === 2 && missingOrientation) {\n                const virtualNormal = [0, 0, 0];\n                vec3.cross(virtualNormal, presentNormals[0], presentNormals[1]);\n                vec3.normalize(virtualNormal, virtualNormal);\n                const virtualCenter = [\n                    (presentCenters[0][0] + presentCenters[1][0]) / 2,\n                    (presentCenters[0][1] + presentCenters[1][1]) / 2,\n                    (presentCenters[0][2] + presentCenters[1][2]) / 2,\n                ];\n                const orientation = null;\n                const virtualAnnotation = {\n                    highlighted: false,\n                    metadata: {\n                        cameraPosition: [...virtualCenter],\n                        cameraFocalPoint: [...virtualCenter],\n                        toolName: this.getToolName(),\n                    },\n                    data: {\n                        handles: {\n                            activeOperation: null,\n                            toolCenter: this.toolCenter,\n                            toolCenterMin: this.toolCenterMin,\n                            toolCenterMax: this.toolCenterMax,\n                        },\n                        activeViewportIds: [],\n                        viewportId: missingOrientation,\n                        referenceLines: [],\n                        orientation,\n                    },\n                    isVirtual: true,\n                    virtualNormal,\n                };\n                this._virtualAnnotations = [virtualAnnotation];\n            }\n            else if (presentViewportInfos.length === 1) {\n                let presentOrientation = null;\n                const vpInfo = presentViewportInfos[0];\n                if (vpInfo.renderingEngineId) {\n                    const renderingEngine = getRenderingEngine(vpInfo.renderingEngineId);\n                    const viewport = renderingEngine.getViewport(vpInfo.viewportId);\n                    if (viewport && viewport.getCamera) {\n                        presentOrientation = this._getOrientationFromNormal(viewport.getCamera().viewPlaneNormal);\n                    }\n                }\n                const presentCenter = presentCenters[0];\n                const canonicalNormals = {\n                    AXIAL: [0, 0, 1],\n                    CORONAL: [0, 1, 0],\n                    SAGITTAL: [1, 0, 0],\n                };\n                const missingIds = orientationIds.filter((id) => id !== presentOrientation);\n                const virtualAnnotations = missingIds.map((orientation) => {\n                    const normal = canonicalNormals[orientation];\n                    const virtualAnnotation = {\n                        highlighted: false,\n                        metadata: {\n                            cameraPosition: [...presentCenter],\n                            cameraFocalPoint: [...presentCenter],\n                            toolName: this.getToolName(),\n                        },\n                        data: {\n                            handles: {\n                                activeOperation: null,\n                                toolCenter: this.toolCenter,\n                                toolCenterMin: this.toolCenterMin,\n                                toolCenterMax: this.toolCenterMax,\n                            },\n                            activeViewportIds: [],\n                            viewportId: orientation,\n                            referenceLines: [],\n                            orientation,\n                        },\n                        isVirtual: true,\n                        virtualNormal: normal,\n                    };\n                    return virtualAnnotation;\n                });\n                this._virtualAnnotations = virtualAnnotations;\n            }\n            if (viewportsInfo && viewportsInfo.length) {\n                triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n            }\n        };\n        this.cancel = () => {\n            console.log('Not implemented yet');\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.onResetCamera = (evt) => {\n            this.resetCroppingSpheres();\n        };\n        this.mouseMoveCallback = (evt, filteredToolAnnotations) => {\n            if (!filteredToolAnnotations) {\n                return;\n            }\n            const { element, currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            let imageNeedsUpdate = false;\n            for (let i = 0; i < filteredToolAnnotations.length; i++) {\n                const annotation = filteredToolAnnotations[i];\n                if (isAnnotationLocked(annotation.annotationUID)) {\n                    continue;\n                }\n                const { data, highlighted } = annotation;\n                if (!data.handles) {\n                    continue;\n                }\n                const previousActiveOperation = data.handles.activeOperation;\n                const previousActiveViewportIds = data.activeViewportIds && data.activeViewportIds.length > 0\n                    ? [...data.activeViewportIds]\n                    : [];\n                data.activeViewportIds = [];\n                let near = false;\n                near = this._pointNearTool(element, annotation, canvasCoords, 6);\n                const nearToolAndNotMarkedActive = near && !highlighted;\n                const notNearToolAndMarkedActive = !near && highlighted;\n                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n                    annotation.highlighted = !highlighted;\n                    imageNeedsUpdate = true;\n                }\n            }\n            return imageNeedsUpdate;\n        };\n        this.filterInteractableAnnotationsForElement = (element, annotations) => {\n            if (!annotations || !annotations.length) {\n                return [];\n            }\n            const enabledElement = getEnabledElement(element);\n            let orientation = null;\n            if (enabledElement.viewport && enabledElement.viewport.getCamera) {\n                orientation = this._getOrientationFromNormal(enabledElement.viewport.getCamera().viewPlaneNormal);\n            }\n            const filtered = annotations.filter((annotation) => {\n                if (annotation.isVirtual) {\n                    return true;\n                }\n                if (annotation.data.orientation &&\n                    orientation &&\n                    annotation.data.orientation === orientation) {\n                    return true;\n                }\n                return false;\n            });\n            return filtered;\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            function lineIntersection2D(p1, p2, q1, q2) {\n                const s1_x = p2[0] - p1[0];\n                const s1_y = p2[1] - p1[1];\n                const s2_x = q2[0] - q1[0];\n                const s2_y = q2[1] - q1[1];\n                const denom = -s2_x * s1_y + s1_x * s2_y;\n                if (Math.abs(denom) < 1e-8) {\n                    return null;\n                }\n                const s = (-s1_y * (p1[0] - q1[0]) + s1_x * (p1[1] - q1[1])) / denom;\n                const t = (s2_x * (p1[1] - q1[1]) - s2_y * (p1[0] - q1[0])) / denom;\n                if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n                    return [p1[0] + t * s1_x, p1[1] + t * s1_y];\n                }\n                return null;\n            }\n            const viewportsInfo = this._getViewportsInfo();\n            if (!viewportsInfo || viewportsInfo.length === 0) {\n                return false;\n            }\n            let renderStatus = false;\n            const { viewport, renderingEngine } = enabledElement;\n            const { element } = viewport;\n            let annotations = this._getAnnotations(enabledElement);\n            if (this._virtualAnnotations && this._virtualAnnotations.length) {\n                annotations = annotations.concat(this._virtualAnnotations);\n            }\n            const camera = viewport.getCamera();\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation || !viewportAnnotation.data) {\n                return renderStatus;\n            }\n            const annotationUID = viewportAnnotation.annotationUID;\n            const { clientWidth, clientHeight } = viewport.canvas;\n            const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n            const data = viewportAnnotation.data;\n            const otherViewportAnnotations = annotations;\n            const volumeCroppingCenterCanvasMin = viewport.worldToCanvas(this.toolCenterMin);\n            const volumeCroppingCenterCanvasMax = viewport.worldToCanvas(this.toolCenterMax);\n            const referenceLines = [];\n            const canvasBox = [0, 0, clientWidth, clientHeight];\n            otherViewportAnnotations.forEach((annotation) => {\n                const data = annotation.data;\n                const isVirtual = 'isVirtual' in annotation &&\n                    annotation.isVirtual === true;\n                data.handles.toolCenter = this.toolCenter;\n                let otherViewport, otherCamera, clientWidth, clientHeight, otherCanvasDiagonalLength, otherCanvasCenter, otherViewportCenterWorld;\n                if (isVirtual) {\n                    const realViewports = viewportsInfo.filter((vp) => vp.viewportId !== data.viewportId);\n                    if (realViewports.length === 2) {\n                        const vp1 = renderingEngine.getViewport(realViewports[0].viewportId);\n                        const vp2 = renderingEngine.getViewport(realViewports[1].viewportId);\n                        const normal1 = vp1.getCamera().viewPlaneNormal;\n                        const normal2 = vp2.getCamera().viewPlaneNormal;\n                        const virtualNormal = vec3.create();\n                        vec3.cross(virtualNormal, normal1, normal2);\n                        vec3.normalize(virtualNormal, virtualNormal);\n                        otherCamera = {\n                            viewPlaneNormal: virtualNormal,\n                            position: data.handles.toolCenter,\n                            focalPoint: data.handles.toolCenter,\n                            viewUp: [0, 1, 0],\n                        };\n                        clientWidth = viewport.canvas.clientWidth;\n                        clientHeight = viewport.canvas.clientHeight;\n                        otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n                        otherCanvasCenter = [clientWidth * 0.5, clientHeight * 0.5];\n                        otherViewportCenterWorld = data.handles.toolCenter;\n                        otherViewport = {\n                            id: data.viewportId,\n                            canvas: viewport.canvas,\n                            canvasToWorld: () => data.handles.toolCenter,\n                        };\n                    }\n                    else {\n                        const virtualNormal = annotation\n                            .virtualNormal ?? [0, 0, 1];\n                        otherCamera = {\n                            viewPlaneNormal: virtualNormal,\n                            position: data.handles.toolCenter,\n                            focalPoint: data.handles.toolCenter,\n                            viewUp: [0, 1, 0],\n                        };\n                        clientWidth = viewport.canvas.clientWidth;\n                        clientHeight = viewport.canvas.clientHeight;\n                        otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n                        otherCanvasCenter = [clientWidth * 0.5, clientHeight * 0.5];\n                        otherViewportCenterWorld = data.handles.toolCenter;\n                        otherViewport = {\n                            id: data.viewportId,\n                            canvas: viewport.canvas,\n                            canvasToWorld: () => data.handles.toolCenter,\n                        };\n                    }\n                }\n                else {\n                    otherViewport = renderingEngine.getViewport(data.viewportId);\n                    otherCamera = otherViewport.getCamera();\n                    clientWidth = otherViewport.canvas.clientWidth;\n                    clientHeight = otherViewport.canvas.clientHeight;\n                    otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n                    otherCanvasCenter = [clientWidth * 0.5, clientHeight * 0.5];\n                    otherViewportCenterWorld =\n                        otherViewport.canvasToWorld(otherCanvasCenter);\n                }\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const direction = [0, 0, 0];\n                vtkMath.cross(camera.viewPlaneNormal, otherCamera.viewPlaneNormal, direction);\n                vtkMath.normalize(direction);\n                vtkMath.multiplyScalar(direction, otherCanvasDiagonalLength);\n                const pointWorld0 = [0, 0, 0];\n                vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\n                const pointWorld1 = [0, 0, 0];\n                vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\n                const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\n                const otherViewportCenterCanvas = viewport.worldToCanvas([\n                    otherViewportCenterWorld[0] ?? 0,\n                    otherViewportCenterWorld[1] ?? 0,\n                    otherViewportCenterWorld[2] ?? 0,\n                ]);\n                const canvasUnitVectorFromCenter = vec2.create();\n                vec2.subtract(canvasUnitVectorFromCenter, pointCanvas0, otherViewportCenterCanvas);\n                vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n                const canvasVectorFromCenterLong = vec2.create();\n                vec2.scale(canvasVectorFromCenterLong, canvasUnitVectorFromCenter, canvasDiagonalLength * 100);\n                const refLinesCenterMin = otherViewportControllable\n                    ? vec2.clone(volumeCroppingCenterCanvasMin)\n                    : vec2.clone(otherViewportCenterCanvas);\n                const refLinePointMinOne = vec2.create();\n                const refLinePointMinTwo = vec2.create();\n                vec2.add(refLinePointMinOne, refLinesCenterMin, canvasVectorFromCenterLong);\n                vec2.subtract(refLinePointMinTwo, refLinesCenterMin, canvasVectorFromCenterLong);\n                liangBarksyClip(refLinePointMinOne, refLinePointMinTwo, canvasBox);\n                referenceLines.push([\n                    otherViewport,\n                    refLinePointMinOne,\n                    refLinePointMinTwo,\n                    'min',\n                ]);\n                const refLinesCenterMax = otherViewportControllable\n                    ? vec2.clone(volumeCroppingCenterCanvasMax)\n                    : vec2.clone(otherViewportCenterCanvas);\n                const refLinePointMaxOne = vec2.create();\n                const refLinePointMaxTwo = vec2.create();\n                vec2.add(refLinePointMaxOne, refLinesCenterMax, canvasVectorFromCenterLong);\n                vec2.subtract(refLinePointMaxTwo, refLinesCenterMax, canvasVectorFromCenterLong);\n                liangBarksyClip(refLinePointMaxOne, refLinePointMaxTwo, canvasBox);\n                referenceLines.push([\n                    otherViewport,\n                    refLinePointMaxOne,\n                    refLinePointMaxTwo,\n                    'max',\n                ]);\n            });\n            data.referenceLines = referenceLines;\n            const viewportColor = this._getReferenceLineColor(viewport.id);\n            const color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n            referenceLines.forEach((line, lineIndex) => {\n                const intersections = [];\n                for (let j = 0; j < referenceLines.length; ++j) {\n                    if (j === lineIndex) {\n                        continue;\n                    }\n                    const otherLine = referenceLines[j];\n                    const intersection = lineIntersection2D(line[1], line[2], otherLine[1], otherLine[2]);\n                    if (intersection) {\n                        intersections.push({\n                            with: otherLine[3],\n                            point: intersection,\n                        });\n                    }\n                }\n                const otherViewport = line[0];\n                let orientation = null;\n                if (otherViewport && otherViewport.id) {\n                    const annotationForViewport = annotations.find((a) => a.data.viewportId === otherViewport.id);\n                    if (annotationForViewport && annotationForViewport.data.orientation) {\n                        orientation = String(annotationForViewport.data.orientation).toUpperCase();\n                    }\n                    else {\n                        const idUpper = otherViewport.id.toUpperCase();\n                        if (idUpper.includes('AXIAL')) {\n                            orientation = 'AXIAL';\n                        }\n                        else if (idUpper.includes('CORONAL')) {\n                            orientation = 'CORONAL';\n                        }\n                        else if (idUpper.includes('SAGITTAL')) {\n                            orientation = 'SAGITTAL';\n                        }\n                    }\n                }\n                const lineColors = this.configuration.lineColors || {};\n                const colorArr = lineColors[orientation] ||\n                    lineColors.unknown || [1.0, 0.0, 0.0];\n                const color = Array.isArray(colorArr)\n                    ? `rgb(${colorArr.map((v) => Math.round(v * 255)).join(',')})`\n                    : colorArr;\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const selectedViewportId = data.activeViewportIds.find((id) => id === otherViewport.id);\n                let lineWidth = this.configuration.lineWidth ?? 1.5;\n                const lineActive = data.handles.activeOperation !== null &&\n                    data.handles.activeOperation === OPERATION.DRAG &&\n                    selectedViewportId;\n                if (lineActive) {\n                    lineWidth = this.configuration.activeLineWidth ?? 2.5;\n                }\n                const lineUID = `${lineIndex}`;\n                if (viewportControllable) {\n                    if (intersections.length === 2) {\n                        drawLineSvg(svgDrawingHelper, annotationUID, lineUID, intersections[0].point, intersections[1].point, {\n                            color,\n                            lineWidth,\n                        });\n                    }\n                    if (this.configuration.extendReferenceLines &&\n                        intersections.length === 2) {\n                        if (this.configuration.extendReferenceLines &&\n                            intersections.length === 2) {\n                            const sortedIntersections = intersections\n                                .map((intersection) => ({\n                                ...intersection,\n                                distance: vec2.distance(line[1], intersection.point),\n                            }))\n                                .sort((a, b) => a.distance - b.distance);\n                            drawLineSvg(svgDrawingHelper, annotationUID, lineUID + '_dashed_before', line[1], sortedIntersections[0].point, { color, lineWidth, lineDash: [4, 4] });\n                            drawLineSvg(svgDrawingHelper, annotationUID, lineUID + '_dashed_after', sortedIntersections[1].point, line[2], { color, lineWidth, lineDash: [4, 4] });\n                        }\n                    }\n                }\n            });\n            renderStatus = true;\n            if (this.configuration.viewportIndicators) {\n                const { viewportIndicatorsConfig } = this.configuration;\n                const xOffset = viewportIndicatorsConfig?.xOffset || 0.95;\n                const yOffset = viewportIndicatorsConfig?.yOffset || 0.05;\n                const referenceColorCoordinates = [\n                    clientWidth * xOffset,\n                    clientHeight * yOffset,\n                ];\n                const circleRadius = viewportIndicatorsConfig?.circleRadius || canvasDiagonalLength * 0.01;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, referenceColorCoordinates, circleRadius, { color, fill: color });\n            }\n            return renderStatus;\n        };\n        this._getAnnotations = (enabledElement) => {\n            const { viewport } = enabledElement;\n            const annotations = getAnnotations(this.getToolName(), viewport.element) || [];\n            const viewportIds = this._getViewportsInfo().map(({ viewportId }) => viewportId);\n            const toolGroupAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                return viewportIds.includes(data.viewportId);\n            });\n            return toolGroupAnnotations;\n        };\n        this._onSphereMoved = (evt) => {\n            if (evt.detail.originalClippingPlanes) {\n                this._syncWithVolumeCroppingTool(evt.detail.originalClippingPlanes);\n            }\n            else {\n                if (evt.detail.seriesInstanceUID !== this.seriesInstanceUID) {\n                    return;\n                }\n                const { draggingSphereIndex, toolCenter } = evt.detail;\n                const newMin = [...this.toolCenterMin];\n                const newMax = [...this.toolCenterMax];\n                if (draggingSphereIndex >= 0 && draggingSphereIndex <= 5) {\n                    const axis = Math.floor(draggingSphereIndex / 2);\n                    const isMin = draggingSphereIndex % 2 === 0;\n                    (isMin ? newMin : newMax)[axis] = toolCenter[axis];\n                    this.setToolCenter(newMin, 'min');\n                    this.setToolCenter(newMax, 'max');\n                    return;\n                }\n                if (draggingSphereIndex >= 6 && draggingSphereIndex <= 13) {\n                    const idx = draggingSphereIndex;\n                    if (idx < 10) {\n                        newMin[0] = toolCenter[0];\n                    }\n                    else {\n                        newMax[0] = toolCenter[0];\n                    }\n                    if ([6, 7, 10, 11].includes(idx)) {\n                        newMin[1] = toolCenter[1];\n                    }\n                    else {\n                        newMax[1] = toolCenter[1];\n                    }\n                    if (idx % 2 === 0) {\n                        newMin[2] = toolCenter[2];\n                    }\n                    else {\n                        newMax[2] = toolCenter[2];\n                    }\n                    this.setToolCenter(newMin, 'min');\n                    this.setToolCenter(newMax, 'max');\n                }\n            }\n        };\n        this._onNewVolume = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            if (viewportsInfo && viewportsInfo.length > 0) {\n                const { viewportId, renderingEngineId } = viewportsInfo[0];\n                const renderingEngine = getRenderingEngine(renderingEngineId);\n                const viewport = renderingEngine.getViewport(viewportId);\n                const volumeActors = viewport.getActors();\n                if (volumeActors.length > 0) {\n                    const imageData = volumeActors[0].actor.getMapper().getInputData();\n                    if (imageData) {\n                        this.seriesInstanceUID = imageData.seriesInstanceUID;\n                        this._updateToolCentersFromViewport(viewport);\n                        const annotations = getAnnotations(this.getToolName(), viewportId) || [];\n                        annotations.forEach((annotation) => {\n                            if (annotation.data && annotation.data.handles) {\n                                annotation.data.handles.toolCenter = [...this.toolCenter];\n                            }\n                        });\n                    }\n                }\n            }\n            this._computeToolCenter(viewportsInfo);\n            triggerEvent(eventTarget, Events.VOLUMECROPPINGCONTROL_TOOL_CHANGED, {\n                toolGroupId: this.toolGroupId,\n                viewportsInfo: viewportsInfo,\n                seriesInstanceUID: this.seriesInstanceUID,\n            });\n        };\n        this._getAnnotationsForViewportsWithDifferentCameras = (enabledElement, annotations) => {\n            const { viewportId, renderingEngine, viewport } = enabledElement;\n            const otherViewportAnnotations = annotations.filter((annotation) => annotation.data.viewportId !== viewportId);\n            if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, position } = camera;\n            const viewportsWithDifferentCameras = otherViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const targetViewport = renderingEngine.getViewport(viewportId);\n                const cameraOfTarget = targetViewport.getCamera();\n                return !(csUtils.isEqual(cameraOfTarget.viewPlaneNormal, viewPlaneNormal, 1e-2) && csUtils.isEqual(cameraOfTarget.position, position, 1));\n            });\n            return viewportsWithDifferentCameras;\n        };\n        this._filterViewportWithSameOrientation = (enabledElement, referenceAnnotation, annotations) => {\n            const { renderingEngine } = enabledElement;\n            const { data } = referenceAnnotation;\n            const viewport = renderingEngine.getViewport(data.viewportId);\n            const linkedViewportAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return otherViewportControllable === true;\n            });\n            if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const viewPlaneNormal = camera.viewPlaneNormal;\n            vtkMath.normalize(viewPlaneNormal);\n            const otherViewportsAnnotationsWithSameCameraDirection = linkedViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                return (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\n                    csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2));\n            });\n            return otherViewportsAnnotationsWithSameCameraDirection;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = !this.configuration.mobile?.enabled;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            this.editData.annotation.data.handles.activeOperation = null;\n            this.editData.annotation.data.activeViewportIds = [];\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            const requireSameOrientation = false;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const delta = eventDetail.deltaPoints.world;\n            if (Math.abs(delta[0]) < 1e-3 &&\n                Math.abs(delta[1]) < 1e-3 &&\n                Math.abs(delta[2]) < 1e-3) {\n                return;\n            }\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            if (viewport.type === Enums.ViewportType.VOLUME_3D) {\n                return;\n            }\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation) {\n                return;\n            }\n            const { handles } = viewportAnnotation.data;\n            if (handles.activeOperation === OPERATION.DRAG) {\n                if (handles.activeType === 'min') {\n                    this.toolCenterMin[0] += delta[0];\n                    this.toolCenterMin[1] += delta[1];\n                    this.toolCenterMin[2] += delta[2];\n                }\n                else if (handles.activeType === 'max') {\n                    this.toolCenterMax[0] += delta[0];\n                    this.toolCenterMax[1] += delta[1];\n                    this.toolCenterMax[2] += delta[2];\n                }\n                else {\n                    this.toolCenter[0] += delta[0];\n                    this.toolCenter[1] += delta[1];\n                    this.toolCenter[2] += delta[2];\n                }\n                const viewportsInfo = this._getViewportsInfo();\n                triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n                triggerEvent(eventTarget, Events.VOLUMECROPPINGCONTROL_TOOL_CHANGED, {\n                    toolGroupId: this.toolGroupId,\n                    toolCenter: this.toolCenter,\n                    toolCenterMin: this.toolCenterMin,\n                    toolCenterMax: this.toolCenterMax,\n                    handleType: handles.activeType,\n                    viewportOrientation: [],\n                    seriesInstanceUID: this.seriesInstanceUID,\n                });\n            }\n        };\n        this._getReferenceLineColor =\n            toolProps.configuration?.getReferenceLineColor ||\n                defaultReferenceLineColor;\n        this._getReferenceLineControllable =\n            toolProps.configuration?.getReferenceLineControllable ||\n                defaultReferenceLineControllable;\n        const viewportsInfo = getToolGroup(this.toolGroupId)?.viewportsInfo;\n        eventTarget.addEventListener(Events.VOLUMECROPPING_TOOL_CHANGED, this._onSphereMoved);\n        if (viewportsInfo && viewportsInfo.length > 0) {\n            const { viewportId, renderingEngineId } = viewportsInfo[0];\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            const viewport = renderingEngine.getViewport(viewportId);\n            const volumeActors = viewport.getActors();\n            if (!volumeActors || !volumeActors.length) {\n                console.warn(`VolumeCroppingControlTool: No volume actors found in viewport ${viewportId}.`);\n                return;\n            }\n            const imageData = volumeActors[0].actor.getMapper().getInputData();\n            if (imageData) {\n                const dimensions = imageData.getDimensions();\n                const spacing = imageData.getSpacing();\n                const origin = imageData.getOrigin();\n                this.seriesInstanceUID = imageData.seriesInstanceUID || 'unknown';\n                const cropFactor = this.configuration.initialCropFactor ?? 0.2;\n                this.toolCenter = [\n                    origin[0] + cropFactor * (dimensions[0] - 1) * spacing[0],\n                    origin[1] + cropFactor * (dimensions[1] - 1) * spacing[1],\n                    origin[2] + cropFactor * (dimensions[2] - 1) * spacing[2],\n                ];\n                const maxCropFactor = 1 - cropFactor;\n                this.toolCenterMin = [\n                    origin[0] + cropFactor * (dimensions[0] - 1) * spacing[0],\n                    origin[1] + cropFactor * (dimensions[1] - 1) * spacing[1],\n                    origin[2] + cropFactor * (dimensions[2] - 1) * spacing[2],\n                ];\n                this.toolCenterMax = [\n                    origin[0] + maxCropFactor * (dimensions[0] - 1) * spacing[0],\n                    origin[1] + maxCropFactor * (dimensions[1] - 1) * spacing[1],\n                    origin[2] + maxCropFactor * (dimensions[2] - 1) * spacing[2],\n                ];\n            }\n        }\n    }\n    _updateToolCentersFromViewport(viewport) {\n        const volumeActors = viewport.getActors();\n        if (!volumeActors || !volumeActors.length) {\n            return;\n        }\n        const imageData = volumeActors[0].actor.getMapper().getInputData();\n        if (!imageData) {\n            return;\n        }\n        this.seriesInstanceUID = imageData.seriesInstanceUID || 'unknown';\n        const dimensions = imageData.getDimensions();\n        const spacing = imageData.getSpacing();\n        const origin = imageData.getOrigin();\n        const cropFactor = this.configuration.initialCropFactor ?? 0.2;\n        const cropStart = cropFactor / 2;\n        const cropEnd = 1 - cropFactor / 2;\n        this.toolCenter = [\n            origin[0] +\n                ((cropStart + cropEnd) / 2) * (dimensions[0] - 1) * spacing[0],\n            origin[1] +\n                ((cropStart + cropEnd) / 2) * (dimensions[1] - 1) * spacing[1],\n            origin[2] +\n                ((cropStart + cropEnd) / 2) * (dimensions[2] - 1) * spacing[2],\n        ];\n        this.toolCenterMin = [\n            origin[0] + cropStart * (dimensions[0] - 1) * spacing[0],\n            origin[1] + cropStart * (dimensions[1] - 1) * spacing[1],\n            origin[2] + cropStart * (dimensions[2] - 1) * spacing[2],\n        ];\n        this.toolCenterMax = [\n            origin[0] + cropEnd * (dimensions[0] - 1) * spacing[0],\n            origin[1] + cropEnd * (dimensions[1] - 1) * spacing[1],\n            origin[2] + cropEnd * (dimensions[2] - 1) * spacing[2],\n        ];\n    }\n    onSetToolInactive() {\n        console.debug(`VolumeCroppingControlTool: onSetToolInactive called for tool ${this.getToolName()}`);\n    }\n    onSetToolActive() {\n        const viewportsInfo = this._getViewportsInfo();\n        let anyAnnotationExists = false;\n        for (const vpInfo of viewportsInfo) {\n            const enabledElement = getEnabledElementByIds(vpInfo.viewportId, vpInfo.renderingEngineId);\n            const annotations = this._getAnnotations(enabledElement);\n            if (annotations && annotations.length > 0) {\n                anyAnnotationExists = true;\n                break;\n            }\n        }\n        if (!anyAnnotationExists) {\n            this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n            this._subscribeToViewportNewVolumeSet(viewportsInfo);\n            this._computeToolCenter(viewportsInfo);\n            triggerEvent(eventTarget, Events.VOLUMECROPPINGCONTROL_TOOL_CHANGED, {\n                toolGroupId: this.toolGroupId,\n                viewportsInfo: viewportsInfo,\n                seriesInstanceUID: this.seriesInstanceUID,\n            });\n        }\n        else {\n            for (const vpInfo of viewportsInfo) {\n                const enabledElement = getEnabledElementByIds(vpInfo.viewportId, vpInfo.renderingEngineId);\n                if (!enabledElement) {\n                    continue;\n                }\n                const annotations = this._getAnnotations(enabledElement);\n                if (annotations && annotations.length > 0) {\n                    annotations.forEach((annotation) => {\n                        removeAnnotation(annotation.annotationUID);\n                    });\n                }\n                enabledElement.viewport.render();\n            }\n        }\n    }\n    onSetToolEnabled() {\n        console.debug(`VolumeCroppingControlTool: onSetToolEnabled called for tool ${this.getToolName()}`);\n        const viewportsInfo = this._getViewportsInfo();\n    }\n    onSetToolDisabled() {\n        console.debug(`VolumeCroppingControlTool: onSetToolDisabled called for tool ${this.getToolName()}`);\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n        viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const annotations = this._getAnnotations(enabledElement);\n            if (annotations?.length) {\n                annotations.forEach((annotation) => {\n                    removeAnnotation(annotation.annotationUID);\n                });\n            }\n        });\n    }\n    _getOrientationFromNormal(normal) {\n        if (!normal) {\n            return null;\n        }\n        const canonical = {\n            AXIAL: [0, 0, 1],\n            CORONAL: [0, 1, 0],\n            SAGITTAL: [1, 0, 0],\n        };\n        const tol = 1e-2;\n        for (const [key, value] of Object.entries(canonical)) {\n            if (Math.abs(normal[0] - value[0]) < tol &&\n                Math.abs(normal[1] - value[1]) < tol &&\n                Math.abs(normal[2] - value[2]) < tol) {\n                return key;\n            }\n            if (Math.abs(normal[0] + value[0]) < tol &&\n                Math.abs(normal[1] + value[1]) < tol &&\n                Math.abs(normal[2] + value[2]) < tol) {\n                return key;\n            }\n        }\n        return null;\n    }\n    _syncWithVolumeCroppingTool(originalClippingPlanes) {\n        const planes = originalClippingPlanes;\n        if (planes.length >= 6) {\n            this.toolCenterMin = [\n                planes[0].origin[0],\n                planes[2].origin[1],\n                planes[4].origin[2],\n            ];\n            this.toolCenterMax = [\n                planes[1].origin[0],\n                planes[3].origin[1],\n                planes[5].origin[2],\n            ];\n            this.toolCenter = [\n                (this.toolCenterMin[0] + this.toolCenterMax[0]) / 2,\n                (this.toolCenterMin[1] + this.toolCenterMax[1]) / 2,\n                (this.toolCenterMin[2] + this.toolCenterMax[2]) / 2,\n            ];\n            const viewportsInfo = this._getViewportsInfo();\n            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n                if (enabledElement) {\n                    const annotations = this._getAnnotations(enabledElement);\n                    annotations.forEach((annotation) => {\n                        if (annotation.data &&\n                            annotation.data.handles &&\n                            annotation.data.orientation) {\n                            const orientation = annotation.data.orientation;\n                            if (orientation === 'AXIAL') {\n                                annotation.data.handles.toolCenterMin = [\n                                    planes[0].origin[0],\n                                    planes[2].origin[1],\n                                    annotation.data.handles.toolCenterMin[2],\n                                ];\n                                annotation.data.handles.toolCenterMax = [\n                                    planes[1].origin[0],\n                                    planes[3].origin[1],\n                                    annotation.data.handles.toolCenterMax[2],\n                                ];\n                            }\n                            else if (orientation === 'CORONAL') {\n                                annotation.data.handles.toolCenterMin = [\n                                    planes[0].origin[0],\n                                    annotation.data.handles.toolCenterMin[1],\n                                    planes[4].origin[2],\n                                ];\n                                annotation.data.handles.toolCenterMax = [\n                                    planes[1].origin[0],\n                                    annotation.data.handles.toolCenterMax[1],\n                                    planes[5].origin[2],\n                                ];\n                            }\n                            else if (orientation === 'SAGITTAL') {\n                                annotation.data.handles.toolCenterMin = [\n                                    annotation.data.handles.toolCenterMin[0],\n                                    planes[2].origin[1],\n                                    planes[4].origin[2],\n                                ];\n                                annotation.data.handles.toolCenterMax = [\n                                    annotation.data.handles.toolCenterMax[0],\n                                    planes[3].origin[1],\n                                    planes[5].origin[2],\n                                ];\n                            }\n                            annotation.data.handles.toolCenter = [\n                                (annotation.data.handles.toolCenterMin[0] +\n                                    annotation.data.handles.toolCenterMax[0]) /\n                                    2,\n                                (annotation.data.handles.toolCenterMin[1] +\n                                    annotation.data.handles.toolCenterMax[1]) /\n                                    2,\n                                (annotation.data.handles.toolCenterMin[2] +\n                                    annotation.data.handles.toolCenterMax[2]) /\n                                    2,\n                            ];\n                        }\n                    });\n                }\n            });\n            if (this._virtualAnnotations && this._virtualAnnotations.length > 0) {\n                this._virtualAnnotations.forEach((annotation) => {\n                    if (annotation.data &&\n                        annotation.data.handles &&\n                        annotation.data.orientation) {\n                        const orientation = annotation.data.orientation.toUpperCase();\n                        if (orientation === 'AXIAL') {\n                            annotation.data.handles.toolCenterMin = [\n                                planes[0].origin[0],\n                                planes[2].origin[1],\n                                annotation.data.handles.toolCenterMin[2],\n                            ];\n                            annotation.data.handles.toolCenterMax = [\n                                planes[1].origin[0],\n                                planes[3].origin[1],\n                                annotation.data.handles.toolCenterMax[2],\n                            ];\n                        }\n                        else if (orientation === 'CORONAL') {\n                            annotation.data.handles.toolCenterMin = [\n                                planes[0].origin[0],\n                                annotation.data.handles.toolCenterMin[1],\n                                planes[4].origin[2],\n                            ];\n                            annotation.data.handles.toolCenterMax = [\n                                planes[1].origin[0],\n                                annotation.data.handles.toolCenterMax[1],\n                                planes[5].origin[2],\n                            ];\n                        }\n                        else if (orientation === 'SAGITTAL') {\n                            annotation.data.handles.toolCenterMin = [\n                                annotation.data.handles.toolCenterMin[0],\n                                planes[2].origin[1],\n                                planes[4].origin[2],\n                            ];\n                            annotation.data.handles.toolCenterMax = [\n                                annotation.data.handles.toolCenterMax[0],\n                                planes[3].origin[1],\n                                planes[5].origin[2],\n                            ];\n                        }\n                        annotation.data.handles.toolCenter = [\n                            (annotation.data.handles.toolCenterMin[0] +\n                                annotation.data.handles.toolCenterMax[0]) /\n                                2,\n                            (annotation.data.handles.toolCenterMin[1] +\n                                annotation.data.handles.toolCenterMax[1]) /\n                                2,\n                            (annotation.data.handles.toolCenterMin[2] +\n                                annotation.data.handles.toolCenterMax[2]) /\n                                2,\n                        ];\n                    }\n                });\n            }\n            triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        }\n    }\n    setToolCenter(toolCenter, handleType) {\n        if (handleType === 'min') {\n            this.toolCenterMin = [...toolCenter];\n        }\n        else if (handleType === 'max') {\n            this.toolCenterMax = [...toolCenter];\n        }\n        const viewportsInfo = this._getViewportsInfo();\n        triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const annotations = this._getAnnotations(enabledElement);\n        const filteredAnnotations = this.filterInteractableAnnotationsForElement(viewport.element, annotations);\n        if (!filteredAnnotations ||\n            filteredAnnotations.length === 0 ||\n            !filteredAnnotations[0]) {\n            return null;\n        }\n        const { data } = filteredAnnotations[0];\n        const viewportIdArray = [];\n        const referenceLines = data.referenceLines || [];\n        for (let i = 0; i < referenceLines.length; ++i) {\n            const otherViewport = referenceLines[i][0];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            if (!viewportControllable) {\n                continue;\n            }\n            viewportIdArray.push(otherViewport.id);\n            i++;\n        }\n        data.activeViewportIds = [...viewportIdArray];\n        data.handles.activeOperation = OPERATION.DRAG;\n        evt.preventDefault();\n        hideElementCursor(element);\n        this._activateModify(element);\n        return filteredAnnotations[0];\n    }\n    handleSelectedCallback(evt, annotation, handle, interactionType) {\n        this.toolSelectedCallback(evt, annotation, interactionType);\n    }\n    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _subscribeToViewportNewVolumeSet(viewports) {\n        viewports.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta) {\n        viewportsAnnotationsToUpdate.forEach((annotation) => {\n            this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\n        });\n    }\n    _applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta) {\n        const { data } = annotation;\n        const viewport = renderingEngine.getViewport(data.viewportId);\n        const camera = viewport.getCamera();\n        const normal = camera.viewPlaneNormal;\n        const dotProd = vtkMath.dot(delta, normal);\n        const projectedDelta = [...normal];\n        vtkMath.multiplyScalar(projectedDelta, dotProd);\n        if (Math.abs(projectedDelta[0]) > 1e-3 ||\n            Math.abs(projectedDelta[1]) > 1e-3 ||\n            Math.abs(projectedDelta[2]) > 1e-3) {\n            const newFocalPoint = [0, 0, 0];\n            const newPosition = [0, 0, 0];\n            vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\n            vtkMath.add(camera.position, projectedDelta, newPosition);\n            viewport.setCamera({\n                focalPoint: newFocalPoint,\n                position: newPosition,\n            });\n            viewport.render();\n        }\n    }\n    _pointNearTool(element, annotation, canvasCoords, proximity) {\n        const { data } = annotation;\n        const referenceLines = data.referenceLines;\n        const viewportIdArray = [];\n        if (referenceLines) {\n            for (let i = 0; i < referenceLines.length; ++i) {\n                const otherViewport = referenceLines[i][0];\n                const start1 = referenceLines[i][1];\n                const end1 = referenceLines[i][2];\n                const type = referenceLines[i][3];\n                const distance1 = lineSegment.distanceToPoint(start1, end1, [\n                    canvasCoords[0],\n                    canvasCoords[1],\n                ]);\n                if (distance1 <= proximity) {\n                    viewportIdArray.push(otherViewport.id);\n                    data.handles.activeOperation = 1;\n                    data.handles.activeType = type;\n                }\n            }\n        }\n        data.activeViewportIds = [...viewportIdArray];\n        this.editData = {\n            annotation,\n        };\n        return data.handles.activeOperation === 1 ? true : false;\n    }\n}\nVolumeCroppingControlTool.toolName = 'VolumeCroppingControl';\nexport default VolumeCroppingControlTool;\n","import vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkPoints from '@kitware/vtk.js/Common/Core/Points';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkSphereSource from '@kitware/vtk.js/Filters/Sources/SphereSource';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkPlane from '@kitware/vtk.js/Common/DataModel/Plane';\nimport { BaseTool } from './base';\nimport { getRenderingEngine, getEnabledElementByIds, getEnabledElement, Enums, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport { Events } from '../enums';\nconst PLANEINDEX = {\n    XMIN: 0,\n    XMAX: 1,\n    YMIN: 2,\n    YMAX: 3,\n    ZMIN: 4,\n    ZMAX: 5,\n};\nconst SPHEREINDEX = {\n    XMIN: 0,\n    XMAX: 1,\n    YMIN: 2,\n    YMAX: 3,\n    ZMIN: 4,\n    ZMAX: 5,\n    XMIN_YMIN_ZMIN: 6,\n    XMIN_YMIN_ZMAX: 7,\n    XMIN_YMAX_ZMIN: 8,\n    XMIN_YMAX_ZMAX: 9,\n    XMAX_YMIN_ZMIN: 10,\n    XMAX_YMIN_ZMAX: 11,\n    XMAX_YMAX_ZMIN: 12,\n    XMAX_YMAX_ZMAX: 13,\n};\nclass VolumeCroppingTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            showCornerSpheres: true,\n            showHandles: true,\n            showClippingPlanes: true,\n            mobile: {\n                enabled: false,\n                opacity: 0.8,\n            },\n            initialCropFactor: 0.08,\n            sphereColors: {\n                SAGITTAL: [1.0, 1.0, 0.0],\n                CORONAL: [0.0, 1.0, 0.0],\n                AXIAL: [1.0, 0.0, 0.0],\n                CORNERS: [0.0, 0.0, 1.0],\n            },\n            sphereRadius: 8,\n            grabSpherePixelDistance: 20,\n            rotateIncrementDegrees: 2,\n            rotateSampleDistanceFactor: 2,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._resizeObservers = new Map();\n        this._hasResolutionChanged = false;\n        this.originalClippingPlanes = [];\n        this.draggingSphereIndex = null;\n        this.toolCenter = [0, 0, 0];\n        this.cornerDragOffset = null;\n        this.faceDragOffset = null;\n        this.sphereStates = [];\n        this.edgeLines = {};\n        this.onSetToolConfiguration = () => {\n            console.debug('Setting tool settoolconfiguration : volumeCropping');\n        };\n        this.onSetToolEnabled = () => {\n            console.debug('Setting tool enabled: volumeCropping');\n        };\n        this.onCameraModified = (evt) => {\n            const { element } = evt.currentTarget\n                ? { element: evt.currentTarget }\n                : evt.detail;\n            const enabledElement = getEnabledElement(element);\n            this._updateClippingPlanes(enabledElement.viewport);\n            enabledElement.viewport.render();\n        };\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const actorEntry = viewport.getDefaultActor();\n            const actor = actorEntry.actor;\n            const mapper = actor.getMapper();\n            const mouseCanvas = [\n                evt.detail.currentPoints.canvas[0],\n                evt.detail.currentPoints.canvas[1],\n            ];\n            this.draggingSphereIndex = null;\n            this.cornerDragOffset = null;\n            this.faceDragOffset = null;\n            for (let i = 0; i < this.sphereStates.length; ++i) {\n                const sphereCanvas = viewport.worldToCanvas(this.sphereStates[i].point);\n                const dist = Math.sqrt(Math.pow(mouseCanvas[0] - sphereCanvas[0], 2) +\n                    Math.pow(mouseCanvas[1] - sphereCanvas[1], 2));\n                if (dist < this.configuration.grabSpherePixelDistance) {\n                    this.draggingSphereIndex = i;\n                    element.style.cursor = 'grabbing';\n                    const sphereState = this.sphereStates[i];\n                    const mouseWorld = viewport.canvasToWorld(mouseCanvas);\n                    if (sphereState.isCorner) {\n                        this.cornerDragOffset = [\n                            sphereState.point[0] - mouseWorld[0],\n                            sphereState.point[1] - mouseWorld[1],\n                            sphereState.point[2] - mouseWorld[2],\n                        ];\n                        this.faceDragOffset = null;\n                    }\n                    else {\n                        const axisIdx = { x: 0, y: 1, z: 2 }[sphereState.axis];\n                        this.faceDragOffset =\n                            sphereState.point[axisIdx] - mouseWorld[axisIdx];\n                        this.cornerDragOffset = null;\n                    }\n                    return true;\n                }\n            }\n            const hasSampleDistance = 'getSampleDistance' in mapper || 'getCurrentSampleDistance' in mapper;\n            if (!hasSampleDistance) {\n                return true;\n            }\n            const originalSampleDistance = mapper.getSampleDistance();\n            if (!this._hasResolutionChanged) {\n                const { rotateSampleDistanceFactor } = this.configuration;\n                mapper.setSampleDistance(originalSampleDistance * rotateSampleDistanceFactor);\n                this._hasResolutionChanged = true;\n                if (this.cleanUp !== null) {\n                    document.removeEventListener('mouseup', this.cleanUp);\n                }\n                this.cleanUp = () => {\n                    mapper.setSampleDistance(originalSampleDistance);\n                    evt.target.style.cursor = '';\n                    if (this.draggingSphereIndex !== null) {\n                        const sphereState = this.sphereStates[this.draggingSphereIndex];\n                        const [viewport3D] = this._getViewportsInfo();\n                        const renderingEngine = getRenderingEngine(viewport3D.renderingEngineId);\n                        const viewport = renderingEngine.getViewport(viewport3D.viewportId);\n                        if (sphereState.isCorner) {\n                            this._updateCornerSpheres();\n                            this._updateFaceSpheresFromCorners();\n                            this._updateClippingPlanesFromFaceSpheres(viewport);\n                        }\n                    }\n                    this.draggingSphereIndex = null;\n                    this.cornerDragOffset = null;\n                    this.faceDragOffset = null;\n                    viewport.render();\n                    this._hasResolutionChanged = false;\n                };\n                document.addEventListener('mouseup', this.cleanUp, { once: true });\n            }\n            return true;\n        };\n        this._onMouseMoveSphere = (evt) => {\n            if (this.draggingSphereIndex === null) {\n                return false;\n            }\n            const sphereState = this.sphereStates[this.draggingSphereIndex];\n            if (!sphereState) {\n                return false;\n            }\n            const { viewport, world } = this._getViewportAndWorldCoords(evt);\n            if (!viewport || !world) {\n                return false;\n            }\n            if (sphereState.isCorner) {\n                const newCorner = this._calculateNewCornerPosition(world);\n                this._updateSpherePosition(sphereState, newCorner);\n                const axisFlags = this._parseCornerKey(sphereState.uid);\n                this._updateRelatedCorners(sphereState, newCorner, axisFlags);\n                this._updateFaceSpheresFromCorners();\n                this._updateCornerSpheres();\n            }\n            else {\n                const axisIdx = { x: 0, y: 1, z: 2 }[sphereState.axis];\n                let newValue = world[axisIdx];\n                if (this.faceDragOffset !== null) {\n                    newValue += this.faceDragOffset;\n                }\n                sphereState.point[axisIdx] = newValue;\n                sphereState.sphereSource.setCenter(...sphereState.point);\n                sphereState.sphereSource.modified();\n                this._updateCornerSpheresFromFaces();\n                this._updateFaceSpheresFromCorners();\n                this._updateCornerSpheres();\n            }\n            this._updateClippingPlanesFromFaceSpheres(viewport);\n            viewport.render();\n            this._triggerToolChangedEvent(sphereState);\n            return true;\n        };\n        this._onControlToolChange = (evt) => {\n            const viewport = this._getViewport();\n            if (!evt.detail.toolCenter) {\n                triggerEvent(eventTarget, Events.VOLUMECROPPING_TOOL_CHANGED, {\n                    originalClippingPlanes: this.originalClippingPlanes,\n                    viewportId: viewport.id,\n                    renderingEngineId: viewport.renderingEngineId,\n                    seriesInstanceUID: this.seriesInstanceUID,\n                });\n            }\n            else {\n                if (evt.detail.seriesInstanceUID !== this.seriesInstanceUID) {\n                    return;\n                }\n                const isMin = evt.detail.handleType === 'min';\n                const toolCenter = isMin\n                    ? evt.detail.toolCenterMin\n                    : evt.detail.toolCenterMax;\n                const normals = isMin\n                    ? [\n                        [1, 0, 0],\n                        [0, 1, 0],\n                        [0, 0, 1],\n                    ]\n                    : [\n                        [-1, 0, 0],\n                        [0, -1, 0],\n                        [0, 0, -1],\n                    ];\n                const planeIndices = isMin\n                    ? [PLANEINDEX.XMIN, PLANEINDEX.YMIN, PLANEINDEX.ZMIN]\n                    : [PLANEINDEX.XMAX, PLANEINDEX.YMAX, PLANEINDEX.ZMAX];\n                const sphereIndices = isMin\n                    ? [SPHEREINDEX.XMIN, SPHEREINDEX.YMIN, SPHEREINDEX.ZMIN]\n                    : [SPHEREINDEX.XMAX, SPHEREINDEX.YMAX, SPHEREINDEX.ZMAX];\n                const axes = ['x', 'y', 'z'];\n                const orientationAxes = [\n                    Enums.OrientationAxis.SAGITTAL,\n                    Enums.OrientationAxis.CORONAL,\n                    Enums.OrientationAxis.AXIAL,\n                ];\n                for (let i = 0; i < 3; ++i) {\n                    const origin = [0, 0, 0];\n                    origin[i] = toolCenter[i];\n                    const plane = vtkPlane.newInstance({\n                        origin,\n                        normal: normals[i],\n                    });\n                    this.originalClippingPlanes[planeIndices[i]].origin = plane.getOrigin();\n                    this.sphereStates[sphereIndices[i]].point[i] = plane.getOrigin()[i];\n                    this.sphereStates[sphereIndices[i]].sphereSource.setCenter(...this.sphereStates[sphereIndices[i]].point);\n                    this.sphereStates[sphereIndices[i]].sphereSource.modified();\n                    const otherSphere = this.sphereStates.find((s, idx) => s.axis === axes[i] && idx !== sphereIndices[i]);\n                    const newCenter = (otherSphere.point[i] + plane.getOrigin()[i]) / 2;\n                    this.sphereStates.forEach((state) => {\n                        if (!state.isCorner &&\n                            state.axis !== axes[i] &&\n                            !evt.detail.viewportOrientation.includes(orientationAxes[i])) {\n                            state.point[i] = newCenter;\n                            state.sphereSource.setCenter(state.point);\n                            state.sphereActor.getProperty().setColor(state.color);\n                            state.sphereSource.modified();\n                        }\n                    });\n                    const volumeActor = viewport.getDefaultActor()?.actor;\n                    if (volumeActor) {\n                        const mapper = volumeActor.getMapper();\n                        const clippingPlanes = mapper.getClippingPlanes();\n                        if (clippingPlanes) {\n                            clippingPlanes[planeIndices[i]].setOrigin(plane.getOrigin());\n                        }\n                    }\n                }\n                this._updateCornerSpheres();\n                viewport.render();\n            }\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this._initialize3DViewports = (viewportsInfo) => {\n            if (!viewportsInfo || !viewportsInfo.length || !viewportsInfo[0]) {\n                console.warn('VolumeCroppingTool: No viewportsInfo available for initialization of volumecroppingtool.');\n                return;\n            }\n            const viewport = this._getViewport();\n            const volumeActors = viewport.getActors();\n            if (!volumeActors || volumeActors.length === 0) {\n                console.warn('VolumeCroppingTool: No volume actors found in the viewport.');\n                return;\n            }\n            const imageData = volumeActors[0].actor.getMapper().getInputData();\n            if (!imageData) {\n                console.warn('VolumeCroppingTool: No image data found for volume actor.');\n                return;\n            }\n            this.seriesInstanceUID = imageData.seriesInstanceUID || 'unknown';\n            const worldBounds = imageData.getBounds();\n            const cropFactor = this.configuration.initialCropFactor || 0.1;\n            const xRange = worldBounds[1] - worldBounds[0];\n            const yRange = worldBounds[3] - worldBounds[2];\n            const zRange = worldBounds[5] - worldBounds[4];\n            const xMin = worldBounds[0] + cropFactor * xRange;\n            const xMax = worldBounds[1] - cropFactor * xRange;\n            const yMin = worldBounds[2] + cropFactor * yRange;\n            const yMax = worldBounds[3] - cropFactor * yRange;\n            const zMin = worldBounds[4] + cropFactor * zRange;\n            const zMax = worldBounds[5] - cropFactor * zRange;\n            const planes = [];\n            const planeXmin = vtkPlane.newInstance({\n                origin: [xMin, 0, 0],\n                normal: [1, 0, 0],\n            });\n            const planeXmax = vtkPlane.newInstance({\n                origin: [xMax, 0, 0],\n                normal: [-1, 0, 0],\n            });\n            const planeYmin = vtkPlane.newInstance({\n                origin: [0, yMin, 0],\n                normal: [0, 1, 0],\n            });\n            const planeYmax = vtkPlane.newInstance({\n                origin: [0, yMax, 0],\n                normal: [0, -1, 0],\n            });\n            const planeZmin = vtkPlane.newInstance({\n                origin: [0, 0, zMin],\n                normal: [0, 0, 1],\n            });\n            const planeZmax = vtkPlane.newInstance({\n                origin: [0, 0, zMax],\n                normal: [0, 0, -1],\n            });\n            const mapper = viewport\n                .getDefaultActor()\n                .actor.getMapper();\n            planes.push(planeXmin);\n            planes.push(planeXmax);\n            planes.push(planeYmin);\n            planes.push(planeYmax);\n            planes.push(planeZmin);\n            planes.push(planeZmax);\n            const originalPlanes = planes.map((plane) => ({\n                origin: [...plane.getOrigin()],\n                normal: [...plane.getNormal()],\n            }));\n            this.originalClippingPlanes = originalPlanes;\n            const sphereXminPoint = [xMin, (yMax + yMin) / 2, (zMax + zMin) / 2];\n            const sphereXmaxPoint = [xMax, (yMax + yMin) / 2, (zMax + zMin) / 2];\n            const sphereYminPoint = [(xMax + xMin) / 2, yMin, (zMax + zMin) / 2];\n            const sphereYmaxPoint = [(xMax + xMin) / 2, yMax, (zMax + zMin) / 2];\n            const sphereZminPoint = [(xMax + xMin) / 2, (yMax + yMin) / 2, zMin];\n            const sphereZmaxPoint = [(xMax + xMin) / 2, (yMax + yMin) / 2, zMax];\n            const adaptiveRadius = this._calculateAdaptiveSphereRadius(Math.sqrt(xRange * xRange + yRange * yRange + zRange * zRange));\n            this._addSphere(viewport, sphereXminPoint, 'x', 'min', null, adaptiveRadius);\n            this._addSphere(viewport, sphereXmaxPoint, 'x', 'max', null, adaptiveRadius);\n            this._addSphere(viewport, sphereYminPoint, 'y', 'min', null, adaptiveRadius);\n            this._addSphere(viewport, sphereYmaxPoint, 'y', 'max', null, adaptiveRadius);\n            this._addSphere(viewport, sphereZminPoint, 'z', 'min', null, adaptiveRadius);\n            this._addSphere(viewport, sphereZmaxPoint, 'z', 'max', null, adaptiveRadius);\n            const corners = [\n                [xMin, yMin, zMin],\n                [xMin, yMin, zMax],\n                [xMin, yMax, zMin],\n                [xMin, yMax, zMax],\n                [xMax, yMin, zMin],\n                [xMax, yMin, zMax],\n                [xMax, yMax, zMin],\n                [xMax, yMax, zMax],\n            ];\n            const cornerKeys = [\n                'XMIN_YMIN_ZMIN',\n                'XMIN_YMIN_ZMAX',\n                'XMIN_YMAX_ZMIN',\n                'XMIN_YMAX_ZMAX',\n                'XMAX_YMIN_ZMIN',\n                'XMAX_YMIN_ZMAX',\n                'XMAX_YMAX_ZMIN',\n                'XMAX_YMAX_ZMAX',\n            ];\n            for (let i = 0; i < corners.length; i++) {\n                this._addSphere(viewport, corners[i], 'corner', null, cornerKeys[i], adaptiveRadius);\n            }\n            const edgeCornerPairs = [\n                ['XMIN_YMIN_ZMIN', 'XMAX_YMIN_ZMIN'],\n                ['XMIN_YMIN_ZMAX', 'XMAX_YMIN_ZMAX'],\n                ['XMIN_YMAX_ZMIN', 'XMAX_YMAX_ZMIN'],\n                ['XMIN_YMAX_ZMAX', 'XMAX_YMAX_ZMAX'],\n                ['XMIN_YMIN_ZMIN', 'XMIN_YMAX_ZMIN'],\n                ['XMIN_YMIN_ZMAX', 'XMIN_YMAX_ZMAX'],\n                ['XMAX_YMIN_ZMIN', 'XMAX_YMAX_ZMIN'],\n                ['XMAX_YMIN_ZMAX', 'XMAX_YMAX_ZMAX'],\n                ['XMIN_YMIN_ZMIN', 'XMIN_YMIN_ZMAX'],\n                ['XMIN_YMAX_ZMIN', 'XMIN_YMAX_ZMAX'],\n                ['XMAX_YMIN_ZMIN', 'XMAX_YMIN_ZMAX'],\n                ['XMAX_YMAX_ZMIN', 'XMAX_YMAX_ZMAX'],\n            ];\n            edgeCornerPairs.forEach(([key1, key2], i) => {\n                const state1 = this.sphereStates.find((s) => s.uid === `corner_${key1}`);\n                const state2 = this.sphereStates.find((s) => s.uid === `corner_${key2}`);\n                if (state1 && state2) {\n                    const uid = `edge_${key1}_${key2}`;\n                    const { actor, source } = this._addLine3DBetweenPoints(viewport, state1.point, state2.point, [0.7, 0.7, 0.7], uid);\n                    this.edgeLines[uid] = { actor, source, key1, key2 };\n                }\n            });\n            mapper.addClippingPlane(planeXmin);\n            mapper.addClippingPlane(planeXmax);\n            mapper.addClippingPlane(planeYmin);\n            mapper.addClippingPlane(planeYmax);\n            mapper.addClippingPlane(planeZmin);\n            mapper.addClippingPlane(planeZmax);\n            eventTarget.addEventListener(Events.VOLUMECROPPINGCONTROL_TOOL_CHANGED, (evt) => {\n                this._onControlToolChange(evt);\n            });\n            viewport.render();\n        };\n        this._getViewportAndWorldCoords = (evt) => {\n            const viewport = this._getViewport();\n            const x = evt.detail.currentPoints.canvas[0];\n            const y = evt.detail.currentPoints.canvas[1];\n            const world = viewport.canvasToWorld([x, y]);\n            return { viewport, world };\n        };\n        this._getViewport = () => {\n            const [viewport3D] = this._getViewportsInfo();\n            const renderingEngine = getRenderingEngine(viewport3D.renderingEngineId);\n            return renderingEngine.getViewport(viewport3D.viewportId);\n        };\n        this._handleCornerSphereMovement = (sphereState, world, viewport) => {\n            const newCorner = this._calculateNewCornerPosition(world);\n            this._updateSpherePosition(sphereState, newCorner);\n            const axisFlags = this._parseCornerKey(sphereState.uid);\n            this._updateRelatedCorners(sphereState, newCorner, axisFlags);\n            this._updateAfterCornerMovement(viewport);\n        };\n        this._handleFaceSphereMovement = (sphereState, world, viewport) => {\n            const axisIdx = { x: 0, y: 1, z: 2 }[sphereState.axis];\n            let newValue = world[axisIdx];\n            if (this.faceDragOffset !== null) {\n                newValue += this.faceDragOffset;\n            }\n            sphereState.point[axisIdx] = newValue;\n            sphereState.sphereSource.setCenter(...sphereState.point);\n            sphereState.sphereSource.modified();\n            this._updateAfterFaceMovement(viewport);\n        };\n        this._calculateNewCornerPosition = (world) => {\n            let newCorner = [world[0], world[1], world[2]];\n            if (this.cornerDragOffset) {\n                newCorner = [\n                    world[0] + this.cornerDragOffset[0],\n                    world[1] + this.cornerDragOffset[1],\n                    world[2] + this.cornerDragOffset[2],\n                ];\n            }\n            return newCorner;\n        };\n        this._parseCornerKey = (uid) => {\n            const cornerKey = uid.replace('corner_', '');\n            return {\n                isXMin: cornerKey.includes('XMIN'),\n                isXMax: cornerKey.includes('XMAX'),\n                isYMin: cornerKey.includes('YMIN'),\n                isYMax: cornerKey.includes('YMAX'),\n                isZMin: cornerKey.includes('ZMIN'),\n                isZMax: cornerKey.includes('ZMAX'),\n            };\n        };\n        this._updateSpherePosition = (sphereState, newPosition) => {\n            sphereState.point = newPosition;\n            sphereState.sphereSource.setCenter(...newPosition);\n            sphereState.sphereSource.modified();\n        };\n        this._updateRelatedCorners = (draggedSphere, newCorner, axisFlags) => {\n            this.sphereStates.forEach((state) => {\n                if (!state.isCorner || state === draggedSphere) {\n                    return;\n                }\n                const key = state.uid.replace('corner_', '');\n                const shouldUpdate = this._shouldUpdateCorner(key, axisFlags);\n                if (shouldUpdate) {\n                    this._updateCornerCoordinates(state, newCorner, key, axisFlags);\n                }\n            });\n        };\n        this._shouldUpdateCorner = (cornerKey, axisFlags) => {\n            return ((axisFlags.isXMin && cornerKey.includes('XMIN')) ||\n                (axisFlags.isXMax && cornerKey.includes('XMAX')) ||\n                (axisFlags.isYMin && cornerKey.includes('YMIN')) ||\n                (axisFlags.isYMax && cornerKey.includes('YMAX')) ||\n                (axisFlags.isZMin && cornerKey.includes('ZMIN')) ||\n                (axisFlags.isZMax && cornerKey.includes('ZMAX')));\n        };\n        this._updateCornerCoordinates = (state, newCorner, cornerKey, axisFlags) => {\n            if ((axisFlags.isXMin && cornerKey.includes('XMIN')) ||\n                (axisFlags.isXMax && cornerKey.includes('XMAX'))) {\n                state.point[0] = newCorner[0];\n            }\n            if ((axisFlags.isYMin && cornerKey.includes('YMIN')) ||\n                (axisFlags.isYMax && cornerKey.includes('YMAX'))) {\n                state.point[1] = newCorner[1];\n            }\n            if ((axisFlags.isZMin && cornerKey.includes('ZMIN')) ||\n                (axisFlags.isZMax && cornerKey.includes('ZMAX'))) {\n                state.point[2] = newCorner[2];\n            }\n            state.sphereSource.setCenter(...state.point);\n            state.sphereSource.modified();\n        };\n        this._updateAfterCornerMovement = (viewport) => {\n            this._updateFaceSpheresFromCorners();\n            this._updateCornerSpheres();\n            this._updateClippingPlanesFromFaceSpheres(viewport);\n        };\n        this._updateAfterFaceMovement = (viewport) => {\n            this._updateCornerSpheresFromFaces();\n            this._updateClippingPlanesFromFaceSpheres(viewport);\n        };\n        this._triggerToolChangedEvent = (sphereState) => {\n            triggerEvent(eventTarget, Events.VOLUMECROPPING_TOOL_CHANGED, {\n                toolCenter: sphereState.point,\n                axis: sphereState.isCorner ? 'corner' : sphereState.axis,\n                draggingSphereIndex: this.draggingSphereIndex,\n                seriesInstanceUID: this.seriesInstanceUID,\n            });\n        };\n        this._onNewVolume = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            this.originalClippingPlanes = [];\n            this.sphereStates = [];\n            this.edgeLines = {};\n            this._initialize3DViewports(viewportsInfo);\n        };\n        this._rotateCamera = (viewport, centerWorld, axis, angle) => {\n            const vtkCamera = viewport.getVtkActiveCamera();\n            const viewUp = vtkCamera.getViewUp();\n            const focalPoint = vtkCamera.getFocalPoint();\n            const position = vtkCamera.getPosition();\n            const newPosition = [0, 0, 0];\n            const newFocalPoint = [0, 0, 0];\n            const newViewUp = [0, 0, 0];\n            const transform = mat4.identity(new Float32Array(16));\n            mat4.translate(transform, transform, centerWorld);\n            mat4.rotate(transform, transform, angle, axis);\n            mat4.translate(transform, transform, [\n                -centerWorld[0],\n                -centerWorld[1],\n                -centerWorld[2],\n            ]);\n            vec3.transformMat4(newPosition, position, transform);\n            vec3.transformMat4(newFocalPoint, focalPoint, transform);\n            mat4.identity(transform);\n            mat4.rotate(transform, transform, angle, axis);\n            vec3.transformMat4(newViewUp, viewUp, transform);\n            viewport.setCamera({\n                position: newPosition,\n                viewUp: newViewUp,\n                focalPoint: newFocalPoint,\n            });\n        };\n        this.touchDragCallback = this._dragCallback.bind(this);\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    onSetToolActive() {\n        if (this.sphereStates && this.sphereStates.length > 0) {\n            if (this.configuration.showHandles) {\n                this.setHandlesVisible(false);\n                this.setClippingPlanesVisible(false);\n            }\n            else {\n                this.setHandlesVisible(true);\n                this.setClippingPlanesVisible(true);\n            }\n        }\n        else {\n            const viewportsInfo = this._getViewportsInfo();\n            const subscribeToElementResize = () => {\n                viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                    if (!this._resizeObservers.has(viewportId)) {\n                        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId) || { viewport: null };\n                        if (!viewport) {\n                            return;\n                        }\n                        const { element } = viewport;\n                        const resizeObserver = new ResizeObserver(() => {\n                            const element = getEnabledElementByIds(viewportId, renderingEngineId);\n                            if (!element) {\n                                return;\n                            }\n                            const { viewport } = element;\n                            const viewPresentation = viewport.getViewPresentation();\n                            viewport.resetCamera();\n                            viewport.setViewPresentation(viewPresentation);\n                            viewport.render();\n                        });\n                        resizeObserver.observe(element);\n                        this._resizeObservers.set(viewportId, resizeObserver);\n                    }\n                });\n            };\n            subscribeToElementResize();\n            this._viewportAddedListener = (evt) => {\n                if (evt.detail.toolGroupId === this.toolGroupId) {\n                    subscribeToElementResize();\n                }\n            };\n            eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n            this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n            this._subscribeToViewportNewVolumeSet(viewportsInfo);\n            this._initialize3DViewports(viewportsInfo);\n            if (this.sphereStates && this.sphereStates.length > 0) {\n                this.setHandlesVisible(true);\n            }\n            else {\n                this.originalClippingPlanes = [];\n                this._initialize3DViewports(viewportsInfo);\n            }\n        }\n    }\n    onSetToolDisabled() {\n        this._resizeObservers.forEach((resizeObserver, viewportId) => {\n            resizeObserver.disconnect();\n            this._resizeObservers.delete(viewportId);\n        });\n        if (this._viewportAddedListener) {\n            eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n            this._viewportAddedListener = null;\n        }\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n    }\n    setHandlesVisible(visible) {\n        this.configuration.showHandles = visible;\n        if (visible) {\n            this.sphereStates[SPHEREINDEX.XMIN].point[0] =\n                this.originalClippingPlanes[PLANEINDEX.XMIN].origin[0];\n            this.sphereStates[SPHEREINDEX.XMAX].point[0] =\n                this.originalClippingPlanes[PLANEINDEX.XMAX].origin[0];\n            this.sphereStates[SPHEREINDEX.YMIN].point[1] =\n                this.originalClippingPlanes[PLANEINDEX.YMIN].origin[1];\n            this.sphereStates[SPHEREINDEX.YMAX].point[1] =\n                this.originalClippingPlanes[PLANEINDEX.YMAX].origin[1];\n            this.sphereStates[SPHEREINDEX.ZMIN].point[2] =\n                this.originalClippingPlanes[PLANEINDEX.ZMIN].origin[2];\n            this.sphereStates[SPHEREINDEX.ZMAX].point[2] =\n                this.originalClippingPlanes[PLANEINDEX.ZMAX].origin[2];\n            [\n                SPHEREINDEX.XMIN,\n                SPHEREINDEX.XMAX,\n                SPHEREINDEX.YMIN,\n                SPHEREINDEX.YMAX,\n                SPHEREINDEX.ZMIN,\n                SPHEREINDEX.ZMAX,\n            ].forEach((idx) => {\n                const s = this.sphereStates[idx];\n                s.sphereSource.setCenter(...s.point);\n                s.sphereSource.modified();\n            });\n            this._updateCornerSpheres();\n        }\n        this._updateHandlesVisibility();\n        const viewportsInfo = this._getViewportsInfo();\n        const [viewport3D] = viewportsInfo;\n        const renderingEngine = getRenderingEngine(viewport3D.renderingEngineId);\n        const viewport = renderingEngine.getViewport(viewport3D.viewportId);\n        viewport.render();\n    }\n    getHandlesVisible() {\n        return this.configuration.showHandles;\n    }\n    getClippingPlanesVisible() {\n        return this.configuration.showClippingPlanes;\n    }\n    setClippingPlanesVisible(visible) {\n        this.configuration.showClippingPlanes = visible;\n        const viewport = this._getViewport();\n        this._updateClippingPlanes(viewport);\n        viewport.render();\n    }\n    _dragCallback(evt) {\n        const { element, currentPoints, lastPoints } = evt.detail;\n        if (this.draggingSphereIndex !== null) {\n            this._onMouseMoveSphere(evt);\n        }\n        else {\n            const currentPointsCanvas = currentPoints.canvas;\n            const lastPointsCanvas = lastPoints.canvas;\n            const { rotateIncrementDegrees } = this.configuration;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const width = element.clientWidth;\n            const height = element.clientHeight;\n            const normalizedPosition = [\n                currentPointsCanvas[0] / width,\n                currentPointsCanvas[1] / height,\n            ];\n            const normalizedPreviousPosition = [\n                lastPointsCanvas[0] / width,\n                lastPointsCanvas[1] / height,\n            ];\n            const center = [width * 0.5, height * 0.5];\n            const centerWorld = viewport.canvasToWorld(center);\n            const normalizedCenter = [0.5, 0.5];\n            const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n            const op = [normalizedPreviousPosition[0], 0, 0];\n            const oe = [normalizedPosition[0], 0, 0];\n            const opsq = op[0] ** 2;\n            const oesq = oe[0] ** 2;\n            const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n            const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n            const nop = [op[0], 0, lop];\n            vtkMath.normalize(nop);\n            const noe = [oe[0], 0, loe];\n            vtkMath.normalize(noe);\n            const dot = vtkMath.dot(nop, noe);\n            if (Math.abs(dot) > 0.0001) {\n                const angleX = -2 *\n                    Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\n                    Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\n                    rotateIncrementDegrees;\n                const upVec = camera.viewUp;\n                const atV = camera.viewPlaneNormal;\n                const rightV = [0, 0, 0];\n                const forwardV = [0, 0, 0];\n                vtkMath.cross(upVec, atV, rightV);\n                vtkMath.normalize(rightV);\n                vtkMath.cross(atV, rightV, forwardV);\n                vtkMath.normalize(forwardV);\n                vtkMath.normalize(upVec);\n                this._rotateCamera(viewport, centerWorld, forwardV, angleX);\n                const angleY = (normalizedPreviousPosition[1] - normalizedPosition[1]) *\n                    rotateIncrementDegrees;\n                this._rotateCamera(viewport, centerWorld, rightV, angleY);\n            }\n            viewport.render();\n        }\n    }\n    _updateClippingPlanes(viewport) {\n        const actorEntry = viewport.getDefaultActor();\n        if (!actorEntry || !actorEntry.actor) {\n            if (!viewport._missingActorWarned) {\n                console.warn('VolumeCroppingTool._updateClippingPlanes: No default actor found in viewport.');\n                viewport._missingActorWarned = true;\n            }\n            return;\n        }\n        const actor = actorEntry.actor;\n        const mapper = actor.getMapper();\n        const matrix = actor.getMatrix();\n        if (!this.configuration.showClippingPlanes) {\n            mapper.removeAllClippingPlanes();\n            return;\n        }\n        const rot = mat3.create();\n        mat3.fromMat4(rot, matrix);\n        const normalMatrix = mat3.create();\n        mat3.invert(normalMatrix, rot);\n        mat3.transpose(normalMatrix, normalMatrix);\n        const originalPlanes = this.originalClippingPlanes;\n        if (!originalPlanes || !originalPlanes.length) {\n            return;\n        }\n        mapper.removeAllClippingPlanes();\n        const transformedOrigins = [];\n        const transformedNormals = [];\n        for (let i = 0; i < originalPlanes.length; ++i) {\n            const plane = originalPlanes[i];\n            const oVec = vec3.create();\n            vec3.transformMat4(oVec, new Float32Array(plane.origin), matrix);\n            const o = [oVec[0], oVec[1], oVec[2]];\n            const nVec = vec3.create();\n            vec3.transformMat3(nVec, new Float32Array(plane.normal), normalMatrix);\n            vec3.normalize(nVec, nVec);\n            const n = [nVec[0], nVec[1], nVec[2]];\n            transformedOrigins.push(o);\n            transformedNormals.push(n);\n        }\n        for (let i = 0; i < transformedOrigins.length; ++i) {\n            const planeInstance = vtkPlane.newInstance({\n                origin: transformedOrigins[i],\n                normal: transformedNormals[i],\n            });\n            mapper.addClippingPlane(planeInstance);\n        }\n    }\n    _updateHandlesVisibility() {\n        this.sphereStates.forEach((state) => {\n            if (state.sphereActor) {\n                state.sphereActor.setVisibility(this.configuration.showHandles);\n            }\n        });\n        Object.values(this.edgeLines).forEach(({ actor }) => {\n            if (actor) {\n                actor.setVisibility(this.configuration.showHandles);\n            }\n        });\n    }\n    _addLine3DBetweenPoints(viewport, point1, point2, color = [0.7, 0.7, 0.7], uid = '') {\n        if (point1[0] === point2[0] &&\n            point1[1] === point2[1] &&\n            point1[2] === point2[2]) {\n            return { actor: null, source: null };\n        }\n        const points = vtkPoints.newInstance();\n        points.setNumberOfPoints(2);\n        points.setPoint(0, point1[0], point1[1], point1[2]);\n        points.setPoint(1, point2[0], point2[1], point2[2]);\n        const lines = vtkCellArray.newInstance({ values: [2, 0, 1] });\n        const polyData = vtkPolyData.newInstance();\n        polyData.setPoints(points);\n        polyData.setLines(lines);\n        const mapper = vtkMapper.newInstance();\n        mapper.setInputData(polyData);\n        const actor = vtkActor.newInstance();\n        actor.setMapper(mapper);\n        actor.getProperty().setColor(...color);\n        actor.getProperty().setLineWidth(0.5);\n        actor.getProperty().setOpacity(1.0);\n        actor.getProperty().setInterpolationToFlat();\n        actor.getProperty().setAmbient(1.0);\n        actor.getProperty().setDiffuse(0.0);\n        actor.getProperty().setSpecular(0.0);\n        actor.setVisibility(this.configuration.showHandles);\n        viewport.addActor({ actor, uid });\n        return { actor, source: polyData };\n    }\n    _addSphere(viewport, point, axis, position, cornerKey = null, adaptiveRadius) {\n        const uid = cornerKey ? `corner_${cornerKey}` : `${axis}_${position}`;\n        const sphereState = this.sphereStates.find((s) => s.uid === uid);\n        if (sphereState) {\n            return;\n        }\n        const sphereSource = vtkSphereSource.newInstance();\n        sphereSource.setCenter(point);\n        sphereSource.setRadius(adaptiveRadius);\n        const sphereMapper = vtkMapper.newInstance();\n        sphereMapper.setInputConnection(sphereSource.getOutputPort());\n        const sphereActor = vtkActor.newInstance();\n        sphereActor.setMapper(sphereMapper);\n        let color = [0.0, 1.0, 0.0];\n        const sphereColors = this.configuration.sphereColors || {};\n        if (cornerKey) {\n            color = sphereColors.CORNERS || [0.0, 0.0, 1.0];\n        }\n        else if (axis === 'z') {\n            color = sphereColors.AXIAL || [1.0, 0.0, 0.0];\n        }\n        else if (axis === 'x') {\n            color = sphereColors.SAGITTAL || [1.0, 1.0, 0.0];\n        }\n        else if (axis === 'y') {\n            color = sphereColors.CORONAL || [0.0, 1.0, 0.0];\n        }\n        const idx = this.sphereStates.findIndex((s) => s.uid === uid);\n        if (idx === -1) {\n            this.sphereStates.push({\n                point: point.slice(),\n                axis,\n                uid,\n                sphereSource,\n                sphereActor,\n                isCorner: !!cornerKey,\n                color,\n            });\n        }\n        else {\n            this.sphereStates[idx].point = point.slice();\n            this.sphereStates[idx].sphereSource = sphereSource;\n        }\n        const existingActors = viewport.getActors();\n        const existing = existingActors.find((a) => a.uid === uid);\n        if (existing) {\n            return;\n        }\n        sphereActor.getProperty().setColor(color);\n        sphereActor.setVisibility(this.configuration.showHandles);\n        viewport.addActor({ actor: sphereActor, uid: uid });\n    }\n    _calculateAdaptiveSphereRadius(diagonal) {\n        const baseRadius = this.configuration.sphereRadius !== undefined\n            ? this.configuration.sphereRadius\n            : 8;\n        const scaleFactor = this.configuration.sphereRadiusScale || 0.01;\n        const adaptiveRadius = diagonal * scaleFactor;\n        const minRadius = this.configuration.minSphereRadius || 2;\n        const maxRadius = this.configuration.maxSphereRadius || 50;\n        return Math.max(minRadius, Math.min(maxRadius, adaptiveRadius));\n    }\n    _updateClippingPlanesFromFaceSpheres(viewport) {\n        const mapper = viewport.getDefaultActor().actor.getMapper();\n        this.originalClippingPlanes[0].origin = [\n            ...this.sphereStates[SPHEREINDEX.XMIN].point,\n        ];\n        this.originalClippingPlanes[1].origin = [\n            ...this.sphereStates[SPHEREINDEX.XMAX].point,\n        ];\n        this.originalClippingPlanes[2].origin = [\n            ...this.sphereStates[SPHEREINDEX.YMIN].point,\n        ];\n        this.originalClippingPlanes[3].origin = [\n            ...this.sphereStates[SPHEREINDEX.YMAX].point,\n        ];\n        this.originalClippingPlanes[4].origin = [\n            ...this.sphereStates[SPHEREINDEX.ZMIN].point,\n        ];\n        this.originalClippingPlanes[5].origin = [\n            ...this.sphereStates[SPHEREINDEX.ZMAX].point,\n        ];\n        mapper.removeAllClippingPlanes();\n        for (let i = 0; i < 6; ++i) {\n            const origin = this.originalClippingPlanes[i].origin;\n            const normal = this.originalClippingPlanes[i].normal;\n            const plane = vtkPlane.newInstance({\n                origin,\n                normal,\n            });\n            mapper.addClippingPlane(plane);\n        }\n    }\n    _updateCornerSpheresFromFaces() {\n        const xMin = this.sphereStates[SPHEREINDEX.XMIN].point[0];\n        const xMax = this.sphereStates[SPHEREINDEX.XMAX].point[0];\n        const yMin = this.sphereStates[SPHEREINDEX.YMIN].point[1];\n        const yMax = this.sphereStates[SPHEREINDEX.YMAX].point[1];\n        const zMin = this.sphereStates[SPHEREINDEX.ZMIN].point[2];\n        const zMax = this.sphereStates[SPHEREINDEX.ZMAX].point[2];\n        const corners = [\n            { key: 'XMIN_YMIN_ZMIN', pos: [xMin, yMin, zMin] },\n            { key: 'XMIN_YMIN_ZMAX', pos: [xMin, yMin, zMax] },\n            { key: 'XMIN_YMAX_ZMIN', pos: [xMin, yMax, zMin] },\n            { key: 'XMIN_YMAX_ZMAX', pos: [xMin, yMax, zMax] },\n            { key: 'XMAX_YMIN_ZMIN', pos: [xMax, yMin, zMin] },\n            { key: 'XMAX_YMIN_ZMAX', pos: [xMax, yMin, zMax] },\n            { key: 'XMAX_YMAX_ZMIN', pos: [xMax, yMax, zMin] },\n            { key: 'XMAX_YMAX_ZMAX', pos: [xMax, yMax, zMax] },\n        ];\n        for (const corner of corners) {\n            const state = this.sphereStates.find((s) => s.uid === `corner_${corner.key}`);\n            if (state) {\n                state.point[0] = corner.pos[0];\n                state.point[1] = corner.pos[1];\n                state.point[2] = corner.pos[2];\n                state.sphereSource.setCenter(...state.point);\n                state.sphereSource.modified();\n            }\n        }\n    }\n    _updateFaceSpheresFromCorners() {\n        const corners = [\n            this.sphereStates[SPHEREINDEX.XMIN_YMIN_ZMIN].point,\n            this.sphereStates[SPHEREINDEX.XMIN_YMIN_ZMAX].point,\n            this.sphereStates[SPHEREINDEX.XMIN_YMAX_ZMIN].point,\n            this.sphereStates[SPHEREINDEX.XMIN_YMAX_ZMAX].point,\n            this.sphereStates[SPHEREINDEX.XMAX_YMIN_ZMIN].point,\n            this.sphereStates[SPHEREINDEX.XMAX_YMIN_ZMAX].point,\n            this.sphereStates[SPHEREINDEX.XMAX_YMAX_ZMIN].point,\n            this.sphereStates[SPHEREINDEX.XMAX_YMAX_ZMAX].point,\n        ];\n        const xs = corners.map((p) => p[0]);\n        const ys = corners.map((p) => p[1]);\n        const zs = corners.map((p) => p[2]);\n        const xMin = Math.min(...xs), xMax = Math.max(...xs);\n        const yMin = Math.min(...ys), yMax = Math.max(...ys);\n        const zMin = Math.min(...zs), zMax = Math.max(...zs);\n        this.sphereStates[SPHEREINDEX.XMIN].point = [\n            xMin,\n            (yMin + yMax) / 2,\n            (zMin + zMax) / 2,\n        ];\n        this.sphereStates[SPHEREINDEX.XMAX].point = [\n            xMax,\n            (yMin + yMax) / 2,\n            (zMin + zMax) / 2,\n        ];\n        this.sphereStates[SPHEREINDEX.YMIN].point = [\n            (xMin + xMax) / 2,\n            yMin,\n            (zMin + zMax) / 2,\n        ];\n        this.sphereStates[SPHEREINDEX.YMAX].point = [\n            (xMin + xMax) / 2,\n            yMax,\n            (zMin + zMax) / 2,\n        ];\n        this.sphereStates[SPHEREINDEX.ZMIN].point = [\n            (xMin + xMax) / 2,\n            (yMin + yMax) / 2,\n            zMin,\n        ];\n        this.sphereStates[SPHEREINDEX.ZMAX].point = [\n            (xMin + xMax) / 2,\n            (yMin + yMax) / 2,\n            zMax,\n        ];\n        [\n            SPHEREINDEX.XMIN,\n            SPHEREINDEX.XMAX,\n            SPHEREINDEX.YMIN,\n            SPHEREINDEX.YMAX,\n            SPHEREINDEX.ZMIN,\n            SPHEREINDEX.ZMAX,\n        ].forEach((idx) => {\n            const s = this.sphereStates[idx];\n            s.sphereSource.setCenter(...s.point);\n            s.sphereSource.modified();\n        });\n    }\n    _updateCornerSpheres() {\n        const xMin = this.sphereStates[SPHEREINDEX.XMIN].point[0];\n        const xMax = this.sphereStates[SPHEREINDEX.XMAX].point[0];\n        const yMin = this.sphereStates[SPHEREINDEX.YMIN].point[1];\n        const yMax = this.sphereStates[SPHEREINDEX.YMAX].point[1];\n        const zMin = this.sphereStates[SPHEREINDEX.ZMIN].point[2];\n        const zMax = this.sphereStates[SPHEREINDEX.ZMAX].point[2];\n        const corners = [\n            { key: 'XMIN_YMIN_ZMIN', pos: [xMin, yMin, zMin] },\n            { key: 'XMIN_YMIN_ZMAX', pos: [xMin, yMin, zMax] },\n            { key: 'XMIN_YMAX_ZMIN', pos: [xMin, yMax, zMin] },\n            { key: 'XMIN_YMAX_ZMAX', pos: [xMin, yMax, zMax] },\n            { key: 'XMAX_YMIN_ZMIN', pos: [xMax, yMin, zMin] },\n            { key: 'XMAX_YMIN_ZMAX', pos: [xMax, yMin, zMax] },\n            { key: 'XMAX_YMAX_ZMIN', pos: [xMax, yMax, zMin] },\n            { key: 'XMAX_YMAX_ZMAX', pos: [xMax, yMax, zMax] },\n        ];\n        for (const corner of corners) {\n            const state = this.sphereStates.find((s) => s.uid === `corner_${corner.key}`);\n            if (state) {\n                state.point[0] = corner.pos[0];\n                state.point[1] = corner.pos[1];\n                state.point[2] = corner.pos[2];\n                state.sphereSource.setCenter(...state.point);\n                state.sphereSource.modified();\n            }\n        }\n        Object.values(this.edgeLines).forEach(({ source, key1, key2 }) => {\n            const state1 = this.sphereStates.find((s) => s.uid === `corner_${key1}`);\n            const state2 = this.sphereStates.find((s) => s.uid === `corner_${key2}`);\n            if (state1 && state2) {\n                const points = source.getPoints();\n                points.setPoint(0, state1.point[0], state1.point[1], state1.point[2]);\n                points.setPoint(1, state2.point[0], state2.point[1], state2.point[2]);\n                points.modified();\n                source.modified();\n            }\n        });\n    }\n    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _subscribeToViewportNewVolumeSet(viewports) {\n        viewports.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n}\nVolumeCroppingTool.toolName = 'VolumeCropping';\nexport default VolumeCroppingTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nconst DIRECTIONS = {\n    X: [1, 0, 0],\n    Y: [0, 1, 0],\n    Z: [0, 0, 1],\n    CUSTOM: [],\n};\nclass VolumeRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            direction: DIRECTIONS.Z,\n            rotateIncrementDegrees: 30,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    mouseWheelCallback(evt) {\n        const { element, wheel } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { direction, rotateIncrementDegrees } = this.configuration;\n        const camera = viewport.getCamera();\n        const { viewUp, position, focalPoint } = camera;\n        const { direction: deltaY } = wheel;\n        const [cx, cy, cz] = focalPoint;\n        const [ax, ay, az] = direction;\n        const angle = (deltaY * (rotateIncrementDegrees * Math.PI)) / 180;\n        const newPosition = [0, 0, 0];\n        const newFocalPoint = [0, 0, 0];\n        const newViewUp = [0, 0, 0];\n        const transform = mat4.identity(new Float32Array(16));\n        mat4.translate(transform, transform, [cx, cy, cz]);\n        mat4.rotate(transform, transform, angle, [ax, ay, az]);\n        mat4.translate(transform, transform, [-cx, -cy, -cz]);\n        vec3.transformMat4(newPosition, position, transform);\n        vec3.transformMat4(newFocalPoint, focalPoint, transform);\n        mat4.identity(transform);\n        mat4.rotate(transform, transform, angle, [ax, ay, az]);\n        vec3.transformMat4(newViewUp, viewUp, transform);\n        viewport.setCamera({\n            position: newPosition,\n            viewUp: newViewUp,\n            focalPoint: newFocalPoint,\n        });\n        viewport.render();\n    }\n}\nVolumeRotateTool.toolName = 'VolumeRotateMouseWheel';\nexport default VolumeRotateTool;\n","import { AnnotationTool } from './base';\nimport { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../stateManagement';\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\nimport { drawRect as drawRectSvg } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { windowLevel } from '../utilities/voi';\nclass WindowLevelRegionTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            minWindowWidth: 10,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                    },\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            removeAnnotation(annotation.annotationUID);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationCompleted(annotation);\n            this.applyWindowLevelRegion(annotation, element);\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            const { currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n            const worldPos = currentPoints.world;\n            const { points } = data.handles;\n            const DEFAULT_HANDLE_INDEX = 3;\n            points[DEFAULT_HANDLE_INDEX] = [...worldPos];\n            const bottomLeftCanvas = worldToCanvas(points[0]);\n            const topRightCanvas = worldToCanvas(points[3]);\n            const bottomRightCanvas = [\n                topRightCanvas[0],\n                bottomLeftCanvas[1],\n            ];\n            const topLeftCanvas = [\n                bottomLeftCanvas[0],\n                topRightCanvas[1],\n            ];\n            const bottomRightWorld = canvasToWorld(bottomRightCanvas);\n            const topLeftWorld = canvasToWorld(topLeftCanvas);\n            points[1] = bottomRightWorld;\n            points[2] = topLeftWorld;\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const dataId = `${annotationUID}-rect`;\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this.applyWindowLevelRegion = (annotation, element) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const imageData = windowLevel.extractWindowLevelRegionToolData(viewport);\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const startCanvas = canvasCoordinates[0];\n            const endCanvas = canvasCoordinates[3];\n            let left = Math.min(startCanvas[0], endCanvas[0]);\n            let top = Math.min(startCanvas[1], endCanvas[1]);\n            let width = Math.abs(startCanvas[0] - endCanvas[0]);\n            let height = Math.abs(startCanvas[1] - endCanvas[1]);\n            left = utilities.clip(left, 0, imageData.width);\n            top = utilities.clip(top, 0, imageData.height);\n            width = Math.floor(Math.min(width, Math.abs(imageData.width - left)));\n            height = Math.floor(Math.min(height, Math.abs(imageData.height - top)));\n            const pixelLuminanceData = windowLevel.getLuminanceFromRegion(imageData, Math.round(left), Math.round(top), width, height);\n            const minMaxMean = windowLevel.calculateMinMaxMean(pixelLuminanceData, imageData.minPixelValue, imageData.maxPixelValue);\n            if (this.configuration.minWindowWidth === undefined) {\n                this.configuration.minWindowWidth = 10;\n            }\n            const windowWidth = Math.max(Math.abs(minMaxMean.max - minMaxMean.min), this.configuration.minWindowWidth);\n            const windowCenter = minMaxMean.mean;\n            const voiLutFunction = viewport.getProperties().VOILUTFunction;\n            const voiRange = utilities.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);\n            viewport.setProperties({ voiRange });\n            viewport.render();\n        };\n        this.cancel = () => {\n            return null;\n        };\n        this.isPointNearTool = () => {\n            return null;\n        };\n        this.toolSelectedCallback = () => {\n            return null;\n        };\n        this.handleSelectedCallback = () => {\n            return null;\n        };\n        this._activateModify = () => {\n            return null;\n        };\n        this._deactivateModify = () => {\n            return null;\n        };\n    }\n}\nWindowLevelRegionTool.toolName = 'WindowLevelRegion';\nexport default WindowLevelRegionTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport, cache, utilities, } from '@cornerstonejs/core';\nconst DEFAULT_MULTIPLIER = 4;\nconst DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;\nconst PT = 'PT';\nclass WindowLevelTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this._getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {\n            const middleSliceIndex = Math.floor(dimensions[2] / 2);\n            const frameLength = dimensions[0] * dimensions[1];\n            let bytesPerVoxel;\n            let TypedArrayConstructor;\n            if (scalarData instanceof Float32Array) {\n                bytesPerVoxel = 4;\n                TypedArrayConstructor = Float32Array;\n            }\n            else if (scalarData instanceof Uint8Array) {\n                bytesPerVoxel = 1;\n                TypedArrayConstructor = Uint8Array;\n            }\n            else if (scalarData instanceof Uint16Array) {\n                bytesPerVoxel = 2;\n                TypedArrayConstructor = Uint16Array;\n            }\n            else if (scalarData instanceof Int16Array) {\n                bytesPerVoxel = 2;\n                TypedArrayConstructor = Int16Array;\n            }\n            const buffer = scalarData.buffer;\n            const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;\n            const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);\n            const { max, min } = this._getMinMax(frame, frameLength);\n            return max - min;\n        };\n    }\n    touchDragCallback(evt) {\n        this.mouseDragCallback(evt);\n    }\n    mouseDragCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let volumeId, lower, upper, modality, newRange, viewportsContainingVolumeUID;\n        let isPreScaled = false;\n        const properties = viewport.getProperties();\n        if (viewport instanceof VolumeViewport) {\n            volumeId = viewport.getVolumeId();\n            viewportsContainingVolumeUID =\n                utilities.getViewportsWithVolumeId(volumeId);\n            ({ lower, upper } = properties.voiRange);\n            const volume = cache.getVolume(volumeId);\n            if (!volume) {\n                throw new Error('Volume not found ' + volumeId);\n            }\n            modality = volume.metadata.Modality;\n            isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;\n        }\n        else if (properties.voiRange) {\n            modality = viewport.modality;\n            ({ lower, upper } = properties.voiRange);\n            const { preScale = { scaled: false } } = viewport.getImageData?.() || {};\n            isPreScaled =\n                preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;\n        }\n        else {\n            throw new Error('Viewport is not a valid type');\n        }\n        if (modality === PT && isPreScaled) {\n            newRange = this.getPTScaledNewRange({\n                deltaPointsCanvas: deltaPoints.canvas,\n                lower,\n                upper,\n                clientHeight: element.clientHeight,\n                isPreScaled,\n                viewport,\n                volumeId,\n            });\n        }\n        else {\n            newRange = this.getNewRange({\n                viewport,\n                deltaPointsCanvas: deltaPoints.canvas,\n                volumeId,\n                lower,\n                upper,\n            });\n        }\n        if (newRange.lower >= newRange.upper) {\n            return;\n        }\n        viewport.setProperties({\n            voiRange: newRange,\n        });\n        viewport.render();\n        if (viewport instanceof VolumeViewport) {\n            viewportsContainingVolumeUID.forEach((vp) => {\n                if (viewport !== vp) {\n                    vp.render();\n                }\n            });\n            return;\n        }\n    }\n    getPTScaledNewRange({ deltaPointsCanvas, lower, upper, clientHeight, viewport, volumeId, isPreScaled, }) {\n        let multiplier = DEFAULT_MULTIPLIER;\n        if (isPreScaled) {\n            multiplier = 5 / clientHeight;\n        }\n        else {\n            multiplier =\n                this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n                    DEFAULT_MULTIPLIER;\n        }\n        const deltaY = deltaPointsCanvas[1];\n        const wcDelta = deltaY * multiplier;\n        upper -= wcDelta;\n        upper = isPreScaled ? Math.max(upper, 0.1) : upper;\n        return { lower, upper };\n    }\n    getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {\n        const multiplier = this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n            DEFAULT_MULTIPLIER;\n        const wwDelta = deltaPointsCanvas[0] * multiplier;\n        const wcDelta = deltaPointsCanvas[1] * multiplier;\n        let { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(lower, upper);\n        windowWidth += wwDelta;\n        windowCenter += wcDelta;\n        windowWidth = Math.max(windowWidth, 1);\n        const voiLutFunction = viewport.getProperties().VOILUTFunction;\n        return utilities.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);\n    }\n    _getMultiplierFromDynamicRange(viewport, volumeId) {\n        let imageDynamicRange;\n        if (volumeId) {\n            const imageVolume = cache.getVolume(volumeId);\n            const { voxelManager } = viewport.getImageData();\n            const middleSlicePixelData = voxelManager.getMiddleSliceData();\n            const calculatedDynamicRange = middleSlicePixelData.reduce((acc, pixel) => {\n                return [Math.min(acc[0], pixel), Math.max(acc[1], pixel)];\n            }, [Infinity, -Infinity]);\n            const BitsStored = imageVolume?.metadata?.BitsStored;\n            const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;\n            const calculatedRange = calculatedDynamicRange[1] - calculatedDynamicRange[0];\n            imageDynamicRange = !Number.isFinite(calculatedRange)\n                ? metadataDynamicRange\n                : Math.min(calculatedRange, metadataDynamicRange);\n        }\n        else {\n            imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);\n        }\n        const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;\n        return !Number.isFinite(ratio)\n            ? DEFAULT_IMAGE_DYNAMIC_RANGE\n            : ratio > 1\n                ? Math.round(ratio)\n                : ratio;\n    }\n    _getImageDynamicRangeFromViewport(viewport) {\n        const { imageData, voxelManager } = viewport.getImageData();\n        if (voxelManager?.getRange) {\n            const range = voxelManager.getRange();\n            return range[1] - range[0];\n        }\n        const dimensions = imageData.getDimensions();\n        if (imageData.getRange) {\n            const imageDataRange = imageData.getRange();\n            return imageDataRange[1] - imageDataRange[0];\n        }\n        let scalarData;\n        if (imageData.getScalarData) {\n            scalarData = imageData.getScalarData();\n        }\n        else {\n            scalarData = imageData.getPointData().getScalars().getData();\n        }\n        if (dimensions[2] !== 1) {\n            return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);\n        }\n        let range;\n        if (scalarData.getRange) {\n            range = scalarData.getRange();\n        }\n        else {\n            const { min, max } = this._getMinMax(scalarData, scalarData.length);\n            range = [min, max];\n        }\n        return range[1] - range[0];\n    }\n    _getMinMax(frame, frameLength) {\n        let min = Infinity;\n        let max = -Infinity;\n        for (let i = 0; i < frameLength; i++) {\n            const voxel = frame[i];\n            if (voxel < min) {\n                min = voxel;\n            }\n            if (voxel > max) {\n                max = voxel;\n            }\n        }\n        return { max, min };\n    }\n}\nWindowLevelTool.toolName = 'WindowLevel';\nexport default WindowLevelTool;\n","import { vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { getConfiguration } from '@cornerstonejs/core';\nimport { Enums, getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { Events } from '../enums';\nclass ZoomTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            zoomToCenter: false,\n            minZoomScale: 0.001,\n            maxZoomScale: 3000,\n            pinchToZoom: true,\n            pan: true,\n            invert: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const camera = enabledElement.viewport.getCamera();\n            const { focalPoint } = camera;\n            this.initialMousePosWorld = worldPos;\n            let dirVec = vec3.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);\n            dirVec = vec3.normalize(vec3.create(), dirVec);\n            this.dirVec = dirVec;\n            return false;\n        };\n        this.preTouchStartCallback = (evt) => {\n            if (!this.configuration.pinchToZoom) {\n                return this.preMouseDownCallback(evt);\n            }\n        };\n        this._dragParallelProjection = (evt, viewport, camera, pinch = false) => {\n            const { element, deltaPoints } = evt.detail;\n            const deltaY = pinch\n                ? evt.detail.deltaDistance.canvas\n                : deltaPoints.canvas[1];\n            const size = [element.clientWidth, element.clientHeight];\n            const { parallelScale, focalPoint, position } = camera;\n            const zoomScale = 5 / size[1];\n            const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);\n            const parallelScaleToSet = (1.0 - k) * parallelScale;\n            let focalPointToSet = focalPoint;\n            let positionToSet = position;\n            if (!this.configuration.zoomToCenter) {\n                const distanceToCanvasCenter = vec3.distance(focalPoint, this.initialMousePosWorld);\n                positionToSet = vec3.scaleAndAdd(vec3.create(), position, this.dirVec, -distanceToCanvasCenter * k);\n                focalPointToSet = vec3.scaleAndAdd(vec3.create(), focalPoint, this.dirVec, -distanceToCanvasCenter * k);\n            }\n            const imageData = viewport.getImageData();\n            let spacing = [1, 1, 1];\n            let cappedParallelScale = parallelScaleToSet;\n            let thresholdExceeded = false;\n            if (imageData) {\n                spacing = imageData.spacing;\n                const { dimensions } = imageData;\n                const imageWidth = dimensions[0] * spacing[0];\n                const imageHeight = dimensions[1] * spacing[1];\n                const canvasAspect = size[0] / size[1];\n                const insetImageMultiplier = getConfiguration().rendering\n                    ?.useLegacyCameraFOV\n                    ? 1.1\n                    : 1;\n                const displayArea = viewport.options?.displayArea;\n                const imageAreaScaleX = displayArea?.imageArea?.[0] ?? insetImageMultiplier;\n                const imageAreaScaleY = displayArea?.imageArea?.[1] ?? insetImageMultiplier;\n                const scaledImageWidth = imageWidth * imageAreaScaleX;\n                const scaledImageHeight = imageHeight * imageAreaScaleY;\n                const scaledImageAspect = scaledImageWidth / scaledImageHeight;\n                let minParallelScaleRequired;\n                if (scaledImageAspect > canvasAspect) {\n                    minParallelScaleRequired = (scaledImageWidth / canvasAspect) * 0.5;\n                }\n                else {\n                    minParallelScaleRequired = scaledImageHeight * 0.5;\n                }\n                const { minZoomScale, maxZoomScale } = this.configuration;\n                const minScaleInWorld = minParallelScaleRequired / maxZoomScale;\n                const maxScaleInWorld = minParallelScaleRequired / minZoomScale;\n                if (parallelScaleToSet < minScaleInWorld) {\n                    cappedParallelScale = minScaleInWorld;\n                    thresholdExceeded = true;\n                }\n                else if (parallelScaleToSet > maxScaleInWorld) {\n                    cappedParallelScale = maxScaleInWorld;\n                    thresholdExceeded = true;\n                }\n            }\n            viewport.setCamera({\n                parallelScale: cappedParallelScale,\n                focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,\n                position: thresholdExceeded ? position : positionToSet,\n            });\n        };\n        this._dragPerspectiveProjection = (evt, viewport, camera, pinch = false) => {\n            const { element, deltaPoints } = evt.detail;\n            const deltaY = pinch\n                ? evt.detail.deltaDistance.canvas\n                : deltaPoints.canvas[1];\n            const size = [element.clientWidth, element.clientHeight];\n            const { position, focalPoint, viewPlaneNormal } = camera;\n            const distance = vtkMath.distance2BetweenPoints(position, focalPoint);\n            const zoomScale = Math.sqrt(distance) / size[1];\n            const directionOfProjection = [\n                -viewPlaneNormal[0],\n                -viewPlaneNormal[1],\n                -viewPlaneNormal[2],\n            ];\n            const k = this.configuration.invert\n                ? deltaY / zoomScale\n                : deltaY * zoomScale;\n            let tmp = k * directionOfProjection[0];\n            position[0] += tmp;\n            focalPoint[0] += tmp;\n            tmp = k * directionOfProjection[1];\n            position[1] += tmp;\n            focalPoint[1] += tmp;\n            tmp = k * directionOfProjection[2];\n            position[2] += tmp;\n            focalPoint[2] += tmp;\n            viewport.setCamera({ position, focalPoint });\n        };\n        this.initialMousePosWorld = [0, 0, 0];\n        this.dirVec = [0, 0, 0];\n        if (this.configuration.pinchToZoom) {\n            this.touchDragCallback = this._pinchCallback.bind(this);\n        }\n        else {\n            this.touchDragCallback = this._dragCallback.bind(this);\n        }\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    mouseWheelCallback(evt) {\n        this._zoom(evt);\n    }\n    _pinchCallback(evt) {\n        const pointsList = evt.detail\n            .currentPointsList;\n        if (pointsList.length > 1) {\n            const { element, currentPoints } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const worldPos = currentPoints.world;\n            const { focalPoint } = camera;\n            this.initialMousePosWorld = worldPos;\n            let dirVec = vec3.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);\n            dirVec = vec3.normalize(vec3.create(), dirVec);\n            this.dirVec = dirVec;\n            if (camera.parallelProjection) {\n                this._dragParallelProjection(evt, viewport, camera, true);\n            }\n            else {\n                this._dragPerspectiveProjection(evt, viewport, camera, true);\n            }\n            viewport.render();\n        }\n        if (this.configuration.pan) {\n            this._panCallback(evt);\n        }\n    }\n    _dragCallback(evt) {\n        const { element } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        if (camera.parallelProjection) {\n            this._dragParallelProjection(evt, viewport, camera);\n        }\n        else {\n            this._dragPerspectiveProjection(evt, viewport, camera);\n        }\n        viewport.render();\n    }\n    _zoom(evt) {\n        const { element, points } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const wheelData = evt.detail.wheel;\n        const direction = wheelData.direction;\n        const eventDetails = {\n            detail: {\n                element,\n                eventName: Events.MOUSE_WHEEL,\n                renderingEngineId: enabledElement.renderingEngineId,\n                viewportId: viewport.id,\n                camera: {},\n                deltaPoints: {\n                    page: points.page,\n                    client: points.client,\n                    world: points.world,\n                    canvas: [0, -direction * 5],\n                },\n                startPoints: points,\n                lastPoints: points,\n                currentPoints: points,\n            },\n        };\n        if (viewport.type === Enums.ViewportType.STACK) {\n            this.preMouseDownCallback(eventDetails);\n        }\n        this._dragCallback(eventDetails);\n    }\n    _panCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const deltaPointsWorld = deltaPoints.world;\n        const camera = enabledElement.viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        enabledElement.viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        enabledElement.viewport.render();\n    }\n}\nZoomTool.toolName = 'Zoom';\nexport default ZoomTool;\n","import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawPath as drawPathSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nclass AngleTool extends AnnotationTool {\n    static { this.toolName = 'Angle'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            showAngleArc: false,\n            arcOffset: 5,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.angleStartedNotYetCompleted) {\n                return;\n            }\n            this.angleStartedNotYetCompleted = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2, point3] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line1 = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            if (!point3) {\n                return false;\n            }\n            const canvasPoint3 = viewport.worldToCanvas(point3);\n            const line2 = {\n                start: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n                end: {\n                    x: canvasPoint3[0],\n                    y: canvasPoint3[1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint2 <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {\n                this.editData.handleIndex = 2;\n                return;\n            }\n            this.angleStartedNotYetCompleted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                this.angleStartedNotYetCompleted = false;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, angleArcLineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].angle == null) {\n                    data.cachedStats[targetId] = {\n                        angle: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotation.annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                let lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                renderStatus = true;\n                if (canvasCoordinates.length !== 3) {\n                    return renderStatus;\n                }\n                lineUID = '2';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], canvasCoordinates[2], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                if (this.configuration.showAngleArc) {\n                    const center = canvasCoordinates[1];\n                    const offset = this.configuration.arcOffset;\n                    const radius = Math.min(lineSegment.distanceToPoint([center[0], center[1]], [canvasCoordinates[0][0], canvasCoordinates[0][1]], [canvasCoordinates[2][0], canvasCoordinates[2][1]]), lineSegment.distanceToPoint([center[0], center[1]], [canvasCoordinates[2][0], canvasCoordinates[2][1]], [canvasCoordinates[0][0], canvasCoordinates[0][1]])) / offset;\n                    const anglePoints = [];\n                    let startAngle = Math.atan2(canvasCoordinates[0][1] - center[1], canvasCoordinates[0][0] - center[0]);\n                    let endAngle = Math.atan2(canvasCoordinates[2][1] - center[1], canvasCoordinates[2][0] - center[0]);\n                    if (endAngle < startAngle) {\n                        endAngle += 2 * Math.PI;\n                    }\n                    const angleDifference = endAngle - startAngle;\n                    if (angleDifference > Math.PI) {\n                        const temp = startAngle;\n                        startAngle = endAngle;\n                        endAngle = temp + 2 * Math.PI;\n                    }\n                    const segments = 32;\n                    for (let i = 0; i <= segments; i++) {\n                        const angle = startAngle + (i / segments) * (endAngle - startAngle);\n                        anglePoints.push([\n                            center[0] + radius * Math.cos(angle),\n                            center[1] + radius * Math.sin(angle),\n                        ]);\n                    }\n                    drawPathSvg(svgDrawingHelper, annotationUID, '3', anglePoints, {\n                        color: color,\n                        width: lineWidth,\n                        lineDash: angleArcLineDash,\n                    });\n                }\n                if (!data.cachedStats[targetId]?.angle) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(AngleTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        if (data.handles.points.length !== 3) {\n            return;\n        }\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const worldPos3 = data.handles.points[2];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const angle = angleBetweenLines([worldPos1, worldPos2], [worldPos2, worldPos3]);\n            const { dimensions, imageData } = this.getTargetImageData(targetId);\n            this.isHandleOutsideImage = [worldPos1, worldPos2, worldPos3]\n                .map((worldPos) => csUtils.transformWorldToIndex(imageData, worldPos))\n                .some((index) => !csUtils.indexWithinDimensions(index, dimensions));\n            cachedStats[targetId] = {\n                angle: isNaN(angle) ? 'Incomplete Angle' : angle,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { angle } = cachedVolumeStats;\n    if (angle === undefined) {\n        return;\n    }\n    if (isNaN(angle)) {\n        return [`${angle}`];\n    }\n    const textLines = [\n        `${csUtils.roundNumber(angle)} ${String.fromCharCode(176)}`,\n    ];\n    return textLines;\n}\nexport default AngleTool;\n","import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawArrow as drawArrowSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { setAnnotationLabel } from '../../utilities';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nclass ArrowAnnotateTool extends AnnotationTool {\n    static { this.toolName = 'ArrowAnnotate'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            getTextCallback,\n            changeTextCallback,\n            preventHandleOutsideImage: false,\n            arrowFirst: true,\n            arrowHeadStyle: 'legacy',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            this.startGroupRecording();\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const { arrowFirst } = this.configuration;\n            const annotation = this.createAnnotation(evt, [[...worldPos], [...worldPos]], {\n                data: {\n                    handles: {\n                        arrowFirst,\n                    },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved, movingTextBox, } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            if (newAnnotation) {\n                this.configuration.getTextCallback((label) => {\n                    if (!label) {\n                        removeAnnotation(annotation.annotationUID);\n                        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                        this.editData = null;\n                        this.isDrawing = false;\n                        return;\n                    }\n                    annotation.data.label = label;\n                    triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n                    triggerAnnotationCompleted(annotation);\n                    this.createMemo(element, annotation, { newAnnotation: !!this.memo });\n                    setAnnotationLabel(annotation, element, label);\n                    this.endGroupRecording();\n                    this.doneEditMemo();\n                    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                });\n            }\n            else if (!movingTextBox) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n            this.doneEditMemo();\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.touchTapCallback = (evt) => {\n            if (evt.detail.taps == 2) {\n                this.doubleClickCallback(evt);\n            }\n        };\n        this.doubleClickCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            let annotations = getAnnotations(this.getToolName(), element);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return;\n            }\n            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));\n            if (!clickedAnnotation) {\n                return;\n            }\n            const annotation = clickedAnnotation;\n            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));\n            this.editData = null;\n            this.isDrawing = false;\n            evt.stopImmediatePropagation();\n            evt.preventDefault();\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles, label } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, markerSize } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineWidth,\n                    });\n                }\n                const arrowUID = '1';\n                if (this.configuration.arrowFirst) {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[1], canvasCoordinates[0], {\n                        color,\n                        width: lineWidth,\n                        lineDash: lineDash,\n                        viaMarker: this.configuration.arrowHeadStyle !== 'legacy',\n                        markerSize,\n                    });\n                }\n                else {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[0], canvasCoordinates[1], {\n                        color,\n                        width: lineWidth,\n                        lineDash: lineDash,\n                        viaMarker: this.configuration.arrowHeadStyle !== 'legacy',\n                        markerSize,\n                    });\n                }\n                renderStatus = true;\n                if (!label) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, [label], textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n    }\n    static { this.hydrate = (viewportId, points, label, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(ArrowAnnotateTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = this.createAnnotation({\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                label: label || '',\n                handles: {\n                    points,\n                },\n            },\n            autoGenerated: false,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        });\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _doneChangingTextCallback(element, annotation, updatedLabel) {\n        annotation.data.label = updatedLabel;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        triggerAnnotationModified(annotation, element);\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nexport default ArrowAnnotateTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, utilities, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawLine as drawLineSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass BidirectionalTool extends AnnotationTool {\n    static { this.toolName = 'Bidirectional'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            let canvasPoint1 = viewport.worldToCanvas(points[0]);\n            let canvasPoint2 = viewport.worldToCanvas(points[1]);\n            let line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            let distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            canvasPoint1 = viewport.worldToCanvas(points[2]);\n            canvasPoint2 = viewport.worldToCanvas(points[3]);\n            line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const data = annotation.data;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            hideElementCursor(element);\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            if (this.editData.handleIndex !== undefined) {\n                const { points } = data.handles;\n                const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n                const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n                if (secondLineSegmentLength > firstLineSegmentLength) {\n                    const longAxis = [[...points[2]], [...points[3]]];\n                    const shortAxisPoint0 = [...points[0]];\n                    const shortAxisPoint1 = [...points[1]];\n                    const longAxisVector = vec2.create();\n                    vec2.set(longAxisVector, longAxis[1][0] - longAxis[0][0], longAxis[1][1] - longAxis[1][0]);\n                    const counterClockWisePerpendicularToLongAxis = vec2.create();\n                    vec2.set(counterClockWisePerpendicularToLongAxis, -longAxisVector[1], longAxisVector[0]);\n                    const currentShortAxisVector = vec2.create();\n                    vec2.set(currentShortAxisVector, shortAxisPoint1[0] - shortAxisPoint0[0], shortAxisPoint1[1] - shortAxisPoint0[0]);\n                    let shortAxis;\n                    if (vec2.dot(currentShortAxisVector, counterClockWisePerpendicularToLongAxis) > 0) {\n                        shortAxis = [shortAxisPoint0, shortAxisPoint1];\n                    }\n                    else {\n                        shortAxis = [shortAxisPoint1, shortAxisPoint0];\n                    }\n                    data.handles.points = [\n                        longAxis[0],\n                        longAxis[1],\n                        shortAxis[0],\n                        shortAxis[1],\n                    ];\n                }\n            }\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { worldToCanvas } = viewport;\n            const { annotation, viewportIdsToRender, handleIndex, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            data.handles.points[handleIndex] = [...worldPos];\n            const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n            const canvasCoords = {\n                longLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[0][0],\n                        y: canvasCoordPoints[0][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[1][0],\n                        y: canvasCoordPoints[1][1],\n                    },\n                },\n                shortLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[2][0],\n                        y: canvasCoordPoints[2][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[3][0],\n                        y: canvasCoordPoints[3][1],\n                    },\n                },\n            };\n            const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n            const shortAxisDistFromCenter = dist / 3;\n            const dx = canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n            const dy = canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n            const length = Math.sqrt(dx * dx + dy * dy);\n            const vectorX = dx / length;\n            const vectorY = dy / length;\n            const xMid = (canvasCoords.longLineSegment.start.x +\n                canvasCoords.longLineSegment.end.x) /\n                2;\n            const yMid = (canvasCoords.longLineSegment.start.y +\n                canvasCoords.longLineSegment.end.y) /\n                2;\n            const startX = xMid + shortAxisDistFromCenter * vectorY;\n            const startY = yMid - shortAxisDistFromCenter * vectorX;\n            const endX = xMid - shortAxisDistFromCenter * vectorY;\n            const endY = yMid + shortAxisDistFromCenter * vectorX;\n            data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n            data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            this.editData.hasMoved = true;\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragModifyHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this._dragModifyHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { annotation, handleIndex: movingHandleIndex } = this.editData;\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            const canvasCoordHandlesCurrent = [\n                viewport.worldToCanvas(data.handles.points[0]),\n                viewport.worldToCanvas(data.handles.points[1]),\n                viewport.worldToCanvas(data.handles.points[2]),\n                viewport.worldToCanvas(data.handles.points[3]),\n            ];\n            const firstLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[0][0],\n                    y: canvasCoordHandlesCurrent[0][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[1][0],\n                    y: canvasCoordHandlesCurrent[1][1],\n                },\n            };\n            const secondLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[2][0],\n                    y: canvasCoordHandlesCurrent[2][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[3][0],\n                    y: canvasCoordHandlesCurrent[3][1],\n                },\n            };\n            const proposedPoint = [...worldPos];\n            const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n            if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n                const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n                const fixedHandleCanvasCoord = canvasCoordHandlesCurrent[fixedHandleIndex];\n                const fixedHandleToProposedCoordVec = vec2.set(vec2.create(), proposedCanvasCoord[0] - fixedHandleCanvasCoord[0], proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]);\n                const fixedHandleToOldCoordVec = vec2.set(vec2.create(), canvasCoordHandlesCurrent[movingHandleIndex][0] -\n                    fixedHandleCanvasCoord[0], canvasCoordHandlesCurrent[movingHandleIndex][1] -\n                    fixedHandleCanvasCoord[1]);\n                vec2.normalize(fixedHandleToProposedCoordVec, fixedHandleToProposedCoordVec);\n                vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n                const proposedFirstLineSegment = {\n                    start: {\n                        x: fixedHandleCanvasCoord[0],\n                        y: fixedHandleCanvasCoord[1],\n                    },\n                    end: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                };\n                if (this._movingLongAxisWouldPutItThroughShortAxis(proposedFirstLineSegment, secondLineSegment)) {\n                    return;\n                }\n                const centerOfRotation = fixedHandleCanvasCoord;\n                const angle = this._getSignedAngle(fixedHandleToOldCoordVec, fixedHandleToProposedCoordVec);\n                let firstPointX = canvasCoordHandlesCurrent[2][0];\n                let firstPointY = canvasCoordHandlesCurrent[2][1];\n                let secondPointX = canvasCoordHandlesCurrent[3][0];\n                let secondPointY = canvasCoordHandlesCurrent[3][1];\n                firstPointX -= centerOfRotation[0];\n                firstPointY -= centerOfRotation[1];\n                secondPointX -= centerOfRotation[0];\n                secondPointY -= centerOfRotation[1];\n                const rotatedFirstPoint = firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n                const rotatedFirstPointY = firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n                const rotatedSecondPoint = secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n                const rotatedSecondPointY = secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n                firstPointX = rotatedFirstPoint + centerOfRotation[0];\n                firstPointY = rotatedFirstPointY + centerOfRotation[1];\n                secondPointX = rotatedSecondPoint + centerOfRotation[0];\n                secondPointY = rotatedSecondPointY + centerOfRotation[1];\n                const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n                const newSecondPoint = viewport.canvasToWorld([\n                    secondPointX,\n                    secondPointY,\n                ]);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n                data.handles.points[2] = newFirstPoint;\n                data.handles.points[3] = newSecondPoint;\n            }\n            else {\n                const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n                const canvasCoordsCurrent = {\n                    longLineSegment: {\n                        start: firstLineSegment.start,\n                        end: firstLineSegment.end,\n                    },\n                    shortLineSegment: {\n                        start: secondLineSegment.start,\n                        end: secondLineSegment.end,\n                    },\n                };\n                const longLineSegmentVec = vec2.subtract(vec2.create(), [\n                    canvasCoordsCurrent.longLineSegment.end.x,\n                    canvasCoordsCurrent.longLineSegment.end.y,\n                ], [\n                    canvasCoordsCurrent.longLineSegment.start.x,\n                    canvasCoordsCurrent.longLineSegment.start.y,\n                ]);\n                const longLineSegmentVecNormalized = vec2.normalize(vec2.create(), longLineSegmentVec);\n                const proposedToCurrentVec = vec2.subtract(vec2.create(), [proposedCanvasCoord[0], proposedCanvasCoord[1]], [\n                    canvasCoordHandlesCurrent[movingHandleIndex][0],\n                    canvasCoordHandlesCurrent[movingHandleIndex][1],\n                ]);\n                const movementLength = vec2.length(proposedToCurrentVec);\n                const angle = this._getSignedAngle(longLineSegmentVecNormalized, proposedToCurrentVec);\n                const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n                const newTranslatedPoint = vec2.scaleAndAdd(vec2.create(), [\n                    canvasCoordHandlesCurrent[translateHandleIndex][0],\n                    canvasCoordHandlesCurrent[translateHandleIndex][1],\n                ], longLineSegmentVecNormalized, movementAlongLineSegmentLength);\n                if (this._movingLongAxisWouldPutItThroughShortAxis({\n                    start: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                    end: {\n                        x: newTranslatedPoint[0],\n                        y: newTranslatedPoint[1],\n                    },\n                }, {\n                    start: {\n                        x: canvasCoordsCurrent.longLineSegment.start.x,\n                        y: canvasCoordsCurrent.longLineSegment.start.y,\n                    },\n                    end: {\n                        x: canvasCoordsCurrent.longLineSegment.end.x,\n                        y: canvasCoordsCurrent.longLineSegment.end.y,\n                    },\n                })) {\n                    return;\n                }\n                const intersectionPoint = lineSegment.intersectLine([proposedCanvasCoord[0], proposedCanvasCoord[1]], [newTranslatedPoint[0], newTranslatedPoint[1]], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n                if (!intersectionPoint) {\n                    return;\n                }\n                data.handles.points[translateHandleIndex] = viewport.canvasToWorld(newTranslatedPoint);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = true;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        width: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, showHandlesAlways ? canvasCoordinates : activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId1 = `${annotationUID}-line-1`;\n                const dataId2 = `${annotationUID}-line-2`;\n                const lineUID = '0';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId1);\n                const secondLineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId2);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._movingLongAxisWouldPutItThroughShortAxis = (firstLineSegment, secondLineSegment) => {\n            const vectorInSecondLineDirection = vec2.create();\n            vec2.set(vectorInSecondLineDirection, secondLineSegment.end.x - secondLineSegment.start.x, secondLineSegment.end.y - secondLineSegment.start.y);\n            vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n            const extendedSecondLineSegment = {\n                start: {\n                    x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n                },\n                end: {\n                    x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n                },\n            };\n            const proposedIntersectionPoint = lineSegment.intersectLine([extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y], [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n            const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n            return wouldPutThroughShortAxis;\n        };\n        this._calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { element } = enabledElement.viewport;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[1];\n            const worldPos3 = data.handles.points[2];\n            const worldPos4 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, dimensions } = image;\n                const index1 = transformWorldToIndex(imageData, worldPos1);\n                const index2 = transformWorldToIndex(imageData, worldPos2);\n                const index3 = transformWorldToIndex(imageData, worldPos3);\n                const index4 = transformWorldToIndex(imageData, worldPos4);\n                const handles1 = [index1, index2];\n                const handles2 = [index3, index4];\n                const { scale: scale1, unit: units1 } = getCalibratedLengthUnitsAndScale(image, handles1);\n                const { scale: scale2, unit: units2 } = getCalibratedLengthUnitsAndScale(image, handles2);\n                const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;\n                const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;\n                const length = dist1 > dist2 ? dist1 : dist2;\n                const width = dist1 > dist2 ? dist2 : dist1;\n                const unit = dist1 > dist2 ? units1 : units2;\n                const widthUnit = dist1 > dist2 ? units2 : units1;\n                this._isInsideVolume(index1, index2, index3, index4, dimensions)\n                    ? (this.isHandleOutsideImage = false)\n                    : (this.isHandleOutsideImage = true);\n                cachedStats[targetId] = {\n                    length,\n                    width,\n                    unit,\n                    widthUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, index3, index4, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions) &&\n                csUtils.indexWithinDimensions(index3, dimensions) &&\n                csUtils.indexWithinDimensions(index4, dimensions));\n        };\n        this._getSignedAngle = (vector1, vector2) => {\n            return Math.atan2(vector1[0] * vector2[1] - vector1[1] * vector2[0], vector1[0] * vector2[0] + vector1[1] * vector2[1]);\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const worldPos = currentPoints.world;\n        this.isDrawing = true;\n        const annotation = this.createAnnotation(evt, [\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n        ]);\n        addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex: 1,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n        };\n        this._activateDraw(element);\n        hideElementCursor(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    static { this.hydrate = (viewportId, axis, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(BidirectionalTool, enabledElement, axis[0], options);\n        const [majorAxis, minorAxis] = axis;\n        const [major0, major1] = majorAxis;\n        const [minor0, minor1] = minorAxis;\n        const points = [major0, major1, minor0, minor1];\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                },\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n        return annotation;\n    }; }\n    _calculateLength(pos1, pos2) {\n        const dx = pos1[0] - pos2[0];\n        const dy = pos1[1] - pos2[1];\n        const dz = pos1[2] - pos2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const { cachedStats, label } = data;\n    const { length, width, unit } = cachedStats[targetId];\n    const textLines = [];\n    if (label) {\n        textLines.push(label);\n    }\n    if (length === undefined) {\n        return textLines;\n    }\n    textLines.push(`L: ${csUtils.roundNumber(length)} ${unit || unit}`, `W: ${csUtils.roundNumber(width)} ${unit}`);\n    return textLines;\n}\nexport default BidirectionalTool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, EPSILON, } from '@cornerstonejs/core';\nimport { getCalibratedAspect, getCalibratedLengthUnitsAndScale, } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { getCanvasCircleCorners, getCanvasCircleRadius, } from '../../utilities/math/circle';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass CircleROITool extends AnnotationTool {\n    static { this.toolName = 'CircleROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            storePointData: false,\n            centerPointRadius: 0,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n            simplified: true,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            this.isDrawing = true;\n            let points;\n            if (this.configuration.simplified) {\n                points = [[...worldPos], [...worldPos]];\n            }\n            else {\n                points = [\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                ];\n            }\n            const annotation = this.createAnnotation(evt, points);\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { points } = annotation.data.handles;\n            const canvasHandles = points.map((p) => viewport.worldToCanvas(p));\n            const canvasCenter = canvasHandles[0];\n            const radius = getCanvasCircleRadius([canvasCenter, canvasHandles[1]]);\n            const radiusPoint = getCanvasCircleRadius([canvasCenter, canvasCoords]);\n            return Math.abs(radiusPoint - radius) < proximity / 2;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const { world: worldPos, canvas: currentCanvasPoints } = currentPoints;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            const centerWorld = data.handles.points[0];\n            const centerCanvas = viewport.worldToCanvas(centerWorld);\n            if (this.configuration.simplified) {\n                data.handles.points[1] = worldPos;\n            }\n            else {\n                const radiusCanvas = vec2.distance(centerCanvas, currentCanvasPoints);\n                data.handles.points[0] = [...centerWorld];\n                data.handles.points[1] = canvasToWorld([\n                    centerCanvas[0],\n                    centerCanvas[1] - radiusCanvas,\n                ]);\n                data.handles.points[2] = canvasToWorld([\n                    centerCanvas[0],\n                    centerCanvas[1] + radiusCanvas,\n                ]);\n                data.handles.points[3] = canvasToWorld([\n                    centerCanvas[0] - radiusCanvas,\n                    centerCanvas[1],\n                ]);\n                data.handles.points[4] = canvasToWorld([\n                    centerCanvas[0] + radiusCanvas,\n                    centerCanvas[1],\n                ]);\n            }\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n            const { annotation, handleIndex } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const { currentPoints, deltaPoints } = eventDetail;\n            if (handleIndex === 0) {\n                const worldPosDelta = deltaPoints.world;\n                points.forEach((point) => {\n                    vec3.add(point, point, worldPosDelta);\n                });\n            }\n            else {\n                const centerWorld = points[0];\n                const centerCanvas = worldToCanvas(centerWorld);\n                const currentCanvasPoint = currentPoints.canvas;\n                const newRadiusCanvas = vec2.distance(centerCanvas, currentCanvasPoint);\n                points[1] = canvasToWorld([\n                    centerCanvas[0],\n                    centerCanvas[1] - newRadiusCanvas,\n                ]);\n                points[2] = canvasToWorld([\n                    centerCanvas[0],\n                    centerCanvas[1] + newRadiusCanvas,\n                ]);\n                points[3] = canvasToWorld([\n                    centerCanvas[0] - newRadiusCanvas,\n                    centerCanvas[1],\n                ]);\n                points[4] = canvasToWorld([\n                    centerCanvas[0] + newRadiusCanvas,\n                    centerCanvas[1],\n                ]);\n            }\n            annotation.invalidated = true;\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                annotation.highlighted = false;\n                annotation.data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                const radius = getCanvasCircleRadius([center, canvasCoordinates[1]]);\n                const canvasCorners = getCanvasCircleCorners([\n                    center,\n                    canvasCoordinates[1],\n                ]);\n                const { centerPointRadius } = this.configuration;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                        radius: null,\n                        radiusUnit: null,\n                        perimeter: null,\n                    };\n                    this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    if (this.configuration.simplified) {\n                        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                    }\n                    else {\n                        activeHandleCanvasCoords = canvasCoordinates;\n                    }\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, showHandlesAlways ? canvasCoordinates : activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-circle`;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                if (centerPointRadius > 0) {\n                    if (radius > 3 * centerPointRadius) {\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                if (this.configuration.calculateStats) {\n                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                    if (!options.visibility) {\n                        data.handles.textBox = {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        };\n                        continue;\n                    }\n                    const textLines = this.configuration.getTextLines(data, targetId);\n                    if (!textLines || textLines.length === 0) {\n                        continue;\n                    }\n                    let canvasTextBoxCoords;\n                    if (!data.handles.textBox.hasMoved) {\n                        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                        data.handles.textBox.worldPosition =\n                            viewport.canvasToWorld(canvasTextBoxCoords);\n                    }\n                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                    const textBoxUID = '1';\n                    const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, [center, canvasCoordinates[1]], {}, options);\n                    const { x: left, y: top, width, height } = boundingBox;\n                    data.handles.textBox.worldBoundingBox = {\n                        topLeft: viewport.canvasToWorld([left, top]),\n                        topRight: viewport.canvasToWorld([left + width, top]),\n                        bottomLeft: viewport.canvasToWorld([left, top + height]),\n                        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                    };\n                }\n            }\n            return renderStatus;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            const { element } = viewport;\n            const wasInvalidated = annotation.invalidated;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const canvasCenter = canvasCoordinates[0];\n            const canvasTop = canvasCoordinates[1];\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasCircleCorners([canvasCenter, canvasTop]));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const pos2Index = transformWorldToIndex(imageData, worldPos2);\n                pos2Index[0] = Math.floor(pos2Index[0]);\n                pos2Index[1] = Math.floor(pos2Index[1]);\n                pos2Index[2] = Math.floor(pos2Index[2]);\n                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n                    const iMin = Math.min(pos1Index[0], pos2Index[0]);\n                    const iMax = Math.max(pos1Index[0], pos2Index[0]);\n                    const jMin = Math.min(pos1Index[1], pos2Index[1]);\n                    const jMax = Math.max(pos1Index[1], pos2Index[1]);\n                    const kMin = Math.min(pos1Index[2], pos2Index[2]);\n                    const kMax = Math.max(pos1Index[2], pos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const center = points[0];\n                    const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;\n                    const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;\n                    const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;\n                    const ellipseObj = {\n                        center,\n                        xRadius: xRadius < EPSILON / 2 ? 0 : xRadius,\n                        yRadius: yRadius < EPSILON / 2 ? 0 : yRadius,\n                        zRadius: zRadius < EPSILON / 2 ? 0 : zRadius,\n                    };\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n                    const handles = [pos1Index, pos2Index];\n                    const { scale, unit, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                    const aspect = getCalibratedAspect(image);\n                    const area = Math.abs(Math.PI *\n                        (worldWidth / scale / 2) *\n                        (worldHeight / aspect / scale / 2));\n                    const pixelUnitsOptions = {\n                        isPreScaled: isViewportPreScaled(viewport, targetId),\n                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                    };\n                    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                    let pointsInShape;\n                    if (voxelManager) {\n                        pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                            isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\n                            boundsIJK,\n                            imageData,\n                            returnPoints: this.configuration.storePointData,\n                        });\n                    }\n                    const stats = this.configuration.statsCalculator.getStatistics();\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean: stats.mean?.value,\n                        max: stats.max?.value,\n                        min: stats.min?.value,\n                        pointsInShape,\n                        stdDev: stats.stdDev?.value,\n                        statsArray: stats.array,\n                        isEmptyArea,\n                        areaUnit,\n                        radius: worldWidth / 2 / scale,\n                        radiusUnit: unit,\n                        perimeter: (2 * Math.PI * (worldWidth / 2)) / scale,\n                        modalityUnit,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            annotation.invalidated = false;\n            if (wasInvalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(CircleROITool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { radius, radiusUnit, area, mean, stdDev, max, min, isEmptyArea, areaUnit, modalityUnit, } = cachedVolumeStats;\n    const textLines = [];\n    if (csUtils.isNumber(radius)) {\n        const radiusLine = isEmptyArea\n            ? `Radius: Oblique not supported`\n            : `Radius: ${csUtils.roundNumber(radius)} ${radiusUnit}`;\n        textLines.push(radiusLine);\n    }\n    if (csUtils.isNumber(area)) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (csUtils.isNumber(mean)) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(min)) {\n        textLines.push(`Min: ${csUtils.roundNumber(min)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(stdDev)) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default CircleROITool;\n","import { vec3 } from 'gl-matrix';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { midPoint2 } from '../../utilities/math/midPoint';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nclass CobbAngleTool extends AnnotationTool {\n    static { this.toolName = 'CobbAngle'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            showArcLines: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.angleStartedNotYetCompleted) {\n                return;\n            }\n            this.angleStartedNotYetCompleted = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { distanceToPoint, distanceToPoint2 } = this.distanceToLines({\n                viewport,\n                points: data.handles.points,\n                canvasCoords,\n                proximity,\n            });\n            if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType, canvasCoords, proximity = 6) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({\n                viewport,\n                points: annotation.data.handles.points,\n                canvasCoords,\n                proximity,\n            });\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n                isNearFirstLine,\n                isNearSecondLine,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {\n                resetElementCursor(element);\n                this.editData.handleIndex = data.handles.points.length;\n                return;\n            }\n            this.angleStartedNotYetCompleted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._mouseDownCallback = (evt) => {\n            const { annotation, handleIndex } = this.editData;\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { data } = annotation;\n            if (handleIndex === 1) {\n                data.handles.points[1] = worldPos;\n                this.editData.hasMoved =\n                    data.handles.points[1][0] !== data.handles.points[0][0] ||\n                        data.handles.points[1][1] !== data.handles.points[0][0];\n                return;\n            }\n            if (handleIndex === 3) {\n                data.handles.points[3] = worldPos;\n                this.editData.hasMoved =\n                    data.handles.points[3][0] !== data.handles.points[2][0] ||\n                        data.handles.points[3][1] !== data.handles.points[2][0];\n                this.angleStartedNotYetCompleted = false;\n                return;\n            }\n            this.editData.hasMoved = false;\n            hideElementCursor(element);\n            data.handles.points[2] = data.handles.points[3] = worldPos;\n            this.editData.handleIndex = data.handles.points.length - 1;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, isNearFirstLine, isNearSecondLine, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined &&\n                (isNearFirstLine || isNearSecondLine)) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                if (isNearFirstLine) {\n                    const firstLinePoints = [points[0], points[1]];\n                    firstLinePoints.forEach((point) => {\n                        point[0] += worldPosDelta[0];\n                        point[1] += worldPosDelta[1];\n                        point[2] += worldPosDelta[2];\n                    });\n                }\n                else if (isNearSecondLine) {\n                    const secondLinePoints = [points[2], points[3]];\n                    secondLinePoints.forEach((point) => {\n                        point[0] += worldPosDelta[0];\n                        point[1] += worldPosDelta[1];\n                        point[2] += worldPosDelta[2];\n                    });\n                }\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateDraw(element);\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            if (data.handles.points.length < 4) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.angleStartedNotYetCompleted = false;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].angle == null) {\n                    data.cachedStats[targetId] = {\n                        angle: null,\n                        arc1Angle: null,\n                        arc2Angle: null,\n                        points: {\n                            world: {\n                                arc1Start: null,\n                                arc1End: null,\n                                arc2Start: null,\n                                arc2End: null,\n                                arc1Angle: null,\n                                arc2Angle: null,\n                            },\n                            canvas: {\n                                arc1Start: null,\n                                arc1End: null,\n                                arc2Start: null,\n                                arc2End: null,\n                                arc1Angle: null,\n                                arc2Angle: null,\n                            },\n                        },\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const firstLine = [canvasCoordinates[0], canvasCoordinates[1]];\n                const secondLine = [canvasCoordinates[2], canvasCoordinates[3]];\n                let lineUID = 'line1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, firstLine[0], firstLine[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                renderStatus = true;\n                if (canvasCoordinates.length < 4) {\n                    return renderStatus;\n                }\n                lineUID = 'line2';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, secondLine[0], secondLine[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                lineUID = 'linkLine';\n                const mid1 = midPoint2(firstLine[0], firstLine[1]);\n                const mid2 = midPoint2(secondLine[0], secondLine[1]);\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {\n                    color,\n                    lineWidth: '1',\n                    lineDash: '1,4',\n                });\n                const { arc1Start, arc1End, arc2End, arc2Start } = data.cachedStats[targetId].points.canvas;\n                const { arc1Angle, arc2Angle } = data.cachedStats[targetId];\n                if (this.configuration.showArcLines) {\n                    lineUID = 'arc1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, arc1Start, arc1End, {\n                        color,\n                        lineWidth: '1',\n                    });\n                    lineUID = 'arc2';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, arc2Start, arc2End, {\n                        color,\n                        lineWidth: '1',\n                    });\n                }\n                if (!data.cachedStats[targetId]?.angle) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = 'cobbAngleText';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n                if (this.configuration.showArcLines) {\n                    const arc1TextBoxUID = 'arcAngle1';\n                    const arc1TextLine = [\n                        `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n                    ];\n                    const arch1TextPosCanvas = midPoint2(arc1Start, arc1End);\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, arc1TextBoxUID, arc1TextLine, arch1TextPosCanvas, {\n                        ...options,\n                        padding: 3,\n                    });\n                    const arc2TextBoxUID = 'arcAngle2';\n                    const arc2TextLine = [\n                        `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n                    ];\n                    const arch2TextPosCanvas = midPoint2(arc2Start, arc2End);\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, arc2TextBoxUID, arc2TextLine, arch2TextPosCanvas, {\n                        ...options,\n                        padding: 3,\n                    });\n                }\n            }\n            return renderStatus;\n        };\n        this.distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {\n            const [point1, point2, point3, point4] = points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const canvasPoint3 = viewport.worldToCanvas(point3);\n            const canvasPoint4 = viewport.worldToCanvas(point4);\n            const line1 = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const line2 = {\n                start: {\n                    x: canvasPoint3[0],\n                    y: canvasPoint3[1],\n                },\n                end: {\n                    x: canvasPoint4[0],\n                    y: canvasPoint4[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const distanceToPoint2 = lineSegment.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            let isNearFirstLine = false;\n            let isNearSecondLine = false;\n            if (distanceToPoint <= proximity) {\n                isNearFirstLine = true;\n            }\n            else if (distanceToPoint2 <= proximity) {\n                isNearSecondLine = true;\n            }\n            return {\n                distanceToPoint,\n                distanceToPoint2,\n                isNearFirstLine,\n                isNearSecondLine,\n            };\n        };\n        this.getArcsStartEndPoints = ({ firstLine, secondLine, mid1, mid2, }) => {\n            const linkLine = [mid1, mid2];\n            const arc1Angle = angleBetweenLines(firstLine, linkLine);\n            const arc2Angle = angleBetweenLines(secondLine, linkLine);\n            const arc1Side = arc1Angle > 90 ? 1 : 0;\n            const arc2Side = arc2Angle > 90 ? 0 : 1;\n            const midLinkLine = midPoint2(linkLine[0], linkLine[1]);\n            const linkLineLength = Math.sqrt((linkLine[1][0] - linkLine[0][0]) ** 2 +\n                (linkLine[1][1] - linkLine[0][1]) ** 2);\n            const ratio = 0.1;\n            const midFirstLine = midPoint2(firstLine[0], firstLine[1]);\n            const midSecondLine = midPoint2(secondLine[0], secondLine[1]);\n            const directionVectorStartArc1 = [\n                firstLine[arc1Side][0] - midFirstLine[0],\n                firstLine[arc1Side][1] - midFirstLine[1],\n            ];\n            const magnitudeStartArc1 = Math.sqrt(directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2);\n            const normalizedDirectionStartArc1 = [\n                directionVectorStartArc1[0] / magnitudeStartArc1,\n                directionVectorStartArc1[1] / magnitudeStartArc1,\n            ];\n            const arc1Start = [\n                midFirstLine[0] +\n                    normalizedDirectionStartArc1[0] * linkLineLength * ratio,\n                midFirstLine[1] +\n                    normalizedDirectionStartArc1[1] * linkLineLength * ratio,\n            ];\n            const directionVectorEndArc1 = [\n                midLinkLine[0] - mid1[0],\n                midLinkLine[1] - mid1[1],\n            ];\n            const magnitudeEndArc1 = Math.sqrt(directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2);\n            const normalizedDirectionEndArc1 = [\n                directionVectorEndArc1[0] / magnitudeEndArc1,\n                directionVectorEndArc1[1] / magnitudeEndArc1,\n            ];\n            const arc1End = [\n                mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,\n                mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio,\n            ];\n            const directionVectorStartArc2 = [\n                secondLine[arc2Side][0] - midSecondLine[0],\n                secondLine[arc2Side][1] - midSecondLine[1],\n            ];\n            const magnitudeStartArc2 = Math.sqrt(directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2);\n            const normalizedDirectionStartArc2 = [\n                directionVectorStartArc2[0] / magnitudeStartArc2,\n                directionVectorStartArc2[1] / magnitudeStartArc2,\n            ];\n            const arc2Start = [\n                midSecondLine[0] +\n                    normalizedDirectionStartArc2[0] * linkLineLength * ratio,\n                midSecondLine[1] +\n                    normalizedDirectionStartArc2[1] * linkLineLength * ratio,\n            ];\n            const directionVectorEndArc2 = [\n                midLinkLine[0] - mid2[0],\n                midLinkLine[1] - mid2[1],\n            ];\n            const magnitudeEndArc2 = Math.sqrt(directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2);\n            const normalizedDirectionEndArc2 = [\n                directionVectorEndArc2[0] / magnitudeEndArc2,\n                directionVectorEndArc2[1] / magnitudeEndArc2,\n            ];\n            const arc2End = [\n                mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,\n                mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio,\n            ];\n            return {\n                arc1Start,\n                arc1End,\n                arc2Start,\n                arc2End,\n                arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,\n                arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle,\n            };\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 25, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle, interactionType = 'mouse') {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        if (data.handles.points.length !== 4) {\n            return;\n        }\n        const seg1 = [null, null];\n        const seg2 = [null, null];\n        let minDist = Number.MAX_VALUE;\n        for (let i = 0; i < 2; i += 1) {\n            for (let j = 2; j < 4; j += 1) {\n                const dist = vec3.distance(data.handles.points[i], data.handles.points[j]);\n                if (dist < minDist) {\n                    minDist = dist;\n                    seg1[1] = data.handles.points[i];\n                    seg1[0] = data.handles.points[(i + 1) % 2];\n                    seg2[0] = data.handles.points[j];\n                    seg2[1] = data.handles.points[2 + ((j - 1) % 2)];\n                }\n            }\n        }\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const canvasPoints = data.handles.points.map((p) => viewport.worldToCanvas(p));\n        const firstLine = [canvasPoints[0], canvasPoints[1]];\n        const secondLine = [canvasPoints[2], canvasPoints[3]];\n        const mid1 = midPoint2(firstLine[0], firstLine[1]);\n        const mid2 = midPoint2(secondLine[0], secondLine[1]);\n        const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } = this.getArcsStartEndPoints({\n            firstLine,\n            secondLine,\n            mid1,\n            mid2,\n        });\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            cachedStats[targetId] = {\n                angle: angleBetweenLines(seg1, seg2),\n                arc1Angle,\n                arc2Angle,\n                points: {\n                    canvas: {\n                        arc1Start,\n                        arc1End,\n                        arc2End,\n                        arc2Start,\n                    },\n                    world: {\n                        arc1Start: viewport.canvasToWorld(arc1Start),\n                        arc1End: viewport.canvasToWorld(arc1End),\n                        arc2End: viewport.canvasToWorld(arc2End),\n                        arc2Start: viewport.canvasToWorld(arc2Start),\n                    },\n                },\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { angle } = cachedVolumeStats;\n    if (angle === undefined) {\n        return;\n    }\n    const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n    return textLines;\n}\nexport default CobbAngleTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { drawHandles as drawHandlesSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport ProbeTool from './ProbeTool';\nclass DragProbeTool extends ProbeTool {\n    static { this.toolName = 'DragProbe'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.postMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                isVisible: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: { points: [[...worldPos]] },\n                    cachedStats: {},\n                },\n            };\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.postTouchStartCallback = (evt) => {\n            return this.postMouseDownCallback(evt);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const annotations = this.filterInteractableAnnotationsForElement(viewport.element, [this.editData.annotation]);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const annotation = this.editData.annotation;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const point = data.handles.points[0];\n            const canvasCoordinates = viewport.worldToCanvas(point);\n            styleSpecifier.annotationUID = annotationUID;\n            const { color } = this.getAnnotationStyle({\n                annotation,\n                styleSpecifier,\n            });\n            if (!data.cachedStats[targetId] ||\n                data.cachedStats[targetId].value === null) {\n                data.cachedStats[targetId] = {\n                    Modality: null,\n                    index: null,\n                    value: null,\n                };\n                this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n            }\n            else if (annotation.invalidated) {\n                this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n            }\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color });\n            renderStatus = true;\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (textLines) {\n                const textCanvasCoordinates = [\n                    canvasCoordinates[0] + 6,\n                    canvasCoordinates[1] - 6,\n                ];\n                const textUID = '0';\n                drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n            }\n            return renderStatus;\n        };\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { index, value, modalityUnit } = cachedVolumeStats;\n    if (value === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n    textLines.push(`${value.toFixed(2)} ${modalityUnit}`);\n    return textLines;\n}\nexport default DragProbeTool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawLine } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getCanvasCircleRadius } from '../../utilities/math/circle';\nimport { vec3 } from 'gl-matrix';\nconst CROSSHAIR_SIZE = 5;\nclass ETDRSGridTool extends AnnotationTool {\n    static { this.toolName = 'ETDRSGrid'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            degrees: [45, 135, 225, 315],\n            diameters: [10, 30, 60],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        points: [[...worldPos]],\n                    },\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const center = viewport.worldToCanvas(points[0]);\n            const radius = getCanvasCircleRadius([center, canvasCoords]);\n            if (Math.abs(radius) < proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            data.handles.points = [\n                canvasToWorld(currentCanvasPoints),\n                canvasToWorld(currentCanvasPoints),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            const { deltaPoints } = eventDetail;\n            const worldPosDelta = deltaPoints.world;\n            const points = data.handles.points;\n            points.forEach((point) => {\n                point[0] += worldPosDelta[0];\n                point[1] += worldPosDelta[1];\n                point[2] += worldPosDelta[2];\n            });\n            annotation.invalidated = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => worldToCanvas(p));\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n            const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n            const canvasCenter = currentCanvasPoints;\n            const canvasEnd = [\n                canvasCoordinates[1][0] + dXCanvas,\n                canvasCoordinates[1][1] + dYCanvas,\n            ];\n            points[0] = canvasToWorld(canvasCenter);\n            points[1] = canvasToWorld(canvasEnd);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const { renderingEngine } = getEnabledElement(element);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                let lineUID = `${annotationUID}-crosshair-vertical`;\n                let start = [center[0], center[1] + CROSSHAIR_SIZE];\n                let end = [center[0], center[1] - CROSSHAIR_SIZE];\n                drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                });\n                lineUID = `${annotationUID}-crosshair-horizontal`;\n                start = [center[0] + CROSSHAIR_SIZE, center[1]];\n                end = [center[0] - CROSSHAIR_SIZE, center[1]];\n                drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                });\n                const diametersCanvas = this.configuration.diameters.map((diameter) => this.worldMeasureToCanvas(diameter, viewport));\n                for (let i = 0; i < diametersCanvas.length; i++) {\n                    const dataId = `${annotationUID}-circle-${i}`;\n                    const circleUID = `${annotationUID}-circle-${i}`;\n                    drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, diametersCanvas[i] / 2, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    }, dataId);\n                }\n                const degreesRad = (x) => (x * Math.PI) / 180;\n                const angleRadians = this.configuration.degrees.map((degree) => degreesRad(degree));\n                for (let i = 0; i < angleRadians.length; i++) {\n                    const lineUID = `${annotationUID}-line-${i}`;\n                    const start = [\n                        (Math.cos(angleRadians[i]) * diametersCanvas[0]) / 2 + center[0],\n                        (Math.sin(angleRadians[i]) * diametersCanvas[0]) / 2 + center[1],\n                    ];\n                    const end = [\n                        (Math.cos(angleRadians[i]) * diametersCanvas[2]) / 2 + center[0],\n                        (Math.sin(angleRadians[i]) * diametersCanvas[2]) / 2 + center[1],\n                    ];\n                    drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n    }\n    worldMeasureToCanvas(measurement, viewport) {\n        const p1 = viewport.canvasToWorld([\n            viewport.canvas.width / 2,\n            viewport.canvas.height / 2,\n        ]);\n        const { viewUp } = viewport.getCamera();\n        const p2 = vec3.scaleAndAdd(vec3.create(), p1, viewUp, measurement);\n        const p1Canvas = viewport.worldToCanvas(p1);\n        const p2Canvas = viewport.worldToCanvas(p2);\n        const distance = Math.sqrt(Math.pow(p2Canvas[0] - p1Canvas[0], 2) +\n            Math.pow(p2Canvas[1] - p1Canvas[1], 2));\n        return distance;\n    }\n}\nexport default ETDRSGridTool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, EPSILON, } from '@cornerstonejs/core';\nimport { getCalibratedAspect, getCalibratedLengthUnitsAndScale, } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawEllipseByCoordinates as drawEllipseSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { pointInEllipse, getCanvasEllipseCorners, } from '../../utilities/math/ellipse';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { vec2 } from 'gl-matrix';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass EllipticalROITool extends AnnotationTool {\n    static { this.toolName = 'EllipticalROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            storePointData: false,\n            centerPointRadius: 0,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                centerWorld: worldPos,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const [bottom, top, left, right] = canvasCoordinates;\n            const w = Math.hypot(left[0] - right[0], left[1] - right[1]);\n            const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);\n            const angle = Math.atan2(left[1] - right[1], left[0] - right[0]);\n            const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];\n            const minorEllipse = {\n                center,\n                xRadius: (w - proximity) / 2,\n                yRadius: (h - proximity) / 2,\n                angle,\n            };\n            const majorEllipse = {\n                center,\n                xRadius: (w + proximity) / 2,\n                yRadius: (h + proximity) / 2,\n                angle,\n            };\n            const pointInMinorEllipse = this._pointInEllipseCanvas(minorEllipse, canvasCoords);\n            const pointInMajorEllipse = this._pointInEllipseCanvas(majorEllipse, canvasCoords);\n            if (pointInMajorEllipse && !pointInMinorEllipse) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            let centerCanvas;\n            let centerWorld;\n            let canvasWidth;\n            let canvasHeight;\n            let originalHandleCanvas;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                const { viewport } = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = viewport;\n                handleIndex = points.findIndex((p) => p === handle);\n                const pointsCanvas = points.map(worldToCanvas);\n                originalHandleCanvas = pointsCanvas[handleIndex];\n                canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);\n                canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);\n                centerCanvas = [\n                    (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,\n                    (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,\n                ];\n                centerWorld = canvasToWorld(centerCanvas);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                canvasWidth,\n                canvasHeight,\n                centerWorld,\n                originalHandleCanvas,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerWorld, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const centerCanvas = viewport.worldToCanvas(centerWorld);\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const bottomCanvas = [centerCanvas[0], centerCanvas[1] - dY];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] + dY];\n            const leftCanvas = [centerCanvas[0] - dX, centerCanvas[1]];\n            const rightCanvas = [centerCanvas[0] + dX, centerCanvas[1]];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { viewport } = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = viewport;\n            const { annotation, canvasWidth, canvasHeight, handleIndex, centerWorld, originalHandleCanvas, } = this.editData;\n            const centerCanvas = viewport.worldToCanvas(centerWorld);\n            const { data } = annotation;\n            const { points } = data.handles;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            if (handleIndex === 0 || handleIndex === 1) {\n                const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n                const canvasBottom = [\n                    centerCanvas[0],\n                    centerCanvas[1] - dYCanvas,\n                ];\n                const canvasTop = [\n                    centerCanvas[0],\n                    centerCanvas[1] + dYCanvas,\n                ];\n                points[0] = canvasToWorld(canvasBottom);\n                points[1] = canvasToWorld(canvasTop);\n                const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];\n                const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;\n                const canvasLeft = [\n                    centerCanvas[0] - newHalfCanvasWidth,\n                    centerCanvas[1],\n                ];\n                const canvasRight = [\n                    centerCanvas[0] + newHalfCanvasWidth,\n                    centerCanvas[1],\n                ];\n                points[2] = canvasToWorld(canvasLeft);\n                points[3] = canvasToWorld(canvasRight);\n            }\n            else {\n                const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n                const canvasLeft = [\n                    centerCanvas[0] - dXCanvas,\n                    centerCanvas[1],\n                ];\n                const canvasRight = [\n                    centerCanvas[0] + dXCanvas,\n                    centerCanvas[1],\n                ];\n                points[2] = canvasToWorld(canvasLeft);\n                points[3] = canvasToWorld(canvasRight);\n                const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];\n                const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;\n                const canvasBottom = [\n                    centerCanvas[0],\n                    centerCanvas[1] - newHalfCanvasHeight,\n                ];\n                const canvasTop = [\n                    centerCanvas[0],\n                    centerCanvas[1] + newHalfCanvasHeight,\n                ];\n                points[0] = canvasToWorld(canvasBottom);\n                points[1] = canvasToWorld(canvasTop);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasCorners = (getCanvasEllipseCorners(canvasCoordinates));\n                const { centerPointRadius } = this.configuration;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                    };\n                    this._calculateCachedStats(annotation, viewport, renderingEngine);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, showHandlesAlways ? canvasCoordinates : activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-ellipse`;\n                const ellipseUID = '0';\n                drawEllipseSvg(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                if (centerPointRadius > 0) {\n                    const minRadius = Math.min(Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2);\n                    if (minRadius > 3 * centerPointRadius) {\n                        const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${ellipseUID}-center`, centerPoint, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            const { element } = viewport;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasEllipseCorners(canvasCoordinates));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const pos2Index = transformWorldToIndex(imageData, worldPos2);\n                pos2Index[0] = Math.floor(pos2Index[0]);\n                pos2Index[1] = Math.floor(pos2Index[1]);\n                pos2Index[2] = Math.floor(pos2Index[2]);\n                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n                    const iMin = Math.min(pos1Index[0], pos2Index[0]);\n                    const iMax = Math.max(pos1Index[0], pos2Index[0]);\n                    const jMin = Math.min(pos1Index[1], pos2Index[1]);\n                    const jMax = Math.max(pos1Index[1], pos2Index[1]);\n                    const kMin = Math.min(pos1Index[2], pos2Index[2]);\n                    const kMax = Math.max(pos1Index[2], pos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const center = [\n                        (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n                        (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n                        (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n                    ];\n                    const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;\n                    const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;\n                    const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;\n                    const ellipseObj = {\n                        center,\n                        xRadius: xRadius < EPSILON / 2 ? 0 : xRadius,\n                        yRadius: yRadius < EPSILON / 2 ? 0 : yRadius,\n                        zRadius: zRadius < EPSILON / 2 ? 0 : zRadius,\n                    };\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n                    const handles = [pos1Index, pos2Index];\n                    const { scale, unit, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                    const aspect = getCalibratedAspect(image);\n                    const area = Math.abs(Math.PI *\n                        (worldWidth / scale / 2) *\n                        (worldHeight / aspect / scale / 2));\n                    const pixelUnitsOptions = {\n                        isPreScaled: isViewportPreScaled(viewport, targetId),\n                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                    };\n                    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                    let pointsInShape;\n                    if (voxelManager) {\n                        pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                            isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\n                            boundsIJK,\n                            imageData,\n                            returnPoints: this.configuration.storePointData,\n                        });\n                    }\n                    const stats = this.configuration.statsCalculator.getStatistics();\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean: stats.mean?.value,\n                        max: stats.max?.value,\n                        min: stats.min?.value,\n                        stdDev: stats.stdDev?.value,\n                        statsArray: stats.array,\n                        pointsInShape,\n                        isEmptyArea,\n                        areaUnit,\n                        modalityUnit,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(EllipticalROITool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    _pointInEllipseCanvas(ellipse, location) {\n        const { xRadius, yRadius, center, angle } = ellipse;\n        const rotLocation = vec2.rotate(vec2.create(), location, center, -angle);\n        if (xRadius <= 0.0 || yRadius <= 0.0) {\n            return false;\n        }\n        const normalized = [rotLocation[0] - center[0], rotLocation[1] - center[1]];\n        const inEllipse = (normalized[0] * normalized[0]) / (xRadius * xRadius) +\n            (normalized[1] * normalized[1]) / (yRadius * yRadius) <=\n            1.0;\n        return inEllipse;\n    }\n    _getCanvasEllipseCenter(ellipseCanvasPoints) {\n        const [bottom, top, left, right] = ellipseCanvasPoints;\n        const topLeft = [left[0], top[1]];\n        const bottomRight = [right[0], bottom[1]];\n        return [\n            (topLeft[0] + bottomRight[0]) / 2,\n            (topLeft[1] + bottomRight[1]) / 2,\n        ];\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit, min } = cachedVolumeStats;\n    const textLines = [];\n    if (csUtils.isNumber(area)) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (csUtils.isNumber(mean)) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(min)) {\n        textLines.push(`Min: ${csUtils.roundNumber(min)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(stdDev)) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default EllipticalROITool;\n","import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawHeight as drawHeightSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass HeightTool extends AnnotationTool {\n    static { this.toolName = 'Height'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                let activeHandleCanvasCoords;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const heightUID = '0';\n                drawHeightSvg(svgDrawingHelper, annotationUID, heightUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash: lineDash,\n                });\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateHeight(pos1, pos2) {\n        const dx = pos2[0] - pos1[0];\n        const dy = pos2[1] - pos1[1];\n        const dz = pos2[2] - pos1[2];\n        if (dx == 0) {\n            if (dy != 0) {\n                return Math.abs(dz);\n            }\n            else {\n                return 0;\n            }\n        }\n        else if (dy == 0) {\n            return Math.abs(dz);\n        }\n        else if (dz == 0) {\n            return Math.abs(dy);\n        }\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData, dimensions } = image;\n            const index1 = transformWorldToIndex(imageData, worldPos1);\n            const index2 = transformWorldToIndex(imageData, worldPos2);\n            const handles = [index1, index2];\n            const { scale, unit } = getCalibratedLengthUnitsAndScale(image, handles);\n            const height = this._calculateHeight(worldPos1, worldPos2) / scale;\n            const outside = this._isInsideVolume(index1, index2, dimensions);\n            this.isHandleOutsideImage = outside;\n            cachedStats[targetId] = {\n                height,\n                unit,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { height, unit } = cachedVolumeStats;\n    if (height === undefined || height === null || isNaN(height)) {\n        return;\n    }\n    const textLines = [`${csUtils.roundNumber(height)} ${unit}`];\n    return textLines;\n}\nexport default HeightTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawArrow as drawArrowSvg, drawHandles as drawHandlesSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nclass KeyImageTool extends AnnotationTool {\n    static { this.toolName = 'KeyImage'; }\n    static { this.dataSeries = {\n        data: {\n            seriesLevel: true,\n        },\n    }; }\n    static { this.dataPoint = {\n        data: {\n            isPoint: true,\n        },\n    }; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            getTextCallback,\n            changeTextCallback,\n            canvasPosition: [10, 10],\n            canvasSize: 10,\n            handleRadius: '6',\n            seriesLevel: false,\n            isPoint: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const worldPos = currentPoints.world;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: { points: [[...worldPos]] },\n                    seriesLevel: this.configuration.seriesLevel,\n                    isPoint: this.configuration.isPoint,\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.configuration.getTextCallback((label) => {\n                if (!label) {\n                    removeAnnotation(annotation.annotationUID);\n                    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                    this.isDrawing = false;\n                    return;\n                }\n                annotation.data.label = label;\n                triggerAnnotationCompleted(annotation);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            });\n            this.createMemo(element, annotation, { newAnnotation: true });\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            if (!data?.isPoint) {\n                return false;\n            }\n            const { canvasPosition, canvasSize } = this.configuration;\n            if (!canvasPosition?.length) {\n                return false;\n            }\n            if (Math.abs(canvasCoords[0] - canvasPosition[0] + canvasSize / 2) <=\n                canvasSize / 2 &&\n                Math.abs(canvasCoords[1] - canvasPosition[1] + canvasSize / 2) <=\n                    canvasSize / 2) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            annotation.highlighted = true;\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { viewportId, renderingEngine } = getEnabledElement(element);\n            this.eventDispatchDetail = {\n                viewportId,\n                renderingEngineId: renderingEngine.id,\n            };\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            if (newAnnotation) {\n                this.createMemo(element, annotation, { newAnnotation });\n            }\n            this.editData = null;\n            this.isDrawing = false;\n            this.doneEditMemo();\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this.doubleClickCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            let annotations = getAnnotations(this.getToolName(), element);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return;\n            }\n            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));\n            if (!clickedAnnotation) {\n                return;\n            }\n            const annotation = clickedAnnotation;\n            this.createMemo(element, annotation);\n            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));\n            this.isDrawing = false;\n            this.doneEditMemo();\n            evt.stopImmediatePropagation();\n            evt.preventDefault();\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            data.handles.points[0] = [...worldPos];\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const { canvasPosition, canvasSize } = this.configuration;\n                const arrowUID = '1';\n                if (data?.isPoint) {\n                    const point = data.handles.points[0];\n                    const canvasCoordinates = viewport.worldToCanvas(point);\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, arrowUID, [canvasCoordinates], {\n                        color,\n                        lineWidth,\n                        handleRadius: this.configuration.handleRadius,\n                    });\n                }\n                else if (canvasPosition?.length) {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasPosition.map((it) => it + canvasSize), canvasPosition, {\n                        color,\n                        width: 1,\n                    });\n                }\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n            }\n            return renderStatus;\n        };\n    }\n    handleSelectedCallback(evt, annotation) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    static setPoint(annotation, isPoint = !annotation.data.isPoint, element) {\n        annotation.data.isPoint = isPoint;\n        triggerAnnotationModified(annotation, element);\n    }\n    _doneChangingTextCallback(element, annotation, updatedText) {\n        annotation.data.label = updatedText;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        triggerAnnotationModified(annotation, element);\n    }\n    cancel(element) {\n        if (this.isDrawing) {\n            this.isDrawing = false;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            return annotation.annotationUID;\n        }\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nexport default KeyImageTool;\n","import { vec2 } from 'gl-matrix';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { drawTextBox as drawTextBoxSvg } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nclass LabelTool extends AnnotationTool {\n    static { this.toolName = 'Label'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            getTextCallback,\n            changeTextCallback,\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { annotationUID } = annotation;\n            const point = annotation.data.handles.points[0];\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            const dist = vec2.distance(canvasCoords, annotationCanvasCoordinate);\n            if (dist < proximity) {\n                return true;\n            }\n            const svgLayer = element.querySelector('svg');\n            if (!svgLayer) {\n                return false;\n            }\n            const textGroup = svgLayer.querySelector(`g[data-annotation-uid=\"${annotationUID}\"]`);\n            if (!textGroup) {\n                return false;\n            }\n            const textGroupElement = textGroup;\n            const bbox = textGroupElement.getBBox();\n            const transform = textGroupElement.getAttribute('transform');\n            let translateX = 0;\n            let translateY = 0;\n            if (transform) {\n                const matches = transform.match(/translate\\(([-\\d.]+)\\s+([-\\d.]+)\\)/);\n                if (matches) {\n                    translateX = parseFloat(matches[1]);\n                    translateY = parseFloat(matches[2]);\n                }\n            }\n            const x = bbox.x + translateX;\n            const y = bbox.y + translateY;\n            const isNear = canvasCoords[0] >= x &&\n                canvasCoords[0] <= x + bbox.width &&\n                canvasCoords[1] >= y &&\n                canvasCoords[1] <= y + bbox.height;\n            return isNear;\n        };\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n                offset: [0, 0, 0],\n            };\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.configuration.getTextCallback((label) => {\n                if (!label) {\n                    removeAnnotation(annotation.annotationUID);\n                    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                    this.isDrawing = false;\n                    return;\n                }\n                resetElementCursor(element);\n                annotation.data.label = label;\n                triggerAnnotationCompleted(annotation);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            });\n            this.createMemo(element, annotation, { newAnnotation: true });\n            return annotation;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            let offset = [0, 0, 0];\n            if (currentPoints && currentPoints.world) {\n                const initialWorldPos = currentPoints.world;\n                const anchorWorldPos = annotation.data.handles.points[0];\n                offset = [\n                    anchorWorldPos[0] - initialWorldPos[0],\n                    anchorWorldPos[1] - initialWorldPos[1],\n                    anchorWorldPos[2] - initialWorldPos[2],\n                ];\n            }\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                offset,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            this._deactivateDraw(element);\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            if (newAnnotation) {\n                this.createMemo(element, annotation, { newAnnotation });\n            }\n            this.editData = null;\n            this.isDrawing = false;\n            this.doneEditMemo();\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { annotation, viewportIdsToRender, offset } = this.editData;\n            if (offset) {\n                annotation.data.handles.points[0] = [\n                    worldPos[0] + offset[0],\n                    worldPos[1] + offset[1],\n                    worldPos[2] + offset[2],\n                ];\n            }\n            else {\n                annotation.data.handles.points[0] = [...worldPos];\n            }\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.LabelChange);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const point = data.handles.points[0];\n                styleSpecifier.annotationUID = annotationUID;\n                const canvasCoordinates = viewport.worldToCanvas(point);\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!data.label) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                const textBoxUID = '1';\n                drawTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, [data.label], canvasCoordinates, {\n                    ...options,\n                    padding: 0,\n                });\n            }\n            return renderStatus;\n        };\n    }\n    static { this.hydrate = (viewportId, position, label, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        const instance = new this();\n        const referencedImageId = instance.getReferencedImageId(viewport, position, viewPlaneNormal, viewUp);\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                label,\n                handles: {\n                    points: [position],\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(_evt, _annotation, _handle, _interactionType) { }\n    _doneChangingTextCallback(element, annotation, updatedLabel) {\n        annotation.data.label = updatedLabel;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        triggerAnnotationModified(annotation, element);\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nLabelTool.toolName = 'Label';\nexport default LabelTool;\n","import { Events, ChangeTypes } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, utilities, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass LengthTool extends AnnotationTool {\n    static { this.toolName = 'Length'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            actions: {\n                undo: {\n                    method: 'undo',\n                    bindings: [{ key: 'z' }],\n                },\n                redo: {\n                    method: 'redo',\n                    bindings: [{ key: 'y' }],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const dataId = `${annotationUID}-line`;\n                const lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(LengthTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateLength(pos1, pos2) {\n        const dx = pos1[0] - pos2[0];\n        const dy = pos1[1] - pos2[1];\n        const dz = pos1[2] - pos2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData, dimensions } = image;\n            const index1 = transformWorldToIndex(imageData, worldPos1);\n            const index2 = transformWorldToIndex(imageData, worldPos2);\n            const handles = [index1, index2];\n            const { scale, unit } = getCalibratedLengthUnitsAndScale(image, handles);\n            const length = this._calculateLength(worldPos1, worldPos2) / scale;\n            if (this._isInsideVolume(index1, index2, dimensions)) {\n                this.isHandleOutsideImage = false;\n            }\n            else {\n                this.isHandleOutsideImage = true;\n            }\n            cachedStats[targetId] = {\n                length,\n                unit,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { length, unit } = cachedVolumeStats;\n    if (length === undefined || length === null || isNaN(length)) {\n        return;\n    }\n    const textLines = [`${csUtils.roundNumber(length)} ${unit}`];\n    return textLines;\n}\nexport default LengthTool;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport LivewireContourTool from './LivewireContourTool';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { ChangeTypes } from '../../enums';\nimport { drawPolyline as drawPolylineSvg } from '../../drawingSvg';\nimport AnnotationToPointData from '../../utilities/contours/AnnotationToPointData';\nclass LivewireContourSegmentationTool extends LivewireContourTool {\n    static { this.toolName = 'LivewireContourSegmentationTool'; }\n    updateInterpolatedAnnotation(annotation, enabledElement) {\n        if (this.editData ||\n            !annotation.invalidated ||\n            !annotation.data.handles.interpolationSources) {\n            return;\n        }\n        annotation.data.contour.originalPolyline = annotation.data.contour.polyline;\n        queueMicrotask(() => {\n            if (!annotation.data.handles.interpolationSources) {\n                return;\n            }\n            const { points } = annotation.data.handles;\n            const { element } = enabledElement.viewport;\n            this.setupBaseEditData(points[0], element, annotation);\n            const { length: count } = points;\n            const { scissors } = this;\n            const { nearestEdge, repeatInterpolation } = this.configuration.interpolation;\n            annotation.data.handles.originalPoints = points;\n            const { worldToSlice, sliceToWorld } = this.editData;\n            const handleSmoothing = [];\n            if (nearestEdge) {\n                let lastPoint = worldToSlice(points[points.length - 1]);\n                points.forEach((point, hIndex) => {\n                    const testPoint = worldToSlice(point);\n                    lastPoint = testPoint;\n                    handleSmoothing.push(testPoint);\n                    scissors.startSearch(lastPoint);\n                    scissors.findPathToPoint(testPoint);\n                    scissors.findPathToPoint(worldToSlice(points[(hIndex + 3) % points.length]));\n                    const minPoint = scissors.findMinNearby(testPoint, nearestEdge);\n                    if (!csUtils.isEqual(testPoint, minPoint)) {\n                        handleSmoothing[hIndex] = minPoint;\n                        lastPoint = minPoint;\n                        points[hIndex] = sliceToWorld(minPoint);\n                    }\n                });\n            }\n            const acceptedPath = new LivewirePath();\n            for (let i = 0; i < count; i++) {\n                scissors.startSearch(worldToSlice(points[i]));\n                const path = scissors.findPathToPoint(worldToSlice(points[(i + 1) % count]));\n                acceptedPath.addPoints(path);\n            }\n            this.updateAnnotation(acceptedPath);\n            this.scissors = null;\n            this.scissorsNext = null;\n            this.editData = null;\n            annotation.data.handles.interpolationSources = null;\n            if (repeatInterpolation) {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, ChangeTypes.InterpolationUpdated);\n            }\n        });\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        const { annotationUID } = annotation;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { showInterpolationPolyline } = this.configuration.interpolation || {};\n        this.updateInterpolatedAnnotation?.(annotation, enabledElement);\n        const { originalPolyline } = annotation.data.contour;\n        const rendered = super.renderAnnotationInstance(renderContext);\n        if (showInterpolationPolyline &&\n            originalPolyline &&\n            annotation.autoGenerated) {\n            const polylineCanvasPoints = originalPolyline.map(worldToCanvas);\n            polylineCanvasPoints.push(polylineCanvasPoints[0]);\n            drawPolylineSvg(svgDrawingHelper, annotationUID, 'interpolationContour-0', polylineCanvasPoints, {\n                color: '#70ffff',\n                lineWidth: 1,\n                fillOpacity: 0,\n            });\n        }\n        return rendered;\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    static {\n        AnnotationToPointData.register(this);\n    }\n}\nexport default LivewireContourSegmentationTool;\n","import { vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, VolumeViewport, utilities, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { removeAnnotation } from '../../stateManagement/annotation/annotationState';\nimport { drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events, KeyboardBindings, ChangeTypes } from '../../enums';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport * as math from '../../utilities/math';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport findHandlePolylineIndex from '../../utilities/contours/findHandlePolylineIndex';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport { triggerAnnotationModified, triggerContourAnnotationCompleted, } from '../../stateManagement/annotation/helpers/state';\nimport { LivewireScissors } from '../../utilities/livewire/LivewireScissors';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getCalibratedLengthUnitsAndScale, throttle } from '../../utilities';\nconst CLICK_CLOSE_CURVE_SQR_DIST = 10 ** 2;\nclass LivewireContourTool extends ContourSegmentationBaseTool {\n    static { this.toolName = 'LivewireContour'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            getTextLines: defaultGetTextLines,\n            calculateStats: true,\n            preventHandleOutsideImage: false,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            snapHandleNearby: 2,\n            interpolation: {\n                enabled: false,\n                nearestEdge: 2,\n                showInterpolationPolyline: false,\n            },\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            actions: {\n                cancelInProgress: {\n                    method: 'cancelInProgress',\n                    bindings: [\n                        {\n                            key: 'Escape',\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const proximitySquared = proximity * proximity;\n            const canvasPoints = annotation.data.contour.polyline.map((p) => viewport.worldToCanvas(p));\n            let startPoint = canvasPoints[canvasPoints.length - 1];\n            for (let i = 0; i < canvasPoints.length; i++) {\n                const endPoint = canvasPoints[i];\n                const distanceToPointSquared = math.lineSegment.distanceToPointSquared(startPoint, endPoint, canvasCoords);\n                if (distanceToPointSquared <= proximitySquared) {\n                    return true;\n                }\n                startPoint = endPoint;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt, clearAnnotation = false) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;\n            const { data } = annotation;\n            this.doneEditMemo();\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            const enabledElement = getEnabledElement(element);\n            if ((this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) ||\n                clearAnnotation) {\n                removeAnnotation(annotation.annotationUID);\n                this.clearEditData();\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                return;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            const changeType = newAnnotation\n                ? ChangeTypes.Completed\n                : ChangeTypes.HandlesUpdated;\n            this.triggerChangeEvent(annotation, enabledElement, changeType, contourHoleProcessingEnabled);\n            this.clearEditData();\n        };\n        this.triggerChangeEvent = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated, contourHoleProcessingEnabled = false) => {\n            if (changeType === ChangeTypes.Completed) {\n                triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n            }\n            else {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, changeType);\n            }\n        };\n        this._mouseDownCallback = (evt) => {\n            const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n            const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld, newAnnotation, } = this.editData;\n            if (this.editData.closed) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const { canvas: canvasPos, world: worldPosOriginal } = currentPoints;\n            let worldPos = worldPosOriginal;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const controlPoints = this.editData.currentPath.getControlPoints();\n            let closePath = controlPoints.length >= 2 && doubleClick;\n            this.doneEditMemo();\n            this.createMemo(element, annotation, {\n                newAnnotation: newAnnotation && controlPoints.length === 1,\n            });\n            if (controlPoints.length >= 2) {\n                const closestHandlePoint = {\n                    index: -1,\n                    distSquared: Infinity,\n                };\n                for (let i = 0, len = controlPoints.length; i < len; i++) {\n                    const controlPoint = controlPoints[i];\n                    const worldControlPoint = sliceToWorld(controlPoint);\n                    const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);\n                    const distSquared = math.point.distanceToPointSquared(canvasPos, canvasControlPoint);\n                    if (distSquared <= CLICK_CLOSE_CURVE_SQR_DIST &&\n                        distSquared < closestHandlePoint.distSquared) {\n                        closestHandlePoint.distSquared = distSquared;\n                        closestHandlePoint.index = i;\n                    }\n                }\n                if (closestHandlePoint.index === 0) {\n                    closePath = true;\n                }\n            }\n            const { snapHandleNearby } = this.configuration;\n            if (snapHandleNearby && !this.editData.closed) {\n                const currentPath = new LivewirePath();\n                const snapPoint = this.scissors.findMinNearby(worldToSlice(worldPosOriginal), 1);\n                const pathPoints = this.scissors.findPathToPoint(snapPoint);\n                currentPath.addPoints(pathPoints);\n                currentPath.prependPath(this.editData.confirmedPath);\n                worldPos = sliceToWorld(snapPoint);\n                this.editData.currentPath = currentPath;\n            }\n            this.editData.closed = this.editData.closed || closePath;\n            this.editData.confirmedPath = this.editData.currentPath;\n            const lastPoint = this.editData.currentPath.getLastPoint();\n            this.editData.confirmedPath.addControlPoint(lastPoint);\n            annotation.data.handles.points.push(sliceToWorld(lastPoint));\n            this.scissors.startSearch(worldToSlice(worldPos));\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (this.editData.closed) {\n                this.updateAnnotation(this.editData.confirmedPath);\n                this._endCallback(evt);\n            }\n            evt.preventDefault();\n        };\n        this._mouseMoveCallback = (evt) => {\n            const { element, currentPoints } = evt.detail;\n            const { world: worldPos, canvas: canvasPos } = currentPoints;\n            const { renderingEngine } = getEnabledElement(element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData.lastCanvasPoint = canvasPos;\n            const { width: imgWidth, height: imgHeight } = this.scissors;\n            const { worldToSlice } = this.editData;\n            const slicePoint = worldToSlice(worldPos);\n            if (slicePoint[0] < 0 ||\n                slicePoint[1] < 0 ||\n                slicePoint[0] >= imgWidth ||\n                slicePoint[1] >= imgHeight) {\n                return;\n            }\n            const pathPoints = this.scissors.findPathToPoint(slicePoint);\n            const currentPath = new LivewirePath();\n            currentPath.addPoints(pathPoints);\n            currentPath.prependPath(this.editData.confirmedPath);\n            this.editData.currentPath = currentPath;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, movingTextBox, handleIndex, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                console.warn('Drag annotation not implemented');\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                this.editHandle(worldPos, element, annotation, handleIndex);\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateDraw(element);\n            this._deactivateModify(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            if (newAnnotation) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            this.scissors = null;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.addEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.removeEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._calculateCachedStats = (annotation, element) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            if (!data.contour.closed) {\n                return;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const { cachedStats } = data;\n            const { polyline: points } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasPoint = canvasCoordinates[0];\n                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n                const deltaXPoint = viewport.canvasToWorld([\n                    canvasPoint[0] + 1,\n                    canvasPoint[1],\n                ]);\n                const deltaYPoint = viewport.canvasToWorld([\n                    canvasPoint[0],\n                    canvasPoint[1] + 1,\n                ]);\n                const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n                const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n                const { imageData } = image;\n                const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, () => {\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(canvasCoordinates);\n                    const topLeftBBWorld = viewport.canvasToWorld([\n                        canvasMinX,\n                        canvasMinY,\n                    ]);\n                    const topLeftBBIndex = utilities.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = utilities.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                let area = math.polyline.getArea(canvasCoordinates) / scale / scale;\n                area *= deltaInX * deltaInY;\n                cachedStats[targetId] = {\n                    Modality: metadata.Modality,\n                    area,\n                    areaUnit: areaUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                this.triggerAnnotationModified(annotation, enabledElement, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {\n            const data = annotation.data;\n            const targetId = this.getTargetId(viewport);\n            if (!data.contour.closed || !textboxStyle.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = 'textBox';\n            const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        this.triggerAnnotationModified = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated) => {\n            const { viewportId, renderingEngineId } = enabledElement;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n                changeType,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    setupBaseEditData(worldPos, element, annotation, nextPos, contourHoleProcessingEnabled) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        this.isDrawing = true;\n        const viewportImageData = viewport.getImageData();\n        const { imageData: vtkImageData } = viewportImageData;\n        let worldToSlice;\n        let sliceToWorld;\n        let width;\n        let height;\n        let scalarData;\n        if (!(viewport instanceof VolumeViewport)) {\n            width = viewportImageData.dimensions[0];\n            height = viewportImageData.dimensions[1];\n            worldToSlice = (point) => {\n                const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n                return [ijkPoint[0], ijkPoint[1]];\n            };\n            sliceToWorld = (point) => csUtils.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);\n            scalarData = viewportImageData.scalarData;\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const sliceImageData = csUtils.getCurrentVolumeViewportSlice(viewport);\n            const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;\n            worldToSlice = (point) => {\n                const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n                const slicePoint = vec3.transformMat4([0, 0, 0], ijkPoint, indexToSliceMatrix);\n                return [slicePoint[0], slicePoint[1]];\n            };\n            sliceToWorld = (point) => {\n                const ijkPoint = vec3.transformMat4([0, 0, 0], [point[0], point[1], 0], sliceToIndexMatrix);\n                return csUtils.transformIndexToWorld(vtkImageData, ijkPoint);\n            };\n            scalarData = sliceImageData.scalarData;\n            width = sliceImageData.width;\n            height = sliceImageData.height;\n        }\n        else {\n            throw new Error('Viewport not supported');\n        }\n        scalarData = csUtils.convertToGrayscale(scalarData, width, height);\n        const { voiRange } = viewport.getProperties();\n        const startPos = worldToSlice(worldPos);\n        this.scissors = LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);\n        if (nextPos) {\n            this.scissorsNext = LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);\n            this.scissorsNext.startSearch(worldToSlice(nextPos));\n        }\n        this.scissors.startSearch(startPos);\n        const newAnnotation = !nextPos;\n        const confirmedPath = new LivewirePath();\n        const currentPath = new LivewirePath();\n        const currentPathNext = newAnnotation ? undefined : new LivewirePath();\n        confirmedPath.addPoint(startPos);\n        confirmedPath.addControlPoint(startPos);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        const lastCanvasPoint = viewport.worldToCanvas(worldPos);\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            newAnnotation,\n            hasMoved: false,\n            lastCanvasPoint,\n            confirmedPath,\n            currentPath,\n            confirmedPathNext: currentPathNext,\n            closed: false,\n            handleIndex: this.editData?.handleIndex ?? annotation.handles?.activeHandleIndex,\n            worldToSlice,\n            sliceToWorld,\n            contourHoleProcessingEnabled,\n        };\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const { world: worldPos } = currentPoints;\n        const annotation = this.createAnnotation(evt);\n        const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n            this.configuration.contourHoleAdditionModifierKey;\n        this.setupBaseEditData(worldPos, element, annotation, undefined, contourHoleProcessingEnabled);\n        this.addAnnotation(annotation, element);\n        this._activateDraw(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(this.editData.viewportIdsToRender);\n        return annotation;\n    }\n    clearEditData() {\n        this.editData = null;\n        this.scissors = null;\n        this.scissorsNext = null;\n        this.isDrawing = false;\n    }\n    editHandle(worldPos, element, annotation, handleIndex) {\n        const { data } = annotation;\n        const { points: handlePoints } = data.handles;\n        const { length: numHandles } = handlePoints;\n        const previousHandle = handlePoints[(handleIndex - 1 + numHandles) % numHandles];\n        const nextHandle = handlePoints[(handleIndex + 1) % numHandles];\n        if (!this.editData?.confirmedPathNext) {\n            this.setupBaseEditData(previousHandle, element, annotation, nextHandle);\n            const { polyline } = data.contour;\n            const confirmedPath = new LivewirePath();\n            const confirmedPathNext = new LivewirePath();\n            const { worldToSlice } = this.editData;\n            const previousIndex = findHandlePolylineIndex(annotation, handleIndex - 1);\n            const nextIndex = findHandlePolylineIndex(annotation, handleIndex + 1);\n            if (nextIndex === -1 || previousIndex === -1) {\n                throw new Error(`Can't find handle index ${nextIndex === -1 && nextHandle} ${previousIndex === -1 && previousHandle}`);\n            }\n            if (handleIndex === 0) {\n                confirmedPathNext.addPoints(polyline.slice(nextIndex + 1, previousIndex).map(worldToSlice));\n            }\n            else {\n                confirmedPath.addPoints(polyline.slice(0, previousIndex + 1).map(worldToSlice));\n                confirmedPathNext.addPoints(polyline.slice(nextIndex, polyline.length).map(worldToSlice));\n            }\n            this.editData.confirmedPath = confirmedPath;\n            this.editData.confirmedPathNext = confirmedPathNext;\n        }\n        const { editData, scissors } = this;\n        const { worldToSlice, sliceToWorld } = editData;\n        const { activeHandleIndex } = data.handles;\n        if (activeHandleIndex === null || activeHandleIndex === undefined) {\n            data.handles.activeHandleIndex = handleIndex;\n        }\n        else if (activeHandleIndex !== handleIndex) {\n            throw new Error(`Trying to edit a different handle than the one currently being edited ${handleIndex}!==${data.handles.activeHandleIndex}`);\n        }\n        const slicePos = worldToSlice(worldPos);\n        if (slicePos[0] < 0 ||\n            slicePos[0] >= scissors.width ||\n            slicePos[1] < 0 ||\n            slicePos[1] >= scissors.height) {\n            return;\n        }\n        handlePoints[handleIndex] = sliceToWorld(slicePos);\n        const pathPointsLeft = scissors.findPathToPoint(slicePos);\n        const pathPointsRight = this.scissorsNext.findPathToPoint(slicePos);\n        const currentPath = new LivewirePath();\n        currentPath.prependPath(editData.confirmedPath);\n        if (handleIndex !== 0) {\n            currentPath.addPoints(pathPointsLeft);\n        }\n        currentPath.addPoints(pathPointsRight.reverse());\n        currentPath.appendPath(editData.confirmedPathNext);\n        if (handleIndex === 0) {\n            currentPath.addPoints(pathPointsLeft);\n        }\n        editData.currentPath = currentPath;\n        annotation.invalidated = true;\n        editData.hasMoved = true;\n        editData.closed = true;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        this.updateAnnotation(this.editData?.currentPath);\n        return super.renderAnnotation(enabledElement, svgDrawingHelper);\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    createAnnotation(evt) {\n        const contourSegmentationAnnotation = super.createAnnotation(evt);\n        const { world: worldPos } = evt.detail.currentPoints;\n        const annotation = csUtils.deepMerge(contourSegmentationAnnotation, {\n            data: {\n                handles: {\n                    points: [[...worldPos]],\n                },\n            },\n        });\n        return annotation;\n    }\n    cancelInProgress(element, config, evt) {\n        if (!this.editData) {\n            this.undo();\n            return;\n        }\n        this._endCallback(evt, true);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { annotation, enabledElement, svgDrawingHelper, annotationStyle, targetId, } = renderContext;\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const { worldToCanvas } = viewport;\n        const { annotationUID, data, highlighted } = annotation;\n        const { handles } = data;\n        const newAnnotation = this.editData?.newAnnotation;\n        const { lineWidth, lineDash, color } = annotationStyle;\n        if (highlighted ||\n            (newAnnotation &&\n                annotation.annotationUID === this.editData?.annotation?.annotationUID)) {\n            const handleGroupUID = '0';\n            const canvasHandles = handles.points.map(worldToCanvas);\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasHandles, {\n                color,\n                lineDash,\n                lineWidth,\n            });\n        }\n        super.renderAnnotationInstance(renderContext);\n        if (!data.cachedStats[targetId] ||\n            data.cachedStats[targetId]?.areaUnit === null) {\n            data.cachedStats[targetId] = {\n                Modality: null,\n                area: null,\n                areaUnit: null,\n            };\n            this._calculateCachedStats(annotation, element);\n        }\n        else if (annotation.invalidated) {\n            this._throttledCalculateCachedStats(annotation, element);\n        }\n        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);\n        return true;\n    }\n    updateAnnotation(livewirePath) {\n        if (!this.editData || !livewirePath) {\n            return;\n        }\n        const { annotation, sliceToWorld, worldToSlice, closed, newAnnotation } = this.editData;\n        let { pointArray: imagePoints } = livewirePath;\n        if (imagePoints.length > 1) {\n            imagePoints = [...imagePoints, imagePoints[0]];\n        }\n        const targetWindingDirection = newAnnotation && closed ? ContourWindingDirection.Clockwise : undefined;\n        this.updateContourPolyline(annotation, {\n            points: imagePoints,\n            closed,\n            targetWindingDirection,\n        }, {\n            canvasToWorld: sliceToWorld,\n            worldToCanvas: worldToSlice,\n        });\n    }\n}\nexport default LivewireContourTool;\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, areaUnit } = cachedVolumeStats;\n    const textLines = [];\n    if (area) {\n        const areaLine = `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    return textLines;\n}\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nimport { drawHandles as drawHandlesSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nconst { transformWorldToIndex } = csUtils;\nclass ProbeTool extends AnnotationTool {\n    static { this.toolName = 'Probe'; }\n    static { this.probeDefaults = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            handleRadius: '6',\n            textCanvasOffset: {\n                x: 6,\n                y: -6,\n            },\n        },\n    }; }\n    constructor(toolProps = {}, defaultToolProps) {\n        super(toolProps, AnnotationTool.mergeDefaultProps(ProbeTool.probeDefaults, defaultToolProps));\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: { points: [[...worldPos]] },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { viewportId, renderingEngine } = getEnabledElement(element);\n            this.eventDispatchDetail = {\n                viewportId,\n                renderingEngineId: renderingEngine.id,\n            };\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            if (newAnnotation) {\n                this.createMemo(element, annotation, { newAnnotation });\n            }\n            this.editData = null;\n            this.isDrawing = false;\n            this.doneEditMemo();\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            data.handles.points[0] = [...worldPos];\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const annotationUID = annotation.annotationUID;\n                const data = annotation.data;\n                const point = data.handles.points[0];\n                const canvasCoordinates = viewport.worldToCanvas(point);\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!data.cachedStats) {\n                    data.cachedStats = {};\n                }\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].value === null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        index: null,\n                        value: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement, ChangeTypes.StatsUpdated);\n                }\n                else if (annotation.invalidated) {\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const handleGroupUID = '0';\n                drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color, lineWidth, handleRadius: this.configuration.handleRadius });\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (textLines) {\n                    const textCanvasCoordinates = [\n                        canvasCoordinates[0] + this.configuration.textCanvasOffset.x,\n                        canvasCoordinates[1] + this.configuration.textCanvasOffset.y,\n                    ];\n                    const textUID = '0';\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], options);\n                }\n            }\n            return renderStatus;\n        };\n    }\n    isPointNearTool(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const point = data.handles.points[0];\n        const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n        return vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n    }\n    toolSelectedCallback() { }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, viewUp, instance, viewport, } = this.hydrateBase(ProbeTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const point = data.handles.points[0];\n        const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n        const near = vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n        if (near === true) {\n            return point;\n        }\n    }\n    handleSelectedCallback(evt, annotation) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement, changeType = ChangeTypes.StatsUpdated) {\n        const data = annotation.data;\n        const { renderingEngineId, viewport } = enabledElement;\n        const { element } = viewport;\n        const worldPos = data.handles.points[0];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const pixelUnitsOptions = {\n                isPreScaled: isViewportPreScaled(viewport, targetId),\n                isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n            };\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { dimensions, imageData, metadata, voxelManager } = image;\n            const modality = metadata.Modality;\n            let ijk = transformWorldToIndex(imageData, worldPos);\n            ijk = vec3.round(ijk, ijk);\n            if (csUtils.indexWithinDimensions(ijk, dimensions)) {\n                this.isHandleOutsideImage = false;\n                let value = voxelManager.getAtIJKPoint(ijk);\n                if (targetId.startsWith('imageId:')) {\n                    const imageId = targetId.split('imageId:')[1];\n                    const imageURI = csUtils.imageIdToURI(imageId);\n                    const viewports = csUtils.getViewportsWithImageURI(imageURI);\n                    const viewport = viewports[0];\n                    ijk[2] = viewport.getCurrentImageIdIndex();\n                }\n                let modalityUnit;\n                if (modality === 'US') {\n                    const calibratedResults = getCalibratedProbeUnitsAndValue(image, [\n                        ijk,\n                    ]);\n                    const hasEnhancedRegionValues = calibratedResults.values.every((value) => value !== null);\n                    value = (hasEnhancedRegionValues ? calibratedResults.values : value);\n                    modalityUnit = hasEnhancedRegionValues\n                        ? calibratedResults.units\n                        : 'raw';\n                }\n                else {\n                    modalityUnit = getPixelValueUnits(modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                }\n                cachedStats[targetId] = {\n                    index: ijk,\n                    value,\n                    Modality: modality,\n                    modalityUnit,\n                };\n                annotation.invalidated = true;\n            }\n            else {\n                this.isHandleOutsideImage = true;\n                cachedStats[targetId] = {\n                    index: ijk,\n                    Modality: modality,\n                };\n            }\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, changeType);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { index, value, modalityUnit } = cachedVolumeStats;\n    if (value === undefined || !index) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n    if (value instanceof Array && modalityUnit instanceof Array) {\n        for (let i = 0; i < value.length; i++) {\n            textLines.push(`${csUtils.roundNumber(value[i])} ${modalityUnit[i]}`);\n        }\n    }\n    else {\n        textLines.push(`${csUtils.roundNumber(value)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default ProbeTool;\n","import { cache, utilities as csUtils, getEnabledElement, } from '@cornerstonejs/core';\nimport { growCut } from '../../utilities/segmentation';\nimport GrowCutBaseTool from '../base/GrowCutBaseTool';\nimport { calculateGrowCutSeeds } from '../../utilities/segmentation/growCut/runOneClickGrowCut';\nimport { ToolModes } from '../../enums';\nclass RegionSegmentPlusTool extends GrowCutBaseTool {\n    static { this.toolName = 'RegionSegmentPlus'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            isPartialVolume: false,\n            positiveSeedVariance: 0.4,\n            negativeSeedVariance: 0.9,\n            subVolumePaddingPercentage: 0.1,\n            islandRemoval: {\n                enabled: false,\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseTimer = null;\n        this.allowedToProceed = false;\n    }\n    mouseMoveCallback(evt) {\n        if (this.mode !== ToolModes.Active) {\n            return;\n        }\n        const eventData = evt.detail;\n        const { currentPoints, element } = eventData;\n        const { world: worldPoint } = currentPoints;\n        element.style.cursor = 'default';\n        if (this.mouseTimer !== null) {\n            window.clearTimeout(this.mouseTimer);\n            this.mouseTimer = null;\n        }\n        this.mouseTimer = window.setTimeout(() => {\n            this.onMouseStable(evt, worldPoint, element);\n        }, this.configuration.mouseStabilityDelay || 500);\n    }\n    async onMouseStable(evt, worldPoint, element) {\n        await super.preMouseDownCallback(evt);\n        const refVolume = cache.getVolume(this.growCutData.segmentation.referencedVolumeId);\n        const seeds = calculateGrowCutSeeds(refVolume, worldPoint, {}) || {\n            positiveSeedIndices: new Set(),\n            negativeSeedIndices: new Set(),\n        };\n        const { positiveSeedIndices, negativeSeedIndices } = seeds;\n        let cursor;\n        if (positiveSeedIndices.size / negativeSeedIndices.size > 20 ||\n            negativeSeedIndices.size < 30) {\n            cursor = 'not-allowed';\n            this.allowedToProceed = false;\n        }\n        else {\n            cursor = 'copy';\n            this.allowedToProceed = true;\n        }\n        const enabledElement = getEnabledElement(element);\n        if (element) {\n            element.style.cursor = cursor;\n            requestAnimationFrame(() => {\n                if (element.style.cursor !== cursor) {\n                    element.style.cursor = cursor;\n                }\n            });\n        }\n        if (this.allowedToProceed) {\n            this.seeds = seeds;\n        }\n        if (enabledElement && enabledElement.viewport) {\n            enabledElement.viewport.render();\n        }\n    }\n    async preMouseDownCallback(evt) {\n        if (!this.allowedToProceed) {\n            return false;\n        }\n        const eventData = evt.detail;\n        const { currentPoints, element } = eventData;\n        const enabledElement = getEnabledElement(element);\n        if (enabledElement) {\n            element.style.cursor = 'wait';\n            requestAnimationFrame(() => {\n                if (element.style.cursor !== 'wait') {\n                    element.style.cursor = 'wait';\n                }\n            });\n        }\n        const { world: worldPoint } = currentPoints;\n        await super.preMouseDownCallback(evt);\n        this.growCutData = csUtils.deepMerge(this.growCutData, {\n            worldPoint,\n            islandRemoval: {\n                worldIslandPoints: [worldPoint],\n            },\n        });\n        this.growCutData.worldPoint = worldPoint;\n        this.growCutData.islandRemoval = {\n            worldIslandPoints: [worldPoint],\n        };\n        await this.runGrowCut();\n        if (element) {\n            element.style.cursor = 'default';\n        }\n        return true;\n    }\n    getRemoveIslandData(growCutData) {\n        const { worldPoint } = growCutData;\n        return {\n            worldIslandPoints: [worldPoint],\n        };\n    }\n    async getGrowCutLabelmap(growCutData) {\n        const { segmentation: { referencedVolumeId }, worldPoint, options, } = growCutData;\n        const { subVolumePaddingPercentage } = this.configuration;\n        const mergedOptions = {\n            ...options,\n            subVolumePaddingPercentage,\n            seeds: this.seeds,\n        };\n        return growCut.runOneClickGrowCut({\n            referencedVolumeId,\n            worldPosition: worldPoint,\n            options: mergedOptions,\n        });\n    }\n}\nexport default RegionSegmentPlusTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, getRenderingEngine, } from '@cornerstonejs/core';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { Events } from '../../enums';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { growCut } from '../../utilities/segmentation';\nimport GrowCutBaseTool from '../base/GrowCutBaseTool';\nclass RegionSegmentTool extends GrowCutBaseTool {\n    static { this.toolName = 'RegionSegment'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            isPartialVolume: true,\n            positiveSeedVariance: 0.5,\n            negativeSeedVariance: 0.9,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const { world: currentWorldPoint } = currentPoints;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.growCutData.circleBorderPoint = currentWorldPoint;\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._endCallback = async (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.runGrowCut();\n            this._deactivateDraw(element);\n            this.growCutData = null;\n            resetElementCursor(element);\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    async preMouseDownCallback(evt) {\n        const eventData = evt.detail;\n        const { element, currentPoints } = eventData;\n        const { world: worldPoint } = currentPoints;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        await super.preMouseDownCallback(evt);\n        Object.assign(this.growCutData, {\n            circleCenterPoint: worldPoint,\n            circleBorderPoint: worldPoint,\n        });\n        this._activateDraw(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        return true;\n    }\n    async getGrowCutLabelmap(growCutData) {\n        const { segmentation: { referencedVolumeId }, renderingEngineId, viewportId, circleCenterPoint, circleBorderPoint, options, } = growCutData;\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n        const viewport = renderingEngine.getViewport(viewportId);\n        const worldCircleRadius = vec3.len(vec3.sub(vec3.create(), circleCenterPoint, circleBorderPoint));\n        const sphereInfo = {\n            center: circleCenterPoint,\n            radius: worldCircleRadius,\n        };\n        return growCut.runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options);\n    }\n    _activateDraw(element) {\n        element.addEventListener(Events.MOUSE_UP, this._endCallback);\n        element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n        element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this.growCutData) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const { segmentation: segmentationData, circleCenterPoint, circleBorderPoint, } = this.growCutData;\n        const canvasCenterPoint = viewport.worldToCanvas(circleCenterPoint);\n        const canvasBorderPoint = viewport.worldToCanvas(circleBorderPoint);\n        const vecCenterToBorder = vec2.sub(vec2.create(), canvasBorderPoint, canvasCenterPoint);\n        const circleRadius = vec2.len(vecCenterToBorder);\n        if (csUtils.isEqual(circleRadius, 0)) {\n            return;\n        }\n        const annotationUID = 'growcut';\n        const circleUID = '0';\n        const { color } = this.getSegmentStyle({\n            segmentationId: segmentationData.segmentationId,\n            segmentIndex: segmentationData.segmentIndex,\n            viewportId: viewport.id,\n        });\n        drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, canvasCenterPoint, circleRadius, {\n            color,\n        });\n    }\n}\nexport default RegionSegmentTool;\n","import { eventTarget, utilities } from '@cornerstonejs/core';\nimport SplineROITool from './SplineROITool';\nimport { Events } from '../../enums';\nimport { convertContourSegmentationAnnotation } from '../../utilities/contourSegmentation';\nclass SplineContourSegmentationTool extends SplineROITool {\n    static { this.toolName = 'SplineContourSegmentationTool'; }\n    constructor(toolProps) {\n        const initialProps = utilities.deepMerge({\n            configuration: {\n                calculateStats: false,\n            },\n        }, toolProps);\n        super(initialProps);\n        this.annotationCutMergeCompletedBinded =\n            this.annotationCutMergeCompleted.bind(this);\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    initializeListeners() {\n        eventTarget.addEventListener(Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, this.annotationCutMergeCompletedBinded);\n    }\n    removeListeners() {\n        eventTarget.removeEventListener(Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, this.annotationCutMergeCompletedBinded);\n    }\n    annotationCutMergeCompleted(evt) {\n        const { sourceAnnotation: annotation } = evt.detail;\n        if (this.toolName !== annotation?.metadata?.toolName ||\n            !this.splineToolNames.includes(annotation?.metadata?.toolName) ||\n            !this.configuration.simplifiedSpline) {\n            return;\n        }\n        convertContourSegmentationAnnotation(annotation);\n    }\n}\nexport default SplineContourSegmentationTool;\n","import { getEnabledElement, eventTarget, triggerEvent, utilities, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { addAnnotation, getChildAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { drawHandles as drawHandlesSvg, drawPolyline as drawPolylineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events, MouseBindings, KeyboardBindings, ChangeTypes, } from '../../enums';\nimport * as math from '../../utilities/math';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport { CardinalSpline } from './splines/CardinalSpline';\nimport { LinearSpline } from './splines/LinearSpline';\nimport { CatmullRomSpline } from './splines/CatmullRomSpline';\nimport { BSpline } from './splines/BSpline';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\nimport { convertContourSegmentationAnnotation } from '../../utilities/contourSegmentation';\nconst SPLINE_MIN_POINTS = 3;\nconst SPLINE_CLICK_CLOSE_CURVE_DIST = 10;\nconst DEFAULT_SPLINE_CONFIG = {\n    resolution: 20,\n    controlPointAdditionDistance: 6,\n    controlPointDeletionDistance: 6,\n    showControlPointsConnectors: false,\n    controlPointAdditionEnabled: true,\n    controlPointDeletionEnabled: true,\n};\nvar SplineTypesEnum;\n(function (SplineTypesEnum) {\n    SplineTypesEnum[\"Cardinal\"] = \"CARDINAL\";\n    SplineTypesEnum[\"Linear\"] = \"LINEAR\";\n    SplineTypesEnum[\"CatmullRom\"] = \"CATMULLROM\";\n    SplineTypesEnum[\"BSpline\"] = \"BSPLINE\";\n})(SplineTypesEnum || (SplineTypesEnum = {}));\nvar SplineToolActions;\n(function (SplineToolActions) {\n    SplineToolActions[\"AddControlPoint\"] = \"addControlPoint\";\n    SplineToolActions[\"DeleteControlPoint\"] = \"deleteControlPoint\";\n})(SplineToolActions || (SplineToolActions = {}));\nconst splineToolNames = [\n    'CatmullRomSplineROI',\n    'LinearSplineROI',\n    'BSplineROI',\n    'CardinalSplineROI',\n];\nclass SplineROITool extends ContourSegmentationBaseTool {\n    static { this.toolName = 'SplineROI'; }\n    static { this.SplineTypes = SplineTypesEnum; }\n    static { this.Actions = SplineToolActions; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            calculateStats: true,\n            simplifiedSpline: false,\n            getTextLines: defaultGetTextLines,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            spline: {\n                configuration: {\n                    [SplineTypesEnum.Cardinal]: {\n                        Class: CardinalSpline,\n                        scale: 0.5,\n                    },\n                    [SplineTypesEnum.CatmullRom]: {\n                        Class: CatmullRomSpline,\n                    },\n                    [SplineTypesEnum.Linear]: {\n                        Class: LinearSpline,\n                    },\n                    [SplineTypesEnum.BSpline]: {\n                        Class: BSpline,\n                        controlPointAdditionEnabled: false,\n                        controlPointDeletionEnabled: false,\n                        showControlPointsConnectors: true,\n                    },\n                },\n                type: SplineTypesEnum.CatmullRom,\n                drawPreviewEnabled: true,\n                enableTwoPointPreview: false,\n                lastControlPointDeletionKeys: ['Backspace', 'Delete'],\n            },\n            actions: {\n                [SplineToolActions.AddControlPoint]: {\n                    method: 'addControlPointCallback',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Primary,\n                            modifierKey: KeyboardBindings.Shift,\n                        },\n                    ],\n                },\n                [SplineToolActions.DeleteControlPoint]: {\n                    method: 'deleteControlPointCallback',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Primary,\n                            modifierKey: KeyboardBindings.Ctrl,\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.splineToolNames = [\n            'CatmullRomSplineROI',\n            'LinearSplineROI',\n            'BSplineROI',\n            'CardinalSplineROI',\n        ];\n        this.isHandleOutsideImage = false;\n        this.fireChangeOnUpdate = null;\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const { instance: spline } = annotation.data.spline;\n            return spline.isPointNearCurve(canvasCoords, proximity);\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;\n            const { data } = annotation;\n            annotation.autoGenerated = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            const enabledElement = getEnabledElement(element);\n            const image = this.getTargetImageData(this.getTargetId(enabledElement.viewport));\n            const { imageData, dimensions } = image;\n            this.isHandleOutsideImage = data.handles.points\n                .map((p) => utilities.transformWorldToIndex(imageData, p))\n                .some((index) => !utilities.indexWithinDimensions(index, dimensions));\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            const changeType = newAnnotation\n                ? ChangeTypes.Completed\n                : ChangeTypes.HandlesUpdated;\n            if (!this.fireChangeOnUpdate) {\n                this.fireChangeOnUpdate = {\n                    annotationUID: annotation.annotationUID,\n                    changeType,\n                    contourHoleProcessingEnabled,\n                };\n            }\n            else {\n                this.fireChangeOnUpdate.annotationUID = annotation.annotationUID;\n                this.fireChangeOnUpdate.changeType = changeType;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._keyDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const key = eventDetail.key ?? '';\n            const { lastControlPointDeletionKeys } = this.configuration.spline;\n            const deleteLastPoint = lastControlPointDeletionKeys.includes(key);\n            if (!deleteLastPoint) {\n                return;\n            }\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            if (data.handles.points.length === SPLINE_MIN_POINTS) {\n                this.cancel(element);\n                return;\n            }\n            else {\n                const controlPointIndex = data.handles.points.length - 1;\n                this._deleteControlPointByIndex(element, annotation, controlPointIndex);\n            }\n            evt.preventDefault();\n        };\n        this._mouseMoveCallback = (evt) => {\n            const { drawPreviewEnabled } = this.configuration.spline;\n            if (!drawPreviewEnabled) {\n                return;\n            }\n            const { element } = evt.detail;\n            const { renderingEngine } = getEnabledElement(element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData.lastCanvasPoint = evt.detail.currentPoints.canvas;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._mouseDownCallback = (evt) => {\n            const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            if (data.contour.closed) {\n                return;\n            }\n            this.doneEditMemo();\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const { canvas: canvasPoint, world: worldPoint } = currentPoints;\n            let closeContour = data.handles.points.length >= 2 && doubleClick;\n            let addNewPoint = true;\n            if (data.handles.points.length) {\n                this.createMemo(element, annotation, {\n                    newAnnotation: data.handles.points.length === 1,\n                });\n            }\n            if (data.handles.points.length >= 3) {\n                this.createMemo(element, annotation);\n                const { instance: spline } = data.spline;\n                const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);\n                if (closestControlPoint?.index === 0) {\n                    addNewPoint = false;\n                    closeContour = true;\n                }\n            }\n            if (addNewPoint) {\n                data.handles.points.push(worldPoint);\n            }\n            data.contour.closed = data.contour.closed || closeContour;\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (data.contour.closed) {\n                this._endCallback(evt);\n            }\n            evt.preventDefault();\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                this.moveAnnotation(annotation, worldPosDelta);\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.triggerAnnotationCompleted = (annotation, contourHoleProcessingEnabled) => {\n            const eventType = Events.ANNOTATION_COMPLETED;\n            const eventDetail = {\n                annotation,\n                changeType: ChangeTypes.Completed,\n                contourHoleProcessingEnabled,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this.triggerAnnotationModified = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated) => {\n            const { viewportId, renderingEngineId } = enabledElement;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n                changeType,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this.triggerChangeEvent = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated, contourHoleProcessingEnabled) => {\n            if (changeType === ChangeTypes.Completed) {\n                this.triggerAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n            }\n            else {\n                this.triggerAnnotationModified(annotation, enabledElement, changeType);\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.KEY_DOWN, this._keyDownCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.addEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.KEY_DOWN, this._keyDownCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.removeEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {\n            const data = annotation.data;\n            const targetId = this.getTargetId(viewport);\n            if (!data.spline.instance.closed || !textboxStyle.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = 'textBox';\n            const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        this.addControlPointCallback = (evt, annotation) => {\n            const { data } = annotation;\n            const splineType = data.spline.type;\n            const splineConfig = this._getSplineConfig(splineType);\n            const maxDist = splineConfig.controlPointAdditionDistance;\n            if (splineConfig.controlPointAdditionEnabled === false) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { instance: spline } = data.spline;\n            const canvasPos = evt.detail.currentPoints.canvas;\n            const closestPointInfo = spline.getClosestPoint(canvasPos);\n            if (closestPointInfo.distance > maxDist) {\n                return;\n            }\n            const { index, point: canvasPoint } = spline.addControlPointAtU(closestPointInfo.uValue);\n            data.handles.points.splice(index, 0, canvasToWorld(canvasPoint));\n            annotation.invalidated = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.deleteControlPointCallback = (evt, annotation) => {\n            const splineType = annotation.data.spline.type;\n            const splineConfig = this._getSplineConfig(splineType);\n            const maxDist = splineConfig.controlPointDeletionDistance;\n            if (splineConfig.controlPointDeletionEnabled === false) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const { canvas: canvasPos } = currentPoints;\n            const { instance: spline } = annotation.data.spline;\n            const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPos, maxDist);\n            if (!closestControlPoint) {\n                return;\n            }\n            this._deleteControlPointByIndex(element, annotation, closestControlPoint.index);\n        };\n        this._calculateCachedStats = (annotation, element) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            if (!data.contour.closed) {\n                return;\n            }\n            const enabledElement = getEnabledElement(element);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            const { cachedStats } = data;\n            const { polyline: points } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasPoint = canvasCoordinates[0];\n                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n                const deltaXPoint = viewport.canvasToWorld([\n                    canvasPoint[0] + 1,\n                    canvasPoint[1],\n                ]);\n                const deltaYPoint = viewport.canvasToWorld([\n                    canvasPoint[0],\n                    canvasPoint[1] + 1,\n                ]);\n                const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n                const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n                const { imageData } = image;\n                const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, () => {\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(canvasCoordinates);\n                    const topLeftBBWorld = viewport.canvasToWorld([\n                        canvasMinX,\n                        canvasMinY,\n                    ]);\n                    const topLeftBBIndex = utilities.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = utilities.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                let area = math.polyline.getArea(canvasCoordinates) / scale / scale;\n                area *= deltaInX * deltaInY;\n                cachedStats[targetId] = {\n                    Modality: metadata.Modality,\n                    area,\n                    areaUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                this.triggerAnnotationModified(annotation, enabledElement, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n        this.annotationCompletedBinded = this.annotationCompleted.bind(this);\n    }\n    annotationCompleted(evt) {\n        const { sourceAnnotation: annotation } = evt.detail;\n        if (!this.splineToolNames.includes(annotation?.metadata?.toolName) ||\n            !this.configuration.simplifiedSpline ||\n            !this.isContourSegmentationTool()) {\n            return;\n        }\n        convertContourSegmentationAnnotation(annotation);\n    }\n    initializeListeners() {\n        eventTarget.addEventListener(Events.ANNOTATION_COMPLETED, this.annotationCompletedBinded);\n    }\n    removeListeners() {\n        eventTarget.removeEventListener(Events.ANNOTATION_COMPLETED, this.annotationCompletedBinded);\n    }\n    onSetToolEnabled() {\n        this.initializeListeners();\n    }\n    onSetToolActive() {\n        this.initializeListeners();\n    }\n    onSetToolDisabled() {\n        this.removeListeners();\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const { canvas: canvasPos } = currentPoints;\n        const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n            this.configuration.contourHoleAdditionModifierKey;\n        const annotation = this.createAnnotation(evt);\n        this.isDrawing = true;\n        this.addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n            lastCanvasPoint: canvasPos,\n            contourHoleProcessingEnabled,\n        };\n        this._activateDraw(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    cancel(element) {\n        if (!this.isDrawing) {\n            return;\n        }\n        this.isDrawing = false;\n        this._deactivateDraw(element);\n        this._deactivateModify(element);\n        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n        if (newAnnotation) {\n            removeAnnotation(annotation.annotationUID);\n        }\n        super.cancelAnnotation(annotation);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        this.editData = null;\n        return annotation.annotationUID;\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, targetId, svgDrawingHelper, annotationStyle } = renderContext;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { element } = viewport;\n        const annotation = renderContext.annotation;\n        const { annotationUID, data, highlighted } = annotation;\n        const { handles } = data;\n        const { points: controlPoints, activeHandleIndex } = handles;\n        const newAnnotation = this.editData?.newAnnotation;\n        const { lineWidth, lineDash, color, locked: annotationLocked, } = annotationStyle;\n        const canvasCoordinates = controlPoints.map((p) => worldToCanvas(p));\n        const { drawPreviewEnabled } = this.configuration.spline;\n        const splineType = annotation.data.spline.type;\n        const splineConfig = this._getSplineConfig(splineType);\n        const spline = annotation.data.spline.instance;\n        const childAnnotations = getChildAnnotations(annotation);\n        const missingAnnotation = childAnnotations.findIndex((it) => !it);\n        if (missingAnnotation !== -1) {\n            throw new Error(`Can't find annotation for child ${annotation.childAnnotationUIDs.join()}`);\n        }\n        const splineAnnotationsGroup = [annotation, ...childAnnotations].filter((annotation) => this._isSplineROIAnnotation(annotation));\n        splineAnnotationsGroup.forEach((annotation) => {\n            const spline = this._updateSplineInstance(element, annotation);\n            const splinePolylineCanvas = spline.getPolylinePoints();\n            this.updateContourPolyline(annotation, {\n                points: splinePolylineCanvas,\n                closed: data.contour.closed,\n                targetWindingDirection: ContourWindingDirection.Clockwise,\n            }, viewport, { updateWindingDirection: data.contour.closed });\n        });\n        super.renderAnnotationInstance(renderContext);\n        if (!data.cachedStats[targetId] ||\n            data.cachedStats[targetId].areaUnit == null) {\n            data.cachedStats[targetId] = {\n                Modality: null,\n                area: null,\n                areaUnit: null,\n            };\n            this._calculateCachedStats(annotation, element);\n        }\n        else if (annotation.invalidated) {\n            this._throttledCalculateCachedStats(annotation, element);\n        }\n        let activeHandleCanvasCoords;\n        if (!annotationLocked && !this.editData && activeHandleIndex !== null) {\n            activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n        }\n        if (activeHandleCanvasCoords || newAnnotation || highlighted) {\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                color,\n                lineWidth,\n                handleRadius: '3',\n            });\n        }\n        if (drawPreviewEnabled &&\n            spline.numControlPoints >= 1 &&\n            this.editData?.lastCanvasPoint &&\n            !spline.closed) {\n            const { lastCanvasPoint } = this.editData;\n            const { enableTwoPointPreview } = this.configuration.spline;\n            if (spline.numControlPoints === 1 && enableTwoPointPreview) {\n                const firstPoint = canvasCoordinates[0];\n                const previewPolylinePoints = [firstPoint, lastCanvasPoint];\n                drawPolylineSvg(svgDrawingHelper, annotationUID, 'previewSplineChange', previewPolylinePoints, {\n                    color: '#9EA0CA',\n                    lineDash: lineDash,\n                    lineWidth: 1,\n                });\n            }\n            else if (spline.numControlPoints > 1) {\n                const previewPolylinePoints = spline.getPreviewPolylinePoints(lastCanvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);\n                drawPolylineSvg(svgDrawingHelper, annotationUID, 'previewSplineChange', previewPolylinePoints, {\n                    color: '#9EA0CA',\n                    lineDash: lineDash,\n                    lineWidth: 1,\n                });\n            }\n        }\n        if (splineConfig.showControlPointsConnectors) {\n            const controlPointsConnectors = [...canvasCoordinates];\n            if (spline.closed) {\n                controlPointsConnectors.push(canvasCoordinates[0]);\n            }\n            drawPolylineSvg(svgDrawingHelper, annotationUID, 'controlPointsConnectors', controlPointsConnectors, {\n                color: 'rgba(255, 255, 255, 0.5)',\n                lineWidth: 1,\n            });\n        }\n        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);\n        if (this.fireChangeOnUpdate?.annotationUID === annotationUID) {\n            this.triggerChangeEvent(annotation, enabledElement, this.fireChangeOnUpdate.changeType, this.fireChangeOnUpdate.contourHoleProcessingEnabled);\n            this.fireChangeOnUpdate = null;\n        }\n        annotation.invalidated = false;\n        return true;\n    }\n    createInterpolatedSplineControl(annotation) {\n        if (annotation.data.handles.points?.length) {\n            return;\n        }\n        const { polyline } = annotation.data.contour;\n        if (!polyline || !polyline.length) {\n            return;\n        }\n        annotation.data.handles.points = [];\n        const { points } = annotation.data.handles;\n        const increment = Math.max(10, Math.floor(polyline.length / 20));\n        for (let i = 0; i < polyline.length - increment; i += increment) {\n            points.push(polyline[i]);\n        }\n        points.push(polyline[polyline.length - 1]);\n    }\n    isSplineAnnotation(annotation) {\n        return splineToolNames.includes(annotation?.metadata?.toolName);\n    }\n    createSplineObjectFromType(annotation, splineType) {\n        const splineConfig = this._getSplineConfig(splineType);\n        const spline = new splineConfig.Class();\n        annotation.data.spline = {\n            type: splineConfig.type,\n            instance: spline,\n            resolution: splineConfig.resolution,\n        };\n    }\n    createAnnotation(evt) {\n        const contourAnnotation = super.createAnnotation(evt);\n        const { world: worldPos } = evt.detail.currentPoints;\n        const { type: splineType } = this.configuration.spline;\n        const splineConfig = this._getSplineConfig(splineType);\n        const spline = new splineConfig.Class();\n        const createSpline = () => ({\n            type: splineConfig.type,\n            instance: spline,\n            resolution: splineConfig.resolution,\n        });\n        let onInterpolationComplete;\n        if (this.configuration.interpolation?.enabled) {\n            onInterpolationComplete = (annotation) => {\n                annotation.data.spline ||= createSpline();\n                this.createInterpolatedSplineControl(annotation);\n            };\n        }\n        return utilities.deepMerge(contourAnnotation, {\n            data: {\n                handles: {\n                    points: [[...worldPos]],\n                },\n                spline: createSpline(),\n                cachedStats: {},\n            },\n            onInterpolationComplete,\n        });\n    }\n    _deleteControlPointByIndex(element, annotation, controlPointIndex) {\n        const enabledElement = getEnabledElement(element);\n        const { points: controlPoints } = annotation.data.handles;\n        if (controlPoints.length === 3) {\n            removeAnnotation(annotation.annotationUID);\n        }\n        else {\n            controlPoints.splice(controlPointIndex, 1);\n        }\n        const { renderingEngine } = enabledElement;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        annotation.invalidated = true;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    }\n    _isSplineROIAnnotation(annotation) {\n        return !!annotation.data?.spline;\n    }\n    _getSplineConfig(type) {\n        const { configuration: config } = this;\n        const splineConfigs = config.spline.configuration;\n        return Object.assign({ type }, DEFAULT_SPLINE_CONFIG, splineConfigs[type]);\n    }\n    _updateSplineInstance(element, annotation) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { data } = annotation;\n        const { type: splineType, instance: spline } = annotation.data.spline;\n        const splineConfig = this._getSplineConfig(splineType);\n        const worldPoints = data.handles.points;\n        const canvasPoints = worldPoints.map(worldToCanvas);\n        const resolution = splineConfig.resolution !== undefined\n            ? parseInt(splineConfig.resolution)\n            : undefined;\n        const scale = splineConfig.scale !== undefined\n            ? parseFloat(splineConfig.scale)\n            : undefined;\n        spline.setControlPoints(canvasPoints);\n        spline.closed = !!data.contour.closed;\n        if (!spline.fixedResolution &&\n            resolution !== undefined &&\n            spline.resolution !== resolution) {\n            spline.resolution = resolution;\n            annotation.invalidated = true;\n        }\n        if (spline instanceof CardinalSpline &&\n            !spline.fixedScale &&\n            scale !== undefined &&\n            spline.scale !== scale) {\n            spline.scale = scale;\n            annotation.invalidated = true;\n        }\n        return spline;\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        if (points.length < SPLINE_MIN_POINTS) {\n            console.warn('Spline requires at least 3 control points');\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, viewUp, instance, viewport, } = this.hydrateBase(SplineROITool, enabledElement, points, options);\n        const splineType = options?.splineType || SplineTypesEnum.CatmullRom;\n        const splineConfig = instance._getSplineConfig(splineType);\n        const SplineClass = splineConfig.Class;\n        const splineInstance = new SplineClass();\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n                label: '',\n                cachedStats: {},\n                spline: {\n                    type: splineType,\n                    instance: splineInstance,\n                },\n                contour: {\n                    closed: true,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: true,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, isEmptyArea, areaUnit } = cachedVolumeStats;\n    const textLines = [];\n    if (area) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${utilities.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    return textLines;\n}\nexport default SplineROITool;\n","import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, StackViewport, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawHandle as drawHandleSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { distanceToPoint } from '../../utilities/math/point';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nimport { lineSegment } from '../../utilities/math';\nconst { transformWorldToIndex } = csUtils;\nclass UltrasoundDirectionalTool extends AnnotationTool {\n    static { this.toolName = 'UltrasoundDirectionalTool'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            displayBothAxesDistances: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.startedDrawing) {\n                return;\n            }\n            this.startedDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            if (!(viewport instanceof StackViewport)) {\n                throw new Error('UltrasoundDirectionalTool can only be used on a StackViewport');\n            }\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            if (this.startedDrawing && data.handles.points.length === 1) {\n                this.editData.handleIndex = 1;\n                return;\n            }\n            this.startedDrawing = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                this.startedDrawing = false;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].xValues == null) {\n                    data.cachedStats[targetId] = {\n                        xValues: [0, 0],\n                        yValues: [0, 0],\n                        isHorizontal: false,\n                        units: [''],\n                        isUnitless: false,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let handleGroupUID = '0';\n                drawHandleSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[0], {\n                    color,\n                }, 0);\n                renderStatus = true;\n                if (canvasCoordinates.length !== 2) {\n                    return renderStatus;\n                }\n                handleGroupUID = '1';\n                drawHandleSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[1], {\n                    color,\n                }, 1);\n                const isUnitless = data.cachedStats[targetId].isUnitless;\n                if (!isUnitless) {\n                    const canvasPoint1 = canvasCoordinates[0];\n                    const canvasPoint2 = canvasCoordinates[1];\n                    const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n                    const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n                    const isHorizontal = data.cachedStats[targetId].isHorizontal;\n                    let projectedPointCanvas = [0, 0];\n                    if (isHorizontal) {\n                        projectedPointCanvas = [\n                            canvasPoint1[0] + canvasDeltaX,\n                            canvasPoint1[1],\n                        ];\n                    }\n                    else {\n                        projectedPointCanvas = [\n                            canvasPoint1[0],\n                            canvasPoint1[1] + canvasDeltaY,\n                        ];\n                    }\n                    let dataId = `${annotationUID}-line-1`;\n                    let lineUID = '1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], projectedPointCanvas, {\n                        color,\n                        width: 1,\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                    dataId = `${annotationUID}-line-2`;\n                    lineUID = '2';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], projectedPointCanvas, {\n                        color,\n                        width: 1,\n                        lineDash: [1, 1],\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                }\n                else {\n                    const dataId = `${annotationUID}-line-1`;\n                    const lineUID = '1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                        color,\n                        width: 1,\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId, this.configuration);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    toolSelectedCallback(evt, annotation, interactionType, canvasCoords) {\n        return;\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        this.editData = {\n            handleIndex,\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        if (data.handles.points.length !== 2) {\n            return;\n        }\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData } = image;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[1];\n            const imageIndex1 = transformWorldToIndex(imageData, worldPos1);\n            const imageIndex2 = transformWorldToIndex(imageData, worldPos2);\n            const { values: values1, units: units1 } = getCalibratedProbeUnitsAndValue(image, [imageIndex1]);\n            const { values: values2, units: units2 } = getCalibratedProbeUnitsAndValue(image, [imageIndex2]);\n            let xValues, yValues, units, isHorizontal;\n            let isUnitless = false;\n            if (units1[0] !== units2[0] ||\n                units1[1] !== units2[1] ||\n                (units1[0] === 'raw' && units2[0] === 'raw')) {\n                const value = distanceToPoint(worldPos1, worldPos2);\n                xValues = [value, 0];\n                yValues = [value, 0];\n                units = ['px'];\n                isUnitless = true;\n            }\n            else {\n                const canvasPoint1 = enabledElement.viewport.worldToCanvas(worldPos1);\n                const canvasPoint2 = enabledElement.viewport.worldToCanvas(worldPos2);\n                const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n                const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n                isHorizontal = Math.abs(canvasDeltaX) > Math.abs(canvasDeltaY);\n                xValues = [values1[0], values2[0]];\n                yValues = [values1[1], values2[1]];\n                units = [units1[0], units1[1]];\n            }\n            cachedStats[targetId] = {\n                xValues,\n                yValues,\n                isHorizontal,\n                units,\n                isUnitless,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId, configuration) {\n    const cachedStats = data.cachedStats[targetId];\n    const { xValues, yValues, units, isUnitless, isHorizontal } = cachedStats;\n    if (isUnitless) {\n        return [`${csUtils.roundNumber(xValues[0])} px`];\n    }\n    if (configuration.displayBothAxesDistances) {\n        const dist1 = Math.abs(xValues[1] - xValues[0]);\n        const dist2 = Math.abs(yValues[1] - yValues[0]);\n        return [\n            `${csUtils.roundNumber(dist1)} ${units[0]}`,\n            `${csUtils.roundNumber(dist2)} ${units[1]}`,\n        ];\n    }\n    if (isHorizontal) {\n        const dist = Math.abs(xValues[1] - xValues[0]);\n        return [`${csUtils.roundNumber(dist)} ${units[0]}`];\n    }\n    else {\n        const dist = Math.abs(yValues[1] - yValues[0]);\n        return [`${csUtils.roundNumber(dist)} ${units[1]}`];\n    }\n}\nexport default UltrasoundDirectionalTool;\n","import { Events, ChangeTypes } from '../../../enums';\nimport { getEnabledElement, utilities, metaData, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawFan as drawFanSvg, } from '../../../drawingSvg';\nimport { state } from '../../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { angleFromCenter, calculateInnerFanPercentage, clipInterval, intervalFromPoints, mergeIntervals, subtractIntervals, } from '../../../utilities/math/fan/fanUtils';\nimport { calculateFanGeometry } from './utils/fanExtraction';\nconst { transformIndexToWorld } = utilities;\nclass UltrasoundPleuraBLineTool extends AnnotationTool {\n    static { this.toolName = 'UltrasoundPleuraBLineTool'; }\n    static { this.USPleuraBLineAnnotationType = {\n        BLINE: 'bLine',\n        PLEURA: 'pleura',\n    }; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            center: null,\n            innerRadius: null,\n            outerRadius: null,\n            startAngle: null,\n            endAngle: null,\n            bLineColor: 'rgb(60, 255, 60)',\n            pleuraColor: 'rgb(0, 4, 255)',\n            drawDepthGuide: true,\n            depth_ratio: 0.5,\n            depthGuideColor: 'rgb(0, 255, 255)',\n            depthGuideThickness: 4,\n            depthGuideDashLength: 20,\n            depthGuideDashGap: 16,\n            depthGuideOpacity: 0.2,\n            fanOpacity: 0.1,\n            showFanAnnotations: true,\n            updatePercentageCallback: null,\n            actions: {\n                undo: {\n                    method: 'undo',\n                    bindings: [{ key: 'z' }],\n                },\n                redo: {\n                    method: 'redo',\n                    bindings: [{ key: 'y' }],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.pleuraAnnotations = [];\n        this.bLineAnnotations = [];\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const { viewPlaneNormal, viewUp, position: cameraPosition, } = viewport.getCamera();\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                    toolName: this.getToolName(),\n                    referencedImageId,\n                    viewUp,\n                    cameraPosition,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                    },\n                    annotationType: this.getActiveAnnotationType(),\n                    label: '',\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { viewport } = getEnabledElement(element) || {};\n            if (!viewport) {\n                return;\n            }\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                const allPointsInsideShape = points.every((point) => {\n                    const newPoint = [\n                        point[0] + worldPosDelta[0],\n                        point[1] + worldPosDelta[1],\n                        point[2] + worldPosDelta[2],\n                    ];\n                    return this.isInsideFanShape(viewport, newPoint);\n                });\n                if (allPointsInsideShape) {\n                    points.forEach((point) => {\n                        point[0] += worldPosDelta[0];\n                        point[1] += worldPosDelta[1];\n                        point[2] += worldPosDelta[2];\n                    });\n                    annotation.invalidated = true;\n                }\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                if (this.isInsideFanShape(viewport, worldPos)) {\n                    data.handles.points[handleIndex] = [...worldPos];\n                    annotation.invalidated = true;\n                }\n            }\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            if (!this.getFanShapeGeometryParameters(viewport)) {\n                return;\n            }\n            const { imageData } = viewport.getImageData() || {};\n            if (!imageData) {\n                return renderStatus;\n            }\n            if (this.configuration.drawDepthGuide) {\n                this.drawDepthGuide(svgDrawingHelper, viewport);\n            }\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const fanCenter = viewport.worldToCanvas(transformIndexToWorld(imageData, this.configuration.center));\n            const indexToCanvasRatio = this.getIndexToCanvasRatio(viewport);\n            const innerRadius = this.configuration.innerRadius * indexToCanvasRatio;\n            const outerRadius = this.configuration.outerRadius * indexToCanvasRatio;\n            const currentImageId = viewport.getCurrentImageId();\n            const unMergedPleuraIntervals = annotations\n                .filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA &&\n                annotation.metadata.referencedImageId === currentImageId)\n                .map((annotation) => {\n                const canvasCoordinates = annotation.data.handles.points.map((p) => viewport.worldToCanvas(p));\n                const interval = intervalFromPoints(fanCenter, canvasCoordinates);\n                return interval;\n            });\n            const mergedPleuraIntervals = mergeIntervals(unMergedPleuraIntervals);\n            const pleuraIntervalsDisplayed = [];\n            const bLineIntervalsDisplayed = [];\n            const drawAnnotation = (annotation) => {\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    return;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color: this.getColorForLineType(annotation),\n                        fill: this.getColorForLineType(annotation),\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const dataId = `${annotationUID}-line`;\n                const lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color: this.getColorForLineType(annotation),\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n                if (this.configuration.showFanAnnotations) {\n                    const lineInterval = intervalFromPoints(fanCenter, canvasCoordinates);\n                    let fanNumber = 0;\n                    if (annotation.data.annotationType ===\n                        UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {\n                        const uncoveredIntervals = subtractIntervals(bLineIntervalsDisplayed, lineInterval);\n                        uncoveredIntervals.forEach((interval) => {\n                            const clippedIntervals = clipInterval(interval, mergedPleuraIntervals);\n                            clippedIntervals.forEach((clippedInterval) => {\n                                fanNumber++;\n                                const fanIndex = fanNumber;\n                                const fanDataId = `${annotationUID}-fan-${fanIndex}`;\n                                const fanUID = `2-${fanIndex}`;\n                                drawFanSvg(svgDrawingHelper, annotationUID, fanUID, fanCenter, innerRadius, outerRadius, clippedInterval[0], clippedInterval[1], {\n                                    color: 'transparent',\n                                    fill: this.getColorForLineType(annotation),\n                                    fillOpacity: this.configuration.fanOpacity,\n                                    width: lineWidth,\n                                    lineDash,\n                                    shadow,\n                                }, fanDataId, 10);\n                                bLineIntervalsDisplayed.push(clippedInterval);\n                            });\n                        });\n                    }\n                    else if (annotation.data.annotationType ===\n                        UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {\n                        const uncoveredIntervals = subtractIntervals(pleuraIntervalsDisplayed, lineInterval);\n                        uncoveredIntervals.forEach((interval, index) => {\n                            fanNumber++;\n                            const fanIndex = fanNumber;\n                            const fanDataId = `${annotationUID}-fan-${fanIndex}`;\n                            const fanUID = `2-${fanIndex}`;\n                            drawFanSvg(svgDrawingHelper, annotationUID, fanUID, fanCenter, innerRadius, outerRadius, interval[0], interval[1], {\n                                color: 'transparent',\n                                fill: this.getColorForLineType(annotation),\n                                fillOpacity: this.configuration.fanOpacity,\n                                width: lineWidth,\n                                lineDash,\n                                shadow,\n                            }, fanDataId, 5);\n                            pleuraIntervalsDisplayed.push(interval);\n                        });\n                    }\n                }\n            };\n            const pleuraAnnotationsToDraw = annotations.filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA &&\n                annotation.metadata.referencedImageId === currentImageId);\n            pleuraAnnotationsToDraw.forEach((annotation) => {\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                drawAnnotation(annotation);\n            });\n            const bLineAnnotationsToDraw = annotations.filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE &&\n                annotation.metadata.referencedImageId === currentImageId);\n            bLineAnnotationsToDraw.forEach((annotation) => {\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                drawAnnotation(annotation);\n            });\n            renderStatus = true;\n            if (this.configuration.updatePercentageCallback && viewport) {\n                this.configuration.updatePercentageCallback(this.calculateBLinePleuraPercentage(viewport));\n            }\n            return renderStatus;\n        };\n        this.activeAnnotationType =\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE;\n    }\n    static filterAnnotations(element, filterFunction = () => true) {\n        const annotations = getAnnotations(UltrasoundPleuraBLineTool.toolName, element);\n        if (!annotations?.length) {\n            return [];\n        }\n        const filteredAnnotations = annotations.filter((annotation) => {\n            const currentImageId = annotation.metadata.referencedImageId;\n            return filterFunction(currentImageId);\n        });\n        return filteredAnnotations;\n    }\n    static countAnnotations(element, filterFunction = () => true) {\n        const annotations = getAnnotations(UltrasoundPleuraBLineTool.toolName, element);\n        const { viewport } = getEnabledElement(element);\n        const imageIds = viewport.getImageIds();\n        const getImageIdIndex = (imageId) => {\n            const index = imageIds.findIndex((id) => id === imageId);\n            if (index === -1) {\n                return 0;\n            }\n            return index;\n        };\n        if (!annotations?.length) {\n            return;\n        }\n        const annotationMapping = new Map();\n        annotations.forEach((annotation) => {\n            const currentImageId = annotation.metadata.referencedImageId;\n            if (!filterFunction(currentImageId)) {\n                return;\n            }\n            const { annotationType } = annotation.data;\n            let counts;\n            if (annotationMapping.has(currentImageId)) {\n                counts = annotationMapping.get(currentImageId);\n            }\n            else {\n                counts = {\n                    frame: getImageIdIndex(currentImageId),\n                    bLine: 0,\n                    pleura: 0,\n                };\n            }\n            if (annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {\n                counts.pleura++;\n            }\n            else if (annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {\n                counts.bLine++;\n            }\n            annotationMapping.set(currentImageId, counts);\n        });\n        return annotationMapping;\n    }\n    static deleteAnnotations(element, filterFunction = () => false) {\n        const annotations = getAnnotations(UltrasoundPleuraBLineTool.toolName, element);\n        if (!annotations?.length) {\n            return;\n        }\n        annotations.forEach((annotation) => {\n            if (!filterFunction(annotation.metadata.referencedImageId)) {\n                return;\n            }\n            removeAnnotation(annotation.annotationUID);\n        });\n    }\n    setActiveAnnotationType(type) {\n        this.activeAnnotationType = type;\n    }\n    getActiveAnnotationType() {\n        return this.activeAnnotationType;\n    }\n    deleteLastAnnotationType(element, type) {\n        let annotationList;\n        const annotations = getAnnotations(UltrasoundPleuraBLineTool.toolName, element);\n        if (type === UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {\n            annotationList = annotations.filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA);\n        }\n        else if (type === UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {\n            annotationList = annotations.filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE);\n        }\n        if (annotationList?.length > 0) {\n            const annotation = annotationList.pop();\n            removeAnnotation(annotation.annotationUID);\n        }\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(UltrasoundPleuraBLineTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    isInsideFanShape(viewport, point) {\n        if (!this.getFanShapeGeometryParameters(viewport)) {\n            return false;\n        }\n        const { imageData } = viewport.getImageData() || {};\n        if (imageData) {\n            const fanCenter = viewport.worldToCanvas(imageData.indexToWorld(this.configuration.center));\n            const canvasCoordinates = viewport.worldToCanvas(point);\n            const angle = angleFromCenter(fanCenter, canvasCoordinates);\n            return (angle >= this.configuration.startAngle &&\n                angle <= this.configuration.endAngle);\n        }\n    }\n    updateFanGeometryConfiguration(fanGeometry) {\n        if (!fanGeometry) {\n            return;\n        }\n        if (this.isFanShapeGeometryParametersValid(fanGeometry)) {\n            this.configuration.center = [\n                fanGeometry.center[0],\n                fanGeometry.center[1],\n                0,\n            ];\n        }\n        this.configuration.innerRadius = fanGeometry.innerRadius;\n        this.configuration.outerRadius = fanGeometry.outerRadius;\n        this.configuration.startAngle = fanGeometry.startAngle;\n        this.configuration.endAngle = fanGeometry.endAngle;\n    }\n    deriveFanGeometryFromViewport(viewport) {\n        const imageId = viewport.getCurrentImageId();\n        const { fanGeometry } = calculateFanGeometry(imageId) || {};\n        if (fanGeometry) {\n            this.updateFanGeometryConfiguration(fanGeometry);\n        }\n    }\n    isFanShapeGeometryParametersValid(fanGeometry) {\n        if (!fanGeometry) {\n            fanGeometry = this.configuration;\n        }\n        return (fanGeometry?.center &&\n            fanGeometry?.innerRadius > 0 &&\n            fanGeometry?.outerRadius &&\n            fanGeometry?.startAngle > 0 &&\n            fanGeometry?.startAngle < 360 &&\n            fanGeometry?.endAngle > 0 &&\n            fanGeometry?.endAngle < 360);\n    }\n    getFanShapeGeometryParameters(viewport) {\n        if (this.isFanShapeGeometryParametersValid()) {\n            return true;\n        }\n        if (!this.isFanShapeGeometryParametersValid()) {\n            const imageId = viewport.getCurrentImageId();\n            const fanGeometry = metaData.get('ultrasoundFanShapeGeometry', imageId);\n            this.updateFanGeometryConfiguration(fanGeometry);\n        }\n        if (!this.isFanShapeGeometryParametersValid()) {\n            this.deriveFanGeometryFromViewport(viewport);\n        }\n        return this.isFanShapeGeometryParametersValid();\n    }\n    calculateBLinePleuraPercentage(viewport) {\n        if (!this.getFanShapeGeometryParameters(viewport)) {\n            return;\n        }\n        const { imageData } = viewport.getImageData() || {};\n        if (!imageData) {\n            return;\n        }\n        const { element } = viewport;\n        const fanCenter = viewport.worldToCanvas(imageData.indexToWorld(this.configuration.center));\n        const currentImageId = viewport.getCurrentImageId();\n        const annotations = getAnnotations(this.getToolName(), element) || [];\n        const pleuraIntervals = annotations\n            .filter((annotation) => annotation.data.annotationType ===\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA &&\n            annotation.metadata.referencedImageId === currentImageId)\n            .map((annotation) => {\n            const canvasCoordinates = annotation.data.handles.points.map((p) => viewport.worldToCanvas(p));\n            return canvasCoordinates;\n        });\n        const bLineIntervals = annotations\n            .filter((annotation) => annotation.data.annotationType ===\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE &&\n            annotation.metadata.referencedImageId === currentImageId)\n            .map((annotation) => {\n            const canvasCoordinates = annotation.data.handles.points.map((p) => viewport.worldToCanvas(p));\n            return canvasCoordinates;\n        });\n        return calculateInnerFanPercentage(fanCenter, pleuraIntervals, bLineIntervals);\n    }\n    getColorForLineType(annotation) {\n        const { annotationType } = annotation.data;\n        const { bLineColor, pleuraColor } = this.configuration;\n        if (annotationType ===\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {\n            return bLineColor;\n        }\n        if (annotationType ===\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {\n            return pleuraColor;\n        }\n        return bLineColor;\n    }\n    getIndexToCanvasRatio(viewport) {\n        const { imageData } = viewport.getImageData() || {};\n        const v1 = viewport.worldToCanvas(imageData.indexToWorld([1, 0, 0]));\n        const v2 = viewport.worldToCanvas(imageData.indexToWorld([2, 0, 0]));\n        const diffVector = [v2[0] - v1[0], v2[1] - v1[1]];\n        const vectorSize = Math.sqrt(diffVector[0] * diffVector[0] + diffVector[1] * diffVector[1]);\n        return vectorSize;\n    }\n    drawDepthGuide(svgDrawingHelper, viewport) {\n        if (!this.getFanShapeGeometryParameters(viewport)) {\n            return;\n        }\n        const { imageData } = viewport.getImageData() || {};\n        if (!imageData) {\n            return;\n        }\n        const radToDegree = (rad) => (rad * 180) / Math.PI;\n        const degreeToRad = (degree) => (degree * Math.PI) / 180;\n        const indexToCanvas = (point) => {\n            return viewport.worldToCanvas(transformIndexToWorld(imageData, point));\n        };\n        const depth_radius = this.configuration.innerRadius +\n            this.configuration.depth_ratio *\n                (this.configuration.outerRadius - this.configuration.innerRadius);\n        const theta_start = this.configuration.startAngle;\n        const theta_end = this.configuration.endAngle;\n        const theta_range = theta_end - theta_start;\n        const arc_length = degreeToRad(theta_range) * depth_radius;\n        let num_dashes = Math.round(arc_length /\n            (this.configuration.depthGuideDashLength +\n                this.configuration.depthGuideDashGap));\n        if (num_dashes <= 0) {\n            num_dashes = Math.max(15, Math.round(theta_range / 5));\n        }\n        const theta_step = theta_range / num_dashes;\n        for (let i = 0; i < num_dashes; i++) {\n            const theta1 = degreeToRad(theta_start + i * theta_step);\n            const theta2 = degreeToRad(theta_start +\n                i * theta_step +\n                radToDegree(this.configuration.depthGuideDashLength) / depth_radius);\n            const start_point = [\n                this.configuration.center[0] + depth_radius * Math.cos(theta1),\n                this.configuration.center[1] + depth_radius * Math.sin(theta1),\n                0,\n            ];\n            const end_point = [\n                this.configuration.center[0] + depth_radius * Math.cos(theta2),\n                this.configuration.center[1] + depth_radius * Math.sin(theta2),\n                0,\n            ];\n            drawLineSvg(svgDrawingHelper, viewport.id, `depthGuide-${i}`, indexToCanvas(start_point), indexToCanvas(end_point), {\n                color: this.configuration.depthGuideColor,\n                lineWidth: this.configuration.depthGuideThickness,\n                strokeOpacity: this.configuration.depthGuideOpacity,\n            });\n        }\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (utilities.indexWithinDimensions(index1, dimensions) &&\n            utilities.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    return [''];\n}\nexport default UltrasoundPleuraBLineTool;\n","export function pickPoints(hull, slack = 7) {\n    if (!hull.length) {\n        throw new Error('Convex hull is empty');\n    }\n    const n = hull.length;\n    const next = (i) => (i + 1) % n;\n    const walk = (from, to) => {\n        const idx = [];\n        for (let i = from;; i = next(i)) {\n            idx.push(i);\n            if (i === to) {\n                break;\n            }\n        }\n        return idx;\n    };\n    let i2 = 0, i3 = 0;\n    for (let i = 1; i < n; i++) {\n        if (hull[i][0] < hull[i2][0]) {\n            i2 = i;\n        }\n        if (hull[i][0] > hull[i3][0]) {\n            i3 = i;\n        }\n    }\n    const P2 = hull[i2];\n    const P3 = hull[i3];\n    const pathA = walk(i2, i3);\n    const pathB = walk(i3, i2);\n    const globalYmin = Math.min(...hull.map((p) => p[1]));\n    const upperPath = pathA.some((i) => hull[i][1] === globalYmin)\n        ? pathA\n        : pathB;\n    const topY = Math.min(...upperPath.map((i) => hull[i][1]));\n    let arcPts = upperPath\n        .map((i) => hull[i])\n        .filter((p) => Math.abs(p[1] - topY) <= slack);\n    if (arcPts.length < 2) {\n        arcPts = upperPath\n            .map((i) => hull[i])\n            .sort((a, b) => a[1] - b[1])\n            .slice(0, 2);\n    }\n    const P1 = arcPts.reduce((best, p) => (p[0] < best[0] ? p : best), arcPts[0]);\n    const P4 = arcPts.reduce((best, p) => (p[0] > best[0] ? p : best), arcPts[0]);\n    return { P1, P2, P3, P4 };\n}\nexport function computeEdgeBuffer(buffer, width, height) {\n    const total = width * height;\n    const channels = buffer.length / total;\n    if (![1, 3, 4].includes(channels)) {\n        throw new Error('Buffer must be 1,3 or 4 channels per pixel');\n    }\n    const gray = new Float32Array(total);\n    for (let i = 0; i < total; i++) {\n        if (channels === 1) {\n            gray[i] = buffer[i];\n        }\n        else {\n            const base = i * channels;\n            const r = buffer[base];\n            const g = buffer[base + 1];\n            const b = buffer[base + 2];\n            gray[i] = 0.299 * r + 0.587 * g + 0.114 * b;\n        }\n    }\n    const edgeBuf = new Float32Array(total);\n    for (let y = 1; y < height - 1; y++) {\n        for (let x = 1; x < width - 1; x++) {\n            const idx = y * width + x;\n            const i00 = idx - width - 1;\n            const i01 = idx - width;\n            const i02 = idx - width + 1;\n            const i10 = idx - 1;\n            const i11 = idx;\n            const i12 = idx + 1;\n            const i20 = idx + width - 1;\n            const i21 = idx + width;\n            const i22 = idx + width + 1;\n            const gx = -gray[i00] +\n                gray[i02] +\n                -2 * gray[i10] +\n                2 * gray[i12] +\n                -gray[i20] +\n                gray[i22];\n            const gy = gray[i00] +\n                2 * gray[i01] +\n                gray[i02] -\n                gray[i20] -\n                2 * gray[i21] -\n                gray[i22];\n            edgeBuf[idx] = Math.hypot(gx, gy);\n        }\n    }\n    return edgeBuf;\n}\nexport function refineCornersDirectional(edgeBuf, width, height, rough, contour, opts = {}) {\n    const { maxDist = 15, slack = 2 } = opts;\n    const directions = {\n        P1: { dx: -1, dy: -1 },\n        P2: { dx: -1, dy: +1 },\n        P3: { dx: +1, dy: +1 },\n        P4: { dx: +1, dy: -1 },\n    };\n    function snapQuadrant(pt, { dx, dy }, threshold = 5) {\n        const xmin = dx < 0 ? pt[0] - maxDist : pt[0] - slack;\n        const xmax = dx < 0 ? pt[0] + slack : pt[0] + maxDist;\n        const ymin = dy < 0 ? pt[1] - maxDist : pt[1] - slack;\n        const ymax = dy < 0 ? pt[1] + slack : pt[1] + maxDist;\n        let best = pt;\n        for (const [cx, cy] of contour) {\n            if (cx < xmin || cx > xmax || cy < ymin || cy > ymax) {\n                continue;\n            }\n            const xi = Math.round(cx);\n            const yi = Math.round(cy);\n            if (xi < 0 || xi >= width || yi < 0 || yi >= height) {\n                continue;\n            }\n            const xAlign = (xi - best[0]) * dx;\n            const yAlign = (yi - best[0]) * dy;\n            const v = edgeBuf[yi * width + xi];\n            if (v > threshold && (xAlign > 0 || yAlign > 0)) {\n                best = [cx, cy];\n            }\n        }\n        return best;\n    }\n    return {\n        P1: snapQuadrant(rough.P1, directions.P1),\n        P2: snapQuadrant(rough.P2, directions.P2),\n        P3: snapQuadrant(rough.P3, directions.P3),\n        P4: snapQuadrant(rough.P4, directions.P4),\n    };\n}\nexport function calculateFanShapeCorners(imageBuffer, width, height, hull, roughContour) {\n    const rough = pickPoints(hull);\n    const refined = refineCornersDirectional(imageBuffer, width, height, rough, roughContour, {\n        maxDist: 20,\n        step: 0.5,\n    });\n    return refined;\n}\n","import { intersectLine } from '../../../../utilities/math/line';\nfunction angleRad(center, p) {\n    return Math.atan2(p[1] - center[1], p[0] - center[0]);\n}\nexport function deriveFanGeometry(params) {\n    const { P1, P2, P3, P4 } = params;\n    const centerResult = intersectLine(P1, P2, P4, P3, true);\n    if (!centerResult) {\n        throw new Error('Fan edges appear parallel  no apex found');\n    }\n    const center = centerResult;\n    let startAngle = angleRad(center, P1) * (180 / Math.PI);\n    let endAngle = angleRad(center, P4) * (180 / Math.PI);\n    if (endAngle <= startAngle) {\n        const tempAngle = startAngle;\n        startAngle = endAngle;\n        endAngle = tempAngle;\n    }\n    const d1 = Math.hypot(P1[0] - center[0], P1[1] - center[1]);\n    const d4 = Math.hypot(P4[0] - center[0], P4[1] - center[1]);\n    const d2 = Math.hypot(P2[0] - center[0], P2[1] - center[1]);\n    const d3 = Math.hypot(P3[0] - center[0], P3[1] - center[1]);\n    const innerRadius = Math.min(d1, d4);\n    const outerRadius = Math.max(d2, d3);\n    return {\n        center,\n        startAngle,\n        endAngle,\n        innerRadius,\n        outerRadius,\n    };\n}\n","import { cache } from '@cornerstonejs/core';\nimport { segmentLargestUSOutlineFromBuffer } from './segmentLargestUSOutlineFromBuffer';\nimport { generateConvexHullFromContour } from './generateConvexHullFromContour';\nimport { calculateFanShapeCorners } from './calculateFanShapeCorners';\nimport { deriveFanGeometry } from './deriveFanGeometry';\nexport function exportContourJpeg(pixelData, width, height, contour, opts = {}) {\n    const { strokeStyle = '#f00', lineWidth = 2, quality = 0.92 } = opts;\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    const totalPixels = width * height;\n    const channels = pixelData.length / totalPixels;\n    const imgData = ctx.createImageData(width, height);\n    const out = imgData.data;\n    for (let i = 0; i < totalPixels; i++) {\n        const baseIn = i * channels;\n        const baseOut = i * 4;\n        if (channels === 1) {\n            const v = pixelData[baseIn];\n            out[baseOut] = v;\n            out[baseOut + 1] = v;\n            out[baseOut + 2] = v;\n            out[baseOut + 3] = 255;\n        }\n        else {\n            out[baseOut] = pixelData[baseIn];\n            out[baseOut + 1] = pixelData[baseIn + 1];\n            out[baseOut + 2] = pixelData[baseIn + 2];\n            out[baseOut + 3] = channels === 4 ? pixelData[baseIn + 3] : 255;\n        }\n    }\n    ctx.putImageData(imgData, 0, 0);\n    if (contour.length > 0) {\n        ctx.strokeStyle = strokeStyle;\n        ctx.lineWidth = lineWidth;\n        ctx.beginPath();\n        ctx.moveTo(contour[0][0] + 0.5, contour[0][1] + 0.5);\n        for (let i = 1; i < contour.length; i++) {\n            ctx.lineTo(contour[i][0] + 0.5, contour[i][1] + 0.5);\n        }\n        ctx.closePath();\n        ctx.stroke();\n    }\n    return canvas.toDataURL('image/jpeg', quality);\n}\nexport function getPixelData(imageId) {\n    const image = cache.getImage(imageId);\n    if (!image) {\n        return;\n    }\n    const width = image.width;\n    const height = image.height;\n    const pixelData = image.getPixelData();\n    return {\n        pixelData,\n        width,\n        height,\n    };\n}\nexport default function saveBinaryData(url, filename) {\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.style.display = 'none';\n    a.click();\n    a.remove();\n}\nfunction exportFanJpeg(pixelData, width, height, fan, opts = {}) {\n    const { center, startAngle: startAngleInDegrees, endAngle: endAngleInDegrees, innerRadius, outerRadius, } = fan;\n    const { strokeStyle = '#0ff', lineWidth = 2, quality = 0.92 } = opts;\n    const startAngle = (startAngleInDegrees * Math.PI) / 180;\n    const endAngle = (endAngleInDegrees * Math.PI) / 180;\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    const total = width * height;\n    const channels = pixelData.length / total;\n    const imgData = ctx.createImageData(width, height);\n    const out = imgData.data;\n    for (let i = 0; i < total; i++) {\n        const baseOut = i * 4;\n        if (channels === 1) {\n            const v = pixelData[i];\n            out[baseOut] = v;\n            out[baseOut + 1] = v;\n            out[baseOut + 2] = v;\n            out[baseOut + 3] = 255;\n        }\n        else {\n            const baseIn = i * channels;\n            out[baseOut] = pixelData[baseIn];\n            out[baseOut + 1] = pixelData[baseIn + 1];\n            out[baseOut + 2] = pixelData[baseIn + 2];\n            out[baseOut + 3] = channels === 4 ? pixelData[baseIn + 3] : 255;\n        }\n    }\n    ctx.putImageData(imgData, 0, 0);\n    ctx.beginPath();\n    for (let a = startAngle; a <= endAngle; a += 0.01) {\n        const x = center[0] + innerRadius * Math.cos(a);\n        const y = center[1] + innerRadius * Math.sin(a);\n        if (a === startAngle) {\n            ctx.moveTo(x, y);\n        }\n        else {\n            ctx.lineTo(x, y);\n        }\n    }\n    for (let a = endAngle; a >= startAngle; a -= 0.01) {\n        const x = center[0] + outerRadius * Math.cos(a);\n        const y = center[1] + outerRadius * Math.sin(a);\n        ctx.lineTo(x, y);\n    }\n    ctx.closePath();\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = lineWidth;\n    ctx.stroke();\n    return canvas.toDataURL('image/jpeg', quality);\n}\nexport function downloadFanJpeg(imageId, contourType = 5) {\n    const { contour, simplified, hull, refined, fanGeometry } = calculateFanGeometry(imageId);\n    const { pixelData, width, height } = getPixelData(imageId) || {};\n    if (!pixelData) {\n        return;\n    }\n    let jpegDataUrl;\n    if (contourType === 1) {\n        jpegDataUrl = exportContourJpeg(pixelData, width, height, contour);\n    }\n    else if (contourType === 2) {\n        jpegDataUrl = exportContourJpeg(pixelData, width, height, simplified);\n    }\n    else if (contourType === 3) {\n        jpegDataUrl = exportContourJpeg(pixelData, width, height, hull);\n    }\n    else if (contourType === 4) {\n        jpegDataUrl = exportContourJpeg(pixelData, width, height, [\n            refined.P1,\n            refined.P2,\n            refined.P3,\n            refined.P4,\n        ]);\n    }\n    else {\n        jpegDataUrl = exportFanJpeg(pixelData, width, height, fanGeometry, {\n            strokeStyle: '#f00',\n            lineWidth: 3,\n            quality: 0.95,\n        });\n    }\n    saveBinaryData(jpegDataUrl, 'contour.jpg');\n}\nexport function calculateFanGeometry(imageId) {\n    const { pixelData, width, height } = getPixelData(imageId) || {};\n    if (!pixelData) {\n        return;\n    }\n    const contour = segmentLargestUSOutlineFromBuffer(pixelData, width, height);\n    const { simplified, hull } = generateConvexHullFromContour(contour);\n    const refined = calculateFanShapeCorners(pixelData, width, height, hull, simplified);\n    const fanGeometry = deriveFanGeometry({\n        P1: refined.P1,\n        P2: refined.P2,\n        P3: refined.P3,\n        P4: refined.P4,\n    });\n    return { contour, simplified, hull, refined, fanGeometry };\n}\n","import * as math from '../../../../utilities/math';\nexport function generateConvexHullFromContour(contour) {\n    const simplified = math.polyline.decimate(contour, 2);\n    const hull = math.polyline.convexHull(simplified);\n    return { simplified, hull };\n}\n","import { floodFill } from '../../../../utilities/segmentation';\nexport function segmentLargestUSOutlineFromBuffer(buffer, width, height) {\n    const totalPixels = width * height;\n    const channelCount = buffer.length / totalPixels;\n    if (![1, 3, 4].includes(channelCount)) {\n        throw new Error('Buffer must be 1, 3, or 4 channels per pixel');\n    }\n    const mask = Array.from({ length: height }, () => new Array(width).fill(false));\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const pixelIndex = y * width + x;\n            const base = pixelIndex * channelCount;\n            let isForeground = false;\n            for (let c = 0; c < Math.min(3, channelCount); c++) {\n                if (buffer[base + c] > 0) {\n                    isForeground = true;\n                    break;\n                }\n            }\n            mask[y][x] = isForeground;\n        }\n    }\n    const labels = Array.from({ length: height }, () => new Array(width).fill(0));\n    let currentLabel = 0;\n    const regionSizes = {};\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (mask[y][x] && labels[y][x] === 0) {\n                currentLabel++;\n                const getter = (px, py) => {\n                    if (px < 0 || px >= width || py < 0 || py >= height) {\n                        return false;\n                    }\n                    return mask[py][px] && labels[py][px] === 0;\n                };\n                let pixelCount = 0;\n                const options = {\n                    onFlood: (px, py) => {\n                        labels[py][px] = currentLabel;\n                        pixelCount++;\n                    },\n                    diagonals: false,\n                };\n                floodFill(getter, [x, y], options);\n                regionSizes[currentLabel] = pixelCount;\n            }\n        }\n    }\n    if (currentLabel === 0) {\n        return [];\n    }\n    const largestLabel = Object.keys(regionSizes).reduce((a, b) => regionSizes[a] > regionSizes[b] ? a : b);\n    function isBorder(x, y) {\n        if (labels[y][x] !== +largestLabel) {\n            return false;\n        }\n        for (const [dx, dy] of [\n            [1, 0],\n            [-1, 0],\n            [0, 1],\n            [0, -1],\n        ]) {\n            const nx = x + dx, ny = y + dy;\n            if (nx < 0 ||\n                nx >= width ||\n                ny < 0 ||\n                ny >= height ||\n                labels[ny][nx] !== +largestLabel) {\n                return true;\n            }\n        }\n        return false;\n    }\n    let start = null;\n    outer: for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (isBorder(x, y)) {\n                start = [x, y];\n                break outer;\n            }\n        }\n    }\n    if (!start) {\n        return [];\n    }\n    const dirs = [\n        [1, 0],\n        [1, 1],\n        [0, 1],\n        [-1, 1],\n        [-1, 0],\n        [-1, -1],\n        [0, -1],\n        [1, -1],\n    ];\n    const contour = [];\n    let current = start;\n    let prev = [start[0] - 1, start[1]];\n    do {\n        contour.push([current[0], current[1]]);\n        const dx0 = prev[0] - current[0], dy0 = prev[1] - current[1];\n        let startDir = dirs.findIndex((d) => d[0] === dx0 && d[1] === dy0);\n        if (startDir < 0) {\n            startDir = 0;\n        }\n        let nextPt = null;\n        for (let k = 1; k <= 8; k++) {\n            const [dx, dy] = dirs[(startDir + k) % 8];\n            const nx = current[0] + dx, ny = current[1] + dy;\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height && isBorder(nx, ny)) {\n                nextPt = [nx, ny];\n                const [bdx, bdy] = dirs[(startDir + k - 1 + 8) % 8];\n                prev = [current[0] + bdx, current[1] + bdy];\n                break;\n            }\n        }\n        if (!nextPt) {\n            break;\n        }\n        current = nextPt;\n    } while (current[0] !== start[0] || current[1] !== start[1]);\n    return contour;\n}\n","import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement, triggerEvent, eventTarget, utilities as csUtils, cache, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { drawHandles as drawHandlesSvg, drawRedactionRect as drawRedactionRectSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nclass VideoRedactionTool extends AnnotationTool {\n    static { this.toolName = 'VideoRedaction'; }\n    constructor(toolConfiguration = {}) {\n        super(toolConfiguration, {\n            supportedInteractionTypes: ['Mouse', 'Touch'],\n            configuration: { shadow: true, preventHandleOutsideImage: false },\n        });\n        this.addNewAnnotation = (evt) => {\n            const eventData = evt.detail;\n            const { currentPoints, element } = eventData;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                    },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n                handleIndex: 3,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            return annotation;\n        };\n        this.getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            for (let i = 0; i < points.length; i++) {\n                const point = points[i];\n                const toolDataCanvasCoordinate = viewport.worldToCanvas(point);\n                const near = vec2.distance(canvasCoords, toolDataCanvasCoordinate) < proximity;\n                if (near === true) {\n                    data.handles.activeHandleIndex = i;\n                    return point;\n                }\n            }\n            data.handles.activeHandleIndex = null;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasPoint1 = viewport.worldToCanvas(points[0]);\n            const canvasPoint2 = viewport.worldToCanvas(points[3]);\n            const rect = this._getRectangleImageCoordinates([\n                canvasPoint1,\n                canvasPoint2,\n            ]);\n            const point = [canvasCoords[0], canvasCoords[1]];\n            const { left, top, width, height } = rect;\n            const distanceToPoint = rectangle.distanceToPoint([left, top, width, height], point);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType = 'mouse') => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { data } = annotation;\n            data.active = true;\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle, interactionType = 'mouse') => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { data } = annotation;\n            data.active = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n                handleIndex,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            data.active = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { annotation, viewportUIDsToRender, handleIndex, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (handleIndex === undefined) {\n                const { deltaPoints } = eventData;\n                const worldPosDelta = deltaPoints.world;\n                const { points } = data.handles;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                data.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventData;\n                const enabledElement = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n                const worldPos = currentPoints.world;\n                const { points } = data.handles;\n                points[handleIndex] = [...worldPos];\n                let bottomLeftCanvas;\n                let bottomRightCanvas;\n                let topLeftCanvas;\n                let topRightCanvas;\n                let bottomLeftWorld;\n                let bottomRightWorld;\n                let topLeftWorld;\n                let topRightWorld;\n                switch (handleIndex) {\n                    case 0:\n                    case 3:\n                        bottomLeftCanvas = worldToCanvas(points[0]);\n                        topRightCanvas = worldToCanvas(points[3]);\n                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                        topLeftWorld = canvasToWorld(topLeftCanvas);\n                        points[1] = bottomRightWorld;\n                        points[2] = topLeftWorld;\n                        break;\n                    case 1:\n                    case 2:\n                        bottomRightCanvas = worldToCanvas(points[1]);\n                        topLeftCanvas = worldToCanvas(points[2]);\n                        bottomLeftCanvas = [\n                            topLeftCanvas[0],\n                            bottomRightCanvas[1],\n                        ];\n                        topRightCanvas = [\n                            bottomRightCanvas[0],\n                            topLeftCanvas[1],\n                        ];\n                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                        topRightWorld = canvasToWorld(topRightCanvas);\n                        points[0] = bottomLeftWorld;\n                        points[3] = topRightWorld;\n                        break;\n                }\n                data.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID } = annotation;\n                const data = annotation.data;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return;\n                }\n                let activeHandleCanvasCoords;\n                if (!this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const rectangleUID = '0';\n                drawRedactionRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color: 'black',\n                    lineDash,\n                    lineWidth,\n                });\n            }\n        };\n        this._getRectangleImageCoordinates = (points) => {\n            const [point0, point1] = points;\n            return {\n                left: Math.min(point0[0], point1[0]),\n                top: Math.min(point0[1], point1[1]),\n                width: Math.abs(point0[0] - point1[0]),\n                height: Math.abs(point0[1] - point1[1]),\n            };\n        };\n        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetUIDs = Object.keys(cachedStats);\n            for (let i = 0; i < targetUIDs.length; i++) {\n                const targetUID = targetUIDs[i];\n                const { imageVolume } = this._getImageVolumeFromTargetUID(targetUID, renderingEngine);\n                const { dimensions, scalarData, vtkImageData: imageData, metadata, } = imageVolume;\n                const worldPos1Index = vec3.fromValues(0, 0, 0);\n                const worldPos2Index = vec3.fromValues(0, 0, 0);\n                imageData.worldToIndexVec3(worldPos1, worldPos1Index);\n                worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n                worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n                worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n                imageData.worldToIndexVec3(worldPos2, worldPos2Index);\n                worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n                worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n                worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n                if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                    this.isHandleOutsideImage = false;\n                    const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                    const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                    const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                    const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                    const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                    const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const area = worldWidth * worldHeight;\n                    let count = 0;\n                    let mean = 0;\n                    let stdDev = 0;\n                    const yMultiple = dimensions[0];\n                    const zMultiple = dimensions[0] * dimensions[1];\n                    for (let k = kMin; k <= kMax; k++) {\n                        for (let j = jMin; j <= jMax; j++) {\n                            for (let i = iMin; i <= iMax; i++) {\n                                const value = scalarData[k * zMultiple + j * yMultiple + i];\n                                count++;\n                                mean += value;\n                            }\n                        }\n                    }\n                    mean /= count;\n                    for (let k = kMin; k <= kMax; k++) {\n                        for (let j = jMin; j <= jMax; j++) {\n                            for (let i = iMin; i <= iMax; i++) {\n                                const value = scalarData[k * zMultiple + j * yMultiple + i];\n                                const valueMinusMean = value - mean;\n                                stdDev += valueMinusMean * valueMinusMean;\n                            }\n                        }\n                    }\n                    stdDev /= count;\n                    stdDev = Math.sqrt(stdDev);\n                    cachedStats[targetUID] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean,\n                        stdDev,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetUID] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                const eventType = Events.ANNOTATION_MODIFIED;\n                const eventDetail = {\n                    annotation,\n                    viewportUID,\n                    renderingEngineUID,\n                    sceneUID: sceneUID,\n                    changeType: ChangeTypes.StatsUpdated,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._getTargetVolumeUID = (scene) => {\n            if (this.configuration.volumeUID) {\n                return this.configuration.volumeUID;\n            }\n            const volumeActors = scene.getVolumeActors();\n            if (!volumeActors && !volumeActors.length) {\n                return;\n            }\n            return volumeActors[0].uid;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    cancel(element) {\n        if (!this.isDrawing) {\n            return;\n        }\n        this.isDrawing = false;\n        this._deactivateDraw(element);\n        this._deactivateModify(element);\n        resetElementCursor(element);\n        const { annotation, viewportUIDsToRender } = this.editData;\n        const { data } = annotation;\n        data.active = false;\n        data.handles.activeHandleIndex = null;\n        triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        this.editData = null;\n        return annotation.annotationUID;\n    }\n    _getImageVolumeFromTargetUID(targetUID, renderingEngine) {\n        let imageVolume, viewport;\n        if (targetUID.startsWith('stackTarget')) {\n            const coloneIndex = targetUID.indexOf(':');\n            const viewportUID = targetUID.substring(coloneIndex + 1);\n            const viewport = renderingEngine.getViewport(viewportUID);\n            imageVolume = viewport.getImageData();\n        }\n        else {\n            imageVolume = cache.getVolume(targetUID);\n        }\n        return { imageVolume, viewport };\n    }\n    _getTargetStackUID(viewport) {\n        return `stackTarget:${viewport.uid}`;\n    }\n}\nexport default VideoRedactionTool;\n","import { vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, cache, getRenderingEngine, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport { drawPolyline as drawPolylineSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { Events } from '../../enums';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { growCut } from '../../utilities/segmentation';\nimport GrowCutBaseTool from '../base/GrowCutBaseTool';\nconst NEGATIVE_PIXEL_RANGE = [-Infinity, -995];\nconst POSITIVE_PIXEL_RANGE = [0, 1900];\nconst ISLAND_PIXEL_RANGE = [1000, 1900];\nconst { transformWorldToIndex, transformIndexToWorld } = csUtils;\nclass WholeBodySegmentTool extends GrowCutBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            isPartialVolume: true,\n            positivePixelRange: POSITIVE_PIXEL_RANGE,\n            negativePixelRange: NEGATIVE_PIXEL_RANGE,\n            islandRemoval: {\n                enabled: true,\n                islandPixelRange: ISLAND_PIXEL_RANGE,\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const { world: currentWorldPoint } = currentPoints;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const linePoints = this._getHorizontalLineWorldPoints(enabledElement, currentWorldPoint);\n            this.growCutData.horizontalLines[1] = linePoints;\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._endCallback = async (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            await this.runGrowCut();\n            this._deactivateDraw(element);\n            this.growCutData = null;\n            resetElementCursor(element);\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    async preMouseDownCallback(evt) {\n        const eventData = evt.detail;\n        const { element, currentPoints } = eventData;\n        const { world: worldPoint } = currentPoints;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        const linePoints = this._getHorizontalLineWorldPoints(enabledElement, worldPoint);\n        await super.preMouseDownCallback(evt);\n        this.growCutData.horizontalLines = [linePoints, linePoints];\n        this._activateDraw(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        return true;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this.growCutData) {\n            return;\n        }\n        const { segmentation: segmentationData, horizontalLines } = this.growCutData;\n        if (horizontalLines.length !== 2) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const { segmentationId, segmentIndex } = segmentationData;\n        const [line1, line2] = horizontalLines;\n        const [worldLine1P1, worldLine1P2] = line1;\n        const [worldLine2P1, worldLine2P2] = line2;\n        const canvasPoints = [\n            worldLine1P1,\n            worldLine1P2,\n            worldLine2P2,\n            worldLine2P1,\n        ].map((worldPoint) => viewport.worldToCanvas(worldPoint));\n        const annotationUID = 'growCutRect';\n        const squareGroupUID = '0';\n        const { color, fillColor, lineWidth, fillOpacity, lineDash } = this.getSegmentStyle({\n            segmentationId,\n            segmentIndex,\n            viewportId: viewport.id,\n        });\n        drawPolylineSvg(svgDrawingHelper, annotationUID, squareGroupUID, canvasPoints, {\n            color,\n            fillColor,\n            fillOpacity,\n            lineWidth,\n            lineDash,\n            closePath: true,\n        });\n    }\n    async getGrowCutLabelmap(growCutData) {\n        const { segmentation: { segmentIndex, referencedVolumeId }, renderingEngineId, viewportId, horizontalLines, } = growCutData;\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n        const viewport = renderingEngine.getViewport(viewportId);\n        const [line1, line2] = horizontalLines;\n        const worldSquarePoints = [line1[0], line1[1], line2[1], line2[0]];\n        const referencedVolume = cache.getVolume(referencedVolumeId);\n        const { topLeft: worldTopLeft, bottomRight: worldBottomRight } = this._getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints);\n        const ijkTopLeft = transformWorldToIndex(referencedVolume.imageData, worldTopLeft);\n        const ijkBottomRight = transformWorldToIndex(referencedVolume.imageData, worldBottomRight);\n        const boundingBoxInfo = {\n            boundingBox: {\n                ijkTopLeft,\n                ijkBottomRight,\n            },\n        };\n        const config = this.configuration;\n        const options = {\n            positiveSeedValue: segmentIndex,\n            negativeSeedValue: 255,\n            negativePixelRange: config.negativePixelRange,\n            positivePixelRange: config.positivePixelRange,\n        };\n        return growCut.runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options);\n    }\n    getRemoveIslandData() {\n        const { segmentation: { segmentIndex, referencedVolumeId, labelmapVolumeId }, } = this.growCutData;\n        const referencedVolume = cache.getVolume(referencedVolumeId);\n        const labelmapVolume = cache.getVolume(labelmapVolumeId);\n        const referencedVolumeData = referencedVolume.voxelManager.getCompleteScalarDataArray();\n        const labelmapData = labelmapVolume.voxelManager.getCompleteScalarDataArray();\n        const { islandPixelRange } = this.configuration.islandRemoval;\n        const islandPointIndexes = [];\n        for (let i = 0, len = labelmapData.length; i < len; i++) {\n            if (labelmapData[i] !== segmentIndex) {\n                continue;\n            }\n            const pixelValue = referencedVolumeData[i];\n            if (pixelValue >= islandPixelRange[0] &&\n                pixelValue <= islandPixelRange[1]) {\n                islandPointIndexes.push(i);\n            }\n        }\n        return {\n            islandPointIndexes,\n        };\n    }\n    _activateDraw(element) {\n        element.addEventListener(Events.MOUSE_UP, this._endCallback);\n        element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n        element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    }\n    _projectWorldPointAcrossSlices(viewport, worldEdgePoint, vecDirection) {\n        const volume = this._getViewportVolume(viewport);\n        const { dimensions } = volume;\n        const ijkPoint = transformWorldToIndex(volume.imageData, worldEdgePoint);\n        const axis = vecDirection.findIndex((n) => csUtils.isEqual(Math.abs(n), 1));\n        if (axis === -1) {\n            throw new Error('Non-orthogonal direction vector');\n        }\n        const ijkLineP1 = [...ijkPoint];\n        const ijkLineP2 = [...ijkPoint];\n        ijkLineP1[axis] = 0;\n        ijkLineP2[axis] = dimensions[axis] - 1;\n        return [ijkLineP1, ijkLineP2];\n    }\n    _getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldEdgePoint) {\n        const { viewPlaneNormal } = viewport.getCamera();\n        return this._projectWorldPointAcrossSlices(viewport, worldEdgePoint, viewPlaneNormal);\n    }\n    _getWorldCuboidCornerPoints(viewport, worldSquarePoints) {\n        const cuboidPoints = [];\n        const volume = this._getViewportVolume(viewport);\n        worldSquarePoints.forEach((worldSquarePoint) => {\n            const ijkEdgePoints = this._getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldSquarePoint);\n            const worldEdgePoints = ijkEdgePoints.map((ijkPoint) => transformIndexToWorld(volume.imageData, ijkPoint));\n            cuboidPoints.push(...worldEdgePoints);\n        });\n        return cuboidPoints;\n    }\n    _getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints) {\n        const worldCuboidPoints = this._getWorldCuboidCornerPoints(viewport, worldSquarePoints);\n        const topLeft = [...worldCuboidPoints[0]];\n        const bottomRight = [...worldCuboidPoints[0]];\n        worldCuboidPoints.forEach((worldPoint) => {\n            vec3.min(topLeft, topLeft, worldPoint);\n            vec3.max(bottomRight, bottomRight, worldPoint);\n        });\n        return { topLeft, bottomRight };\n    }\n    _getViewportVolume(viewport) {\n        if (!(viewport instanceof BaseVolumeViewport)) {\n            throw new Error('Viewport is not a BaseVolumeViewport');\n        }\n        const volumeId = viewport.getAllVolumeIds()[0];\n        return cache.getVolume(volumeId);\n    }\n    _getHorizontalLineIJKPoints(enabledElement, worldPoint) {\n        const { viewport } = enabledElement;\n        const volume = this._getViewportVolume(viewport);\n        const { dimensions } = volume;\n        const ijkPoint = transformWorldToIndex(volume.imageData, worldPoint);\n        const { viewUp, viewPlaneNormal } = viewport.getCamera();\n        const vecRow = vec3.cross(vec3.create(), viewUp, viewPlaneNormal);\n        const axis = vecRow.findIndex((n) => csUtils.isEqual(Math.abs(n), 1));\n        const ijkLineP1 = [...ijkPoint];\n        const ijkLineP2 = [...ijkPoint];\n        ijkLineP1[axis] = 0;\n        ijkLineP2[axis] = dimensions[axis] - 1;\n        return [ijkLineP1, ijkLineP2];\n    }\n    _getHorizontalLineWorldPoints(enabledElement, worldPoint) {\n        const { viewport } = enabledElement;\n        const volume = this._getViewportVolume(viewport);\n        const [ijkPoint1, ijkPoint2] = this._getHorizontalLineIJKPoints(enabledElement, worldPoint);\n        const worldPoint1 = transformIndexToWorld(volume.imageData, ijkPoint1);\n        const worldPoint2 = transformIndexToWorld(volume.imageData, ijkPoint2);\n        return [worldPoint1, worldPoint2];\n    }\n}\nWholeBodySegmentTool.toolName = 'WholeBodySegment';\nexport default WholeBodySegmentTool;\n","import { mat4 } from 'gl-matrix';\nimport { CubicSpline } from './CubicSpline';\nconst TRANSFORM_MATRIX = mat4.multiplyScalar(mat4.create(), mat4.fromValues(1, 4, 1, 0, -3, 0, 3, 0, 3, -6, 3, 0, -1, 3, -3, 1), 1 / 6);\nclass BSpline extends CubicSpline {\n    getTransformMatrix() {\n        return TRANSFORM_MATRIX;\n    }\n}\nexport { BSpline as default, BSpline };\n","import { CubicSpline } from './CubicSpline';\nclass CardinalSpline extends CubicSpline {\n    constructor(props) {\n        super(props);\n        this._scale = props?.scale ?? 0.5;\n        this._fixedScale = props?.fixedScale ?? false;\n    }\n    get scale() {\n        return this._scale;\n    }\n    set scale(scale) {\n        if (this._fixedScale || this._scale === scale) {\n            return;\n        }\n        this._scale = scale;\n        this.invalidated = true;\n    }\n    get fixedScale() {\n        return this._fixedScale;\n    }\n    getTransformMatrix() {\n        const { scale: s } = this;\n        const s2 = 2 * s;\n        return [\n            0, 1, 0, 0,\n            -s, 0, s, 0,\n            s2, s - 3, 3 - s2, -s,\n            -s, 2 - s, s - 2, s\n        ];\n    }\n}\nexport { CardinalSpline as default, CardinalSpline };\n","import { CardinalSpline } from './CardinalSpline';\nclass CatmullRomSpline extends CardinalSpline {\n    constructor() {\n        super({ scale: 0.5, fixedScale: true });\n    }\n}\nexport { CatmullRomSpline as default, CatmullRomSpline };\n","import { vec4 } from 'gl-matrix';\nimport { Spline } from './Spline';\nimport * as math from '../../../utilities/math';\nconst MAX_U_ERROR = 1e-8;\nclass CubicSpline extends Spline {\n    getPreviewCurveSegments(controlPointPreview, closeSpline) {\n        const previewNumCurveSegments = this._getNumCurveSegments() + 1;\n        const startCurveSegIndex = Math.max(0, previewNumCurveSegments - 2);\n        const endCurveSegIndex = closeSpline\n            ? previewNumCurveSegments\n            : previewNumCurveSegments - 1;\n        const transformMatrix = this.getTransformMatrix();\n        const controlPoints = [...this.controlPoints];\n        const curveSegments = [];\n        if (!closeSpline) {\n            controlPoints.push(controlPointPreview);\n        }\n        for (let i = startCurveSegIndex; i <= endCurveSegIndex; i++) {\n            const curveSegment = this._getCurveSegment(i, transformMatrix, controlPoints, closeSpline);\n            curveSegments.push(curveSegment);\n        }\n        return curveSegments;\n    }\n    getSplineCurves() {\n        const numCurveSegments = this._getNumCurveSegments();\n        const curveSegments = new Array(numCurveSegments);\n        if (numCurveSegments <= 0) {\n            return [];\n        }\n        const transformMatrix = this.getTransformMatrix();\n        let previousCurveSegmentsLength = 0;\n        for (let i = 0; i < numCurveSegments; i++) {\n            const curveSegment = this._getCurveSegment(i, transformMatrix);\n            curveSegment.previousCurveSegmentsLength = previousCurveSegmentsLength;\n            curveSegments[i] = curveSegment;\n            previousCurveSegmentsLength += curveSegment.length;\n        }\n        return curveSegments;\n    }\n    _getNumCurveSegments(controlPoints = this.controlPoints, closed = this.closed) {\n        return closed\n            ? controlPoints.length\n            : Math.max(0, controlPoints.length - 1);\n    }\n    _getPoint(u, transformMatrix, controlPoints = this.controlPoints, closed = this.closed) {\n        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n        const uInt = Math.floor(u);\n        let curveSegmentIndex = uInt % numCurveSegments;\n        const t = u - uInt;\n        const curveSegmentIndexOutOfBounds = curveSegmentIndex < 0 || curveSegmentIndex >= numCurveSegments;\n        if (curveSegmentIndexOutOfBounds) {\n            if (this.closed) {\n                curveSegmentIndex =\n                    (numCurveSegments + curveSegmentIndex) % numCurveSegments;\n            }\n            else {\n                return;\n            }\n        }\n        const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed);\n        const tt = t * t;\n        const ttt = tt * t;\n        const tValues = vec4.fromValues(1, t, tt, ttt);\n        const qValues = vec4.transformMat4(vec4.create(), tValues, transformMatrix);\n        return [\n            vec4.dot(qValues, vec4.fromValues(p0[0], p1[0], p2[0], p3[0])),\n            vec4.dot(qValues, vec4.fromValues(p0[1], p1[1], p2[1], p3[1])),\n        ];\n    }\n    _getCurveSegmentPoints(curveSegmentIndex, controlPoints = this.controlPoints, closed = this.closed) {\n        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n        const p1Index = curveSegmentIndex;\n        const p0Index = p1Index - 1;\n        const p2Index = closed ? (p1Index + 1) % numCurveSegments : p1Index + 1;\n        const p3Index = p2Index + 1;\n        const p1 = controlPoints[p1Index];\n        const p2 = controlPoints[p2Index];\n        let p0;\n        let p3;\n        if (p0Index >= 0) {\n            p0 = controlPoints[p0Index];\n        }\n        else {\n            p0 = closed\n                ? controlPoints[controlPoints.length - 1]\n                : math.point.mirror(p2, p1);\n        }\n        if (p3Index < controlPoints.length) {\n            p3 = controlPoints[p3Index];\n        }\n        else {\n            p3 = closed ? controlPoints[0] : math.point.mirror(p1, p2);\n        }\n        return { p0, p1, p2, p3 };\n    }\n    _getLineSegments(curveSegmentIndex, transformMatrix, controlPoints = this.controlPoints, closed = this.closed) {\n        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n        const numLineSegments = this.resolution + 1;\n        const inc = 1 / numLineSegments;\n        const minU = curveSegmentIndex;\n        let maxU = minU + 1;\n        if (!closed && curveSegmentIndex === numCurveSegments - 1) {\n            maxU -= MAX_U_ERROR;\n        }\n        const lineSegments = [];\n        let startPoint;\n        let endPoint;\n        let previousLineSegmentsLength = 0;\n        for (let i = 0, u = minU; i <= numLineSegments; i++, u += inc) {\n            u = u > maxU ? maxU : u;\n            const point = this._getPoint(u, transformMatrix, controlPoints, closed);\n            if (!i) {\n                startPoint = point;\n                continue;\n            }\n            endPoint = point;\n            const dx = endPoint[0] - startPoint[0];\n            const dy = endPoint[1] - startPoint[1];\n            const length = Math.sqrt(dx ** 2 + dy ** 2);\n            const aabb = {\n                minX: startPoint[0] <= endPoint[0] ? startPoint[0] : endPoint[0],\n                maxX: startPoint[0] >= endPoint[0] ? startPoint[0] : endPoint[0],\n                minY: startPoint[1] <= endPoint[1] ? startPoint[1] : endPoint[1],\n                maxY: startPoint[1] >= endPoint[1] ? startPoint[1] : endPoint[1],\n            };\n            lineSegments.push({\n                points: {\n                    start: startPoint,\n                    end: endPoint,\n                },\n                aabb,\n                length,\n                previousLineSegmentsLength,\n            });\n            startPoint = endPoint;\n            previousLineSegmentsLength += length;\n        }\n        return lineSegments;\n    }\n    _getCurveSegment(curveSegmentIndex, transformMatrix = this.getTransformMatrix(), controlPoints = this.controlPoints, closed = this.closed) {\n        const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed);\n        const lineSegments = this._getLineSegments(curveSegmentIndex, transformMatrix, controlPoints, closed);\n        let curveSegmentLength = 0;\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n        lineSegments.forEach(({ aabb: lineSegAABB, length: lineSegLength }) => {\n            minX = Math.min(minX, lineSegAABB.minX);\n            minY = Math.min(minY, lineSegAABB.minY);\n            maxX = Math.max(maxX, lineSegAABB.maxX);\n            maxY = Math.max(maxY, lineSegAABB.maxY);\n            curveSegmentLength += lineSegLength;\n        });\n        return {\n            controlPoints: { p0, p1, p2, p3 },\n            aabb: { minX, minY, maxX, maxY },\n            length: curveSegmentLength,\n            previousCurveSegmentsLength: 0,\n            lineSegments,\n        };\n    }\n}\nexport { CubicSpline as default, CubicSpline };\n","import { CardinalSpline } from './CardinalSpline';\nclass LinearSpline extends CardinalSpline {\n    constructor() {\n        super({ resolution: 0, fixedResolution: true, scale: 0, fixedScale: true });\n    }\n}\nexport { LinearSpline as default, LinearSpline };\n","import { QuadraticSpline } from './QuadraticSpline';\nconst TRANSFORM_MATRIX = [\n    1, 0, 0,\n    -2, 2, 0,\n    1, -2, 1,\n];\nclass QuadraticBezier extends QuadraticSpline {\n    hasTangentPoints() {\n        return true;\n    }\n    getTransformMatrix() {\n        return TRANSFORM_MATRIX;\n    }\n}\nexport { QuadraticBezier as default, QuadraticBezier };\n","import { Spline } from './Spline';\nclass QuadraticSpline extends Spline {\n    getSplineCurves() {\n        return [];\n    }\n    getLineSegments() {\n        return [];\n    }\n    getPreviewCurveSegments(controlPointPreview, closeSpline) {\n        return [];\n    }\n}\nexport { QuadraticSpline as default, QuadraticSpline };\n","import * as math from '../../../utilities/math';\nclass Spline {\n    constructor(props) {\n        this._controlPoints = [];\n        this._invalidated = false;\n        this._length = 0;\n        this._controlPoints = [];\n        this._resolution = props?.resolution ?? 20;\n        this._fixedResolution = props?.fixedResolution ?? false;\n        this._closed = props?.closed ?? false;\n        this._invalidated = true;\n    }\n    get controlPoints() {\n        return this._controlPoints;\n    }\n    get numControlPoints() {\n        return this._controlPoints.length;\n    }\n    get resolution() {\n        return this._resolution;\n    }\n    set resolution(resolution) {\n        if (this._fixedResolution || this._resolution === resolution) {\n            return;\n        }\n        this._resolution = resolution;\n        this.invalidated = true;\n    }\n    get fixedResolution() {\n        return this._fixedResolution;\n    }\n    get closed() {\n        return this._closed;\n    }\n    set closed(closed) {\n        if (this._closed === closed) {\n            return;\n        }\n        this._closed = closed;\n        this.invalidated = true;\n    }\n    get aabb() {\n        this._update();\n        return this._aabb;\n    }\n    get length() {\n        this._update();\n        return this._length;\n    }\n    get invalidated() {\n        return this._invalidated;\n    }\n    set invalidated(invalidated) {\n        this._invalidated = invalidated;\n    }\n    hasTangentPoints() {\n        return false;\n    }\n    addControlPoint(point) {\n        this._controlPoints.push([point[0], point[1]]);\n        this.invalidated = true;\n    }\n    addControlPoints(points) {\n        points.forEach((point) => this.addControlPoint(point));\n    }\n    addControlPointAtU(u) {\n        const lineSegment = this._getLineSegmentAt(u);\n        const { start: startPoint, end: endPoint } = lineSegment.points;\n        const curveSegmentIndex = Math.floor(u);\n        const curveSegment = this._curveSegments[curveSegmentIndex];\n        const t = u - Math.floor(curveSegmentIndex);\n        const controlPointPos = [\n            startPoint[0] + t * (endPoint[0] - startPoint[0]),\n            startPoint[1] + t * (endPoint[1] - startPoint[1]),\n        ];\n        const insertIndex = this._controlPoints.indexOf(curveSegment.controlPoints.p1) + 1;\n        this._controlPoints.splice(insertIndex, 0, controlPointPos);\n        this.invalidated = true;\n        return {\n            index: insertIndex,\n            point: controlPointPos,\n        };\n    }\n    deleteControlPointByIndex(index) {\n        const minControlPoints = this._closed ? 3 : 1;\n        const canDelete = index >= 0 &&\n            index < this._controlPoints.length &&\n            this._controlPoints.length > minControlPoints;\n        if (!canDelete) {\n            return false;\n        }\n        this._controlPoints.splice(index, 1);\n        this.invalidated = true;\n        return true;\n    }\n    clearControlPoints() {\n        this._controlPoints = [];\n        this.invalidated = true;\n    }\n    setControlPoints(points) {\n        this.clearControlPoints();\n        this.addControlPoints(points);\n    }\n    updateControlPoint(index, newControlPoint) {\n        if (index < 0 || index >= this._controlPoints.length) {\n            throw new Error('Index out of bounds');\n        }\n        this._controlPoints[index] = [...newControlPoint];\n        this.invalidated = true;\n    }\n    getControlPoints() {\n        return this._controlPoints.map((controlPoint) => [\n            controlPoint[0],\n            controlPoint[1],\n        ]);\n    }\n    getClosestControlPoint(point) {\n        const controlPoints = this._controlPoints;\n        let minSquaredDist = Infinity;\n        let closestPointIndex = -1;\n        for (let i = 0, len = controlPoints.length; i < len; i++) {\n            const controlPoint = controlPoints[i];\n            const dx = point[0] - controlPoint[0];\n            const dy = point[1] - controlPoint[1];\n            const squaredDist = dx * dx + dy * dy;\n            if (squaredDist < minSquaredDist) {\n                minSquaredDist = squaredDist;\n                closestPointIndex = i;\n            }\n        }\n        return {\n            index: closestPointIndex,\n            point: closestPointIndex === -1\n                ? undefined\n                : [...controlPoints[closestPointIndex]],\n            distance: Math.sqrt(minSquaredDist),\n        };\n    }\n    getClosestControlPointWithinDistance(point, maxDist) {\n        const closestControlPoint = this.getClosestControlPoint(point);\n        return closestControlPoint.distance <= maxDist\n            ? closestControlPoint\n            : undefined;\n    }\n    getClosestPoint(point) {\n        this._update();\n        const curveSegmentsDistInfo = this._getCurveSegmmentsDistanceSquaredInfo(point);\n        if (!curveSegmentsDistInfo.length) {\n            return;\n        }\n        curveSegmentsDistInfo.sort((csA, csB) => csA.distanceSquared - csB.distanceSquared);\n        let closestPoint;\n        let closestPointCurveSegmentIndex = -1;\n        let minDistSquared = Infinity;\n        let minDistCurveSegment;\n        let minDistLineSegment;\n        for (let i = 0; i < curveSegmentsDistInfo.length; i++) {\n            const curveSegmentDistInfo = curveSegmentsDistInfo[i];\n            if (curveSegmentDistInfo.distanceSquared > minDistSquared) {\n                continue;\n            }\n            const { curveSegmentIndex, curveSegment } = curveSegmentDistInfo;\n            const { lineSegments } = curveSegment;\n            for (let j = 0; j < lineSegments.length; j++) {\n                const lineSegment = lineSegments[j];\n                const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = math.lineSegment.distanceToPointSquaredInfo(lineSegment.points.start, lineSegment.points.end, point);\n                if (lineSegDistSquared < minDistSquared) {\n                    minDistLineSegment = lineSegment;\n                    closestPointCurveSegmentIndex = curveSegmentIndex;\n                    minDistCurveSegment = curveSegmentDistInfo.curveSegment;\n                    closestPoint = lineSegPoint;\n                    minDistSquared = lineSegDistSquared;\n                }\n            }\n        }\n        const curveSegmentLengthToPoint = minDistLineSegment.previousLineSegmentsLength +\n            math.point.distanceToPoint(minDistLineSegment.points.start, closestPoint);\n        const t = curveSegmentLengthToPoint / minDistCurveSegment.length;\n        const u = closestPointCurveSegmentIndex + t;\n        return {\n            point: closestPoint,\n            uValue: u,\n            distance: Math.sqrt(minDistSquared),\n        };\n    }\n    getClosestPointOnControlPointLines(point) {\n        const linePoints = [...this._controlPoints];\n        if (this._closed) {\n            linePoints.push(this._controlPoints[0]);\n        }\n        if (!linePoints.length) {\n            return;\n        }\n        let closestPoint;\n        let minDistSquared = Infinity;\n        let startPoint = linePoints[0];\n        for (let i = 1, len = linePoints.length; i < len; i++) {\n            const endPoint = linePoints[i];\n            const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = math.lineSegment.distanceToPointSquaredInfo(startPoint, endPoint, point);\n            if (lineSegDistSquared < minDistSquared) {\n                closestPoint = lineSegPoint;\n                minDistSquared = lineSegDistSquared;\n            }\n            startPoint = endPoint;\n        }\n        return {\n            point: closestPoint,\n            distance: Math.sqrt(minDistSquared),\n        };\n    }\n    getPolylinePoints() {\n        this._update();\n        return this._convertCurveSegmentsToPolyline(this._curveSegments);\n    }\n    getPreviewPolylinePoints(controlPointPreview, closeDistance) {\n        if (this._closed) {\n            return [];\n        }\n        this._update();\n        const closestControlPoint = this.getClosestControlPointWithinDistance(controlPointPreview, closeDistance);\n        const closeSpline = closestControlPoint?.index === 0;\n        const previewCurveSegments = this.getPreviewCurveSegments(controlPointPreview, closeSpline);\n        return previewCurveSegments?.length\n            ? this._convertCurveSegmentsToPolyline(previewCurveSegments)\n            : [];\n    }\n    isPointNearCurve(point, maxDist) {\n        this._update();\n        const curveSegments = this._getCurveSegmmentsWithinDistance(point, maxDist);\n        const maxDistSquared = maxDist * maxDist;\n        for (let i = 0; i < curveSegments.length; i++) {\n            const { lineSegments } = curveSegments[i];\n            for (let j = 0; j < lineSegments.length; j++) {\n                const lineSegment = lineSegments[j];\n                const lineDistSquared = math.lineSegment.distanceToPointSquared(lineSegment.points.start, lineSegment.points.end, point);\n                if (lineDistSquared <= maxDistSquared) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    containsPoint(point) {\n        this._update();\n        const controlPoints = this._controlPoints;\n        if (controlPoints.length < 3) {\n            return false;\n        }\n        const curveSegments = [...this._curveSegments];\n        const closingCurveSegment = this._getClosingCurveSegmentWithStraightLineSegment();\n        if (closingCurveSegment) {\n            curveSegments.push(closingCurveSegment);\n        }\n        let numIntersections = 0;\n        for (let i = 0; i < curveSegments.length; i++) {\n            const curveSegment = curveSegments[i];\n            const { aabb: curveSegAABB } = curveSegment;\n            const mayIntersectCurveSegment = point[0] <= curveSegAABB.maxX &&\n                point[1] >= curveSegAABB.minY &&\n                point[1] < curveSegAABB.maxY;\n            if (!mayIntersectCurveSegment) {\n                continue;\n            }\n            const { lineSegments } = curveSegment;\n            for (let i = 0; i < lineSegments.length; i++) {\n                const lineSegment = lineSegments[i];\n                const { aabb: lineSegmentAABB } = lineSegment;\n                const mayIntersectLineSegment = point[0] <= lineSegmentAABB.maxX &&\n                    point[1] >= lineSegmentAABB.minY &&\n                    point[1] < lineSegmentAABB.maxY;\n                if (mayIntersectLineSegment) {\n                    const { start: p1, end: p2 } = lineSegment.points;\n                    const isVerticalLine = p1[0] === p2[0];\n                    const xIntersection = ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\n                    numIntersections +=\n                        isVerticalLine || point[0] <= xIntersection ? 1 : 0;\n                }\n            }\n        }\n        return numIntersections % 2 === 1;\n    }\n    _update() {\n        if (!this._invalidated) {\n            return;\n        }\n        const curveSegments = this.getSplineCurves();\n        let length = 0;\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n        for (let i = 0, len = curveSegments.length; i < len; i++) {\n            const { aabb: curveSegAABB, length: curveSegLength } = curveSegments[i];\n            minX = minX <= curveSegAABB.minX ? minX : curveSegAABB.minX;\n            minY = minY <= curveSegAABB.minY ? minY : curveSegAABB.minY;\n            maxX = maxX >= curveSegAABB.maxX ? maxX : curveSegAABB.maxX;\n            maxY = maxY >= curveSegAABB.maxY ? maxY : curveSegAABB.maxY;\n            length += curveSegLength;\n        }\n        this._curveSegments = curveSegments;\n        this._aabb = { minX, minY, maxX, maxY };\n        this._length = length;\n        this._invalidated = false;\n    }\n    _convertCurveSegmentsToPolyline(curveSegments) {\n        this._update();\n        const polylinePoints = [];\n        curveSegments.forEach(({ lineSegments }, curveSegIndex) => {\n            lineSegments.forEach((lineSegment, lineSegIndex) => {\n                if (curveSegIndex === 0 && lineSegIndex === 0) {\n                    polylinePoints.push([...lineSegment.points.start]);\n                }\n                polylinePoints.push([...lineSegment.points.end]);\n            });\n        });\n        return polylinePoints;\n    }\n    _getCurveSegmmentsDistanceSquaredInfo(point) {\n        this._update();\n        const curveSegmentsDistanceSquared = [];\n        const { _curveSegments: curveSegments } = this;\n        for (let i = 0; i < curveSegments.length; i++) {\n            const curveSegment = curveSegments[i];\n            const distanceSquared = math.aabb.distanceToPointSquared(curveSegment.aabb, point);\n            curveSegmentsDistanceSquared.push({\n                curveSegmentIndex: i,\n                curveSegment,\n                distanceSquared,\n            });\n        }\n        return curveSegmentsDistanceSquared;\n    }\n    _getCurveSegmmentsWithinDistance(point, maxDist) {\n        this._update();\n        const maxDistSquared = maxDist * maxDist;\n        if (math.aabb.distanceToPointSquared(this.aabb, point) > maxDistSquared) {\n            return [];\n        }\n        const curveSegmentsDistance = this._getCurveSegmmentsDistanceSquaredInfo(point);\n        const curveSegmentsWithinRange = [];\n        for (let i = 0, len = curveSegmentsDistance.length; i < len; i++) {\n            const { curveSegment, distanceSquared: curveSegmentDistSquared } = curveSegmentsDistance[i];\n            if (curveSegmentDistSquared <= maxDistSquared) {\n                curveSegmentsWithinRange.push(curveSegment);\n            }\n        }\n        return curveSegmentsWithinRange;\n    }\n    _getLineSegmentAt(u) {\n        this._update();\n        const curveSegmentIndex = Math.floor(u);\n        const t = u - curveSegmentIndex;\n        const curveSegment = this._curveSegments[curveSegmentIndex];\n        const { lineSegments } = curveSegment;\n        const pointLength = curveSegment.length * t;\n        for (let i = 0; i < lineSegments.length; i++) {\n            const lineSegment = lineSegments[i];\n            const lengthEnd = lineSegment.previousLineSegmentsLength + lineSegment.length;\n            if (pointLength >= lineSegment.previousLineSegmentsLength &&\n                pointLength <= lengthEnd) {\n                return lineSegment;\n            }\n        }\n    }\n    _getClosingCurveSegmentWithStraightLineSegment() {\n        if (this.closed) {\n            return;\n        }\n        const controlPoints = this._controlPoints;\n        const startControlPoint = controlPoints[0];\n        const endControlPoint = controlPoints[controlPoints.length - 1];\n        const closingLineSegment = {\n            points: {\n                start: [...startControlPoint],\n                end: [...endControlPoint],\n            },\n            aabb: {\n                minX: Math.min(startControlPoint[0], endControlPoint[0]),\n                minY: Math.min(startControlPoint[1], endControlPoint[1]),\n                maxX: Math.max(startControlPoint[0], endControlPoint[0]),\n                maxY: Math.max(startControlPoint[1], endControlPoint[1]),\n            },\n        };\n        return {\n            aabb: {\n                minX: closingLineSegment.aabb.minX,\n                minY: closingLineSegment.aabb.minY,\n                maxX: closingLineSegment.aabb.maxX,\n                maxY: closingLineSegment.aabb.maxY,\n            },\n            lineSegments: [closingLineSegment],\n        };\n    }\n}\nexport { Spline as default, Spline };\n","import { utilities, getEnabledElement, cache, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport BaseTool from './BaseTool';\nimport { getAnnotationManager } from '../../stateManagement/annotation/annotationState';\nimport triggerAnnotationRender from '../../utilities/triggerAnnotationRender';\nimport filterAnnotationsForDisplay from '../../utilities/planar/filterAnnotationsForDisplay';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nimport { getState } from '../../stateManagement/annotation/config';\nclass AnnotationDisplayTool extends BaseTool {\n    constructor() {\n        super(...arguments);\n        this.onImageSpacingCalibrated = (evt) => {\n            const { element, imageId } = evt.detail;\n            const imageURI = utilities.imageIdToURI(imageId);\n            const annotationManager = getAnnotationManager();\n            const framesOfReference = annotationManager.getFramesOfReference();\n            framesOfReference.forEach((frameOfReference) => {\n                const frameOfReferenceSpecificAnnotations = annotationManager.getAnnotations(frameOfReference);\n                const toolSpecificAnnotations = frameOfReferenceSpecificAnnotations[this.getToolName()];\n                if (!toolSpecificAnnotations || !toolSpecificAnnotations.length) {\n                    return;\n                }\n                toolSpecificAnnotations.forEach((annotation) => {\n                    if (!annotation.metadata?.referencedImageId) {\n                        return;\n                    }\n                    const referencedImageURI = utilities.imageIdToURI(annotation.metadata.referencedImageId);\n                    if (referencedImageURI === imageURI) {\n                        annotation.invalidated = true;\n                        annotation.data.cachedStats = {};\n                    }\n                });\n                triggerAnnotationRender(element);\n            });\n        };\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!annotations?.length) {\n            return [];\n        }\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        return filterAnnotationsForDisplay(viewport, annotations);\n    }\n    static createAnnotation(...annotationBaseData) {\n        let annotation = {\n            annotationUID: null,\n            highlighted: true,\n            invalidated: true,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: this.toolName,\n            },\n            data: {\n                handles: {\n                    points: new Array(),\n                    activeHandleIndex: null,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                },\n                cachedStats: {},\n                label: '',\n            },\n        };\n        for (const baseData of annotationBaseData) {\n            annotation = utilities.deepMerge(annotation, baseData);\n        }\n        return annotation;\n    }\n    createAnnotation(evt, points, ...annotationBaseData) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const { world: worldPos } = currentPoints;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp, position: cameraPosition } = camera;\n        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n        const viewReference = viewport.getViewReference({ points: [worldPos] });\n        const annotation = AnnotationDisplayTool.createAnnotation({\n            metadata: {\n                toolName: this.getToolName(),\n                ...viewReference,\n                referencedImageId,\n                viewUp,\n                cameraPosition,\n            },\n            data: {\n                handles: {\n                    points: points || [],\n                },\n            },\n        }, ...annotationBaseData);\n        return annotation;\n    }\n    getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp) {\n        const targetId = this.getTargetId(viewport);\n        let referencedImageId = targetId.split(/^[a-zA-Z]+:/)[1];\n        if (viewport instanceof BaseVolumeViewport) {\n            const volumeId = utilities.getVolumeId(targetId);\n            const imageVolume = cache.getVolume(volumeId);\n            referencedImageId = utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n        }\n        return referencedImageId;\n    }\n    getStyle(property, specifications, annotation) {\n        return getStyleProperty(property, specifications, getState(annotation), this.mode);\n    }\n}\nAnnotationDisplayTool.toolName = 'AnnotationDisplayTool';\nexport default AnnotationDisplayTool;\n","import { utilities } from '@cornerstonejs/core';\nimport ToolModes from '../../enums/ToolModes';\nconst { DefaultHistoryMemo } = utilities.HistoryMemo;\nclass BaseTool {\n    static { this.defaults = {\n        configuration: {\n            strategies: {},\n            defaultStrategy: undefined,\n            activeStrategy: undefined,\n            strategyOptions: {},\n        },\n    }; }\n    constructor(toolProps, defaultToolProps) {\n        const mergedDefaults = BaseTool.mergeDefaultProps(BaseTool.defaults, defaultToolProps);\n        const initialProps = utilities.deepMerge(mergedDefaults, toolProps);\n        const { configuration = {}, supportedInteractionTypes, toolGroupId, } = initialProps;\n        this.toolGroupId = toolGroupId;\n        this.supportedInteractionTypes = supportedInteractionTypes || [];\n        this.configuration = Object.assign({}, configuration);\n        this.mode = ToolModes.Disabled;\n    }\n    static mergeDefaultProps(defaultProps = {}, additionalProps) {\n        if (!additionalProps) {\n            return defaultProps;\n        }\n        return utilities.deepMerge(defaultProps, additionalProps);\n    }\n    get toolName() {\n        return this.getToolName();\n    }\n    getToolName() {\n        return this.constructor.toolName;\n    }\n    applyActiveStrategy(enabledElement, operationData) {\n        const { strategies, activeStrategy } = this.configuration;\n        return strategies[activeStrategy]?.call(this, enabledElement, operationData);\n    }\n    applyActiveStrategyCallback(enabledElement, operationData, callbackType, ...extraArgs) {\n        const { strategies, activeStrategy } = this.configuration;\n        if (!strategies[activeStrategy]) {\n            throw new Error(`applyActiveStrategyCallback: active strategy ${activeStrategy} not found, check tool configuration or spellings`);\n        }\n        return strategies[activeStrategy][callbackType]?.call(this, enabledElement, operationData, ...extraArgs);\n    }\n    setConfiguration(newConfiguration) {\n        this.configuration = utilities.deepMerge(this.configuration, newConfiguration);\n    }\n    setActiveStrategy(strategyName) {\n        this.setConfiguration({ activeStrategy: strategyName });\n    }\n    getTargetImageData(targetId) {\n        if (targetId.startsWith('imageId:')) {\n            const imageId = targetId.split('imageId:')[1];\n            const imageURI = utilities.imageIdToURI(imageId);\n            let viewports = utilities.getViewportsWithImageURI(imageURI);\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            viewports = viewports.filter((viewport) => {\n                return viewport.getCurrentImageId() === imageId;\n            });\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            return viewports[0].getImageData();\n        }\n        else if (targetId.startsWith('volumeId:')) {\n            const volumeId = utilities.getVolumeId(targetId);\n            const viewports = utilities.getViewportsWithVolumeId(volumeId);\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            return viewports[0].getImageData();\n        }\n        else if (targetId.startsWith('videoId:')) {\n            const imageURI = utilities.imageIdToURI(targetId);\n            const viewports = utilities.getViewportsWithImageURI(imageURI);\n            if (!viewports || !viewports.length) {\n                return;\n            }\n            return viewports[0].getImageData();\n        }\n        else {\n            throw new Error('getTargetIdImage: targetId must start with \"imageId:\" or \"volumeId:\"');\n        }\n    }\n    getTargetId(viewport) {\n        const targetId = viewport.getViewReferenceId?.();\n        if (targetId) {\n            return targetId;\n        }\n        throw new Error('getTargetId: viewport must have a getViewReferenceId method');\n    }\n    undo() {\n        this.doneEditMemo();\n        DefaultHistoryMemo.undo();\n    }\n    redo() {\n        DefaultHistoryMemo.redo();\n    }\n    static createZoomPanMemo(viewport) {\n        const state = {\n            pan: viewport.getPan(),\n            zoom: viewport.getZoom(),\n        };\n        const zoomPanMemo = {\n            restoreMemo: () => {\n                const currentPan = viewport.getPan();\n                const currentZoom = viewport.getZoom();\n                viewport.setZoom(state.zoom);\n                viewport.setPan(state.pan);\n                viewport.render();\n                state.pan = currentPan;\n                state.zoom = currentZoom;\n            },\n        };\n        DefaultHistoryMemo.push(zoomPanMemo);\n        return zoomPanMemo;\n    }\n    doneEditMemo() {\n        if (this.memo?.commitMemo?.()) {\n            DefaultHistoryMemo.push(this.memo);\n        }\n        this.memo = null;\n    }\n    static startGroupRecording() {\n        DefaultHistoryMemo.startGroupRecording();\n    }\n    static endGroupRecording() {\n        DefaultHistoryMemo.endGroupRecording();\n    }\n}\nBaseTool.toolName = 'BaseTool';\nexport default BaseTool;\n","import { cache, getEnabledElementByViewportId, Enums, utilities, } from '@cornerstonejs/core';\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport { handleContourSegmentation } from './contourHandler/handleContourSegmentation';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport removeContourFromElement from './removeContourFromElement';\nimport { getPolySeg } from '../../../config';\nimport { computeAndAddRepresentation } from '../../../utilities/segmentation/computeAndAddRepresentation';\nimport { getUniqueSegmentIndices } from '../../../utilities/segmentation/getUniqueSegmentIndices';\nimport { getAnnotation } from '../../../stateManagement/annotation/annotationState';\nimport { vec3 } from 'gl-matrix';\nconst polySegConversionInProgressForViewportId = new Map();\nconst processedViewportSegmentations = new Map();\nfunction removeRepresentation(viewportId, segmentationId, renderImmediate = false) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    if (!renderImmediate) {\n        return;\n    }\n    viewport.render();\n}\nasync function render(viewport, contourRepresentation) {\n    const { segmentationId } = contourRepresentation;\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    let contourData = segmentation.representationData[Representations.Contour];\n    const polySeg = getPolySeg();\n    if (!contourData &&\n        getPolySeg()?.canComputeRequestedRepresentation(segmentationId, Representations.Contour) &&\n        !polySegConversionInProgressForViewportId.get(viewport.id)) {\n        polySegConversionInProgressForViewportId.set(viewport.id, true);\n        contourData = await computeAndAddRepresentation(segmentationId, Representations.Contour, () => polySeg.computeContourData(segmentationId, { viewport }));\n        polySegConversionInProgressForViewportId.set(viewport.id, false);\n    }\n    else if (!contourData && !getPolySeg()) {\n        console.debug(`No contour data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to contour. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);\n    }\n    if (!contourData) {\n        return;\n    }\n    if (!contourData.geometryIds?.length) {\n        return;\n    }\n    let hasContourDataButNotMatchingViewport = false;\n    const viewportNormal = viewport.getCamera().viewPlaneNormal;\n    if (contourData.annotationUIDsMap) {\n        hasContourDataButNotMatchingViewport = !_checkContourNormalsMatchViewport(contourData.annotationUIDsMap, viewportNormal);\n    }\n    if (contourData.geometryIds.length > 0) {\n        hasContourDataButNotMatchingViewport = !_checkContourGeometryMatchViewport(contourData.geometryIds, viewportNormal);\n    }\n    const viewportProcessed = processedViewportSegmentations.get(viewport.id) || new Set();\n    if (hasContourDataButNotMatchingViewport &&\n        !polySegConversionInProgressForViewportId.get(viewport.id) &&\n        !viewportProcessed.has(segmentationId) &&\n        viewport.viewportStatus === Enums.ViewportStatus.RENDERED) {\n        polySegConversionInProgressForViewportId.set(viewport.id, true);\n        const segmentIndices = getUniqueSegmentIndices(segmentationId);\n        const surfacesInfo = await polySeg.computeSurfaceData(segmentationId, {\n            segmentIndices,\n            viewport,\n        });\n        const geometryIds = surfacesInfo.geometryIds;\n        const pointsAndPolys = [];\n        for (const geometryId of geometryIds.values()) {\n            const geometry = cache.getGeometry(geometryId);\n            const data = geometry.data;\n            pointsAndPolys.push({\n                points: data.points,\n                polys: data.polys,\n                segmentIndex: data.segmentIndex,\n                id: data.segmentIndex,\n            });\n        }\n        const polyDataCache = await polySeg.clipAndCacheSurfacesForViewport(pointsAndPolys, viewport);\n        const rawResults = polySeg.extractContourData(polyDataCache);\n        const annotationUIDsMap = polySeg.createAndAddContourSegmentationsFromClippedSurfaces(rawResults, viewport, segmentationId);\n        contourData.annotationUIDsMap = new Map([\n            ...contourData.annotationUIDsMap,\n            ...annotationUIDsMap,\n        ]);\n        viewportProcessed.add(segmentationId);\n        processedViewportSegmentations.set(viewport.id, viewportProcessed);\n        polySegConversionInProgressForViewportId.set(viewport.id, false);\n    }\n    handleContourSegmentation(viewport, contourData.geometryIds, contourData.annotationUIDsMap, contourRepresentation);\n}\nfunction _checkContourGeometryMatchViewport(geometryIds, viewportNormal) {\n    let validGeometry = null;\n    let geometryData = null;\n    for (const geometryId of geometryIds) {\n        const geometry = cache.getGeometry(geometryId);\n        if (!geometry) {\n            continue;\n        }\n        const data = geometry.data;\n        if (data.contours?.[0]?.points?.length >= 3) {\n            validGeometry = geometry;\n            geometryData = data;\n            break;\n        }\n    }\n    if (!validGeometry || !geometryData) {\n        return false;\n    }\n    const contours = geometryData.contours;\n    const { points } = contours[0];\n    const [point] = points;\n    const delta = vec3.create();\n    const { length } = points;\n    const increment = Math.ceil(length / 25);\n    for (let i = 1; i < length; i += increment) {\n        const point2 = points[i];\n        vec3.sub(delta, point, point2);\n        vec3.normalize(delta, delta);\n        if (vec3.dot(viewportNormal, delta) > 0.1) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction _checkContourNormalsMatchViewport(annotationUIDsMap, viewportNormal) {\n    const annotationUIDs = Array.from(annotationUIDsMap.values())\n        .flat()\n        .map((uidSet) => Array.from(uidSet))\n        .flat();\n    const randomAnnotationUIDs = utilities.getRandomSampleFromArray(annotationUIDs, 3);\n    for (const annotationUID of randomAnnotationUIDs) {\n        const annotation = getAnnotation(annotationUID);\n        if (annotation?.metadata) {\n            if (!annotation.metadata.viewPlaneNormal) {\n                continue;\n            }\n            const annotationNormal = annotation.metadata.viewPlaneNormal;\n            const dotProduct = Math.abs(viewportNormal[0] * annotationNormal[0] +\n                viewportNormal[1] * annotationNormal[1] +\n                viewportNormal[2] * annotationNormal[2]);\n            if (Math.abs(dotProduct - 1) > 0.01) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nfunction getUpdateFunction(viewport) {\n    return null;\n}\nexport default {\n    getUpdateFunction,\n    render,\n    removeRepresentation,\n};\n","import { getEnabledElementByViewportId, VolumeViewport, } from '@cornerstonejs/core';\nimport addLabelmapToElement from './addLabelmapToElement';\nimport removeLabelmapFromElement from './removeLabelmapFromElement';\nimport { getActiveSegmentation } from '../../../stateManagement/segmentation/activeSegmentation';\nimport { getColorLUT } from '../../../stateManagement/segmentation/getColorLUT';\nimport { getCurrentLabelmapImageIdsForViewport } from '../../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { segmentationStyle } from '../../../stateManagement/segmentation/SegmentationStyle';\nimport SegmentationRepresentations from '../../../enums/SegmentationRepresentations';\nimport { internalGetHiddenSegmentIndices } from '../../../stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices';\nimport { getActiveSegmentIndex } from '../../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getLabelmapActorEntries } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nimport { getPolySeg } from '../../../config';\nimport { computeAndAddRepresentation } from '../../../utilities/segmentation/computeAndAddRepresentation';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { defaultSegmentationStateManager } from '../../../stateManagement/segmentation/SegmentationStateManager';\nexport const MAX_NUMBER_COLORS = 255;\nconst labelMapConfigCache = new Map();\nlet polySegConversionInProgress = false;\nfunction removeRepresentation(viewportId, segmentationId, renderImmediate = false) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    labelMapConfigCache.forEach((value, key) => {\n        if (key.includes(segmentationId)) {\n            labelMapConfigCache.delete(key);\n        }\n    });\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    removeLabelmapFromElement(viewport.element, segmentationId);\n    if (!renderImmediate) {\n        return;\n    }\n    viewport.render();\n}\nasync function render(viewport, representation) {\n    const { segmentationId, config } = representation;\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        console.warn('No segmentation found for segmentationId: ', segmentationId);\n        return;\n    }\n    let labelmapData = segmentation.representationData[SegmentationRepresentations.Labelmap];\n    let labelmapActorEntries = getLabelmapActorEntries(viewport.id, segmentationId);\n    if (!labelmapData &&\n        getPolySeg()?.canComputeRequestedRepresentation(segmentationId, SegmentationRepresentations.Labelmap) &&\n        !polySegConversionInProgress) {\n        polySegConversionInProgress = true;\n        const polySeg = getPolySeg();\n        labelmapData = await computeAndAddRepresentation(segmentationId, SegmentationRepresentations.Labelmap, () => polySeg.computeLabelmapData(segmentationId, { viewport }), () => {\n            defaultSegmentationStateManager.processLabelmapRepresentationAddition(viewport.id, segmentationId);\n            setTimeout(() => {\n                triggerSegmentationDataModified(segmentationId);\n            }, 0);\n        });\n        if (!labelmapData) {\n            throw new Error(`No labelmap data found for segmentationId ${segmentationId}.`);\n        }\n        polySegConversionInProgress = false;\n    }\n    else if (!labelmapData && !getPolySeg()) {\n        console.debug(`No labelmap data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to labelmap. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);\n    }\n    if (!labelmapData) {\n        return;\n    }\n    if (viewport instanceof VolumeViewport) {\n        if (!labelmapActorEntries?.length) {\n            await _addLabelmapToViewport(viewport, labelmapData, segmentationId, config);\n        }\n        labelmapActorEntries = getLabelmapActorEntries(viewport.id, segmentationId);\n    }\n    else {\n        const labelmapImageIds = getCurrentLabelmapImageIdsForViewport(viewport.id, segmentationId);\n        if (!labelmapImageIds?.length) {\n            return;\n        }\n        if (!labelmapActorEntries) {\n            await _addLabelmapToViewport(viewport, labelmapData, segmentationId, config);\n        }\n        labelmapActorEntries = getLabelmapActorEntries(viewport.id, segmentationId);\n    }\n    if (!labelmapActorEntries?.length) {\n        return;\n    }\n    for (const labelmapActorEntry of labelmapActorEntries) {\n        _setLabelmapColorAndOpacity(viewport.id, labelmapActorEntry, representation);\n    }\n}\nfunction _setLabelmapColorAndOpacity(viewportId, labelmapActorEntry, segmentationRepresentation) {\n    const { segmentationId } = segmentationRepresentation;\n    const { cfun, ofun } = segmentationRepresentation.config;\n    const { colorLUTIndex } = segmentationRepresentation;\n    const activeSegmentation = getActiveSegmentation(viewportId);\n    const isActiveLabelmap = activeSegmentation?.segmentationId === segmentationId;\n    const labelmapStyle = segmentationStyle.getStyle({\n        viewportId,\n        type: SegmentationRepresentations.Labelmap,\n        segmentationId,\n    });\n    const renderInactiveSegmentations = segmentationStyle.getRenderInactiveSegmentations(viewportId);\n    const colorLUT = getColorLUT(colorLUTIndex);\n    const numColors = Math.min(256, colorLUT.length);\n    const { outlineWidth, renderOutline, outlineOpacity, activeSegmentOutlineWidthDelta, } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap);\n    const segmentsHidden = internalGetHiddenSegmentIndices(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Labelmap,\n    });\n    for (let i = 0; i < numColors; i++) {\n        const segmentIndex = i;\n        const segmentColor = colorLUT[segmentIndex];\n        const perSegmentStyle = segmentationStyle.getStyle({\n            viewportId,\n            type: SegmentationRepresentations.Labelmap,\n            segmentationId,\n            segmentIndex,\n        });\n        const segmentSpecificLabelmapConfig = perSegmentStyle;\n        const { fillAlpha, outlineWidth, renderFill, renderOutline } = _getLabelmapConfig(labelmapStyle, isActiveLabelmap, segmentSpecificLabelmapConfig);\n        const { forceOpacityUpdate, forceColorUpdate } = _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, {\n            fillAlpha,\n            renderFill,\n            renderOutline,\n            segmentColor,\n            outlineWidth,\n            segmentsHidden: segmentsHidden,\n            cfun,\n            ofun,\n        });\n        if (forceColorUpdate) {\n            cfun.addRGBPoint(segmentIndex, segmentColor[0] / MAX_NUMBER_COLORS, segmentColor[1] / MAX_NUMBER_COLORS, segmentColor[2] / MAX_NUMBER_COLORS);\n        }\n        if (forceOpacityUpdate) {\n            if (renderFill) {\n                const segmentOpacity = segmentsHidden.has(segmentIndex)\n                    ? 0\n                    : (segmentColor[3] / 255) * fillAlpha;\n                ofun.removePoint(segmentIndex);\n                ofun.addPointLong(segmentIndex, segmentOpacity, 0.5, 1.0);\n            }\n            else {\n                ofun.addPointLong(segmentIndex, 0.01, 0.5, 1.0);\n            }\n        }\n    }\n    ofun.setClamping(false);\n    const labelmapActor = labelmapActorEntry.actor;\n    const { preLoad } = labelmapActor.get?.('preLoad') || { preLoad: null };\n    if (preLoad) {\n        preLoad({ cfun, ofun, actor: labelmapActor });\n    }\n    else {\n        labelmapActor.getProperty().setRGBTransferFunction(0, cfun);\n        labelmapActor.getProperty().setScalarOpacity(0, ofun);\n        labelmapActor.getProperty().setInterpolationTypeToNearest();\n    }\n    if (renderOutline) {\n        labelmapActor.getProperty().setUseLabelOutline(renderOutline);\n        labelmapActor.getProperty().setLabelOutlineOpacity(outlineOpacity);\n        const activeSegmentIndex = getActiveSegmentIndex(segmentationRepresentation.segmentationId);\n        const outlineWidths = new Array(numColors - 1);\n        for (let i = 1; i < numColors; i++) {\n            const isHidden = segmentsHidden.has(i);\n            if (isHidden) {\n                outlineWidths[i - 1] = 0;\n                continue;\n            }\n            outlineWidths[i - 1] =\n                i === activeSegmentIndex\n                    ? outlineWidth + activeSegmentOutlineWidthDelta\n                    : outlineWidth;\n        }\n        labelmapActor.getProperty().setLabelOutlineThickness(outlineWidths);\n        labelmapActor.modified();\n        labelmapActor.getProperty().modified();\n        labelmapActor.getMapper().modified();\n    }\n    else {\n        labelmapActor\n            .getProperty()\n            .setLabelOutlineThickness(new Array(numColors - 1).fill(0));\n    }\n    const visible = isActiveLabelmap || renderInactiveSegmentations;\n    labelmapActor.setVisibility(visible);\n}\nfunction _getLabelmapConfig(labelmapConfig, isActiveLabelmap, segmentsLabelmapConfig) {\n    const segmentLabelmapConfig = segmentsLabelmapConfig || {};\n    const configToUse = {\n        ...labelmapConfig,\n        ...segmentLabelmapConfig,\n    };\n    const fillAlpha = isActiveLabelmap\n        ? configToUse.fillAlpha\n        : configToUse.fillAlphaInactive;\n    const outlineWidth = isActiveLabelmap\n        ? configToUse.outlineWidth\n        : configToUse.outlineWidthInactive;\n    const renderFill = isActiveLabelmap\n        ? configToUse.renderFill\n        : configToUse.renderFillInactive;\n    const renderOutline = isActiveLabelmap\n        ? configToUse.renderOutline\n        : configToUse.renderOutlineInactive;\n    const outlineOpacity = isActiveLabelmap\n        ? configToUse.outlineOpacity\n        : configToUse.outlineOpacityInactive;\n    const activeSegmentOutlineWidthDelta = configToUse.activeSegmentOutlineWidthDelta;\n    return {\n        fillAlpha,\n        outlineWidth,\n        renderFill,\n        renderOutline,\n        outlineOpacity,\n        activeSegmentOutlineWidthDelta,\n    };\n}\nfunction _needsTransferFunctionUpdate(viewportId, segmentationId, segmentIndex, { fillAlpha, renderFill, renderOutline, segmentColor, outlineWidth, segmentsHidden, cfun, ofun, }) {\n    const cacheUID = `${viewportId}-${segmentationId}-${segmentIndex}`;\n    const oldConfig = labelMapConfigCache.get(cacheUID);\n    if (!oldConfig) {\n        labelMapConfigCache.set(cacheUID, {\n            fillAlpha,\n            renderFill,\n            renderOutline,\n            outlineWidth,\n            segmentColor: segmentColor.slice(),\n            segmentsHidden: new Set(segmentsHidden),\n            cfunMTime: cfun.getMTime(),\n            ofunMTime: ofun.getMTime(),\n        });\n        return {\n            forceOpacityUpdate: true,\n            forceColorUpdate: true,\n        };\n    }\n    const { fillAlpha: oldFillAlpha, renderFill: oldRenderFill, renderOutline: oldRenderOutline, outlineWidth: oldOutlineWidth, segmentColor: oldSegmentColor, segmentsHidden: oldSegmentsHidden, cfunMTime: oldCfunMTime, ofunMTime: oldOfunMTime, } = oldConfig;\n    const forceColorUpdate = oldSegmentColor[0] !== segmentColor[0] ||\n        oldSegmentColor[1] !== segmentColor[1] ||\n        oldSegmentColor[2] !== segmentColor[2];\n    const forceOpacityUpdate = oldSegmentColor[3] !== segmentColor[3] ||\n        oldFillAlpha !== fillAlpha ||\n        oldRenderFill !== renderFill ||\n        oldRenderOutline !== renderOutline ||\n        oldOutlineWidth !== outlineWidth ||\n        oldSegmentsHidden !== segmentsHidden;\n    if (forceOpacityUpdate || forceColorUpdate) {\n        labelMapConfigCache.set(cacheUID, {\n            fillAlpha,\n            renderFill,\n            renderOutline,\n            outlineWidth,\n            segmentColor: segmentColor.slice(),\n            segmentsHidden: new Set(segmentsHidden),\n            cfunMTime: cfun.getMTime(),\n            ofunMTime: ofun.getMTime(),\n        });\n    }\n    return {\n        forceOpacityUpdate,\n        forceColorUpdate,\n    };\n}\nasync function _addLabelmapToViewport(viewport, labelmapData, segmentationId, config) {\n    const result = await addLabelmapToElement(viewport.element, labelmapData, segmentationId, config);\n    return result || undefined;\n}\nfunction getUpdateFunction(viewport) {\n    return;\n}\nexport default {\n    getUpdateFunction,\n    render,\n    removeRepresentation,\n};\nexport { render, removeRepresentation };\n","import { cache, getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport Representations from '../../../enums/SegmentationRepresentations';\nimport removeSurfaceFromElement from './removeSurfaceFromElement';\nimport addOrUpdateSurfaceToElement from './addOrUpdateSurfaceToElement';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { getColorLUT } from '../../../stateManagement/segmentation/getColorLUT';\nimport { getPolySeg } from '../../../config';\nimport { computeAndAddRepresentation } from '../../../utilities/segmentation/computeAndAddRepresentation';\nimport { internalGetHiddenSegmentIndices } from '../../../stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices';\nfunction removeRepresentation(viewportId, segmentationId, renderImmediate = false) {\n    const enabledElement = getEnabledElementByViewportId(viewportId);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    removeSurfaceFromElement(viewport.element, segmentationId);\n    if (!renderImmediate) {\n        return;\n    }\n    viewport.render();\n}\nasync function render(viewport, representation) {\n    const { segmentationId, type } = representation;\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    let SurfaceData = segmentation.representationData[Representations.Surface];\n    if (!SurfaceData &&\n        getPolySeg()?.canComputeRequestedRepresentation(segmentationId, Representations.Surface)) {\n        const polySeg = getPolySeg();\n        SurfaceData = await computeAndAddRepresentation(segmentationId, Representations.Surface, () => polySeg.computeSurfaceData(segmentationId, { viewport }));\n        if (!SurfaceData) {\n            throw new Error(`No Surface data found for segmentationId ${segmentationId} even we tried to compute it`);\n        }\n    }\n    else if (!SurfaceData && !getPolySeg()) {\n        console.debug(`No surface data found for segmentationId ${segmentationId} and PolySeg add-on is not configured. Unable to convert from other representations to surface. Please register PolySeg using cornerstoneTools.init({ addons: { polySeg } }) to enable automatic conversion.`);\n    }\n    if (!SurfaceData) {\n        console.warn(`No Surface data found for segmentationId ${segmentationId}. Skipping render.`);\n        return;\n    }\n    const { geometryIds } = SurfaceData;\n    if (!geometryIds?.size) {\n        console.warn(`No Surfaces found for segmentationId ${segmentationId}. Skipping render.`);\n    }\n    const { colorLUTIndex } = representation;\n    const colorLUT = getColorLUT(colorLUTIndex);\n    const surfaces = [];\n    geometryIds.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (!geometry?.data) {\n            console.warn(`No Surfaces found for geometryId ${geometryId}. Skipping render.`);\n            return;\n        }\n        const { segmentIndex } = geometry.data;\n        const hiddenSegments = internalGetHiddenSegmentIndices(viewport.id, {\n            segmentationId,\n            type,\n        });\n        const isHidden = hiddenSegments.has(segmentIndex);\n        const surface = geometry.data;\n        const color = colorLUT[segmentIndex];\n        surface.color = color.slice(0, 3);\n        surface.visible = !isHidden;\n        surfaces.push(surface);\n        addOrUpdateSurfaceToElement(viewport, surface, segmentationId);\n    });\n    viewport.render();\n}\nfunction getUpdateFunction(viewport) {\n    const polySeg = getPolySeg();\n    return (segmentationId) => polySeg.updateSurfaceData(segmentationId, { viewport });\n}\nexport default {\n    getUpdateFunction,\n    render,\n    removeRepresentation,\n};\nexport { getUpdateFunction, render, removeRepresentation };\n","import { getEnabledElement, eventTarget } from '@cornerstonejs/core';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { Events, ToolModes, StrategyCallbacks } from '../../enums';\nimport { fillInsideSphere, thresholdInsideSphere, thresholdInsideSphereIsland, } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { thresholdInsideCircle, fillInsideCircle, } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nimport { getStrategyData } from './strategies/utils/getStrategyData';\nclass BrushTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE_CIRCLE: fillInsideCircle,\n                ERASE_INSIDE_CIRCLE: eraseInsideCircle,\n                FILL_INSIDE_SPHERE: fillInsideSphere,\n                ERASE_INSIDE_SPHERE: eraseInsideSphere,\n                THRESHOLD_INSIDE_CIRCLE: thresholdInsideCircle,\n                THRESHOLD_INSIDE_SPHERE: thresholdInsideSphere,\n                THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL: thresholdInsideSphereIsland,\n            },\n            defaultStrategy: 'FILL_INSIDE_CIRCLE',\n            activeStrategy: 'FILL_INSIDE_CIRCLE',\n            brushSize: 25,\n            useCenterSegmentIndex: false,\n            preview: {\n                enabled: false,\n                previewColors: {\n                    0: [255, 255, 255, 128],\n                },\n                previewTimeMs: 250,\n                previewMoveDistance: 8,\n                dragMoveDistance: 4,\n                dragTimeMs: 500,\n            },\n            actions: {\n                [StrategyCallbacks.AcceptPreview]: {\n                    method: StrategyCallbacks.AcceptPreview,\n                    bindings: [\n                        {\n                            key: 'Enter',\n                        },\n                    ],\n                },\n                [StrategyCallbacks.RejectPreview]: {\n                    method: StrategyCallbacks.RejectPreview,\n                    bindings: [\n                        {\n                            key: 'Escape',\n                        },\n                    ],\n                },\n                [StrategyCallbacks.Interpolate]: {\n                    method: StrategyCallbacks.Interpolate,\n                    bindings: [\n                        {\n                            key: 'i',\n                        },\n                    ],\n                    configuration: {\n                        useBallStructuringElement: true,\n                        noUseDistanceTransform: true,\n                        noUseExtrapolation: true,\n                    },\n                },\n                interpolateExtrapolation: {\n                    method: StrategyCallbacks.Interpolate,\n                    bindings: [\n                        {\n                            key: 'e',\n                        },\n                    ],\n                    configuration: {},\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._lastDragInfo = null;\n        this.onSetToolPassive = (evt) => {\n            this.disableCursor();\n        };\n        this.onSetToolEnabled = () => {\n            this.disableCursor();\n        };\n        this.onSetToolDisabled = (evt) => {\n            this.disableCursor();\n        };\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this._editData = this.createEditData(element);\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            this._previewData.isDrag = false;\n            this._previewData.timerStart = Date.now();\n            const canvasPoint = vec2.clone(currentPoints.canvas);\n            const worldPoint = viewport.canvasToWorld([\n                canvasPoint[0],\n                canvasPoint[1],\n            ]);\n            this._lastDragInfo = {\n                canvas: canvasPoint,\n                world: vec3.clone(worldPoint),\n            };\n            const hoverData = this._hoverData || this.createHoverData(element);\n            triggerAnnotationRenderForViewportUIDs(hoverData.viewportIdsToRender);\n            const operationData = this.getOperationData(element);\n            this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.OnInteractionStart);\n            return true;\n        };\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode === ToolModes.Active) {\n                this.updateCursor(evt);\n                if (!this.configuration.preview.enabled) {\n                    return;\n                }\n                const { previewTimeMs, previewMoveDistance, dragMoveDistance } = this.configuration.preview;\n                const { currentPoints, element } = evt.detail;\n                const { canvas } = currentPoints;\n                const { startPoint, timer, timerStart, isDrag } = this._previewData;\n                if (isDrag) {\n                    return;\n                }\n                const delta = vec2.distance(canvas, startPoint);\n                const time = Date.now() - timerStart;\n                if (delta > previewMoveDistance ||\n                    (time > previewTimeMs && delta > dragMoveDistance)) {\n                    if (timer) {\n                        window.clearTimeout(timer);\n                        this._previewData.timer = null;\n                    }\n                    if (!isDrag) {\n                        this.rejectPreview(element);\n                    }\n                }\n                if (!this._previewData.timer) {\n                    const timer = window.setTimeout(this.previewCallback, 250);\n                    Object.assign(this._previewData, {\n                        timerStart: Date.now(),\n                        timer,\n                        startPoint: canvas,\n                        element,\n                    });\n                }\n            }\n        };\n        this.previewCallback = () => {\n            if (this._previewData.isDrag) {\n                this._previewData.timer = null;\n                return;\n            }\n            this._previewData.timer = null;\n            const operationData = this.getOperationData(this._previewData.element);\n            const enabledElement = getEnabledElement(this._previewData.element);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            const activeStrategy = this.configuration.activeStrategy;\n            const strategyData = getStrategyData({\n                operationData,\n                viewport,\n                strategy: activeStrategy,\n            });\n            if (!operationData) {\n                return;\n            }\n            const memo = this.createMemo(operationData.segmentationId, strategyData.segmentationVoxelManager);\n            this._previewData.preview = this.applyActiveStrategyCallback(getEnabledElement(this._previewData.element), {\n                ...operationData,\n                ...strategyData,\n                memo,\n            }, StrategyCallbacks.Preview);\n        };\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.updateCursor(evt);\n            const { viewportIdsToRender } = this._hoverData;\n            triggerAnnotationRenderForViewportUIDs(viewportIdsToRender);\n            const delta = vec2.distance(currentPoints.canvas, this._previewData.startPoint);\n            const { dragTimeMs, dragMoveDistance } = this.configuration.preview;\n            if (!this._previewData.isDrag &&\n                Date.now() - this._previewData.timerStart < dragTimeMs &&\n                delta < dragMoveDistance) {\n                return;\n            }\n            if (this._previewData.timer) {\n                window.clearTimeout(this._previewData.timer);\n                this._previewData.timer = null;\n            }\n            if (!this._lastDragInfo) {\n                const startCanvas = this._previewData.startPoint;\n                const startWorld = viewport.canvasToWorld([\n                    startCanvas[0],\n                    startCanvas[1],\n                ]);\n                this._lastDragInfo = {\n                    canvas: vec2.clone(startCanvas),\n                    world: vec3.clone(startWorld),\n                };\n            }\n            const currentCanvas = currentPoints.canvas;\n            const currentWorld = viewport.canvasToWorld([\n                currentCanvas[0],\n                currentCanvas[1],\n            ]);\n            this._hoverData = this.createHoverData(element, currentCanvas);\n            this._calculateCursor(element, currentCanvas);\n            const operationData = this.getOperationData(element);\n            operationData.strokePointsWorld = [\n                vec3.clone(this._lastDragInfo.world),\n                vec3.clone(currentWorld),\n            ];\n            this._previewData.preview = this.applyActiveStrategy(enabledElement, operationData);\n            const currentCanvasClone = vec2.clone(currentCanvas);\n            this._lastDragInfo = {\n                canvas: currentCanvasClone,\n                world: vec3.clone(currentWorld),\n            };\n            this._previewData.element = element;\n            this._previewData.timerStart = Date.now() + dragTimeMs;\n            this._previewData.isDrag = true;\n            this._previewData.startPoint = currentCanvasClone;\n        };\n        this._endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const operationData = this.getOperationData(element);\n            if (!this._previewData.preview && !this._previewData.isDrag) {\n                this.applyActiveStrategy(enabledElement, operationData);\n            }\n            this.doneEditMemo();\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.updateCursor(evt);\n            this._editData = null;\n            this._lastDragInfo = null;\n            this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.OnInteractionEnd);\n            if (!this._previewData.isDrag) {\n                this.acceptPreview(element);\n            }\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    disableCursor() {\n        this._hoverData = undefined;\n        this.rejectPreview();\n    }\n    updateCursor(evt) {\n        const eventData = evt.detail;\n        const { element } = eventData;\n        const { currentPoints } = eventData;\n        const centerCanvas = currentPoints.canvas;\n        this._hoverData = this.createHoverData(element, centerCanvas);\n        this._calculateCursor(element, centerCanvas);\n        if (!this._hoverData) {\n            return;\n        }\n        triggerAnnotationRenderForViewportUIDs(this._hoverData.viewportIdsToRender);\n    }\n    _calculateCursor(element, centerCanvas) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { canvasToWorld } = viewport;\n        const camera = viewport.getCamera();\n        const { brushSize } = this.configuration;\n        const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n        const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n        const viewRight = vec3.create();\n        vec3.cross(viewRight, viewUp, viewPlaneNormal);\n        const centerCursorInWorld = canvasToWorld([\n            centerCanvas[0],\n            centerCanvas[1],\n        ]);\n        const bottomCursorInWorld = vec3.create();\n        const topCursorInWorld = vec3.create();\n        const leftCursorInWorld = vec3.create();\n        const rightCursorInWorld = vec3.create();\n        for (let i = 0; i <= 2; i++) {\n            bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;\n            topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;\n            leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;\n            rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;\n        }\n        if (!this._hoverData) {\n            return;\n        }\n        const { brushCursor } = this._hoverData;\n        const { data } = brushCursor;\n        if (data.handles === undefined) {\n            data.handles = {};\n        }\n        data.handles.points = [\n            bottomCursorInWorld,\n            topCursorInWorld,\n            leftCursorInWorld,\n            rightCursorInWorld,\n        ];\n        const activeStrategy = this.configuration.activeStrategy;\n        const strategy = this.configuration.strategies[activeStrategy];\n        if (typeof strategy?.computeInnerCircleRadius === 'function') {\n            strategy.computeInnerCircleRadius({\n                configuration: this.configuration,\n                viewport,\n            });\n        }\n        data.invalidated = false;\n    }\n    getStatistics(element, segmentIndices) {\n        if (!element) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const stats = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.GetStatistics, segmentIndices);\n        return stats;\n    }\n    rejectPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        this.doneEditMemo();\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.RejectPreview);\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    acceptPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        super.acceptPreview(element);\n    }\n    interpolate(element, config) {\n        if (!element) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        this._previewData.preview = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.Interpolate, config.configuration);\n        this._previewData.isDrag = true;\n    }\n    invalidateBrushCursor() {\n        if (this._hoverData === undefined) {\n            return;\n        }\n        const { data } = this._hoverData.brushCursor;\n        const { viewport } = this._hoverData;\n        data.invalidated = true;\n        const { segmentColor } = this.getActiveSegmentationData(viewport) || {};\n        this._hoverData.brushCursor.metadata.segmentColor = segmentColor;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this._hoverData) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const viewportIdsToRender = this._hoverData.viewportIdsToRender;\n        if (!viewportIdsToRender.includes(viewport.id)) {\n            return;\n        }\n        const brushCursor = this._hoverData.brushCursor;\n        if (brushCursor.data.invalidated === true) {\n            const { centerCanvas } = this._hoverData;\n            const { element } = viewport;\n            this._calculateCursor(element, centerCanvas);\n        }\n        const toolMetadata = brushCursor.metadata;\n        if (!toolMetadata) {\n            return;\n        }\n        const annotationUID = toolMetadata.brushCursorUID;\n        const data = brushCursor.data;\n        const { points } = data.handles;\n        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n        const bottom = canvasCoordinates[0];\n        const top = canvasCoordinates[1];\n        const center = [\n            Math.floor((bottom[0] + top[0]) / 2),\n            Math.floor((bottom[1] + top[1]) / 2),\n        ];\n        const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n        const color = `rgb(${toolMetadata.segmentColor?.slice(0, 3) || [0, 0, 0]})`;\n        if (!viewport.getRenderingEngine()) {\n            console.warn('Rendering Engine has been destroyed');\n            return;\n        }\n        const circleUID = '0';\n        drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n            color,\n            lineDash: this.centerSegmentIndexInfo.segmentIndex === 0 ? [1, 2] : null,\n        });\n        const { dynamicRadiusInCanvas } = this.configuration?.threshold || {\n            dynamicRadiusInCanvas: 0,\n        };\n        if (dynamicRadiusInCanvas) {\n            const circleUID1 = '1';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID1, center, dynamicRadiusInCanvas, {\n                color,\n            });\n        }\n    }\n}\nBrushTool.toolName = 'Brush';\nexport default BrushTool;\n","import { StackViewport, cache, getEnabledElement, utilities as csUtils, utilities as coreUtils, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { addAnnotation, removeAnnotation, getAnnotations, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport throttle from '../../utilities/throttle';\nimport debounce from '../../utilities/debounce';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { hideElementCursor, resetElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport CircleROITool from '../annotation/CircleROITool';\nimport { getCanvasCircleCorners, getCanvasCircleRadius, } from '../../utilities/math/circle';\nimport { getCalibratedLengthUnitsAndScale, getCalibratedAspect, } from '../../utilities/getCalibratedUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { filterAnnotationsWithinSamePlane } from '../../utilities/planar';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nconst { transformWorldToIndex } = csUtils;\nclass CircleROIStartEndThresholdTool extends CircleROITool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            simplified: true,\n            storePointData: false,\n            numSlicesToPropagate: 10,\n            calculatePointsInsideVolume: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n            showTextBox: false,\n            throttleTimeout: 100,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            let referencedImageId, imageVolume, volumeId;\n            if (viewport instanceof StackViewport) {\n                throw new Error('Stack Viewport Not implemented');\n            }\n            else {\n                const targetId = this.getTargetId(viewport);\n                volumeId = csUtils.getVolumeId(targetId);\n                imageVolume = cache.getVolume(volumeId);\n                referencedImageId = csUtils.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n            }\n            const spacingInNormal = csUtils.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);\n            const startCoord = this._getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal);\n            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            let points;\n            if (this.configuration.simplified) {\n                points = [[...worldPos], [...worldPos]];\n            }\n            else {\n                points = [\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                ];\n            }\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    volumeId,\n                    spacingInNormal,\n                    enabledElement,\n                },\n                data: {\n                    label: '',\n                    startCoordinate: startCoord,\n                    endCoordinate: endCoord,\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points,\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {\n                        pointsInVolume: [],\n                        projectionPoints: [],\n                        statistics: [],\n                    },\n                    labelmapUID: null,\n                },\n            };\n            this._computeProjectionPoints(annotation, imageVolume);\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { metadata } = annotation;\n            const { enabledElement } = metadata;\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            const targetId = this.getTargetId(enabledElement.viewport);\n            const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n            this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            else {\n                triggerAnnotationModified(annotation, element);\n            }\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            let annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = filterAnnotationsWithinSamePlane(annotations, viewport.getCamera());\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data, metadata } = annotation;\n                const { startCoordinate, endCoordinate } = data;\n                const { points, activeHandleIndex } = data.handles;\n                const { enabledElement: annotationEnabledElement } = metadata;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                const radius = getCanvasCircleRadius([\n                    canvasCoordinates[0],\n                    canvasCoordinates[1],\n                ]);\n                const { centerPointRadius } = this.configuration;\n                const canvasCorners = getCanvasCircleCorners([\n                    canvasCoordinates[0],\n                    canvasCoordinates[1],\n                ]);\n                const focalPoint = viewport.getCamera().focalPoint;\n                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;\n                let tempStartCoordinate = startCoordinate;\n                let tempEndCoordinate = endCoordinate;\n                if (Array.isArray(startCoordinate)) {\n                    tempStartCoordinate = this._getCoordinateForViewplaneNormal(tempStartCoordinate, viewplaneNormal);\n                    data.startCoordinate = tempStartCoordinate;\n                }\n                if (Array.isArray(endCoordinate)) {\n                    tempEndCoordinate = this._getCoordinateForViewplaneNormal(tempEndCoordinate, viewplaneNormal);\n                    data.endCoordinate = tempEndCoordinate;\n                }\n                const roundedStartCoordinate = coreUtils.roundToPrecision(data.startCoordinate);\n                const roundedEndCoordinate = coreUtils.roundToPrecision(data.endCoordinate);\n                const cameraCoordinate = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);\n                const roundedCameraCoordinate = coreUtils.roundToPrecision(cameraCoordinate);\n                if (roundedCameraCoordinate <\n                    Math.min(roundedStartCoordinate, roundedEndCoordinate) ||\n                    roundedCameraCoordinate >\n                        Math.max(roundedStartCoordinate, roundedEndCoordinate)) {\n                    continue;\n                }\n                const middleCoordinate = coreUtils.roundToPrecision((data.startCoordinate + data.endCoordinate) / 2);\n                let isMiddleSlice = false;\n                if (roundedCameraCoordinate === middleCoordinate) {\n                    isMiddleSlice = true;\n                }\n                data.handles.points[0][this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal)] = middleCoordinate;\n                const iteratorVolumeIDs = annotationEnabledElement.viewport?.volumeIds.values();\n                for (const volumeId of iteratorVolumeIDs) {\n                    if (annotation.invalidated &&\n                        annotation.metadata.volumeId === volumeId) {\n                        this._throttledCalculateCachedStats(annotation, annotationEnabledElement);\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null &&\n                    isMiddleSlice) {\n                    if (this.configuration.simplified) {\n                        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                    }\n                    else {\n                        activeHandleCanvasCoords = canvasCoordinates;\n                    }\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                let lineWidthToUse = lineWidth;\n                let lineDashToUse = lineDash;\n                if (isMiddleSlice) {\n                    lineWidthToUse = lineWidth;\n                    lineDashToUse = [];\n                }\n                else {\n                    lineDashToUse = [5, 5];\n                }\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineDash: lineDashToUse,\n                    lineWidth: lineWidthToUse,\n                });\n                if (centerPointRadius > 0) {\n                    if (radius > 3 * centerPointRadius) {\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                if (this.configuration.showTextBox) {\n                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                    if (!options.visibility) {\n                        data.handles.textBox = {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        };\n                        continue;\n                    }\n                    const textLines = this.configuration.getTextLines(data, { metadata });\n                    if (!textLines || textLines.length === 0) {\n                        continue;\n                    }\n                    let canvasTextBoxCoords;\n                    if (!data.handles.textBox.hasMoved) {\n                        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                        data.handles.textBox.worldPosition =\n                            viewport.canvasToWorld(canvasTextBoxCoords);\n                    }\n                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                    const textBoxUID = '1';\n                    const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, [canvasCoordinates[0], canvasCoordinates[1]], {}, options);\n                    const { x: left, y: top, width, height } = boundingBox;\n                    data.handles.textBox.worldBoundingBox = {\n                        topLeft: viewport.canvasToWorld([left, top]),\n                        topRight: viewport.canvasToWorld([left + width, top]),\n                        bottomLeft: viewport.canvasToWorld([left, top + height]),\n                        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                    };\n                }\n            }\n            return renderStatus;\n        };\n        if (this.configuration.calculatePointsInsideVolume) {\n            this._throttledCalculateCachedStats = throttle(this._calculateCachedStatsTool, this.configuration.throttleTimeout, { trailing: true });\n        }\n        else {\n            this._throttledCalculateCachedStats = debounce(this._calculateCachedStatsTool, this.configuration.throttleTimeout);\n        }\n    }\n    _computeProjectionPoints(annotation, imageVolume) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, spacingInNormal } = metadata;\n        const { startCoordinate, endCoordinate } = data;\n        const { points } = data.handles;\n        const projectionAxisIndex = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n        const startWorld = vec3.clone(points[0]);\n        startWorld[projectionAxisIndex] = startCoordinate;\n        const endWorld = vec3.clone(points[0]);\n        endWorld[projectionAxisIndex] = endCoordinate;\n        const direction = vec3.create();\n        vec3.subtract(direction, endWorld, startWorld);\n        const distance = vec3.length(direction);\n        if (distance === 0) {\n            const handlesOnStartPlane = points.map((p) => {\n                const newPoint = vec3.clone(p);\n                newPoint[projectionAxisIndex] = startCoordinate;\n                return Array.from(newPoint);\n            });\n            data.cachedStats.projectionPoints = [handlesOnStartPlane];\n            return;\n        }\n        vec3.normalize(direction, direction);\n        const handlesToStart = csUtils.deepClone(points);\n        handlesToStart[0][projectionAxisIndex] = startCoordinate;\n        handlesToStart[1][projectionAxisIndex] = startCoordinate;\n        const newProjectionPoints = [];\n        for (let dist = 0; dist <= distance + 1e-6; dist += spacingInNormal) {\n            newProjectionPoints.push(handlesToStart.map((point) => {\n                const newPoint = vec3.create();\n                vec3.scaleAndAdd(newPoint, point, direction, dist);\n                return Array.from(newPoint);\n            }));\n        }\n        data.cachedStats.projectionPoints = newProjectionPoints;\n    }\n    _computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, viewUp } = metadata;\n        const { viewport } = enabledElement;\n        const projectionPoints = data.cachedStats.projectionPoints;\n        const pointsInsideVolume = [[]];\n        const image = this.getTargetImageData(targetId);\n        const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n        const baseTopLeftCanvas = getCanvasCircleCorners([\n            canvasCoordinates[0],\n            canvasCoordinates[1],\n        ])[0];\n        const baseBottomRightCanvas = getCanvasCircleCorners([\n            canvasCoordinates[0],\n            canvasCoordinates[1],\n        ])[1];\n        const basePos1 = viewport.canvasToWorld(baseTopLeftCanvas);\n        const basePos2 = viewport.canvasToWorld(baseBottomRightCanvas);\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, basePos1, basePos2);\n        const measureInfo = getCalibratedLengthUnitsAndScale(image, data.handles.points);\n        const aspect = getCalibratedAspect(image);\n        const area = Math.abs(Math.PI *\n            (worldWidth / measureInfo.scale / 2) *\n            (worldHeight / aspect / measureInfo.scale / 2));\n        const modalityUnitOptions = {\n            isPreScaled: isViewportPreScaled(viewport, targetId),\n            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n        };\n        const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);\n        for (let i = 0; i < projectionPoints.length; i++) {\n            if (!imageVolume) {\n                continue;\n            }\n            const centerWorld = projectionPoints[i][0];\n            const currentCanvasCoordinates = projectionPoints[i].map((p) => viewport.worldToCanvas(p));\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasCircleCorners([\n                currentCanvasCoordinates[0],\n                currentCanvasCoordinates[1],\n            ]));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            const { dimensions, imageData, voxelManager } = imageVolume;\n            const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n            const worldProjectionPointIndex = transformWorldToIndex(imageData, centerWorld);\n            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n            worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n            worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n            worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n            worldPos1Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n            worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n            worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n            worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n            worldPos2Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                const boundsIJK = [\n                    [iMin, iMax],\n                    [jMin, jMax],\n                    [kMin, kMax],\n                ];\n                const center = centerWorld;\n                const ellipseObj = {\n                    center,\n                    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n                    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n                    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n                };\n                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                    isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS),\n                    boundsIJK,\n                    imageData,\n                    returnPoints: this.configuration.storePointData,\n                });\n                pointsInsideVolume.push(pointsInShape);\n            }\n        }\n        const stats = this.configuration.statsCalculator.getStatistics();\n        data.cachedStats.pointsInVolume = pointsInsideVolume;\n        data.cachedStats.statistics = {\n            Modality: metadata.Modality,\n            area,\n            mean: stats.mean?.value,\n            stdDev: stats.stdDev?.value,\n            max: stats.max?.value,\n            statsArray: stats.array,\n            areaUnit: measureInfo.areaUnit,\n            modalityUnit,\n        };\n    }\n    _calculateCachedStatsTool(annotation, enabledElement) {\n        const data = annotation.data;\n        const { viewport } = enabledElement;\n        const { cachedStats } = data;\n        const targetId = this.getTargetId(viewport);\n        const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n        this._computeProjectionPoints(annotation, imageVolume);\n        this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);\n        annotation.invalidated = false;\n        triggerAnnotationModified(annotation, viewport.element);\n        return cachedStats;\n    }\n    _getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {\n        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n        const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);\n        const startPos = vec3.create();\n        vec3.scaleAndAdd(startPos, worldPos, viewPlaneNormal, numSlicesToPropagateFromStart * -spacingInNormal);\n        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);\n        return startCoord;\n    }\n    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {\n        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n        const numSlicesToPropagateToEnd = numSlicesToPropagate - Math.round(numSlicesToPropagate / 2);\n        const endPos = vec3.create();\n        vec3.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagateToEnd * spacingInNormal);\n        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);\n        return endCoord;\n    }\n    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {\n        const viewplaneNormalAbs = [\n            Math.abs(viewPlaneNormal[0]),\n            Math.abs(viewPlaneNormal[1]),\n            Math.abs(viewPlaneNormal[2]),\n        ];\n        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));\n        return indexOfDirection;\n    }\n    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {\n        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n        return pos[indexOfDirection];\n    }\n}\nfunction defaultGetTextLines(data, _context = {}) {\n    const cachedVolumeStats = data.cachedStats.statistics;\n    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n    if (mean === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`Area: ${csUtils.roundNumber(area)} ${areaUnit}`);\n    textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    return textLines;\n}\nCircleROIStartEndThresholdTool.toolName = 'CircleROIStartEndThreshold';\nexport default CircleROIStartEndThresholdTool;\n","import { BaseVolumeViewport, cache, getEnabledElement, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { fillInsideCircle } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { Events } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { segmentLocking, activeSegmentation, segmentIndex as segmentIndexController, config as segmentationConfig, } from '../../stateManagement/segmentation';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, } from '../../stateManagement/segmentation/segmentationState';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nclass CircleScissorsTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideCircle,\n                ERASE_INSIDE: eraseInsideCircle,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeLabelmapSegmentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeLabelmapSegmentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeLabelmapSegmentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            const { representationData } = getSegmentation(segmentationId);\n            const labelmapData = representationData.Labelmap;\n            if (!labelmapData) {\n                throw new Error('No labelmap data found for the active segmentation, create one before using scissors tool');\n            }\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    isDrawing: true,\n                    cachedStats: {},\n                },\n            };\n            const viewportIdsToRender = [viewport.id];\n            this.editData = {\n                annotation,\n                centerCanvas: canvasPos,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = labelmapData;\n                const segmentation = cache.getVolume(volumeId);\n                this.editData = {\n                    ...this.editData,\n                    volumeId,\n                    referencedVolumeId: segmentation.referencedVolumeId,\n                };\n            }\n            else {\n                const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                this.editData = {\n                    ...this.editData,\n                    imageId: segmentationImageId,\n                };\n            }\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const radius = Math.sqrt(dX * dX + dY * dY);\n            const bottomCanvas = [\n                centerCanvas[0],\n                centerCanvas[1] + radius,\n            ];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];\n            const leftCanvas = [\n                centerCanvas[0] - radius,\n                centerCanvas[1],\n            ];\n            const rightCanvas = [\n                centerCanvas[0] + radius,\n                centerCanvas[1],\n            ];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            const { viewPlaneNormal, viewUp } = annotation.metadata;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n                viewPlaneNormal,\n                viewUp,\n                createMemo: this.createMemo.bind(this),\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n            this.doneEditMemo();\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { viewportIdsToRender } = this.editData;\n            if (!viewportIdsToRender.includes(viewport.id)) {\n                return renderStatus;\n            }\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const bottom = canvasCoordinates[0];\n            const top = canvasCoordinates[1];\n            const center = [\n                Math.floor((bottom[0] + top[0]) / 2),\n                Math.floor((bottom[1] + top[1]) / 2),\n            ];\n            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const circleUID = '0';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nCircleScissorsTool.toolName = 'CircleScissor';\nexport default CircleScissorsTool;\n","import { Events, SegmentationRepresentations } from '../../enums';\nimport { eventTarget, utilities, getRenderingEngine, } from '@cornerstonejs/core';\nimport PlanarFreehandContourSegmentationTool from '../annotation/PlanarFreehandContourSegmentationTool';\nimport BrushTool from './BrushTool';\nimport * as segmentation from '../../stateManagement/segmentation';\nimport { getSegmentationRepresentationsBySegmentationId } from '../../stateManagement/segmentation/getSegmentationRepresentation';\nclass LabelMapEditWithContourTool extends PlanarFreehandContourSegmentationTool {\n    static { this.toolName = 'LabelMapEditWithContour'; }\n    static { this.annotationsToViewportMap = new Map(); }\n    static { this.viewportIdsChecked = []; }\n    constructor(toolProps = {}) {\n        const initialProps = utilities.deepMerge({\n            configuration: {\n                calculateStats: false,\n                allowOpenContours: false,\n            },\n        }, toolProps);\n        super(initialProps);\n        this.onViewportAddedToToolGroupBinded =\n            this.onViewportAddedToToolGroup.bind(this);\n        this.onSegmentationModifiedBinded = this.onSegmentationModified.bind(this);\n    }\n    initializeListeners() {\n        LabelMapEditWithContourTool.annotationsToViewportMap.clear();\n        LabelMapEditWithContourTool.viewportIdsChecked = [];\n        eventTarget.addEventListener(Events.ANNOTATION_MODIFIED, this.annotationModified);\n        eventTarget.addEventListener(Events.ANNOTATION_COMPLETED, this.annotationCompleted);\n        eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this.onViewportAddedToToolGroupBinded);\n        eventTarget.addEventListener(Events.SEGMENTATION_MODIFIED, this.onSegmentationModifiedBinded);\n        eventTarget.addEventListener(Events.SEGMENTATION_REPRESENTATION_MODIFIED, this.onSegmentationModifiedBinded);\n    }\n    cleanUpListeners() {\n        LabelMapEditWithContourTool.annotationsToViewportMap.clear();\n        LabelMapEditWithContourTool.viewportIdsChecked = [];\n        eventTarget.removeEventListener(Events.ANNOTATION_MODIFIED, this.annotationModified);\n        eventTarget.removeEventListener(Events.ANNOTATION_COMPLETED, this.annotationCompleted);\n        eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this.onViewportAddedToToolGroup.bind(this));\n        eventTarget.removeEventListener(Events.SEGMENTATION_MODIFIED, this.onSegmentationModified.bind(this));\n        eventTarget.removeEventListener(Events.SEGMENTATION_REPRESENTATION_MODIFIED, this.onSegmentationModified.bind(this));\n    }\n    async checkContourSegmentation(viewportId) {\n        if (LabelMapEditWithContourTool.viewportIdsChecked.includes(viewportId)) {\n            return;\n        }\n        const activeSeg = segmentation.getActiveSegmentation(viewportId);\n        if (!activeSeg) {\n            console.log('No active segmentation detected');\n            return false;\n        }\n        const segmentationId = activeSeg.segmentationId;\n        if (!activeSeg.representationData.Contour) {\n            LabelMapEditWithContourTool.viewportIdsChecked.push(viewportId);\n            await segmentation.addContourRepresentationToViewport(viewportId, [\n                {\n                    segmentationId,\n                    type: SegmentationRepresentations.Contour,\n                },\n            ]);\n            segmentation.addRepresentationData({\n                segmentationId,\n                type: SegmentationRepresentations.Contour,\n                data: {},\n            });\n        }\n        else {\n            LabelMapEditWithContourTool.viewportIdsChecked.push(viewportId);\n        }\n        return true;\n    }\n    onViewportAddedToToolGroup(evt) {\n        const { toolGroupId, viewportId } = evt.detail;\n        if (toolGroupId !== this.toolGroupId) {\n            return;\n        }\n        this.checkContourSegmentation(viewportId);\n    }\n    onSegmentationModified(evt) {\n        const { segmentationId } = evt.detail || {};\n        if (!segmentationId) {\n            return;\n        }\n        const representations = getSegmentationRepresentationsBySegmentationId(segmentationId);\n        if (!representations) {\n            return;\n        }\n        representations.forEach(async ({ viewportId }) => await this.checkContourSegmentation(viewportId));\n    }\n    onSetToolEnabled() {\n        this.initializeListeners();\n    }\n    onSetToolActive() {\n        this.initializeListeners();\n    }\n    onSetToolDisabled() {\n        this.cleanUpListeners();\n    }\n    annotationModified(evt) {\n        const { annotation, renderingEngineId, viewportId } = evt.detail;\n        const viewport = getRenderingEngine(renderingEngineId)?.getViewport(viewportId);\n        if (!viewport) {\n            return;\n        }\n        LabelMapEditWithContourTool.annotationsToViewportMap.set(annotation.annotationUID, viewport);\n    }\n    annotationCompleted(evt) {\n        const { annotation } = evt.detail;\n        const { polyline } = annotation.data?.contour || {};\n        if (annotation?.metadata?.toolName !== LabelMapEditWithContourTool.toolName) {\n            return;\n        }\n        if (!polyline) {\n            return;\n        }\n        if (LabelMapEditWithContourTool.annotationsToViewportMap.has(annotation.annotationUID)) {\n            const viewport = LabelMapEditWithContourTool.annotationsToViewportMap.get(annotation.annotationUID);\n            if (polyline.length > 3) {\n                BrushTool.viewportContoursToLabelmap(viewport);\n            }\n        }\n    }\n}\nexport default LabelMapEditWithContourTool;\n","import { cache, getEnabledElement, utilities as csUtils, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { segmentLocking, activeSegmentation, segmentIndex as segmentIndexController, } from '../../stateManagement/segmentation';\nimport floodFill from '../../utilities/segmentation/floodFill';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, } from '../../stateManagement/segmentation/segmentationState';\nconst { transformWorldToIndex, isEqual } = csUtils;\nclass PaintFillTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal } = camera;\n            const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeSegmentationRepresentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeSegmentationRepresentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const { representationData } = getSegmentation(segmentationId);\n            let dimensions;\n            let direction;\n            let index;\n            let voxelManager;\n            this.doneEditMemo();\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = representationData[SegmentationRepresentations.Labelmap];\n                const segmentation = cache.getVolume(volumeId);\n                ({ dimensions, direction } = segmentation);\n                voxelManager = segmentation.voxelManager;\n                index = transformWorldToIndex(segmentation.imageData, worldPos);\n            }\n            else {\n                const currentSegmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                if (!currentSegmentationImageId) {\n                    throw new Error('No active segmentation imageId detected, create one before using scissors tool');\n                }\n                const { imageData } = viewport.getImageData();\n                dimensions = imageData.getDimensions();\n                direction = imageData.getDirection();\n                const image = cache.getImage(currentSegmentationImageId);\n                voxelManager = image.voxelManager;\n                index = transformWorldToIndex(imageData, worldPos);\n            }\n            const fixedDimension = this.getFixedDimension(viewPlaneNormal, direction);\n            if (fixedDimension === undefined) {\n                console.warn('Oblique paint fill not yet supported');\n                return;\n            }\n            const { floodFillGetter, getLabelValue, getScalarDataPositionFromPlane, inPlaneSeedPoint, fixedDimensionValue, } = this.generateHelpers(voxelManager, dimensions, index, fixedDimension);\n            if (index[0] < 0 ||\n                index[0] >= dimensions[0] ||\n                index[1] < 0 ||\n                index[1] >= dimensions[1] ||\n                index[2] < 0 ||\n                index[2] >= dimensions[2]) {\n                return;\n            }\n            const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);\n            if (segmentsLocked.includes(clickedLabelValue)) {\n                return;\n            }\n            const floodFillResult = floodFill(floodFillGetter, inPlaneSeedPoint);\n            const { flooded } = floodFillResult;\n            flooded.forEach((index) => {\n                const scalarDataIndex = getScalarDataPositionFromPlane(index[0], index[1]);\n                voxelManager.setAtIndex(scalarDataIndex, segmentIndex);\n            });\n            const framesModified = this.getFramesModified(fixedDimension, fixedDimensionValue, floodFillResult);\n            triggerSegmentationDataModified(segmentationId, framesModified);\n            return true;\n        };\n        this.getFramesModified = (fixedDimension, fixedDimensionValue, floodFillResult) => {\n            const { flooded: boundaries } = floodFillResult;\n            if (fixedDimension === 2) {\n                return [fixedDimensionValue];\n            }\n            let minJ = Infinity;\n            let maxJ = -Infinity;\n            for (let b = 0; b < boundaries.length; b++) {\n                const j = boundaries[b][1];\n                if (j < minJ) {\n                    minJ = j;\n                }\n                if (j > maxJ) {\n                    maxJ = j;\n                }\n            }\n            const framesModified = [];\n            for (let frame = minJ; frame <= maxJ; frame++) {\n                framesModified.push(frame);\n            }\n            return framesModified;\n        };\n        this.generateHelpers = (voxelManager, dimensions, seedIndex3D, fixedDimension = 2) => {\n            let fixedDimensionValue;\n            let inPlaneSeedPoint;\n            switch (fixedDimension) {\n                case 0:\n                    fixedDimensionValue = seedIndex3D[0];\n                    inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]];\n                    break;\n                case 1:\n                    fixedDimensionValue = seedIndex3D[1];\n                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]];\n                    break;\n                case 2:\n                    fixedDimensionValue = seedIndex3D[2];\n                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]];\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            const getScalarDataPosition = (x, y, z) => {\n                return voxelManager.toIndex([x, y, z]);\n            };\n            const getLabelValue = (x, y, z) => {\n                return voxelManager.getAtIJK(x, y, z);\n            };\n            const floodFillGetter = this.generateFloodFillGetter(dimensions, fixedDimension, fixedDimensionValue, getLabelValue);\n            const getScalarDataPositionFromPlane = this.generateGetScalarDataPositionFromPlane(getScalarDataPosition, fixedDimension, fixedDimensionValue);\n            return {\n                getScalarDataPositionFromPlane,\n                getLabelValue,\n                floodFillGetter,\n                inPlaneSeedPoint,\n                fixedDimensionValue,\n            };\n        };\n        this.generateFloodFillGetter = (dimensions, fixedDimension, fixedDimensionValue, getLabelValue) => {\n            let floodFillGetter;\n            switch (fixedDimension) {\n                case 0:\n                    floodFillGetter = (y, z) => {\n                        if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {\n                            return;\n                        }\n                        return getLabelValue(fixedDimensionValue, y, z);\n                    };\n                    break;\n                case 1:\n                    floodFillGetter = (x, z) => {\n                        if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {\n                            return;\n                        }\n                        return getLabelValue(x, fixedDimensionValue, z);\n                    };\n                    break;\n                case 2:\n                    floodFillGetter = (x, y) => {\n                        if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {\n                            return;\n                        }\n                        return getLabelValue(x, y, fixedDimensionValue);\n                    };\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            return floodFillGetter;\n        };\n        this.generateGetScalarDataPositionFromPlane = (getScalarDataPosition, fixedDimension, fixedDimensionValue) => {\n            let getScalarDataPositionFromPlane;\n            switch (fixedDimension) {\n                case 0:\n                    getScalarDataPositionFromPlane = (y, z) => {\n                        return getScalarDataPosition(fixedDimensionValue, y, z);\n                    };\n                    break;\n                case 1:\n                    getScalarDataPositionFromPlane = (x, z) => {\n                        return getScalarDataPosition(x, fixedDimensionValue, z);\n                    };\n                    break;\n                case 2:\n                    getScalarDataPositionFromPlane = (x, y) => {\n                        return getScalarDataPosition(x, y, fixedDimensionValue);\n                    };\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            return getScalarDataPositionFromPlane;\n        };\n    }\n    getFixedDimension(viewPlaneNormal, direction) {\n        const xDirection = direction.slice(0, 3);\n        const yDirection = direction.slice(3, 6);\n        const zDirection = direction.slice(6, 9);\n        const absoluteOfViewPlaneNormal = [\n            Math.abs(viewPlaneNormal[0]),\n            Math.abs(viewPlaneNormal[1]),\n            Math.abs(viewPlaneNormal[2]),\n        ];\n        const absoluteOfXDirection = [\n            Math.abs(xDirection[0]),\n            Math.abs(xDirection[1]),\n            Math.abs(xDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {\n            return 0;\n        }\n        const absoluteOfYDirection = [\n            Math.abs(yDirection[0]),\n            Math.abs(yDirection[1]),\n            Math.abs(yDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {\n            return 1;\n        }\n        const absoluteOfZDirection = [\n            Math.abs(zDirection[0]),\n            Math.abs(zDirection[1]),\n            Math.abs(zDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {\n            return 2;\n        }\n    }\n}\nPaintFillTool.toolName = 'PaintFill';\nexport default PaintFillTool;\n","import { getEnabledElement, cache, StackViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { vec3 } from 'gl-matrix';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { drawHandles as drawHandlesSvg, drawRect as drawRectSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport throttle from '../../utilities/throttle';\nimport debounce from '../../utilities/debounce';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { hideElementCursor, resetElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport RectangleROITool from '../annotation/RectangleROITool';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { filterAnnotationsWithinSamePlane } from '../../utilities/planar';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nconst { transformWorldToIndex } = csUtils;\nclass RectangleROIStartEndThresholdTool extends RectangleROITool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            storePointData: false,\n            numSlicesToPropagate: 10,\n            calculatePointsInsideVolume: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n            showTextBox: false,\n            throttleTimeout: 100,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            let referencedImageId, imageVolume, volumeId;\n            if (viewport instanceof StackViewport) {\n                throw new Error('Stack Viewport Not implemented');\n            }\n            else {\n                const targetId = this.getTargetId(viewport);\n                volumeId = csUtils.getVolumeId(targetId);\n                imageVolume = cache.getVolume(volumeId);\n                referencedImageId = csUtils.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n            }\n            const spacingInNormal = csUtils.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);\n            const startCoord = this._getStartCoordinate(worldPos, viewPlaneNormal);\n            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    enabledElement,\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    toolName: this.getToolName(),\n                    volumeId,\n                    spacingInNormal,\n                },\n                data: {\n                    label: '',\n                    startCoordinate: startCoord,\n                    endCoordinate: endCoord,\n                    cachedStats: {\n                        pointsInVolume: [],\n                        projectionPoints: [],\n                        projectionPointsImageIds: [referencedImageId],\n                        statistics: [],\n                    },\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    labelmapUID: null,\n                },\n            };\n            this._computeProjectionPoints(annotation, imageVolume);\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { metadata } = annotation;\n            const { enabledElement } = metadata;\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            const targetId = this.getTargetId(enabledElement.viewport);\n            const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n            this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            else {\n                triggerAnnotationModified(annotation, element);\n            }\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            let annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = filterAnnotationsWithinSamePlane(annotations, viewport.getCamera());\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data, metadata } = annotation;\n                const { startCoordinate, endCoordinate } = data;\n                const { points, activeHandleIndex } = data.handles;\n                const { enabledElement: annotationEnabledElement } = metadata;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const focalPoint = viewport.getCamera().focalPoint;\n                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;\n                let startCoord = startCoordinate;\n                let endCoord = endCoordinate;\n                if (Array.isArray(startCoordinate)) {\n                    startCoord = this._getCoordinateForViewplaneNormal(startCoord, viewplaneNormal);\n                    const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal);\n                    data.handles.points.forEach((point) => {\n                        point[indexOfDirection] = startCoord;\n                    });\n                    data.startCoordinate = startCoord;\n                }\n                if (Array.isArray(endCoordinate)) {\n                    endCoord = this._getCoordinateForViewplaneNormal(endCoord, viewplaneNormal);\n                    data.endCoordinate = endCoord;\n                    data.endCoordinate = endCoord;\n                }\n                const roundedStartCoord = csUtils.roundToPrecision(startCoord);\n                const roundedEndCoord = csUtils.roundToPrecision(endCoord);\n                const coord = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);\n                const roundedCoord = csUtils.roundToPrecision(coord);\n                if (roundedCoord < Math.min(roundedStartCoord, roundedEndCoord) ||\n                    roundedCoord > Math.max(roundedStartCoord, roundedEndCoord)) {\n                    continue;\n                }\n                const iteratorVolumeIDs = annotationEnabledElement.viewport?.volumeIds.values();\n                for (const volumeId of iteratorVolumeIDs) {\n                    if (annotation.invalidated &&\n                        annotation.metadata.volumeId === volumeId) {\n                        this._throttledCalculateCachedStats(annotation, annotationEnabledElement);\n                    }\n                }\n                let firstOrLastSlice = false;\n                if (roundedCoord === roundedStartCoord ||\n                    roundedCoord === roundedEndCoord) {\n                    firstOrLastSlice = true;\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null &&\n                    firstOrLastSlice) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                let lineDashToUse = lineDash;\n                if (!firstOrLastSlice) {\n                    lineDashToUse = 2;\n                }\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color,\n                    lineDash: lineDashToUse,\n                    lineWidth,\n                });\n                renderStatus = true;\n                if (this.configuration.showTextBox) {\n                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                    if (!options.visibility) {\n                        data.handles.textBox = {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        };\n                        continue;\n                    }\n                    const textLines = this.configuration.getTextLines(data, { metadata });\n                    if (!textLines || textLines.length === 0) {\n                        continue;\n                    }\n                    if (!data.handles.textBox.hasMoved) {\n                        const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                        data.handles.textBox.worldPosition =\n                            viewport.canvasToWorld(canvasTextBoxCoords);\n                    }\n                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                    const textBoxUID = '1';\n                    const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                    const { x: left, y: top, width, height } = boundingBox;\n                    data.handles.textBox.worldBoundingBox = {\n                        topLeft: viewport.canvasToWorld([left, top]),\n                        topRight: viewport.canvasToWorld([left + width, top]),\n                        bottomLeft: viewport.canvasToWorld([left, top + height]),\n                        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                    };\n                }\n            }\n            return renderStatus;\n        };\n        if (this.configuration.calculatePointsInsideVolume) {\n            this._throttledCalculateCachedStats = throttle(this._calculateCachedStatsTool, this.configuration.throttleTimeout, { trailing: true });\n        }\n        else {\n            this._throttledCalculateCachedStats = debounce(this._calculateCachedStatsTool, this.configuration.throttleTimeout);\n        }\n    }\n    _computeProjectionPoints(annotation, imageVolume) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, spacingInNormal } = metadata;\n        const { imageData } = imageVolume;\n        const { startCoordinate, endCoordinate } = data;\n        const { points } = data.handles;\n        const startIJK = transformWorldToIndex(imageData, points[0]);\n        const endIJK = transformWorldToIndex(imageData, points[0]);\n        const startWorld = vec3.create();\n        imageData.indexToWorldVec3(startIJK, startWorld);\n        const endWorld = vec3.create();\n        imageData.indexToWorldVec3(endIJK, endWorld);\n        const projectionAxisIndex = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n        if (projectionAxisIndex == 2) {\n            startWorld[2] = startCoordinate;\n            endWorld[2] = endCoordinate;\n        }\n        else if (projectionAxisIndex == 0) {\n            startWorld[0] = startCoordinate;\n            endWorld[0] = endCoordinate;\n        }\n        else if (projectionAxisIndex == 1) {\n            startWorld[1] = startCoordinate;\n            endWorld[1] = endCoordinate;\n        }\n        const direction = vec3.create();\n        vec3.subtract(direction, endWorld, startWorld);\n        const distance = vec3.length(direction);\n        vec3.normalize(direction, direction);\n        const newProjectionPoints = [];\n        for (let dist = 0; dist < distance; dist += spacingInNormal) {\n            newProjectionPoints.push(points.map((point) => {\n                const newPoint = vec3.create();\n                vec3.scaleAndAdd(newPoint, point, direction, dist);\n                return Array.from(newPoint);\n            }));\n        }\n        data.cachedStats.projectionPoints = newProjectionPoints;\n    }\n    _computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, viewUp } = metadata;\n        const { viewport } = enabledElement;\n        const projectionPoints = data.cachedStats.projectionPoints;\n        const pointsInsideVolume = [[]];\n        const image = this.getTargetImageData(targetId);\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[3];\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n        const measureInfo = getCalibratedLengthUnitsAndScale(image, data.habdles);\n        const area = Math.abs(worldWidth * worldHeight) /\n            (measureInfo.scale * measureInfo.scale);\n        const modalityUnitOptions = {\n            isPreScaled: isViewportPreScaled(viewport, targetId),\n            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n        };\n        const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);\n        for (let i = 0; i < projectionPoints.length; i++) {\n            if (!imageVolume) {\n                continue;\n            }\n            const projectionPoint = projectionPoints[i][0];\n            const { dimensions, imageData, voxelManager } = imageVolume;\n            const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n            const worldProjectionPointIndex = transformWorldToIndex(imageData, projectionPoint);\n            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n            worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n            worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n            worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n            worldPos1Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n            worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n            worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n            worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n            worldPos2Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                this.isHandleOutsideImage = false;\n                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                const boundsIJK = [\n                    [iMin, iMax],\n                    [jMin, jMax],\n                    [kMin, kMax],\n                ];\n                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                    boundsIJK,\n                    imageData,\n                    returnPoints: this.configuration.storePointData,\n                });\n                pointsInsideVolume.push(pointsInShape);\n            }\n        }\n        const stats = this.configuration.statsCalculator.getStatistics();\n        data.cachedStats.pointsInVolume = pointsInsideVolume;\n        data.cachedStats.statistics = {\n            Modality: metadata.Modality,\n            area,\n            mean: stats.mean?.value,\n            stdDev: stats.stdDev?.value,\n            max: stats.max?.value,\n            statsArray: stats.array,\n            areaUnit: measureInfo.areaUnit,\n            modalityUnit,\n        };\n    }\n    _calculateCachedStatsTool(annotation, enabledElement) {\n        const data = annotation.data;\n        const { viewport } = enabledElement;\n        const { cachedStats } = data;\n        const targetId = this.getTargetId(viewport);\n        const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n        this._computeProjectionPoints(annotation, imageVolume);\n        this._computePointsInsideVolume(annotation, targetId, imageVolume, enabledElement);\n        annotation.invalidated = false;\n        triggerAnnotationModified(annotation, viewport.element);\n        return cachedStats;\n    }\n    _getStartCoordinate(worldPos, viewPlaneNormal) {\n        const startPos = worldPos;\n        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);\n        return startCoord;\n    }\n    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {\n        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n        const endPos = vec3.create();\n        vec3.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagate * spacingInNormal);\n        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);\n        return endCoord;\n    }\n    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {\n        const viewplaneNormalAbs = [\n            Math.abs(viewPlaneNormal[0]),\n            Math.abs(viewPlaneNormal[1]),\n            Math.abs(viewPlaneNormal[2]),\n        ];\n        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));\n        return indexOfDirection;\n    }\n    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {\n        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n        return pos[indexOfDirection];\n    }\n}\nfunction defaultGetTextLines(data, _context = {}) {\n    const cachedVolumeStats = data.cachedStats.statistics;\n    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n    if (mean === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`Area: ${csUtils.roundNumber(area)} ${areaUnit}`);\n    textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    return textLines;\n}\nRectangleROIStartEndThresholdTool.toolName = 'RectangleROIStartEndThreshold';\nexport default RectangleROIStartEndThresholdTool;\n","import { getEnabledElement, cache, StackViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { drawHandles as drawHandlesSvg, drawRect as drawRectSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport RectangleROITool from '../annotation/RectangleROITool';\nclass RectangleROIThresholdTool extends RectangleROITool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const targetId = this.getTargetId(viewport);\n            let referencedImageId, volumeId;\n            if (viewport instanceof StackViewport) {\n                referencedImageId = targetId.split('imageId:')[1];\n            }\n            else {\n                volumeId = csUtils.getVolumeId(targetId);\n                const imageVolume = cache.getVolume(volumeId);\n                referencedImageId = csUtils.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n            }\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    enabledElement,\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    toolName: this.getToolName(),\n                    volumeId,\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: null,\n                            worldBoundingBox: null,\n                        },\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    segmentationId: null,\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                triggerAnnotationModified(annotation, element);\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                });\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n    }\n}\nRectangleROIThresholdTool.toolName = 'RectangleROIThreshold';\nexport default RectangleROIThresholdTool;\n","import { BaseVolumeViewport, cache, getEnabledElement, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { fillInsideRectangle } from './strategies/fillRectangle';\nimport { eraseInsideRectangle } from './strategies/eraseRectangle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawRect as drawRectSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { config as segmentationConfig, segmentLocking, segmentIndex as segmentIndexController, activeSegmentation, } from '../../stateManagement/segmentation';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, } from '../../stateManagement/segmentation/segmentationState';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nclass RectangleScissorsTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideRectangle,\n                ERASE_INSIDE: eraseInsideRectangle,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeLabelmapSegmentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeLabelmapSegmentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeLabelmapSegmentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            const { representationData } = getSegmentation(segmentationId);\n            const labelmapData = representationData[SegmentationRepresentations.Labelmap];\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                },\n            };\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = labelmapData;\n                const segmentation = cache.getVolume(volumeId);\n                this.editData = {\n                    ...this.editData,\n                    volumeId,\n                    referencedVolumeId: segmentation.referencedVolumeId,\n                };\n            }\n            else {\n                const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                this.editData = {\n                    ...this.editData,\n                    imageId: segmentationImageId,\n                };\n            }\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n            const { data } = annotation;\n            const { currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n            const worldPos = currentPoints.world;\n            const { points } = data.handles;\n            points[handleIndex] = [...worldPos];\n            let bottomLeftCanvas;\n            let bottomRightCanvas;\n            let topLeftCanvas;\n            let topRightCanvas;\n            let bottomLeftWorld;\n            let bottomRightWorld;\n            let topLeftWorld;\n            let topRightWorld;\n            switch (handleIndex) {\n                case 0:\n                case 3:\n                    bottomLeftCanvas = worldToCanvas(points[0]);\n                    topRightCanvas = worldToCanvas(points[3]);\n                    bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                    topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                    bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                    topLeftWorld = canvasToWorld(topLeftCanvas);\n                    points[1] = bottomRightWorld;\n                    points[2] = topLeftWorld;\n                    break;\n                case 1:\n                case 2:\n                    bottomRightCanvas = worldToCanvas(points[1]);\n                    topLeftCanvas = worldToCanvas(points[2]);\n                    bottomLeftCanvas = [\n                        topLeftCanvas[0],\n                        bottomRightCanvas[1],\n                    ];\n                    topRightCanvas = [bottomRightCanvas[0], topLeftCanvas[1]];\n                    bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                    topRightWorld = canvasToWorld(topRightCanvas);\n                    points[0] = bottomLeftWorld;\n                    points[3] = topRightWorld;\n                    break;\n            }\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n                createMemo: this.createMemo.bind(this),\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n            this.doneEditMemo();\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const rectangleUID = '0';\n            drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nRectangleScissorsTool.toolName = 'RectangleScissor';\nexport default RectangleScissorsTool;\n","import { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, utilities, } from '@cornerstonejs/core';\nimport { addAnnotation, getAllAnnotations, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { drawLine as drawLineSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport BidirectionalTool from '../annotation/BidirectionalTool';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nclass SegmentBidirectionalTool extends BidirectionalTool {\n    static { this.toolName = 'SegmentBidirectional'; }\n    constructor(toolProps = {}) {\n        super(toolProps);\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = true;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const viewportId = viewport.id;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { segmentIndex, segmentationId } = annotation.metadata;\n                const { lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const colorArray = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n                const color = `rgb(${colorArray.slice(0, 3).join(',')})`;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        width: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId1 = `${annotationUID}-line-1`;\n                const dataId2 = `${annotationUID}-line-2`;\n                const lineUID = '0';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId1);\n                const secondLineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {\n                    color,\n                    lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId2);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                options.color = color;\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const worldPos = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        this.isDrawing = true;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const annotation = {\n            highlighted: true,\n            invalidated: true,\n            metadata: {\n                toolName: this.getToolName(),\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...viewport.getViewReference({ points: [worldPos] }),\n            },\n            data: {\n                handles: {\n                    points: [\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                    ],\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n        };\n        addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex: 1,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n        };\n        this._activateDraw(element);\n        hideElementCursor(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    static { this.hydrate = (viewportId, axis, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const existingAnnotations = getAllAnnotations();\n        const toolAnnotations = existingAnnotations.filter((annotation) => annotation.metadata.toolName === 'SegmentBidirectional');\n        const existingAnnotation = toolAnnotations.find((annotation) => {\n            const { metadata } = annotation;\n            if (metadata.segmentIndex === options?.segmentIndex &&\n                metadata.segmentationId === options?.segmentationId) {\n                return true;\n            }\n            return false;\n        });\n        if (existingAnnotation) {\n            removeAnnotation(existingAnnotation.annotationUID);\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, } = this.hydrateBase(SegmentBidirectionalTool, enabledElement, axis[0], options);\n        const [majorAxis, minorAxis] = axis;\n        const [major0, major1] = majorAxis;\n        const [minor0, minor1] = minorAxis;\n        const points = [major0, major1, minor0, minor1];\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                },\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                segmentIndex: options?.segmentIndex,\n                segmentationId: options?.segmentationId,\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n        return annotation;\n    }; }\n}\nexport default SegmentBidirectionalTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { config as segmentationConfig } from '../../stateManagement/segmentation';\nimport { BaseTool } from '../base';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/activeSegmentation';\nimport { getSegmentIndexAtWorldPoint } from '../../utilities/segmentation';\nimport { state } from '../../store/state';\nimport { drawTextBox as drawTextBoxSvg } from '../../drawingSvg';\nclass SegmentLabelTool extends BaseTool {\n    constructor(toolProps = {\n        data: {\n            handles: {\n                textBox: {\n                    worldPosition: [0, 0, 0],\n                    worldBoundingBox: {\n                        topLeft: [0, 0, 0],\n                        topRight: [0, 0, 0],\n                        bottomLeft: [0, 0, 0],\n                        bottomRight: [0, 0, 0],\n                    },\n                },\n            },\n        },\n    }, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            hoverTimeout: 100,\n            searchRadius: 6,\n            color: null,\n            background: null,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseMoveCallback = (evt) => {\n            if (this.hoverTimer) {\n                clearTimeout(this.hoverTimer);\n            }\n            this.hoverTimer = setTimeout(() => {\n                this._setHoveredSegment(evt);\n                this.hoverTimer = null;\n            }, this.configuration.hoverTimeout);\n            return true;\n        };\n        this.onSetToolEnabled = () => {\n            this.onSetToolActive();\n        };\n        this.onSetToolActive = () => {\n            this.hoverTimer = null;\n        };\n        this.onSetToolDisabled = () => {\n            this.hoverTimer = null;\n        };\n        this.data = toolProps.data ?? {\n            handles: {\n                textBox: {\n                    worldPosition: [0, 0, 0],\n                    worldBoundingBox: {\n                        topLeft: [0, 0, 0],\n                        topRight: [0, 0, 0],\n                        bottomLeft: [0, 0, 0],\n                        bottomRight: [0, 0, 0],\n                    },\n                },\n            },\n        };\n        this.hoverTimer = null;\n    }\n    _setHoveredSegment(evt = {}) {\n        if (state.isInteractingWithTool) {\n            return;\n        }\n        const { element, currentPoints } = evt.detail;\n        const worldPoint = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const activeSegmentation = getActiveSegmentation(viewport.id);\n        if (!activeSegmentation) {\n            return;\n        }\n        this._setHoveredSegmentForType(activeSegmentation, worldPoint, viewport);\n    }\n    _setHoveredSegmentForType(activeSegmentation, worldPoint, viewport) {\n        const imageDataInfo = viewport.getImageData();\n        if (!imageDataInfo) {\n            return;\n        }\n        const { segmentationId } = activeSegmentation;\n        const hoveredSegmentIndex = getSegmentIndexAtWorldPoint(segmentationId, worldPoint, {\n            viewport,\n        });\n        const segment = activeSegmentation.segments[hoveredSegmentIndex];\n        const color = this.configuration.color ??\n            segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, hoveredSegmentIndex);\n        const label = segment?.label;\n        const canvasCoordinates = viewport.worldToCanvas(worldPoint);\n        this._editData = {\n            hoveredSegmentIndex,\n            hoveredSegmentLabel: label,\n            canvasCoordinates,\n            color,\n        };\n        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {\n            return;\n        }\n        const renderingEngine = viewport.getRenderingEngine();\n        const viewportIds = renderingEngine.getViewports().map((v) => v.id);\n        triggerSegmentationModified(segmentationId);\n        triggerAnnotationRenderForViewportIds(viewportIds);\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this._editData) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const { hoveredSegmentIndex, hoveredSegmentLabel, canvasCoordinates, color, } = this._editData;\n        if (!hoveredSegmentIndex) {\n            return;\n        }\n        const offset = -15;\n        const textBoxPosition = [\n            canvasCoordinates[0] + offset,\n            canvasCoordinates[1] + offset,\n        ];\n        const boundingBox = drawTextBoxSvg(svgDrawingHelper, 'segmentSelectLabelAnnotation', 'segmentSelectLabelTextBox', [hoveredSegmentLabel ?? '(unnamed segment)'], textBoxPosition, {\n            color: `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]})`,\n            background: this.configuration.background ?? undefined,\n        });\n        const left = canvasCoordinates[0];\n        const top = canvasCoordinates[1];\n        const { width, height } = boundingBox;\n        this.data.handles.textBox.worldBoundingBox = {\n            topLeft: viewport.canvasToWorld([left, top]),\n            topRight: viewport.canvasToWorld([left + width, top]),\n            bottomLeft: viewport.canvasToWorld([left, top + height]),\n            bottomRight: viewport.canvasToWorld([left + width, top + height]),\n        };\n    }\n}\nSegmentLabelTool.toolName = 'SegmentLabelTool';\nexport default SegmentLabelTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/activeSegmentation';\nimport { setActiveSegmentIndex } from '../../stateManagement/segmentation/segmentIndex';\nimport { getHoveredContourSegmentationAnnotation, getSegmentIndexAtLabelmapBorder, getSegmentIndexAtWorldPoint, } from '../../utilities/segmentation';\nimport { state } from '../../store/state';\nimport { ToolModes } from '../../enums';\nclass SegmentSelectTool extends BaseTool {\n    static { this.SelectMode = {\n        Inside: 'Inside',\n        Border: 'Border',\n    }; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            hoverTimeout: 100,\n            mode: SegmentSelectTool.SelectMode.Border,\n            searchRadius: 6,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode !== ToolModes.Active) {\n                return;\n            }\n            if (this.hoverTimer) {\n                clearTimeout(this.hoverTimer);\n            }\n            this.hoverTimer = setTimeout(() => {\n                this._setActiveSegment(evt);\n                this.hoverTimer = null;\n            }, this.configuration.hoverTimeout);\n            return true;\n        };\n        this.onSetToolEnabled = () => {\n            this.onSetToolActive();\n        };\n        this.onSetToolActive = () => {\n            this.hoverTimer = null;\n        };\n        this.onSetToolDisabled = () => {\n            this.hoverTimer = null;\n        };\n        this.hoverTimer = null;\n    }\n    _setActiveSegment(evt = {}) {\n        if (state.isInteractingWithTool) {\n            return;\n        }\n        const { element, currentPoints } = evt.detail;\n        const worldPoint = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const activeSegmentation = getActiveSegmentation(viewport.id);\n        if (!activeSegmentation) {\n            return;\n        }\n        this._setActiveSegmentForType(activeSegmentation, worldPoint, viewport);\n    }\n    _setActiveSegmentForType(activeSegmentation, worldPoint, viewport) {\n        const imageDataInfo = viewport.getImageData();\n        if (!imageDataInfo) {\n            return;\n        }\n        const { segmentationId, representationData } = activeSegmentation;\n        let hoveredSegmentIndex;\n        if (this.configuration.mode === SegmentSelectTool.SelectMode.Inside) {\n            hoveredSegmentIndex = getSegmentIndexAtWorldPoint(segmentationId, worldPoint, {\n                viewport,\n            });\n        }\n        else {\n            if (representationData.Labelmap) {\n                hoveredSegmentIndex = getSegmentIndexAtLabelmapBorder(segmentationId, worldPoint, {\n                    viewport,\n                    searchRadius: this.configuration.searchRadius,\n                });\n            }\n            else if (representationData.Contour) {\n                hoveredSegmentIndex =\n                    getHoveredContourSegmentationAnnotation(segmentationId);\n            }\n            else if (representationData.Surface) {\n            }\n        }\n        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {\n            return;\n        }\n        setActiveSegmentIndex(segmentationId, hoveredSegmentIndex);\n        const renderingEngine = viewport.getRenderingEngine();\n        const viewportIds = renderingEngine.getViewports().map((v) => v.id);\n        triggerSegmentationModified(segmentationId);\n        triggerAnnotationRenderForViewportIds(viewportIds);\n    }\n}\nSegmentSelectTool.toolName = 'SegmentSelectTool';\nexport default SegmentSelectTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { fillInsideSphere } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { config as segmentationConfig, segmentLocking, segmentIndex as segmentIndexController, activeSegmentation, } from '../../stateManagement/segmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nclass SphereScissorsTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideSphere,\n                ERASE_INSIDE: eraseInsideSphere,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            this.doneEditMemo();\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeSegmentationRepresentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeSegmentationRepresentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            this.isDrawing = true;\n            const annotation = {\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    invalidated: true,\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                    highlighted: true,\n                },\n            };\n            const viewportIdsToRender = [viewport.id];\n            this.editData = {\n                annotation,\n                centerCanvas: canvasPos,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                toolGroupId: this.toolGroupId,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            const { representationData } = getSegmentation(segmentationId);\n            const editData = this.getEditData({\n                viewport,\n                representationData,\n                segmentsLocked,\n                segmentationId,\n            });\n            this.editData = {\n                ...this.editData,\n                ...editData,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const radius = Math.sqrt(dX * dX + dY * dY);\n            const bottomCanvas = [\n                centerCanvas[0],\n                centerCanvas[1] + radius,\n            ];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];\n            const leftCanvas = [\n                centerCanvas[0] - radius,\n                centerCanvas[1],\n            ];\n            const rightCanvas = [\n                centerCanvas[0] + radius,\n                centerCanvas[1],\n            ];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved, segmentIndex, segmentsLocked, } = this.editData;\n            const { data } = annotation;\n            const { viewPlaneNormal, viewUp } = annotation.metadata;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n                segmentIndex,\n                segmentsLocked,\n                viewPlaneNormal,\n                viewUp,\n                createMemo: this.createMemo.bind(this),\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n            this.doneEditMemo();\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { viewportIdsToRender } = this.editData;\n            if (!viewportIdsToRender.includes(viewport.id)) {\n                return renderStatus;\n            }\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const bottom = canvasCoordinates[0];\n            const top = canvasCoordinates[1];\n            const center = [\n                Math.floor((bottom[0] + top[0]) / 2),\n                Math.floor((bottom[1] + top[1]) / 2),\n            ];\n            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const circleUID = '0';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nSphereScissorsTool.toolName = 'SphereScissor';\nexport default SphereScissorsTool;\n","import { cache, utilities as csUtils } from '@cornerstonejs/core';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport { getSegmentation } from '../../../../stateManagement/segmentation/getSegmentation';\nimport getOrCreateImageVolume from '../../../../utilities/segmentation/getOrCreateImageVolume';\nexport default {\n    [StrategyCallbacks.EnsureImageVolumeFor3DManipulation]: (data) => {\n        const { operationData, viewport } = data;\n        let referencedImageIds;\n        if (viewport) {\n            referencedImageIds = viewport.getImageIds();\n            const isValidVolumeForSphere = csUtils.isValidVolume(referencedImageIds);\n            if (!isValidVolumeForSphere) {\n                throw new Error('Volume is not reconstructable for sphere manipulation');\n            }\n        }\n        else {\n            const segmentation = getSegmentation(operationData.segmentationId);\n            const imageIds = segmentation.representationData\n                .Labelmap.imageIds;\n            referencedImageIds = imageIds.map((imageId) => {\n                const image = cache.getImage(imageId);\n                return image.referencedImageId;\n            });\n        }\n        const imageVolume = getOrCreateImageVolume(referencedImageIds);\n        if (!imageVolume) {\n            throw new Error('Failed to create or get image volume');\n        }\n        operationData.imageVoxelManager = imageVolume.voxelManager;\n        operationData.imageData = imageVolume.imageData;\n    },\n};\n","import { utilities, cache } from '@cornerstonejs/core';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport getOrCreateSegmentationVolume from '../../../../utilities/segmentation/getOrCreateSegmentationVolume';\nexport default {\n    [StrategyCallbacks.EnsureSegmentationVolumeFor3DManipulation]: (data) => {\n        const { operationData, viewport } = data;\n        const { segmentationId, imageIds: segImageIds } = operationData;\n        const referencedImageIds = viewport\n            ? viewport.getImageIds()\n            : segImageIds.map((imageId) => cache.getImage(imageId).referencedImageId);\n        const isValidVolumeForSphere = utilities.isValidVolume(referencedImageIds);\n        if (!isValidVolumeForSphere) {\n            throw new Error('Volume is not reconstructable for sphere manipulation');\n        }\n        const segVolume = getOrCreateSegmentationVolume(segmentationId);\n        if (!segVolume) {\n            return;\n        }\n        operationData.segmentationVoxelManager = segVolume.voxelManager;\n        operationData.segmentationImageData = segVolume.imageData;\n        return;\n    },\n};\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../../../utilities/boundingBox';\nimport BrushStrategy from './BrushStrategy';\nimport { StrategyCallbacks } from '../../../enums';\nimport compositions from './compositions';\nimport { pointInSphere } from '../../../utilities/math/sphere';\nconst { transformWorldToIndex, transformIndexToWorld, isEqual } = csUtils;\nexport function getEllipseCornersFromCanvasCoordinates(canvasCoordinates) {\n    const [bottom, top, left, right] = canvasCoordinates;\n    const topLeft = [left[0], top[1]];\n    const bottomRight = [right[0], bottom[1]];\n    const bottomLeft = [left[0], bottom[1]];\n    const topRight = [right[0], top[1]];\n    return [topLeft, bottomRight, bottomLeft, topRight];\n}\nfunction createCircleCornersForCenter(center, viewUp, viewRight, radius) {\n    const centerVec = vec3.fromValues(center[0], center[1], center[2]);\n    const top = vec3.create();\n    vec3.scaleAndAdd(top, centerVec, viewUp, radius);\n    const bottom = vec3.create();\n    vec3.scaleAndAdd(bottom, centerVec, viewUp, -radius);\n    const right = vec3.create();\n    vec3.scaleAndAdd(right, centerVec, viewRight, radius);\n    const left = vec3.create();\n    vec3.scaleAndAdd(left, centerVec, viewRight, -radius);\n    return [\n        bottom,\n        top,\n        left,\n        right,\n    ];\n}\nfunction createStrokePredicate(centers, radius) {\n    if (!centers.length || radius <= 0) {\n        return null;\n    }\n    const radiusSquared = radius * radius;\n    const centerVecs = centers.map((point) => [point[0], point[1], point[2]]);\n    const segments = [];\n    for (let i = 1; i < centerVecs.length; i++) {\n        const start = centerVecs[i - 1];\n        const end = centerVecs[i];\n        const dx = end[0] - start[0];\n        const dy = end[1] - start[1];\n        const dz = end[2] - start[2];\n        const lengthSquared = dx * dx + dy * dy + dz * dz;\n        segments.push({ start, vector: [dx, dy, dz], lengthSquared });\n    }\n    return (worldPoint) => {\n        if (!worldPoint) {\n            return false;\n        }\n        for (const centerVec of centerVecs) {\n            const dx = worldPoint[0] - centerVec[0];\n            const dy = worldPoint[1] - centerVec[1];\n            const dz = worldPoint[2] - centerVec[2];\n            if (dx * dx + dy * dy + dz * dz <= radiusSquared) {\n                return true;\n            }\n        }\n        for (const { start, vector, lengthSquared } of segments) {\n            if (lengthSquared === 0) {\n                const dx = worldPoint[0] - start[0];\n                const dy = worldPoint[1] - start[1];\n                const dz = worldPoint[2] - start[2];\n                if (dx * dx + dy * dy + dz * dz <= radiusSquared) {\n                    return true;\n                }\n                continue;\n            }\n            const dx = worldPoint[0] - start[0];\n            const dy = worldPoint[1] - start[1];\n            const dz = worldPoint[2] - start[2];\n            const dot = dx * vector[0] + dy * vector[1] + dz * vector[2];\n            const t = Math.max(0, Math.min(1, dot / lengthSquared));\n            const projX = start[0] + vector[0] * t;\n            const projY = start[1] + vector[1] * t;\n            const projZ = start[2] + vector[2] * t;\n            const distX = worldPoint[0] - projX;\n            const distY = worldPoint[1] - projY;\n            const distZ = worldPoint[2] - projZ;\n            if (distX * distX + distY * distY + distZ * distZ <= radiusSquared) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nconst initializeCircle = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, viewport, segmentationImageData, viewUp, viewPlaneNormal, } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.create();\n        if (points.length >= 2) {\n            vec3.add(center, points[0], points[1]);\n            vec3.scale(center, center, 0.5);\n        }\n        else {\n            vec3.copy(center, points[0]);\n        }\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const brushRadius = points.length >= 2 ? vec3.distance(points[0], points[1]) / 2 : 0;\n        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n        const corners = getEllipseCornersFromCanvasCoordinates(canvasCoordinates);\n        const cornersInWorld = corners.map((corner) => viewport.canvasToWorld(corner));\n        const normalizedViewUp = vec3.fromValues(viewUp[0], viewUp[1], viewUp[2]);\n        vec3.normalize(normalizedViewUp, normalizedViewUp);\n        const normalizedPlaneNormal = vec3.fromValues(viewPlaneNormal[0], viewPlaneNormal[1], viewPlaneNormal[2]);\n        vec3.normalize(normalizedPlaneNormal, normalizedPlaneNormal);\n        const viewRight = vec3.create();\n        vec3.cross(viewRight, normalizedViewUp, normalizedPlaneNormal);\n        vec3.normalize(viewRight, viewRight);\n        const strokeCentersSource = operationData.strokePointsWorld &&\n            operationData.strokePointsWorld.length > 0\n            ? operationData.strokePointsWorld\n            : [operationData.centerWorld];\n        const strokeCenters = strokeCentersSource.map((point) => vec3.clone(point));\n        const strokeCornersWorld = strokeCenters.flatMap((centerPoint) => createCircleCornersForCenter(centerPoint, normalizedViewUp, viewRight, brushRadius));\n        const circleCornersIJK = strokeCornersWorld.map((world) => transformWorldToIndex(segmentationImageData, world));\n        const boundsIJK = getBoundingBoxAroundShapeIJK(circleCornersIJK, segmentationImageData.getDimensions());\n        operationData.strokePointsWorld = strokeCenters;\n        operationData.isInObject = createPointInEllipse(cornersInWorld, {\n            strokePointsWorld: strokeCenters,\n            segmentationImageData,\n            radius: brushRadius,\n        });\n        operationData.isInObjectBoundsIJK = boundsIJK;\n    },\n};\nfunction createPointInEllipse(cornersInWorld = [], options = {}) {\n    if (!cornersInWorld || cornersInWorld.length !== 4) {\n        throw new Error('createPointInEllipse: cornersInWorld must have 4 points');\n    }\n    const [topLeft, bottomRight, bottomLeft, topRight] = cornersInWorld;\n    const center = vec3.create();\n    vec3.add(center, topLeft, bottomRight);\n    vec3.scale(center, center, 0.5);\n    const majorAxisVec = vec3.create();\n    vec3.subtract(majorAxisVec, topRight, topLeft);\n    const xRadius = vec3.length(majorAxisVec) / 2;\n    vec3.normalize(majorAxisVec, majorAxisVec);\n    const minorAxisVec = vec3.create();\n    vec3.subtract(minorAxisVec, bottomLeft, topLeft);\n    const yRadius = vec3.length(minorAxisVec) / 2;\n    vec3.normalize(minorAxisVec, minorAxisVec);\n    const normal = vec3.create();\n    vec3.cross(normal, majorAxisVec, minorAxisVec);\n    vec3.normalize(normal, normal);\n    const radiusForStroke = options.radius ?? Math.max(xRadius, yRadius);\n    const strokePredicate = createStrokePredicate(options.strokePointsWorld || [], radiusForStroke);\n    if (isEqual(xRadius, yRadius)) {\n        const radius = xRadius;\n        const sphereObj = {\n            center,\n            radius,\n            radius2: radius * radius,\n        };\n        return (pointLPS, pointIJK) => {\n            let worldPoint = pointLPS;\n            if (!worldPoint && pointIJK && options.segmentationImageData) {\n                worldPoint = transformIndexToWorld(options.segmentationImageData, pointIJK);\n            }\n            if (!worldPoint) {\n                return false;\n            }\n            if (strokePredicate?.(worldPoint)) {\n                return true;\n            }\n            return pointInSphere(sphereObj, worldPoint);\n        };\n    }\n    return (pointLPS, pointIJK) => {\n        let worldPoint = pointLPS;\n        if (!worldPoint && pointIJK && options.segmentationImageData) {\n            worldPoint = transformIndexToWorld(options.segmentationImageData, pointIJK);\n        }\n        if (!worldPoint) {\n            return false;\n        }\n        if (strokePredicate?.(worldPoint)) {\n            return true;\n        }\n        const pointVec = vec3.create();\n        vec3.subtract(pointVec, worldPoint, center);\n        const distToPlane = vec3.dot(pointVec, normal);\n        const proj = vec3.create();\n        vec3.scaleAndAdd(proj, pointVec, normal, -distToPlane);\n        const fromTopLeft = vec3.create();\n        const centerToTopLeft = vec3.create();\n        vec3.subtract(centerToTopLeft, center, topLeft);\n        vec3.subtract(fromTopLeft, proj, centerToTopLeft);\n        const x = vec3.dot(fromTopLeft, majorAxisVec);\n        const y = vec3.dot(fromTopLeft, minorAxisVec);\n        return (x * x) / (xRadius * xRadius) + (y * y) / (yRadius * yRadius) <= 1;\n    };\n}\nconst CIRCLE_STRATEGY = new BrushStrategy('Circle', compositions.regionFill, compositions.setValue, initializeCircle, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics);\nconst CIRCLE_THRESHOLD_STRATEGY = new BrushStrategy('CircleThreshold', compositions.regionFill, compositions.setValue, initializeCircle, compositions.determineSegmentIndex, compositions.dynamicThreshold, compositions.threshold, compositions.preview, compositions.islandRemoval, compositions.labelmapStatistics);\nconst fillInsideCircle = CIRCLE_STRATEGY.strategyFunction;\nconst thresholdInsideCircle = CIRCLE_THRESHOLD_STRATEGY.strategyFunction;\nexport function fillOutsideCircle() {\n    throw new Error('Not yet implemented');\n}\nexport { CIRCLE_STRATEGY, CIRCLE_THRESHOLD_STRATEGY, fillInsideCircle, thresholdInsideCircle, createPointInEllipse, createPointInEllipse as createEllipseInPoint, };\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils, StackViewport } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../../../utilities/boundingBox';\nimport BrushStrategy from './BrushStrategy';\nimport { StrategyCallbacks } from '../../../enums';\nimport compositions from './compositions';\nconst { transformWorldToIndex } = csUtils;\nconst initializeRectangle = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, viewport, segmentationImageData, } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.fromValues(0, 0, 0);\n        points.forEach((point) => {\n            vec3.add(center, center, point);\n        });\n        vec3.scale(center, center, 1 / points.length);\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const { boundsIJK, pointInShapeFn } = createPointInRectangle(viewport, points, segmentationImageData);\n        operationData.isInObject = pointInShapeFn;\n        operationData.isInObjectBoundsIJK = boundsIJK;\n    },\n};\nfunction createPointInRectangle(viewport, points, segmentationImageData) {\n    let rectangleCornersIJK = points.map((world) => {\n        return transformWorldToIndex(segmentationImageData, world);\n    });\n    rectangleCornersIJK = rectangleCornersIJK.map((point) => {\n        return point.map((coord) => {\n            return Math.round(coord);\n        });\n    });\n    const boundsIJK = getBoundingBoxAroundShapeIJK(rectangleCornersIJK, segmentationImageData.getDimensions());\n    const [p0, p1, p2, p3] = points;\n    const axisU = vec3.create();\n    const axisV = vec3.create();\n    vec3.subtract(axisU, p1, p0);\n    vec3.subtract(axisV, p3, p0);\n    const uLen = vec3.length(axisU);\n    const vLen = vec3.length(axisV);\n    vec3.normalize(axisU, axisU);\n    vec3.normalize(axisV, axisV);\n    const normal = vec3.create();\n    vec3.cross(normal, axisU, axisV);\n    vec3.normalize(normal, normal);\n    const direction = segmentationImageData.getDirection();\n    const spacing = segmentationImageData.getSpacing();\n    const { viewPlaneNormal } = viewport.getCamera();\n    const EPS = csUtils.getSpacingInNormalDirection({\n        direction,\n        spacing,\n    }, viewPlaneNormal);\n    const pointInShapeFn = (pointLPS) => {\n        const v = vec3.create();\n        vec3.subtract(v, pointLPS, p0);\n        const u = vec3.dot(v, axisU);\n        const vproj = vec3.dot(v, axisV);\n        const d = Math.abs(vec3.dot(v, normal));\n        return (u >= -EPS &&\n            u <= uLen + EPS &&\n            vproj >= -EPS &&\n            vproj <= vLen + EPS &&\n            d <= EPS);\n    };\n    return { boundsIJK, pointInShapeFn };\n}\nconst RECTANGLE_STRATEGY = new BrushStrategy('Rectangle', compositions.regionFill, compositions.setValue, initializeRectangle, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics);\nconst RECTANGLE_THRESHOLD_STRATEGY = new BrushStrategy('RectangleThreshold', compositions.regionFill, compositions.setValue, initializeRectangle, compositions.determineSegmentIndex, compositions.dynamicThreshold, compositions.threshold, compositions.preview, compositions.islandRemoval, compositions.labelmapStatistics);\nconst fillInsideRectangle = RECTANGLE_STRATEGY.strategyFunction;\nconst thresholdInsideRectangle = RECTANGLE_THRESHOLD_STRATEGY.strategyFunction;\nexport { RECTANGLE_STRATEGY, RECTANGLE_THRESHOLD_STRATEGY, fillInsideRectangle, thresholdInsideRectangle, };\n","import { cache, Enums, eventTarget } from '@cornerstonejs/core';\nimport { getCurrentLabelmapImageIdForViewport } from '../../../../stateManagement/segmentation/segmentationState';\nimport { getLabelmapActorEntry } from '../../../../stateManagement/segmentation/helpers';\nimport { getReferenceVolumeForSegmentationVolume } from '../../../../utilities/segmentation/getReferenceVolumeForSegmentationVolume';\nfunction getStrategyDataForVolumeViewport({ operationData }) {\n    const { volumeId } = operationData;\n    if (!volumeId) {\n        const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n            detail: {\n                type: 'Segmentation',\n                message: 'No volume id found for the segmentation',\n            },\n            cancelable: true,\n        });\n        eventTarget.dispatchEvent(event);\n        return null;\n    }\n    const segmentationVolume = cache.getVolume(volumeId);\n    const imageVolume = getReferenceVolumeForSegmentationVolume(volumeId);\n    if (!segmentationVolume || !imageVolume) {\n        return null;\n    }\n    const { imageData: segmentationImageData } = segmentationVolume;\n    const { voxelManager: segmentationVoxelManager } = segmentationVolume;\n    const { voxelManager: imageVoxelManager, imageData } = imageVolume;\n    return {\n        segmentationImageData,\n        segmentationVoxelManager,\n        segmentationScalarData: null,\n        imageScalarData: null,\n        imageVoxelManager,\n        imageData,\n    };\n}\nfunction getStrategyDataForStackViewport({ operationData, viewport, strategy, }) {\n    const { segmentationId } = operationData;\n    let segmentationImageData;\n    let segmentationVoxelManager;\n    let segmentationScalarData;\n    let imageScalarData;\n    let imageVoxelManager;\n    let imageData;\n    if (strategy.ensureSegmentationVolumeFor3DManipulation) {\n        strategy.ensureSegmentationVolumeFor3DManipulation({\n            operationData,\n            viewport,\n        });\n        segmentationVoxelManager = operationData.segmentationVoxelManager;\n        segmentationImageData = operationData.segmentationImageData;\n        segmentationScalarData = null;\n    }\n    else {\n        const labelmapImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n        if (!labelmapImageId) {\n            return null;\n        }\n        const actorEntry = getLabelmapActorEntry(viewport.id, segmentationId);\n        if (!actorEntry) {\n            return null;\n        }\n        const currentSegImage = cache.getImage(labelmapImageId);\n        segmentationImageData = actorEntry.actor.getMapper().getInputData();\n        segmentationVoxelManager = currentSegImage.voxelManager;\n        const currentSegmentationImageId = operationData.imageId;\n        const segmentationImage = cache.getImage(currentSegmentationImageId);\n        if (!segmentationImage) {\n            return null;\n        }\n        segmentationScalarData = segmentationImage.getPixelData?.();\n    }\n    if (strategy.ensureImageVolumeFor3DManipulation) {\n        strategy.ensureImageVolumeFor3DManipulation({\n            operationData,\n            viewport,\n        });\n        imageVoxelManager = operationData.imageVoxelManager;\n        imageScalarData = operationData.imageScalarData;\n        imageData = operationData.imageData;\n    }\n    else {\n        const currentImageId = viewport.getCurrentImageId();\n        if (!currentImageId) {\n            return null;\n        }\n        const image = cache.getImage(currentImageId);\n        imageData = image ? null : viewport.getImageData();\n        imageScalarData = image?.getPixelData() || imageData.getScalarData();\n        imageVoxelManager = image?.voxelManager;\n    }\n    return {\n        segmentationImageData,\n        segmentationScalarData,\n        imageScalarData,\n        segmentationVoxelManager,\n        imageVoxelManager,\n        imageData,\n    };\n}\nfunction getStrategyData({ operationData, viewport, strategy, }) {\n    if (!operationData) {\n        return null;\n    }\n    if (('volumeId' in operationData && operationData.volumeId != null) ||\n        ('referencedVolumeId' in operationData &&\n            operationData.referencedVolumeId != null)) {\n        return getStrategyDataForVolumeViewport({ operationData });\n    }\n    return getStrategyDataForStackViewport({ operationData, viewport, strategy });\n}\nexport { getStrategyData };\n","export var ContourWindingDirection;\n(function (ContourWindingDirection) {\n    ContourWindingDirection[ContourWindingDirection[\"CounterClockwise\"] = -1] = \"CounterClockwise\";\n    ContourWindingDirection[ContourWindingDirection[\"Unknown\"] = 0] = \"Unknown\";\n    ContourWindingDirection[ContourWindingDirection[\"Clockwise\"] = 1] = \"Clockwise\";\n})(ContourWindingDirection || (ContourWindingDirection = {}));\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport { ChangeTypes } from '../enums';\nexport default class AnnotationMultiSlice {\n    static setStartRange(viewport, annotation, startRange = viewport.getCurrentImageIdIndex()) {\n        this.setRange(viewport, annotation, startRange);\n    }\n    static setEndRange(viewport, annotation, endRange = viewport.getCurrentImageIdIndex()) {\n        this.setRange(viewport, annotation, undefined, endRange);\n    }\n    static setRange(viewport, annotation, startRange, endRange) {\n        const { metadata } = annotation;\n        if (startRange === undefined) {\n            startRange = metadata.sliceIndex < endRange ? metadata.sliceIndex : 0;\n            if (endRange === undefined) {\n                endRange = viewport.getNumberOfSlices() - 1;\n            }\n        }\n        const rangeEndSliceIndex = viewport.getSliceIndexForImage(metadata.multiSliceReference);\n        if (endRange === undefined) {\n            endRange =\n                rangeEndSliceIndex >= startRange\n                    ? rangeEndSliceIndex\n                    : viewport.getNumberOfSlices() - 1;\n        }\n        endRange = Math.max(startRange, endRange);\n        metadata.sliceIndex = Math.min(startRange, endRange);\n        metadata.referencedImageId = viewport.getCurrentImageId(metadata.sliceIndex);\n        metadata.referencedImageURI = undefined;\n        if (endRange === metadata.sliceIndex) {\n            metadata.multiSliceReference = undefined;\n        }\n        else if (endRange !== metadata.multiSliceReference?.sliceIndex) {\n            metadata.multiSliceReference = {\n                referencedImageId: viewport.getCurrentImageId(endRange),\n                sliceIndex: endRange,\n            };\n        }\n        const eventDetail = {\n            viewportId: viewport.id,\n            renderingEngineId: viewport.renderingEngineId,\n            changeType: ChangeTypes.MetadataReferenceModified,\n            annotation,\n        };\n        triggerEvent(eventTarget, Events.ANNOTATION_MODIFIED, eventDetail);\n        this.setViewportFrameRange(viewport, metadata);\n    }\n    static setSingle(viewport, annotation, current = viewport.getCurrentImageIdIndex()) {\n        this.setRange(viewport, annotation, current, current);\n    }\n    static getFrameRange(annotation) {\n        const { metadata } = annotation;\n        const { sliceIndex, multiSliceReference } = metadata;\n        const rangeEndSliceIndex = multiSliceReference?.sliceIndex;\n        return rangeEndSliceIndex\n            ? [sliceIndex + 1, rangeEndSliceIndex + 1]\n            : sliceIndex + 1;\n    }\n    static getFrameRangeStr(annotation) {\n        const range = this.getFrameRange(annotation);\n        return Array.isArray(range) ? `${range[0]}-${range[1]}` : String(range);\n    }\n    static setViewportFrameRange(viewport, specifier) {\n        if (viewport.setFrameRange && specifier.multiSliceReference?.sliceIndex) {\n            viewport.setFrameRange(specifier.sliceIndex + 1, specifier.multiSliceReference.sliceIndex + 1);\n        }\n    }\n}\n","import { utilities, BaseVolumeViewport, StackViewport, cache, metaData, } from '@cornerstonejs/core';\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\nimport { vec3 } from 'gl-matrix';\nfunction annotationHydration(viewport, toolName, worldPoints, options) {\n    const viewReference = viewport.getViewReference();\n    const { viewPlaneNormal, FrameOfReferenceUID } = viewReference;\n    const annotation = {\n        annotationUID: options?.annotationUID || utilities.uuidv4(),\n        data: {\n            handles: {\n                points: worldPoints,\n            },\n        },\n        highlighted: false,\n        autoGenerated: false,\n        invalidated: false,\n        isLocked: false,\n        isVisible: true,\n        metadata: {\n            toolName,\n            viewPlaneNormal,\n            FrameOfReferenceUID,\n            referencedImageId: getReferencedImageId(viewport, worldPoints[0], viewPlaneNormal),\n            ...options,\n        },\n    };\n    addAnnotation(annotation, viewport.element);\n    return annotation;\n}\nfunction getReferencedImageId(viewport, worldPos, viewPlaneNormal) {\n    let referencedImageId;\n    if (viewport instanceof StackViewport) {\n        referencedImageId = getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal);\n    }\n    else if (viewport instanceof BaseVolumeViewport) {\n        const targetId = getTargetId(viewport);\n        const volumeId = utilities.getVolumeId(targetId);\n        const imageVolume = cache.getVolume(volumeId);\n        referencedImageId = utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n    }\n    else {\n        throw new Error('getReferencedImageId: viewport must be a StackViewport or BaseVolumeViewport');\n    }\n    return referencedImageId;\n}\nfunction getTargetId(viewport) {\n    const targetId = viewport.getViewReferenceId?.();\n    if (targetId) {\n        return targetId;\n    }\n    if (viewport instanceof BaseVolumeViewport) {\n        return `volumeId:${getTargetVolumeId(viewport)}`;\n    }\n    throw new Error('getTargetId: viewport must have a getTargetId method');\n}\nfunction getTargetVolumeId(viewport) {\n    const actorEntries = viewport.getActors();\n    if (!actorEntries) {\n        return;\n    }\n    return actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume')?.uid;\n}\nfunction getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal) {\n    const imageIds = viewport.getImageIds();\n    if (!imageIds || !imageIds.length) {\n        return;\n    }\n    const distanceImagePairs = imageIds.map((imageId) => {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const distance = calculateDistanceToImage(worldPos, imagePositionPatient, viewPlaneNormal);\n        return { imageId, distance };\n    });\n    distanceImagePairs.sort((a, b) => a.distance - b.distance);\n    return distanceImagePairs[0].imageId;\n}\nfunction calculateDistanceToImage(worldPos, ImagePositionPatient, viewPlaneNormal) {\n    const dir = vec3.create();\n    vec3.sub(dir, worldPos, ImagePositionPatient);\n    const dot = vec3.dot(dir, viewPlaneNormal);\n    return Math.abs(dot);\n}\nexport { annotationHydration, getClosestImageIdForStackViewport };\n","function extend2DBoundingBoxInViewAxis(boundsIJK, numSlicesToProject) {\n    const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);\n    if (sliceNormalIndex === -1) {\n        throw new Error('3D bounding boxes not supported in an oblique plane');\n    }\n    boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;\n    boundsIJK[sliceNormalIndex][1] += numSlicesToProject;\n    return boundsIJK;\n}\nexport default extend2DBoundingBoxInViewAxis;\n","import { CONSTANTS } from '@cornerstonejs/core';\nconst { EPSILON } = CONSTANTS;\nfunction calculateBoundingBox(points, dimensions, isWorld = false) {\n    let xMin = Infinity;\n    let xMax = isWorld ? -Infinity : 0;\n    let yMin = Infinity;\n    let yMax = isWorld ? -Infinity : 0;\n    let zMin = Infinity;\n    let zMax = isWorld ? -Infinity : 0;\n    const is3D = points[0]?.length === 3;\n    for (let i = 0; i < points.length; i++) {\n        const p = points[i];\n        xMin = Math.min(p[0], xMin);\n        xMax = Math.max(p[0], xMax);\n        yMin = Math.min(p[1], yMin);\n        yMax = Math.max(p[1], yMax);\n        if (is3D) {\n            zMin = Math.min(p[2] ?? zMin, zMin);\n            zMax = Math.max(p[2] ?? zMax, zMax);\n        }\n    }\n    if (dimensions) {\n        xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);\n        xMax = Math.min(isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1, xMax);\n        yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);\n        yMax = Math.min(isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1, yMax);\n        if (is3D && dimensions.length === 3) {\n            zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);\n            zMax = Math.min(isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1, zMax);\n        }\n    }\n    else if (!isWorld) {\n        xMin = Math.max(0, xMin);\n        xMax = Math.min(Infinity, xMax);\n        yMin = Math.max(0, yMin);\n        yMax = Math.min(Infinity, yMax);\n        if (is3D) {\n            zMin = Math.max(0, zMin);\n            zMax = Math.min(Infinity, zMax);\n        }\n    }\n    return is3D\n        ? [\n            [xMin, xMax],\n            [yMin, yMax],\n            [zMin, zMax],\n        ]\n        : [[xMin, xMax], [yMin, yMax], null];\n}\nexport function getBoundingBoxAroundShapeIJK(points, dimensions) {\n    return calculateBoundingBox(points, dimensions, false);\n}\nexport function getBoundingBoxAroundShapeWorld(points, clipBounds) {\n    return calculateBoundingBox(points, clipBounds, true);\n}\n","import { utilities, Enums } from '@cornerstonejs/core';\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\nexport default function calibrateImageSpacing(imageId, renderingEngine, calibrationOrScale) {\n    if (typeof calibrationOrScale === 'number') {\n        calibrationOrScale = {\n            type: Enums.CalibrationTypes.USER,\n            scale: calibrationOrScale,\n        };\n    }\n    calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);\n    const viewports = renderingEngine.getStackViewports();\n    viewports.forEach((viewport) => {\n        const imageIds = viewport.getImageIds();\n        if (imageIds.includes(imageId)) {\n            viewport.calibrateSpacing(imageId);\n        }\n    });\n}\n","var Events;\n(function (Events) {\n    Events[\"CLIP_STOPPED\"] = \"CORNERSTONE_CINE_TOOL_STOPPED\";\n    Events[\"CLIP_STARTED\"] = \"CORNERSTONE_CINE_TOOL_STARTED\";\n})(Events || (Events = {}));\nexport default Events;\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport { utilities as csUtils, getEnabledElement, StackViewport, VideoViewport, VolumeViewport, cache, BaseVolumeViewport, Enums, } from '@cornerstonejs/core';\nimport CINE_EVENTS from './events';\nimport { addToolState, getToolState, getToolStateByViewportId } from './state';\nconst { ViewportStatus } = Enums;\nconst { triggerEvent } = csUtils;\nconst debounced = true;\nconst dynamicVolumesPlayingMap = new Map();\nfunction playClip(element, playClipOptions) {\n    let playClipTimeouts;\n    let playClipIsTimeVarying;\n    if (element === undefined) {\n        throw new Error('playClip: element must not be undefined');\n    }\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        throw new Error('playClip: element must be a valid Cornerstone enabled element');\n    }\n    if (!playClipOptions) {\n        playClipOptions = {};\n    }\n    playClipOptions.dynamicCineEnabled =\n        playClipOptions.dynamicCineEnabled ?? true;\n    const { viewport } = enabledElement;\n    const playClipContext = _createCinePlayContext(viewport, playClipOptions);\n    let playClipData = getToolState(element);\n    const isDynamicCinePlaying = playClipOptions.dynamicCineEnabled;\n    if (isDynamicCinePlaying) {\n        _stopDynamicVolumeCine(element);\n    }\n    if (!playClipData) {\n        playClipData = {\n            intervalId: undefined,\n            framesPerSecond: 30,\n            lastFrameTimeStamp: undefined,\n            ignoreFrameTimeVector: false,\n            usingFrameTimeVector: false,\n            frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\n            speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\n            reverse: playClipOptions.reverse ?? false,\n            loop: playClipOptions.loop ?? true,\n            bounce: playClipOptions.bounce ?? false,\n        };\n        addToolState(element, playClipData);\n    }\n    else {\n        _stopClip(element, {\n            stopDynamicCine: !isDynamicCinePlaying,\n            viewportId: viewport.id,\n        });\n    }\n    playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\n    if (playClipOptions.framesPerSecond < 0 ||\n        playClipOptions.framesPerSecond > 0) {\n        playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\n        playClipData.reverse = playClipData.framesPerSecond < 0;\n        playClipData.ignoreFrameTimeVector = true;\n    }\n    if (playClipData.ignoreFrameTimeVector !== true &&\n        playClipData.frameTimeVector &&\n        playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\n        playClipContext.frameTimeVectorEnabled) {\n        const { timeouts, isTimeVarying } = _getPlayClipTimeouts(playClipData.frameTimeVector, playClipData.speed);\n        playClipTimeouts = timeouts;\n        playClipIsTimeVarying = isTimeVarying;\n    }\n    if (playClipOptions.bounce !== undefined) {\n        playClipData.bounce = playClipOptions.bounce;\n    }\n    const playClipAction = () => {\n        const { numScrollSteps, currentStepIndex } = playClipContext;\n        let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n        const outOfRange = newStepIndex < 0 || newStepIndex >= numScrollSteps;\n        if (outOfRange) {\n            if (playClipData.bounce) {\n                playClipData.reverse = !playClipData.reverse;\n                newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n                newStepIndex = Math.max(0, Math.min(numScrollSteps - 1, newStepIndex));\n            }\n            else if (!playClipData.loop) {\n                _stopClip(element, {\n                    stopDynamicCine: !isDynamicCinePlaying,\n                    viewportId: viewport.id,\n                });\n                triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, { element });\n                return;\n            }\n            else {\n                newStepIndex = playClipData.reverse ? numScrollSteps - 1 : 0;\n            }\n        }\n        const delta = newStepIndex - currentStepIndex;\n        if (delta) {\n            try {\n                playClipContext.scroll(delta);\n            }\n            catch (e) {\n                console.warn('Play clip not scrolling', e);\n                _stopClipWithData(playClipData);\n                triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, { element });\n            }\n        }\n    };\n    if (isDynamicCinePlaying) {\n        const volume = _getVolumeFromViewport(viewport);\n        if (volume) {\n            dynamicVolumesPlayingMap.set(volume.volumeId, element);\n        }\n    }\n    if (playClipContext.play) {\n        playClipData.framesPerSecond = playClipContext.play(playClipOptions.framesPerSecond);\n    }\n    else if (playClipTimeouts &&\n        playClipTimeouts.length > 0 &&\n        playClipIsTimeVarying) {\n        playClipData.usingFrameTimeVector = true;\n        playClipData.intervalId = window.setTimeout(function playClipTimeoutHandler() {\n            playClipData.intervalId = window.setTimeout(playClipTimeoutHandler, playClipTimeouts[playClipContext.currentStepIndex]);\n            playClipAction();\n        }, 0);\n    }\n    else {\n        playClipData.usingFrameTimeVector = false;\n        playClipData.intervalId = window.setInterval(playClipAction, 1000 / Math.abs(playClipData.framesPerSecond));\n    }\n    const eventDetail = {\n        element,\n    };\n    triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\n}\nfunction stopClip(element, options = {}) {\n    _stopClip(element, {\n        stopDynamicCine: true,\n        ...options,\n    });\n}\nfunction _stopClip(element, options = { stopDynamicCine: true, viewportId: undefined }) {\n    const { stopDynamicCine, viewportId } = options;\n    const enabledElement = getEnabledElement(element);\n    let toolState;\n    const viewport = enabledElement?.viewport;\n    if (!enabledElement) {\n        if (viewportId) {\n            toolState = getToolStateByViewportId(viewportId);\n        }\n        else {\n            return;\n        }\n    }\n    else {\n        const { viewport } = enabledElement;\n        toolState = getToolState(viewport.element);\n    }\n    if (toolState) {\n        _stopClipWithData(toolState);\n    }\n    if (viewport instanceof VideoViewport) {\n        viewport.pause();\n    }\n    else if (stopDynamicCine && viewport instanceof BaseVolumeViewport) {\n        _stopDynamicVolumeCine(element);\n    }\n}\nfunction _stopDynamicVolumeCine(element) {\n    const { viewport } = getEnabledElement(element);\n    if (viewport instanceof VolumeViewport) {\n        const volume = _getVolumeFromViewport(viewport);\n        if (volume?.isDynamicVolume()) {\n            const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\n            dynamicVolumesPlayingMap.delete(volume.volumeId);\n            if (dynamicCineElement && dynamicCineElement !== element) {\n                stopClip(dynamicCineElement);\n            }\n        }\n    }\n}\nfunction _getPlayClipTimeouts(vector, speed) {\n    let i;\n    let sample;\n    let delay;\n    let sum = 0;\n    const limit = vector.length;\n    const timeouts = [];\n    let isTimeVarying = false;\n    if (typeof speed !== 'number' || speed <= 0) {\n        speed = 1;\n    }\n    for (i = 1; i < limit; i++) {\n        delay = (Number(vector[i]) / speed) | 0;\n        timeouts.push(delay);\n        if (i === 1) {\n            sample = delay;\n        }\n        else if (delay !== sample) {\n            isTimeVarying = true;\n        }\n        sum += delay;\n    }\n    if (timeouts.length > 0) {\n        if (isTimeVarying) {\n            delay = (sum / timeouts.length) | 0;\n        }\n        else {\n            delay = timeouts[0];\n        }\n        timeouts.push(delay);\n    }\n    return { timeouts, isTimeVarying };\n}\nfunction _stopClipWithData(playClipData) {\n    const id = playClipData.intervalId;\n    if (typeof id !== 'undefined') {\n        playClipData.intervalId = undefined;\n        if (playClipData.usingFrameTimeVector) {\n            clearTimeout(id);\n        }\n        else {\n            clearInterval(id);\n        }\n    }\n}\nfunction _getVolumeFromViewport(viewport) {\n    if (!(viewport instanceof VolumeViewport)) {\n        return undefined;\n    }\n    const volumeIds = viewport.getAllVolumeIds();\n    if (!volumeIds?.length) {\n        return undefined;\n    }\n    const dynamicVolumeId = volumeIds.find((volumeId) => cache.getVolume(volumeId)?.isDynamicVolume());\n    const volumeId = dynamicVolumeId ?? volumeIds[0];\n    return cache.getVolume(volumeId);\n}\nfunction _createStackViewportCinePlayContext(viewport, waitForRendered) {\n    const imageIds = viewport.getImageIds();\n    return {\n        get numScrollSteps() {\n            return imageIds.length;\n        },\n        get currentStepIndex() {\n            return viewport.getTargetImageIdIndex();\n        },\n        get frameTimeVectorEnabled() {\n            return true;\n        },\n        waitForRenderedCount: 0,\n        scroll(delta) {\n            if (this.waitForRenderedCount <= waitForRendered &&\n                viewport.viewportStatus !== ViewportStatus.RENDERED) {\n                this.waitForRenderedCount++;\n                return;\n            }\n            this.waitForRenderedCount = 0;\n            csUtils.scroll(viewport, { delta, debounceLoading: debounced });\n        },\n    };\n}\nfunction _createVideoViewportCinePlayContext(viewport, waitForRendered) {\n    return {\n        get numScrollSteps() {\n            return viewport.getNumberOfSlices();\n        },\n        get currentStepIndex() {\n            return viewport.getSliceIndex();\n        },\n        get frameTimeVectorEnabled() {\n            return true;\n        },\n        waitForRenderedCount: 0,\n        scroll(delta) {\n            if (this.waitForRenderedCount <= waitForRendered &&\n                viewport.viewportStatus !== ViewportStatus.RENDERED) {\n                this.waitForRenderedCount++;\n                return;\n            }\n            this.waitForRenderedCount = 0;\n            csUtils.scroll(viewport, { delta, debounceLoading: debounced });\n        },\n        play(fps) {\n            if (fps) {\n                viewport.setPlaybackRate(fps / 24);\n            }\n            viewport.play();\n            return viewport.getFrameRate();\n        },\n    };\n}\nfunction _createVolumeViewportCinePlayContext(viewport, volume) {\n    const { volumeId } = volume;\n    const cachedScrollInfo = {\n        viewPlaneNormal: vec3.create(),\n        scrollInfo: null,\n    };\n    const getScrollInfo = () => {\n        const camera = viewport.getCamera();\n        const updateCache = !cachedScrollInfo.scrollInfo ||\n            !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\n        if (updateCache) {\n            const scrollInfo = csUtils.getVolumeViewportScrollInfo(viewport, volumeId);\n            cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\n            cachedScrollInfo.scrollInfo = scrollInfo;\n        }\n        return cachedScrollInfo.scrollInfo;\n    };\n    return {\n        get numScrollSteps() {\n            return getScrollInfo().numScrollSteps;\n        },\n        get currentStepIndex() {\n            return getScrollInfo().currentStepIndex;\n        },\n        get frameTimeVectorEnabled() {\n            const camera = viewport.getCamera();\n            const volumeViewPlaneNormal = volume.direction\n                .slice(6, 9)\n                .map((x) => -x);\n            const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\n            return glMatrix.equals(dot, 1);\n        },\n        scroll(delta) {\n            getScrollInfo().currentStepIndex += delta;\n            csUtils.scroll(viewport, { delta });\n        },\n    };\n}\nfunction _createDynamicVolumeViewportCinePlayContext(volume) {\n    return {\n        get numScrollSteps() {\n            return volume.numDimensionGroups;\n        },\n        get currentStepIndex() {\n            return volume.dimensionGroupNumber - 1;\n        },\n        get frameTimeVectorEnabled() {\n            return false;\n        },\n        scroll(delta) {\n            volume.scroll(delta);\n        },\n    };\n}\nfunction _createCinePlayContext(viewport, playClipOptions) {\n    if (viewport instanceof StackViewport) {\n        return _createStackViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);\n    }\n    if (viewport instanceof VolumeViewport) {\n        const volume = _getVolumeFromViewport(viewport);\n        if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\n            return _createDynamicVolumeViewportCinePlayContext(volume);\n        }\n        return _createVolumeViewportCinePlayContext(viewport, volume);\n    }\n    if (viewport instanceof VideoViewport) {\n        return _createVideoViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);\n    }\n    throw new Error('Unknown viewport type');\n}\nexport { playClip, stopClip };\n","import { getEnabledElement } from '@cornerstonejs/core';\nconst state = {};\nfunction addToolState(element, data) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n    state[viewportId] = data;\n}\nfunction getToolState(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId } = enabledElement;\n    return state[viewportId];\n}\nfunction getToolStateByViewportId(viewportId) {\n    return state[viewportId];\n}\nexport { addToolState, getToolState, getToolStateByViewportId };\n","import { setAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nexport function addContourSegmentationAnnotation(annotation) {\n    if (annotation.parentAnnotationUID) {\n        return;\n    }\n    if (!annotation.data.segmentation) {\n        throw new Error('addContourSegmentationAnnotation: annotation does not have a segmentation data');\n    }\n    const { segmentationId, segmentIndex } = annotation.data.segmentation;\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation.representationData.Contour) {\n        segmentation.representationData.Contour = { annotationUIDsMap: new Map() };\n    }\n    let { annotationUIDsMap } = segmentation.representationData.Contour;\n    if (!annotationUIDsMap) {\n        annotationUIDsMap = new Map();\n    }\n    let annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\n    if (!annotationsUIDsSet) {\n        annotationsUIDsSet = new Set();\n        annotationUIDsMap.set(segmentIndex, annotationsUIDsSet);\n    }\n    if (segmentation.segments[segmentIndex].locked) {\n        setAnnotationLocked(annotation.annotationUID, true);\n    }\n    annotationUIDsMap.set(segmentIndex, annotationsUIDsSet.add(annotation.annotationUID));\n}\n","export default function areSameSegment(firstAnnotation, secondAnnotation) {\n    const { segmentation: firstSegmentation } = firstAnnotation.data;\n    const { segmentation: secondSegmentation } = secondAnnotation.data;\n    return (firstSegmentation.segmentationId === secondSegmentation.segmentationId &&\n        firstSegmentation.segmentIndex === secondSegmentation.segmentIndex);\n}\n","export function areViewReferencesEqual(a, b) {\n    if (!a || !b) {\n        return false;\n    }\n    if (a.FrameOfReferenceUID !== b.FrameOfReferenceUID) {\n        return false;\n    }\n    if (a.referencedImageId !== b.referencedImageId) {\n        return false;\n    }\n    if (!a.viewPlaneNormal || !b.viewPlaneNormal) {\n        return false;\n    }\n    if (a.viewPlaneNormal.length !== b.viewPlaneNormal.length) {\n        return false;\n    }\n    for (let i = 0; i < a.viewPlaneNormal.length; i++) {\n        if (a.viewPlaneNormal[i] !== b.viewPlaneNormal[i]) {\n            return false;\n        }\n    }\n    return true;\n}\n","import { getAnnotation } from '../../stateManagement/annotation/annotationState';\nimport getViewportsForAnnotation from '../getViewportsForAnnotation';\nimport { convertContourPolylineToCanvasSpace, checkIntersection, createPolylineHole, combinePolylines, } from './sharedOperations';\nexport async function contourSegmentationOperation(sourceAnnotationOrUID, targetAnnotationOrUID, viewport, contourHoleProcessingEnabled = true) {\n    const sourceAnnotation = typeof sourceAnnotationOrUID === 'string'\n        ? getAnnotation(sourceAnnotationOrUID)\n        : sourceAnnotationOrUID;\n    const targetAnnotation = typeof targetAnnotationOrUID === 'string'\n        ? getAnnotation(targetAnnotationOrUID)\n        : targetAnnotationOrUID;\n    if (!sourceAnnotation || !targetAnnotation) {\n        throw new Error('Both source and target annotations must be valid');\n    }\n    if (!viewport) {\n        viewport = getViewportFromAnnotation(sourceAnnotation);\n    }\n    const sourcePolyline = convertContourPolylineToCanvasSpace(sourceAnnotation.data.contour.polyline, viewport);\n    const targetPolyline = convertContourPolylineToCanvasSpace(targetAnnotation.data.contour.polyline, viewport);\n    const intersectionInfo = checkIntersection(sourcePolyline, targetPolyline);\n    if (!intersectionInfo.hasIntersection) {\n        console.warn('No intersection found between the two annotations');\n        return;\n    }\n    if (intersectionInfo.isContourHole) {\n        if (!contourHoleProcessingEnabled) {\n            console.warn('Hole processing is disabled');\n            return;\n        }\n        createPolylineHole(viewport, targetAnnotation, sourceAnnotation);\n    }\n    else {\n        combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline);\n    }\n}\nfunction getViewportFromAnnotation(annotation) {\n    const viewports = getViewportsForAnnotation(annotation);\n    if (!viewports.length) {\n        throw new Error('No viewport found for the annotation');\n    }\n    return viewports[0];\n}\n","import { utilities } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotation } from '../../stateManagement';\nimport { getViewportAssociatedToSegmentation } from '../../stateManagement/segmentation/utilities/getViewportAssociatedToSegmentation';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport { getAnnotationsUIDMapFromSegmentation } from '../../stateManagement/segmentation/utilities/getAnnotationsUIDMapFromSegmentation';\nexport function copyAnnotation(annotation, segmentationId, segmentIndex) {\n    const newAnnotation = {\n        annotationUID: utilities.uuidv4(),\n        data: {\n            contour: {\n                closed: true,\n                polyline: [],\n            },\n            segmentation: {\n                segmentationId,\n                segmentIndex,\n            },\n            handles: {},\n        },\n        handles: {},\n        highlighted: false,\n        autoGenerated: false,\n        invalidated: false,\n        isLocked: false,\n        isVisible: true,\n        metadata: {\n            ...annotation.metadata,\n            toolName: annotation.metadata.toolName,\n        },\n    };\n    newAnnotation.data.segmentation.segmentationId = segmentationId;\n    newAnnotation.data.segmentation.segmentIndex = segmentIndex;\n    if (annotation.data.contour?.polyline) {\n        newAnnotation.data.contour.polyline = [...annotation.data.contour.polyline];\n    }\n    if (annotation.data.handles?.points) {\n        newAnnotation.data.handles.points = annotation.data.handles.points.map((point) => [...point]);\n    }\n    return newAnnotation;\n}\nexport function copyContourSegment(segmentationId, segmentIndex, targetSegmentationId, targetSegmentIndex) {\n    const annotationUIDsMap = getAnnotationsUIDMapFromSegmentation(segmentationId);\n    const targetAnnotationUIDsMap = getAnnotationsUIDMapFromSegmentation(targetSegmentationId);\n    if (!annotationUIDsMap || !targetAnnotationUIDsMap) {\n        return;\n    }\n    if (!annotationUIDsMap?.has(segmentIndex)) {\n        return;\n    }\n    const annotationUIDs = annotationUIDsMap.get(segmentIndex);\n    const viewport = getViewportAssociatedToSegmentation(targetSegmentationId);\n    if (!viewport) {\n        return;\n    }\n    const toolGroup = getToolGroupForViewport(viewport.id);\n    const copyContourAnnotation = (annotation) => {\n        const newAnnotation = copyAnnotation(annotation, targetSegmentationId, targetSegmentIndex);\n        if (toolGroup) {\n            const instance = toolGroup.getToolInstance(annotation.metadata.toolName);\n            if (instance) {\n                if (typeof instance.isSplineAnnotation === 'function' &&\n                    instance.isSplineAnnotation(annotation)) {\n                    instance.createSplineObjectFromType(newAnnotation, annotation.data.spline.type);\n                }\n            }\n        }\n        addAnnotation(newAnnotation, viewport.element);\n        newAnnotationsUID.add(newAnnotation.annotationUID);\n        return newAnnotation;\n    };\n    const newAnnotationsUID = new Set();\n    for (const annotationUID of annotationUIDs) {\n        const annotation = getAnnotation(annotationUID);\n        const newAnnotation = copyContourAnnotation(annotation);\n        if (annotation?.childAnnotationUIDs) {\n            newAnnotation.childAnnotationUIDs = [];\n            for (const childAnnotationUID of annotation.childAnnotationUIDs) {\n                const childAnnotation = getAnnotation(childAnnotationUID);\n                const newChildAnnotation = copyContourAnnotation(childAnnotation);\n                newChildAnnotation.parentAnnotationUID = newAnnotation.annotationUID;\n                newAnnotation.childAnnotationUIDs.push(newChildAnnotation.annotationUID);\n            }\n        }\n    }\n    targetAnnotationUIDsMap.set(targetSegmentIndex, newAnnotationsUID);\n}\n","import * as math from '../math';\nfunction findAllIntersectingContours(viewport, sourcePolyline, contourSegmentationAnnotations) {\n    const intersectingContours = [];\n    const sourceAABB = math.polyline.getAABB(sourcePolyline);\n    for (let i = 0; i < contourSegmentationAnnotations.length; i++) {\n        const targetAnnotation = contourSegmentationAnnotations[i];\n        const targetPolyline = convertContourPolylineToCanvasSpace(targetAnnotation.data.contour.polyline, viewport);\n        const targetAABB = math.polyline.getAABB(targetPolyline);\n        const aabbIntersect = math.aabb.intersectAABB(sourceAABB, targetAABB);\n        if (!aabbIntersect) {\n            continue;\n        }\n        const lineSegmentsIntersect = math.polyline.intersectPolyline(sourcePolyline, targetPolyline);\n        const isContourHole = !lineSegmentsIntersect &&\n            math.polyline.containsPoints(targetPolyline, sourcePolyline);\n        if (lineSegmentsIntersect || isContourHole) {\n            intersectingContours.push({\n                targetAnnotation,\n                targetPolyline,\n                isContourHole,\n            });\n        }\n    }\n    return intersectingContours;\n}\nfunction convertContourPolylineToCanvasSpace(polyline, viewport) {\n    const numPoints = polyline.length;\n    const projectedPolyline = new Array(numPoints);\n    for (let i = 0; i < numPoints; i++) {\n        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n    }\n    return projectedPolyline;\n}\nexport { findAllIntersectingContours };\n","export function getViewReferenceFromAnnotation(annotation) {\n    const { metadata } = annotation;\n    if (!metadata) {\n        return {};\n    }\n    const { FrameOfReferenceUID, referencedImageId, referencedImageURI, multiSliceReference, cameraFocalPoint, viewPlaneNormal, viewUp, sliceIndex, volumeId, bounds, } = metadata;\n    const viewReference = {\n        FrameOfReferenceUID,\n        referencedImageId,\n        referencedImageURI,\n        multiSliceReference,\n        cameraFocalPoint,\n        viewPlaneNormal,\n        viewUp,\n        sliceIndex,\n        volumeId,\n        bounds,\n    };\n    return viewReference;\n}\n","import { utilities } from '@cornerstonejs/core';\nimport { addAnnotation, removeAnnotation } from '../../stateManagement';\nimport { removeContourSegmentationAnnotation } from './removeContourSegmentationAnnotation';\nimport { addContourSegmentationAnnotation } from './addContourSegmentationAnnotation';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nconst DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';\nexport default function convertContourSegmentationAnnotation(annotation) {\n    const { polyline } = annotation.data?.contour || {};\n    if (!polyline || polyline.length < 3) {\n        console.warn('Skipping creation of new annotation due to invalid polyline:', polyline);\n        return;\n    }\n    removeAnnotation(annotation.annotationUID);\n    removeContourSegmentationAnnotation(annotation);\n    const startPointWorld = polyline[0];\n    const endPointWorld = polyline[polyline.length - 1];\n    const newAnnotation = {\n        metadata: {\n            ...annotation.metadata,\n            toolName: DEFAULT_CONTOUR_SEG_TOOL_NAME,\n            originalToolName: annotation.metadata.originalToolName || annotation.metadata.toolName,\n        },\n        data: {\n            cachedStats: {},\n            handles: {\n                points: [startPointWorld, endPointWorld],\n                textBox: annotation.data.handles.textBox\n                    ? { ...annotation.data.handles.textBox }\n                    : undefined,\n            },\n            contour: {\n                ...annotation.data.contour,\n            },\n            spline: annotation.data.spline,\n            segmentation: {\n                ...annotation.data.segmentation,\n            },\n        },\n        annotationUID: utilities.uuidv4(),\n        highlighted: true,\n        invalidated: true,\n        isLocked: false,\n        isVisible: undefined,\n        interpolationUID: annotation.interpolationUID,\n        interpolationCompleted: annotation.interpolationCompleted,\n    };\n    addAnnotation(newAnnotation, annotation.metadata.FrameOfReferenceUID);\n    addContourSegmentationAnnotation(newAnnotation);\n    triggerAnnotationModified(newAnnotation);\n    return newAnnotation;\n}\n","export default function isContourSegmentationAnnotation(annotation) {\n    return !!annotation.data?.segmentation;\n}\n","import { utilities } from '@cornerstonejs/core';\nimport { addAnnotation } from '../../stateManagement';\nconst DEFAULT_CONTOUR_SEG_TOOLNAME = 'PlanarFreehandContourSegmentationTool';\nexport default function addPolylinesToSegmentation(viewport, annotationUIDsMap, segmentationId, polylinesInfo, segmentIndex) {\n    polylinesInfo.forEach(({ polyline, viewReference }) => {\n        if (polyline.length < 3) {\n            return;\n        }\n        const contourSegmentationAnnotation = {\n            annotationUID: utilities.uuidv4(),\n            data: {\n                contour: {\n                    closed: true,\n                    polyline,\n                },\n                segmentation: {\n                    segmentationId,\n                    segmentIndex,\n                },\n                handles: {},\n            },\n            handles: {},\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: DEFAULT_CONTOUR_SEG_TOOLNAME,\n                ...viewReference,\n            },\n        };\n        addAnnotation(contourSegmentationAnnotation, viewport.element);\n        const currentSet = annotationUIDsMap?.get(segmentIndex) || new Set();\n        currentSet.add(contourSegmentationAnnotation.annotationUID);\n        annotationUIDsMap.set(segmentIndex, currentSet);\n    });\n    return annotationUIDsMap;\n}\n","import { getAnnotation, removeAnnotation } from '../../stateManagement';\nimport { convertContourPolylineToCanvasSpace, convertContourPolylineToWorld, } from './sharedOperations';\nimport addPolylinesToSegmentation from './addPolylinesToSegmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { copyContourSegment } from './copyAnnotation';\nimport { removeContourSegmentationAnnotation } from './removeContourSegmentationAnnotation';\nimport { getViewportAssociatedToSegmentation } from '../../stateManagement/segmentation/utilities/getViewportAssociatedToSegmentation';\nimport { unifyPolylineSets } from './polylineUnify';\nimport { subtractPolylineSets } from './polylineSubtract';\nimport { intersectPolylinesSets } from './polylineIntersect';\nimport { xorPolylinesSets } from './polylineXor';\nimport { getViewReferenceFromAnnotation } from './getViewReferenceFromAnnotation';\nexport var LogicalOperation;\n(function (LogicalOperation) {\n    LogicalOperation[LogicalOperation[\"Union\"] = 0] = \"Union\";\n    LogicalOperation[LogicalOperation[\"Subtract\"] = 1] = \"Subtract\";\n    LogicalOperation[LogicalOperation[\"Intersect\"] = 2] = \"Intersect\";\n    LogicalOperation[LogicalOperation[\"XOR\"] = 3] = \"XOR\";\n    LogicalOperation[LogicalOperation[\"Copy\"] = 4] = \"Copy\";\n    LogicalOperation[LogicalOperation[\"Delete\"] = 5] = \"Delete\";\n})(LogicalOperation || (LogicalOperation = {}));\nfunction getPolylinesInfoWorld(contourRepresentationData, segmentIndex) {\n    const polylinesInfo = [];\n    const { annotationUIDsMap } = contourRepresentationData || {};\n    if (!annotationUIDsMap?.has(segmentIndex)) {\n        return;\n    }\n    const annotationUIDs = annotationUIDsMap.get(segmentIndex);\n    for (const annotationUID of annotationUIDs) {\n        const annotation = getAnnotation(annotationUID);\n        const { polyline } = annotation.data.contour;\n        polylinesInfo.push({\n            polyline,\n            viewReference: getViewReferenceFromAnnotation(annotation),\n        });\n    }\n    return polylinesInfo;\n}\nfunction extractPolylinesInCanvasSpace(viewport, segment1, segment2) {\n    const segmentation1 = getSegmentation(segment1.segmentationId);\n    const segmentation2 = getSegmentation(segment2.segmentationId);\n    if (!segmentation1 || !segmentation2) {\n        return;\n    }\n    if (!segmentation1.representationData.Contour ||\n        !segmentation2.representationData.Contour) {\n        return;\n    }\n    const polyLinesInfoWorld1 = getPolylinesInfoWorld(segmentation1.representationData.Contour, segment1.segmentIndex);\n    const polyLinesInfoWorld2 = getPolylinesInfoWorld(segmentation2.representationData.Contour, segment2.segmentIndex);\n    if (!polyLinesInfoWorld1 || !polyLinesInfoWorld2) {\n        return;\n    }\n    const polyLinesInfoCanvas1 = polyLinesInfoWorld1.map(({ polyline, viewReference }) => {\n        return {\n            polyline: convertContourPolylineToCanvasSpace(polyline, viewport),\n            viewReference,\n        };\n    });\n    const polyLinesInfoCanvas2 = polyLinesInfoWorld2.map(({ polyline, viewReference }) => {\n        return {\n            polyline: convertContourPolylineToCanvasSpace(polyline, viewport),\n            viewReference,\n        };\n    });\n    return { polyLinesInfoCanvas1, polyLinesInfoCanvas2 };\n}\nfunction addSegmentInSegmentation(segmentation, { segmentIndex, label, color }) {\n    if (!segmentation?.segments) {\n        return;\n    }\n    const segmentData = segmentation.segments[segmentIndex] ?? {\n        active: false,\n        locked: false,\n        segmentIndex,\n        cachedStats: {},\n        label,\n        color,\n    };\n    if (label !== undefined) {\n        segmentData.label = label;\n    }\n    if (color !== undefined) {\n        segmentData.color = color;\n    }\n    segmentation.segments[segmentIndex] = segmentData;\n}\nfunction removeAnnotations(annotationUIDList) {\n    annotationUIDList.forEach((annotationUID) => {\n        const annotation = getAnnotation(annotationUID);\n        removeAnnotation(annotationUID);\n        removeContourSegmentationAnnotation(annotation);\n    });\n    annotationUIDList.clear();\n}\nfunction applyLogicalOperation(segment1, segment2, options, operation) {\n    const viewport = getViewportAssociatedToSegmentation(segment1.segmentationId);\n    if (!viewport) {\n        return;\n    }\n    const { polyLinesInfoCanvas1, polyLinesInfoCanvas2 } = extractPolylinesInCanvasSpace(viewport, segment1, segment2) || {};\n    if (!polyLinesInfoCanvas1 || !polyLinesInfoCanvas2) {\n        return;\n    }\n    let polylinesMerged;\n    switch (operation) {\n        case LogicalOperation.Union:\n            polylinesMerged = unifyPolylineSets(polyLinesInfoCanvas1, polyLinesInfoCanvas2);\n            break;\n        case LogicalOperation.Subtract:\n            polylinesMerged = subtractPolylineSets(polyLinesInfoCanvas1, polyLinesInfoCanvas2);\n            break;\n        case LogicalOperation.Intersect:\n            polylinesMerged = intersectPolylinesSets(polyLinesInfoCanvas1, polyLinesInfoCanvas2);\n            break;\n        case LogicalOperation.XOR:\n            polylinesMerged = xorPolylinesSets(polyLinesInfoCanvas1, polyLinesInfoCanvas2);\n            break;\n        default:\n            polylinesMerged = unifyPolylineSets(polyLinesInfoCanvas1, polyLinesInfoCanvas2);\n            break;\n    }\n    const polyLinesWorld = polylinesMerged.map(({ polyline, viewReference }) => {\n        return {\n            polyline: convertContourPolylineToWorld(polyline, viewport),\n            viewReference,\n        };\n    });\n    const resultSegment = options;\n    const segmentation = getSegmentation(resultSegment.segmentationId);\n    const segmentIndex = resultSegment.segmentIndex;\n    const color = resultSegment.color;\n    const label = resultSegment.label;\n    const contourRepresentationData = segmentation.representationData\n        .Contour;\n    const { annotationUIDsMap } = contourRepresentationData;\n    if (!annotationUIDsMap) {\n        return;\n    }\n    if (segment1.segmentationId === resultSegment.segmentationId &&\n        segment1.segmentIndex === segmentIndex) {\n        const existingAnnotationUIDs = annotationUIDsMap.get(segmentIndex);\n        if (existingAnnotationUIDs) {\n            removeAnnotations(existingAnnotationUIDs);\n        }\n    }\n    addPolylinesToSegmentation(viewport, annotationUIDsMap, segmentation.segmentationId, polyLinesWorld, segmentIndex);\n    addSegmentInSegmentation(segmentation, { segmentIndex, color, label });\n}\nexport function add(segment1, segment2, options) {\n    applyLogicalOperation(segment1, segment2, options, LogicalOperation.Union);\n}\nexport function subtract(segment1, segment2, options) {\n    applyLogicalOperation(segment1, segment2, options, LogicalOperation.Subtract);\n}\nexport function intersect(segment1, segment2, options) {\n    applyLogicalOperation(segment1, segment2, options, LogicalOperation.Intersect);\n}\nexport function xor(segment1, segment2, options) {\n    applyLogicalOperation(segment1, segment2, options, LogicalOperation.XOR);\n}\nexport function copy(segment, options) {\n    copyContourSegment(segment.segmentationId, segment.segmentIndex, options.segmentationId, options.segmentIndex);\n}\nexport function deleteOperation(segment) {\n    const segmentation = getSegmentation(segment.segmentationId);\n    if (!segmentation) {\n        console.log('No active segmentation detected');\n        return;\n    }\n    if (!segmentation.representationData.Contour) {\n        console.log('No contour representation found');\n        return;\n    }\n    const representationData = segmentation.representationData.Contour;\n    const { annotationUIDsMap } = representationData;\n    if (!annotationUIDsMap) {\n        console.log('No annotation map found');\n        return;\n    }\n    if (!annotationUIDsMap.has(segment.segmentIndex)) {\n        console.log('Segmentation index has no annotations');\n        return;\n    }\n    const annotationUIDList = annotationUIDsMap.get(segment.segmentIndex);\n    removeAnnotations(annotationUIDList);\n}\n","import { utilities as csUtils, getEnabledElement } from '@cornerstonejs/core';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport * as math from '../math';\nimport updateContourPolyline from '../contours/updateContourPolyline';\nimport { addAnnotation, removeAnnotation, getChildAnnotations, addChildAnnotation, clearParentAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { addContourSegmentationAnnotation } from './addContourSegmentationAnnotation';\nimport { removeContourSegmentationAnnotation } from './removeContourSegmentationAnnotation';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getViewportIdsWithToolToRender } from '../viewportFilters';\nimport { hasToolByName, hasTool } from '../../store/addTool';\nconst DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';\nfunction processMultipleIntersections(viewport, sourceAnnotation, sourcePolyline, intersectingContours) {\n    const holeOperations = intersectingContours.filter((item) => item.isContourHole);\n    const mergeOperations = intersectingContours.filter((item) => !item.isContourHole);\n    if (holeOperations.length > 0) {\n        const primaryHoleTarget = holeOperations[0];\n        createPolylineHole(viewport, primaryHoleTarget.targetAnnotation, sourceAnnotation);\n        updateViewportsForAnnotations(viewport, [\n            sourceAnnotation,\n            primaryHoleTarget.targetAnnotation,\n        ]);\n        return;\n    }\n    if (mergeOperations.length === 0) {\n        return;\n    }\n    if (!hasToolByName(DEFAULT_CONTOUR_SEG_TOOL_NAME)) {\n        console.warn(`${DEFAULT_CONTOUR_SEG_TOOL_NAME} is not registered in cornerstone. Cannot process multiple intersections.`);\n        return;\n    }\n    processSequentialIntersections(viewport, sourceAnnotation, sourcePolyline, mergeOperations);\n}\nfunction processSequentialIntersections(viewport, sourceAnnotation, sourcePolyline, mergeOperations) {\n    const { element } = viewport;\n    const allAnnotationsToRemove = [sourceAnnotation];\n    const allResultPolylines = [];\n    const allHoles = [];\n    mergeOperations.forEach(({ targetAnnotation }) => {\n        const holes = getContourHolesData(viewport, targetAnnotation);\n        allHoles.push(...holes);\n        allAnnotationsToRemove.push(targetAnnotation);\n    });\n    const sourceStartPoint = sourcePolyline[0];\n    const shouldMerge = mergeOperations.some(({ targetPolyline }) => math.polyline.containsPoint(targetPolyline, sourceStartPoint));\n    if (shouldMerge) {\n        let resultPolyline = sourcePolyline;\n        mergeOperations.forEach(({ targetPolyline }) => {\n            resultPolyline = math.polyline.mergePolylines(resultPolyline, targetPolyline);\n        });\n        allResultPolylines.push(resultPolyline);\n    }\n    else {\n        mergeOperations.forEach(({ targetPolyline }) => {\n            const subtractedPolylines = math.polyline.subtractPolylines(targetPolyline, sourcePolyline);\n            allResultPolylines.push(...subtractedPolylines);\n        });\n    }\n    allAnnotationsToRemove.forEach((annotation) => {\n        removeAnnotation(annotation.annotationUID);\n        removeContourSegmentationAnnotation(annotation);\n    });\n    allHoles.forEach((holeData) => clearParentAnnotation(holeData.annotation));\n    const baseAnnotation = mergeOperations[0].targetAnnotation;\n    const newAnnotations = [];\n    allResultPolylines.forEach((polyline) => {\n        if (!polyline || polyline.length < 3) {\n            console.warn('Skipping creation of new annotation due to invalid polyline:', polyline);\n            return;\n        }\n        const newAnnotation = createNewAnnotationFromPolyline(viewport, baseAnnotation, polyline);\n        addAnnotation(newAnnotation, element);\n        addContourSegmentationAnnotation(newAnnotation);\n        triggerAnnotationModified(newAnnotation, viewport.element);\n        newAnnotations.push(newAnnotation);\n    });\n    reassignHolesToNewAnnotations(viewport, allHoles, newAnnotations);\n    updateViewportsForAnnotations(viewport, allAnnotationsToRemove);\n}\nfunction createNewAnnotationFromPolyline(viewport, baseAnnotation, polyline) {\n    const startPointWorld = viewport.canvasToWorld(polyline[0]);\n    const endPointWorld = viewport.canvasToWorld(polyline[polyline.length - 1]);\n    const newAnnotation = {\n        metadata: {\n            ...baseAnnotation.metadata,\n            toolName: DEFAULT_CONTOUR_SEG_TOOL_NAME,\n            originalToolName: baseAnnotation.metadata.originalToolName ||\n                baseAnnotation.metadata.toolName,\n        },\n        data: {\n            cachedStats: {},\n            handles: {\n                points: [startPointWorld, endPointWorld],\n                textBox: baseAnnotation.data.handles.textBox\n                    ? { ...baseAnnotation.data.handles.textBox }\n                    : undefined,\n            },\n            contour: {\n                polyline: [],\n                closed: true,\n            },\n            spline: baseAnnotation.data.spline,\n            segmentation: {\n                ...baseAnnotation.data.segmentation,\n            },\n        },\n        annotationUID: csUtils.uuidv4(),\n        highlighted: true,\n        invalidated: true,\n        isLocked: false,\n        isVisible: undefined,\n        interpolationUID: baseAnnotation.interpolationUID,\n        interpolationCompleted: baseAnnotation.interpolationCompleted,\n    };\n    updateContourPolyline(newAnnotation, {\n        points: polyline,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    return newAnnotation;\n}\nfunction reassignHolesToNewAnnotations(viewport, holes, newAnnotations) {\n    holes.forEach((holeData) => {\n        const parentAnnotation = newAnnotations.find((annotation) => {\n            const parentPolyline = convertContourPolylineToCanvasSpace(annotation.data.contour.polyline, viewport);\n            return math.polyline.containsPoints(parentPolyline, holeData.polyline);\n        });\n        if (parentAnnotation) {\n            addChildAnnotation(parentAnnotation, holeData.annotation);\n        }\n    });\n}\nfunction getContourHolesData(viewport, annotation) {\n    return getChildAnnotations(annotation).map((holeAnnotation) => {\n        const contourHoleAnnotation = holeAnnotation;\n        const polyline = convertContourPolylineToCanvasSpace(contourHoleAnnotation.data.contour.polyline, viewport);\n        return { annotation: contourHoleAnnotation, polyline };\n    });\n}\nfunction createPolylineHole(viewport, targetAnnotation, holeAnnotation) {\n    addChildAnnotation(targetAnnotation, holeAnnotation);\n    removeContourSegmentationAnnotation(holeAnnotation);\n    const { contour: holeContour } = holeAnnotation.data;\n    const holePolylineCanvas = convertContourPolylineToCanvasSpace(holeContour.polyline, viewport);\n    updateContourPolyline(holeAnnotation, {\n        points: holePolylineCanvas,\n        closed: holeContour.closed,\n        targetWindingDirection: targetAnnotation.data.contour.windingDirection ===\n            ContourWindingDirection.Clockwise\n            ? ContourWindingDirection.CounterClockwise\n            : ContourWindingDirection.Clockwise,\n    }, viewport);\n}\nfunction convertContourPolylineToCanvasSpace(polyline, viewport) {\n    const numPoints = polyline.length;\n    const projectedPolyline = new Array(numPoints);\n    for (let i = 0; i < numPoints; i++) {\n        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n    }\n    return projectedPolyline;\n}\nfunction updateViewportsForAnnotations(viewport, annotations) {\n    const { element } = viewport;\n    const updatedToolNames = new Set([DEFAULT_CONTOUR_SEG_TOOL_NAME]);\n    annotations.forEach((annotation) => {\n        updatedToolNames.add(annotation.metadata.toolName);\n    });\n    for (const toolName of updatedToolNames.values()) {\n        if (hasToolByName(toolName)) {\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, toolName);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        }\n    }\n}\nexport { processMultipleIntersections };\n","import { checkIntersection, cleanupPolylines } from './sharedOperations';\nimport { intersectPolylines } from '../math/polyline';\nimport arePolylinesIdentical from '../math/polyline/arePolylinesIdentical';\nimport { areViewReferencesEqual } from './areViewReferencesEqual';\nexport function intersectPolylinesSets(set1, set2) {\n    if (!set1.length || !set2.length) {\n        return [];\n    }\n    const result = [];\n    for (const polyA of set1) {\n        for (const polyB of set2) {\n            if (!areViewReferencesEqual(polyA.viewReference, polyB.viewReference)) {\n                continue;\n            }\n            if (arePolylinesIdentical(polyA.polyline, polyB.polyline)) {\n                result.push({ ...polyA });\n                continue;\n            }\n            const intersection = checkIntersection(polyA.polyline, polyB.polyline);\n            if (intersection.hasIntersection && !intersection.isContourHole) {\n                const intersectionRegions = cleanupPolylines(intersectPolylines(polyA.polyline, polyB.polyline));\n                if (intersectionRegions && intersectionRegions.length > 0) {\n                    intersectionRegions.forEach((region) => {\n                        result.push({\n                            polyline: region,\n                            viewReference: polyA.viewReference,\n                        });\n                    });\n                }\n            }\n        }\n    }\n    return result;\n}\n","import * as math from '../math';\nimport { checkIntersection, cleanupPolylines, convertContourPolylineToCanvasSpace, removeDuplicatePoints, } from './sharedOperations';\nimport arePolylinesIdentical from '../math/polyline/arePolylinesIdentical';\nimport { getViewReferenceFromAnnotation } from './getViewReferenceFromAnnotation';\nimport { areViewReferencesEqual } from './areViewReferencesEqual';\nexport function subtractPolylineSets(polylinesSetA, polylinesSetB) {\n    const result = [];\n    for (let i = 0; i < polylinesSetA.length; i++) {\n        let currentPolylines = [polylinesSetA[i]];\n        for (let j = 0; j < polylinesSetB.length; j++) {\n            const polylineB = polylinesSetB[j];\n            const newPolylines = [];\n            for (const currentPolyline of currentPolylines) {\n                if (!areViewReferencesEqual(currentPolyline.viewReference, polylineB.viewReference)) {\n                    newPolylines.push(currentPolyline);\n                    continue;\n                }\n                if (arePolylinesIdentical(currentPolyline.polyline, polylineB.polyline)) {\n                    continue;\n                }\n                const intersection = checkIntersection(currentPolyline.polyline, polylineB.polyline);\n                if (intersection.hasIntersection && !intersection.isContourHole) {\n                    const subtractedPolylines = cleanupPolylines(math.polyline.subtractPolylines(currentPolyline.polyline, polylineB.polyline));\n                    for (const subtractedPolyline of subtractedPolylines) {\n                        const cleaned = removeDuplicatePoints(subtractedPolyline);\n                        if (cleaned.length >= 3) {\n                            newPolylines.push({\n                                polyline: cleaned,\n                                viewReference: currentPolyline.viewReference,\n                            });\n                        }\n                    }\n                }\n                else {\n                    newPolylines.push({\n                        polyline: currentPolyline.polyline,\n                        viewReference: currentPolyline.viewReference,\n                    });\n                }\n            }\n            currentPolylines = newPolylines;\n        }\n        result.push(...currentPolylines);\n    }\n    return result;\n}\nexport function subtractMultiplePolylineSets(basePolylineSet, subtractorSets) {\n    if (subtractorSets.length === 0) {\n        return [...basePolylineSet];\n    }\n    let result = [...basePolylineSet];\n    for (let i = 0; i < subtractorSets.length; i++) {\n        result = subtractPolylineSets(result, subtractorSets[i]);\n    }\n    return result;\n}\nexport function subtractAnnotationPolylines(baseAnnotations, subtractorAnnotations, viewport) {\n    const basePolylines = baseAnnotations.map((annotation) => ({\n        polyline: convertContourPolylineToCanvasSpace(annotation.data.contour.polyline, viewport),\n        viewReference: getViewReferenceFromAnnotation(annotation),\n    }));\n    const subtractorPolylines = subtractorAnnotations.map((annotation) => ({\n        polyline: convertContourPolylineToCanvasSpace(annotation.data.contour.polyline, viewport),\n        viewReference: getViewReferenceFromAnnotation(annotation),\n    }));\n    return subtractPolylineSets(basePolylines, subtractorPolylines);\n}\n","import * as math from '../math';\nimport { checkIntersection, convertContourPolylineToCanvasSpace, } from './sharedOperations';\nimport arePolylinesIdentical from '../math/polyline/arePolylinesIdentical';\nimport { getViewReferenceFromAnnotation } from './getViewReferenceFromAnnotation';\nimport { areViewReferencesEqual } from './areViewReferencesEqual';\nexport function unifyPolylineSets(polylinesSetA, polylinesSetB) {\n    const result = [];\n    const processedFromA = new Set();\n    const processedFromB = new Set();\n    for (let i = 0; i < polylinesSetA.length; i++) {\n        if (processedFromA.has(i)) {\n            continue;\n        }\n        const polylineA = polylinesSetA[i];\n        let merged = false;\n        for (let j = 0; j < polylinesSetB.length; j++) {\n            if (processedFromB.has(j)) {\n                continue;\n            }\n            const polylineB = polylinesSetB[j];\n            if (!areViewReferencesEqual(polylineA.viewReference, polylineB.viewReference)) {\n                continue;\n            }\n            if (arePolylinesIdentical(polylineA.polyline, polylineB.polyline)) {\n                result.push(polylineA);\n                processedFromA.add(i);\n                processedFromB.add(j);\n                merged = true;\n                break;\n            }\n            const intersection = checkIntersection(polylineA.polyline, polylineB.polyline);\n            if (intersection.hasIntersection && !intersection.isContourHole) {\n                const mergedPolyline = math.polyline.mergePolylines(polylineA.polyline, polylineB.polyline);\n                result.push({\n                    polyline: mergedPolyline,\n                    viewReference: polylineA.viewReference,\n                });\n                processedFromA.add(i);\n                processedFromB.add(j);\n                merged = true;\n                break;\n            }\n        }\n        if (!merged) {\n            result.push(polylineA);\n            processedFromA.add(i);\n        }\n    }\n    for (let j = 0; j < polylinesSetB.length; j++) {\n        if (!processedFromB.has(j)) {\n            result.push(polylinesSetB[j]);\n        }\n    }\n    return result;\n}\nexport function unifyMultiplePolylineSets(polylineSets) {\n    if (polylineSets.length === 0) {\n        return [];\n    }\n    if (polylineSets.length === 1) {\n        return [...polylineSets[0]];\n    }\n    let result = [...polylineSets[0]];\n    for (let i = 1; i < polylineSets.length; i++) {\n        result = unifyPolylineSets(result, polylineSets[i]);\n    }\n    return result;\n}\nexport function unifyAnnotationPolylines(annotationsSetA, annotationsSetB, viewport) {\n    const polylinesSetA = annotationsSetA.map((annotation) => ({\n        polyline: convertContourPolylineToCanvasSpace(annotation.data.contour.polyline, viewport),\n        viewReference: getViewReferenceFromAnnotation(annotation),\n    }));\n    const polylinesSetB = annotationsSetB.map((annotation) => ({\n        polyline: convertContourPolylineToCanvasSpace(annotation.data.contour.polyline, viewport),\n        viewReference: getViewReferenceFromAnnotation(annotation),\n    }));\n    return unifyPolylineSets(polylinesSetA, polylinesSetB);\n}\n","import { cleanupPolylines } from './sharedOperations';\nimport arePolylinesIdentical from '../math/polyline/arePolylinesIdentical';\nimport { subtractPolylineSets } from './polylineSubtract';\nimport { areViewReferencesEqual } from './areViewReferencesEqual';\nexport function xorPolylinesSets(polylinesSetA, polylinesSetB) {\n    if (!polylinesSetA.length && !polylinesSetB.length) {\n        return [];\n    }\n    if (!polylinesSetA.length) {\n        return polylinesSetB;\n    }\n    if (!polylinesSetB.length) {\n        return polylinesSetA;\n    }\n    if (polylinesSetA.length === polylinesSetB.length) {\n        let allIdentical = true;\n        for (let i = 0; i < polylinesSetA.length; i++) {\n            let foundMatch = false;\n            for (let j = 0; j < polylinesSetB.length; j++) {\n                if (!areViewReferencesEqual(polylinesSetA[i].viewReference, polylinesSetB[j].viewReference)) {\n                    continue;\n                }\n                if (arePolylinesIdentical(polylinesSetA[i].polyline, polylinesSetB[j].polyline)) {\n                    foundMatch = true;\n                    break;\n                }\n            }\n            if (!foundMatch) {\n                allIdentical = false;\n                break;\n            }\n        }\n        if (allIdentical) {\n            return [];\n        }\n    }\n    const aMinusB = subtractPolylineSets(polylinesSetA, polylinesSetB);\n    const bMinusA = subtractPolylineSets(polylinesSetB, polylinesSetA);\n    const xorResult = [...aMinusB, ...bMinusA];\n    return xorResult;\n}\n","import { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nexport function removeContourSegmentationAnnotation(annotation) {\n    if (!annotation.data.segmentation) {\n        throw new Error('removeContourSegmentationAnnotation: annotation does not have a segmentation data');\n    }\n    const { segmentationId, segmentIndex } = annotation.data.segmentation;\n    const segmentation = getSegmentation(segmentationId);\n    const { annotationUIDsMap } = segmentation?.representationData.Contour || {};\n    const annotationsUIDsSet = annotationUIDsMap?.get(segmentIndex);\n    if (!annotationsUIDsSet) {\n        return;\n    }\n    annotationsUIDsSet.delete(annotation.annotationUID);\n    if (!annotationsUIDsSet.size) {\n        annotationUIDsMap.delete(segmentIndex);\n    }\n}\n","import { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport * as math from '../math';\nimport updateContourPolyline from '../contours/updateContourPolyline';\nimport { addAnnotation, removeAnnotation, getChildAnnotations, addChildAnnotation, clearParentAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { addContourSegmentationAnnotation } from './addContourSegmentationAnnotation';\nimport { removeContourSegmentationAnnotation } from './removeContourSegmentationAnnotation';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getViewportIdsWithToolToRender } from '../viewportFilters';\nimport { hasToolByName } from '../../store/addTool';\nconst TOLERANCE = 1e-10;\nconst DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';\nexport function convertContourPolylineToCanvasSpace(polyline, viewport) {\n    const numPoints = polyline.length;\n    const projectedPolyline = new Array(numPoints);\n    for (let i = 0; i < numPoints; i++) {\n        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n    }\n    return projectedPolyline;\n}\nexport function convertContourPolylineToWorld(polyline, viewport) {\n    const numPoints = polyline.length;\n    const projectedPolyline = new Array(numPoints);\n    for (let i = 0; i < numPoints; i++) {\n        projectedPolyline[i] = viewport.canvasToWorld(polyline[i]);\n    }\n    return projectedPolyline;\n}\nexport function checkIntersection(sourcePolyline, targetPolyline) {\n    const sourceAABB = math.polyline.getAABB(sourcePolyline);\n    const targetAABB = math.polyline.getAABB(targetPolyline);\n    const aabbIntersect = math.aabb.intersectAABB(sourceAABB, targetAABB);\n    if (!aabbIntersect) {\n        return { hasIntersection: false, isContourHole: false };\n    }\n    const lineSegmentsIntersect = math.polyline.intersectPolyline(sourcePolyline, targetPolyline);\n    const isContourHole = !lineSegmentsIntersect &&\n        math.polyline.containsPoints(targetPolyline, sourcePolyline);\n    const hasIntersection = lineSegmentsIntersect || isContourHole;\n    return { hasIntersection, isContourHole };\n}\nexport function getContourHolesData(viewport, annotation) {\n    return getChildAnnotations(annotation).map((holeAnnotation) => {\n        const contourHoleAnnotation = holeAnnotation;\n        const polyline = convertContourPolylineToCanvasSpace(contourHoleAnnotation.data.contour.polyline, viewport);\n        return { annotation: contourHoleAnnotation, polyline };\n    });\n}\nexport function createPolylineHole(viewport, targetAnnotation, holeAnnotation) {\n    addChildAnnotation(targetAnnotation, holeAnnotation);\n    removeContourSegmentationAnnotation(holeAnnotation);\n    const { contour: holeContour } = holeAnnotation.data;\n    const holePolylineCanvas = convertContourPolylineToCanvasSpace(holeContour.polyline, viewport);\n    updateContourPolyline(holeAnnotation, {\n        points: holePolylineCanvas,\n        closed: holeContour.closed,\n        targetWindingDirection: targetAnnotation.data.contour.windingDirection ===\n            ContourWindingDirection.Clockwise\n            ? ContourWindingDirection.CounterClockwise\n            : ContourWindingDirection.Clockwise,\n    }, viewport);\n    const { element } = viewport;\n    updateViewportsForAnnotations(viewport, [targetAnnotation, holeAnnotation]);\n}\nexport function combinePolylines(viewport, targetAnnotation, targetPolyline, sourceAnnotation, sourcePolyline) {\n    if (!hasToolByName(DEFAULT_CONTOUR_SEG_TOOL_NAME)) {\n        console.warn(`${DEFAULT_CONTOUR_SEG_TOOL_NAME} is not registered in cornerstone. Cannot combine polylines.`);\n        return;\n    }\n    const sourceStartPoint = sourcePolyline[0];\n    const mergePolylines = math.polyline.containsPoint(targetPolyline, sourceStartPoint);\n    const contourHolesData = getContourHolesData(viewport, targetAnnotation);\n    const unassignedContourHolesSet = new Set(contourHolesData);\n    const reassignedContourHolesMap = new Map();\n    const assignHoleToPolyline = (parentPolyline, holeData) => {\n        let holes = reassignedContourHolesMap.get(parentPolyline);\n        if (!holes) {\n            holes = [];\n            reassignedContourHolesMap.set(parentPolyline, holes);\n        }\n        holes.push(holeData);\n        unassignedContourHolesSet.delete(holeData);\n    };\n    const newPolylines = [];\n    if (mergePolylines) {\n        const mergedPolyline = math.polyline.mergePolylines(targetPolyline, sourcePolyline);\n        newPolylines.push(mergedPolyline);\n        Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => assignHoleToPolyline(mergedPolyline, holeData));\n    }\n    else {\n        const subtractedPolylines = math.polyline.subtractPolylines(targetPolyline, sourcePolyline);\n        subtractedPolylines.forEach((newPolyline) => {\n            newPolylines.push(newPolyline);\n            Array.from(unassignedContourHolesSet.keys()).forEach((holeData) => {\n                const containsHole = math.polyline.containsPoints(newPolyline, holeData.polyline);\n                if (containsHole) {\n                    assignHoleToPolyline(newPolyline, holeData);\n                }\n            });\n        });\n    }\n    Array.from(reassignedContourHolesMap.values()).forEach((contourHolesDataArray) => contourHolesDataArray.forEach((contourHoleData) => clearParentAnnotation(contourHoleData.annotation)));\n    const { element } = viewport;\n    const { metadata, data } = targetAnnotation;\n    const { handles, segmentation } = data;\n    const { textBox } = handles;\n    removeAnnotation(sourceAnnotation.annotationUID);\n    removeAnnotation(targetAnnotation.annotationUID);\n    removeContourSegmentationAnnotation(sourceAnnotation);\n    removeContourSegmentationAnnotation(targetAnnotation);\n    const newAnnotations = [];\n    for (let i = 0; i < newPolylines.length; i++) {\n        const polyline = newPolylines[i];\n        if (!polyline || polyline.length < 3) {\n            console.warn('Skipping creation of new annotation due to invalid polyline:', polyline);\n            continue;\n        }\n        const newAnnotation = createNewAnnotationFromPolyline(viewport, targetAnnotation, polyline);\n        addAnnotation(newAnnotation, element);\n        addContourSegmentationAnnotation(newAnnotation);\n        triggerAnnotationModified(newAnnotation, viewport.element);\n        newAnnotations.push(newAnnotation);\n        reassignedContourHolesMap\n            .get(polyline)\n            ?.forEach((holeData) => addChildAnnotation(newAnnotation, holeData.annotation));\n    }\n    updateViewportsForAnnotations(viewport, [targetAnnotation, sourceAnnotation]);\n}\nexport function createNewAnnotationFromPolyline(viewport, templateAnnotation, polyline) {\n    const startPointWorld = viewport.canvasToWorld(polyline[0]);\n    const endPointWorld = viewport.canvasToWorld(polyline[polyline.length - 1]);\n    const newAnnotation = {\n        metadata: {\n            ...templateAnnotation.metadata,\n            toolName: DEFAULT_CONTOUR_SEG_TOOL_NAME,\n            originalToolName: templateAnnotation.metadata.originalToolName ||\n                templateAnnotation.metadata.toolName,\n        },\n        data: {\n            cachedStats: {},\n            handles: {\n                points: [startPointWorld, endPointWorld],\n                textBox: templateAnnotation.data.handles.textBox\n                    ? { ...templateAnnotation.data.handles.textBox }\n                    : undefined,\n            },\n            contour: {\n                polyline: [],\n                closed: true,\n            },\n            spline: templateAnnotation.data.spline,\n            segmentation: {\n                ...templateAnnotation.data.segmentation,\n            },\n        },\n        annotationUID: csUtils.uuidv4(),\n        highlighted: true,\n        invalidated: true,\n        isLocked: false,\n        isVisible: undefined,\n        interpolationUID: templateAnnotation.interpolationUID,\n        interpolationCompleted: templateAnnotation.interpolationCompleted,\n    };\n    updateContourPolyline(newAnnotation, {\n        points: polyline,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    return newAnnotation;\n}\nexport function updateViewportsForAnnotations(viewport, annotations) {\n    const { element } = viewport;\n    const updatedToolNames = new Set([DEFAULT_CONTOUR_SEG_TOOL_NAME]);\n    annotations.forEach((annotation) => {\n        updatedToolNames.add(annotation.metadata.toolName);\n    });\n    for (const toolName of updatedToolNames.values()) {\n        if (hasToolByName(toolName)) {\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, toolName);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        }\n    }\n}\nexport function removeDuplicatePoints(polyline) {\n    if (!polyline || polyline.length < 2) {\n        return polyline;\n    }\n    const cleaned = [polyline[0]];\n    for (let i = 1; i < polyline.length; i++) {\n        const currentPoint = polyline[i];\n        const lastPoint = cleaned[cleaned.length - 1];\n        const dx = Math.abs(currentPoint[0] - lastPoint[0]);\n        const dy = Math.abs(currentPoint[1] - lastPoint[1]);\n        if (dx > TOLERANCE || dy > TOLERANCE) {\n            cleaned.push(currentPoint);\n        }\n    }\n    return cleaned;\n}\nexport function cleanupPolylines(polylines) {\n    const validPolylines = [];\n    const seenPolylines = new Set();\n    for (let polyline of polylines) {\n        if (!polyline || polyline.length < 3) {\n            continue;\n        }\n        polyline = removeDuplicatePoints(polyline);\n        if (polyline.length < 3) {\n            continue;\n        }\n        const sortedPoints = [...polyline].sort((a, b) => {\n            if (a[0] !== b[0]) {\n                return a[0] - b[0];\n            }\n            return a[1] - b[1];\n        });\n        const polylineKey = sortedPoints\n            .map((p) => `${p[0].toFixed(6)},${p[1].toFixed(6)}`)\n            .join('|');\n        if (!seenPolylines.has(polylineKey)) {\n            seenPolylines.add(polylineKey);\n            validPolylines.push(polyline);\n        }\n    }\n    return validPolylines;\n}\n","import RectangleROIStartEndThreshold from './RectangleROIStartEndThreshold';\nfunction validateAnnotation(annotation) {\n    if (!annotation?.data) {\n        throw new Error('Tool data is empty');\n    }\n    if (!annotation.metadata || !annotation.metadata.referencedImageId) {\n        throw new Error('Tool data is not associated with any imageId');\n    }\n}\nclass AnnotationToPointData {\n    static { this.TOOL_NAMES = {}; }\n    constructor() {\n    }\n    static convert(annotation, segment, metadataProvider) {\n        validateAnnotation(annotation);\n        const { toolName } = annotation.metadata;\n        const toolClass = AnnotationToPointData.TOOL_NAMES[toolName];\n        if (!toolClass) {\n            throw new Error(`Unknown tool type: ${toolName}, cannot convert to RTSSReport`);\n        }\n        const contourSequence = toolClass.getContourSequence(annotation, metadataProvider);\n        const color = segment.color?.slice(0, 3) || [\n            Math.floor(Math.random() * 255),\n            Math.floor(Math.random() * 255),\n            Math.floor(Math.random() * 255),\n        ];\n        return {\n            ReferencedROINumber: segment.segmentIndex,\n            ROIDisplayColor: color,\n            ContourSequence: Array.isArray(contourSequence)\n                ? contourSequence\n                : [contourSequence],\n        };\n    }\n    static register(toolClass) {\n        AnnotationToPointData.TOOL_NAMES[toolClass.toolName] = toolClass;\n    }\n}\nAnnotationToPointData.register(RectangleROIStartEndThreshold);\nexport default AnnotationToPointData;\n","import { vec3 } from 'gl-matrix';\nexport function calculatePerimeter(polyline, closed) {\n    let perimeter = 0;\n    for (let i = 0; i < polyline.length - 1; i++) {\n        const point1 = polyline[i];\n        const point2 = polyline[i + 1];\n        perimeter += vec3.dist(point1, point2);\n    }\n    if (closed) {\n        const firstPoint = polyline[0];\n        const lastPoint = polyline[polyline.length - 1];\n        perimeter += vec3.dist(firstPoint, lastPoint);\n    }\n    return perimeter;\n}\nexport default calculatePerimeter;\n","function findNextLink(line, lines, contourPoints) {\n    let index = -1;\n    lines.forEach((cell, i) => {\n        if (index >= 0) {\n            return;\n        }\n        if (cell.a == line.b) {\n            index = i;\n        }\n    });\n    if (index >= 0) {\n        const nextLine = lines[index];\n        lines.splice(index, 1);\n        contourPoints.push(nextLine.b);\n        if (contourPoints[0] == nextLine.b) {\n            return {\n                remainingLines: lines,\n                contourPoints,\n                type: 'CLOSED_PLANAR',\n            };\n        }\n        return findNextLink(nextLine, lines, contourPoints);\n    }\n    return {\n        remainingLines: lines,\n        contourPoints,\n        type: 'OPEN_PLANAR',\n    };\n}\nexport function findContours(lines) {\n    if (lines.length == 0) {\n        return [];\n    }\n    const contourPoints = [];\n    const firstCell = lines.shift();\n    contourPoints.push(firstCell.a);\n    contourPoints.push(firstCell.b);\n    const result = findNextLink(firstCell, lines, contourPoints);\n    if (result.remainingLines.length == 0) {\n        return [\n            {\n                type: result.type,\n                contourPoints: result.contourPoints,\n            },\n        ];\n    }\n    else {\n        const extraContours = findContours(result.remainingLines);\n        extraContours.push({\n            type: result.type,\n            contourPoints: result.contourPoints,\n        });\n        return extraContours;\n    }\n}\nexport function findContoursFromReducedSet(lines) {\n    return findContours(lines);\n}\nexport default {\n    findContours,\n    findContoursFromReducedSet,\n};\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nconst { isEqual } = csUtils;\nexport default function findHandlePolylineIndex(annotation, handleIndex) {\n    const { polyline } = annotation.data.contour;\n    const { points } = annotation.data.handles;\n    const { length } = points;\n    if (handleIndex === length) {\n        return polyline.length;\n    }\n    if (handleIndex < 0) {\n        handleIndex = (handleIndex + length) % length;\n    }\n    if (handleIndex === 0) {\n        return 0;\n    }\n    const handle = points[handleIndex];\n    const index = polyline.findIndex((point) => isEqual(handle, point));\n    if (index !== -1) {\n        return index;\n    }\n    let closestDistance = Infinity;\n    return polyline.reduce((closestIndex, point, testIndex) => {\n        const distance = vec3.squaredDistance(point, handle);\n        if (distance < closestDistance) {\n            closestDistance = distance;\n            return testIndex;\n        }\n        return closestIndex;\n    }, -1);\n}\n","import isClosed from '../math/polyline/isClosed';\nimport { getSignedArea } from '../math/polyline';\nexport default function findIslands(polylines, threshold) {\n    if (!polylines || polylines.length === 0) {\n        return [];\n    }\n    if (threshold <= 0) {\n        return [];\n    }\n    const islandIndexes = [];\n    for (let i = 0; i < polylines.length; i++) {\n        const polyline = polylines[i];\n        if (!polyline || polyline.length < 3) {\n            continue;\n        }\n        const isClosedPolyline = isClosed(polyline);\n        if (isClosedPolyline) {\n            const area = Math.abs(getSignedArea(polyline)) / 100;\n            if (area < threshold) {\n                islandIndexes.push(i);\n            }\n        }\n    }\n    return islandIndexes;\n}\n","import getContourHolesDataWorld from './getContourHolesDataWorld';\nexport default function getContourHolesDataCanvas(annotation, viewport) {\n    const worldHoleContours = getContourHolesDataWorld(annotation);\n    const canvasHoleContours = [];\n    worldHoleContours.forEach((worldHoleContour) => {\n        const numPoints = worldHoleContour.length;\n        const canvasHoleContour = new Array(numPoints);\n        for (let i = 0; i < numPoints; i++) {\n            canvasHoleContour[i] = viewport.worldToCanvas(worldHoleContour[i]);\n        }\n        canvasHoleContours.push(canvasHoleContour);\n    });\n    return canvasHoleContours;\n}\n","import { getAnnotation } from '../../stateManagement/annotation/annotationState';\nexport default function getContourHolesDataWorld(annotation) {\n    const childAnnotationUIDs = annotation.childAnnotationUIDs ?? [];\n    return childAnnotationUIDs.map((uid) => getAnnotation(uid).data.contour.polyline);\n}\n","export function getDeduplicatedVTKPolyDataPoints(polyData, bypass = false) {\n    const points = polyData.getPoints();\n    const lines = polyData.getLines();\n    const pointsArray = new Array(points.getNumberOfPoints())\n        .fill(0)\n        .map((_, i) => points.getPoint(i).slice());\n    const linesArray = new Array(lines.getNumberOfCells()).fill(0).map((_, i) => {\n        const cell = lines.getCell(i * 3).slice();\n        return { a: cell[0], b: cell[1] };\n    });\n    if (bypass) {\n        return { points: pointsArray, lines: linesArray };\n    }\n    const newPoints = [];\n    for (const [i, pt] of pointsArray.entries()) {\n        const index = newPoints.findIndex((point) => point[0] === pt[0] && point[1] === pt[1] && point[2] === pt[2]);\n        if (index >= 0) {\n            linesArray.map((line) => {\n                if (line.a === i) {\n                    line.a = index;\n                }\n                if (line.b === i) {\n                    line.b = index;\n                }\n                return line;\n            });\n        }\n        else {\n            const newIndex = newPoints.length;\n            newPoints.push(pt);\n            linesArray.map((line) => {\n                if (line.a === i) {\n                    line.a = newIndex;\n                }\n                if (line.b === i) {\n                    line.b = newIndex;\n                }\n                return line;\n            });\n        }\n    }\n    const newLines = linesArray.filter((line) => line.a !== line.b);\n    return { points: newPoints, lines: newLines };\n}\nexport default { getDeduplicatedVTKPolyDataPoints };\n","import { glMatrix, vec3 } from 'gl-matrix';\nexport default function areCoplanarContours(firstAnnotation, secondAnnotation) {\n    const { viewPlaneNormal: firstViewPlaneNormal } = firstAnnotation.metadata;\n    const { viewPlaneNormal: secondViewPlaneNormal } = secondAnnotation.metadata;\n    const dot = vec3.dot(firstViewPlaneNormal, secondViewPlaneNormal);\n    const parallelPlanes = glMatrix.equals(1, Math.abs(dot));\n    if (!parallelPlanes) {\n        return false;\n    }\n    const { polyline: firstPolyline } = firstAnnotation.data.contour;\n    const { polyline: secondPolyline } = secondAnnotation.data.contour;\n    const firstDistance = vec3.dot(firstViewPlaneNormal, firstPolyline[0]);\n    const secondDistance = vec3.dot(firstViewPlaneNormal, secondPolyline[0]);\n    return glMatrix.equals(firstDistance, secondDistance);\n}\n","const getIsPointInsidePolygon = (point, vertices) => {\n    const x = point[0];\n    const y = point[1];\n    let inside = false;\n    for (let i = 0, j = vertices.length - 1; i < vertices.length; j = i++) {\n        const xi = vertices[i][0], yi = vertices[i][1];\n        const xj = vertices[j][0], yj = vertices[j][1];\n        const intersect = yi > y != yj > y && x < ((xj - xi) * (y - yi)) / (yj - yi) + xi;\n        if (intersect) {\n            inside = !inside;\n        }\n    }\n    return inside;\n};\nfunction checkEnclosed(outerContour, innerContour, points) {\n    const vertices = [];\n    outerContour.contourPoints.forEach((point) => {\n        vertices.push([points[point][0], points[point][1]]);\n    });\n    let pointsNotEnclosed = 0;\n    innerContour.contourPoints.forEach((point) => {\n        const result = getIsPointInsidePolygon([points[point][0], points[point][1]], vertices);\n        if (!result) {\n            pointsNotEnclosed++;\n        }\n    });\n    return pointsNotEnclosed === 0;\n}\nexport function processContourHoles(contours, points, useXOR = true) {\n    const retContours = contours.filter((contour) => contour.type !== 'CLOSED_PLANAR');\n    const closedContours = contours.filter((contour) => contour.type === 'CLOSED_PLANAR');\n    const contourWithHoles = [];\n    let contourWithoutHoles = [];\n    closedContours.forEach((contour, index) => {\n        const holes = [];\n        closedContours.forEach((hContour, hIndex) => {\n            if (index != hIndex) {\n                if (checkEnclosed(contour, hContour, points)) {\n                    holes.push(hIndex);\n                }\n            }\n        });\n        if (holes.length > 0) {\n            contourWithHoles.push({\n                contour,\n                holes,\n            });\n        }\n        else {\n            contourWithoutHoles.push(index);\n        }\n    });\n    if (useXOR) {\n        contourWithHoles.forEach((contourHoleSet) => {\n            contourHoleSet.contour.type = 'CLOSEDPLANAR_XOR';\n            retContours.push(contourHoleSet.contour);\n            contourHoleSet.holes.forEach((holeIndex) => {\n                closedContours[holeIndex].type = 'CLOSEDPLANAR_XOR';\n                retContours.push(closedContours[holeIndex]);\n                contourWithoutHoles = contourWithoutHoles.filter((contourIndex) => {\n                    return contourIndex !== holeIndex;\n                });\n            });\n        });\n        contourWithoutHoles.forEach((contourIndex) => {\n            retContours.push(closedContours[contourIndex]);\n        });\n    }\n    else {\n    }\n    return retContours;\n}\nexport default { processContourHoles };\n","import getSignedArea from '../math/polyline/getSignedArea';\nimport containsPoints from '../math/polyline/containsPoints';\nimport isClosed from '../math/polyline/isClosed';\nfunction isPolygonInsidePolygon(inner, outer) {\n    return containsPoints(outer, inner);\n}\nexport default function findContourHoles(polylines) {\n    const results = [];\n    const closedPolylines = [];\n    polylines.forEach((polyline, index) => {\n        if (isClosed(polyline)) {\n            closedPolylines.push({ polyline, originalIndex: index });\n        }\n    });\n    for (let i = 0; i < closedPolylines.length; i++) {\n        const outerContour = closedPolylines[i];\n        const outerArea = Math.abs(getSignedArea(outerContour.polyline));\n        const holeIndexes = [];\n        for (let j = 0; j < closedPolylines.length; j++) {\n            if (i === j) {\n                continue;\n            }\n            const potentialHole = closedPolylines[j];\n            const holeArea = Math.abs(getSignedArea(potentialHole.polyline));\n            if (holeArea < outerArea &&\n                isPolygonInsidePolygon(potentialHole.polyline, outerContour.polyline)) {\n                holeIndexes.push(potentialHole.originalIndex);\n            }\n        }\n        if (holeIndexes.length > 0) {\n            results.push({\n                contourIndex: outerContour.originalIndex,\n                holeIndexes: holeIndexes.sort((a, b) => a - b),\n            });\n        }\n    }\n    return results.sort((a, b) => a.contourIndex - b.contourIndex);\n}\nexport { findContourHoles };\n","import { cache as cornerstoneCache, getWebWorkerManager, cache, utilities, } from '@cornerstonejs/core';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { WorkerTypes } from '../../enums';\nimport { registerComputeWorker } from '../registerComputeWorker';\nimport { triggerWorkerProgress } from '../segmentation/utilsForWorker';\nimport getOrCreateSegmentationVolume from '../segmentation/getOrCreateSegmentationVolume';\nconst { Labelmap } = SegmentationRepresentations;\nasync function generateContourSetsFromLabelmap({ segmentations }) {\n    registerComputeWorker();\n    triggerWorkerProgress(WorkerTypes.GENERATE_CONTOUR_SETS, 0);\n    const { representationData, segments = [0, 1], segmentationId, } = segmentations;\n    let { volumeId: segVolumeId } = representationData[Labelmap];\n    if (!segVolumeId) {\n        const segVolume = getOrCreateSegmentationVolume(segmentationId);\n        if (segVolume) {\n            segVolumeId = segVolume.volumeId;\n        }\n    }\n    const vol = cornerstoneCache.getVolume(segVolumeId);\n    if (!vol) {\n        console.warn(`No volume found for ${segVolumeId}`);\n        return;\n    }\n    const voxelManager = vol.voxelManager;\n    const segScalarData = voxelManager.getCompleteScalarDataArray();\n    const segmentationInfo = {\n        scalarData: segScalarData,\n        dimensions: vol.dimensions,\n        spacing: vol.imageData.getSpacing(),\n        origin: vol.imageData.getOrigin(),\n        direction: vol.imageData.getDirection(),\n    };\n    const indices = Array.isArray(segments)\n        ? segments\n            .filter((segment) => segment !== null)\n            .map((segment) => segment.segmentIndex || segment)\n        : Object.values(segments)\n            .filter((segment) => segment !== null)\n            .map((segment) => segment.segmentIndex || segment);\n    const contourSets = await getWebWorkerManager().executeTask('compute', 'generateContourSetsFromLabelmapVolume', {\n        segmentation: segmentationInfo,\n        indices,\n        mode: 'individual',\n    });\n    const refImages = vol.imageIds.map((imageId) => {\n        const refImageId = cache.getImage(imageId)?.referencedImageId;\n        return refImageId ? cache.getImage(refImageId) : undefined;\n    });\n    const refImageDataMetadata = refImages.map((image) => {\n        return utilities.getImageDataMetadata(image);\n    });\n    const processedContourSets = contourSets\n        .map((contourSet) => {\n        const segment = segments[contourSet.segment.segmentIndex] || {};\n        if (!contourSet.sliceContours.length) {\n            return null;\n        }\n        const p1 = contourSet.sliceContours[0].polyData.points[0];\n        let refImageId;\n        if (p1) {\n            const refImageIndex = refImageDataMetadata.findIndex((imageDataMetadata) => {\n                const { scanAxisNormal, origin } = imageDataMetadata;\n                const plane = utilities.planar.planeEquation(scanAxisNormal, origin);\n                return utilities.planar.isPointOnPlane(p1, plane);\n            });\n            if (refImageIndex !== -1) {\n                refImageId = refImages[refImageIndex].imageId;\n            }\n        }\n        return {\n            label: segment.label,\n            color: segment.color,\n            metadata: {\n                FrameOfReferenceUID: vol.metadata.FrameOfReferenceUID,\n                referencedImageId: refImageId,\n            },\n            sliceContours: contourSet.sliceContours.map((contourData) => ({\n                contours: contourData.contours,\n                polyData: contourData.polyData,\n                FrameNumber: contourData.sliceIndex + 1,\n                sliceIndex: contourData.sliceIndex,\n                FrameOfReferenceUID: vol.metadata.FrameOfReferenceUID,\n                referencedImageId: refImageId,\n            })),\n        };\n    })\n        .filter((contourSet) => contourSet !== null);\n    triggerWorkerProgress(WorkerTypes.GENERATE_CONTOUR_SETS, 100);\n    return processedContourSets;\n}\nexport { generateContourSetsFromLabelmap };\n","import InterpolationManager from '../../segmentation/InterpolationManager/InterpolationManager';\nexport default function acceptAutogeneratedInterpolations(annotationGroupSelector, selector) {\n    InterpolationManager.acceptAutoGenerated(annotationGroupSelector, selector);\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport * as math from '../math';\nimport { getParentAnnotation, invalidateAnnotation, } from '../../stateManagement/annotation/annotationState';\nexport default function updateContourPolyline(annotation, polylineData, transforms, options) {\n    const { canvasToWorld, worldToCanvas } = transforms;\n    const { data } = annotation;\n    const { targetWindingDirection } = polylineData;\n    let { points: polyline } = polylineData;\n    let windingDirection = math.polyline.getWindingDirection(polyline);\n    if (options?.decimate?.enabled) {\n        polyline = math.polyline.decimate(polylineData.points, options?.decimate?.epsilon);\n    }\n    let { closed } = polylineData;\n    const numPoints = polyline.length;\n    const polylineWorldPoints = new Array(numPoints);\n    const currentPolylineWindingDirection = math.polyline.getWindingDirection(polyline);\n    const parentAnnotation = getParentAnnotation(annotation);\n    if (closed === undefined) {\n        let currentClosedState = false;\n        if (polyline.length > 3) {\n            const lastToFirstDist = math.point.distanceToPointSquared(polyline[0], polyline[numPoints - 1]);\n            currentClosedState = csUtils.isEqual(0, lastToFirstDist);\n        }\n        closed = currentClosedState;\n    }\n    if (options?.updateWindingDirection !== false) {\n        let updatedWindingDirection = parentAnnotation\n            ? parentAnnotation.data.contour.windingDirection * -1\n            : targetWindingDirection;\n        if (updatedWindingDirection === undefined) {\n            updatedWindingDirection = windingDirection;\n        }\n        if (updatedWindingDirection !== windingDirection) {\n            polyline.reverse();\n        }\n        const handlePoints = (data.handles?.points ?? []).map(worldToCanvas);\n        if (handlePoints.length > 2) {\n            const currentHandlesWindingDirection = math.polyline.getWindingDirection(handlePoints);\n            if (currentHandlesWindingDirection !== updatedWindingDirection) {\n                data.handles.points.reverse();\n            }\n        }\n        windingDirection = updatedWindingDirection;\n    }\n    for (let i = 0; i < numPoints; i++) {\n        polylineWorldPoints[i] = canvasToWorld(polyline[i]);\n    }\n    data.contour.polyline = polylineWorldPoints;\n    data.contour.closed = closed;\n    data.contour.windingDirection = windingDirection;\n    invalidateAnnotation(annotation);\n}\n","import { Enums } from '@cornerstonejs/core';\nfunction sumOverDimensionGroups(voxelManager, dimensionGroups) {\n    const arrayLength = voxelManager.getScalarDataLength();\n    const resultArray = new Float32Array(arrayLength);\n    for (const dimensionGroupNumber of dimensionGroups) {\n        const scalarData = voxelManager.getDimensionGroupScalarData(dimensionGroupNumber);\n        for (let i = 0; i < arrayLength; i++) {\n            resultArray[i] += scalarData[i];\n        }\n    }\n    return resultArray;\n}\nfunction averageOverDimensionGroups(voxelManager, dimensionGroups) {\n    const sumArray = sumOverDimensionGroups(voxelManager, dimensionGroups);\n    const numDimensionGroups = dimensionGroups.length;\n    for (let i = 0; i < sumArray.length; i++) {\n        sumArray[i] /= numDimensionGroups;\n    }\n    return sumArray;\n}\nconst operationFunctions = {\n    [Enums.GenerateImageType.SUM]: (voxelManager, dimensionGroups, callback) => {\n        const resultArray = sumOverDimensionGroups(voxelManager, dimensionGroups);\n        for (let i = 0; i < resultArray.length; i++) {\n            callback(i, resultArray[i]);\n        }\n    },\n    [Enums.GenerateImageType.AVERAGE]: (voxelManager, dimensionGroups, callback) => {\n        const resultArray = averageOverDimensionGroups(voxelManager, dimensionGroups);\n        for (let i = 0; i < resultArray.length; i++) {\n            callback(i, resultArray[i]);\n        }\n    },\n    [Enums.GenerateImageType.SUBTRACT]: (voxelManager, dimensionGroups, callback) => {\n        if (dimensionGroups.length !== 2) {\n            throw new Error('Please provide only 2 dimension groups for subtraction.');\n        }\n        const arrayLength = voxelManager.getScalarDataLength();\n        const scalarData1 = voxelManager.getDimensionGroupScalarData(dimensionGroups[0]);\n        const scalarData2 = voxelManager.getDimensionGroupScalarData(dimensionGroups[1]);\n        for (let i = 0; i < arrayLength; i++) {\n            const difference = scalarData1[i] - scalarData2[i];\n            callback(i, difference);\n        }\n    },\n};\nfunction generateImageFromTimeData(dynamicVolume, operation, options) {\n    const { dimensionGroupNumbers, frameNumbers } = options;\n    if (frameNumbers) {\n        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');\n    }\n    const dimensionGroups = dimensionGroupNumbers ||\n        frameNumbers ||\n        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);\n    if (dimensionGroups.length <= 1) {\n        throw new Error('Please provide two or more dimension groups');\n    }\n    const voxelManager = dynamicVolume.voxelManager;\n    const arrayLength = voxelManager.getScalarDataLength();\n    const operationFunction = operationFunctions[operation];\n    if (!operationFunction) {\n        throw new Error(`Unsupported operation: ${operation}`);\n    }\n    const resultArray = new Float32Array(arrayLength);\n    operationFunction(voxelManager, dimensionGroups, (index, value) => {\n        resultArray[index] = value;\n    });\n    return resultArray;\n}\nfunction updateVolumeFromTimeData(dynamicVolume, operation, options) {\n    const { dimensionGroupNumbers, frameNumbers, targetVolume } = options;\n    if (!targetVolume) {\n        throw new Error('A target volume must be provided');\n    }\n    if (frameNumbers) {\n        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');\n    }\n    const dimensionGroups = dimensionGroupNumbers ||\n        frameNumbers ||\n        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);\n    if (dimensionGroups.length <= 1) {\n        throw new Error('Please provide two or more dimension groups');\n    }\n    const voxelManager = dynamicVolume.voxelManager;\n    const targetVoxelManager = targetVolume.voxelManager;\n    const operationFunction = operationFunctions[operation];\n    if (!operationFunction) {\n        throw new Error(`Unsupported operation: ${operation}`);\n    }\n    operationFunction(voxelManager, dimensionGroups, (index, value) => {\n        targetVoxelManager.setAtIndex(index, value);\n    });\n    targetVoxelManager.resetModifiedSlices();\n    for (let k = 0; k < targetVolume.dimensions[2]; k++) {\n        targetVoxelManager.modifiedSlices.add(k);\n    }\n}\nexport { generateImageFromTimeData, updateVolumeFromTimeData };\n","import { utilities, cache } from '@cornerstonejs/core';\nimport { getVoxelOverlap } from '../segmentation/utilities';\nfunction getDataInTime(dynamicVolume, options) {\n    let dataInTime;\n    const dimensionGroups = options.dimensionGroupNumbers ||\n        options.frameNumbers ||\n        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);\n    if (options.frameNumbers) {\n        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');\n    }\n    if (!options.maskVolumeId && !options.worldCoordinate) {\n        throw new Error('You should provide either maskVolumeId or imageCoordinate');\n    }\n    if (options.maskVolumeId && options.worldCoordinate) {\n        throw new Error('You can only use one of maskVolumeId or imageCoordinate');\n    }\n    if (options.maskVolumeId) {\n        const segmentationVolume = cache.getVolume(options.maskVolumeId);\n        if (!segmentationVolume) {\n            throw new Error('Segmentation volume not found');\n        }\n        const [dataInTime, ijkCoords] = _getDimensionGroupDataMask(dimensionGroups, dynamicVolume, segmentationVolume);\n        return [dataInTime, ijkCoords];\n    }\n    if (options.worldCoordinate) {\n        const dataInTime = _getDimensionGroupDataCoordinate(dimensionGroups, options.worldCoordinate, dynamicVolume);\n        return dataInTime;\n    }\n    return dataInTime;\n}\nfunction _getDimensionGroupDataCoordinate(dimensionGroups, coordinate, volume) {\n    const { dimensions, imageData } = volume;\n    const index = imageData.worldToIndex(coordinate);\n    index[0] = Math.floor(index[0]);\n    index[1] = Math.floor(index[1]);\n    index[2] = Math.floor(index[2]);\n    if (!utilities.indexWithinDimensions(index, dimensions)) {\n        throw new Error('outside bounds');\n    }\n    const yMultiple = dimensions[0];\n    const zMultiple = dimensions[0] * dimensions[1];\n    const value = [];\n    dimensionGroups.forEach((dimensionGroupNumber) => {\n        const scalarIndex = index[2] * zMultiple + index[1] * yMultiple + index[0];\n        value.push(volume.voxelManager.getAtIndexAndDimensionGroup(scalarIndex, dimensionGroupNumber));\n    });\n    return value;\n}\nfunction _getDimensionGroupDataMask(dimensionGroups, dynamicVolume, segmentationVolume) {\n    const { imageData: maskImageData } = segmentationVolume;\n    const segVoxelManager = segmentationVolume.voxelManager;\n    const scalarDataLength = segVoxelManager.getScalarDataLength();\n    const nonZeroVoxelIndices = [];\n    nonZeroVoxelIndices.length = scalarDataLength;\n    let actualLen = 0;\n    for (let i = 0, len = scalarDataLength; i < len; i++) {\n        if (segVoxelManager.getAtIndex(i) !== 0) {\n            nonZeroVoxelIndices[actualLen++] = i;\n        }\n    }\n    nonZeroVoxelIndices.length = actualLen;\n    const nonZeroVoxelValuesInTime = [];\n    const isSameVolume = dynamicVolume.voxelManager.getScalarDataLength() === scalarDataLength &&\n        JSON.stringify(dynamicVolume.spacing) ===\n            JSON.stringify(segmentationVolume.spacing);\n    const ijkCoords = [];\n    if (isSameVolume) {\n        for (let i = 0; i < nonZeroVoxelIndices.length; i++) {\n            const valuesInTime = [];\n            const index = nonZeroVoxelIndices[i];\n            for (let j = 0; j < dimensionGroups.length; j++) {\n                valuesInTime.push(dynamicVolume.voxelManager.getAtIndexAndDimensionGroup(index, dimensionGroups[j]));\n            }\n            nonZeroVoxelValuesInTime.push(valuesInTime);\n            ijkCoords.push(segVoxelManager.toIJK(index));\n        }\n        return [nonZeroVoxelValuesInTime, ijkCoords];\n    }\n    const callback = ({ pointLPS: segPointLPS, value: segValue, pointIJK: segPointIJK, }) => {\n        if (segValue === 0) {\n            return;\n        }\n        const overlapIJKMinMax = getVoxelOverlap(dynamicVolume.imageData, dynamicVolume.dimensions, dynamicVolume.spacing, segPointLPS);\n        let count = 0;\n        const perDimensionGroupSum = new Map();\n        dimensionGroups.forEach((dimensionGroupNumber) => perDimensionGroupSum.set(dimensionGroupNumber, 0));\n        const averageCallback = ({ index }) => {\n            for (let i = 0; i < dimensionGroups.length; i++) {\n                const value = dynamicVolume.voxelManager.getAtIndexAndDimensionGroup(index, dimensionGroups[i]);\n                const dimensionGroupNumber = dimensionGroups[i];\n                perDimensionGroupSum.set(dimensionGroupNumber, perDimensionGroupSum.get(dimensionGroupNumber) + value);\n            }\n            count++;\n        };\n        dynamicVolume.voxelManager.forEach(averageCallback, {\n            imageData: dynamicVolume.imageData,\n            boundsIJK: overlapIJKMinMax,\n        });\n        const averageValues = [];\n        perDimensionGroupSum.forEach((sum) => {\n            averageValues.push(sum / count);\n        });\n        ijkCoords.push(segPointIJK);\n        nonZeroVoxelValuesInTime.push(averageValues);\n    };\n    segmentationVolume.voxelManager.forEach(callback, {\n        imageData: maskImageData,\n    });\n    return [nonZeroVoxelValuesInTime, ijkCoords];\n}\nexport default getDataInTime;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { getAnnotations } from '../stateManagement/annotation/annotationState';\nimport * as ToolGroupManager from '../store/ToolGroupManager';\nfunction getAnnotationNearPoint(element, canvasPoint, proximity = 5) {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        throw new Error('getAnnotationNearPoint: enabledElement not found');\n    }\n    return getAnnotationNearPointOnEnabledElement(enabledElement, canvasPoint, proximity);\n}\nfunction getAnnotationNearPointOnEnabledElement(enabledElement, point, proximity) {\n    const { renderingEngineId, viewportId } = enabledElement;\n    const toolGroup = ToolGroupManager.getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return null;\n    }\n    const { _toolInstances: tools } = toolGroup;\n    for (const name in tools) {\n        const found = findAnnotationNearPointByTool(tools[name], enabledElement, point, proximity);\n        if (found) {\n            return found;\n        }\n    }\n    return null;\n}\nfunction findAnnotationNearPointByTool(tool, enabledElement, point, proximity) {\n    const { viewport } = enabledElement;\n    const annotations = getAnnotations(tool.constructor.toolName, viewport?.element);\n    const currentId = viewport?.getCurrentImageId?.();\n    if (annotations?.length) {\n        const { element } = enabledElement.viewport;\n        for (const annotation of annotations) {\n            const referencedImageId = annotation.metadata?.referencedImageId;\n            if ((currentId && referencedImageId && currentId !== referencedImageId) ||\n                !tool.isPointNearTool) {\n                continue;\n            }\n            if (tool.isPointNearTool(element, annotation, point, proximity, '') ||\n                tool.getHandleNearImagePoint(element, annotation, point, proximity)) {\n                return annotation;\n            }\n        }\n    }\n    return null;\n}\nexport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement };\n","import { Enums, utilities } from '@cornerstonejs/core';\nconst { CalibrationTypes } = Enums;\nconst PIXEL_UNITS = 'px';\nconst VOXEL_UNITS = 'voxels';\nconst SUPPORTED_REGION_DATA_TYPES = [\n    1,\n    2,\n    3,\n    4,\n];\nconst SUPPORTED_LENGTH_VARIANT = [\n    '3,3',\n    '4,7',\n];\nconst SUPPORTED_PROBE_VARIANT = [\n    '4,3',\n    '4,7',\n];\nconst UNIT_MAPPING = {\n    0: 'px',\n    1: 'percent',\n    2: 'dB',\n    3: 'cm',\n    4: 'seconds',\n    5: 'hertz',\n    6: 'dB/seconds',\n    7: 'cm/sec',\n    8: 'cm\\xb2',\n    9: 'cm\\xb2/s',\n    0xc: 'degrees',\n};\nconst EPS = 1e-3;\nconst SQUARE = '\\xb2';\nconst getCalibratedLengthUnitsAndScale = (image, handles) => {\n    const { calibration, hasPixelSpacing } = image;\n    let unit = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\n    const volumeUnit = hasPixelSpacing ? 'mm\\xb3' : VOXEL_UNITS;\n    let areaUnit = unit + SQUARE;\n    let scale = 1;\n    let calibrationType = '';\n    if (!calibration ||\n        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {\n        return { unit, areaUnit, scale, volumeUnit };\n    }\n    if (calibration.type === CalibrationTypes.UNCALIBRATED) {\n        return {\n            unit: PIXEL_UNITS,\n            areaUnit: PIXEL_UNITS + SQUARE,\n            scale,\n            volumeUnit: VOXEL_UNITS,\n        };\n    }\n    if (calibration.sequenceOfUltrasoundRegions) {\n        let imageIndex1, imageIndex2;\n        if (Array.isArray(handles) && handles.length === 2) {\n            [imageIndex1, imageIndex2] = handles;\n        }\n        else if (typeof handles === 'function') {\n            const points = handles();\n            imageIndex1 = points[0];\n            imageIndex2 = points[1];\n        }\n        let regions = calibration.sequenceOfUltrasoundRegions.filter((region) => imageIndex1[0] >= region.regionLocationMinX0 &&\n            imageIndex1[0] <= region.regionLocationMaxX1 &&\n            imageIndex1[1] >= region.regionLocationMinY0 &&\n            imageIndex1[1] <= region.regionLocationMaxY1 &&\n            imageIndex2[0] >= region.regionLocationMinX0 &&\n            imageIndex2[0] <= region.regionLocationMaxX1 &&\n            imageIndex2[1] >= region.regionLocationMinY0 &&\n            imageIndex2[1] <= region.regionLocationMaxY1);\n        if (!regions?.length) {\n            return { unit, areaUnit, scale, volumeUnit };\n        }\n        regions = regions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n            SUPPORTED_LENGTH_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));\n        if (!regions.length) {\n            return {\n                unit: PIXEL_UNITS,\n                areaUnit: PIXEL_UNITS + SQUARE,\n                scale,\n                volumeUnit: VOXEL_UNITS,\n            };\n        }\n        const region = regions[0];\n        const physicalDeltaX = Math.abs(region.physicalDeltaX);\n        const physicalDeltaY = Math.abs(region.physicalDeltaY);\n        const isSamePhysicalDelta = utilities.isEqual(physicalDeltaX, physicalDeltaY, EPS);\n        if (isSamePhysicalDelta) {\n            scale = 1 / physicalDeltaX;\n            calibrationType = 'US Region';\n            unit = UNIT_MAPPING[region.physicalUnitsXDirection] || 'unknown';\n            areaUnit = unit + SQUARE;\n        }\n        else {\n            return {\n                unit: PIXEL_UNITS,\n                areaUnit: PIXEL_UNITS + SQUARE,\n                scale,\n                volumeUnit: VOXEL_UNITS,\n            };\n        }\n    }\n    else if (calibration.scale) {\n        scale = calibration.scale;\n    }\n    const types = [\n        CalibrationTypes.ERMF,\n        CalibrationTypes.USER,\n        CalibrationTypes.ERROR,\n        CalibrationTypes.PROJECTION,\n        CalibrationTypes.CALIBRATED,\n        CalibrationTypes.UNKNOWN,\n    ];\n    if (types.includes(calibration?.type)) {\n        calibrationType = calibration.type;\n    }\n    return {\n        unit: unit + (calibrationType ? ` ${calibrationType}` : ''),\n        areaUnit: areaUnit + (calibrationType ? ` ${calibrationType}` : ''),\n        scale,\n        volumeUnit: volumeUnit + (calibrationType ? ` ${calibrationType}` : ''),\n    };\n};\nconst getCalibratedProbeUnitsAndValue = (image, handles) => {\n    const [imageIndex] = handles;\n    const { calibration } = image;\n    let units = ['raw'];\n    let values = [null];\n    let calibrationType = '';\n    if (!calibration ||\n        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {\n        return { units, values };\n    }\n    if (calibration.sequenceOfUltrasoundRegions) {\n        const supportedRegionsMetadata = calibration.sequenceOfUltrasoundRegions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n            SUPPORTED_PROBE_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));\n        if (!supportedRegionsMetadata?.length) {\n            return { units, values };\n        }\n        const region = supportedRegionsMetadata.find((region) => imageIndex[0] >= region.regionLocationMinX0 &&\n            imageIndex[0] <= region.regionLocationMaxX1 &&\n            imageIndex[1] >= region.regionLocationMinY0 &&\n            imageIndex[1] <= region.regionLocationMaxY1);\n        if (!region) {\n            return { units, values };\n        }\n        const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;\n        const { physicalDeltaX, physicalDeltaY } = region;\n        const yValue = (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *\n            physicalDeltaY;\n        const xValue = (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *\n            physicalDeltaX;\n        calibrationType = 'US Region';\n        values = [xValue, yValue];\n        units = [\n            UNIT_MAPPING[region.physicalUnitsXDirection],\n            UNIT_MAPPING[region.physicalUnitsYDirection],\n        ];\n    }\n    return {\n        units,\n        values,\n        calibrationType,\n    };\n};\nconst getCalibratedAspect = (image) => image.calibration?.aspect || 1;\nexport { getCalibratedLengthUnitsAndScale, getCalibratedAspect, getCalibratedProbeUnitsAndValue, };\n","import { metaData } from '@cornerstonejs/core';\nfunction getPixelValueUnitsImageId(imageId, options) {\n    const generalSeriesModule = metaData.get('generalSeriesModule', imageId);\n    return getPixelValueUnits(generalSeriesModule.modality, imageId, options);\n}\nfunction getPixelValueUnits(modality, imageId, options) {\n    if (modality === 'CT') {\n        return 'HU';\n    }\n    else if (modality === 'PT') {\n        return _handlePTModality(imageId, options);\n    }\n    else {\n        return '';\n    }\n}\nfunction _handlePTModality(imageId, options) {\n    if (!options.isPreScaled) {\n        return 'raw';\n    }\n    if (options.isSuvScaled) {\n        return 'SUV';\n    }\n    const generalSeriesModule = metaData.get('generalSeriesModule', imageId);\n    if (generalSeriesModule?.modality === 'PT') {\n        const petSeriesModule = metaData.get('petSeriesModule', imageId);\n        return petSeriesModule?.units || 'unitless';\n    }\n    return 'unknown';\n}\nexport { getPixelValueUnits, getPixelValueUnitsImageId };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { getBoundingBoxAroundShapeIJK } from './boundingBox';\nconst { transformWorldToIndex } = csUtils;\nfunction _getSphereBoundsInfo(circlePoints, imageData, directionVectors) {\n    const [bottom, top] = circlePoints;\n    const centerWorld = vec3.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);\n    const radiusWorld = vec3.distance(bottom, top) / 2;\n    const { boundsIJK, topLeftWorld, bottomRightWorld } = _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld);\n    return {\n        boundsIJK,\n        centerWorld: centerWorld,\n        radiusWorld,\n        topLeftWorld: topLeftWorld,\n        bottomRightWorld: bottomRightWorld,\n    };\n}\nfunction getSphereBoundsInfo(circlePoints, imageData) {\n    const direction = imageData.getDirection();\n    const rowCosine = vec3.fromValues(direction[0], direction[1], direction[2]);\n    const columnCosine = vec3.fromValues(direction[3], direction[4], direction[5]);\n    const scanAxis = vec3.fromValues(direction[6], direction[7], direction[8]);\n    const viewPlaneNormal = vec3.negate(vec3.create(), scanAxis);\n    const directionVectors = {\n        row: rowCosine,\n        column: columnCosine,\n        normal: viewPlaneNormal,\n    };\n    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);\n}\nfunction getSphereBoundsInfoFromViewport(circlePoints, imageData, viewport) {\n    if (!viewport) {\n        throw new Error('viewport is required in order to calculate the sphere bounds');\n    }\n    const camera = viewport.getCamera();\n    const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n    const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const directionVectors = {\n        row: viewRight,\n        normal: viewPlaneNormal,\n        column: vec3.negate(vec3.create(), viewUp),\n    };\n    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);\n}\nfunction _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld) {\n    const dimensions = imageData.getDimensions();\n    const { row: rowCosine, column: columnCosine, normal: vecNormal, } = directionVectors;\n    const topLeftWorld = vec3.create();\n    const bottomRightWorld = vec3.create();\n    vec3.scaleAndAdd(topLeftWorld, centerWorld, vecNormal, radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, centerWorld, vecNormal, -radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, columnCosine, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, columnCosine, radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, rowCosine, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, rowCosine, radiusWorld);\n    const topLeftIJK = transformWorldToIndex(imageData, topLeftWorld);\n    const bottomRightIJK = transformWorldToIndex(imageData, bottomRightWorld);\n    const pointsIJK = circlePoints.map((p) => transformWorldToIndex(imageData, p));\n    const boundsIJK = getBoundingBoxAroundShapeIJK([topLeftIJK, bottomRightIJK, ...pointsIJK], dimensions);\n    return { boundsIJK, topLeftWorld, bottomRightWorld };\n}\nexport { getSphereBoundsInfo, getSphereBoundsInfoFromViewport };\n","import { getEnabledElements, utilities as csUtils } from '@cornerstonejs/core';\nconst { isEqual } = csUtils;\nexport default function getViewportsForAnnotation(annotation) {\n    const { metadata } = annotation;\n    return getEnabledElements()\n        .filter((enabledElement) => {\n        if (enabledElement.FrameOfReferenceUID === metadata.FrameOfReferenceUID) {\n            const viewport = enabledElement.viewport;\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            return (isEqual(viewPlaneNormal, metadata.viewPlaneNormal) &&\n                (!metadata.viewUp || isEqual(viewUp, metadata.viewUp)));\n        }\n        return;\n    })\n        .map((enabledElement) => enabledElement.viewport);\n}\n","import { utilities, triggerEvent } from '@cornerstonejs/core';\nimport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement, } from './getAnnotationNearPoint';\nimport debounce from './debounce';\nimport throttle from './throttle';\nimport isObject from './isObject';\nimport calibrateImageSpacing from './calibrateImageSpacing';\nimport { getCalibratedLengthUnitsAndScale, getCalibratedProbeUnitsAndValue, getCalibratedAspect, } from './getCalibratedUnits';\nimport triggerAnnotationRenderForViewportIds from './triggerAnnotationRenderForViewportIds';\nimport triggerAnnotationRenderForToolGroupIds from './triggerAnnotationRenderForToolGroupIds';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getSphereBoundsInfo } from './getSphereBoundsInfo';\nimport { pointToString } from './pointToString';\nimport AnnotationMultiSlice from './AnnotationMultiSlice';\nimport getViewportForAnnotation from './getViewportForAnnotation';\nimport { annotationHydration, getClosestImageIdForStackViewport, } from './annotationHydration';\nimport * as contours from './contours';\nimport * as segmentation from './segmentation';\nimport * as drawing from './drawing';\nimport * as math from './math';\nimport * as planar from './planar';\nimport * as viewportFilters from './viewportFilters';\nimport * as orientation from './orientation';\nimport * as cine from './cine';\nimport * as boundingBox from './boundingBox';\nimport * as planarFreehandROITool from './planarFreehandROITool';\nimport * as rectangleROITool from './rectangleROITool';\nimport { stackPrefetch, stackContextPrefetch } from './stackPrefetch';\nimport * as viewport from './viewport';\nimport * as touch from './touch';\nimport * as dynamicVolume from './dynamicVolume';\nimport * as polyDataUtils from './polyData/utils';\nimport * as voi from './voi';\nimport * as contourSegmentation from './contourSegmentation';\nimport { pointInSurroundingSphereCallback } from './pointInSurroundingSphereCallback';\nconst roundNumber = utilities.roundNumber;\nimport normalizeViewportPlane from './normalizeViewportPlane';\nimport IslandRemoval from './segmentation/islandRemoval';\nimport { getPixelValueUnits, getPixelValueUnitsImageId, } from './getPixelValueUnits';\nimport * as geometricSurfaceUtils from './geometricSurfaceUtils';\nimport setAnnotationLabel from './setAnnotationLabel';\nimport { moveAnnotationToViewPlane } from './moveAnnotationToViewPlane';\nimport getOrCreateImageVolume from './segmentation/getOrCreateImageVolume';\nimport * as usFanExtraction from '../tools/annotation/UltrasoundPleuraBLineTool/utils/fanExtraction';\nexport { math, planar, viewportFilters, drawing, debounce, dynamicVolume, throttle, orientation, isObject, touch, triggerEvent, calibrateImageSpacing, getCalibratedLengthUnitsAndScale, getCalibratedProbeUnitsAndValue, getCalibratedAspect, getPixelValueUnits, getPixelValueUnitsImageId, segmentation, contours, triggerAnnotationRenderForViewportIds, triggerAnnotationRenderForToolGroupIds, triggerAnnotationRender, getSphereBoundsInfo, getAnnotationNearPoint, getViewportForAnnotation, getAnnotationNearPointOnEnabledElement, viewport, cine, boundingBox, rectangleROITool, planarFreehandROITool, stackPrefetch, stackContextPrefetch, roundNumber, pointToString, polyDataUtils, voi, AnnotationMultiSlice, contourSegmentation, annotationHydration, getClosestImageIdForStackViewport, pointInSurroundingSphereCallback, normalizeViewportPlane, IslandRemoval, geometricSurfaceUtils, usFanExtraction, setAnnotationLabel, moveAnnotationToViewPlane, getOrCreateImageVolume, };\n","import { pointsAreEqual } from './robustSegmentIntersection';\nexport default function arePolylinesIdentical(poly1, poly2) {\n    if (poly1.length !== poly2.length) {\n        return false;\n    }\n    const len = poly1.length;\n    if (len === 0) {\n        return true;\n    }\n    let identicalForward = true;\n    for (let i = 0; i < len; i++) {\n        if (!pointsAreEqual(poly1[i], poly2[i])) {\n            identicalForward = false;\n            break;\n        }\n    }\n    if (identicalForward) {\n        return true;\n    }\n    let identicalReverse = true;\n    for (let i = 0; i < len; i++) {\n        if (!pointsAreEqual(poly1[i], poly2[len - 1 - i])) {\n            identicalReverse = false;\n            break;\n        }\n    }\n    if (identicalReverse) {\n        return true;\n    }\n    for (let offset = 1; offset < len; offset++) {\n        let cyclicForward = true;\n        for (let i = 0; i < len; i++) {\n            if (!pointsAreEqual(poly1[i], poly2[(i + offset) % len])) {\n                cyclicForward = false;\n                break;\n            }\n        }\n        if (cyclicForward) {\n            return true;\n        }\n        let cyclicReverse = true;\n        for (let i = 0; i < len; i++) {\n            if (!pointsAreEqual(poly1[i], poly2[(len - 1 - i + offset) % len])) {\n                cyclicReverse = false;\n                break;\n            }\n        }\n        if (cyclicReverse) {\n            return true;\n        }\n    }\n    return false;\n}\n","import containsPoint from './containsPoint';\nexport default function containsPoints(polyline, points) {\n    for (let i = 0, numPoint = points.length; i < numPoint; i++) {\n        if (!containsPoint(polyline, points[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n","import * as mathLine from '../line';\nconst DEFAULT_EPSILON = 0.1;\nexport default function decimate(polyline, epsilon = DEFAULT_EPSILON) {\n    const numPoints = polyline.length;\n    if (numPoints < 3) {\n        return polyline;\n    }\n    const epsilonSquared = epsilon * epsilon;\n    const partitionQueue = [[0, numPoints - 1]];\n    const polylinePointFlags = new Array(numPoints).fill(false);\n    let numDecimatedPoints = 2;\n    polylinePointFlags[0] = true;\n    polylinePointFlags[numPoints - 1] = true;\n    while (partitionQueue.length) {\n        const [startIndex, endIndex] = partitionQueue.pop();\n        if (endIndex - startIndex === 1) {\n            continue;\n        }\n        const startPoint = polyline[startIndex];\n        const endPoint = polyline[endIndex];\n        let maxDistSquared = -Infinity;\n        let maxDistIndex = -1;\n        for (let i = startIndex + 1; i < endIndex; i++) {\n            const currentPoint = polyline[i];\n            const distSquared = mathLine.distanceToPointSquared(startPoint, endPoint, currentPoint);\n            if (distSquared > maxDistSquared) {\n                maxDistSquared = distSquared;\n                maxDistIndex = i;\n            }\n        }\n        if (maxDistSquared < epsilonSquared) {\n            continue;\n        }\n        polylinePointFlags[maxDistIndex] = true;\n        numDecimatedPoints++;\n        partitionQueue.push([maxDistIndex, endIndex]);\n        partitionQueue.push([startIndex, maxDistIndex]);\n    }\n    const decimatedPolyline = new Array(numDecimatedPoints);\n    for (let srcIndex = 0, dstIndex = 0; srcIndex < numPoints; srcIndex++) {\n        if (polylinePointFlags[srcIndex]) {\n            decimatedPolyline[dstIndex++] = polyline[srcIndex];\n        }\n    }\n    return decimatedPolyline;\n}\n","export default function getSignedArea(polyline) {\n    if (polyline.length < 3) {\n        return 0;\n    }\n    const refPoint = polyline[0];\n    let area = 0;\n    for (let i = 0, len = polyline.length; i < len; i++) {\n        const p1 = polyline[i];\n        const p2Index = i === len - 1 ? 0 : i + 1;\n        const p2 = polyline[p2Index];\n        const aX = p1[0] - refPoint[0];\n        const aY = p1[1] - refPoint[1];\n        const bX = p2[0] - refPoint[0];\n        const bY = p2[1] - refPoint[1];\n        area += aX * bY - aY * bX;\n    }\n    area *= 0.5;\n    return area;\n}\n","import { glMatrix } from 'gl-matrix';\nimport { distanceToPointSquared } from '../point';\nexport default function isClosed(polyline) {\n    if (polyline.length < 3) {\n        return false;\n    }\n    const numPolylinePoints = polyline.length;\n    const firstPoint = polyline[0];\n    const lastPoint = polyline[numPolylinePoints - 1];\n    const distFirstToLastPoints = distanceToPointSquared(firstPoint, lastPoint);\n    return glMatrix.equals(0, distFirstToLastPoints);\n}\n","export default function findClosestPoint(sourcePoints, targetPoint) {\n    let minPoint = [0, 0];\n    let minDistance = Number.MAX_SAFE_INTEGER;\n    sourcePoints.forEach(function (sourcePoint) {\n        const distance = _distanceBetween(targetPoint, sourcePoint);\n        if (distance < minDistance) {\n            minDistance = distance;\n            minPoint = [...sourcePoint];\n        }\n    });\n    return minPoint;\n}\nfunction _distanceBetween(p1, p2) {\n    const [x1, y1] = p1;\n    const [x2, y2] = p2;\n    return Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));\n}\n","import { StackViewport } from '@cornerstonejs/core';\nimport * as vec3 from 'gl-matrix/vec3';\nexport function moveAnnotationToViewPlane(annotation, viewport) {\n    const { data } = annotation;\n    const { points } = data.handles;\n    const { focalPoint, viewPlaneNormal } = viewport.getCamera();\n    const projectedDistance = vec3.dot(vec3.sub(vec3.create(), points[0], focalPoint), viewPlaneNormal);\n    points.forEach((point) => {\n        vec3.add(point, point, vec3.scale(vec3.create(), [-viewPlaneNormal[0], -viewPlaneNormal[1], -viewPlaneNormal[2]], projectedDistance));\n    });\n    if (viewport instanceof StackViewport) {\n        annotation.metadata.referencedImageId = viewport.getCurrentImageId();\n    }\n    return annotation;\n}\n","import { BaseVolumeViewport, utilities } from '@cornerstonejs/core';\nconst { isEqual } = utilities;\nconst acquisitionMapping = {\n    toIJK: (ijkPrime) => ijkPrime,\n    fromIJK: (ijk) => ijk,\n    type: 'acquistion',\n};\nconst jkMapping = {\n    toIJK: ([j, k, i]) => [i, j, k],\n    fromIJK: ([i, j, k]) => [j, k, i],\n    type: 'jk',\n};\nconst ikMapping = {\n    toIJK: ([i, k, j]) => [i, j, k],\n    fromIJK: ([i, j, k]) => [i, k, j],\n    type: 'ik',\n};\nexport default function normalizeViewportPlane(viewport, boundsIJK) {\n    if (!(viewport instanceof BaseVolumeViewport)) {\n        return { ...acquisitionMapping, boundsIJKPrime: boundsIJK };\n    }\n    const { viewPlaneNormal } = viewport.getCamera();\n    const mapping = (isEqual(Math.abs(viewPlaneNormal[0]), 1) && jkMapping) ||\n        (isEqual(Math.abs(viewPlaneNormal[1]), 1) && ikMapping) ||\n        (isEqual(Math.abs(viewPlaneNormal[2]), 1) && acquisitionMapping);\n    if (!mapping) {\n        return {\n            toIJK: null,\n            boundsIJKPrime: null,\n            fromIJK: null,\n            error: `Only mappings orthogonal to acquisition plane are permitted, but requested ${viewPlaneNormal}`,\n        };\n    }\n    return { ...mapping, boundsIJKPrime: mapping.fromIJK(boundsIJK) };\n}\n","export default function getOrientationStringLPS(vector) {\n    let orientation = '';\n    const orientationX = vector[0] < 0 ? 'R' : 'L';\n    const orientationY = vector[1] < 0 ? 'A' : 'P';\n    const orientationZ = vector[2] < 0 ? 'F' : 'H';\n    const abs = [Math.abs(vector[0]), Math.abs(vector[1]), Math.abs(vector[2])];\n    const MIN = 0.0001;\n    for (let i = 0; i < 3; i++) {\n        if (abs[0] > MIN && abs[0] > abs[1] && abs[0] > abs[2]) {\n            orientation += orientationX;\n            abs[0] = 0;\n        }\n        else if (abs[1] > MIN && abs[1] > abs[0] && abs[1] > abs[2]) {\n            orientation += orientationY;\n            abs[1] = 0;\n        }\n        else if (abs[2] > MIN && abs[2] > abs[0] && abs[2] > abs[1]) {\n            orientation += orientationZ;\n            abs[2] = 0;\n        }\n        else if (abs[0] > MIN && abs[1] > MIN && abs[0] === abs[1]) {\n            orientation += orientationX + orientationY;\n            abs[0] = 0;\n            abs[1] = 0;\n        }\n        else if (abs[0] > MIN && abs[2] > MIN && abs[0] === abs[2]) {\n            orientation += orientationX + orientationZ;\n            abs[0] = 0;\n            abs[2] = 0;\n        }\n        else if (abs[1] > MIN && abs[2] > MIN && abs[1] === abs[2]) {\n            orientation += orientationY + orientationZ;\n            abs[1] = 0;\n            abs[2] = 0;\n        }\n        else {\n            break;\n        }\n    }\n    return orientation;\n}\n","export default function invertOrientationStringLPS(orientationString) {\n    let inverted = orientationString.replace('H', 'f');\n    inverted = inverted.replace('F', 'h');\n    inverted = inverted.replace('R', 'l');\n    inverted = inverted.replace('L', 'r');\n    inverted = inverted.replace('A', 'p');\n    inverted = inverted.replace('P', 'a');\n    inverted = inverted.toUpperCase();\n    return inverted;\n}\n","import smoothAnnotation from './smoothAnnotation';\nexport default {\n    smoothAnnotation,\n};\nexport { smoothAnnotation };\n","import { interpolatePoints } from './algorithms/bspline';\nfunction getContinuousUniformDistributionValues(minDistributionDistance, closedInterval) {\n    const result = [];\n    const [intervalIni, intervalEnd] = closedInterval;\n    const intervalSize = intervalEnd - intervalIni + 1;\n    const intensity = Math.floor(intervalSize / minDistributionDistance);\n    let x = 0;\n    let continuosDistributionValue = Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n    while (continuosDistributionValue <= intervalEnd) {\n        result.push(continuosDistributionValue);\n        x++;\n        continuosDistributionValue =\n            Math.round(((intervalSize - 1) / (intensity - 1)) * x) + intervalIni;\n    }\n    return result;\n}\nexport default function interpolateSegmentPoints(points, iniIndex, endIndex, knotsRatioPercentage) {\n    const segmentSize = endIndex - iniIndex + 1;\n    const amountOfKnots = Math.floor((knotsRatioPercentage / 100) * segmentSize) ?? 1;\n    const minKnotDistance = Math.floor(segmentSize / amountOfKnots) ?? 1;\n    if (isNaN(segmentSize) || !segmentSize || !minKnotDistance) {\n        return points;\n    }\n    if (segmentSize / minKnotDistance < 2) {\n        return points;\n    }\n    const interpolationIniIndex = Math.max(0, iniIndex);\n    const interpolationEndIndex = Math.min(points.length - 1, endIndex);\n    const segmentPointsUnchangedBeg = points.slice(0, interpolationIniIndex);\n    const segmentPointsUnchangedEnd = points.slice(interpolationEndIndex + 1, points.length);\n    const knotsIndexes = getContinuousUniformDistributionValues(minKnotDistance, [\n        interpolationIniIndex,\n        interpolationEndIndex,\n    ]);\n    const interpolatedPoints = interpolatePoints(points, knotsIndexes);\n    return [\n        ...segmentPointsUnchangedBeg,\n        ...interpolatedPoints,\n        ...segmentPointsUnchangedEnd,\n    ];\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { pointInSphere } from './math/sphere';\nimport { getBoundingBoxAroundShape } from './boundingBox';\nconst { transformWorldToIndex } = csUtils;\nexport function pointInSurroundingSphereCallback(imageData, circlePoints, callback, viewport) {\n    const { boundsIJK, centerWorld, radiusWorld } = _getBounds(circlePoints, imageData, viewport);\n    const sphereObj = {\n        center: centerWorld,\n        radius: radiusWorld,\n    };\n    const dimensions = imageData.getDimensions();\n    const voxelManager = csUtils.VoxelManager.createScalarVolumeVoxelManager({\n        dimensions: dimensions,\n        scalarData: imageData.getPointData().getScalars().getData(),\n    });\n    voxelManager.forEach(callback, {\n        boundsIJK,\n        isInObject: (pointLPS) => pointInSphere(sphereObj, pointLPS),\n        imageData,\n    });\n}\nfunction _getBounds(circlePoints, imageData, viewport) {\n    const [bottom, top] = circlePoints;\n    const centerWorld = vec3.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);\n    const radiusWorld = vec3.distance(bottom, top) / 2;\n    let boundsIJK;\n    if (!viewport) {\n        const centerIJK = transformWorldToIndex(imageData, centerWorld);\n        const spacings = imageData.getSpacing();\n        const minSpacing = Math.min(...spacings);\n        const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);\n        boundsIJK = [\n            [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],\n            [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],\n            [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],\n        ];\n        return {\n            boundsIJK,\n            centerWorld: centerWorld,\n            radiusWorld,\n        };\n    }\n    boundsIJK = _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld);\n    return {\n        boundsIJK,\n        centerWorld: centerWorld,\n        radiusWorld,\n    };\n}\nfunction _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld) {\n    const [bottom, top] = circlePoints;\n    const dimensions = imageData.getDimensions();\n    const camera = viewport.getCamera();\n    const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n    const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const topLeftWorld = vec3.create();\n    const bottomRightWorld = vec3.create();\n    vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n    const sphereCornersIJK = [\n        transformWorldToIndex(imageData, topLeftWorld),\n        (transformWorldToIndex(imageData, bottomRightWorld)),\n    ];\n    const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);\n    return boundsIJK;\n}\n","export function pointToString(point, decimals = 5) {\n    return (parseFloat(point[0]).toFixed(decimals) +\n        ',' +\n        parseFloat(point[1]).toFixed(decimals) +\n        ',' +\n        parseFloat(point[2]).toFixed(decimals) +\n        ',');\n}\n","import { vec3 } from 'gl-matrix';\nexport function getPoint(points, idx) {\n    const idx3 = idx * 3;\n    if (idx3 < points.length) {\n        return vec3.fromValues(points[idx3], points[idx3 + 1], points[idx3 + 2]);\n    }\n}\nexport function getPolyDataPointIndexes(polyData) {\n    const linesData = polyData.getLines().getData();\n    let idx = 0;\n    const lineSegments = new Map();\n    while (idx < linesData.length) {\n        const segmentSize = linesData[idx++];\n        const segment = [];\n        for (let i = 0; i < segmentSize; i++) {\n            segment.push(linesData[idx + i]);\n        }\n        lineSegments.set(segment[0], segment);\n        idx += segmentSize;\n    }\n    const contours = [];\n    const findStartingPoint = (map) => {\n        for (const [key, value] of map.entries()) {\n            if (value !== undefined) {\n                return key;\n            }\n        }\n        return -1;\n    };\n    let startPoint = findStartingPoint(lineSegments);\n    while (startPoint !== -1) {\n        const contour = [startPoint];\n        while (lineSegments.has(startPoint)) {\n            const nextPoint = lineSegments.get(startPoint)[1];\n            if (lineSegments.has(nextPoint)) {\n                contour.push(nextPoint);\n            }\n            lineSegments.delete(startPoint);\n            startPoint = nextPoint;\n        }\n        contours.push(contour);\n        startPoint = findStartingPoint(lineSegments);\n    }\n    return contours.length ? contours : undefined;\n}\nexport function getPolyDataPoints(polyData) {\n    const contoursIndexes = getPolyDataPointIndexes(polyData);\n    if (!contoursIndexes) {\n        return;\n    }\n    const rawPointsData = polyData.getPoints().getData();\n    return contoursIndexes.map((contourIndexes) => contourIndexes.map((index) => getPoint(rawPointsData, index)));\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\nimport extend2DBoundingBoxInViewAxis from '../boundingBox/extend2DBoundingBoxInViewAxis';\nfunction getBoundsIJKFromRectangleAnnotations(annotations, referenceVolume, options = {}) {\n    const AllBoundsIJK = [];\n    annotations.forEach((annotation) => {\n        const { data } = annotation;\n        const { points } = data.handles;\n        const { imageData, dimensions } = referenceVolume;\n        let pointsToUse = points;\n        if (data.cachedStats?.projectionPoints) {\n            const { projectionPoints } = data.cachedStats;\n            pointsToUse = [].concat(...projectionPoints);\n        }\n        const rectangleCornersIJK = pointsToUse.map((world) => csUtils.transformWorldToIndex(imageData, world));\n        let boundsIJK = getBoundingBoxAroundShapeIJK(rectangleCornersIJK, dimensions);\n        if (options.numSlicesToProject && !data.cachedStats?.projectionPoints) {\n            boundsIJK = extend2DBoundingBoxInViewAxis(boundsIJK, options.numSlicesToProject);\n        }\n        AllBoundsIJK.push(boundsIJK);\n    });\n    if (AllBoundsIJK.length === 1) {\n        return AllBoundsIJK[0];\n    }\n    const boundsIJK = AllBoundsIJK.reduce((accumulator, currentValue) => {\n        return {\n            iMin: Math.min(accumulator.iMin, currentValue.iMin),\n            jMin: Math.min(accumulator.jMin, currentValue.jMin),\n            kMin: Math.min(accumulator.kMin, currentValue.kMin),\n            iMax: Math.max(accumulator.iMax, currentValue.iMax),\n            jMax: Math.max(accumulator.jMax, currentValue.jMax),\n            kMax: Math.max(accumulator.kMax, currentValue.kMax),\n        };\n    }, {\n        iMin: Infinity,\n        jMin: Infinity,\n        kMin: Infinity,\n        iMax: -Infinity,\n        jMax: -Infinity,\n        kMax: -Infinity,\n    });\n    return boundsIJK;\n}\nexport default getBoundsIJKFromRectangleAnnotations;\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nconst { isEqual } = csUtils;\nconst iAxis = vec3.fromValues(1, 0, 0);\nconst jAxis = vec3.fromValues(0, 1, 0);\nconst kAxis = vec3.fromValues(0, 0, 1);\nconst axisList = [iAxis, jAxis, kAxis];\nfunction isAxisAlignedRectangle(rectangleCornersIJK) {\n    const rectangleVec1 = vec3.subtract(vec3.create(), rectangleCornersIJK[0], rectangleCornersIJK[1]);\n    const rectangleVec2 = vec3.subtract(vec3.create(), rectangleCornersIJK[0], rectangleCornersIJK[2]);\n    const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);\n    const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);\n    const isAligned = [...anglesVec1, ...anglesVec2].every((angle) => isEqual(angle, 0) ||\n        isEqual(angle, 90) ||\n        isEqual(angle, 180) ||\n        isEqual(angle, 270));\n    return isAligned;\n}\nfunction calculateAnglesWithAxes(vec, axes) {\n    return axes.map((axis) => (vec3.angle(vec, axis) * 180) / Math.PI);\n}\nexport { isAxisAlignedRectangle };\n","import { getWebWorkerManager } from '@cornerstonejs/core';\nimport { getConfig } from '../config';\nlet registered = false;\nexport function registerComputeWorker() {\n    if (registered) {\n        return;\n    }\n    registered = true;\n    const workerFn = () => {\n        return new Worker(new URL('../workers/computeWorker.js', import.meta.url), {\n            name: 'compute',\n            type: 'module',\n        });\n    };\n    const workerManager = getWebWorkerManager();\n    const config = getConfig();\n    const computeWorkerConfig = config.computeWorker;\n    const options = {\n        maxWorkerInstances: 1,\n        autoTerminateOnIdle: computeWorkerConfig?.autoTerminateOnIdle ?? {\n            enabled: true,\n            idleTimeThreshold: 2000,\n        },\n    };\n    workerManager.registerWorker('compute', workerFn, options);\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { state as annotationState } from '../../../stateManagement/annotation';\nimport getInterpolationDataCollection from '../../contours/interpolation/getInterpolationDataCollection';\nimport interpolate from '../../contours/interpolation/interpolate';\nimport deleteRelatedAnnotations from './deleteRelatedAnnotations';\nimport ChangeTypes from '../../../enums/ChangeTypes';\nimport getViewportForAnnotation from '../../getViewportForAnnotation';\nimport { addContourSegmentationAnnotation } from '../../contourSegmentation/addContourSegmentationAnnotation';\nconst { uuidv4 } = csUtils;\nconst ChangeTypesForInterpolation = [\n    ChangeTypes.HandlesUpdated,\n    ChangeTypes.InterpolationUpdated,\n];\nexport default class InterpolationManager {\n    static { this.toolNames = []; }\n    static addTool(toolName) {\n        if (!this.toolNames.includes(toolName)) {\n            this.toolNames.push(toolName);\n        }\n    }\n    static removeTool(toolName) {\n        if (this.toolNames.includes(toolName)) {\n            this.toolNames = this.toolNames.filter((name) => name !== toolName);\n        }\n    }\n    static acceptAutoGenerated(annotationGroupSelector, selector = {}) {\n        const { toolNames, segmentationId, segmentIndex, sliceIndex } = selector;\n        for (const toolName of toolNames || InterpolationManager.toolNames) {\n            const annotations = annotationState.getAnnotations(toolName, annotationGroupSelector);\n            if (!annotations?.length) {\n                continue;\n            }\n            for (const annotation of annotations) {\n                const { interpolationUID, data, autoGenerated, metadata } = annotation;\n                if (interpolationUID) {\n                    annotation.interpolationCompleted = true;\n                }\n                if (!autoGenerated) {\n                    continue;\n                }\n                if (segmentIndex && segmentIndex !== data.segmentation.segmentIndex) {\n                    continue;\n                }\n                if (sliceIndex !== undefined &&\n                    metadata &&\n                    sliceIndex !== metadata.sliceIndex) {\n                    continue;\n                }\n                if (segmentationId &&\n                    segmentationId !== data.segmentation.segmentationId) {\n                    continue;\n                }\n                addContourSegmentationAnnotation(annotation);\n                annotation.autoGenerated = false;\n            }\n        }\n    }\n    static { this.handleAnnotationCompleted = (evt) => {\n        const annotation = evt.detail.annotation;\n        if (!annotation?.metadata) {\n            return;\n        }\n        const { toolName, originalToolName } = annotation.metadata;\n        if (!this.toolNames.includes(toolName) &&\n            !this.toolNames.includes(originalToolName)) {\n            return;\n        }\n        const viewport = getViewportForAnnotation(annotation);\n        if (!viewport) {\n            console.warn('Unable to find viewport for', annotation);\n            return;\n        }\n        const sliceData = getSliceData(viewport);\n        const viewportData = {\n            viewport,\n            sliceData,\n            annotation,\n            interpolationUID: annotation.interpolationUID,\n        };\n        const hasInterpolationUID = !!annotation.interpolationUID;\n        annotation.autoGenerated = false;\n        if (hasInterpolationUID) {\n            deleteRelatedAnnotations(viewportData);\n            interpolate(viewportData);\n            return;\n        }\n        const filterData = [\n            {\n                key: 'segmentIndex',\n                value: annotation.data.segmentation.segmentIndex,\n                parentKey: (annotation) => annotation.data.segmentation,\n            },\n            {\n                key: 'viewPlaneNormal',\n                value: annotation.metadata.viewPlaneNormal,\n                parentKey: (annotation) => annotation.metadata,\n            },\n            {\n                key: 'viewUp',\n                value: annotation.metadata.viewUp,\n                parentKey: (annotation) => annotation.metadata,\n            },\n        ];\n        let interpolationAnnotations = getInterpolationDataCollection(viewportData, filterData);\n        const { sliceIndex } = annotation.metadata;\n        const skipUIDs = new Set();\n        interpolationAnnotations.forEach((interpolationAnnotation) => {\n            if (interpolationAnnotation.interpolationCompleted ||\n                interpolationAnnotation.metadata.sliceIndex === sliceIndex) {\n                const { interpolationUID } = interpolationAnnotation;\n                skipUIDs.add(interpolationUID);\n            }\n        });\n        interpolationAnnotations = interpolationAnnotations.filter((interpolationAnnotation) => !skipUIDs.has(interpolationAnnotation.interpolationUID));\n        annotation.interpolationUID =\n            interpolationAnnotations[0]?.interpolationUID || uuidv4();\n        viewportData.interpolationUID = annotation.interpolationUID;\n        interpolate(viewportData);\n    }; }\n    static { this.handleAnnotationUpdate = (evt) => {\n        const annotation = evt.detail.annotation;\n        const { changeType = ChangeTypes.HandlesUpdated } = evt.detail;\n        if (!annotation?.metadata) {\n            return;\n        }\n        const { toolName, originalToolName } = annotation.metadata;\n        if ((!this.toolNames.includes(toolName) &&\n            !this.toolNames.includes(originalToolName)) ||\n            !ChangeTypesForInterpolation.includes(changeType)) {\n            return;\n        }\n        const viewport = getViewportForAnnotation(annotation);\n        if (!viewport) {\n            console.warn('Unable to find matching viewport for annotation interpolation', annotation);\n            return;\n        }\n        if (annotation.autoGenerated) {\n            addContourSegmentationAnnotation(annotation);\n            annotation.autoGenerated = false;\n        }\n        const sliceData = getSliceData(viewport);\n        const viewportData = {\n            viewport,\n            sliceData,\n            annotation,\n            interpolationUID: annotation.interpolationUID,\n            isInterpolationUpdate: changeType === ChangeTypes.InterpolationUpdated,\n        };\n        interpolate(viewportData);\n    }; }\n    static { this.handleAnnotationDelete = (evt) => {\n        const annotation = evt.detail.annotation;\n        if (!annotation?.metadata) {\n            return;\n        }\n        const { toolName } = annotation.metadata;\n        if (!this.toolNames.includes(toolName) || annotation.autoGenerated) {\n            return;\n        }\n        const viewport = getViewportForAnnotation(annotation);\n        if (!viewport) {\n            console.warn(\"No viewport, can't delete interpolated results\", annotation);\n            return;\n        }\n        const sliceData = getSliceData(viewport);\n        const viewportData = {\n            viewport,\n            sliceData,\n            annotation,\n            interpolationUID: annotation.interpolationUID,\n        };\n        annotation.autoGenerated = false;\n        deleteRelatedAnnotations(viewportData);\n    }; }\n}\nfunction getSliceData(viewport) {\n    const sliceData = {\n        numberOfSlices: viewport.getNumberOfSlices(),\n        imageIndex: viewport.getCurrentImageIdIndex(),\n    };\n    return sliceData;\n}\n","import { InstanceVolumetricCalculator } from './VolumetricCalculator';\nexport default class SegmentStatsCalculator {\n    static { this.calculators = new Map(); }\n    static { this.indices = []; }\n    static { this.mode = 'collective'; }\n    static statsInit(options) {\n        const { storePointData, indices, mode } = options;\n        this.mode = mode;\n        this.indices = indices;\n        this.calculators.clear();\n        if (this.mode === 'individual') {\n            indices.forEach((index) => {\n                this.calculators.set(index, new InstanceVolumetricCalculator({ storePointData }));\n            });\n        }\n        else {\n            this.calculators.set(indices, new InstanceVolumetricCalculator({ storePointData }));\n        }\n    }\n    static statsCallback(data) {\n        const { segmentIndex, ...statsData } = data;\n        if (!segmentIndex) {\n            throw new Error('Segment index is required for stats calculation');\n        }\n        const calculator = this.mode === 'individual'\n            ? this.calculators.get(segmentIndex)\n            : this.calculators.get(this.indices);\n        if (!calculator) {\n            throw new Error(`No calculator found for segment ${segmentIndex}`);\n        }\n        calculator.statsCallback(statsData);\n    }\n    static getStatistics(options) {\n        if (this.mode === 'individual') {\n            const result = {};\n            this.calculators.forEach((calculator, segmentIndex) => {\n                result[segmentIndex] = calculator.getStatistics(options);\n            });\n            return result;\n        }\n        const calculator = this.calculators.get(this.indices);\n        return calculator.getStatistics(options);\n    }\n}\n","import { BasicStatsCalculator, InstanceBasicStatsCalculator, } from '../math/basic/BasicStatsCalculator';\nimport { getCalibratedLengthUnitsAndScale } from '../getCalibratedUnits';\nconst TEST_MAX_LOCATIONS = 10;\nfunction createVolumetricState() {\n    return {\n        maxIJKs: [],\n    };\n}\nfunction volumetricStatsCallback(state, data) {\n    const { value } = data;\n    const { maxIJKs } = state;\n    const length = maxIJKs.length;\n    if (typeof value !== 'number' ||\n        (length >= TEST_MAX_LOCATIONS && value < maxIJKs[0].value)) {\n        return;\n    }\n    const dataCopy = {\n        value: data.value,\n        pointLPS: data.pointLPS\n            ? [data.pointLPS[0], data.pointLPS[1], data.pointLPS[2]]\n            : undefined,\n        pointIJK: data.pointIJK\n            ? [data.pointIJK[0], data.pointIJK[1], data.pointIJK[2]]\n            : undefined,\n    };\n    if (!length || value >= maxIJKs[length - 1].value) {\n        maxIJKs.push(dataCopy);\n    }\n    else {\n        for (let i = 0; i < length; i++) {\n            if (value <= maxIJKs[i].value) {\n                maxIJKs.splice(i, 0, dataCopy);\n                break;\n            }\n        }\n    }\n    if (length >= TEST_MAX_LOCATIONS) {\n        maxIJKs.splice(0, 1);\n    }\n}\nfunction volumetricGetStatistics(state, stats, options) {\n    const { spacing, calibration } = options;\n    const { volumeUnit } = getCalibratedLengthUnitsAndScale({\n        calibration,\n        hasPixelSpacing: true,\n    }, []);\n    const volumeScale = spacing ? spacing[0] * spacing[1] * spacing[2] : 1;\n    stats.volume = {\n        value: Array.isArray(stats.count.value)\n            ? stats.count.value.map((v) => v * volumeScale)\n            : stats.count.value * volumeScale,\n        unit: volumeUnit,\n        name: 'volume',\n        label: 'Volume',\n    };\n    stats.maxIJKs = state.maxIJKs.filter((entry) => entry.pointIJK !== undefined);\n    stats.array.push(stats.volume);\n    state.maxIJKs = [];\n    return stats;\n}\nexport class VolumetricCalculator extends BasicStatsCalculator {\n    static { this.volumetricState = createVolumetricState(); }\n    static statsInit(options) {\n        super.statsInit(options);\n        this.volumetricState = createVolumetricState();\n    }\n    static statsCallback(data) {\n        super.statsCallback(data);\n        volumetricStatsCallback(this.volumetricState, data);\n    }\n    static getStatistics(options) {\n        const optionsWithUnit = {\n            ...options,\n            unit: options?.unit || 'none',\n            calibration: options?.calibration,\n            hasPixelSpacing: options?.hasPixelSpacing,\n        };\n        const stats = super.getStatistics(optionsWithUnit);\n        return volumetricGetStatistics(this.volumetricState, stats, optionsWithUnit);\n    }\n}\nexport class InstanceVolumetricCalculator extends InstanceBasicStatsCalculator {\n    constructor(options) {\n        super(options);\n        this.volumetricState = createVolumetricState();\n    }\n    statsInit(options) {\n        super.statsInit(options);\n        this.volumetricState = createVolumetricState();\n    }\n    statsCallback(data) {\n        super.statsCallback(data);\n        volumetricStatsCallback(this.volumetricState, data);\n    }\n    getStatistics(options) {\n        const optionsWithUnit = {\n            ...options,\n            unit: options?.unit || 'none',\n            calibration: options?.calibration,\n            hasPixelSpacing: options?.hasPixelSpacing,\n        };\n        const stats = super.getStatistics(optionsWithUnit);\n        return volumetricGetStatistics(this.volumetricState, stats, optionsWithUnit);\n    }\n}\nexport default VolumetricCalculator;\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getBrushToolInstances } from './getBrushToolInstances';\nexport function setBrushSizeForToolGroup(toolGroupId, brushSize, toolName) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n    brushBasedToolInstances.forEach((tool) => {\n        const minRadius = tool.configuration.minRadius;\n        const maxRadius = tool.configuration.maxRadius;\n        let newBrushSize = minRadius ? Math.max(brushSize, minRadius) : brushSize;\n        newBrushSize = maxRadius ? Math.min(newBrushSize, maxRadius) : newBrushSize;\n        tool.configuration.brushSize = newBrushSize;\n        tool.invalidateBrushCursor();\n    });\n    const viewportIds = toolGroup.getViewportIds();\n    triggerAnnotationRenderForViewportIds(viewportIds);\n}\nexport function getBrushSizeForToolGroup(toolGroupId, toolName) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const toolInstances = toolGroup._toolInstances;\n    if (!Object.keys(toolInstances).length) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId, toolName);\n    const brushToolInstance = brushBasedToolInstances[0];\n    if (!brushToolInstance) {\n        return;\n    }\n    return brushToolInstance.configuration.brushSize;\n}\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getBrushToolInstances } from './getBrushToolInstances';\nexport function setBrushThresholdForToolGroup(toolGroupId, threshold) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n    brushBasedToolInstances.forEach((tool) => {\n        const activeStrategy = tool.configuration.activeStrategy;\n        if (!activeStrategy.toLowerCase().includes('threshold')) {\n            return;\n        }\n        tool.configuration = {\n            ...tool.configuration,\n            threshold: {\n                ...tool.configuration.threshold,\n                ...threshold,\n            },\n        };\n    });\n    const viewportsInfo = toolGroup.getViewportsInfo();\n    if (!viewportsInfo.length) {\n        return;\n    }\n    const viewportIds = toolGroup.getViewportIds();\n    triggerAnnotationRenderForViewportIds(viewportIds);\n}\nexport function getBrushThresholdForToolGroup(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const toolInstances = toolGroup._toolInstances;\n    if (!Object.keys(toolInstances).length) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n    const brushToolInstance = brushBasedToolInstances[0];\n    if (!brushToolInstance) {\n        return;\n    }\n    return brushToolInstance.configuration.threshold.range;\n}\n","import { utilities, getWebWorkerManager } from '@cornerstonejs/core';\nimport { triggerWorkerProgress } from './utilsForWorker';\nimport { WorkerTypes } from '../../enums';\nimport { registerComputeWorker } from '../registerComputeWorker';\nimport createMergedLabelmapForIndex from './createMergedLabelmapForIndex';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport getOrCreateSegmentationVolume from './getOrCreateSegmentationVolume';\nimport { getReferenceVolumeForSegmentation } from './getReferenceVolumeForSegmentation';\nasync function computeMetabolicStats({ segmentationIds, segmentIndex, }) {\n    registerComputeWorker();\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 0);\n    const segmentation = getSegmentation(segmentationIds[0]);\n    const { imageIds: segImageIds } = segmentation.representationData\n        .Labelmap;\n    const isValidVolume = utilities.isValidVolume(segImageIds);\n    if (!isValidVolume) {\n        throw new Error('Invalid volume - TMTV cannot be calculated');\n    }\n    const stats = await calculateForVolume({\n        segmentationIds,\n        segmentIndex,\n    });\n    return stats;\n}\nasync function calculateForVolume({ segmentationIds, segmentIndex }) {\n    const labelmapVolumes = segmentationIds.map((id) => {\n        return getOrCreateSegmentationVolume(id);\n    });\n    const mergedLabelmap = createMergedLabelmapForIndex(labelmapVolumes, segmentIndex);\n    if (!mergedLabelmap) {\n        throw new Error('Invalid volume - TMTV cannot be calculated');\n    }\n    const { imageData, dimensions, direction, origin, voxelManager } = mergedLabelmap;\n    const spacing = imageData.getSpacing();\n    const segmentationScalarData = voxelManager.getCompleteScalarDataArray();\n    const segmentationInfo = {\n        scalarData: segmentationScalarData,\n        dimensions,\n        spacing,\n        origin,\n        direction,\n    };\n    const referenceVolume = getReferenceVolumeForSegmentation(segmentationIds[0]);\n    const imageInfo = {\n        dimensions: referenceVolume.dimensions,\n        spacing: referenceVolume.spacing,\n        origin: referenceVolume.origin,\n        direction: referenceVolume.direction,\n        scalarData: referenceVolume.voxelManager.getCompleteScalarDataArray(),\n    };\n    if (imageInfo.scalarData.length === 0 ||\n        segmentationInfo.scalarData.length === 0) {\n        return {\n            [segmentIndex]: {\n                name: 'TMTV',\n                value: 0,\n            },\n        };\n    }\n    const stats = await getWebWorkerManager().executeTask('compute', 'computeMetabolicStats', {\n        segmentationInfo,\n        imageInfo,\n    });\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 100);\n    return stats;\n}\nexport { computeMetabolicStats };\n","import { cache } from '@cornerstonejs/core';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport getOrCreateImageVolume from './getOrCreateImageVolume';\nexport function getReferenceVolumeForSegmentation(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return null;\n    }\n    let referenceImageIds;\n    const labelmap = segmentation.representationData.Labelmap;\n    if ('imageIds' in labelmap) {\n        const { imageIds } = labelmap;\n        const firstImage = cache.getImage(imageIds[0]);\n        const volumeInfo = cache.getVolumeContainingImageId(firstImage.referencedImageId);\n        if (volumeInfo?.volume) {\n            return volumeInfo.volume;\n        }\n        referenceImageIds = imageIds.map((imageId) => cache.getImage(imageId).referencedImageId);\n    }\n    else if ('volumeId' in labelmap) {\n        const { volumeId, referencedVolumeId } = labelmap;\n        if (referencedVolumeId) {\n            const refVolume = cache.getVolume(referencedVolumeId);\n            if (refVolume) {\n                return refVolume;\n            }\n        }\n        const segVolume = cache.getVolume(volumeId);\n        if (segVolume) {\n            referenceImageIds = segVolume.imageIds.map((imageId) => cache.getImage(imageId).referencedImageId);\n        }\n    }\n    return getOrCreateImageVolume(referenceImageIds);\n}\n","import { generateContourSetsFromLabelmap } from '../contours';\nimport findLargestBidirectional from './findLargestBidirectional';\nimport getOrCreateSegmentationVolume from './getOrCreateSegmentationVolume';\nexport default async function contourAndFindLargestBidirectional(segmentation) {\n    const contours = await generateContourSetsFromLabelmap({\n        segmentations: segmentation,\n    });\n    if (!contours?.length || !contours[0].sliceContours.length) {\n        return;\n    }\n    const { segments = [\n        null,\n        { label: 'Unspecified', color: null, containedSegmentIndices: null },\n    ], } = segmentation;\n    const vol = getOrCreateSegmentationVolume(segmentation.segmentationId);\n    if (!vol) {\n        return;\n    }\n    const segmentIndex = segments.findIndex((it) => !!it);\n    if (segmentIndex === -1) {\n        return;\n    }\n    segments[segmentIndex].segmentIndex = segmentIndex;\n    return findLargestBidirectional(contours[0], vol.volumeId, segments[segmentIndex]);\n}\n","export default function createBidirectionalToolData(bidirectionalData, viewport) {\n    const { majorAxis, minorAxis, label = '', sliceIndex } = bidirectionalData;\n    const [major0, major1] = majorAxis;\n    const [minor0, minor1] = minorAxis;\n    const points = [major0, major1, minor0, minor1];\n    const bidirectionalToolData = {\n        highlighted: true,\n        invalidated: true,\n        metadata: {\n            toolName: 'Bidirectional',\n            ...viewport.getViewReference({ sliceIndex }),\n        },\n        data: {\n            handles: {\n                points,\n                textBox: {\n                    hasMoved: false,\n                    worldPosition: [0, 0, 0],\n                    worldBoundingBox: {\n                        topLeft: [0, 0, 0],\n                        topRight: [0, 0, 0],\n                        bottomLeft: [0, 0, 0],\n                        bottomRight: [0, 0, 0],\n                    },\n                },\n                activeHandleIndex: null,\n            },\n            label,\n            cachedStats: {},\n        },\n        isLocked: false,\n        isVisible: true,\n    };\n    return bidirectionalToolData;\n}\n","import { utilities, eventTarget } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport Events from '../../enums/Events';\nconst { VoxelManager, RLEVoxelMap } = utilities;\nexport function createLabelmapMemo(segmentationId, segmentationVoxelManager) {\n    return createRleMemo(segmentationId, segmentationVoxelManager);\n}\nexport function restoreMemo(isUndo) {\n    const { segmentationVoxelManager, undoVoxelManager, redoVoxelManager } = this;\n    const useVoxelManager = isUndo === false ? redoVoxelManager : undoVoxelManager;\n    useVoxelManager.forEach(({ value, pointIJK }) => {\n        segmentationVoxelManager.setAtIJKPoint(pointIJK, value);\n    });\n    const slices = useVoxelManager.getArrayOfModifiedSlices();\n    triggerSegmentationDataModified(this.segmentationId, slices);\n}\nexport function createRleMemo(segmentationId, segmentationVoxelManager) {\n    const voxelManager = VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);\n    const state = {\n        segmentationId,\n        restoreMemo,\n        commitMemo,\n        segmentationVoxelManager,\n        voxelManager,\n        id: utilities.uuidv4(),\n        operationType: 'labelmap',\n    };\n    return state;\n}\nfunction commitMemo() {\n    if (this.redoVoxelManager) {\n        return true;\n    }\n    if (!this.voxelManager.modifiedSlices.size) {\n        return false;\n    }\n    const { segmentationVoxelManager } = this;\n    const undoVoxelManager = VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);\n    RLEVoxelMap.copyMap(undoVoxelManager.map, this.voxelManager.map);\n    for (const key of this.voxelManager.modifiedSlices.keys()) {\n        undoVoxelManager.modifiedSlices.add(key);\n    }\n    this.undoVoxelManager = undoVoxelManager;\n    const redoVoxelManager = VoxelManager.createRLEVolumeVoxelManager({\n        dimensions: this.segmentationVoxelManager.dimensions,\n    });\n    this.redoVoxelManager = redoVoxelManager;\n    undoVoxelManager.forEach(({ index, pointIJK, value }) => {\n        const currentValue = segmentationVoxelManager.getAtIJKPoint(pointIJK);\n        if (currentValue === value) {\n            return;\n        }\n        redoVoxelManager.setAtIndex(index, currentValue);\n    });\n    return true;\n}\n","import { getEnabledElementByIds, volumeLoader, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nexport default async function createLabelmapVolumeForViewport(input) {\n    const { viewportId, renderingEngineId, options } = input;\n    let { segmentationId } = input;\n    const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n    if (!enabledElement) {\n        throw new Error('element disabled');\n    }\n    const { viewport } = enabledElement;\n    if (!(viewport instanceof VolumeViewport)) {\n        throw new Error('Segmentation only supports VolumeViewport');\n    }\n    const { uid } = viewport.getDefaultActor();\n    if (segmentationId === undefined) {\n        segmentationId = `${uid}-based-segmentation-${options?.volumeId ?? csUtils.uuidv4().slice(0, 8)}`;\n    }\n    if (options) {\n        const properties = structuredClone(options);\n        await volumeLoader.createLocalVolume(segmentationId, properties);\n    }\n    else {\n        const volumeId = viewport.getVolumeId();\n        volumeLoader.createAndCacheDerivedLabelmapVolume(volumeId, {\n            volumeId: segmentationId,\n        });\n    }\n    return segmentationId;\n}\n","import { volumeLoader, utilities as csUtils, cache } from '@cornerstonejs/core';\nfunction createMergedLabelmapForIndex(labelmaps, segmentIndex = 1, volumeId = 'mergedLabelmap') {\n    labelmaps.forEach(({ direction, dimensions, origin, spacing }) => {\n        if (!csUtils.isEqual(dimensions, labelmaps[0].dimensions) ||\n            !csUtils.isEqual(direction, labelmaps[0].direction) ||\n            !csUtils.isEqual(spacing, labelmaps[0].spacing) ||\n            !csUtils.isEqual(origin, labelmaps[0].origin)) {\n            throw new Error('labelmaps must have the same size and shape');\n        }\n    });\n    const labelmap = labelmaps[0];\n    const arrayType = labelmap.voxelManager.getConstructor();\n    const outputData = new arrayType(labelmap.voxelManager.getScalarDataLength());\n    labelmaps.forEach((labelmap) => {\n        const voxelManager = labelmap.voxelManager;\n        const scalarDataLength = voxelManager.getScalarDataLength();\n        for (let i = 0; i < scalarDataLength; i++) {\n            if (voxelManager.getAtIndex(i) === segmentIndex) {\n                outputData[i] = segmentIndex;\n            }\n        }\n    });\n    const options = {\n        scalarData: outputData,\n        metadata: labelmap.metadata,\n        spacing: labelmap.spacing,\n        origin: labelmap.origin,\n        direction: labelmap.direction,\n        dimensions: labelmap.dimensions,\n    };\n    const cachedVolume = cache.getVolume(volumeId);\n    let mergedVolume;\n    if (cachedVolume) {\n        mergedVolume = cachedVolume;\n        mergedVolume.voxelManager.setCompleteScalarDataArray(outputData);\n    }\n    else {\n        mergedVolume = volumeLoader.createLocalVolume(volumeId, options);\n    }\n    return mergedVolume;\n}\nexport default createMergedLabelmapForIndex;\n","import { vec3 } from 'gl-matrix';\nimport { createIsInSegment, isLineInSegment } from './isLineInSegment';\nconst EPSILON = 1e-2;\nexport default function findLargestBidirectional(contours, segVolumeId, segment) {\n    const { sliceContours } = contours;\n    const { segmentIndex, containedSegmentIndices } = segment;\n    let maxBidirectional;\n    const isInSegment = createIsInSegment(segVolumeId, segmentIndex, containedSegmentIndices);\n    for (const sliceContour of sliceContours) {\n        const bidirectional = createBidirectionalForSlice(sliceContour, isInSegment, maxBidirectional);\n        if (!bidirectional) {\n            continue;\n        }\n        maxBidirectional = bidirectional;\n    }\n    if (maxBidirectional) {\n        Object.assign(maxBidirectional, segment);\n    }\n    return maxBidirectional;\n}\nexport function createBidirectionalForSlice(sliceContour, isInSegment, currentMax = { maxMajor: 0, maxMinor: 0 }) {\n    const { points } = sliceContour.polyData;\n    const { maxMinor: currentMaxMinor, maxMajor: currentMaxMajor } = currentMax;\n    let maxMajor = currentMaxMajor * currentMaxMajor;\n    let maxMinor = currentMaxMinor * currentMaxMinor;\n    let maxMajorPoints;\n    for (let index1 = 0; index1 < points.length; index1++) {\n        for (let index2 = index1 + 1; index2 < points.length; index2++) {\n            const point1 = points[index1];\n            const point2 = points[index2];\n            const distance2 = vec3.sqrDist(point1, point2);\n            if (distance2 < maxMajor) {\n                continue;\n            }\n            if (distance2 - EPSILON < maxMajor + EPSILON && maxMajorPoints) {\n                continue;\n            }\n            if (!isInSegment.testCenter(point1, point2)) {\n                continue;\n            }\n            if (!isLineInSegment(point1, point2, isInSegment)) {\n                continue;\n            }\n            maxMajor = distance2 - EPSILON;\n            maxMajorPoints = [index1, index2];\n            maxMinor = 0;\n        }\n    }\n    if (!maxMajorPoints) {\n        return;\n    }\n    maxMajor = Math.sqrt(maxMajor + EPSILON);\n    const handle0 = points[maxMajorPoints[0]];\n    const handle1 = points[maxMajorPoints[1]];\n    const unitMajor = vec3.sub(vec3.create(), handle0, handle1);\n    vec3.scale(unitMajor, unitMajor, 1 / maxMajor);\n    let maxMinorPoints;\n    for (let index1 = 0; index1 < points.length; index1++) {\n        for (let index2 = index1 + 1; index2 < points.length; index2++) {\n            const point1 = points[index1];\n            const point2 = points[index2];\n            const distance2 = vec3.sqrDist(point1, point2);\n            if (distance2 <= maxMinor) {\n                continue;\n            }\n            const delta = vec3.sub(vec3.create(), point1, point2);\n            const dot = Math.abs(vec3.dot(delta, unitMajor)) / Math.sqrt(distance2);\n            if (dot > EPSILON) {\n                continue;\n            }\n            if (!isInSegment.testCenter(point1, point2)) {\n                continue;\n            }\n            if (!isLineInSegment(point1, point2, isInSegment)) {\n                continue;\n            }\n            maxMinor = distance2;\n            maxMinorPoints = [index1, index2];\n        }\n    }\n    if (!maxMinorPoints) {\n        return;\n    }\n    maxMinor = Math.sqrt(maxMinor);\n    const handle2 = points[maxMinorPoints[0]];\n    const handle3 = points[maxMinorPoints[1]];\n    const bidirectional = {\n        majorAxis: [handle0, handle1],\n        minorAxis: [handle2, handle3],\n        maxMajor,\n        maxMinor,\n        ...sliceContour,\n    };\n    return bidirectional;\n}\n","function floodFill(getter, seed, options = {}) {\n    const onFlood = options.onFlood;\n    const onBoundary = options.onBoundary;\n    const equals = options.equals;\n    const filter = options.filter;\n    const diagonals = options.diagonals || false;\n    const startNode = get(seed);\n    const permutations = prunedPermutations();\n    const stack = [];\n    const flooded = [];\n    const visits = new Set();\n    const bounds = options.bounds;\n    stack.push({ currentArgs: seed });\n    while (stack.length > 0) {\n        flood(stack.pop());\n    }\n    return {\n        flooded,\n    };\n    function flood(job) {\n        const getArgs = job.currentArgs;\n        const prevArgs = job.previousArgs;\n        if (visited(getArgs)) {\n            return;\n        }\n        markAsVisited(getArgs);\n        if (member(getArgs)) {\n            markAsFlooded(getArgs);\n            pushAdjacent(getArgs);\n        }\n        else {\n            markAsBoundary(prevArgs);\n        }\n    }\n    function visited(key) {\n        const [x, y, z = 0] = key;\n        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n        return visits.has(iKey);\n    }\n    function markAsVisited(key) {\n        const [x, y, z = 0] = key;\n        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n        visits.add(iKey);\n    }\n    function member(getArgs) {\n        const node = get(getArgs);\n        return equals ? equals(node, startNode) : node === startNode;\n    }\n    function markAsFlooded(getArgs) {\n        flooded.push(getArgs);\n        if (onFlood) {\n            onFlood(...getArgs);\n        }\n    }\n    function markAsBoundary(prevArgs) {\n        const [x, y, z = 0] = prevArgs;\n        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n        bounds?.set(iKey, prevArgs);\n        if (onBoundary) {\n            onBoundary(...prevArgs);\n        }\n    }\n    function pushAdjacent(getArgs) {\n        for (let i = 0; i < permutations.length; i += 1) {\n            const perm = permutations[i];\n            const nextArgs = getArgs.slice(0);\n            for (let j = 0; j < getArgs.length; j += 1) {\n                nextArgs[j] += perm[j];\n            }\n            if (filter?.(nextArgs) === false) {\n                continue;\n            }\n            if (visited(nextArgs)) {\n                continue;\n            }\n            stack.push({\n                currentArgs: nextArgs,\n                previousArgs: getArgs,\n            });\n        }\n    }\n    function get(getArgs) {\n        return getter(...getArgs);\n    }\n    function prunedPermutations() {\n        const permutations = permute(seed.length);\n        return permutations.filter(function (perm) {\n            const count = countNonZeroes(perm);\n            return count !== 0 && (count === 1 || diagonals);\n        });\n    }\n    function permute(length) {\n        const perms = [];\n        const permutation = function (string) {\n            return string.split('').map(function (c) {\n                return parseInt(c, 10) - 1;\n            });\n        };\n        for (let i = 0; i < Math.pow(3, length); i += 1) {\n            const string = lpad(i.toString(3), '0', length);\n            perms.push(permutation(string));\n        }\n        return perms;\n    }\n}\nfunction countNonZeroes(array) {\n    let count = 0;\n    for (let i = 0; i < array.length; i += 1) {\n        if (array[i] !== 0) {\n            count += 1;\n        }\n    }\n    return count;\n}\nfunction lpad(string, character, length) {\n    const array = new Array(length + 1);\n    const pad = array.join(character);\n    return (pad + string).slice(-length);\n}\nexport default floodFill;\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nexport function getBrushToolInstances(toolGroupId, toolName) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return [];\n    }\n    const toolInstances = toolGroup._toolInstances;\n    if (!Object.keys(toolInstances).length) {\n        return [];\n    }\n    if (toolName && toolInstances[toolName]) {\n        return [toolInstances[toolName]];\n    }\n    const brushBasedToolInstances = Object.values(toolInstances).filter((toolInstance) => toolInstance instanceof BrushTool);\n    return brushBasedToolInstances;\n}\n","import { getAnnotation } from '../../stateManagement';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nexport function getHoveredContourSegmentationAnnotation(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    const { annotationUIDsMap } = segmentation.representationData.Contour;\n    for (const [segmentIndex, annotationUIDs] of annotationUIDsMap.entries()) {\n        const highlightedAnnotationUID = Array.from(annotationUIDs).find((annotationUID) => getAnnotation(annotationUID).highlighted);\n        if (highlightedAnnotationUID) {\n            return segmentIndex;\n        }\n    }\n    return undefined;\n}\n","import { cache, volumeLoader, utilities as csUtils, } from '@cornerstonejs/core';\nfunction getOrCreateImageVolume(referencedImageIds) {\n    if (!referencedImageIds || referencedImageIds.length <= 1) {\n        return;\n    }\n    const isValidVolume = csUtils.isValidVolume(referencedImageIds);\n    if (!isValidVolume) {\n        return;\n    }\n    const volumeId = cache.generateVolumeId(referencedImageIds);\n    let imageVolume = cache.getVolume(volumeId);\n    if (imageVolume) {\n        return imageVolume;\n    }\n    imageVolume = volumeLoader.createAndCacheVolumeFromImagesSync(volumeId, referencedImageIds);\n    return imageVolume;\n}\nexport default getOrCreateImageVolume;\n","import { cache, volumeLoader, utilities, } from '@cornerstonejs/core';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nfunction getOrCreateSegmentationVolume(segmentationId) {\n    const { representationData } = getSegmentation(segmentationId);\n    let { volumeId } = representationData.Labelmap;\n    let segVolume;\n    if (volumeId) {\n        segVolume = cache.getVolume(volumeId);\n        if (segVolume) {\n            return segVolume;\n        }\n    }\n    const { imageIds: labelmapImageIds } = representationData.Labelmap;\n    volumeId = cache.generateVolumeId(labelmapImageIds);\n    if (!labelmapImageIds || labelmapImageIds.length === 1) {\n        return;\n    }\n    const isValidVolume = utilities.isValidVolume(labelmapImageIds);\n    if (!isValidVolume) {\n        return;\n    }\n    segVolume = volumeLoader.createAndCacheVolumeFromImagesSync(volumeId, labelmapImageIds);\n    return segVolume;\n}\nexport default getOrCreateSegmentationVolume;\n","import { cache } from '@cornerstonejs/core';\nexport function getReferenceVolumeForSegmentationVolume(segmentationVolumeId) {\n    const segmentationVolume = cache.getVolume(segmentationVolumeId);\n    if (!segmentationVolume) {\n        return null;\n    }\n    const referencedVolumeId = segmentationVolume.referencedVolumeId;\n    let imageVolume;\n    if (referencedVolumeId) {\n        imageVolume = cache.getVolume(referencedVolumeId);\n    }\n    else {\n        const imageIds = segmentationVolume.imageIds;\n        const image = cache.getImage(imageIds[0]);\n        const referencedImageId = image.referencedImageId;\n        const volumeInfo = cache.getVolumeContainingImageId(referencedImageId);\n        imageVolume = volumeInfo?.volume;\n    }\n    return imageVolume;\n}\n","import { BaseVolumeViewport, cache, utilities } from '@cornerstonejs/core';\nimport { getSegmentation, getCurrentLabelmapImageIdForViewport, } from '../../stateManagement/segmentation/segmentationState';\nimport { getLabelmapActorEntry } from '../../stateManagement/segmentation/helpers';\nexport function getSegmentIndexAtLabelmapBorder(segmentationId, worldPoint, { viewport, searchRadius }) {\n    const segmentation = getSegmentation(segmentationId);\n    const labelmapData = segmentation.representationData.Labelmap;\n    if (viewport instanceof BaseVolumeViewport) {\n        const { volumeId } = labelmapData;\n        const segmentationVolume = cache.getVolume(volumeId);\n        if (!segmentationVolume) {\n            return;\n        }\n        const voxelManager = segmentationVolume.voxelManager;\n        const imageData = segmentationVolume.imageData;\n        const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n        const segmentIndex = voxelManager.getAtIJK(indexIJK[0], indexIJK[1], indexIJK[2]);\n        const canvasPoint = viewport.worldToCanvas(worldPoint);\n        const onEdge = isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius);\n        return onEdge ? segmentIndex : undefined;\n    }\n    const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n    const image = cache.getImage(segmentationImageId);\n    if (!image) {\n        return;\n    }\n    const segmentationActorEntry = getLabelmapActorEntry(viewport.id, segmentationId);\n    const imageData = segmentationActorEntry?.actor.getMapper().getInputData();\n    const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n    const dimensions = imageData.getDimensions();\n    const voxelManager = (imageData.voxelManager ||\n        utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData: imageData.getPointData().getScalars().getData(),\n        }));\n    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);\n    const onEdge = isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex);\n    return onEdge ? segmentIndex : undefined;\n}\nfunction isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius = 1) {\n    const neighborRange = Array.from({ length: 2 * searchRadius + 1 }, (_, i) => i - searchRadius);\n    for (const deltaI of neighborRange) {\n        for (const deltaJ of neighborRange) {\n            for (const deltaK of neighborRange) {\n                if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {\n                    continue;\n                }\n                const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);\n                if (neighborIndex !== undefined && segmentIndex !== neighborIndex) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nfunction isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex, searchRadius) {\n    const getNeighborIndex = (deltaI, deltaJ, deltaK) => {\n        const neighborIJK = [\n            indexIJK[0] + deltaI,\n            indexIJK[1] + deltaJ,\n            indexIJK[2] + deltaK,\n        ];\n        return voxelManager.getAtIJK(neighborIJK[0], neighborIJK[1], neighborIJK[2]);\n    };\n    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\nfunction isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius) {\n    const getNeighborIndex = (deltaI, deltaJ) => {\n        const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];\n        const worldPoint = viewport.canvasToWorld(neighborCanvas);\n        const voxelManager = imageData.get('voxelManager').voxelManager;\n        const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n        return voxelManager.getAtIJK(indexIJK[0], indexIJK[1], indexIJK[2]);\n    };\n    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\n","import { BaseVolumeViewport, cache, utilities } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport { getSegmentation, getCurrentLabelmapImageIdsForViewport, } from '../../stateManagement/segmentation/segmentationState';\nimport { getAnnotation } from '../../stateManagement';\nimport { isPointInsidePolyline3D } from '../math/polyline';\nimport { getLabelmapActorEntry } from '../../stateManagement/segmentation/helpers/getSegmentationActor';\nexport function getSegmentIndexAtWorldPoint(segmentationId, worldPoint, options = {}) {\n    const segmentation = getSegmentation(segmentationId);\n    const representationData = segmentation.representationData;\n    const desiredRepresentation = options?.representationType ?? Object.keys(representationData)[0];\n    if (!desiredRepresentation) {\n        throw new Error(`Segmentation ${segmentationId} does not have any representations`);\n    }\n    switch (desiredRepresentation) {\n        case SegmentationRepresentations.Labelmap:\n            return getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, options);\n        case SegmentationRepresentations.Contour:\n            return getSegmentIndexAtWorldForContour(segmentation, worldPoint, options);\n        default:\n            return;\n    }\n}\nexport function getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, { viewport }) {\n    const labelmapData = segmentation.representationData.Labelmap;\n    if (viewport instanceof BaseVolumeViewport) {\n        const { volumeId } = labelmapData;\n        const segmentationVolume = cache.getVolume(volumeId);\n        if (!segmentationVolume) {\n            return;\n        }\n        const segmentIndex = segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);\n        return segmentIndex;\n    }\n    const segmentationImageIds = getCurrentLabelmapImageIdsForViewport(viewport.id, segmentation.segmentationId);\n    if (segmentationImageIds.length > 1) {\n        console.warn('Segment selection for labelmaps with multiple imageIds in stack viewports is not supported yet.');\n        return;\n    }\n    const segmentationImageId = segmentationImageIds[0];\n    const image = cache.getImage(segmentationImageId);\n    if (!image) {\n        return;\n    }\n    const segmentationActorEntry = getLabelmapActorEntry(viewport.id, segmentation.segmentationId);\n    const imageData = segmentationActorEntry?.actor.getMapper().getInputData();\n    const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n    const dimensions = imageData.getDimensions();\n    const voxelManager = (imageData.voxelManager ||\n        utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData: imageData.getPointData().getScalars().getData(),\n        }));\n    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);\n    return segmentIndex;\n}\nexport function getSegmentIndexAtWorldForContour(segmentation, worldPoint, { viewport }) {\n    const contourData = segmentation.representationData.Contour;\n    const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());\n    const { viewPlaneNormal } = viewport.getCamera();\n    for (const segmentIndex of segmentIndices) {\n        const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);\n        if (!annotationsSet) {\n            continue;\n        }\n        for (const annotationUID of annotationsSet) {\n            const annotation = getAnnotation(annotationUID);\n            if (!annotation) {\n                continue;\n            }\n            const { polyline } = annotation.data.contour;\n            if (!utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)) {\n                continue;\n            }\n            if (isPointInsidePolyline3D(worldPoint, polyline)) {\n                return Number(segmentIndex);\n            }\n        }\n    }\n}\n","import { getWebWorkerManager } from '@cornerstonejs/core';\nimport { WorkerTypes } from '../../enums';\nimport { registerComputeWorker } from '../registerComputeWorker';\nimport { triggerWorkerProgress, getSegmentationDataForWorker, prepareVolumeStrategyDataForWorker, prepareStackDataForWorker, } from './utilsForWorker';\nexport async function getSegmentLargestBidirectional({ segmentationId, segmentIndices, mode = 'individual', }) {\n    registerComputeWorker();\n    triggerWorkerProgress(WorkerTypes.COMPUTE_LARGEST_BIDIRECTIONAL, 0);\n    const segData = getSegmentationDataForWorker(segmentationId, segmentIndices);\n    if (!segData) {\n        return;\n    }\n    const { operationData, segImageIds, reconstructableVolume, indices } = segData;\n    const bidirectionalData = reconstructableVolume\n        ? await calculateVolumeBidirectional({\n            operationData,\n            indices,\n            mode,\n        })\n        : await calculateStackBidirectional({\n            segImageIds,\n            indices,\n            mode,\n        });\n    triggerWorkerProgress(WorkerTypes.COMPUTE_LARGEST_BIDIRECTIONAL, 100);\n    return bidirectionalData;\n}\nasync function calculateVolumeBidirectional({ operationData, indices, mode }) {\n    const strategyData = prepareVolumeStrategyDataForWorker(operationData);\n    const { segmentationVoxelManager, segmentationImageData } = strategyData;\n    const segmentationScalarData = segmentationVoxelManager.getCompleteScalarDataArray();\n    const segmentationInfo = {\n        scalarData: segmentationScalarData,\n        dimensions: segmentationImageData.getDimensions(),\n        spacing: segmentationImageData.getSpacing(),\n        origin: segmentationImageData.getOrigin(),\n        direction: segmentationImageData.getDirection(),\n    };\n    const bidirectionalData = await getWebWorkerManager().executeTask('compute', 'getSegmentLargestBidirectionalInternal', {\n        segmentationInfo,\n        indices,\n        mode,\n    });\n    return bidirectionalData;\n}\nasync function calculateStackBidirectional({ segImageIds, indices, mode }) {\n    const { segmentationInfo } = prepareStackDataForWorker(segImageIds);\n    const bidirectionalData = await getWebWorkerManager().executeTask('compute', 'getSegmentLargestBidirectionalInternal', {\n        segmentationInfo,\n        indices,\n        mode,\n        isStack: true,\n    });\n    return bidirectionalData;\n}\n","import { utilities, getWebWorkerManager } from '@cornerstonejs/core';\nimport { triggerWorkerProgress, getSegmentationDataForWorker, prepareVolumeStrategyDataForWorker, prepareStackDataForWorker, getImageReferenceInfo, } from './utilsForWorker';\nimport { getPixelValueUnitsImageId } from '../getPixelValueUnits';\nimport VolumetricCalculator from './VolumetricCalculator';\nimport { WorkerTypes } from '../../enums';\nimport { registerComputeWorker } from '../registerComputeWorker';\nconst radiusForVol1 = Math.pow((3 * 1000) / (4 * Math.PI), 1 / 3);\nasync function getStatistics({ segmentationId, segmentIndices, mode = 'collective', }) {\n    registerComputeWorker();\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 0);\n    const segData = getSegmentationDataForWorker(segmentationId, segmentIndices);\n    if (!segData) {\n        return;\n    }\n    const { operationData, segVolumeId, segImageIds, reconstructableVolume, indices, } = segData;\n    const { refImageId, modalityUnitOptions } = getImageReferenceInfo(segVolumeId, segImageIds);\n    const unit = getPixelValueUnitsImageId(refImageId, modalityUnitOptions);\n    const stats = reconstructableVolume\n        ? await calculateVolumeStatistics({\n            operationData,\n            indices,\n            unit,\n            mode,\n        })\n        : await calculateStackStatistics({\n            segImageIds,\n            indices,\n            unit,\n            mode,\n        });\n    return stats;\n}\nasync function calculateVolumeStatistics({ operationData, indices, unit, mode, }) {\n    const strategyData = prepareVolumeStrategyDataForWorker(operationData);\n    const { segmentationVoxelManager, imageVoxelManager, segmentationImageData, imageData, } = strategyData;\n    if (!segmentationVoxelManager || !segmentationImageData) {\n        return;\n    }\n    const spacing = segmentationImageData.getSpacing();\n    const { boundsIJK: boundsOrig } = segmentationVoxelManager;\n    if (!boundsOrig) {\n        return VolumetricCalculator.getStatistics({ spacing });\n    }\n    const segmentationScalarData = segmentationVoxelManager.getCompleteScalarDataArray();\n    const segmentationInfo = {\n        scalarData: segmentationScalarData,\n        dimensions: segmentationImageData.getDimensions(),\n        spacing: segmentationImageData.getSpacing(),\n        origin: segmentationImageData.getOrigin(),\n        direction: segmentationImageData.getDirection(),\n    };\n    const imageInfo = {\n        scalarData: imageVoxelManager.getCompleteScalarDataArray(),\n        dimensions: imageData.getDimensions(),\n        spacing: imageData.getSpacing(),\n        origin: imageData.getOrigin(),\n        direction: imageData.getDirection(),\n    };\n    if (!imageInfo.scalarData?.length) {\n        return;\n    }\n    const stats = await getWebWorkerManager().executeTask('compute', 'calculateSegmentsStatisticsVolume', {\n        segmentationInfo,\n        imageInfo,\n        indices,\n        unit,\n        mode,\n    });\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 100);\n    if (mode === 'collective') {\n        return processSegmentationStatistics({\n            stats,\n            unit,\n            spacing,\n            segmentationImageData,\n            imageVoxelManager,\n        });\n    }\n    else {\n        const finalStats = {};\n        Object.entries(stats).forEach(([segmentIndex, stat]) => {\n            finalStats[segmentIndex] = processSegmentationStatistics({\n                stats: stat,\n                unit,\n                spacing,\n                segmentationImageData,\n                imageVoxelManager,\n            });\n        });\n        return finalStats;\n    }\n}\nconst updateStatsArray = (stats, newStat) => {\n    if (!stats.array) {\n        return;\n    }\n    const existingIndex = stats.array.findIndex((stat) => stat.name === newStat.name);\n    if (existingIndex !== -1) {\n        stats.array[existingIndex] = newStat;\n    }\n    else {\n        stats.array.push(newStat);\n    }\n};\nconst processSegmentationStatistics = ({ stats, unit, spacing, segmentationImageData, imageVoxelManager, }) => {\n    stats.mean.unit = unit;\n    stats.max.unit = unit;\n    stats.min.unit = unit;\n    if (unit !== 'SUV') {\n        return stats;\n    }\n    const radiusIJK = spacing.map((s) => Math.max(1, Math.round((1.1 * radiusForVol1) / s)));\n    for (const testMax of stats.maxIJKs) {\n        const testStats = getSphereStats(testMax, radiusIJK, segmentationImageData, imageVoxelManager, spacing);\n        if (!testStats) {\n            continue;\n        }\n        const { mean } = testStats;\n        if (!stats.peakValue || stats.peakValue.value <= mean.value) {\n            stats.peakValue = {\n                name: 'peakValue',\n                label: 'Peak Value',\n                value: mean.value,\n                unit,\n            };\n            stats.peakPoint = {\n                name: 'peakLPS',\n                label: 'Peak SUV Point',\n                value: testMax.pointLPS ? [...testMax.pointLPS] : null,\n                unit: null,\n            };\n            updateStatsArray(stats, stats.peakValue);\n            updateStatsArray(stats, stats.peakPoint);\n        }\n    }\n    if (stats.volume && stats.mean) {\n        const mtv = stats.volume.value;\n        const suvMean = stats.mean.value;\n        stats.lesionGlycolysis = {\n            name: 'lesionGlycolysis',\n            label: 'Lesion Glycolysis',\n            value: mtv * suvMean,\n            unit: `${stats.volume.unit}${unit}`,\n        };\n        updateStatsArray(stats, stats.lesionGlycolysis);\n    }\n    return stats;\n};\nasync function calculateStackStatistics({ segImageIds, indices, unit, mode }) {\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 0);\n    const { segmentationInfo, imageInfo } = prepareStackDataForWorker(segImageIds);\n    const stats = await getWebWorkerManager().executeTask('compute', 'calculateSegmentsStatisticsStack', {\n        segmentationInfo,\n        imageInfo,\n        indices,\n        mode,\n    });\n    triggerWorkerProgress(WorkerTypes.COMPUTE_STATISTICS, 100);\n    const spacing = segmentationInfo[0].spacing;\n    const segmentationImageData = segmentationInfo[0];\n    const imageVoxelManager = imageInfo[0].voxelManager;\n    if (mode === 'collective') {\n        return processSegmentationStatistics({\n            stats,\n            unit,\n            spacing,\n            segmentationImageData,\n            imageVoxelManager,\n        });\n    }\n    else {\n        const finalStats = {};\n        Object.entries(stats).forEach(([segmentIndex, stat]) => {\n            finalStats[segmentIndex] = processSegmentationStatistics({\n                stats: stat,\n                unit,\n                spacing,\n                segmentationImageData,\n                imageVoxelManager,\n            });\n        });\n        return finalStats;\n    }\n}\nfunction getSphereStats(testMax, radiusIJK, segData, imageVoxels, spacing) {\n    const { pointIJK: centerIJK, pointLPS: centerLPS } = testMax;\n    if (!centerIJK) {\n        return;\n    }\n    const boundsIJK = centerIJK.map((ijk, idx) => [\n        ijk - radiusIJK[idx],\n        ijk + radiusIJK[idx],\n    ]);\n    const testFunction = (_pointLPS, pointIJK) => {\n        const i = (pointIJK[0] - centerIJK[0]) / radiusIJK[0];\n        const j = (pointIJK[1] - centerIJK[1]) / radiusIJK[1];\n        const k = (pointIJK[2] - centerIJK[2]) / radiusIJK[2];\n        const radius = i * i + j * j + k * k;\n        return radius <= 1;\n    };\n    const statsFunction = ({ pointIJK, pointLPS }) => {\n        const value = imageVoxels.getAtIJKPoint(pointIJK);\n        if (value === undefined) {\n            return;\n        }\n        VolumetricCalculator.statsCallback({ value, pointLPS, pointIJK });\n    };\n    VolumetricCalculator.statsInit({ storePointData: false });\n    utilities.pointInShapeCallback(segData, {\n        pointInShapeFn: testFunction,\n        callback: statsFunction,\n        boundsIJK,\n    });\n    return VolumetricCalculator.getStatistics({ spacing });\n}\nexport default getStatistics;\n","import { cache } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport { getCachedSegmentIndices, setCachedSegmentIndices } from './utilities';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nfunction getUniqueSegmentIndices(segmentationId) {\n    const cachedResult = getCachedSegmentIndices(segmentationId);\n    if (cachedResult) {\n        return cachedResult;\n    }\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation found for segmentationId ${segmentationId}`);\n    }\n    let indices;\n    if (segmentation.representationData.Labelmap) {\n        indices = handleLabelmapSegmentation(segmentation, segmentationId);\n    }\n    else if (segmentation.representationData.Contour) {\n        indices = handleContourSegmentation(segmentation);\n    }\n    else if (segmentation.representationData.Surface) {\n        indices = handleSurfaceSegmentation(segmentation);\n    }\n    else {\n        throw new Error(`Unsupported segmentation type: ${segmentation.representationData}`);\n    }\n    setCachedSegmentIndices(segmentationId, indices);\n    return indices;\n}\nfunction handleLabelmapSegmentation(segmentation, segmentationId) {\n    const labelmapData = segmentation.representationData[SegmentationRepresentations.Labelmap];\n    const keySet = new Set();\n    if (labelmapData.imageIds) {\n        addImageSegmentIndices(keySet, labelmapData.imageIds);\n    }\n    else {\n        addVolumeSegmentIndices(keySet, segmentationId);\n    }\n    return Array.from(keySet)\n        .map(Number)\n        .sort((a, b) => a - b);\n}\nfunction addVolumeSegmentIndices(keySet, segmentationId) {\n    const volume = cache.getVolume(segmentationId);\n    volume.voxelManager.forEach(({ value }) => {\n        if (value !== 0) {\n            keySet.add(value);\n        }\n    });\n}\nfunction addImageSegmentIndices(keySet, imageIds) {\n    imageIds.forEach((segmentationImageId) => {\n        const image = cache.getImage(segmentationImageId);\n        const scalarData = image.voxelManager.getScalarData();\n        scalarData.forEach((segmentIndex) => {\n            if (segmentIndex !== 0) {\n                keySet.add(segmentIndex);\n            }\n        });\n    });\n}\nfunction handleContourSegmentation(segmentation) {\n    const { annotationUIDsMap, geometryIds } = segmentation.representationData.Contour || {};\n    if (!geometryIds) {\n        throw new Error(`No geometryIds found for segmentationId ${segmentation.segmentationId}`);\n    }\n    const indices = new Set([...annotationUIDsMap.keys()]);\n    geometryIds.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        indices.add(geometry.data.segmentIndex);\n    });\n    return Array.from(indices).sort((a, b) => a - b);\n}\nfunction handleSurfaceSegmentation(segmentation) {\n    const geometryIds = segmentation.representationData.Surface?.geometryIds ?? [];\n    return Array.from(geometryIds.keys())\n        .map(Number)\n        .sort((a, b) => a - b);\n}\nexport { getUniqueSegmentIndices };\n","const shader = `\nconst MAX_STRENGTH = 65535f;\n\n// Workgroup size - X*Y*Z must be multiple of 32 for better performance\noverride workGroupSizeX = 1u;\noverride workGroupSizeY = 1u;\noverride workGroupSizeZ = 1u;\n\n// Compare the current voxel to neighbors using a 9x9x9 window\noverride windowSize = 9i;\n\nstruct Params {\n  size: vec3u,\n  iteration: u32,\n}\n\n// New structure to track bounds of modified voxels\nstruct Bounds {\n  minX: atomic<i32>,\n  minY: atomic<i32>,\n  minZ: atomic<i32>,\n  maxX: atomic<i32>,\n  maxY: atomic<i32>,\n  maxZ: atomic<i32>,\n}\n\n@group(0) @binding(0) var<uniform> params: Params;\n@group(0) @binding(1) var<storage> volumePixelData: array<f32>;\n@group(0) @binding(2) var<storage, read_write> labelmap: array<u32>;\n@group(0) @binding(3) var<storage, read_write> strengthData: array<f32>;\n@group(0) @binding(4) var<storage> prevLabelmap: array<u32>;\n@group(0) @binding(5) var<storage> prevStrengthData: array<f32>;\n@group(0) @binding(6) var<storage, read_write> updatedVoxelsCounter: array<atomic<u32>>;\n@group(0) @binding(7) var<storage, read_write> modifiedBounds: Bounds;\n\nfn getPixelIndex(ijkPos: vec3u) -> u32 {\n  let numPixelsPerSlice = params.size.x * params.size.y;\n  return ijkPos.x + ijkPos.y * params.size.x + ijkPos.z * numPixelsPerSlice;\n}\n\nfn updateBounds(position: vec3i) {\n  // Atomically update min bounds (use min operation)\n  let oldMinX = atomicMin(&modifiedBounds.minX, position.x);\n  let oldMinY = atomicMin(&modifiedBounds.minY, position.y);\n  let oldMinZ = atomicMin(&modifiedBounds.minZ, position.z);\n\n  // Atomically update max bounds (use max operation)\n  let oldMaxX = atomicMax(&modifiedBounds.maxX, position.x);\n  let oldMaxY = atomicMax(&modifiedBounds.maxY, position.y);\n  let oldMaxZ = atomicMax(&modifiedBounds.maxZ, position.z);\n}\n\n@compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\nfn main(\n  @builtin(global_invocation_id) globalId: vec3u,\n) {\n  // Make sure it will not get out of bounds for volume with sizes that\n  // are not multiple of workGroupSize\n  if (\n    globalId.x >= params.size.x ||\n    globalId.y >= params.size.y ||\n    globalId.z >= params.size.z\n  ) {\n    return;\n  }\n\n  // Initialize bounds for the first iteration\n  if (params.iteration == 0 && globalId.x == 0 && globalId.y == 0 && globalId.z == 0) {\n    // Initialize to opposite extremes to ensure any update will improve the bounds\n    atomicStore(&modifiedBounds.minX, i32(params.size.x));\n    atomicStore(&modifiedBounds.minY, i32(params.size.y));\n    atomicStore(&modifiedBounds.minZ, i32(params.size.z));\n    atomicStore(&modifiedBounds.maxX, -1);\n    atomicStore(&modifiedBounds.maxY, -1);\n    atomicStore(&modifiedBounds.maxZ, -1);\n  }\n\n  let currentCoord = vec3i(globalId);\n  let currentPixelIndex = getPixelIndex(globalId);\n\n  let numPixels = arrayLength(&volumePixelData);\n  let currentPixelValue = volumePixelData[currentPixelIndex];\n\n  if (params.iteration == 0) {\n    // All non-zero initial labels are given maximum strength\n    strengthData[currentPixelIndex] = select(MAX_STRENGTH, 0., labelmap[currentPixelIndex] == 0);\n\n    // Update bounds for non-zero initial labels\n    if (labelmap[currentPixelIndex] != 0) {\n      updateBounds(currentCoord);\n    }\n    return;\n  }\n\n  // It should at least copy the values from previous state\n  var newLabel = prevLabelmap[currentPixelIndex];\n  var newStrength = prevStrengthData[currentPixelIndex];\n\n  let window = i32(ceil(f32(windowSize - 1) * .5));\n  let minWindow = -1i * window;\n  let maxWindow = 1i * window;\n\n  for (var k = minWindow; k <= maxWindow; k++) {\n    for (var j = minWindow; j <= maxWindow; j++) {\n      for (var i = minWindow; i <= maxWindow; i++) {\n        // Skip current voxel\n        if (i == 0 && j == 0 && k == 0) {\n          continue;\n        }\n\n        let neighborCoord = currentCoord + vec3i(i, j, k);\n\n        //  Boundary conditions. Do not grow outside of the volume\n        if (\n          neighborCoord.x < 0i || neighborCoord.x >= i32(params.size.x) ||\n          neighborCoord.y < 0i || neighborCoord.y >= i32(params.size.y) ||\n          neighborCoord.z < 0i || neighborCoord.z >= i32(params.size.z)\n        ) {\n          continue;\n        }\n\n        let neighborIndex = getPixelIndex(vec3u(neighborCoord));\n        let neighborPixelValue = volumePixelData[neighborIndex];\n        let prevNeighborStrength = prevStrengthData[neighborIndex];\n        let strengthCost = abs(neighborPixelValue - currentPixelValue);\n        let takeoverStrength = prevNeighborStrength - strengthCost;\n\n        if (takeoverStrength > newStrength) {\n          newLabel = prevLabelmap[neighborIndex];\n          newStrength = takeoverStrength;\n        }\n      }\n    }\n  }\n\n  if (labelmap[currentPixelIndex] != newLabel) {\n    atomicAdd(&updatedVoxelsCounter[params.iteration], 1u);\n\n    // Update bounds for modified voxels\n    updateBounds(currentCoord);\n  }\n\n  labelmap[currentPixelIndex] = newLabel;\n  strengthData[currentPixelIndex] = newStrength;\n}\n`;\nexport default shader;\n","import { cache } from '@cornerstonejs/core';\nimport shaderCode from './growCutShader';\nconst GB = 1024 * 1024 * 1024;\nconst WEBGPU_MEMORY_LIMIT = 1.99 * GB;\nconst DEFAULT_GROWCUT_OPTIONS = {\n    windowSize: 3,\n    maxProcessingTime: 30000,\n    inspection: {\n        numCyclesInterval: 5,\n        numCyclesBelowThreshold: 3,\n        threshold: 1e-4,\n    },\n};\nasync function runGrowCut(referenceVolumeId, labelmapVolumeId, options = DEFAULT_GROWCUT_OPTIONS) {\n    const workGroupSize = [8, 8, 4];\n    const { windowSize, maxProcessingTime } = Object.assign({}, DEFAULT_GROWCUT_OPTIONS, options);\n    const inspection = Object.assign({}, DEFAULT_GROWCUT_OPTIONS.inspection, options.inspection);\n    const volume = cache.getVolume(referenceVolumeId);\n    const labelmap = cache.getVolume(labelmapVolumeId);\n    const [columns, rows, numSlices] = volume.dimensions;\n    if (labelmap.dimensions[0] !== columns ||\n        labelmap.dimensions[1] !== rows ||\n        labelmap.dimensions[2] !== numSlices) {\n        throw new Error('Volume and labelmap must have the same size');\n    }\n    let numIterations = Math.floor(Math.sqrt(rows ** 2 + columns ** 2 + numSlices ** 2) / 2);\n    numIterations = Math.min(numIterations, 500);\n    const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();\n    let volumePixelData = volume.voxelManager.getCompleteScalarDataArray();\n    if (!(volumePixelData instanceof Float32Array)) {\n        volumePixelData = new Float32Array(volumePixelData);\n    }\n    const requiredLimits = {\n        maxStorageBufferBindingSize: WEBGPU_MEMORY_LIMIT,\n        maxBufferSize: WEBGPU_MEMORY_LIMIT,\n    };\n    const adapter = await navigator.gpu?.requestAdapter();\n    const device = await adapter.requestDevice({ requiredLimits });\n    const BUFFER_SIZE = volumePixelData.byteLength;\n    const UPDATED_VOXELS_COUNTER_BUFFER_SIZE = numIterations * Uint32Array.BYTES_PER_ELEMENT;\n    const BOUNDS_BUFFER_SIZE = 6 * Int32Array.BYTES_PER_ELEMENT;\n    const shaderModule = device.createShaderModule({\n        code: shaderCode,\n    });\n    const numIterationIndex = 3;\n    const paramsArrayValues = new Uint32Array([\n        columns,\n        rows,\n        numSlices,\n        0,\n    ]);\n    const gpuParamsBuffer = device.createBuffer({\n        size: paramsArrayValues.byteLength,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    const gpuVolumePixelDataBuffer = device.createBuffer({\n        size: BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(gpuVolumePixelDataBuffer, 0, volumePixelData);\n    const gpuLabelmapBuffers = [0, 1].map(() => device.createBuffer({\n        size: BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE |\n            GPUBufferUsage.COPY_SRC |\n            GPUBufferUsage.COPY_DST,\n    }));\n    device.queue.writeBuffer(gpuLabelmapBuffers[0], 0, new Uint32Array(labelmapData));\n    const gpuStrengthBuffers = [0, 1].map(() => {\n        const strengthBuffer = device.createBuffer({\n            size: BUFFER_SIZE,\n            usage: GPUBufferUsage.STORAGE |\n                GPUBufferUsage.COPY_SRC |\n                GPUBufferUsage.COPY_DST,\n        });\n        return strengthBuffer;\n    });\n    const gpuCounterBuffer = device.createBuffer({\n        size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE |\n            GPUBufferUsage.COPY_SRC |\n            GPUBufferUsage.COPY_DST,\n    });\n    const gpuBoundsBuffer = device.createBuffer({\n        size: BOUNDS_BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE |\n            GPUBufferUsage.COPY_SRC |\n            GPUBufferUsage.COPY_DST,\n    });\n    const initialBounds = new Int32Array([\n        columns,\n        rows,\n        numSlices,\n        -1,\n        -1,\n        -1,\n    ]);\n    device.queue.writeBuffer(gpuBoundsBuffer, 0, initialBounds);\n    const bindGroupLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'uniform',\n                },\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'read-only-storage',\n                },\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n            {\n                binding: 3,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n            {\n                binding: 4,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'read-only-storage',\n                },\n            },\n            {\n                binding: 5,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'read-only-storage',\n                },\n            },\n            {\n                binding: 6,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n            {\n                binding: 7,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n        ],\n    });\n    const bindGroups = [0, 1].map((i) => {\n        const outputLabelmapBuffer = gpuLabelmapBuffers[i];\n        const outputStrengthBuffer = gpuStrengthBuffers[i];\n        const previouLabelmapBuffer = gpuLabelmapBuffers[(i + 1) % 2];\n        const previousStrengthBuffer = gpuStrengthBuffers[(i + 1) % 2];\n        return device.createBindGroup({\n            layout: bindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: gpuParamsBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: gpuVolumePixelDataBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: outputLabelmapBuffer,\n                    },\n                },\n                {\n                    binding: 3,\n                    resource: {\n                        buffer: outputStrengthBuffer,\n                    },\n                },\n                {\n                    binding: 4,\n                    resource: {\n                        buffer: previouLabelmapBuffer,\n                    },\n                },\n                {\n                    binding: 5,\n                    resource: {\n                        buffer: previousStrengthBuffer,\n                    },\n                },\n                {\n                    binding: 6,\n                    resource: {\n                        buffer: gpuCounterBuffer,\n                    },\n                },\n                {\n                    binding: 7,\n                    resource: {\n                        buffer: gpuBoundsBuffer,\n                    },\n                },\n            ],\n        });\n    });\n    const pipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [bindGroupLayout],\n        }),\n        compute: {\n            module: shaderModule,\n            entryPoint: 'main',\n            constants: {\n                workGroupSizeX: workGroupSize[0],\n                workGroupSizeY: workGroupSize[1],\n                workGroupSizeZ: workGroupSize[2],\n                windowSize,\n            },\n        },\n    });\n    const numWorkGroups = [\n        Math.ceil(columns / workGroupSize[0]),\n        Math.ceil(rows / workGroupSize[1]),\n        Math.ceil(numSlices / workGroupSize[2]),\n    ];\n    const gpuUpdatedVoxelsCounterStagingBuffer = device.createBuffer({\n        size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    const limitProcessingTime = maxProcessingTime\n        ? performance.now() + maxProcessingTime\n        : 0;\n    let currentInspectionNumCyclesInterval = inspection.numCyclesInterval;\n    let belowThresholdCounter = 0;\n    for (let i = 0; i < numIterations; i++) {\n        paramsArrayValues[numIterationIndex] = i;\n        device.queue.writeBuffer(gpuParamsBuffer, 0, paramsArrayValues);\n        const commandEncoder = device.createCommandEncoder();\n        const passEncoder = commandEncoder.beginComputePass();\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroups[i % 2]);\n        passEncoder.dispatchWorkgroups(numWorkGroups[0], numWorkGroups[1], numWorkGroups[2]);\n        passEncoder.end();\n        commandEncoder.copyBufferToBuffer(gpuCounterBuffer, i * Uint32Array.BYTES_PER_ELEMENT, gpuUpdatedVoxelsCounterStagingBuffer, i * Uint32Array.BYTES_PER_ELEMENT, Uint32Array.BYTES_PER_ELEMENT);\n        device.queue.submit([commandEncoder.finish()]);\n        const inspect = i > 0 && !(i % currentInspectionNumCyclesInterval);\n        if (inspect) {\n            await gpuUpdatedVoxelsCounterStagingBuffer.mapAsync(GPUMapMode.READ, 0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);\n            const updatedVoxelsCounterResultBuffer = gpuUpdatedVoxelsCounterStagingBuffer.getMappedRange(0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);\n            const updatedVoxelsCounterBufferData = new Uint32Array(updatedVoxelsCounterResultBuffer.slice(0));\n            const updatedVoxelsRatio = updatedVoxelsCounterBufferData[i] / volumePixelData.length;\n            gpuUpdatedVoxelsCounterStagingBuffer.unmap();\n            if (i >= 1 && updatedVoxelsRatio < inspection.threshold) {\n                currentInspectionNumCyclesInterval = 1;\n                belowThresholdCounter++;\n                if (belowThresholdCounter === inspection.numCyclesBelowThreshold) {\n                    break;\n                }\n            }\n            else {\n                currentInspectionNumCyclesInterval = inspection.numCyclesInterval;\n            }\n        }\n        if (limitProcessingTime && performance.now() > limitProcessingTime) {\n            console.warn(`Exceeded processing time limit (${maxProcessingTime})ms`);\n            break;\n        }\n    }\n    const commandEncoder = device.createCommandEncoder();\n    const outputLabelmapBufferIndex = (numIterations + 1) % 2;\n    const labelmapStagingBuffer = device.createBuffer({\n        size: BUFFER_SIZE,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    const boundsStagingBuffer = device.createBuffer({\n        size: BOUNDS_BUFFER_SIZE,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    commandEncoder.copyBufferToBuffer(gpuLabelmapBuffers[outputLabelmapBufferIndex], 0, labelmapStagingBuffer, 0, BUFFER_SIZE);\n    commandEncoder.copyBufferToBuffer(gpuBoundsBuffer, 0, boundsStagingBuffer, 0, BOUNDS_BUFFER_SIZE);\n    device.queue.submit([commandEncoder.finish()]);\n    await labelmapStagingBuffer.mapAsync(GPUMapMode.READ, 0, BUFFER_SIZE);\n    const labelmapResultBuffer = labelmapStagingBuffer.getMappedRange(0, BUFFER_SIZE);\n    const labelmapResult = new Uint32Array(labelmapResultBuffer);\n    labelmapData.set(labelmapResult);\n    labelmapStagingBuffer.unmap();\n    await boundsStagingBuffer.mapAsync(GPUMapMode.READ, 0, BOUNDS_BUFFER_SIZE);\n    const boundsResultBuffer = boundsStagingBuffer.getMappedRange(0, BOUNDS_BUFFER_SIZE);\n    const boundsResult = new Int32Array(boundsResultBuffer.slice(0));\n    boundsStagingBuffer.unmap();\n    const minX = boundsResult[0];\n    const minY = boundsResult[1];\n    const minZ = boundsResult[2];\n    const maxX = boundsResult[3];\n    const maxY = boundsResult[4];\n    const maxZ = boundsResult[5];\n    labelmap.voxelManager.setCompleteScalarDataArray(labelmapData);\n    labelmap.voxelManager.clearBounds();\n    labelmap.voxelManager.setBounds([\n        [minX, maxX],\n        [minY, maxY],\n        [minZ, maxZ],\n    ]);\n}\nexport { runGrowCut as default, runGrowCut as run };\n","import { volumeLoader, utilities as csUtils } from '@cornerstonejs/core';\nimport { run } from './runGrowCut';\nconst POSITIVE_SEED_VALUE = 254;\nconst NEGATIVE_SEED_VALUE = 255;\nconst NEGATIVE_PIXEL_RANGE = [-Infinity, -995];\nconst POSITIVE_PIXEL_RANGE = [0, 1900];\nfunction _setNegativeSeedValues(subVolume, labelmap, options) {\n    const { negativeSeedValue = NEGATIVE_SEED_VALUE, negativePixelRange = NEGATIVE_PIXEL_RANGE, } = options;\n    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const [width, height, numSlices] = labelmap.dimensions;\n    const middleSliceIndex = Math.floor(numSlices / 2);\n    const visited = new Array(width * height).fill(false);\n    const sliceOffset = middleSliceIndex * width * height;\n    const bfs = (startX, startY) => {\n        const queue = [[startX, startY]];\n        while (queue.length) {\n            const [x, y] = queue.shift();\n            const slicePixelIndex = y * width + x;\n            if (x < 0 ||\n                x >= width ||\n                y < 0 ||\n                y >= height ||\n                visited[slicePixelIndex]) {\n                continue;\n            }\n            visited[slicePixelIndex] = true;\n            const volumeVoxelIndex = sliceOffset + slicePixelIndex;\n            const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];\n            if (volumeVoxelValue < negativePixelRange[0] ||\n                volumeVoxelValue > negativePixelRange[1]) {\n                continue;\n            }\n            labelmap.voxelManager.setAtIndex(volumeVoxelIndex, negativeSeedValue);\n            queue.push([x - 1, y]);\n            queue.push([x + 1, y]);\n            queue.push([x, y - 1]);\n            queue.push([x, y + 1]);\n        }\n    };\n    const scanLine = (startX, limitX, incX, y) => {\n        for (let x = startX; x !== limitX; x += incX) {\n            const slicePixelIndex = y * width + x;\n            const volumeVoxelIndex = sliceOffset + slicePixelIndex;\n            const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];\n            if (volumeVoxelValue < negativePixelRange[0] ||\n                volumeVoxelValue > negativePixelRange[1]) {\n                break;\n            }\n            if (!visited[slicePixelIndex]) {\n                bfs(x, y);\n            }\n        }\n    };\n    for (let y = 0; y < height; y++) {\n        scanLine(0, width - 1, 1, y);\n        scanLine(width - 1, 0, -1, y);\n    }\n}\nfunction _setPositiveSeedValues(subVolume, labelmap, options) {\n    const { positiveSeedValue = POSITIVE_SEED_VALUE, positivePixelRange = POSITIVE_PIXEL_RANGE, } = options;\n    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();\n    const [width, height, numSlices] = labelmap.dimensions;\n    const middleSliceIndex = Math.floor(numSlices / 2);\n    const startSliceIndex = Math.max(middleSliceIndex - 3, 0);\n    const stopSliceIndex = Math.max(startSliceIndex + 5, numSlices);\n    const pixelsPerSlice = width * height;\n    for (let z = startSliceIndex; z < stopSliceIndex; z++) {\n        const zOffset = z * pixelsPerSlice;\n        for (let y = 0; y < height; y++) {\n            const yOffset = y * width;\n            for (let x = 0; x < width; x++) {\n                const index = zOffset + yOffset + x;\n                const pixelValue = subVolPixelData[index];\n                const isPositiveValue = pixelValue >= positivePixelRange[0] &&\n                    pixelValue <= positivePixelRange[1];\n                if (isPositiveValue) {\n                    labelmap.voxelManager.setAtIndex(index, positiveSeedValue);\n                }\n            }\n        }\n    }\n}\nasync function _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options) {\n    const labelmap = volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);\n    _setPositiveSeedValues(subVolume, labelmap, options);\n    _setNegativeSeedValues(subVolume, labelmap, options);\n    return labelmap;\n}\nasync function runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options) {\n    const { boundingBox } = boundingBoxInfo;\n    const { ijkTopLeft, ijkBottomRight } = boundingBox;\n    const subVolumeBoundsIJK = {\n        minX: ijkTopLeft[0],\n        maxX: ijkBottomRight[0],\n        minY: ijkTopLeft[1],\n        maxY: ijkBottomRight[1],\n        minZ: ijkTopLeft[2],\n        maxZ: ijkBottomRight[2],\n    };\n    const subVolume = csUtils.createSubVolume(referencedVolumeId, subVolumeBoundsIJK, {\n        targetBuffer: {\n            type: 'Float32Array',\n        },\n    });\n    const labelmap = await _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options);\n    await run(subVolume.volumeId, labelmap.volumeId);\n    return labelmap;\n}\nexport { runGrowCutForBoundingBox as default, runGrowCutForBoundingBox };\n","import { quat, vec3 } from 'gl-matrix';\nimport { utilities as csUtils, cache, volumeLoader } from '@cornerstonejs/core';\nimport { run } from './runGrowCut';\nimport { getSphereBoundsInfo } from '../../getSphereBoundsInfo';\nconst { transformWorldToIndex } = csUtils;\nconst POSITIVE_SEED_VALUE = 254;\nconst NEGATIVE_SEED_VALUE = 255;\nconst POSITIVE_SEED_VARIANCE = 0.1;\nconst NEGATIVE_SEED_VARIANCE = 0.8;\nfunction _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo) {\n    const { topLeftWorld, bottomRightWorld } = sphereBoundsInfo;\n    const topLeftIJK = transformWorldToIndex(referencedVolume.imageData, topLeftWorld);\n    const bottomRightIJK = transformWorldToIndex(referencedVolume.imageData, bottomRightWorld);\n    return {\n        ...sphereBoundsInfo,\n        topLeftIJK,\n        bottomRightIJK,\n    };\n}\nfunction _getSphereBoundsInfo(referencedVolume, sphereInfo) {\n    const direction = referencedVolume.imageData.getDirection();\n    const vecColumn = vec3.fromValues(direction[3], direction[4], direction[5]);\n    const { center: sphereCenterPoint, radius: sphereRadius } = sphereInfo;\n    const refVolImageData = referencedVolume.imageData;\n    const topCirclePoint = vec3.scaleAndAdd(vec3.create(), sphereCenterPoint, vecColumn, -sphereRadius);\n    const bottomCirclePoint = vec3.scaleAndAdd(vec3.create(), sphereCenterPoint, vecColumn, sphereRadius);\n    const sphereBoundsInfo = getSphereBoundsInfo([bottomCirclePoint, topCirclePoint], refVolImageData);\n    return _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo);\n}\nfunction _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport) {\n    const refVolImageData = referencedVolume.imageData;\n    const camera = viewport.getCamera();\n    const { ijkVecRowDir, ijkVecColDir } = csUtils.getVolumeDirectionVectors(refVolImageData, camera);\n    const obliqueView = [ijkVecRowDir, ijkVecColDir].some((vec) => !csUtils.isEqual(Math.abs(vec[0]), 1) &&\n        !csUtils.isEqual(Math.abs(vec[1]), 1) &&\n        !csUtils.isEqual(Math.abs(vec[2]), 1));\n    if (obliqueView) {\n        console.warn('Oblique view is not supported!');\n        return;\n    }\n    const { boundsIJK: sphereBoundsIJK } = _getSphereBoundsInfo(referencedVolume, sphereInfo);\n    const subVolumeBoundsIJK = {\n        minX: sphereBoundsIJK[0][0],\n        maxX: sphereBoundsIJK[0][1] + 1,\n        minY: sphereBoundsIJK[1][0],\n        maxY: sphereBoundsIJK[1][1] + 1,\n        minZ: sphereBoundsIJK[2][0],\n        maxZ: sphereBoundsIJK[2][1] + 1,\n    };\n    return csUtils.createSubVolume(referencedVolume.volumeId, subVolumeBoundsIJK, {\n        targetBuffer: {\n            type: 'Float32Array',\n        },\n    });\n}\nfunction _setPositiveSeedValues(referencedVolume, labelmap, sphereInfo, options) {\n    const refVolumePixelData = referencedVolume.voxelManager.getCompleteScalarDataArray();\n    const worldStartPos = sphereInfo.center;\n    const [width, height, numSlices] = referencedVolume.dimensions;\n    const numPixelsPerSlice = width * height;\n    const ijkStartPosition = transformWorldToIndex(referencedVolume.imageData, worldStartPos);\n    const referencePixelValue = refVolumePixelData[ijkStartPosition[2] * numPixelsPerSlice +\n        ijkStartPosition[1] * width +\n        ijkStartPosition[0]];\n    const positiveSeedValue = options.positiveSeedValue ?? POSITIVE_SEED_VALUE;\n    const positiveSeedVariance = options.positiveSeedVariance ?? POSITIVE_SEED_VARIANCE;\n    const positiveSeedVarianceValue = Math.abs(referencePixelValue * positiveSeedVariance);\n    const minPositivePixelValue = referencePixelValue - positiveSeedVarianceValue;\n    const maxPositivePixelValue = referencePixelValue + positiveSeedVarianceValue;\n    const neighborsCoordDelta = [\n        [-1, 0, 0],\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n        [0, 0, 1],\n    ];\n    const startVoxelIndex = ijkStartPosition[2] * numPixelsPerSlice +\n        ijkStartPosition[1] * width +\n        ijkStartPosition[0];\n    labelmap.voxelManager.setAtIndex(startVoxelIndex, positiveSeedValue);\n    const queue = [ijkStartPosition];\n    while (queue.length) {\n        const ijkVoxel = queue.shift();\n        const [x, y, z] = ijkVoxel;\n        for (let i = 0, len = neighborsCoordDelta.length; i < len; i++) {\n            const neighborCoordDelta = neighborsCoordDelta[i];\n            const nx = x + neighborCoordDelta[0];\n            const ny = y + neighborCoordDelta[1];\n            const nz = z + neighborCoordDelta[2];\n            if (nx < 0 ||\n                nx >= width ||\n                ny < 0 ||\n                ny >= height ||\n                nz < 0 ||\n                nz >= numSlices) {\n                continue;\n            }\n            const neighborVoxelIndex = nz * numPixelsPerSlice + ny * width + nx;\n            const neighborPixelValue = refVolumePixelData[neighborVoxelIndex];\n            const neighborLabelmapValue = labelmap.voxelManager.getAtIndex(neighborVoxelIndex);\n            if (neighborLabelmapValue === positiveSeedValue ||\n                neighborPixelValue < minPositivePixelValue ||\n                neighborPixelValue > maxPositivePixelValue) {\n                continue;\n            }\n            labelmap.voxelManager.setAtIndex(neighborVoxelIndex, positiveSeedValue);\n            queue.push([nx, ny, nz]);\n        }\n    }\n}\nfunction _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options) {\n    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const [columns, rows, numSlices] = labelmap.dimensions;\n    const numPixelsPerSlice = columns * rows;\n    const { worldVecRowDir, worldVecSliceDir } = csUtils.getVolumeDirectionVectors(labelmap.imageData, viewport.getCamera());\n    const ijkSphereCenter = transformWorldToIndex(subVolume.imageData, sphereInfo.center);\n    const referencePixelValue = subVolPixelData[ijkSphereCenter[2] * columns * rows +\n        ijkSphereCenter[1] * columns +\n        ijkSphereCenter[0]];\n    const negativeSeedVariance = options.negativeSeedVariance ?? NEGATIVE_SEED_VARIANCE;\n    const negativeSeedValue = options?.negativeSeedValue ?? NEGATIVE_SEED_VALUE;\n    const negativeSeedVarianceValue = Math.abs(referencePixelValue * negativeSeedVariance);\n    const minNegativePixelValue = referencePixelValue - negativeSeedVarianceValue;\n    const maxNegativePixelValue = referencePixelValue + negativeSeedVarianceValue;\n    const numCirclePoints = 360;\n    const rotationAngle = (2 * Math.PI) / numCirclePoints;\n    const worldQuat = quat.setAxisAngle(quat.create(), worldVecSliceDir, rotationAngle);\n    const vecRotation = vec3.clone(worldVecRowDir);\n    for (let i = 0; i < numCirclePoints; i++) {\n        const worldCircleBorderPoint = vec3.scaleAndAdd(vec3.create(), sphereInfo.center, vecRotation, sphereInfo.radius);\n        const ijkCircleBorderPoint = transformWorldToIndex(labelmap.imageData, worldCircleBorderPoint);\n        const [x, y, z] = ijkCircleBorderPoint;\n        vec3.transformQuat(vecRotation, vecRotation, worldQuat);\n        if (x < 0 ||\n            x >= columns ||\n            y < 0 ||\n            y >= rows ||\n            z < 0 ||\n            z >= numSlices) {\n            continue;\n        }\n        const offset = x + y * columns + z * numPixelsPerSlice;\n        const pixelValue = subVolPixelData[offset];\n        if (pixelValue < minNegativePixelValue ||\n            pixelValue > maxNegativePixelValue) {\n            labelmap.voxelManager.setAtIndex(offset, negativeSeedValue);\n        }\n    }\n}\nasync function _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options) {\n    const labelmap = await volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);\n    _setPositiveSeedValues(subVolume, labelmap, sphereInfo, options);\n    _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options);\n    return labelmap;\n}\nasync function runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    const subVolume = _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport);\n    const labelmap = await _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options);\n    await run(subVolume.volumeId, labelmap.volumeId);\n    return labelmap;\n}\nexport { runGrowCutForSphere as default, runGrowCutForSphere };\n","import { utilities as csUtils, cache, volumeLoader } from '@cornerstonejs/core';\nimport { run } from './runGrowCut';\nimport { POSITIVE_SEED_LABEL, NEGATIVE_SEED_LABEL, DEFAULT_NEIGHBORHOOD_RADIUS, DEFAULT_POSITIVE_STD_DEV_MULTIPLIER, DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER, DEFAULT_NEGATIVE_SEED_MARGIN, DEFAULT_NEGATIVE_SEEDS_COUNT, MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER, } from './constants';\nconst { transformWorldToIndex } = csUtils;\nconst MAX_POSITIVE_SEEDS = 100000;\nfunction calculateGrowCutSeeds(referencedVolume, worldPosition, options) {\n    const { dimensions, imageData: refImageData } = referencedVolume;\n    const [width, height, numSlices] = dimensions;\n    const referenceVolumeVoxelManager = referencedVolume.voxelManager;\n    const scalarData = referenceVolumeVoxelManager.getCompleteScalarDataArray();\n    const numPixelsPerSlice = width * height;\n    const neighborhoodRadius = options?.initialNeighborhoodRadius ?? DEFAULT_NEIGHBORHOOD_RADIUS;\n    const positiveK = options?.positiveStdDevMultiplier ?? DEFAULT_POSITIVE_STD_DEV_MULTIPLIER;\n    const negativeK = options?.negativeStdDevMultiplier ?? DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER;\n    const negativeSeedMargin = options?.negativeSeedMargin ?? DEFAULT_NEGATIVE_SEED_MARGIN;\n    const negativeSeedsTargetPatches = options?.negativeSeedsTargetPatches ?? DEFAULT_NEGATIVE_SEEDS_COUNT;\n    const ijkStart = transformWorldToIndex(refImageData, worldPosition).map(Math.round);\n    const startIndex = referenceVolumeVoxelManager.toIndex(ijkStart);\n    if (ijkStart[0] < 0 ||\n        ijkStart[0] >= width ||\n        ijkStart[1] < 0 ||\n        ijkStart[1] >= height ||\n        ijkStart[2] < 0 ||\n        ijkStart[2] >= numSlices) {\n        console.warn('Click position is outside volume bounds.');\n        return null;\n    }\n    const initialStats = csUtils.calculateNeighborhoodStats(scalarData, dimensions, ijkStart, neighborhoodRadius);\n    if (initialStats.count === 0) {\n        initialStats.mean = scalarData[startIndex];\n        initialStats.stdDev = 0;\n    }\n    const positiveIntensityMin = initialStats.mean - positiveK * initialStats.stdDev;\n    const positiveIntensityMax = initialStats.mean + positiveK * initialStats.stdDev;\n    const neighborsCoordDelta = [\n        [-1, 0, 0],\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n        [0, 0, 1],\n    ];\n    let minX = Infinity, minY = Infinity, minZ = Infinity;\n    let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;\n    const positiveSeedIndices = new Set();\n    const queue = [];\n    const startValue = scalarData[startIndex];\n    if (startValue >= positiveIntensityMin &&\n        startValue <= positiveIntensityMax) {\n        positiveSeedIndices.add(startIndex);\n        queue.push(ijkStart);\n        minX = maxX = ijkStart[0];\n        minY = maxY = ijkStart[1];\n        minZ = maxZ = ijkStart[2];\n    }\n    else {\n        console.warn('Clicked voxel intensity is outside the calculated positive range. No positive seeds generated.');\n        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };\n    }\n    let currentQueueIndex = 0;\n    while (currentQueueIndex < queue.length &&\n        positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {\n        const [x, y, z] = queue[currentQueueIndex++];\n        minX = Math.min(x, minX);\n        minY = Math.min(y, minY);\n        minZ = Math.min(z, minZ);\n        maxX = Math.max(x, maxX);\n        maxY = Math.max(y, maxY);\n        maxZ = Math.max(z, maxZ);\n        for (let i = 0; i < neighborsCoordDelta.length; i++) {\n            const [dx, dy, dz] = neighborsCoordDelta[i];\n            const nx = x + dx;\n            const ny = y + dy;\n            const nz = z + dz;\n            if (nx < 0 ||\n                nx >= width ||\n                ny < 0 ||\n                ny >= height ||\n                nz < 0 ||\n                nz >= numSlices) {\n                continue;\n            }\n            const neighborIndex = nz * numPixelsPerSlice + ny * width + nx;\n            if (positiveSeedIndices.has(neighborIndex)) {\n                continue;\n            }\n            const neighborValue = scalarData[neighborIndex];\n            if (neighborValue >= positiveIntensityMin &&\n                neighborValue <= positiveIntensityMax) {\n                positiveSeedIndices.add(neighborIndex);\n                if (positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {\n                    queue.push([nx, ny, nz]);\n                }\n            }\n        }\n    }\n    if (positiveSeedIndices.size >= MAX_POSITIVE_SEEDS) {\n        console.debug(`Reached maximum number of positive seeds (${MAX_POSITIVE_SEEDS}). Stopping BFS.`);\n    }\n    if (positiveSeedIndices.size === 0) {\n        console.warn('No positive seeds found after BFS.');\n        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };\n    }\n    let positiveSum = 0;\n    let positiveSumSq = 0;\n    positiveSeedIndices.forEach((index) => {\n        const value = scalarData[index];\n        positiveSum += value;\n        positiveSumSq += value * value;\n    });\n    const positiveCount = positiveSeedIndices.size;\n    const positiveMean = positiveSum / positiveCount;\n    const positiveVariance = positiveSumSq / positiveCount - positiveMean * positiveMean;\n    const positiveStdDev = Math.sqrt(Math.max(0, positiveVariance));\n    const negativeDiffThreshold = negativeK * positiveStdDev;\n    const minXm = Math.max(0, minX - negativeSeedMargin);\n    const minYm = Math.max(0, minY - negativeSeedMargin);\n    const minZm = Math.max(0, minZ - negativeSeedMargin);\n    const maxXm = Math.min(width - 1, maxX + negativeSeedMargin);\n    const maxYm = Math.min(height - 1, maxY + negativeSeedMargin);\n    const maxZm = Math.min(numSlices - 1, maxZ + negativeSeedMargin);\n    const negativeSeedIndices = new Set();\n    let attempts = 0;\n    let patchesAdded = 0;\n    const maxAttempts = negativeSeedsTargetPatches * MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER;\n    while (patchesAdded < negativeSeedsTargetPatches && attempts < maxAttempts) {\n        attempts++;\n        const rx = Math.floor(Math.random() * (maxXm - minXm + 1) + minXm);\n        const ry = Math.floor(Math.random() * (maxYm - minYm + 1) + minYm);\n        const rz = Math.floor(Math.random() * (maxZm - minZm + 1) + minZm);\n        const centerIndex = rz * numPixelsPerSlice + ry * width + rx;\n        if (positiveSeedIndices.has(centerIndex) ||\n            negativeSeedIndices.has(centerIndex)) {\n            continue;\n        }\n        const centerValue = scalarData[centerIndex];\n        if (Math.abs(centerValue - positiveMean) > negativeDiffThreshold) {\n            let patchContributed = false;\n            for (let dy = -1; dy <= 1; dy++) {\n                const ny = ry + dy;\n                if (ny < 0 || ny >= height) {\n                    continue;\n                }\n                for (let dx = -1; dx <= 1; dx++) {\n                    const nx = rx + dx;\n                    if (nx < 0 || nx >= width) {\n                        continue;\n                    }\n                    const neighborIndex = rz * numPixelsPerSlice + ny * width + nx;\n                    if (positiveSeedIndices.has(neighborIndex) ||\n                        negativeSeedIndices.has(neighborIndex)) {\n                        continue;\n                    }\n                    negativeSeedIndices.add(neighborIndex);\n                    patchContributed = true;\n                }\n            }\n            if (patchContributed) {\n                patchesAdded++;\n            }\n        }\n    }\n    if (negativeSeedIndices.size === 0) {\n        console.warn('Could not find any negative seeds. GrowCut might fail or produce poor results.');\n    }\n    console.debug('positiveSeedIndices', positiveSeedIndices.size);\n    console.debug('negativeSeedIndices', negativeSeedIndices.size);\n    return { positiveSeedIndices, negativeSeedIndices };\n}\nasync function runOneClickGrowCut({ referencedVolumeId, worldPosition, options, }) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    const labelmap = volumeLoader.createAndCacheDerivedLabelmapVolume(referencedVolumeId);\n    labelmap.voxelManager.forEach(({ index, value }) => {\n        if (value !== 0) {\n            labelmap.voxelManager.setAtIndex(index, 0);\n        }\n    });\n    const seeds = options.seeds ??\n        calculateGrowCutSeeds(referencedVolume, worldPosition, options);\n    const positiveSeedLabel = options?.positiveSeedValue ?? POSITIVE_SEED_LABEL;\n    const negativeSeedLabel = options?.negativeSeedValue ?? NEGATIVE_SEED_LABEL;\n    if (!seeds) {\n        return null;\n    }\n    const { positiveSeedIndices, negativeSeedIndices } = seeds;\n    if (positiveSeedIndices.size < 10 ||\n        positiveSeedIndices.size > MAX_POSITIVE_SEEDS ||\n        negativeSeedIndices.size < 10) {\n        console.warn('Not enough seeds found. GrowCut might fail or produce poor results.');\n        return labelmap;\n    }\n    positiveSeedIndices.forEach((index) => {\n        labelmap.voxelManager.setAtIndex(index, positiveSeedLabel);\n    });\n    negativeSeedIndices.forEach((index) => {\n        labelmap.voxelManager.setAtIndex(index, negativeSeedLabel);\n    });\n    await run(referencedVolumeId, labelmap.volumeId, options);\n    return labelmap;\n}\nexport { runOneClickGrowCut as default, runOneClickGrowCut, calculateGrowCutSeeds, };\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getBrushToolInstances } from './getBrushToolInstances';\nexport function invalidateBrushCursor(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n    brushBasedToolInstances.forEach((tool) => {\n        tool.invalidateBrushCursor();\n    });\n    const viewportsInfo = toolGroup.getViewportsInfo();\n    const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);\n    if (!viewportsInfoArray.length) {\n        return;\n    }\n    const viewportIds = toolGroup.getViewportIds();\n    triggerAnnotationRenderForViewportIds(viewportIds);\n}\n","import { cache } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nexport default function isLineInSegment(point1, point2, isInSegment) {\n    const ijk1 = isInSegment.toIJK(point1);\n    const ijk2 = isInSegment.toIJK(point2);\n    const testPoint = vec3.create();\n    const { testIJK } = isInSegment;\n    const delta = vec3.sub(vec3.create(), ijk1, ijk2);\n    const testSize = Math.round(Math.max(...delta.map(Math.abs)));\n    if (testSize < 2) {\n        return true;\n    }\n    const unitDelta = vec3.scale(vec3.create(), delta, 1 / testSize);\n    for (let i = 1; i < testSize; i++) {\n        vec3.scaleAndAdd(testPoint, ijk2, unitDelta, i);\n        if (!testIJK(testPoint)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction createIsInSegmentMetadata({ dimensions, imageData, voxelManager, segmentIndex, containedSegmentIndices, }) {\n    const width = dimensions[0];\n    const pixelsPerSlice = width * dimensions[1];\n    return {\n        testCenter: (point1, point2) => {\n            const point = vec3.add(vec3.create(), point1, point2).map((it) => it / 2);\n            const ijk = imageData.worldToIndex(point).map(Math.round);\n            const [i, j, k] = ijk;\n            const index = i + j * width + k * pixelsPerSlice;\n            const value = voxelManager.getAtIndex(index);\n            return value === segmentIndex || containedSegmentIndices?.has(value);\n        },\n        toIJK: (point) => imageData.worldToIndex(point),\n        testIJK: (ijk) => {\n            const [i, j, k] = ijk;\n            const index = Math.round(i) + Math.round(j) * width + Math.round(k) * pixelsPerSlice;\n            const value = voxelManager.getAtIndex(index);\n            return value === segmentIndex || containedSegmentIndices?.has(value);\n        },\n    };\n}\nfunction createIsInSegment(segVolumeId, segmentIndex, containedSegmentIndices) {\n    const vol = cache.getVolume(segVolumeId);\n    if (!vol) {\n        console.warn(`No volume found for ${segVolumeId}`);\n        return;\n    }\n    return createIsInSegmentMetadata({\n        dimensions: vol.dimensions,\n        imageData: vol.imageData,\n        voxelManager: vol.voxelManager,\n        segmentIndex,\n        containedSegmentIndices,\n    });\n}\nexport { createIsInSegment, createIsInSegmentMetadata, isLineInSegment };\n","import { utilities } from '@cornerstonejs/core';\nimport normalizeViewportPlane from '../normalizeViewportPlane';\nconst { RLEVoxelMap, VoxelManager } = utilities;\nconst MAX_IMAGE_SIZE = 65535;\nexport var SegmentationEnum;\n(function (SegmentationEnum) {\n    SegmentationEnum[SegmentationEnum[\"SEGMENT\"] = -1] = \"SEGMENT\";\n    SegmentationEnum[SegmentationEnum[\"ISLAND\"] = -2] = \"ISLAND\";\n    SegmentationEnum[SegmentationEnum[\"INTERIOR\"] = -3] = \"INTERIOR\";\n    SegmentationEnum[SegmentationEnum[\"EXTERIOR\"] = -4] = \"EXTERIOR\";\n    SegmentationEnum[SegmentationEnum[\"INTERIOR_SMALL\"] = -5] = \"INTERIOR_SMALL\";\n    SegmentationEnum[SegmentationEnum[\"INTERIOR_TEST\"] = -6] = \"INTERIOR_TEST\";\n})(SegmentationEnum || (SegmentationEnum = {}));\nexport default class IslandRemoval {\n    constructor(options) {\n        this.fillInternalEdge = false;\n        this.maxInternalRemove = 128;\n        this.maxInternalRemove =\n            options?.maxInternalRemove ?? this.maxInternalRemove;\n        this.fillInternalEdge = options?.fillInternalEdge ?? this.fillInternalEdge;\n    }\n    initialize(viewport, segmentationVoxels, options) {\n        const hasSource = !!segmentationVoxels.sourceVoxelManager;\n        const segmentationVoxelManager = hasSource\n            ? segmentationVoxels.sourceVoxelManager\n            : segmentationVoxels;\n        const previewVoxelManager = hasSource\n            ? segmentationVoxels\n            : VoxelManager.createRLEHistoryVoxelManager(segmentationVoxelManager);\n        const { segmentIndex = 1, previewSegmentIndex = 1 } = options;\n        const clickedPoints = options.points || segmentationVoxelManager.getPoints();\n        if (!clickedPoints?.length) {\n            return;\n        }\n        const boundsIJK = segmentationVoxelManager\n            .getBoundsIJK()\n            .map((bound, i) => [\n            Math.min(bound[0], ...clickedPoints.map((point) => point[i])),\n            Math.max(bound[1], ...clickedPoints.map((point) => point[i])),\n        ]);\n        if (boundsIJK.find((it) => it[0] < 0 || it[1] > MAX_IMAGE_SIZE)) {\n            return;\n        }\n        const { toIJK, fromIJK, boundsIJKPrime, error } = normalizeViewportPlane(viewport, boundsIJK);\n        if (error) {\n            console.warn('Not performing island removal for planes not orthogonal to acquisition plane', error);\n            return;\n        }\n        const [width, height, depth] = fromIJK(segmentationVoxelManager.dimensions);\n        const segmentSet = new RLEVoxelMap(width, height, depth);\n        const getter = (i, j, k) => {\n            const index = segmentationVoxelManager.toIndex(toIJK([i, j, k]));\n            const oldVal = segmentationVoxelManager.getAtIndex(index);\n            if (oldVal === previewSegmentIndex || oldVal === segmentIndex) {\n                return SegmentationEnum.SEGMENT;\n            }\n        };\n        segmentSet.fillFrom(getter, boundsIJKPrime);\n        segmentSet.normalizer = { toIJK, fromIJK, boundsIJKPrime };\n        this.segmentSet = segmentSet;\n        this.previewVoxelManager = previewVoxelManager;\n        this.segmentIndex = segmentIndex;\n        this.previewSegmentIndex = previewSegmentIndex ?? segmentIndex;\n        this.selectedPoints = clickedPoints;\n        return true;\n    }\n    floodFillSegmentIsland() {\n        const { selectedPoints: clickedPoints, segmentSet } = this;\n        let floodedCount = 0;\n        const { fromIJK } = segmentSet.normalizer;\n        clickedPoints.forEach((clickedPoint) => {\n            const ijkPrime = fromIJK(clickedPoint);\n            const index = segmentSet.toIndex(ijkPrime);\n            const [iPrime, jPrime, kPrime] = ijkPrime;\n            if (segmentSet.get(index) === SegmentationEnum.SEGMENT) {\n                floodedCount += segmentSet.floodFill(iPrime, jPrime, kPrime, SegmentationEnum.ISLAND);\n            }\n        });\n        return floodedCount;\n    }\n    removeExternalIslands() {\n        const { previewVoxelManager, segmentSet } = this;\n        const { toIJK } = segmentSet.normalizer;\n        const callback = (index, rle) => {\n            const [, jPrime, kPrime] = segmentSet.toIJK(index);\n            if (rle.value !== SegmentationEnum.ISLAND) {\n                for (let iPrime = rle.start; iPrime < rle.end; iPrime++) {\n                    const clearPoint = toIJK([iPrime, jPrime, kPrime]);\n                    const v = previewVoxelManager.getAtIJKPoint(clearPoint);\n                    previewVoxelManager.setAtIJKPoint(clearPoint, v === undefined ? 0 : null);\n                }\n            }\n        };\n        segmentSet.forEach(callback, { rowModified: true });\n    }\n    removeInternalIslands() {\n        const { segmentSet, previewVoxelManager, previewSegmentIndex } = this;\n        const { height, normalizer, width } = segmentSet;\n        const { toIJK } = normalizer;\n        segmentSet.forEachRow((baseIndex, row) => {\n            let lastRle;\n            for (const rle of [...row]) {\n                if (rle.value !== SegmentationEnum.ISLAND) {\n                    continue;\n                }\n                if (!lastRle) {\n                    if (this.fillInternalEdge && rle.start > 0) {\n                        for (let iPrime = 0; iPrime < rle.start; iPrime++) {\n                            segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);\n                        }\n                    }\n                    lastRle = rle;\n                    continue;\n                }\n                for (let iPrime = lastRle.end; iPrime < rle.start; iPrime++) {\n                    segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);\n                }\n                lastRle = rle;\n            }\n            if (this.fillInternalEdge && lastRle?.end < width) {\n                for (let iPrime = lastRle.end; iPrime < width; iPrime++) {\n                    segmentSet.set(baseIndex + iPrime, SegmentationEnum.INTERIOR);\n                }\n            }\n        });\n        segmentSet.forEach((baseIndex, rle) => {\n            if (rle.value !== SegmentationEnum.INTERIOR) {\n                return;\n            }\n            const [, jPrime, kPrime] = segmentSet.toIJK(baseIndex);\n            const rowPrev = jPrime > 0 ? segmentSet.getRun(jPrime - 1, kPrime) : null;\n            const rowNext = jPrime + 1 < height ? segmentSet.getRun(jPrime + 1, kPrime) : null;\n            const isLast = jPrime === height - 1;\n            const isFirst = jPrime === 0;\n            const prevCovers = IslandRemoval.covers(rle, rowPrev) ||\n                (isFirst && this.fillInternalEdge);\n            const nextCovers = IslandRemoval.covers(rle, rowNext) || (isLast && this.fillInternalEdge);\n            if (rle.end - rle.start > 2 && (!prevCovers || !nextCovers)) {\n                segmentSet.floodFill(rle.start, jPrime, kPrime, SegmentationEnum.EXTERIOR, { singlePlane: true });\n            }\n        });\n        segmentSet.forEach((baseIndex, rle) => {\n            if (rle.value !== SegmentationEnum.INTERIOR) {\n                return;\n            }\n            const [, jPrime, kPrime] = segmentSet.toIJK(baseIndex);\n            const size = segmentSet.floodFill(rle.start, jPrime, kPrime, SegmentationEnum.INTERIOR_TEST);\n            const isBig = size > this.maxInternalRemove;\n            const newType = isBig\n                ? SegmentationEnum.EXTERIOR\n                : SegmentationEnum.INTERIOR_SMALL;\n            segmentSet.floodFill(rle.start, jPrime, kPrime, newType);\n        });\n        segmentSet.forEach((baseIndex, rle) => {\n            if (rle.value !== SegmentationEnum.INTERIOR_SMALL) {\n                return;\n            }\n            for (let iPrime = rle.start; iPrime < rle.end; iPrime++) {\n                const clearPoint = toIJK(segmentSet.toIJK(baseIndex + iPrime));\n                previewVoxelManager.setAtIJKPoint(clearPoint, previewSegmentIndex);\n            }\n        });\n        return previewVoxelManager.getArrayOfModifiedSlices();\n    }\n    static covers(rle, row) {\n        if (!row) {\n            return false;\n        }\n        let { start } = rle;\n        const { end } = rle;\n        for (const rowRle of row) {\n            if (start >= rowRle.start && start < rowRle.end) {\n                start = rowRle.end;\n                if (start >= end) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n","import { state } from '../../stateManagement/annotation';\nimport RectangleROIStartEndThresholdTool from '../../tools/segmentation/RectangleROIStartEndThresholdTool';\nimport RectangleROIThresholdTool from '../../tools/segmentation/RectangleROIThresholdTool';\nimport thresholdVolumeByRange from './thresholdVolumeByRange';\nimport getBoundsIJKFromRectangleAnnotations from '../rectangleROITool/getBoundsIJKFromRectangleAnnotations';\nfunction rectangleROIThresholdVolumeByRange(annotationUIDs, segmentationVolume, thresholdVolumeInformation, options) {\n    const annotations = annotationUIDs.map((annotationUID) => {\n        return state.getAnnotation(annotationUID);\n    });\n    _validateAnnotations(annotations);\n    let boundsIJK;\n    for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n        const volumeSize = thresholdVolumeInformation[i].volume.voxelManager.getScalarDataLength();\n        if (volumeSize === segmentationVolume.voxelManager.getScalarDataLength() ||\n            i === 0) {\n            boundsIJK = getBoundsIJKFromRectangleAnnotations(annotations, thresholdVolumeInformation[i].volume, options);\n        }\n    }\n    const outputSegmentationVolume = thresholdVolumeByRange(segmentationVolume, thresholdVolumeInformation, { ...options, boundsIJK, segmentationId: options.segmentationId });\n    outputSegmentationVolume.modified();\n    return outputSegmentationVolume;\n}\nfunction _validateAnnotations(annotations) {\n    const validToolNames = [\n        RectangleROIThresholdTool.toolName,\n        RectangleROIStartEndThresholdTool.toolName,\n    ];\n    for (const annotation of annotations) {\n        const name = annotation.metadata.toolName;\n        if (!validToolNames.includes(name)) {\n            throw new Error('rectangleROIThresholdVolumeByRange only supports RectangleROIThreshold and RectangleROIStartEndThreshold annotations');\n        }\n    }\n}\nexport default rectangleROIThresholdVolumeByRange;\n","import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { state as annotationState, config as annotationConfig, } from '../../stateManagement/annotation';\nimport contourAndFindLargestBidirectional from './contourAndFindLargestBidirectional';\nimport createBidirectionalToolData from './createBidirectionalToolData';\nimport BidirectionalTool from '../../tools/annotation/BidirectionalTool';\nimport { getSegmentations } from '../../stateManagement/segmentation/getSegmentations';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nexport default async function segmentContourAction(element, configuration) {\n    console.warn('Deprecation Alert: There is a new getSegmentLargestBidirectional function that handles volume, stack and individual segment cases properly. This function is deprecated and will be removed in a future version.');\n    const { data: configurationData } = configuration;\n    const enabledElement = getEnabledElement(element);\n    const segment = (configurationData.getSegment || defaultGetSegment)(enabledElement, configurationData);\n    if (!segment) {\n        return;\n    }\n    const FrameOfReferenceUID = enabledElement.viewport.getFrameOfReferenceUID();\n    const segmentationsList = getSegmentations();\n    const { segmentIndex, segmentationId } = segment;\n    const bidirectionals = annotationState.getAnnotations(this.toolName || BidirectionalTool.toolName, FrameOfReferenceUID);\n    let hasExistingActiveSegment = false;\n    const existingLargestBidirectionals = bidirectionals.filter((existingBidirectionalItem) => {\n        const segment = existingBidirectionalItem.data.segment;\n        if (!segment) {\n            return false;\n        }\n        if (segment.segmentationId === segmentationId &&\n            segment.segmentIndex === segmentIndex) {\n            hasExistingActiveSegment = true;\n            existingBidirectionalItem.data.segment = segment;\n        }\n        return true;\n    });\n    if (!hasExistingActiveSegment) {\n        existingLargestBidirectionals.push({\n            data: { segment },\n        });\n    }\n    let newBidirectional;\n    existingLargestBidirectionals.forEach(async (existingLargestBidirectional) => {\n        const segments = [];\n        const updateSegment = existingLargestBidirectional.data\n            .segment;\n        const { segmentIndex, segmentationId } = updateSegment;\n        segments[segmentIndex] = updateSegment;\n        annotationState.removeAnnotation(existingLargestBidirectional.annotationUID);\n        const bidirectionalData = await contourAndFindLargestBidirectional({\n            ...segmentationsList.find((segmentation) => segmentation.segmentationId === segmentationId),\n            segments,\n        });\n        if (!bidirectionalData) {\n            return;\n        }\n        const bidirectionalToolData = createBidirectionalToolData(bidirectionalData, enabledElement.viewport);\n        bidirectionalToolData.annotationUID =\n            existingLargestBidirectional.annotationUID;\n        bidirectionalToolData.data.segment = updateSegment;\n        const annotationUID = annotationState.addAnnotation(bidirectionalToolData, FrameOfReferenceUID);\n        if (updateSegment.segmentIndex === segment.segmentIndex &&\n            updateSegment.segmentationId === segment.segmentationId) {\n            newBidirectional = bidirectionalData;\n            const { style } = segment;\n            if (style) {\n                annotationConfig.style.setAnnotationStyles(annotationUID, style);\n            }\n        }\n    });\n    if (newBidirectional) {\n        const { sliceIndex } = newBidirectional;\n        const imageIds = enabledElement.viewport.getImageIds();\n        utilities.jumpToSlice(element, {\n            imageIndex: imageIds.length - 1 - sliceIndex,\n        });\n        enabledElement.viewport.render();\n    }\n    else {\n        console.warn('No bidirectional found');\n    }\n    return newBidirectional;\n}\nexport function defaultGetSegment(enabledElement, configuration) {\n    const segmentationsList = getSegmentations();\n    if (!segmentationsList.length) {\n        return;\n    }\n    const segmentationId = configuration.segmentationId || segmentationsList[0].segmentationId;\n    const segmentIndex = configuration.segmentIndex ?? getActiveSegmentIndex(segmentationId);\n    if (!segmentIndex) {\n        return;\n    }\n    const segmentData = configuration.segmentData?.get(segmentIndex);\n    return {\n        label: `Segment ${segmentIndex}`,\n        segmentIndex,\n        segmentationId,\n        ...segmentData,\n    };\n}\n","import { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { getVoxelOverlap, processVolumes } from './utilities';\nfunction thresholdSegmentationByRange(segmentationVolume, segmentationIndex, thresholdVolumeInformation, overlapType, segmentationId) {\n    if (!segmentationId) {\n        throw new Error('Segmentation ID is required to be passed inside thresholdSegmentationByRange');\n    }\n    const { baseVolumeIdx, volumeInfoList } = processVolumes(segmentationVolume, thresholdVolumeInformation);\n    const { voxelManager } = volumeInfoList[baseVolumeIdx];\n    const refVoxelManager = voxelManager;\n    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();\n    const segVoxelManager = segmentationVolume.voxelManager;\n    volumeInfoList.forEach((volumeInfo) => {\n        const { volumeSize } = volumeInfo;\n        if (volumeSize === scalarDataLength) {\n            _handleSameSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo);\n        }\n        else {\n            _handleDifferentSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType);\n        }\n    });\n    triggerSegmentationDataModified(segmentationId);\n    return segmentationVolume;\n}\nfunction _handleDifferentSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo, volumeInfoList, baseVolumeIdx, overlapType) {\n    const { imageData, lower, upper, dimensions } = volumeInfo;\n    let total, overlaps, range;\n    const segScalarDataLength = segVoxelManager.getScalarDataLength();\n    for (let i = 0; i < segScalarDataLength; i++) {\n        if (segScalarDataLength.getAtIndex(i) === segmentationIndex) {\n            const overlapBounds = getVoxelOverlap(imageData, dimensions, volumeInfoList[baseVolumeIdx].spacing, volumeInfoList[baseVolumeIdx].imageData.getPoint(i));\n            const callbackOverlap = ({ value }) => {\n                total = total + 1;\n                if (value >= range.lower && value <= range.upper) {\n                    overlaps = overlaps + 1;\n                }\n            };\n            total = 0;\n            overlaps = 0;\n            range = { lower, upper };\n            let overlapTest = false;\n            segVoxelManager.forEach(callbackOverlap, {\n                imageData,\n                boundsIJK: overlapBounds,\n            });\n            overlapTest = overlapType === 0 ? overlaps > 0 : overlaps === total;\n            segVoxelManager.setAtIndex(i, overlapTest ? segmentationIndex : 0);\n        }\n    }\n    return { total, range, overlaps };\n}\nfunction _handleSameSizeVolume(segVoxelManager, refVoxelManager, segmentationIndex, volumeInfo) {\n    const { lower, upper } = volumeInfo;\n    const scalarDataLength = segVoxelManager.getScalarDataLength();\n    for (let i = 0; i < scalarDataLength; i++) {\n        if (segVoxelManager.getAtIndex[i] === segmentationIndex) {\n            const value = refVoxelManager.getAtIndex(i);\n            segVoxelManager.setAtIndex(i, value >= lower && value <= upper ? segmentationIndex : 0);\n        }\n    }\n}\nexport default thresholdSegmentationByRange;\n","import { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { getVoxelOverlap, processVolumes } from './utilities';\nfunction thresholdVolumeByRange(segmentationVolume, thresholdVolumeInformation, options) {\n    const { imageData: segmentationImageData } = segmentationVolume;\n    const { overwrite, boundsIJK, segmentationId } = options;\n    if (!segmentationId) {\n        throw new Error('Segmentation ID is required to be passed inside thresholdVolumeByRange as options');\n    }\n    const overlapType = options?.overlapType || 0;\n    const segVoxelManager = segmentationVolume.voxelManager;\n    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();\n    if (overwrite) {\n        for (let i = 0; i < scalarDataLength; i++) {\n            segVoxelManager.setAtIndex(i, 0);\n        }\n    }\n    const { baseVolumeIdx, volumeInfoList } = processVolumes(segmentationVolume, thresholdVolumeInformation);\n    let overlaps, total, range;\n    const testOverlapRange = (volumeInfo, voxelSpacing, voxelCenter) => {\n        const callbackOverlap = ({ value }) => {\n            total = total + 1;\n            if (value >= range.lower && value <= range.upper) {\n                overlaps = overlaps + 1;\n            }\n        };\n        const { imageData, dimensions, lower, upper } = volumeInfo;\n        const overlapBounds = getVoxelOverlap(imageData, dimensions, voxelSpacing, voxelCenter);\n        total = 0;\n        overlaps = 0;\n        range = { lower, upper };\n        let overlapTest = false;\n        const { voxelManager } = imageData.get('voxelManager');\n        voxelManager.forEach(callbackOverlap, {\n            imageData,\n            boundsIJK: overlapBounds,\n        });\n        if (overlapType === 0) {\n            overlapTest = overlaps > 0;\n        }\n        else if (overlapType == 1) {\n            overlapTest = overlaps === total;\n        }\n        return overlapTest;\n    };\n    const testRange = (volumeInfo, pointIJK) => {\n        const { imageData, lower, upper } = volumeInfo;\n        const voxelManager = imageData.get('voxelManager').voxelManager;\n        const offset = voxelManager.toIndex(pointIJK);\n        const value = voxelManager.getAtIndex(offset);\n        if (value <= lower || value >= upper) {\n            return false;\n        }\n        else {\n            return true;\n        }\n    };\n    const callback = ({ index, pointIJK, pointLPS }) => {\n        let insert = volumeInfoList.length > 0;\n        for (let i = 0; i < volumeInfoList.length; i++) {\n            if (volumeInfoList[i].volumeSize === scalarDataLength) {\n                insert = testRange(volumeInfoList[i], pointIJK);\n            }\n            else {\n                insert = testOverlapRange(volumeInfoList[i], volumeInfoList[baseVolumeIdx].spacing, pointLPS);\n            }\n            if (!insert) {\n                break;\n            }\n        }\n        if (insert) {\n            segVoxelManager.setAtIndex(index, options.segmentIndex || 1);\n        }\n    };\n    const voxelManager = segmentationVolume.voxelManager;\n    voxelManager.forEach(callback, {\n        imageData: segmentationImageData,\n        boundsIJK,\n    });\n    triggerSegmentationDataModified(options.segmentationId);\n    return segmentationVolume;\n}\nexport default thresholdVolumeByRange;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../boundingBox/getBoundingBoxAroundShape';\nconst equalsCheck = (a, b) => {\n    return JSON.stringify(a) === JSON.stringify(b);\n};\nexport function getVoxelOverlap(imageData, dimensions, voxelSpacing, voxelCenter) {\n    const halfSpacingX = voxelSpacing[0] / 2;\n    const halfSpacingY = voxelSpacing[1] / 2;\n    const halfSpacingZ = voxelSpacing[2] / 2;\n    const voxelCornersIJK = new Array(8);\n    voxelCornersIJK[0] = csUtils.transformWorldToIndex(imageData, [\n        voxelCenter[0] - halfSpacingX,\n        voxelCenter[1] - halfSpacingY,\n        voxelCenter[2] - halfSpacingZ,\n    ]);\n    const offsets = [\n        [1, -1, -1],\n        [-1, 1, -1],\n        [1, 1, -1],\n        [-1, -1, 1],\n        [1, -1, 1],\n        [-1, 1, 1],\n        [1, 1, 1],\n    ];\n    for (let i = 0; i < 7; i++) {\n        const [xOff, yOff, zOff] = offsets[i];\n        voxelCornersIJK[i + 1] = csUtils.transformWorldToIndex(imageData, [\n            voxelCenter[0] + xOff * halfSpacingX,\n            voxelCenter[1] + yOff * halfSpacingY,\n            voxelCenter[2] + zOff * halfSpacingZ,\n        ]);\n    }\n    return getBoundingBoxAroundShapeIJK(voxelCornersIJK, dimensions);\n}\nexport function processVolumes(segmentationVolume, thresholdVolumeInformation) {\n    const { spacing: segmentationSpacing } = segmentationVolume;\n    const scalarDataLength = segmentationVolume.voxelManager.getScalarDataLength();\n    const volumeInfoList = [];\n    let baseVolumeIdx = 0;\n    for (let i = 0; i < thresholdVolumeInformation.length; i++) {\n        const { imageData, spacing, dimensions, voxelManager } = thresholdVolumeInformation[i].volume;\n        const volumeSize = thresholdVolumeInformation[i].volume.voxelManager.getScalarDataLength();\n        if (volumeSize === scalarDataLength &&\n            equalsCheck(spacing, segmentationSpacing)) {\n            baseVolumeIdx = i;\n        }\n        const lower = thresholdVolumeInformation[i].lower;\n        const upper = thresholdVolumeInformation[i].upper;\n        volumeInfoList.push({\n            imageData,\n            lower,\n            upper,\n            spacing,\n            dimensions,\n            volumeSize,\n            voxelManager,\n        });\n    }\n    return {\n        volumeInfoList,\n        baseVolumeIdx,\n    };\n}\nconst segmentIndicesCache = new Map();\nexport const setSegmentationDirty = (segmentationId) => {\n    const cached = segmentIndicesCache.get(segmentationId);\n    if (cached) {\n        cached.isDirty = true;\n    }\n};\nexport const setSegmentationClean = (segmentationId) => {\n    const cached = segmentIndicesCache.get(segmentationId);\n    if (cached) {\n        cached.isDirty = false;\n    }\n};\nexport const getCachedSegmentIndices = (segmentationId) => {\n    const cached = segmentIndicesCache.get(segmentationId);\n    if (cached && !cached.isDirty) {\n        return cached.indices;\n    }\n    return null;\n};\nexport const setCachedSegmentIndices = (segmentationId, indices) => {\n    segmentIndicesCache.set(segmentationId, { indices, isDirty: false });\n};\n","import { cache, utilities, eventTarget, Enums, triggerEvent, metaData, } from '@cornerstonejs/core';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { getStrategyData } from '../../tools/segmentation/strategies/utils/getStrategyData';\nimport ensureSegmentationVolume from '../../tools/segmentation/strategies/compositions/ensureSegmentationVolume';\nimport ensureImageVolume from '../../tools/segmentation/strategies/compositions/ensureImageVolume';\nexport const triggerWorkerProgress = (workerType, progress) => {\n    triggerEvent(eventTarget, Enums.Events.WEB_WORKER_PROGRESS, {\n        progress,\n        type: workerType,\n    });\n};\nexport const getSegmentationDataForWorker = (segmentationId, segmentIndices) => {\n    const segmentation = getSegmentation(segmentationId);\n    const { representationData } = segmentation;\n    const { Labelmap } = representationData;\n    if (!Labelmap) {\n        console.debug('No labelmap found for segmentation', segmentationId);\n        return null;\n    }\n    const segVolumeId = Labelmap.volumeId;\n    const segImageIds = Labelmap.imageIds;\n    const operationData = {\n        segmentationId,\n        volumeId: segVolumeId,\n        imageIds: segImageIds,\n    };\n    let reconstructableVolume = false;\n    if (segImageIds) {\n        const refImageIds = segImageIds.map((imageId) => {\n            const image = cache.getImage(imageId);\n            return image.referencedImageId;\n        });\n        reconstructableVolume = utilities.isValidVolume(refImageIds);\n    }\n    let indices = segmentIndices;\n    if (!indices) {\n        indices = [getActiveSegmentIndex(segmentationId)];\n    }\n    else if (!Array.isArray(indices)) {\n        indices = [indices, 255];\n    }\n    return {\n        operationData,\n        segVolumeId,\n        segImageIds,\n        reconstructableVolume,\n        indices,\n    };\n};\nexport const prepareVolumeStrategyDataForWorker = (operationData) => {\n    return getStrategyData({\n        operationData,\n        strategy: {\n            ensureSegmentationVolumeFor3DManipulation: ensureSegmentationVolume.ensureSegmentationVolumeFor3DManipulation,\n            ensureImageVolumeFor3DManipulation: ensureImageVolume.ensureImageVolumeFor3DManipulation,\n        },\n    });\n};\nexport const prepareImageInfo = (imageVoxelManager, imageData) => {\n    const imageScalarData = imageVoxelManager.getCompleteScalarDataArray();\n    return {\n        scalarData: imageScalarData,\n        dimensions: imageData.getDimensions(),\n        spacing: imageData.getSpacing(),\n        origin: imageData.getOrigin(),\n        direction: imageData.getDirection(),\n    };\n};\nexport const prepareStackDataForWorker = (segImageIds) => {\n    const segmentationInfo = [];\n    const imageInfo = [];\n    for (const segImageId of segImageIds) {\n        const segImage = cache.getImage(segImageId);\n        const segPixelData = segImage.getPixelData();\n        const { origin, direction, spacing, dimensions } = utilities.getImageDataMetadata(segImage);\n        segmentationInfo.push({\n            scalarData: segPixelData,\n            dimensions,\n            spacing,\n            origin,\n            direction,\n        });\n        const refImageId = segImage.referencedImageId;\n        if (refImageId) {\n            const refImage = cache.getImage(refImageId);\n            if (!refImage) {\n                continue;\n            }\n            const refPixelData = refImage.getPixelData();\n            const refVoxelManager = refImage.voxelManager;\n            const refSpacing = [\n                refImage.rowPixelSpacing,\n                refImage.columnPixelSpacing,\n            ];\n            imageInfo.push({\n                scalarData: refPixelData,\n                dimensions: refVoxelManager\n                    ? refVoxelManager.dimensions\n                    : [refImage.columns, refImage.rows, 1],\n                spacing: refSpacing,\n            });\n        }\n    }\n    return { segmentationInfo, imageInfo };\n};\nexport const getImageReferenceInfo = (segVolumeId, segImageIds) => {\n    let refImageId;\n    if (segVolumeId) {\n        const segmentationVolume = cache.getVolume(segVolumeId);\n        const imageIds = segmentationVolume.imageIds;\n        const cachedImage = cache.getImage(imageIds[0]);\n        if (cachedImage) {\n            refImageId = cachedImage.referencedImageId;\n        }\n    }\n    else if (segImageIds?.length) {\n        const segImage = cache.getImage(segImageIds[0]);\n        refImageId = segImage.referencedImageId;\n    }\n    const refImage = cache.getImage(refImageId);\n    const scalingModule = metaData.get('scalingModule', refImageId);\n    const modalityUnitOptions = {\n        isPreScaled: Boolean(refImage?.preScale?.scaled),\n        isSuvScaled: typeof scalingModule?.suvbw === 'number',\n    };\n    return { refImageId, modalityUnitOptions };\n};\n","import { cache } from '@cornerstonejs/core';\nfunction validateRepresentationData(segmentationRepresentationData) {\n    if ('volumeId' in segmentationRepresentationData) {\n        segmentationRepresentationData =\n            segmentationRepresentationData;\n        const cachedVolume = cache.getVolume(segmentationRepresentationData.volumeId);\n        if (!cachedVolume) {\n            throw new Error(`volumeId of ${segmentationRepresentationData.volumeId} not found in cache, you should load and cache volume before adding segmentation`);\n        }\n    }\n    else if ('imageIds' in segmentationRepresentationData) {\n        segmentationRepresentationData =\n            segmentationRepresentationData;\n        if (!segmentationRepresentationData.imageIds) {\n            throw new Error('The segmentationInput.representationData.imageIds is undefined, please provide a valid representationData.imageIds for stack data');\n        }\n    }\n    else {\n        throw new Error('The segmentationInput.representationData is undefined, please provide a valid representationData');\n    }\n}\nexport function validatePublic(segmentationInput) {\n    if (!segmentationInput.representation.data) {\n        throw new Error('The segmentationInput.representationData.data is undefined, please provide a valid representationData.data');\n    }\n    const representationData = segmentationInput.representation\n        .data;\n    validateRepresentationData(representationData);\n}\nexport function validate(segmentationRepresentationData) {\n    validateRepresentationData(segmentationRepresentationData);\n}\n","import { triggerAnnotationModified } from '../stateManagement/annotation/helpers/state';\nimport { ChangeTypes } from '../enums';\nexport default function setAnnotationLabel(annotation, element, updatedLabel) {\n    annotation.data.label = updatedLabel;\n    triggerAnnotationModified(annotation, element, ChangeTypes.LabelChange);\n}\n","import { imageLoader, Enums, eventTarget, imageLoadPoolManager, cache, metaData, utilities, triggerEvent, } from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport { getStackData, requestType, clearFromImageIds, getPromiseRemovedHandler, } from './stackPrefetchUtils';\nimport { Events } from '../../enums';\nconst { imageRetrieveMetadataProvider } = utilities;\nlet configuration = {\n    maxImagesToPrefetch: Infinity,\n    minBefore: 2,\n    maxAfter: 2,\n    directionExtraImages: 10,\n    preserveExistingPool: false,\n};\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 5;\nconst priorities = {};\nconst enable = (element, priority = 0) => {\n    const stack = getStackData(element);\n    if (!stack) {\n        return;\n    }\n    if (!stack.imageIds?.length) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    updateToolState(element);\n    priorities[element] = priority;\n    prefetch(element, priority);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    eventTarget.addEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n};\nfunction prefetch(element, priority = 0) {\n    const stack = getStackData(element);\n    if (!stack) {\n        return;\n    }\n    if (!stack?.imageIds?.length) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    const stackPrefetchData = getToolState(element);\n    if (!stackPrefetchData) {\n        return;\n    }\n    const stackPrefetch = (stackPrefetchData || {});\n    stackPrefetch.enabled =\n        stackPrefetch.enabled && (stackPrefetch.indicesToRequest?.length ?? 0) > 0;\n    if (stackPrefetch.enabled === false) {\n        return;\n    }\n    function removeFromList(imageIdIndex) {\n        const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n        if (index > -1) {\n            stackPrefetch.indicesToRequest.splice(index, 1);\n        }\n    }\n    const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n    const { currentImageIdIndex } = stack;\n    indicesToRequestCopy.forEach((imageIdIndex) => {\n        const imageId = stack.imageIds[imageIdIndex];\n        if (!imageId) {\n            return;\n        }\n        const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n        const imageCached = distance < 6\n            ? cache.getImageLoadObject(imageId)\n            : cache.isLoaded(imageId);\n        if (imageCached) {\n            removeFromList(imageIdIndex);\n        }\n    });\n    if (!stackPrefetch.indicesToRequest.length) {\n        return;\n    }\n    if (!configuration.preserveExistingPool) {\n        imageLoadPoolManager.filterRequests(clearFromImageIds(stack));\n    }\n    function doneCallback(imageId) {\n        const imageIdIndex = stack.imageIds.indexOf(imageId);\n        removeFromList(imageIdIndex);\n        const image = cache.getCachedImageBasedOnImageURI(imageId);\n        const { stats } = stackPrefetch;\n        const decodeTimeInMS = image?.image?.decodeTimeInMS || 0;\n        if (decodeTimeInMS) {\n            stats.imageIds.set(imageId, decodeTimeInMS);\n            stats.decodeTimeInMS += decodeTimeInMS;\n            const loadTimeInMS = image?.image?.loadTimeInMS || 0;\n            stats.loadTimeInMS += loadTimeInMS;\n        }\n        if (!stackPrefetch.indicesToRequest.length) {\n            if (image?.sizeInBytes) {\n                const { sizeInBytes } = image;\n                const usage = cache.getMaxCacheSize() / 4 / sizeInBytes;\n                if (!stackPrefetch.cacheFill) {\n                    stats.initialTime = Date.now() - stats.start;\n                    stats.initialSize = stats.imageIds.size;\n                    updateToolState(element, usage);\n                    prefetch(element, priority);\n                }\n                else if (stats.imageIds.size) {\n                    stats.fillTime = Date.now() - stats.start;\n                    const { size } = stats.imageIds;\n                    stats.fillSize = size;\n                }\n            }\n        }\n        if (stackPrefetch.indicesToRequest.length === 0) {\n            const eventDetail = {\n                element: element,\n                lastPrefetchedImageId: imageId,\n            };\n            triggerEvent(eventTarget, Events.STACK_PREFETCH_COMPLETE, eventDetail);\n        }\n    }\n    const requestFn = (imageId, options) => {\n        const { retrieveOptions = {} } = metaData.get(imageRetrieveMetadataProvider.IMAGE_RETRIEVE_CONFIGURATION, imageId, 'stack') || {};\n        options.retrieveOptions = {\n            ...options.retrieveOptions,\n            ...(retrieveOptions.default || Object.values(retrieveOptions)?.[0] || {}),\n        };\n        return imageLoader\n            .loadAndCacheImage(imageId, options)\n            .then(() => doneCallback(imageId));\n    };\n    stackPrefetch.indicesToRequest.forEach((imageIdIndex) => {\n        const imageId = stack.imageIds[imageIdIndex];\n        const options = {\n            requestType,\n        };\n        imageLoadPoolManager.addRequest(requestFn.bind(null, imageId, options), requestType, {\n            imageId,\n        }, priority);\n    });\n}\nfunction onImageUpdated(e) {\n    clearTimeout(resetPrefetchTimeout);\n    resetPrefetchTimeout = setTimeout(function () {\n        const element = e.target;\n        try {\n            updateToolState(element);\n            prefetch(element, priorities[element]);\n        }\n        catch (error) {\n            return;\n        }\n    }, resetPrefetchDelay);\n}\nconst signum = (x) => (x < 0 ? -1 : 1);\nconst updateToolState = (element, usage) => {\n    const stack = getStackData(element);\n    if (!stack) {\n        return;\n    }\n    if (!stack.imageIds?.length) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    const { currentImageIdIndex } = stack;\n    let { maxAfter = 2, minBefore = 2 } = configuration;\n    const { directionExtraImages = 10 } = configuration;\n    const stackPrefetchData = getToolState(element) ||\n        {\n            indicesToRequest: [],\n            currentImageIdIndex,\n            stackCount: 0,\n            enabled: true,\n            direction: 1,\n            stats: {\n                start: Date.now(),\n                imageIds: new Map(),\n                decodeTimeInMS: 0,\n                loadTimeInMS: 0,\n                totalBytes: 0,\n            },\n        };\n    const delta = currentImageIdIndex - stackPrefetchData.currentImageIdIndex;\n    stackPrefetchData.direction = signum(delta);\n    stackPrefetchData.currentImageIdIndex = currentImageIdIndex;\n    stackPrefetchData.enabled = true;\n    if (stackPrefetchData.stackCount < 100) {\n        stackPrefetchData.stackCount += directionExtraImages;\n    }\n    if (Math.abs(delta) > maxAfter || !delta) {\n        stackPrefetchData.stackCount = 0;\n        if (usage) {\n            const positionFraction = currentImageIdIndex / stack.imageIds.length;\n            minBefore = Math.ceil(usage * positionFraction);\n            maxAfter = Math.ceil(usage * (1 - positionFraction));\n            stackPrefetchData.cacheFill = true;\n        }\n        else {\n            stackPrefetchData.cacheFill = false;\n        }\n    }\n    else if (delta < 0) {\n        minBefore += stackPrefetchData.stackCount;\n        maxAfter = 0;\n    }\n    else {\n        maxAfter += stackPrefetchData.stackCount;\n        minBefore = 0;\n    }\n    const minIndex = Math.max(0, currentImageIdIndex - minBefore);\n    const maxIndex = Math.min(stack.imageIds.length - 1, currentImageIdIndex + maxAfter);\n    const indicesToRequest = [];\n    for (let i = currentImageIdIndex + 1; i <= maxIndex; i++) {\n        indicesToRequest.push(i);\n    }\n    for (let i = currentImageIdIndex - 1; i >= minIndex; i--) {\n        indicesToRequest.push(i);\n    }\n    stackPrefetchData.indicesToRequest = indicesToRequest;\n    addToolState(element, stackPrefetchData);\n};\nfunction disable(element) {\n    clearTimeout(resetPrefetchTimeout);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    const stackPrefetchData = getToolState(element);\n    if (stackPrefetchData) {\n        stackPrefetchData.enabled = false;\n    }\n}\nfunction getConfiguration() {\n    return configuration;\n}\nfunction setConfiguration(config) {\n    configuration = config;\n}\nconst stackContextPrefetch = {\n    enable,\n    disable,\n    getConfiguration,\n    setConfiguration,\n};\nexport default stackContextPrefetch;\n","import { imageLoader, Enums, eventTarget, imageLoadPoolManager, cache, metaData, utilities, triggerEvent, } from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport { getStackData, requestType, priority, getPromiseRemovedHandler, nearestIndex, range, } from './stackPrefetchUtils';\nimport { Events } from '../../enums';\nconst { imageRetrieveMetadataProvider } = utilities;\nlet configuration = {\n    maxImagesToPrefetch: Infinity,\n    preserveExistingPool: true,\n};\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 10;\nfunction prefetch(element) {\n    const stackPrefetchData = getToolState(element);\n    if (!stackPrefetchData) {\n        return;\n    }\n    const stackPrefetch = (stackPrefetchData || {});\n    const stack = getStackData(element);\n    if (!stack?.imageIds?.length) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    const { currentImageIdIndex } = stack;\n    stackPrefetch.enabled =\n        stackPrefetch.enabled && (stackPrefetch.indicesToRequest?.length ?? 0) > 0;\n    if (stackPrefetch.enabled === false) {\n        return;\n    }\n    function removeFromList(imageIdIndex) {\n        const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n        if (index > -1) {\n            stackPrefetch.indicesToRequest.splice(index, 1);\n        }\n    }\n    stackPrefetchData.indicesToRequest.sort((a, b) => a - b);\n    const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n    indicesToRequestCopy.forEach(function (imageIdIndex) {\n        const imageId = stack.imageIds[imageIdIndex];\n        if (!imageId) {\n            return;\n        }\n        const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n        const imageCached = distance < 6\n            ? cache.getImageLoadObject(imageId)\n            : cache.isLoaded(imageId);\n        if (imageCached) {\n            removeFromList(imageIdIndex);\n        }\n    });\n    if (!stackPrefetch.indicesToRequest.length) {\n        return;\n    }\n    if (!configuration.preserveExistingPool) {\n        imageLoadPoolManager.clearRequestStack(requestType);\n    }\n    const nearest = nearestIndex(stackPrefetch.indicesToRequest, stack.currentImageIdIndex);\n    let imageId;\n    let nextImageIdIndex;\n    const preventCache = false;\n    function doneCallback(imageId) {\n        console.log('prefetch done: %s', imageId);\n        const imageIdIndex = stack.imageIds.indexOf(imageId);\n        removeFromList(imageIdIndex);\n        if (stackPrefetch.indicesToRequest.length === 0) {\n            const eventDetail = {\n                element: element,\n                lastPrefetchedImageId: imageId,\n            };\n            triggerEvent(eventTarget, Events.STACK_PREFETCH_COMPLETE, eventDetail);\n        }\n    }\n    let lowerIndex = nearest.low;\n    let higherIndex = nearest.high;\n    const imageIdsToPrefetch = [];\n    while (lowerIndex >= 0 ||\n        higherIndex < stackPrefetch.indicesToRequest.length) {\n        const currentIndex = stack.currentImageIdIndex;\n        const shouldSkipLower = currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >\n            configuration.maxImagesToPrefetch;\n        const shouldSkipHigher = stackPrefetch.indicesToRequest[higherIndex] - currentIndex >\n            configuration.maxImagesToPrefetch;\n        const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;\n        const shouldLoadHigher = !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;\n        if (!shouldLoadHigher && !shouldLoadLower) {\n            break;\n        }\n        if (shouldLoadLower) {\n            nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];\n            imageId = stack.imageIds[nextImageIdIndex];\n            imageIdsToPrefetch.push(imageId);\n        }\n        if (shouldLoadHigher) {\n            nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];\n            imageId = stack.imageIds[nextImageIdIndex];\n            imageIdsToPrefetch.push(imageId);\n        }\n    }\n    const requestFn = (imageId, options) => {\n        const { retrieveOptions = {} } = metaData.get(imageRetrieveMetadataProvider.IMAGE_RETRIEVE_CONFIGURATION, imageId, 'stack') || {};\n        options.retrieveOptions = {\n            ...options.retrieveOptions,\n            ...(retrieveOptions.default || Object.values(retrieveOptions)?.[0] || {}),\n        };\n        return imageLoader\n            .loadAndCacheImage(imageId, options)\n            .then(() => doneCallback(imageId));\n    };\n    imageIdsToPrefetch.forEach((imageId) => {\n        const options = {\n            requestType,\n        };\n        imageLoadPoolManager.addRequest(requestFn.bind(null, imageId, options), requestType, {\n            imageId,\n        }, priority);\n    });\n}\nfunction onImageUpdated(e) {\n    clearTimeout(resetPrefetchTimeout);\n    resetPrefetchTimeout = setTimeout(function () {\n        const element = e.target;\n        try {\n            prefetch(element);\n        }\n        catch (error) {\n            return;\n        }\n    }, resetPrefetchDelay);\n}\nfunction enable(element) {\n    const stack = getStackData(element);\n    if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    const stackPrefetchData = {\n        indicesToRequest: range(0, stack.imageIds.length - 1),\n        enabled: true,\n        direction: 1,\n    };\n    const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(stack.currentImageIdIndex);\n    stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);\n    addToolState(element, stackPrefetchData);\n    prefetch(element);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    eventTarget.addEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n}\nfunction disable(element) {\n    clearTimeout(resetPrefetchTimeout);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    const stackPrefetchData = getToolState(element);\n    if (stackPrefetchData && stackPrefetchData.indicesToRequest.length) {\n        stackPrefetchData.enabled = false;\n        imageLoadPoolManager.clearRequestStack(requestType);\n    }\n}\nfunction getConfiguration() {\n    return configuration;\n}\nfunction setConfiguration(config) {\n    configuration = config;\n}\nconst stackPrefetch = { enable, disable, getConfiguration, setConfiguration };\nexport default stackPrefetch;\n","function getDeltaPoints(currentPoints, lastPoints) {\n    const curr = getMeanPoints(currentPoints);\n    const last = getMeanPoints(lastPoints);\n    return {\n        page: _subtractPoints2D(curr.page, last.page),\n        client: _subtractPoints2D(curr.client, last.client),\n        canvas: _subtractPoints2D(curr.canvas, last.canvas),\n        world: _subtractPoints3D(curr.world, last.world),\n    };\n}\nfunction getDeltaDistance(currentPoints, lastPoints) {\n    const curr = getMeanPoints(currentPoints);\n    const last = getMeanPoints(lastPoints);\n    return {\n        page: _getDistance2D(curr.page, last.page),\n        client: _getDistance2D(curr.client, last.client),\n        canvas: _getDistance2D(curr.canvas, last.canvas),\n        world: _getDistance3D(curr.world, last.world),\n    };\n}\nfunction getDeltaRotation(currentPoints, lastPoints) {\n}\nfunction getDeltaDistanceBetweenIPoints(currentPoints, lastPoints) {\n    const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\n    const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\n    const deltaDistance = {\n        page: currentDistance.page - lastDistance.page,\n        client: currentDistance.client - lastDistance.client,\n        canvas: currentDistance.canvas - lastDistance.canvas,\n        world: currentDistance.world - lastDistance.world,\n    };\n    return deltaDistance;\n}\nfunction copyPointsList(points) {\n    return JSON.parse(JSON.stringify(points));\n}\nfunction copyPoints(points) {\n    return JSON.parse(JSON.stringify(points));\n}\nfunction getMeanPoints(points) {\n    return points.reduce((prev, curr) => {\n        return {\n            page: [\n                prev.page[0] + curr.page[0] / points.length,\n                prev.page[1] + curr.page[1] / points.length,\n            ],\n            client: [\n                prev.client[0] + curr.client[0] / points.length,\n                prev.client[1] + curr.client[1] / points.length,\n            ],\n            canvas: [\n                prev.canvas[0] + curr.canvas[0] / points.length,\n                prev.canvas[1] + curr.canvas[1] / points.length,\n            ],\n            world: [\n                prev.world[0] + curr.world[0] / points.length,\n                prev.world[1] + curr.world[1] / points.length,\n                prev.world[2] + curr.world[2] / points.length,\n            ],\n        };\n    }, {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n    });\n}\nfunction getMeanTouchPoints(points) {\n    return points.reduce((prev, curr) => {\n        return {\n            page: [\n                prev.page[0] + curr.page[0] / points.length,\n                prev.page[1] + curr.page[1] / points.length,\n            ],\n            client: [\n                prev.client[0] + curr.client[0] / points.length,\n                prev.client[1] + curr.client[1] / points.length,\n            ],\n            canvas: [\n                prev.canvas[0] + curr.canvas[0] / points.length,\n                prev.canvas[1] + curr.canvas[1] / points.length,\n            ],\n            world: [\n                prev.world[0] + curr.world[0] / points.length,\n                prev.world[1] + curr.world[1] / points.length,\n                prev.world[2] + curr.world[2] / points.length,\n            ],\n            touch: {\n                identifier: null,\n                radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\n                radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\n                force: prev.touch.force + curr.touch.force / points.length,\n                rotationAngle: prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\n            },\n        };\n    }, {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n        touch: {\n            identifier: null,\n            radiusX: 0,\n            radiusY: 0,\n            force: 0,\n            rotationAngle: 0,\n        },\n    });\n}\nfunction _subtractPoints2D(point0, point1) {\n    return [point0[0] - point1[0], point0[1] - point1[1]];\n}\nfunction _subtractPoints3D(point0, point1) {\n    return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\nfunction _getMeanDistanceBetweenAllIPoints(points) {\n    const pairedDistance = [];\n    for (let i = 0; i < points.length; i++) {\n        for (let j = 0; j < points.length; j++) {\n            if (i < j) {\n                pairedDistance.push({\n                    page: _getDistance2D(points[i].page, points[j].page),\n                    client: _getDistance2D(points[i].client, points[j].client),\n                    canvas: _getDistance2D(points[i].canvas, points[j].canvas),\n                    world: _getDistance3D(points[i].world, points[j].world),\n                });\n            }\n        }\n    }\n    return pairedDistance.reduce((prev, curr) => {\n        return {\n            page: prev.page + curr.page / pairedDistance.length,\n            client: prev.client + curr.client / pairedDistance.length,\n            canvas: prev.canvas + curr.canvas / pairedDistance.length,\n            world: prev.world + curr.world / pairedDistance.length,\n        };\n    }, {\n        page: 0,\n        client: 0,\n        canvas: 0,\n        world: 0,\n    });\n}\nfunction _getDistance2D(point0, point1) {\n    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2));\n}\nfunction _getDistance3D(point0, point1) {\n    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) +\n        Math.pow(point0[1] - point1[1], 2) +\n        Math.pow(point0[2] - point1[2], 2));\n}\nexport { getMeanPoints, getMeanTouchPoints, copyPoints, copyPointsList, getDeltaDistanceBetweenIPoints, getDeltaPoints, getDeltaDistance, getDeltaRotation, };\n","import { annotationRenderingEngine } from '../stateManagement/annotation/AnnotationRenderingEngine';\nfunction triggerAnnotationRender(element) {\n    annotationRenderingEngine.renderViewport(element);\n}\nexport default triggerAnnotationRender;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getToolGroup } from '../store/ToolGroupManager';\nexport function triggerAnnotationRenderForToolGroupIds(toolGroupIds) {\n    toolGroupIds.forEach((toolGroupId) => {\n        const toolGroup = getToolGroup(toolGroupId);\n        if (!toolGroup) {\n            console.warn(`ToolGroup not available for ${toolGroupId}`);\n            return;\n        }\n        const viewportsInfo = toolGroup.getViewportsInfo();\n        viewportsInfo.forEach((viewportInfo) => {\n            const { renderingEngineId, viewportId } = viewportInfo;\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            if (!renderingEngine) {\n                console.warn(`RenderingEngine not available for ${renderingEngineId}`);\n                return;\n            }\n            const viewport = renderingEngine.getViewport(viewportId);\n            triggerAnnotationRender(viewport.element);\n        });\n    });\n}\nexport default triggerAnnotationRenderForToolGroupIds;\n","import { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nexport function triggerAnnotationRenderForViewportIds(viewportIdsToRender) {\n    if (!viewportIdsToRender.length) {\n        return;\n    }\n    viewportIdsToRender.forEach((viewportId) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            console.warn(`Viewport not available for ${viewportId}`);\n            return;\n        }\n        const { viewport } = enabledElement;\n        if (!viewport) {\n            console.warn(`Viewport not available for ${viewportId}`);\n            return;\n        }\n        const element = viewport.element;\n        triggerAnnotationRender(element);\n    });\n}\nexport default triggerAnnotationRenderForViewportIds;\n","export default function filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID) {\n    const numViewports = viewports.length;\n    const viewportsWithFrameOfReferenceUID = [];\n    for (let vp = 0; vp < numViewports; vp++) {\n        const viewport = viewports[vp];\n        if (viewport.getFrameOfReferenceUID() === FrameOfReferenceUID) {\n            viewportsWithFrameOfReferenceUID.push(viewport);\n        }\n    }\n    return viewportsWithFrameOfReferenceUID;\n}\n","import { vec3 } from 'gl-matrix';\nexport function filterViewportsWithParallelNormals(viewports, camera, EPS = 0.999) {\n    return viewports.filter((viewport) => {\n        const vpCamera = viewport.getCamera();\n        const isParallel = Math.abs(vec3.dot(vpCamera.viewPlaneNormal, camera.viewPlaneNormal)) >\n            EPS;\n        return isParallel;\n    });\n}\nexport default filterViewportsWithParallelNormals;\n","import { ToolModes } from '../../enums';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nconst { Active, Passive, Enabled } = ToolModes;\nexport default function filterViewportsWithToolEnabled(viewports, toolName) {\n    const numViewports = viewports.length;\n    const viewportsWithToolEnabled = [];\n    for (let vp = 0; vp < numViewports; vp++) {\n        const viewport = viewports[vp];\n        const toolGroup = getToolGroupForViewport(viewport.id, viewport.renderingEngineId);\n        if (!toolGroup) {\n            continue;\n        }\n        const hasTool = _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName);\n        if (hasTool) {\n            viewportsWithToolEnabled.push(viewport);\n        }\n    }\n    return viewportsWithToolEnabled;\n}\nfunction _toolGroupHasActiveEnabledOrPassiveTool(toolGroup, toolName) {\n    const { toolOptions } = toolGroup;\n    const tool = toolOptions[toolName];\n    if (!tool) {\n        return false;\n    }\n    const toolMode = tool.mode;\n    return toolMode === Active || toolMode === Passive || toolMode === Enabled;\n}\n","import { vec2 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { isRangeValid, areColorbarRangesEqual } from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\nimport { ColorbarCanvas } from './ColorbarCanvas';\nimport { ColorbarTicks } from './ColorbarTicks';\nimport isRangeTextPositionValid from './common/isRangeTextPositionValid';\nimport Widget from '../../../widgets/Widget';\nconst DEFAULTS = {\n    MULTIPLIER: 1,\n    RANGE_TEXT_POSITION: ColorbarRangeTextPosition.Right,\n    TICKS_BAR_SIZE: 50,\n};\nclass Colorbar extends Widget {\n    constructor(props) {\n        super(props);\n        this._isMouseOver = false;\n        this._isInteracting = false;\n        this._mouseOverCallback = (evt) => {\n            this._isMouseOver = true;\n            this.showTicks();\n            evt.stopPropagation();\n        };\n        this._mouseOutCallback = (evt) => {\n            this._isMouseOver = false;\n            this.hideTicks();\n            evt.stopPropagation();\n        };\n        this._mouseDownCallback = (evt) => {\n            this._isInteracting = true;\n            this.showTicks();\n            this._addVOIEventListeners(evt);\n            evt.stopPropagation();\n        };\n        this._mouseDragCallback = (evt, initialState) => {\n            const multipliers = this.getVOIMultipliers();\n            const currentPoints = this._getPointsFromMouseEvent(evt);\n            const { points: startPoints, voiRange: startVOIRange } = initialState;\n            const canvasDelta = vec2.sub(vec2.create(), currentPoints.local, startPoints.local);\n            const wwDelta = canvasDelta[0] * multipliers[0];\n            const wcDelta = canvasDelta[1] * multipliers[1];\n            if (!wwDelta && !wcDelta) {\n                return;\n            }\n            const { lower: voiLower, upper: voiUpper } = startVOIRange;\n            let { windowWidth, windowCenter } = csUtils.windowLevel.toWindowLevel(voiLower, voiUpper);\n            windowWidth = Math.max(windowWidth + wwDelta, 1);\n            windowCenter += wcDelta;\n            const newVoiRange = csUtils.windowLevel.toLowHighRange(windowWidth, windowCenter);\n            this.voiRange = newVoiRange;\n            evt.stopPropagation();\n            evt.preventDefault();\n        };\n        this._mouseUpCallback = (evt) => {\n            this._isInteracting = false;\n            this.hideTicks();\n            this._removeVOIEventListeners();\n            evt.stopPropagation();\n        };\n        this._eventListenersManager =\n            new csUtils.eventListener.MultiTargetEventListenerManager();\n        this._colormaps = Colorbar.getColormapsMap(props);\n        this._activeColormapName = Colorbar.getInitialColormapName(props);\n        this._canvas = this._createCanvas(props);\n        this._ticksBar = this._createTicksBar(props);\n        this._rangeTextPosition =\n            props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;\n        this._canvas.appendTo(this.rootElement);\n        this._ticksBar.appendTo(this.rootElement);\n        this._addRootElementEventListeners();\n    }\n    get activeColormapName() {\n        return this._activeColormapName;\n    }\n    set activeColormapName(colormapName) {\n        if (colormapName === this._activeColormapName) {\n            return;\n        }\n        const colormap = this._colormaps.get(colormapName);\n        if (!colormap) {\n            console.warn(`Invalid colormap name (${colormapName})`);\n            return;\n        }\n        this._activeColormapName = colormapName;\n        this._canvas.colormap = colormap;\n    }\n    get imageRange() {\n        return this._canvas.imageRange;\n    }\n    set imageRange(imageRange) {\n        this._canvas.imageRange = imageRange;\n        this._ticksBar.imageRange = imageRange;\n    }\n    get voiRange() {\n        return this._canvas.voiRange;\n    }\n    set voiRange(voiRange) {\n        const { voiRange: currentVoiRange } = this._canvas;\n        if (!isRangeValid(voiRange) ||\n            areColorbarRangesEqual(voiRange, currentVoiRange)) {\n            return;\n        }\n        this._canvas.voiRange = voiRange;\n        this._ticksBar.voiRange = voiRange;\n        this.onVoiChange(voiRange);\n    }\n    get showFullImageRange() {\n        return this._canvas.showFullImageRange;\n    }\n    set showFullImageRange(value) {\n        this._canvas.showFullImageRange = value;\n        this._ticksBar.showFullPixelValueRange = value;\n    }\n    destroy() {\n        super.destroy();\n        this._eventListenersManager.reset();\n    }\n    createRootElement() {\n        const rootElement = document.createElement('div');\n        Object.assign(rootElement.style, {\n            position: 'relative',\n            fontSize: '0',\n            width: '100%',\n            height: '100%',\n        });\n        return rootElement;\n    }\n    onContainerResize() {\n        super.onContainerResize();\n        this.updateTicksBar();\n        this._canvas.size = this.containerSize;\n    }\n    getVOIMultipliers() {\n        return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];\n    }\n    onVoiChange(voiRange) {\n    }\n    showTicks() {\n        this.updateTicksBar();\n        this._ticksBar.visible = true;\n    }\n    hideTicks() {\n        if (this._isInteracting || this._isMouseOver) {\n            return;\n        }\n        this._ticksBar.visible = false;\n    }\n    static getColormapsMap(props) {\n        const { colormaps } = props;\n        return colormaps.reduce((items, item) => items.set(item.Name, item), new Map());\n    }\n    static getInitialColormapName(props) {\n        const { activeColormapName, colormaps } = props;\n        const colormapExists = !!activeColormapName &&\n            colormaps.some((cm) => cm.Name === activeColormapName);\n        return colormapExists ? activeColormapName : colormaps[0].Name;\n    }\n    _createCanvas(props) {\n        const { imageRange, voiRange, showFullPixelValueRange } = props;\n        const colormap = this._colormaps.get(this._activeColormapName);\n        return new ColorbarCanvas({\n            colormap,\n            imageRange,\n            voiRange: voiRange,\n            showFullPixelValueRange,\n        });\n    }\n    _createTicksBar(props) {\n        const ticksProps = props.ticks;\n        return new ColorbarTicks({\n            imageRange: props.imageRange,\n            voiRange: props.voiRange,\n            ticks: ticksProps,\n            showFullPixelValueRange: props.showFullPixelValueRange,\n        });\n    }\n    _getPointsFromMouseEvent(evt) {\n        const { rootElement: element } = this;\n        const clientPoint = [evt.clientX, evt.clientY];\n        const pagePoint = [evt.pageX, evt.pageY];\n        const rect = element.getBoundingClientRect();\n        const localPoints = [\n            pagePoint[0] - rect.left - window.pageXOffset,\n            pagePoint[1] - rect.top - window.pageYOffset,\n        ];\n        return { client: clientPoint, page: pagePoint, local: localPoints };\n    }\n    updateTicksBar() {\n        const { width: containerWidth, height: containerHeight } = this.containerSize;\n        if (containerWidth === 0 && containerHeight === 0) {\n            return;\n        }\n        const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;\n        const isHorizontal = containerWidth >= containerHeight;\n        const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;\n        const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;\n        if (!isRangeTextPositionValid(containerWidth, containerHeight, rangeTextPosition)) {\n            throw new Error('Invalid rangeTextPosition value for the current colobar orientation');\n        }\n        let ticksBarTop;\n        let ticksBarLeft;\n        ticksBar.size = { width, height };\n        if (isHorizontal) {\n            ticksBarLeft = 0;\n            ticksBarTop =\n                rangeTextPosition === ColorbarRangeTextPosition.Top\n                    ? -height\n                    : containerHeight;\n        }\n        else {\n            ticksBarTop = 0;\n            ticksBarLeft =\n                rangeTextPosition === ColorbarRangeTextPosition.Left\n                    ? -width\n                    : containerWidth;\n        }\n        ticksBar.top = ticksBarTop;\n        ticksBar.left = ticksBarLeft;\n    }\n    _addRootElementEventListeners() {\n        const { _eventListenersManager: manager } = this;\n        const { rootElement: element } = this;\n        manager.addEventListener(element, 'mouseover', this._mouseOverCallback);\n        manager.addEventListener(element, 'mouseout', this._mouseOutCallback);\n        manager.addEventListener(element, 'mousedown', this._mouseDownCallback);\n    }\n    _addVOIEventListeners(evt) {\n        const { _eventListenersManager: manager } = this;\n        const points = this._getPointsFromMouseEvent(evt);\n        const voiRange = { ...this._canvas.voiRange };\n        const initialDragState = { points, voiRange };\n        this._removeVOIEventListeners();\n        manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);\n        manager.addEventListener(document, 'voi.mousemove', (evt) => this._mouseDragCallback(evt, initialDragState));\n    }\n    _removeVOIEventListeners() {\n        const { _eventListenersManager: manager } = this;\n        manager.removeEventListener(document, 'voi.mouseup');\n        manager.removeEventListener(document, 'voi.mousemove');\n    }\n}\nexport { Colorbar as default, Colorbar };\n","import { eventTarget, VolumeViewport, StackViewport, Enums, utilities, getEnabledElement, cache, } from '@cornerstonejs/core';\nimport { Colorbar } from './Colorbar';\nimport { getVOIMultipliers } from '../../getVOIMultipliers';\nconst { Events } = Enums;\nconst defaultImageRange = { lower: -1000, upper: 1000 };\nclass ViewportColorbar extends Colorbar {\n    constructor(props) {\n        const { element, volumeId } = props;\n        const imageRange = ViewportColorbar._getImageRange(element, volumeId);\n        const voiRange = ViewportColorbar._getVOIRange(element, volumeId);\n        super({ ...props, imageRange, voiRange });\n        this.autoHideTicks = () => {\n            if (this._hideTicksTimeoutId) {\n                return;\n            }\n            const timeLeft = this._hideTicksTime - Date.now();\n            if (timeLeft <= 0) {\n                this.hideTicks();\n            }\n            else {\n                this._hideTicksTimeoutId = window.setTimeout(() => {\n                    this._hideTicksTimeoutId = 0;\n                    this.autoHideTicks();\n                }, timeLeft);\n            }\n        };\n        this._stackNewImageCallback = () => {\n            this.imageRange = ViewportColorbar._getImageRange(this._element);\n        };\n        this._imageVolumeModifiedCallback = (evt) => {\n            const { volumeId } = evt.detail;\n            if (volumeId !== this._volumeId) {\n                return;\n            }\n            const { _element: element } = this;\n            this.imageRange = ViewportColorbar._getImageRange(element, volumeId);\n        };\n        this._viewportVOIModifiedCallback = (evt) => {\n            const { viewportId, volumeId, range: voiRange, colormap } = evt.detail;\n            const { viewport } = this.enabledElement;\n            if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n                return;\n            }\n            this.voiRange = voiRange;\n            if (colormap) {\n                this.activeColormapName = colormap.name;\n            }\n            this.showAndAutoHideTicks();\n        };\n        this._viewportColormapModifiedCallback = (evt) => {\n            const { viewportId, colormap, volumeId } = evt.detail;\n            const { viewport } = this.enabledElement;\n            if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n                return;\n            }\n            this.activeColormapName = colormap.name;\n        };\n        this._element = element;\n        this._volumeId = volumeId;\n        this._addCornerstoneEventListener();\n    }\n    get element() {\n        return this._element;\n    }\n    get enabledElement() {\n        return getEnabledElement(this._element);\n    }\n    getVOIMultipliers() {\n        const { viewport } = this.enabledElement;\n        return getVOIMultipliers(viewport, this._volumeId);\n    }\n    onVoiChange(voiRange) {\n        super.onVoiChange(voiRange);\n        const { viewport } = this.enabledElement;\n        if (viewport instanceof StackViewport) {\n            viewport.setProperties({\n                voiRange: voiRange,\n            });\n            viewport.render();\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const { _volumeId: volumeId } = this;\n            const viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(volumeId);\n            viewport.setProperties({ voiRange }, volumeId);\n            viewportsContainingVolumeUID.forEach((vp) => vp.render());\n        }\n    }\n    static _getImageRange(element, volumeId) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const actor = viewport.getImageActor(volumeId);\n        if (!actor) {\n            return defaultImageRange;\n        }\n        const imageData = actor.getMapper().getInputData();\n        const scalarData = imageData.getPointData().getScalars();\n        let imageRange;\n        if (!scalarData) {\n            if (!volumeId) {\n                throw new Error('volumeId is required when scalarData is not available');\n            }\n            const volume = cache.getVolume(volumeId);\n            const [minValue, maxValue] = volume.voxelManager.getRange();\n            imageRange = [minValue, maxValue];\n        }\n        else {\n            imageRange = scalarData.getRange();\n        }\n        return imageRange[0] === 0 && imageRange[1] === 0\n            ? defaultImageRange\n            : { lower: imageRange[0], upper: imageRange[1] };\n    }\n    static _getVOIRange(element, volumeId) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const actor = viewport.getImageActor(volumeId);\n        if (!actor) {\n            return defaultImageRange;\n        }\n        const voiRange = actor.getProperty().getRGBTransferFunction(0).getRange();\n        return voiRange[0] === 0 && voiRange[1] === 0\n            ? defaultImageRange\n            : { lower: voiRange[0], upper: voiRange[1] };\n    }\n    showAndAutoHideTicks(interval = 1000) {\n        this._hideTicksTime = Date.now() + interval;\n        this.showTicks();\n        this.autoHideTicks();\n    }\n    _addCornerstoneEventListener() {\n        const { _element: element } = this;\n        eventTarget.addEventListener(Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedCallback);\n        element.addEventListener(Events.STACK_NEW_IMAGE, this._stackNewImageCallback);\n        element.addEventListener(Events.VOI_MODIFIED, this._viewportVOIModifiedCallback);\n        element.addEventListener(Events.COLORMAP_MODIFIED, this._viewportColormapModifiedCallback);\n    }\n    destroy() {\n        super.destroy();\n        const { _element: element } = this;\n        eventTarget.removeEventListener(Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedCallback);\n        element.removeEventListener(Events.STACK_NEW_IMAGE, this._stackNewImageCallback);\n        element.removeEventListener(Events.VOI_MODIFIED, this._viewportVOIModifiedCallback);\n        element.removeEventListener(Events.COLORMAP_MODIFIED, this._viewportColormapModifiedCallback);\n    }\n}\nexport { ViewportColorbar as default, ViewportColorbar };\n","export var ColorbarRangeTextPosition;\n(function (ColorbarRangeTextPosition) {\n    ColorbarRangeTextPosition[\"Top\"] = \"top\";\n    ColorbarRangeTextPosition[\"Left\"] = \"left\";\n    ColorbarRangeTextPosition[\"Bottom\"] = \"bottom\";\n    ColorbarRangeTextPosition[\"Right\"] = \"right\";\n})(ColorbarRangeTextPosition || (ColorbarRangeTextPosition = {}));\n","function calculateMinMaxMean(pixelLuminance, globalMin, globalMax) {\n    const numPixels = pixelLuminance.length;\n    let min = globalMax;\n    let max = globalMin;\n    let sum = 0;\n    if (numPixels < 2) {\n        return {\n            min,\n            max,\n            mean: (globalMin + globalMax) / 2,\n        };\n    }\n    for (let index = 0; index < numPixels; index++) {\n        const spv = pixelLuminance[index];\n        min = Math.min(min, spv);\n        max = Math.max(max, spv);\n        sum += spv;\n    }\n    return {\n        min,\n        max,\n        mean: sum / numPixels,\n    };\n}\nexport { calculateMinMaxMean };\n","import { utilities as csUtils, StackViewport, VolumeViewport, } from '@cornerstonejs/core';\nfunction extractWindowLevelRegionToolData(viewport) {\n    if (viewport instanceof VolumeViewport) {\n        return extractImageDataVolume(viewport);\n    }\n    if (viewport instanceof StackViewport) {\n        return extractImageDataStack(viewport);\n    }\n    throw new Error('Viewport not supported');\n}\nfunction extractImageDataVolume(viewport) {\n    const { scalarData, width, height } = csUtils.getCurrentVolumeViewportSlice(viewport);\n    const { min: minPixelValue, max: maxPixelValue } = csUtils.getMinMax(scalarData);\n    return {\n        scalarData,\n        minPixelValue,\n        maxPixelValue,\n        width,\n        height,\n        rows: width,\n        columns: height,\n    };\n}\nfunction extractImageDataStack(viewport) {\n    const imageData = viewport.getImageData();\n    const { scalarData } = imageData;\n    const { min: minPixelValue, max: maxPixelValue } = csUtils.getMinMax(scalarData);\n    const width = imageData.dimensions[0];\n    const height = imageData.dimensions[1];\n    const { rows, columns, color } = viewport.getCornerstoneImage();\n    return {\n        scalarData,\n        width,\n        height,\n        minPixelValue,\n        maxPixelValue,\n        rows,\n        columns,\n        color,\n    };\n}\nexport { extractWindowLevelRegionToolData };\n","function getLuminanceFromRegion(imageData, x, y, width, height) {\n    const luminance = [];\n    let index = 0;\n    const pixelData = imageData.scalarData;\n    let spIndex, row, column;\n    if (imageData.color) {\n        for (row = 0; row < height; row++) {\n            for (column = 0; column < width; column++) {\n                spIndex = ((row + y) * imageData.columns + (column + x)) * 4;\n                const red = pixelData[spIndex];\n                const green = pixelData[spIndex + 1];\n                const blue = pixelData[spIndex + 2];\n                luminance[index++] = 0.2126 * red + 0.7152 * green + 0.0722 * blue;\n            }\n        }\n    }\n    else {\n        for (row = 0; row < height; row++) {\n            for (column = 0; column < width; column++) {\n                spIndex = (row + y) * imageData.columns + (column + x);\n                luminance[index++] = pixelData[spIndex];\n            }\n        }\n    }\n    return luminance;\n}\nexport { getLuminanceFromRegion };\n","export const version = '4.11.3';\n","/**\n * lodash (Custom Build) <https://lodash.com/>\n * Build: `lodash modularize exports=\"npm\" -o ./`\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\n * Released under MIT license <https://lodash.com/license>\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n */\n\n/** Used as the `TypeError` message for \"Functions\" methods. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/** Used to stand-in for `undefined` hash values. */\nvar HASH_UNDEFINED = '__lodash_hash_undefined__';\n\n/** Used as references for various `Number` constants. */\nvar INFINITY = 1 / 0;\n\n/** `Object#toString` result references. */\nvar funcTag = '[object Function]',\n    genTag = '[object GeneratorFunction]',\n    symbolTag = '[object Symbol]';\n\n/** Used to match property names within property paths. */\nvar reIsDeepProp = /\\.|\\[(?:[^[\\]]*|([\"'])(?:(?!\\1)[^\\\\]|\\\\.)*?\\1)\\]/,\n    reIsPlainProp = /^\\w*$/,\n    reLeadingDot = /^\\./,\n    rePropName = /[^.[\\]]+|\\[(?:(-?\\d+(?:\\.\\d+)?)|([\"'])((?:(?!\\2)[^\\\\]|\\\\.)*?)\\2)\\]|(?=(?:\\.|\\[\\])(?:\\.|\\[\\]|$))/g;\n\n/**\n * Used to match `RegExp`\n * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).\n */\nvar reRegExpChar = /[\\\\^$.*+?()[\\]{}|]/g;\n\n/** Used to match backslashes in property paths. */\nvar reEscapeChar = /\\\\(\\\\)?/g;\n\n/** Used to detect host constructors (Safari). */\nvar reIsHostCtor = /^\\[object .+?Constructor\\]$/;\n\n/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\n/**\n * Gets the value at `key` of `object`.\n *\n * @private\n * @param {Object} [object] The object to query.\n * @param {string} key The key of the property to get.\n * @returns {*} Returns the property value.\n */\nfunction getValue(object, key) {\n  return object == null ? undefined : object[key];\n}\n\n/**\n * Checks if `value` is a host object in IE < 9.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\n */\nfunction isHostObject(value) {\n  // Many host objects are `Object` objects that can coerce to strings\n  // despite having improperly defined `toString` methods.\n  var result = false;\n  if (value != null && typeof value.toString != 'function') {\n    try {\n      result = !!(value + '');\n    } catch (e) {}\n  }\n  return result;\n}\n\n/** Used for built-in method references. */\nvar arrayProto = Array.prototype,\n    funcProto = Function.prototype,\n    objectProto = Object.prototype;\n\n/** Used to detect overreaching core-js shims. */\nvar coreJsData = root['__core-js_shared__'];\n\n/** Used to detect methods masquerading as native. */\nvar maskSrcKey = (function() {\n  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');\n  return uid ? ('Symbol(src)_1.' + uid) : '';\n}());\n\n/** Used to resolve the decompiled source of functions. */\nvar funcToString = funcProto.toString;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar objectToString = objectProto.toString;\n\n/** Used to detect if a method is native. */\nvar reIsNative = RegExp('^' +\n  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\\\$&')\n  .replace(/hasOwnProperty|(function).*?(?=\\\\\\()| for .+?(?=\\\\\\])/g, '$1.*?') + '$'\n);\n\n/** Built-in value references. */\nvar Symbol = root.Symbol,\n    splice = arrayProto.splice;\n\n/* Built-in method references that are verified to be native. */\nvar Map = getNative(root, 'Map'),\n    nativeCreate = getNative(Object, 'create');\n\n/** Used to convert symbols to primitives and strings. */\nvar symbolProto = Symbol ? Symbol.prototype : undefined,\n    symbolToString = symbolProto ? symbolProto.toString : undefined;\n\n/**\n * Creates a hash object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction Hash(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the hash.\n *\n * @private\n * @name clear\n * @memberOf Hash\n */\nfunction hashClear() {\n  this.__data__ = nativeCreate ? nativeCreate(null) : {};\n}\n\n/**\n * Removes `key` and its value from the hash.\n *\n * @private\n * @name delete\n * @memberOf Hash\n * @param {Object} hash The hash to modify.\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction hashDelete(key) {\n  return this.has(key) && delete this.__data__[key];\n}\n\n/**\n * Gets the hash value for `key`.\n *\n * @private\n * @name get\n * @memberOf Hash\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction hashGet(key) {\n  var data = this.__data__;\n  if (nativeCreate) {\n    var result = data[key];\n    return result === HASH_UNDEFINED ? undefined : result;\n  }\n  return hasOwnProperty.call(data, key) ? data[key] : undefined;\n}\n\n/**\n * Checks if a hash value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf Hash\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction hashHas(key) {\n  var data = this.__data__;\n  return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);\n}\n\n/**\n * Sets the hash `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf Hash\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the hash instance.\n */\nfunction hashSet(key, value) {\n  var data = this.__data__;\n  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;\n  return this;\n}\n\n// Add methods to `Hash`.\nHash.prototype.clear = hashClear;\nHash.prototype['delete'] = hashDelete;\nHash.prototype.get = hashGet;\nHash.prototype.has = hashHas;\nHash.prototype.set = hashSet;\n\n/**\n * Creates an list cache object.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction ListCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the list cache.\n *\n * @private\n * @name clear\n * @memberOf ListCache\n */\nfunction listCacheClear() {\n  this.__data__ = [];\n}\n\n/**\n * Removes `key` and its value from the list cache.\n *\n * @private\n * @name delete\n * @memberOf ListCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction listCacheDelete(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    return false;\n  }\n  var lastIndex = data.length - 1;\n  if (index == lastIndex) {\n    data.pop();\n  } else {\n    splice.call(data, index, 1);\n  }\n  return true;\n}\n\n/**\n * Gets the list cache value for `key`.\n *\n * @private\n * @name get\n * @memberOf ListCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction listCacheGet(key) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  return index < 0 ? undefined : data[index][1];\n}\n\n/**\n * Checks if a list cache value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf ListCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction listCacheHas(key) {\n  return assocIndexOf(this.__data__, key) > -1;\n}\n\n/**\n * Sets the list cache `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf ListCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the list cache instance.\n */\nfunction listCacheSet(key, value) {\n  var data = this.__data__,\n      index = assocIndexOf(data, key);\n\n  if (index < 0) {\n    data.push([key, value]);\n  } else {\n    data[index][1] = value;\n  }\n  return this;\n}\n\n// Add methods to `ListCache`.\nListCache.prototype.clear = listCacheClear;\nListCache.prototype['delete'] = listCacheDelete;\nListCache.prototype.get = listCacheGet;\nListCache.prototype.has = listCacheHas;\nListCache.prototype.set = listCacheSet;\n\n/**\n * Creates a map cache object to store key-value pairs.\n *\n * @private\n * @constructor\n * @param {Array} [entries] The key-value pairs to cache.\n */\nfunction MapCache(entries) {\n  var index = -1,\n      length = entries ? entries.length : 0;\n\n  this.clear();\n  while (++index < length) {\n    var entry = entries[index];\n    this.set(entry[0], entry[1]);\n  }\n}\n\n/**\n * Removes all key-value entries from the map.\n *\n * @private\n * @name clear\n * @memberOf MapCache\n */\nfunction mapCacheClear() {\n  this.__data__ = {\n    'hash': new Hash,\n    'map': new (Map || ListCache),\n    'string': new Hash\n  };\n}\n\n/**\n * Removes `key` and its value from the map.\n *\n * @private\n * @name delete\n * @memberOf MapCache\n * @param {string} key The key of the value to remove.\n * @returns {boolean} Returns `true` if the entry was removed, else `false`.\n */\nfunction mapCacheDelete(key) {\n  return getMapData(this, key)['delete'](key);\n}\n\n/**\n * Gets the map value for `key`.\n *\n * @private\n * @name get\n * @memberOf MapCache\n * @param {string} key The key of the value to get.\n * @returns {*} Returns the entry value.\n */\nfunction mapCacheGet(key) {\n  return getMapData(this, key).get(key);\n}\n\n/**\n * Checks if a map value for `key` exists.\n *\n * @private\n * @name has\n * @memberOf MapCache\n * @param {string} key The key of the entry to check.\n * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.\n */\nfunction mapCacheHas(key) {\n  return getMapData(this, key).has(key);\n}\n\n/**\n * Sets the map `key` to `value`.\n *\n * @private\n * @name set\n * @memberOf MapCache\n * @param {string} key The key of the value to set.\n * @param {*} value The value to set.\n * @returns {Object} Returns the map cache instance.\n */\nfunction mapCacheSet(key, value) {\n  getMapData(this, key).set(key, value);\n  return this;\n}\n\n// Add methods to `MapCache`.\nMapCache.prototype.clear = mapCacheClear;\nMapCache.prototype['delete'] = mapCacheDelete;\nMapCache.prototype.get = mapCacheGet;\nMapCache.prototype.has = mapCacheHas;\nMapCache.prototype.set = mapCacheSet;\n\n/**\n * Gets the index at which the `key` is found in `array` of key-value pairs.\n *\n * @private\n * @param {Array} array The array to inspect.\n * @param {*} key The key to search for.\n * @returns {number} Returns the index of the matched value, else `-1`.\n */\nfunction assocIndexOf(array, key) {\n  var length = array.length;\n  while (length--) {\n    if (eq(array[length][0], key)) {\n      return length;\n    }\n  }\n  return -1;\n}\n\n/**\n * The base implementation of `_.get` without support for default values.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @returns {*} Returns the resolved value.\n */\nfunction baseGet(object, path) {\n  path = isKey(path, object) ? [path] : castPath(path);\n\n  var index = 0,\n      length = path.length;\n\n  while (object != null && index < length) {\n    object = object[toKey(path[index++])];\n  }\n  return (index && index == length) ? object : undefined;\n}\n\n/**\n * The base implementation of `_.isNative` without bad shim checks.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a native function,\n *  else `false`.\n */\nfunction baseIsNative(value) {\n  if (!isObject(value) || isMasked(value)) {\n    return false;\n  }\n  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;\n  return pattern.test(toSource(value));\n}\n\n/**\n * The base implementation of `_.toString` which doesn't convert nullish\n * values to empty strings.\n *\n * @private\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n */\nfunction baseToString(value) {\n  // Exit early for strings to avoid a performance hit in some environments.\n  if (typeof value == 'string') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return symbolToString ? symbolToString.call(value) : '';\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Casts `value` to a path array if it's not one.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {Array} Returns the cast property path array.\n */\nfunction castPath(value) {\n  return isArray(value) ? value : stringToPath(value);\n}\n\n/**\n * Gets the data for `map`.\n *\n * @private\n * @param {Object} map The map to query.\n * @param {string} key The reference key.\n * @returns {*} Returns the map data.\n */\nfunction getMapData(map, key) {\n  var data = map.__data__;\n  return isKeyable(key)\n    ? data[typeof key == 'string' ? 'string' : 'hash']\n    : data.map;\n}\n\n/**\n * Gets the native function at `key` of `object`.\n *\n * @private\n * @param {Object} object The object to query.\n * @param {string} key The key of the method to get.\n * @returns {*} Returns the function if it's native, else `undefined`.\n */\nfunction getNative(object, key) {\n  var value = getValue(object, key);\n  return baseIsNative(value) ? value : undefined;\n}\n\n/**\n * Checks if `value` is a property name and not a property path.\n *\n * @private\n * @param {*} value The value to check.\n * @param {Object} [object] The object to query keys on.\n * @returns {boolean} Returns `true` if `value` is a property name, else `false`.\n */\nfunction isKey(value, object) {\n  if (isArray(value)) {\n    return false;\n  }\n  var type = typeof value;\n  if (type == 'number' || type == 'symbol' || type == 'boolean' ||\n      value == null || isSymbol(value)) {\n    return true;\n  }\n  return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||\n    (object != null && value in Object(object));\n}\n\n/**\n * Checks if `value` is suitable for use as unique object key.\n *\n * @private\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is suitable, else `false`.\n */\nfunction isKeyable(value) {\n  var type = typeof value;\n  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')\n    ? (value !== '__proto__')\n    : (value === null);\n}\n\n/**\n * Checks if `func` has its source masked.\n *\n * @private\n * @param {Function} func The function to check.\n * @returns {boolean} Returns `true` if `func` is masked, else `false`.\n */\nfunction isMasked(func) {\n  return !!maskSrcKey && (maskSrcKey in func);\n}\n\n/**\n * Converts `string` to a property path array.\n *\n * @private\n * @param {string} string The string to convert.\n * @returns {Array} Returns the property path array.\n */\nvar stringToPath = memoize(function(string) {\n  string = toString(string);\n\n  var result = [];\n  if (reLeadingDot.test(string)) {\n    result.push('');\n  }\n  string.replace(rePropName, function(match, number, quote, string) {\n    result.push(quote ? string.replace(reEscapeChar, '$1') : (number || match));\n  });\n  return result;\n});\n\n/**\n * Converts `value` to a string key if it's not a string or symbol.\n *\n * @private\n * @param {*} value The value to inspect.\n * @returns {string|symbol} Returns the key.\n */\nfunction toKey(value) {\n  if (typeof value == 'string' || isSymbol(value)) {\n    return value;\n  }\n  var result = (value + '');\n  return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;\n}\n\n/**\n * Converts `func` to its source code.\n *\n * @private\n * @param {Function} func The function to process.\n * @returns {string} Returns the source code.\n */\nfunction toSource(func) {\n  if (func != null) {\n    try {\n      return funcToString.call(func);\n    } catch (e) {}\n    try {\n      return (func + '');\n    } catch (e) {}\n  }\n  return '';\n}\n\n/**\n * Creates a function that memoizes the result of `func`. If `resolver` is\n * provided, it determines the cache key for storing the result based on the\n * arguments provided to the memoized function. By default, the first argument\n * provided to the memoized function is used as the map cache key. The `func`\n * is invoked with the `this` binding of the memoized function.\n *\n * **Note:** The cache is exposed as the `cache` property on the memoized\n * function. Its creation may be customized by replacing the `_.memoize.Cache`\n * constructor with one whose instances implement the\n * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)\n * method interface of `delete`, `get`, `has`, and `set`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to have its output memoized.\n * @param {Function} [resolver] The function to resolve the cache key.\n * @returns {Function} Returns the new memoized function.\n * @example\n *\n * var object = { 'a': 1, 'b': 2 };\n * var other = { 'c': 3, 'd': 4 };\n *\n * var values = _.memoize(_.values);\n * values(object);\n * // => [1, 2]\n *\n * values(other);\n * // => [3, 4]\n *\n * object.a = 2;\n * values(object);\n * // => [1, 2]\n *\n * // Modify the result cache.\n * values.cache.set(object, ['a', 'b']);\n * values(object);\n * // => ['a', 'b']\n *\n * // Replace `_.memoize.Cache`.\n * _.memoize.Cache = WeakMap;\n */\nfunction memoize(func, resolver) {\n  if (typeof func != 'function' || (resolver && typeof resolver != 'function')) {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  var memoized = function() {\n    var args = arguments,\n        key = resolver ? resolver.apply(this, args) : args[0],\n        cache = memoized.cache;\n\n    if (cache.has(key)) {\n      return cache.get(key);\n    }\n    var result = func.apply(this, args);\n    memoized.cache = cache.set(key, result);\n    return result;\n  };\n  memoized.cache = new (memoize.Cache || MapCache);\n  return memoized;\n}\n\n// Assign cache to `_.memoize`.\nmemoize.Cache = MapCache;\n\n/**\n * Performs a\n * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)\n * comparison between two values to determine if they are equivalent.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to compare.\n * @param {*} other The other value to compare.\n * @returns {boolean} Returns `true` if the values are equivalent, else `false`.\n * @example\n *\n * var object = { 'a': 1 };\n * var other = { 'a': 1 };\n *\n * _.eq(object, object);\n * // => true\n *\n * _.eq(object, other);\n * // => false\n *\n * _.eq('a', 'a');\n * // => true\n *\n * _.eq('a', Object('a'));\n * // => false\n *\n * _.eq(NaN, NaN);\n * // => true\n */\nfunction eq(value, other) {\n  return value === other || (value !== value && other !== other);\n}\n\n/**\n * Checks if `value` is classified as an `Array` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an array, else `false`.\n * @example\n *\n * _.isArray([1, 2, 3]);\n * // => true\n *\n * _.isArray(document.body.children);\n * // => false\n *\n * _.isArray('abc');\n * // => false\n *\n * _.isArray(_.noop);\n * // => false\n */\nvar isArray = Array.isArray;\n\n/**\n * Checks if `value` is classified as a `Function` object.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a function, else `false`.\n * @example\n *\n * _.isFunction(_);\n * // => true\n *\n * _.isFunction(/abc/);\n * // => false\n */\nfunction isFunction(value) {\n  // The use of `Object#toString` avoids issues with the `typeof` operator\n  // in Safari 8-9 which returns 'object' for typed array and other constructors.\n  var tag = isObject(value) ? objectToString.call(value) : '';\n  return tag == funcTag || tag == genTag;\n}\n\n/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return !!value && (type == 'object' || type == 'function');\n}\n\n/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return !!value && typeof value == 'object';\n}\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && objectToString.call(value) == symbolTag);\n}\n\n/**\n * Converts `value` to a string. An empty string is returned for `null`\n * and `undefined` values. The sign of `-0` is preserved.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {string} Returns the string.\n * @example\n *\n * _.toString(null);\n * // => ''\n *\n * _.toString(-0);\n * // => '-0'\n *\n * _.toString([1, 2, 3]);\n * // => '1,2,3'\n */\nfunction toString(value) {\n  return value == null ? '' : baseToString(value);\n}\n\n/**\n * Gets the value at `path` of `object`. If the resolved value is\n * `undefined`, the `defaultValue` is returned in its place.\n *\n * @static\n * @memberOf _\n * @since 3.7.0\n * @category Object\n * @param {Object} object The object to query.\n * @param {Array|string} path The path of the property to get.\n * @param {*} [defaultValue] The value returned for `undefined` resolved values.\n * @returns {*} Returns the resolved value.\n * @example\n *\n * var object = { 'a': [{ 'b': { 'c': 3 } }] };\n *\n * _.get(object, 'a[0].b.c');\n * // => 3\n *\n * _.get(object, ['a', '0', 'b', 'c']);\n * // => 3\n *\n * _.get(object, 'a.b.c', 'default');\n * // => 'default'\n */\nfunction get(object, path, defaultValue) {\n  var result = object == null ? undefined : baseGet(object, path);\n  return result === undefined ? defaultValue : result;\n}\n\nmodule.exports = get;\n"],"names":["config","getConfig","setConfig","newConfig","polysegInitialized","getPolySeg","addons","polySeg","console","warn","polyseg","init","DEFINED_CURSORS","Symbol","STANDARD_CURSORS","Set","MouseCursor","constructor","name","fallback","this","getName","addFallbackStyleProperty","style","getStyleProperty","getDefinedCursor","definedCursors","getDefinedCursors","mouseCursor","get","has","set","setDefinedCursor","cursor","context","symbol","Map","Object","defineProperty","value","standardCursorNames","values","ELEMENT_CURSORS_MAP","initElementCursor","element","_getElementCursors","_setElementCursor","cursors","resetElementCursor","hideElementCursor","map","WeakMap","ImageMouseCursor","url","x","y","super","getUniqueInstanceName","Number","prefix","utilities","BASE","iconContent","iconSize","viewBox","mousePoint","mousePointerGroupString","SEGMENTATION_CURSOR_BOUNDARIES","MINUS_RECT","PLUS_RECT","SCISSOR_ICON","RECTANGLE_ICON","CIRCLE_ICON","CursorSVG","Angle","extend","ArrowAnnotate","Bidirectional","CobbAngle","CircleROI","EllipticalROI","FreehandROI","FreehandROISculptor","Length","Height","Probe","RectangleROI","Label","Crosshairs","Eraser","Magnify","Pan","Rotate","StackScroll","WindowLevelRegion","WindowLevel","Zoom","SegmentationFreeHandEraseInside","SegmentationFreeHandFillInside","SegmentationFreeHandEraseOutside","SegmentationFreeHandFillOutside","SegmentationRectangleEraseInside","RectangleScissor","CircleScissor","base","assign","create","registerCursor","toolName","svgCursorNames","keys","STATE","AnnotationStyleStates","Highlighted","MODE","ToolModes","Active","SVGMouseCursor","pointer","color","urn","type","getCursorURN","pointerStrokeWidth","descriptor","getDefinedSVGCursorDescriptor","options","blob","svgString","createSVGIconWithPointer","createSVGIcon","Blob","createSVGIconBlob","URL","createObjectURL","createSVGIconUrl","createSVGMouseCursor","format","template","dictionary","dict","defined","prototype","hasOwnProperty","bind","replace","match","key","scale","Math","max","svgSize","cursorName","log","setElementCursor","CursorNames","svgDrawingHelper","annotationUID","ellipseUID","corner1","corner2","dataId","top","bottom","left","right","canvasCoordinates","width","lineWidth","lineDash","undefined","strokeWidth","svgNodeHash","existingEllipse","getSvgNode","w","hypot","h","angle","atan2","PI","center","attributes","cx","cy","rx","ry","stroke","fill","transform","setNodeTouched","svgEllipseElement","document","createElementNS","setAttribute","appendNode","handleGroupUID","handle","uniqueIndex","handleRadius","opacity","r","Error","side","parseFloat","height","existingHandleElement","newHandleElement","drawLine","lineUID","start","end","isNaN","markerStartId","markerEndId","shadow","strokeOpacity","textBoxLinkLineColor","existingLine","layerId","svgLayerElement","id","dropShadowStyle","x1","y1","x2","y2","newLine","drawPath","pathUID","points","pointsArrays","length","Array","isArray","fillColor","fillOpacity","closePath","existingNode","pointsAttribute","i","numArrays","numPoints","j","point","toFixed","d","newNode","drawPolyline","polylineUID","existingPolyLine","firstPoint","newPolyLine","drawRectByCoordinates","rectangleUID","_width","existingRect","topLeft","topRight","bottomLeft","bottomRight","leftEdgeCenter","svgRectElement","_createTextSpan","text","textSpanElement","textContent","_drawTextBackground","group","backgroundStyles","textBoxBorderRadius","textBoxMargin","querySelector","textElement","getBBox","removeChild","insertBefore","firstChild","bBox","from","querySelectorAll","forEach","tspan","textUID","textLines","position","padding","fontFamily","fontSize","background","textGroupBoundingBox","svgns","existingTextGroup","textSpans","children","textSpan","appendChild","textAttributes","textGroupAttributes","textGroup","noSelectStyle","combinedStyle","_createTextElement","_drawTextGroup","centerX","centerY","drawHeight","heightUID","midX","endfirstLine","endsecondLine","firstLine","secondLine","threeLine","fanUID","innerRadius","outerRadius","startAngle","endAngle","zIndex","_getHash","existingFanElement","startRad","endRad","outerStartX","cos","outerStartY","sin","outerEndX","outerEndY","innerStartX","innerStartY","largeArcFlag","pathData","setAttributesIfNecessary","newFanElement","toString","setNewAttributesIfValid","drawArrow","arrowUID","viaMarker","markerSize","headLength","legacyDrawArrow","markerFullId","defs","arrowMarker","arrowPath","drawRedactionRect","tlhc","min","abs","svgNode","currentValue","getAttribute","newValue","removeAttribute","enable","eventTarget","addEventListener","ANNOTATION_COMPLETED","handleAnnotationCompleted","ANNOTATION_MODIFIED","handleAnnotationUpdate","ANNOTATION_REMOVED","handleAnnotationDelete","disable","removeEventListener","Passive","Enabled","onCameraModified","evt","tool","Enums","CAMERA_MODIFIED","onCameraReset","onResetCamera","CAMERA_RESET","onImageRendered","detail","IMAGE_RENDERED","onImageSpacingCalibrated","IMAGE_SPACING_CALIBRATED","KEY_DOWN","KEY_UP","MOUSE_CLICK","MOUSE_DOWN","MOUSE_DOWN_ACTIVATE","MOUSE_DOUBLE_CLICK","MOUSE_DRAG","MOUSE_MOVE","MOUSE_UP","MOUSE_WHEEL","TOUCH_START","TOUCH_START_ACTIVATE","TOUCH_DRAG","TOUCH_END","TOUCH_TAP","TOUCH_PRESS","mouseDoubleClickListener","mouseDownListener","mouseMoveListener","capture","preventGhostClick","touchStartListener","passive","wheelListener","segmentationId","modifiedSlicesToUse","representationData","getSegmentation","viewportIds","getViewportIdsWithSegmentation","hasVolumeViewport","some","viewportId","viewport","getEnabledElementByViewportId","VolumeViewport","hasStackViewport","StackViewport","hasBothStackAndVolume","segmentationVolume","cache","getVolume","volumeId","imageData","vtkOpenGLTexture","slicesToUpdate","numSlices","getDimensions","setUpdatedFrame","modified","performVolumeLabelmapUpdate","SegmentationRepresentations","Labelmap","representations","getSegmentationRepresentation","filter","representation","enabledElement","actorEntries","actorEntry","segImageData","actor","getMapper","getInputData","currentSegmentationImageIds","segmentationImage","getImage","performStackLabelmapUpdate","_imageChangeEventListener","eventData","renderingEngineId","getEnabledElementByIds","labelmapRepresentations","actors","getActors","updateLabelmapSegmentationImageReferences","labelmapActors","flatMap","find","derivedImageIds","includes","referencedId","removeActors","uid","currentImageId","getCurrentImageId","shouldTriggerSegmentationRender","derivedImageId","derivedImage","segmentationActorInput","dimensions","spacing","direction","getImageDataMetadata","currentImage","imageId","origin","currentOrigin","originToUse","voxelManager","getConstructor","newPixelData","getScalarData","scalarArray","numberOfComponents","setDimensions","setSpacing","setDirection","setOrigin","getPointData","setScalars","addImages","representationUID","callback","imageActor","setInputData","segmentationImageData","setDerivedImage","render","getEnabledElement","BaseVolumeViewport","PRE_STACK_NEW_IMAGE","async","contourSegmentationCompletedListener","sourceAnnotation","annotation","isContourSegmentationAnnotation","viewports","getViewportsForAnnotation","viewportWithToolRegistered","silent","toolGroup","getToolGroupForViewport","errorMessage","hasTool","getToolOptions","isFreehandContourSegToolRegisteredForViewport","getViewport","contourSegmentationAnnotations","sourceAnnotationUID","getAllAnnotations","targetAnnotation","areSameSegment","isReferenceViewable","metadata","getValidContourSegmentationAnnotations","triggerEvent","Events","ANNOTATION_CUT_MERGE_PROCESS_COMPLETED","sourcePolyline","data","contour","polyline","intersectingContours","targetPolyline","isContourHole","contourHoleProcessingEnabled","annotationCompletedListener","removed","getRenderingEngines","renderingEngine","getViewports","vp","triggerAnnotationRenderForViewportIds","t","annotationRemovedListener","removeContourSegmentationAnnotation","segmentation","removeAnnotation","csToolsInitialized","defaultConfiguration","_removeCornerstoneEventListeners","elementEnabledEvent","ELEMENT_ENABLED","elementDisabledEvent","ELEMENT_DISABLED","addEnabledElement","removeEnabledElement","_addCornerstoneEventListeners","_removeCornerstoneToolsEventListeners","ANNOTATION_SELECTION_CHANGE","SEGMENTATION_MODIFIED","SEGMENTATION_DATA_MODIFIED","SEGMENTATION_REPRESENTATION_MODIFIED","SEGMENTATION_REPRESENTATION_ADDED","SEGMENTATION_REMOVED","destroy","annotationManager","getAnnotationManager","segmentationStateManager","restoreAnnotations","resetState","annotationRenderingEngine","_needsRender","_animationFrameSet","_animationFrameHandle","_renderFlaggedViewports","_throwIfDestroyed","elements","_viewportElements","_triggerRender","delete","size","_render","addViewportElement","removeViewportElement","_reset","renderViewport","_setViewportsToBeRenderedNextFrame","hasBeenDestroyed","_setAllViewportsToBeRenderedNextFrame","add","elementsEnabled","indexOf","window","requestAnimationFrame","getRenderingEngine","enabledTools","eventDetail","draw","anyRendered","renderAnnotation","rendered","ANNOTATION_RENDERED","cancelAnimationFrame","clear","FrameOfReferenceSpecificAnnotationManager","getGroupKey","annotationGroupSelector","FrameOfReferenceUID","_imageVolumeModifiedHandler","frameOfReferenceSpecificAnnotations","annotations","invalidated","getFramesOfReference","getAnnotations","groupKey","getAnnotation","frameOfReferenceUID","frameOfReferenceAnnotations","toolSpecificAnnotations","getNumberOfAnnotations","total","addAnnotation","preprocessingFn","push","groupAnnotations","toolAnnotations","index","findIndex","splice","removeAnnotations","removedAnnotations","annotationsForTool","saveAnnotations","structuredClone","state","flat","getNumberOfAllAnnotations","count","removeAllAnnotations","IMAGE_VOLUME_MODIFIED","setPreprocessingFn","defaultFrameOfReferenceSpecificAnnotationManager","globalLockedAnnotationUIDsSet","setAnnotationLocked","locked","makeEventDetail","lockedAnnotationUIDsSet","added","isLocked","lock","unlock","publish","unlockAllAnnotations","clearLockedAnnotationsSet","getAnnotationsLocked","isAnnotationLocked","getAnnotationsLockedCount","checkAndSetAnnotationLocked","freeze","item","ANNOTATION_LOCK_CHANGE","selectedAnnotationUIDs","setAnnotationSelected","selected","preserveSelected","clearSelectionSet","isSelected","selectAnnotation","deselectAnnotation","getAnnotationsSelected","getAnnotationsSelectedByToolName","isAnnotationSelected","getAnnotationsSelectedCount","selection","selectionSet","defaultManager","setAnnotationManager","manager","clearParentAnnotation","childUID","parentAnnotationUID","parentAnnotation","childUIDIndex","childAnnotationUIDs","addChildAnnotation","childAnnotation","parentUID","getParentAnnotation","getChildAnnotations","childAnnotationUID","HTMLDivElement","triggerAnnotationAddedForElement","triggerAnnotationAddedForFOR","triggerAnnotationRemoved","annotationManagerUID","invalidateAnnotation","currAnnotation","globalHiddenAnnotationUIDsSet","setAnnotationVisibility","visible","show","annotationUIDsSet","lastHidden","isVisible","hide","showAllAnnotations","isAnnotationVisible","lastVisible","hidden","ANNOTATION_VISIBILITY_CHANGE","checkAndSetAnnotationVisibility","_initializeConfig","colorHighlighted","colorSelected","colorLocked","textBoxVisibility","textBoxFontFamily","textBoxFontSize","textBoxColor","textBoxColorHighlighted","textBoxColorSelected","textBoxColorLocked","textBoxBackground","textBoxLinkLineWidth","textBoxLinkLineDash","textBoxShadow","angleArcLineDash","getAnnotationToolStyles","getViewportToolStyles","getToolGroupToolStyles","toolGroupId","toolGroups","getDefaultToolStyles","default","setAnnotationStyles","styles","annotationSpecificStyles","setViewportToolStyles","viewportSpecificStyles","setToolGroupToolStyles","toolGroupSpecificStyles","setDefaultToolStyles","toolStyle","specifications","_getToolStyle","property","annotationToolStyles","viewportToolStyles","global","toolGroupToolStyles","globalStyles","toolStyles","styleSpecifier","mode","alternatives","list","getHierarchalPropertyStyles","highlighted","Selected","Locked","autoGenerated","AutoGenerated","Default","eventType","ANNOTATION_ADDED","getToolGroupsWithToolName","viewportsToRender","viewportsInfo","viewportInfo","triggerAnnotationModified","changeType","ChangeTypes","HandlesUpdated","triggerAnnotationCompleted","_triggerAnnotationCompleted","triggerContourAnnotationCompleted","AnnotationGroup","annotationUIDs","_isVisible","visibleFilter","unboundVisibleFilter","setVisible","baseEvent","findNearby","uids","remove","annotationState","resetAnnotationManager","renderers","Contour","Surface","planarContourToolName","triggerSegmentationRender","segmentationRenderingEngine","renderSegmentationsForViewport","triggerSegmentationRenderBySegmentationId","renderSegmentation","_pendingRenderQueue","_getAllViewports","_renderFlaggedSegmentations","nextViewportIds","shift","_getViewportIdsForSegmentation","segmentationRepresentations","segmentationRenderList","_addPlanarFreeHandToolIfAbsent","display","existingRepresentation","then","error","Promise","resolve","allSettled","results","segmentationDetails","status","onSegmentationRender","SEGMENTATION_RENDERED","tools","addTool","setToolPassive","initialDefaultState","colorLUT","segmentations","viewportSegRepresentations","internalComputeVolumeLabelmapFromStack","imageIds","segmentationImageIds","volumeLoader","internalConvertStackToVolumeLabelmap","defaultSegmentationStateManager","getDefaultRenderingConfig","cfun","ofun","addPoint","_stackLabelmapImageIdReferenceMap","_labelmapImageIdReferenceMap","getState","updateState","updater","newState","getColorLUT","lutIndex","getNextColorLUTIndex","updateSegmentation","payload","draftState","triggerSegmentationModified","addSegmentation","newSegmentation","getLabelmapImageIds","removeSegmentation","filteredSegmentations","triggerSegmentationRemoved","addSegmentationRepresentation","renderingConfig","getSegmentationRepresentations","debug","setRenderInactiveSegmentations","addDefaultSegmentationRepresentation","addLabelmapRepresentation","triggerSegmentationRepresentationModified","segmentReps","segments","segmentIndex","active","colorLUTIndex","_setActiveSegmentation","processLabelmapRepresentationAddition","volumeViewport","isBaseVolumeSegmentation","_updateLabelmapSegmentationReferences","labelmapImageIds","updateCallback","referenceImageId","viewableLabelmapImageIdFound","labelmapImageId","referencedImageId","asOverlay","_updateLabelmapImageIdReferenceMap","stackViewport","_updateAllLabelmapSegmentationImageReferences","getImageIds","sliceIndex","withNavigation","labelmapData","getLabelmapImageIdsForImageId","_generateMapKey","getCurrentLabelmapImageIdsForViewport","getCurrentLabelmapImageIdForViewport","getStackSegmentationImageIdsForViewport","associatedReferenceImageAndLabelmapImageIds","removeSegmentationRepresentationsInternal","specifier","removedRepresentations","currentRepresentations","activeRepresentationRemoved","every","shouldRemove","removeSegmentationRepresentations","triggerSegmentationRepresentationRemoved","remainingRepresentations","removeSegmentationRepresentation","suppressEvent","currentValues","newValues","setActiveSegmentation","getActiveSegmentation","activeSegRep","segRep","viewportRepresentations","typeMatch","idMatch","getSegmentationRepresentationVisibility","viewportRepresentation","setSegmentationRepresentationVisibility","entries","segment","addColorLUT","removeColorLUT","_getStackIdForImageIds","slice","round","join","getAllViewportSegmentationRepresentations","getSegmentationRepresentationsBySegmentationId","result","viewportReps","filteredReps","indexToUse","colorLUTToUse","missingColorLUTs","addSegmentationRepresentations","segmentationInputArray","segmentationInput","addContourRepresentationToViewport","contourInputArray","input","addContourRepresentationToViewportMap","viewportInputMap","inputArray","addLabelmapRepresentationToViewport","labelmapInputArray","addLabelmapRepresentationToViewportMap","addSurfaceRepresentationToViewport","surfaceInputArray","addSurfaceRepresentationToViewportMap","inputData","contourData","geometryIds","annotationUIDsMap","normalizedSegments","segmentsConfig","label","cachedStats","rest","normalizedSegment","geometryId","geometry","getGeometry","normalizeContourSegments","surfaceData","normalizeSurfaceSegments","normalizeSegments","addSegmentations","suppressEvents","setColorLUT","colorLUTsIndex","segmentationRepresentation","getSegmentIndexColor","colorValue","setSegmentIndexColor","colorReference","getActiveSegmentIndex","activeSegmentIndex","getSegmentations","viewportSegmentations","getViewportSegmentations","getViewportSegmentationRepresentations","computeStackLabelmapFromVolume","convertVolumeToStackLabelmap","computeVolumeLabelmapFromStack","args","getActorEntry","filterFn","filteredActors","getLabelmapActorUID","getLabelmapActorEntry","getLabelmapActorEntries","getActorEntries","startsWith","getSurfaceActorEntry","getSurfaceRepresentationUID","updateSegmentations","segmentationUpdateArray","segmentationUpdate","visibility","setSegmentIndexVisibility","getSegmentIndexVisibility","getHiddenSegmentIndices","reduce","acc","getStyle","setStyle","merge","renderInactiveSegmentations","getRenderInactiveSegmentations","resetToGlobalStyle","hasCustomStyle","clearSegmentValue","setAtIndex","triggerSegmentationDataModified","removeSegment","setNextSegmentAsActive","getAnnotationsUIDMapFromSegmentation","removeCompleteContourAnnotation","removeContourSegmentAnnotations","isThisSegmentActive","updatedSegments","segmentIndices","sort","a","b","currentIndex","nextSegmentIndex","previousSegmentIndex","setActiveSegmentIndex","helpers","convertStackToVolumeLabelmap","internalAddSegmentationRepresentation","representationInput","getColorLUTIndex","firstSegmentIndex","segmentKeys","k","colorLUTOrIndex","JSON","parse","stringify","rep","removeAllSegmentations","immediate","_removeSegmentationRepresentations","labelmapDisplay","contourDisplay","removeRepresentation","surfaceDisplay","_removeRepresentationObject","removeAllSegmentationRepresentations","removeLabelmapRepresentation","removeContourRepresentation","removeSurfaceRepresentation","isSegmentIndexLocked","setSegmentIndexLocked","_setContourSegmentationSegmentAnnotationsLocked","getLockedSegmentIndices","parseInt","segmentationListeners","addDefaultSegmentationListener","representationType","updateFunction","getUpdateFunction","addSegmentationListener","listenerMap","removeSegmentationListener","listener","debouncedHandler","event","eventSegmentationId","createDebouncedSegmentationListener","removeAllSegmentationListeners","convertContourHoles","targetSegmentationId","targetSegmentationIndex","annotationsUIDsSet","targetUIDsSet","targetSegmentation","polylinesCanvasMap","polylines","holeDetectionResults","findContourHoles","hole","holeIndexes","decimateContours","epsilon","polylineCanvas","decimatedPolyline2D","point2D","canvasToWorld","closePolyline","closed","lastPoint","extractSegmentPolylines","contourRepresentationData","polyLinesMap","annotationUIDsInSegmentMap","getAnnotationMapFromSegmentation","annotationsInfo","annotationInfo","isClosed","holesUIDs","holesPolyline","holesClosed","getPolylinesMap","convertContourPolylineToCanvasSpace","annotationMap","annotationUIDsInSegment","hasChildAnnotations","childPolylinesInformation","childInfo","childPolylines","getViewportsAssociatedToSegmentation","getViewportAssociatedToSegmentation","getViewportWithMatchingViewPlaneNormal","dotThreshold","annotationViewPlaneNormal","viewPlaneNormal","normalizedAnnotationNormal","camera","getCamera","normalizedCameraNormal","dotProduct","removeContourHoles","removeContourIslands","threshold","islands","smoothContours","knotsRatioPercentage","smoothedPolyline","_getViewportIndex","arr","ar","_containsViewport","synchronizerId","eventName","eventHandler","_viewportOptions","_onEvent","_ignoreFiredEvents","_targetViewports","_eventSource","currentTarget","_sourceViewports","s","fireEvent","_enabled","_eventName","_eventHandler","_options","eventSource","_auxiliaryEvents","auxiliaryEvents","isDisabled","_hasSourceElements","setOptions","setEnabled","enabled","getOptions","addTarget","addSource","source","_updateDisableHandlers","getSourceViewports","getTargetViewports","removeSource","removeTarget","getViewportElement","hasSourceViewport","hasTargetViewport","sourceViewport","sourceEvent","promises","targetViewport","ex","vp1","vp2","unique","vps","concat","u","_getUniqueViewports","_remove","disableHandler","getEventSource","synchronizers","sync","synchronizer","pop","synchronizerIndex","synchronizersFilteredByIds","notDisabled","Disabled","PRIMARY_BINDINGS","mouseButton","MouseBindings","Primary","ToolGroup","toolOptions","currentActivePrimaryToolName","prevActivePrimaryToolName","restoreToolOptions","_toolInstances","getViewportIds","getViewportsInfo","getToolInstance","toolInstanceName","toolInstance","getToolInstances","configuration","toolDefinition","hasToolName","localToolInstance","toolClass","ToolClass","instantiatedTool","addToolInstance","parentClassName","ToolClassToUse","ParentClass","ToolInstance","addViewport","renderingEngineUIDToUse","_findRenderingEngine","vpId","getActivePrimaryMouseButtonTool","setViewportsCursorByToolName","TOOLGROUP_VIEWPORT_ADDED","removeViewports","indices","vpInfo","TOOLGROUP_VIEWPORT_REMOVED","setActiveStrategy","strategyName","setToolMode","setToolDisabled","setToolEnabled","setToolActive","toolBindingsOptions","bindings","binding","TouchBinding","numTouchPoints","MouseBinding","obj","hasSameBinding","_hasMousePrimaryButtonBinding","_setCursorForViewports","onSetToolActive","_renderViewports","TOOL_ACTIVATED","_triggerToolModeChangedEvent","prevToolOptions","matchBindings","removeAllBindings","getDefaultPrimaryBindings","matchBinding","onSetToolPassive","onSetToolEnabled","onSetToolDisabled","toolOptionsForTool","_getCursor","Settings","getRuntimeSettings","setToolConfiguration","overwrite","_configuration","onSetToolConfiguration","getDefaultMousePrimary","getToolConfiguration","configurationPath","getPrevActivePrimaryToolName","setActivePrimaryTool","activeToolName","getCurrentActivePrimaryToolName","clone","newToolGroupId","fnToolFilter","sourceToolInstance","sourceToolOptions","sourceToolMode","primaryBindings","primary","TOOL_MODE_CHANGED","renderingEngines","matchingEngines","engine","binding1","binding2","modifierKey","tg","toolGroupIndex","svgLayer","svgLayerId","classList","pointerEvents","feOffset","feColorMatrix","feBlend","_createSvgAnnotationLayer","viewportUid","renderingEngineUid","dataset","elementHash","svgNodeCache","_setSvgNodeCache","enabledElements","hasToolByName","removeTool","cancelActiveManipulations","toolsWithData","cancel","VIEWPORT_ELEMENT","_removeViewportFromSynchronizers","_removeViewportFromToolGroup","_removeEnabledElement","foundElementIndex","el","elementDisabledEvt","_resetSvgNodeCache","internalViewportNode","_removeSvgNode","defaultState","isInteractingWithTool","isMultiPartToolActive","resetCornerstoneToolsState","resetSvgNodeCache","areViewportsCoplanar","viewport1","viewport2","viewPlaneNormal1","viewPlaneNormal2","dotProducts","cameraSyncCallback","synchronizerInstance","cameraModifiedEvent","tViewport","setCamera","getSpatialRegistration","targetId","sourceId","imageSliceSyncCallback","sViewport","disabled","imageId1","sourceImagePositionPatient","metaData","imagePositionPatient","targetImageIds","registrationMatrixMat4","getFrameOfReferenceUID","useInitialPosition","targetImagePositionPatientWithRegistrationMatrix","closestImageIdIndex2","targetPoint","closestImageIdIndex","distance","Infinity","imageIndexToSet","getCurrentImageIdIndex","imageIndex","presentationViewSyncCallback","_synchronizerInstance","_sourceEvent","presentationView","getViewPresentation","setViewPresentation","slabThicknessSyncCallback","slabThickness","getSlabThickness","setSlabThickness","voiSyncCallback","modifiedEvent","range","invertStateChanged","invert","colormap","tProperties","voiRange","syncInvertState","syncColormap","_actors","setProperties","zoomPanSyncCallback","syncZoom","srcZoom","getZoom","setZoom","syncPan","srcPan","getPan","setPan","createStackImageSynchronizer","createCameraPositionSynchronizer","synchronizerName","createSynchronizer","STACK_NEW_IMAGE","VOLUME_NEW_IMAGE","createImageSliceSynchronizer","createPresentationViewSynchronizer","viewPresentation","createVOISynchronizer","VOI_MODIFIED","COLORMAP_MODIFIED","createZoomPanSynchronizer","csEvents","isSegmentation","AdvancedMagnifyToolActions","PARALLEL_THRESHOLD","CONSTANTS","AdvancedMagnifyTool","Actions","toolProps","defaultToolProps","supportedInteractionTypes","magnifyingGlass","radius","zoomFactor","zoomFactorList","autoPan","actions","showZoomFactorsList","method","Secondary","KeyboardBindings","Shift","addNewAnnotation","currentPoints","worldPos","world","canvasPos","canvas","canvasHandlePoints","_getCanvasHandlePoints","viewUp","getReferencedImageId","magnifyViewportId","getToolName","sourceViewportId","isCanvasAnnotation","handles","activeHandleIndex","magnifyViewportManager","createViewport","sourceEnabledElement","annotationPoints","canvasDelta","delta","len","viewportIdsToRender","getViewportIdsWithToolToRender","preventDefault","dispose","isPointNearTool","canvasCoords","proximity","canvasTop","canvasBottom","canvasLeft","radiusPoint","getCanvasCircleRadius","toolSelectedCallback","editData","_activateModify","handleSelectedCallback","handleIndex","p","_endCallback","newAnnotation","_deactivateModify","isDrawing","_dragDrawCallback","deltaPoints","hasMoved","_dragModifyCallback","_dragHandle","canvasCenter","currentCanvasPoints","newRadius","newCanvasHandlePoints","renderStatus","filteredAnnotations","filterInteractableAnnotationsForElement","activeHandleCanvasCoords","drawHandles","circleUID","drawCircle","magnifyViewport","update","canvasCenterPos","canvasRadius","AdvancedMagnifyViewportManager","getInstance","canvasPoint","viewportElement","currentZoomFactor","dropdown","_getZoomFactorsListDropdown","newZoomFactor","parentElement","focus","onChangeCallback","createElement","stopPropagation","keyCode","which","toLowerCase","option","title","defaultSelected","sourceElement","AdvancedMagnifyViewport","_addSourceElementEventListener","_magnifyViewportsMap","magnifyViewportInfo","_annotationRemovedCallback","destroyViewport","_newStackImageCallback","magnifyViewportsMapEntries","_getMagnifyViewportsMapEntriesBySourceViewportId","stackActorReInitialized","_newVolumeImageCallback","currentViewPlaneNormal","worldImagePlanePoint","vecHandleToImagePlane","worldDist","worldDelta","_initialize","_singleton","_removeEventListeners","_destroyViewports","magnifyViewportMapEntry","_removeSourceElementEventListener","newEnabledElement","_addEventListeners","newStackHandler","VIEWPORT_NEW_IMAGE_SET","newVolumeHandler","VOLUME_VIEWPORT_NEW_VOLUME","_enabledElement","_sourceToolGroup","_magnifyToolGroup","_isViewportReady","_radius","_resized","_canAutoPan","_viewportId","_sourceEnabledElement","_autoPan","_browserMouseDownCallback","_browserMouseUpCallback","_handleToolModeChanged","_mouseDragCallback","_resizeViewportAsync","_resizeViewport","_syncViewports","disableElement","parentNode","magnifyToolGroup","_inheritBorderRadius","magnifyElement","borderRadius","_createViewportNode","overflow","boxSizing","_convertZoomFactorToParallelScale","parallelScale","offsetWidth","_isStackViewport","_isVolumeViewport","_cloneToolGroups","sourceActors","magnifyToolGroupId","sourceToolGroup","_cloneStack","setStack","_cloneVolumes","volumeInputArray","setVolumes","_cloneViewport","sourceViewportOptions","viewportInput","defaultOptions","enableElement","_cancelMouseEventCallback","target","closest","canvasCurrent","magnifyRadius","dist","distanceToPoint","maxDist","panDist","canvasDeltaPos","newCanvasPosition","currentWorldPos","newWorldPos","worldDeltaPos","autoPanCallbackData","currentPosition","newPosition","_addBrowserEventListeners","_removeBrowserEventListeners","sourceCanvas","_syncViewportsCameras","focalPoint","sqrt","pow","updatedFocalPoint","updatedPosition","_syncStackViewports","setImageIdIndex","sourceProperties","getProperties","getImageData","resize","AnnotationEraserTool","preMouseDownCallback","_deleteNearbyAnnotations","preTouchStartCallback","interactionType","annotationsToRemove","interactableAnnotations","createAnnotationMemo","deleting","RENDERING_DEFAULTS","defaultReferenceLineColor","defaultReferenceLineControllable","defaultReferenceLineDraggableRotatable","defaultReferenceLineSlabThicknessControlsOn","OPERATION","CrosshairsTool","viewportIndicators","viewportIndicatorsConfig","panSize","enableHDPIHandles","referenceLinesCenterGapRadius","referenceLinesCenterGapRatio","filterActorUIDsToSetSlabThickness","slabThicknessBlendMode","MAXIMUM_INTENSITY_BLEND","centerPoint","mobile","toolCenter","initializeViewport","_getAnnotations","cameraPosition","cameraFocalPoint","rotationPoints","slabThicknessPoints","activeOperation","activeViewportIds","normal","clientWidth","clientHeight","_getViewportsInfo","getToolGroup","resetCrosshairs","resetPan","resetZoom","resetToCenter","resetRotation","resetCamera","resetSlabThickness","_computeToolCenter","computeToolCenter","firstViewport","secondViewport","thirdViewport","normal1","point1","normal2","point2","normal3","point3","firstPlane","secondPlane","thirdPlane","setToolCenter","jumpWorld","_jump","viewportIdArray","otherViewport","viewportControllable","_getReferenceLineControllable","viewportDraggableRotatable","_getReferenceLineDraggableRotatable","_pointNearTool","viewportAnnotation","currentCamera","oldCameraPosition","deltaCameraPosition","oldCameraFocalPoint","deltaCameraFocalPoint","isRotation","cameraModifiedInPlane","CROSSHAIR_TOOL_CENTER_CHANGED","_autoPanViewportIfNecessary","mouseMoveCallback","filteredToolAnnotations","imageNeedsUpdate","previousActiveOperation","previousActiveViewportIds","near","getHandleNearImagePoint","_areViewportIdArraysEqual","canvasDiagonalLength","canvasMinDimensionLength","crosshairCenterCanvas","worldToCanvas","otherViewportAnnotations","_filterAnnotationsByUniqueViewportOrientations","referenceLines","canvasBox","otherCamera","otherViewportControllable","otherViewportDraggableRotatable","otherViewportSlabThicknessControlsOn","_getReferenceLineSlabThicknessControlsOn","otherCanvasDiagonalLength","otherCanvasCenter","otherViewportCenterWorld","pointWorld0","pointWorld1","pointCanvas0","otherViewportCenterCanvas","canvasUnitVectorFromCenter","canvasVectorFromCenterLong","canvasVectorFromCenterMid","canvasVectorFromCenterShort","canvasVectorFromCenterStart","mobileConfig","centerGap","refLinePointOne","refLinePointTwo","refLinePointThree","refLinePointFour","refLinesCenter","rotHandleOne","rotHandleTwo","stHandlesCenterCanvas","stHandlesCenterWorld","worldUnitVectorFromCenter","matrix","buildFromDegree","rotate","worldUnitOrthoVectorFromCenter","slabThicknessValue","worldOrthoVectorFromCenter","worldVerticalRefPoint","canvasVerticalRefPoint","canvasOrthoVectorFromCenter","stLinePointOne","stLinePointTwo","stLinePointThree","stLinePointFour","stHandleOne","stHandleTwo","stHandleThree","stHandleFour","newRtpoints","newStpoints","viewportColor","_getReferenceLineColor","line","lineIndex","viewportSlabThicknessControlsOn","selectedViewportId","lineActive","rotHandlesActive","rotationHandles","rotHandleWorldOne","rotHandleWorldTwo","slabThicknessHandlesActive","slabThicknessHandles","slabThicknessHandleWorldOne","slabThicknessHandleWorldTwo","slabThicknessHandleWorldThree","slabThicknessHandleWorldFour","devicePixelRatio","handleUID","referenceColorCoordinates","xOffset","yOffset","circleRadius","defaultColor","defaultSize","maxAllowedSize","centerPointColor","centerPointSize","_onNewVolume","viewportIdArrayOne","viewportIdArrayTwo","itemFound","_getAnnotationsForViewportsWithDifferentCameras","viewportsWithDifferentCameras","cameraOfTarget","_filterViewportWithSameOrientation","referenceAnnotation","linkedViewportAnnotations","otherViewPlaneNormal","otherLinkedViewportAnnotationsFromSameScene","otherViewportsAnnotationsWithUniqueCameras","cameraFound","jj","cameraOfStocked","otherNonLinkedViewportAnnotationsFromSameScene","_checkIfViewportsRenderingSameScene","volumeIds","getAllVolumeIds","otherVolumeIds","viewportsAnnotationsToUpdate","sameScene","_applyDeltaShiftToSelectedViewportCameras","_dragCallback","dir1","dir2","centerCanvas","finalPointCanvas","originalPointCanvas","_isClockWise","rotationAxis","buildFromRadian","translate","otherViewportsIds","renderViewports","referenceAnnotations","viewportsIds","dotProd","projectedDelta","mod","currentPoint","lastPoints","currentCenter","otherViewportRotationPoints","dotProdDirection","projectedDirection","normalizedProjectedDirection","normalizedProjectedDelta","MINIMUM_SLAB_THICKNESS","_pointNearReferenceLine","lineViewport","lineSegment1","distanceToPoint1","lineSegment2","distanceToPoint2","getReferenceLineColor","getReferenceLineControllable","getReferenceLineDraggableRotatable","getReferenceLineSlabThicknessControlsOn","_unsubscribeToViewportNewVolumeSet","_subscribeToViewportNewVolumeSet","scroll","scrollDelta","newFocalPoint","_getRotationHandleNearImagePoint","_getSlabThicknessHandleNearImagePoint","toolCenterCanvas","pan","visiblePointCanvas","visiblePointWorld","deltaPointsWorld","actorUIDs","blendModeToUse","COMPOSITE","setBlendMode","c","_applyDeltaShiftToViewportCamera","annotationCanvasCoordinate","stPointLineCanvas1","stPointLineCanvas2","stPointLineCanvas1Start","stPointLineCanvas2Start","MIPJumpToClickTool","targetViewportIds","mouseClickCallback","getVolumeId","maxIntensity","brightestPoint","getPointInLineOfSightWithCriteria","intensity","foundToolGroup","jumpToWorld","MAGNIFY_VIEWPORT_ID","MagnifyTool","magnifySize","magnifyWidth","magnifyHeight","_hasBeenRemoved","_getReferencedImageId","_createMagnificationViewport","_activateDraw","viewportProperties","rotation","originalViewportRotation","magnifyToolElement","STACK","_cancelCallback","_dragEndCallback","_deactivateDraw","getTargetId","split","OverlayMarkerType","OrientationMarkerTool","CUBE","AXIS","VTPFILE","OVERLAY_MARKER_TYPES","orientationWidget","viewportCorner","Corners","BOTTOM_RIGHT","viewportSize","minPixelSize","maxPixelSize","overlayMarkerType","ANNOTATED_CUBE","overlayConfiguration","faceProperties","xPlus","faceColor","faceRotation","xMinus","yPlus","fontColor","yMinus","zPlus","zMinus","defaultStyle","fontStyle","fontSizeScale","res","edgeThickness","edgeColor","resolution","AXES","CUSTOM","polyDataURL","_resizeObservers","initViewports","_subscribeToViewportEvents","cleanUpData","orientationMarker","orientationMarkers","updateViewport","updatingOrientationMarker","unsubscribe","unobserve","subscribeToElementResize","resizeObserver","ResizeObserver","setTimeout","observe","getOffscreenMultiRenderWindow","getRenderWindow","filterViewportsWithToolEnabled","widget","getWidget","isDeleted","addAxisActorInViewport","getRenderer","removeActor","createAnnotationCube","createCustomActor","renderer","renderWindow","interactor","getInteractor","parentRenderer","setViewportCorner","setViewportSize","setMinPixelSize","setMaxPixelSize","updateMarkerOrientation","addWidget","response","fetch","arrayBuffer","vtpReader","parseAsArrayBuffer","polyData","shallowCopy","getOutputData","setActiveScalars","mapper","setColorModeToDirectScalars","setMapper","rotateZ","setDefaultStyle","setXPlusFaceProperty","setXMinusFaceProperty","setYPlusFaceProperty","setYMinusFaceProperty","setZPlusFaceProperty","setZMinusFaceProperty","createAnnotatedCubeActor","axes","annotatedCube","methodName","charAt","toUpperCase","EPSILON","OverlayGridTool","A","sourceImageIds","_init","imagePlaneModule","pointSets","calculateImageIdPointSets","viewportData","rows","columns","rowCosines","columnCosines","rowPixelSpacing","columnPixelSpacing","pointSet1","pointSet2","imageIdNormal","getImageIdNormal","isParallel","targetViewportPlane","targetData","initializeViewportData","pointSetsToUse","pointSetToUse","topBottomVec","isPerpendicular","lineStartsWorld","lineEndsWorld","lineStartWorld","lineEndWorld","vec1","vec2","dot","imageOrientationPatient","rowCosineVec","colCosineVec","PanTool","limitToViewport","touchDragCallback","mouseDragCallback","_checkImageInViewport","deltaPointsCanvas","ratio","viewportRight","viewportBottom","defaultActor","getDefaultActor","bounds","getBounds","computeVisiblePropBounds","imageLeft","imageTop","imageRight","imageBottom","PlanarRotateTool","mouseWheelCallback","wheel","setAngle","startPoints","currentPointWorld","startPointWorld","centerWorld","v1","v2","cross","rotAngle","rotMat","Float32Array","rotatedViewUp","ReferenceCursors","preventHandleOutsideImage","displayThreshold","positionSync","disableCursor","isHandleOutsideImage","_elementWithCursor","_currentCursorWorldPosition","_currentCanvasPosition","_disableCursorEnabled","getActiveAnnotation","createInitialAnnotation","updateAnnotationPosition","textBox","worldPosition","worldBoundingBox","previousCamera","oldFocalPoint","cameraNormal","isElementWithCursor","updateViewportImage","lineWidthBase","e","crosshairUIDs","upper","lower","centerSpace","lineLength","plane","currentMousePosition","closestIndex","currentDistance","normalizedViewPlane","scaledPlaneNormal","ReferenceLines","enforceSameFrameOfReference","showFullDimension","sourceViewportCanvasCornersInWorld","sourceViewPlaneNormal","topRightVec","newNormal","handleFullDimension","targetImage","getTargetImageData","topLeftImageCoord","topRightImageCoord","bottomRightImageCoord","bottomLeftImageCoord","indexToWorld","lineStartImageCoord","lineEndImageCoord","intersectInfiniteLines","isInBound","err","line1Start","line1End","line2Start","line2End","x3","y3","x4","y4","a1","b1","c1","a2","b2","c2","viewportsWithAnnotations","ScaleOverlayTool","scaleLocation","viewportCanvasCornersInWorld","thisAnnotation","computeScaleSize","worldWidthViewport","worldHeightViewport","location","scaleSizes","currentScaleSize","scaleSize","computeEndScaleTicks","locationTickOffset","endTick1","endTick2","computeInnerScaleTicks","leftTick","rightTick","canvasScaleSize","tickIds","tickUIDs","tickCoordinates","numberSmallTicks","tickSpacing","locationOffset","computeWorldScaleCoordinates","pointSet","worldCoordinates","midpointLocation","midpoint","offset","computeCanvasScaleCoordinates","canvasSize","vscaleBounds","hscaleBounds","scaleCanvasCoordinates","worldDistanceOnCanvas","computeScaleBounds","horizontalReduction","verticalReduction","hReduction","vReduction","locationBounds","canvasBounds","scaleTicks","scaleId","leftTickId","rightTickId","locationTextOffest","textCanvasCoordinates","textBoxLines","_getTextLines","drawTextBox","scaleSizeDisplayValue","scaleSizeUnits","SculptorTool","minSpacing","referencedToolNames","toolShape","referencedToolName","updateCursorSize","registeredShapes","isActive","commonData","activeAnnotationUID","isEditingOpenContour","canvasLocation","configureToolSize","selectFreehandTool","activateModify","updateCursor","endCallback","deactivateModify","activeAnnotation","filterSculptableAnnotationsForElement","calculateStats","dragCallback","sculpt","registerShapes","shapeName","setToolShape","shapeClass","shape","cursorShape","selectedShape","sculptData","mouseCanvasPoint","deltaWorld","maxSpacing","getMaxSpacing","pushedHandles","pushHandles","first","insertNewHandles","interpolatePointsWithinMaxSpacing","indicesToInsertAfter","nextHandleIndex","contourIndex","currentCanvasPoint","nextCanvasPoint","updateToolSize","sculptableAnnotations","findNewHandleIndices","newIndexModifier","insertIndex","insertHandleRadially","last","previousIndex","nextIndex","handleData","getInsertPosition","closestAnnotationUID","getClosestFreehandToolOnElement","canvasPoints","toolIndex","distanceFromTool","renderShape","SegmentationIntersectionTool","actorsWorldPointsMap","calculateSurfaceSegmentationIntersectionsForViewport","calculateSurfaceSegmentationIntersections","cacheId","getCacheId","clippingFilter","actorWorldPointMap","polyLineIdx","worldPointsSet","polyLineUID","actorWorldPointsMap","polyDataUtils","colorArray","colorComponentToString","component","componentString","floor","colorToString","getProperty","getColor","StackScrollTool","debounceIfNotLoaded","loop","deltaY","_scroll","_scrollDrag","deltaPointY","pixelsPerImage","_getPixelPerImage","imageIdIndexOffset","debounceLoading","scrollSlabs","numberOfSlices","getNumberOfSlices","offsetHeight","TrackballRotateTool","rotateIncrementDegrees","rotateSampleDistanceFactor","_hasResolutionChanged","originalSampleDistance","getSampleDistance","setSampleDistance","cleanUp","once","_viewportAddedListener","disconnect","rotateCamera","axis","vtkCamera","getVtkActiveCamera","getViewUp","getFocalPoint","getPosition","newViewUp","currentPointsCanvas","lastPointsCanvas","normalizedPosition","normalizedPreviousPosition","radsq","op","oe","opsq","oesq","lop","loe","nop","noe","angleX","acos","sign","upVec","atV","rightV","forwardV","angleY","VolumeCroppingControlTool","extendReferenceLines","initialCropFactor","lineColors","AXIAL","CORONAL","SAGITTAL","UNKNOWN","lineWidthActive","_virtualAnnotations","sphereStates","draggingSphereIndex","toolCenterMin","toolCenterMax","_updateToolCentersFromViewport","orientation","_getOrientationFromNormal","resetCroppingSpheres","orientationIds","presentOrientations","Boolean","missingOrientation","presentNormals","presentCenters","presentViewportInfos","virtualNormal","virtualCenter","virtualAnnotation","isVirtual","presentOrientation","presentCenter","canonicalNormals","virtualAnnotations","lineIntersection2D","p1","p2","q1","q2","s1_x","s1_y","s2_x","s2_y","denom","volumeCroppingCenterCanvasMin","volumeCroppingCenterCanvasMax","realViewports","refLinesCenterMin","refLinePointMinOne","refLinePointMinTwo","refLinesCenterMax","refLinePointMaxOne","refLinePointMaxTwo","intersections","otherLine","intersection","with","annotationForViewport","String","idUpper","colorArr","unknown","v","activeLineWidth","sortedIntersections","_onSphereMoved","originalClippingPlanes","_syncWithVolumeCroppingTool","seriesInstanceUID","newMin","newMax","idx","volumeActors","VOLUMECROPPINGCONTROL_TOOL_CHANGED","VOLUME_3D","activeType","handleType","viewportOrientation","VOLUMECROPPING_TOOL_CHANGED","getSpacing","getOrigin","cropFactor","maxCropFactor","cropStart","cropEnd","onSetToolInactive","anyAnnotationExists","canonical","tol","planes","start1","end1","PLANEINDEX","SPHEREINDEX","XMIN","XMAX","YMIN","YMAX","ZMIN","ZMAX","XMIN_YMIN_ZMIN","XMIN_YMIN_ZMAX","XMIN_YMAX_ZMIN","XMIN_YMAX_ZMAX","XMAX_YMIN_ZMIN","XMAX_YMIN_ZMAX","XMAX_YMAX_ZMIN","XMAX_YMAX_ZMAX","VolumeCroppingTool","showCornerSpheres","showHandles","showClippingPlanes","sphereColors","CORNERS","sphereRadius","grabSpherePixelDistance","cornerDragOffset","faceDragOffset","edgeLines","_updateClippingPlanes","mouseCanvas","sphereCanvas","sphereState","mouseWorld","isCorner","axisIdx","z","viewport3D","_updateCornerSpheres","_updateFaceSpheresFromCorners","_updateClippingPlanesFromFaceSpheres","_onMouseMoveSphere","_getViewportAndWorldCoords","newCorner","_calculateNewCornerPosition","_updateSpherePosition","axisFlags","_parseCornerKey","_updateRelatedCorners","sphereSource","setCenter","_updateCornerSpheresFromFaces","_triggerToolChangedEvent","_onControlToolChange","_getViewport","isMin","normals","planeIndices","sphereIndices","orientationAxes","newCenter","sphereActor","setColor","volumeActor","clippingPlanes","getClippingPlanes","_initialize3DViewports","worldBounds","xRange","yRange","zRange","xMin","xMax","yMin","yMax","zMin","zMax","planeXmin","planeXmax","planeYmin","planeYmax","planeZmin","planeZmax","originalPlanes","getNormal","sphereXminPoint","sphereXmaxPoint","sphereYminPoint","sphereYmaxPoint","sphereZminPoint","sphereZmaxPoint","adaptiveRadius","_calculateAdaptiveSphereRadius","_addSphere","corners","cornerKeys","key1","key2","state1","state2","_addLine3DBetweenPoints","addClippingPlane","_handleCornerSphereMovement","_updateAfterCornerMovement","_handleFaceSphereMovement","_updateAfterFaceMovement","cornerKey","isXMin","isXMax","isYMin","isYMax","isZMin","isZMax","draggedSphere","_shouldUpdateCorner","_updateCornerCoordinates","_rotateCamera","setHandlesVisible","setClippingPlanesVisible","_updateHandlesVisibility","getHandlesVisible","getClippingPlanesVisible","normalizedCenter","_missingActorWarned","getMatrix","removeAllClippingPlanes","rot","normalMatrix","transformedOrigins","transformedNormals","oVec","o","nVec","n","planeInstance","setVisibility","setNumberOfPoints","setPoint","lines","setPoints","setLines","setLineWidth","setOpacity","setInterpolationToFlat","setAmbient","setDiffuse","setSpecular","addActor","setRadius","sphereMapper","setInputConnection","getOutputPort","diagonal","sphereRadiusScale","minRadius","minSphereRadius","maxRadius","maxSphereRadius","pos","corner","xs","ys","zs","getPoints","DIRECTIONS","VolumeRotateTool","cz","ax","ay","az","WindowLevelRegionTool","minWindowWidth","applyWindowLevelRegion","bottomLeftCanvas","topRightCanvas","bottomRightCanvas","topLeftCanvas","bottomRightWorld","topLeftWorld","getAnnotationStyle","drawRect","windowLevel","startCanvas","endCanvas","pixelLuminanceData","minMaxMean","minPixelValue","maxPixelValue","windowWidth","windowCenter","mean","voiLutFunction","VOILUTFunction","WindowLevelTool","_getImageDynamicRangeFromMiddleSlice","scalarData","middleSliceIndex","frameLength","bytesPerVoxel","TypedArrayConstructor","Uint8Array","Uint16Array","Int16Array","frame","buffer","_getMinMax","modality","newRange","viewportsContainingVolumeUID","isPreScaled","properties","volume","Modality","scaling","preScale","scaled","scalingParameters","suvbw","getPTScaledNewRange","getNewRange","multiplier","_getMultiplierFromDynamicRange","wwDelta","wcDelta","imageDynamicRange","imageVolume","calculatedDynamicRange","getMiddleSliceData","pixel","BitsStored","metadataDynamicRange","calculatedRange","isFinite","_getImageDynamicRangeFromViewport","getRange","imageDataRange","getScalars","getData","voxel","ZoomTool","zoomToCenter","minZoomScale","maxZoomScale","pinchToZoom","initialMousePosWorld","dirVec","_dragParallelProjection","pinch","deltaDistance","parallelScaleToSet","focalPointToSet","positionToSet","distanceToCanvasCenter","cappedParallelScale","thresholdExceeded","imageWidth","imageHeight","canvasAspect","insetImageMultiplier","getConfiguration","rendering","useLegacyCameraFOV","displayArea","scaledImageWidth","imageArea","scaledImageHeight","minParallelScaleRequired","minScaleInWorld","maxScaleInWorld","_dragPerspectiveProjection","zoomScale","directionOfProjection","tmp","_pinchCallback","_zoom","currentPointsList","parallelProjection","_panCallback","eventDetails","page","client","AngleTool","showAngleArc","arcOffset","getTextLines","defaultGetTextLines","angleStartedNotYetCompleted","createAnnotation","movingTextBox","canvasPoint1","canvasPoint2","line1","canvasPoint3","line2","doneEditMemo","createMemo","worldPosDelta","_throttledCalculateCachedStats","_calculateCachedStats","showHandlesAlways","anglePoints","temp","getLinkedTextBoxStyle","canvasTextBoxCoords","textBoxPosition","textBoxUID","boundingBox","drawLinkedTextBox","trailing","hydrate","instance","hydrateBase","serializableOptions","worldPos1","worldPos2","worldPos3","targetIds","StatsUpdated","cachedVolumeStats","fromCharCode","ArrowAnnotateTool","getTextCallback","changeTextCallback","arrowFirst","arrowHeadStyle","startGroupRecording","memo","setAnnotationLabel","endGroupRecording","touchTapCallback","taps","doubleClickCallback","clickedAnnotation","_doneChangingTextCallback","stopImmediatePropagation","updatedLabel","_isInsideVolume","index1","index2","doneChangingTextCallback","prompt","transformWorldToIndex","BidirectionalTool","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","canvasCoordPoints","shortAxisDistFromCenter","dx","dy","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","unit","dataId1","dataId2","secondLineUID","getTextBoxCoordsCanvas","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos4","image","index3","index4","handles1","handles2","scale1","units1","scale2","units2","dist1","_calculateLength","dist2","widthUnit","vector1","vector2","majorAxis","minorAxis","major0","major1","minor0","minor1","pos1","pos2","dz","CircleROITool","storePointData","centerPointRadius","statsCalculator","BasicStatsCalculator","simplified","canvasHandles","radiusCanvas","newRadiusCanvas","canvasCorners","getCanvasCircleCorners","areaUnit","getStackViewports","referencedImageURI","hasImageURI","currentImageURI","area","stdDev","radiusUnit","perimeter","wasInvalidated","pos1Index","pos2Index","boundsIJK","xRadius","yRadius","zRadius","ellipseObj","worldWidth","worldHeight","isEmptyArea","aspect","pixelUnitsOptions","isSuvScaled","modalityUnit","pointsInShape","statsCallback","isInObject","pointLPS","pointInEllipse","fast","returnPoints","stats","getStatistics","statsArray","array","radiusLine","areaLine","CobbAngleTool","showArcLines","distanceToLines","isNearFirstLine","isNearSecondLine","_mouseDownCallback","arc1Angle","arc2Angle","arc1Start","arc1End","arc2Start","arc2End","mid1","mid2","arc1TextBoxUID","arc1TextLine","arch1TextPosCanvas","arc2TextBoxUID","arc2TextLine","arch2TextPosCanvas","point4","canvasPoint4","getArcsStartEndPoints","linkLine","arc1Side","arc2Side","midLinkLine","linkLineLength","midFirstLine","midSecondLine","directionVectorStartArc1","magnitudeStartArc1","normalizedDirectionStartArc1","directionVectorEndArc1","magnitudeEndArc1","normalizedDirectionEndArc1","directionVectorStartArc2","magnitudeStartArc2","normalizedDirectionStartArc2","directionVectorEndArc2","magnitudeEndArc2","normalizedDirectionEndArc2","seg1","seg2","minDist","MAX_VALUE","DragProbeTool","postMouseDownCallback","postTouchStartCallback","ETDRSGridTool","degrees","diameters","getViewReference","dXCanvas","dYCanvas","canvasEnd","diametersCanvas","diameter","worldMeasureToCanvas","degreesRad","angleRadians","degree","measurement","p1Canvas","p2Canvas","EllipticalROITool","minorEllipse","majorEllipse","pointInMinorEllipse","_pointInEllipseCanvas","canvasWidth","canvasHeight","originalHandleCanvas","pointsCanvas","dX","dY","bottomCanvas","topCanvas","leftCanvas","rightCanvas","newHalfCanvasWidth","canvasRight","newHalfCanvasHeight","getCanvasEllipseCorners","_getCanvasEllipseCenter","ellipse","rotLocation","normalized","ellipseCanvasPoints","HeightTool","_calculateHeight","outside","KeyImageTool","dataSeries","seriesLevel","dataPoint","isPoint","canvasPosition","createAnnotationForViewport","eventDispatchDetail","it","updatedText","LabelTool","textGroupElement","bbox","translateX","translateY","matches","initialWorldPos","anchorWorldPos","LabelChange","_evt","_annotation","_handle","_interactionType","LengthTool","undo","redo","LivewireContourSegmentationTool","updateInterpolatedAnnotation","interpolationSources","originalPolyline","queueMicrotask","setupBaseEditData","scissors","nearestEdge","repeatInterpolation","interpolation","originalPoints","worldToSlice","sliceToWorld","handleSmoothing","hIndex","testPoint","startSearch","findPathToPoint","minPoint","findMinNearby","acceptedPath","path","addPoints","updateAnnotation","scissorsNext","InterpolationUpdated","renderAnnotationInstance","renderContext","showInterpolationPolyline","polylineCanvasPoints","isContourSegmentationTool","register","LivewireContourTool","contourHoleAdditionModifierKey","snapHandleNearby","decimate","cancelInProgress","proximitySquared","startPoint","endPoint","clearAnnotation","clearEditData","Completed","triggerChangeEvent","doubleClick","worldPosOriginal","controlPoints","currentPath","getControlPoints","closestHandlePoint","distSquared","worldControlPoint","canvasControlPoint","snapPoint","pathPoints","prependPath","confirmedPath","getLastPoint","addControlPoint","_mouseMoveCallback","lastCanvasPoint","imgWidth","imgHeight","slicePoint","editHandle","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","getCalibratedLengthUnitsAndScale","maxX","canvasMaxX","maxY","canvasMaxY","minX","canvasMinX","minY","canvasMinY","topLeftBBWorld","topLeftBBIndex","bottomRightBBWorld","_renderStats","textboxStyle","throttle","nextPos","viewportImageData","vtkImageData","sliceImageData","sliceToIndexMatrix","indexToSliceMatrix","ijkPoint","startPos","createInstanceFromRawPixelData","currentPathNext","confirmedPathNext","handlePoints","numHandles","previousHandle","nextHandle","slicePos","pathPointsLeft","pathPointsRight","reverse","appendPath","contourSegmentationAnnotation","annotationStyle","textbox","livewirePath","pointArray","imagePoints","targetWindingDirection","Clockwise","updateContourPolyline","ProbeTool","probeDefaults","textCanvasOffset","mergeDefaultProps","ijk","getAtIJKPoint","imageURI","calibratedResults","hasEnhancedRegionValues","units","RegionSegmentPlusTool","isPartialVolume","positiveSeedVariance","negativeSeedVariance","subVolumePaddingPercentage","islandRemoval","mouseTimer","allowedToProceed","worldPoint","clearTimeout","onMouseStable","mouseStabilityDelay","refVolume","growCutData","referencedVolumeId","seeds","positiveSeedIndices","negativeSeedIndices","worldIslandPoints","runGrowCut","getRemoveIslandData","getGrowCutLabelmap","mergedOptions","growCut","RegionSegmentTool","currentWorldPoint","circleBorderPoint","circleCenterPoint","sphereInfo","segmentationData","canvasCenterPoint","canvasBorderPoint","vecCenterToBorder","getSegmentStyle","SplineContourSegmentationTool","annotationCutMergeCompletedBinded","annotationCutMergeCompleted","initializeListeners","removeListeners","splineToolNames","simplifiedSpline","convertContourSegmentationAnnotation","DEFAULT_SPLINE_CONFIG","controlPointAdditionDistance","controlPointDeletionDistance","showControlPointsConnectors","controlPointAdditionEnabled","controlPointDeletionEnabled","SplineTypesEnum","SplineToolActions","SplineROITool","SplineTypes","spline","Cardinal","Class","CatmullRom","Linear","BSpline","drawPreviewEnabled","enableTwoPointPreview","lastControlPointDeletionKeys","AddControlPoint","DeleteControlPoint","Ctrl","fireChangeOnUpdate","isPointNearCurve","_keyDownCallback","controlPointIndex","_deleteControlPointByIndex","closeContour","addNewPoint","closestControlPoint","getClosestControlPointWithinDistance","moveAnnotation","addControlPointCallback","splineType","splineConfig","_getSplineConfig","closestPointInfo","getClosestPoint","addControlPointAtU","uValue","deleteControlPointCallback","annotationCompletedBinded","annotationCompleted","cancelAnnotation","annotationLocked","childAnnotations","_isSplineROIAnnotation","splinePolylineCanvas","_updateSplineInstance","getPolylinePoints","updateWindingDirection","numControlPoints","previewPolylinePoints","getPreviewPolylinePoints","controlPointsConnectors","createInterpolatedSplineControl","increment","isSplineAnnotation","createSplineObjectFromType","contourAnnotation","createSpline","onInterpolationComplete","splineConfigs","setControlPoints","fixedResolution","fixedScale","splineInstance","SplineClass","UltrasoundDirectionalTool","displayBothAxesDistances","startedDrawing","lineSegment","xValues","yValues","isHorizontal","isUnitless","drawHandle","canvasDeltaY","canvasDeltaX","projectedPointCanvas","imageIndex1","imageIndex2","values1","values2","transformIndexToWorld","UltrasoundPleuraBLineTool","USPleuraBLineAnnotationType","BLINE","PLEURA","bLineColor","pleuraColor","drawDepthGuide","depth_ratio","depthGuideColor","depthGuideThickness","depthGuideDashLength","depthGuideDashGap","depthGuideOpacity","fanOpacity","showFanAnnotations","updatePercentageCallback","pleuraAnnotations","bLineAnnotations","annotationType","getActiveAnnotationType","newPoint","isInsideFanShape","getFanShapeGeometryParameters","fanCenter","indexToCanvasRatio","getIndexToCanvasRatio","unMergedPleuraIntervals","mergedPleuraIntervals","pleuraIntervalsDisplayed","bLineIntervalsDisplayed","drawAnnotation","getColorForLineType","lineInterval","fanNumber","interval","clippedInterval","fanDataId","drawFan","calculateBLinePleuraPercentage","activeAnnotationType","filterAnnotations","filterFunction","countAnnotations","getImageIdIndex","annotationMapping","counts","bLine","pleura","deleteAnnotations","setActiveAnnotationType","deleteLastAnnotationType","annotationList","updateFanGeometryConfiguration","fanGeometry","isFanShapeGeometryParametersValid","deriveFanGeometryFromViewport","calculateFanGeometry","pleuraIntervals","bLineIntervals","diffVector","radToDegree","rad","degreeToRad","indexToCanvas","depth_radius","theta_start","theta_range","arc_length","num_dashes","theta_step","theta1","theta2","start_point","end_point","calculateFanShapeCorners","imageBuffer","hull","roughContour","rough","slack","next","walk","to","i2","i3","P2","P3","pathA","pathB","globalYmin","upperPath","topY","arcPts","P1","best","P4","pickPoints","refined","edgeBuf","opts","directions","snapQuadrant","pt","xmin","xmax","ymin","ymax","xi","yi","xAlign","yAlign","refineCornersDirectional","step","angleRad","deriveFanGeometry","params","centerResult","intersectLine","tempAngle","d1","d4","d2","d3","exportContourJpeg","pixelData","strokeStyle","quality","ctx","getContext","totalPixels","channels","imgData","createImageData","out","baseIn","baseOut","putImageData","beginPath","moveTo","lineTo","toDataURL","getPixelData","saveBinaryData","filename","href","download","body","click","downloadFanJpeg","contourType","jpegDataUrl","fan","startAngleInDegrees","endAngleInDegrees","exportFanJpeg","generateConvexHullFromContour","segmentLargestUSOutlineFromBuffer","channelCount","mask","isForeground","labels","currentLabel","regionSizes","getter","px","py","pixelCount","onFlood","diagonals","floodFill","largestLabel","isBorder","nx","ny","outer","dirs","current","prev","dx0","dy0","startDir","nextPt","bdx","bdy","VideoRedactionTool","toolConfiguration","viewportUIDsToRender","toolDataCanvasCoordinate","rect","_getRectangleImageCoordinates","bottomLeftWorld","topRightWorld","point0","viewportUID","renderingEngineUID","sceneUID","targetUIDs","targetUID","_getImageVolumeFromTargetUID","worldPos1Index","worldPos2Index","worldToIndexVec3","iMin","iMax","jMin","jMax","kMin","kMax","yMultiple","zMultiple","valueMinusMean","_getTargetVolumeUID","scene","volumeUID","getVolumeActors","coloneIndex","substring","_getTargetStackUID","NEGATIVE_PIXEL_RANGE","POSITIVE_PIXEL_RANGE","ISLAND_PIXEL_RANGE","WholeBodySegmentTool","positivePixelRange","negativePixelRange","islandPixelRange","linePoints","_getHorizontalLineWorldPoints","horizontalLines","worldLine1P1","worldLine1P2","worldLine2P1","worldLine2P2","worldSquarePoints","referencedVolume","worldTopLeft","worldBottomRight","_getWorldBoundingBoxFromProjectedSquare","boundingBoxInfo","ijkTopLeft","ijkBottomRight","positiveSeedValue","negativeSeedValue","labelmapVolumeId","labelmapVolume","referencedVolumeData","getCompleteScalarDataArray","islandPointIndexes","pixelValue","_projectWorldPointAcrossSlices","worldEdgePoint","vecDirection","_getViewportVolume","ijkLineP1","ijkLineP2","_getCuboidIJKEdgePointsFromProjectedWorldPoint","_getWorldCuboidCornerPoints","cuboidPoints","worldSquarePoint","worldEdgePoints","worldCuboidPoints","_getHorizontalLineIJKPoints","ijkPoint1","ijkPoint2","TRANSFORM_MATRIX","getTransformMatrix","CardinalSpline","props","_scale","_fixedScale","s2","CatmullRomSpline","CubicSpline","getPreviewCurveSegments","controlPointPreview","closeSpline","previewNumCurveSegments","_getNumCurveSegments","startCurveSegIndex","endCurveSegIndex","transformMatrix","curveSegments","curveSegment","_getCurveSegment","getSplineCurves","numCurveSegments","previousCurveSegmentsLength","_getPoint","uInt","curveSegmentIndex","p0","p3","_getCurveSegmentPoints","tt","ttt","tValues","qValues","p0Index","p2Index","p3Index","_getLineSegments","numLineSegments","inc","maxU","lineSegments","previousLineSegmentsLength","aabb","curveSegmentLength","lineSegAABB","lineSegLength","LinearSpline","QuadraticBezier","hasTangentPoints","QuadraticSpline","getLineSegments","Spline","_controlPoints","_invalidated","_length","_resolution","_fixedResolution","_closed","_update","_aabb","addControlPoints","_getLineSegmentAt","_curveSegments","controlPointPos","deleteControlPointByIndex","minControlPoints","clearControlPoints","updateControlPoint","newControlPoint","controlPoint","getClosestControlPoint","minSquaredDist","closestPointIndex","squaredDist","curveSegmentsDistInfo","_getCurveSegmmentsDistanceSquaredInfo","closestPoint","csA","csB","distanceSquared","minDistCurveSegment","minDistLineSegment","closestPointCurveSegmentIndex","minDistSquared","curveSegmentDistInfo","lineSegPoint","lineSegDistSquared","getClosestPointOnControlPointLines","_convertCurveSegmentsToPolyline","closeDistance","previewCurveSegments","_getCurveSegmmentsWithinDistance","maxDistSquared","containsPoint","closingCurveSegment","_getClosingCurveSegmentWithStraightLineSegment","numIntersections","curveSegAABB","lineSegmentAABB","isVerticalLine","xIntersection","curveSegLength","polylinePoints","curveSegIndex","lineSegIndex","curveSegmentsDistanceSquared","curveSegmentsDistance","curveSegmentsWithinRange","curveSegmentDistSquared","pointLength","lengthEnd","startControlPoint","endControlPoint","closingLineSegment","AnnotationDisplayTool","arguments","frameOfReference","annotationBaseData","baseData","viewReference","DefaultHistoryMemo","BaseTool","defaults","strategies","defaultStrategy","activeStrategy","strategyOptions","mergedDefaults","initialProps","defaultProps","additionalProps","applyActiveStrategy","operationData","call","applyActiveStrategyCallback","callbackType","extraArgs","setConfiguration","newConfiguration","getViewReferenceId","createZoomPanMemo","zoom","zoomPanMemo","restoreMemo","currentPan","currentZoom","commitMemo","polySegConversionInProgressForViewportId","processedViewportSegmentations","contourRepresentation","canComputeRequestedRepresentation","computeContourData","hasContourDataButNotMatchingViewport","viewportNormal","uidSet","randomAnnotationUIDs","annotationNormal","_checkContourNormalsMatchViewport","validGeometry","geometryData","contours","ceil","_checkContourGeometryMatchViewport","viewportProcessed","viewportStatus","RENDERED","computeSurfaceData","pointsAndPolys","polys","polyDataCache","clipAndCacheSurfacesForViewport","rawResults","extractContourData","createAndAddContourSegmentationsFromClippedSurfaces","renderImmediate","labelMapConfigCache","polySegConversionInProgress","_setLabelmapColorAndOpacity","labelmapActorEntry","activeSegmentation","isActiveLabelmap","labelmapStyle","numColors","outlineWidth","renderOutline","outlineOpacity","activeSegmentOutlineWidthDelta","_getLabelmapConfig","segmentsHidden","segmentColor","segmentSpecificLabelmapConfig","fillAlpha","renderFill","forceOpacityUpdate","forceColorUpdate","_needsTransferFunctionUpdate","addRGBPoint","segmentOpacity","removePoint","addPointLong","setClamping","labelmapActor","preLoad","setRGBTransferFunction","setScalarOpacity","setInterpolationTypeToNearest","setUseLabelOutline","setLabelOutlineOpacity","outlineWidths","setLabelOutlineThickness","labelmapConfig","segmentsLabelmapConfig","configToUse","fillAlphaInactive","outlineWidthInactive","renderFillInactive","renderOutlineInactive","outlineOpacityInactive","cacheUID","oldConfig","cfunMTime","getMTime","ofunMTime","oldFillAlpha","oldRenderFill","oldRenderOutline","oldOutlineWidth","oldSegmentColor","oldSegmentsHidden","oldCfunMTime","oldOfunMTime","_addLabelmapToViewport","labelmapActorEntries","computeLabelmapData","updateSurfaceData","SurfaceData","surfaces","isHidden","surface","BrushTool","FILL_INSIDE_CIRCLE","ERASE_INSIDE_CIRCLE","FILL_INSIDE_SPHERE","ERASE_INSIDE_SPHERE","THRESHOLD_INSIDE_CIRCLE","THRESHOLD_INSIDE_SPHERE","THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL","brushSize","useCenterSegmentIndex","preview","previewColors","previewTimeMs","previewMoveDistance","dragMoveDistance","dragTimeMs","StrategyCallbacks","AcceptPreview","RejectPreview","Interpolate","useBallStructuringElement","noUseDistanceTransform","noUseExtrapolation","interpolateExtrapolation","_lastDragInfo","_editData","createEditData","_previewData","isDrag","timerStart","Date","now","hoverData","_hoverData","createHoverData","getOperationData","OnInteractionStart","timer","time","rejectPreview","previewCallback","strategyData","strategy","segmentationVoxelManager","Preview","startWorld","currentCanvas","currentWorld","_calculateCursor","strokePointsWorld","currentCanvasClone","OnInteractionEnd","acceptPreview","viewRight","centerCursorInWorld","bottomCursorInWorld","topCursorInWorld","leftCursorInWorld","rightCursorInWorld","brushCursor","computeInnerCircleRadius","GetStatistics","interpolate","invalidateBrushCursor","getActiveSegmentationData","toolMetadata","brushCursorUID","centerSegmentIndexInfo","dynamicRadiusInCanvas","circleUID1","CircleROIStartEndThresholdTool","numSlicesToPropagate","calculatePointsInsideVolume","showTextBox","throttleTimeout","spacingInNormal","startCoord","_getStartCoordinate","endCoord","_getEndCoordinate","startCoordinate","endCoordinate","pointsInVolume","projectionPoints","statistics","labelmapUID","_computeProjectionPoints","_computePointsInsideVolume","filterAnnotationsWithinSamePlane","annotationEnabledElement","viewplaneNormal","tempStartCoordinate","tempEndCoordinate","_getCoordinateForViewplaneNormal","roundedStartCoordinate","roundedEndCoordinate","cameraCoordinate","roundedCameraCoordinate","middleCoordinate","isMiddleSlice","_getIndexOfCoordinatesForViewplaneNormal","iteratorVolumeIDs","lineWidthToUse","lineDashToUse","_calculateCachedStatsTool","projectionAxisIndex","endWorld","handlesOnStartPlane","handlesToStart","newProjectionPoints","pointsInsideVolume","baseTopLeftCanvas","baseBottomRightCanvas","basePos1","basePos2","measureInfo","modalityUnitOptions","currentCanvasCoordinates","worldProjectionPointIndex","indexOfProjection","numSlicesToPropagateFromStart","numSlicesToPropagateToEnd","endPos","viewplaneNormalAbs","_context","CircleScissorsTool","FILL_INSIDE","ERASE_INSIDE","activeLabelmapSegmentation","segmentsLocked","segmentLocking","segmentationImageId","LabelMapEditWithContourTool","annotationsToViewportMap","viewportIdsChecked","allowOpenContours","onViewportAddedToToolGroupBinded","onViewportAddedToToolGroup","onSegmentationModifiedBinded","onSegmentationModified","annotationModified","cleanUpListeners","checkContourSegmentation","activeSeg","viewportContoursToLabelmap","isEqual","PaintFillTool","activeSegmentationRepresentation","currentSegmentationImageId","getDirection","fixedDimension","getFixedDimension","floodFillGetter","getLabelValue","getScalarDataPositionFromPlane","inPlaneSeedPoint","fixedDimensionValue","generateHelpers","clickedLabelValue","floodFillResult","flooded","scalarDataIndex","framesModified","getFramesModified","boundaries","minJ","maxJ","seedIndex3D","getAtIJK","generateFloodFillGetter","generateGetScalarDataPositionFromPlane","toIndex","getScalarDataPosition","xDirection","yDirection","zDirection","absoluteOfViewPlaneNormal","absoluteOfXDirection","absoluteOfYDirection","absoluteOfZDirection","RectangleROIStartEndThresholdTool","projectionPointsImageIds","indexOfDirection","roundedStartCoord","roundedEndCoord","coord","roundedCoord","firstOrLastSlice","startIJK","endIJK","indexToWorldVec3","habdles","projectionPoint","RectangleROIThresholdTool","RectangleScissorsTool","SegmentBidirectionalTool","existingAnnotation","SegmentLabelTool","hoverTimeout","searchRadius","hoverTimer","_setHoveredSegment","_setHoveredSegmentForType","hoveredSegmentIndex","getSegmentIndexAtWorldPoint","hoveredSegmentLabel","SegmentSelectTool","SelectMode","Inside","Border","_setActiveSegment","_setActiveSegmentForType","getSegmentIndexAtLabelmapBorder","getHoveredContourSegmentationAnnotation","SphereScissorsTool","getEditData","EnsureImageVolumeFor3DManipulation","referencedImageIds","imageVoxelManager","EnsureSegmentationVolumeFor3DManipulation","segImageIds","segVolume","getEllipseCornersFromCanvasCoordinates","initializeCircle","Initialize","centerIJK","brushRadius","cornersInWorld","normalizedViewUp","normalizedPlaneNormal","strokeCenters","strokeCornersWorld","centerVec","createCircleCornersForCenter","circleCornersIJK","getBoundingBoxAroundShapeIJK","createPointInEllipse","isInObjectBoundsIJK","majorAxisVec","minorAxisVec","radiusForStroke","strokePredicate","centers","radiusSquared","centerVecs","lengthSquared","vector","projX","projY","projZ","distX","distY","distZ","createStrokePredicate","sphereObj","radius2","pointIJK","pointVec","distToPlane","proj","fromTopLeft","centerToTopLeft","CIRCLE_STRATEGY","regionFill","setValue","determineSegmentIndex","labelmapStatistics","CIRCLE_THRESHOLD_STRATEGY","dynamicThreshold","fillInsideCircle","strategyFunction","thresholdInsideCircle","fillOutsideCircle","initializeRectangle","pointInShapeFn","rectangleCornersIJK","axisU","axisV","uLen","vLen","EPS","vproj","createPointInRectangle","RECTANGLE_STRATEGY","RECTANGLE_THRESHOLD_STRATEGY","fillInsideRectangle","thresholdInsideRectangle","getStrategyData","CustomEvent","ERROR_EVENT","message","cancelable","dispatchEvent","segmentationScalarData","imageScalarData","getStrategyDataForVolumeViewport","ensureSegmentationVolumeFor3DManipulation","currentSegImage","ensureImageVolumeFor3DManipulation","getStrategyDataForStackViewport","ContourWindingDirection","AnnotationMultiSlice","setStartRange","startRange","setRange","setEndRange","endRange","rangeEndSliceIndex","getSliceIndexForImage","multiSliceReference","MetadataReferenceModified","setViewportFrameRange","setSingle","getFrameRange","getFrameRangeStr","setFrameRange","annotationHydration","worldPoints","getClosestImageIdForStackViewport","getClassName","getTargetVolumeId","distanceImagePairs","ImagePositionPatient","dir","calculateDistanceToImage","numSlicesToProject","sliceNormalIndex","calculateBoundingBox","isWorld","is3D","getBoundingBoxAroundShapeWorld","clipBounds","calibratedPixelSpacingMetadataProvider","calibrateImageSpacing","calibrationOrScale","USER","calibrateSpacing","ViewportStatus","debounced","dynamicVolumesPlayingMap","playClip","playClipOptions","playClipTimeouts","playClipIsTimeVarying","dynamicCineEnabled","playClipContext","waitForRendered","numScrollSteps","currentStepIndex","getTargetImageIdIndex","frameTimeVectorEnabled","waitForRenderedCount","_createStackViewportCinePlayContext","_getVolumeFromViewport","isDynamicVolume","numDimensionGroups","dimensionGroupNumber","_createDynamicVolumeViewportCinePlayContext","cachedScrollInfo","scrollInfo","getScrollInfo","volumeViewPlaneNormal","_createVolumeViewportCinePlayContext","VideoViewport","getSliceIndex","play","fps","setPlaybackRate","getFrameRate","_createVideoViewportCinePlayContext","_createCinePlayContext","playClipData","isDynamicCinePlaying","_stopDynamicVolumeCine","_stopClip","stopDynamicCine","intervalId","framesPerSecond","lastFrameTimeStamp","ignoreFrameTimeVector","usingFrameTimeVector","frameTimeVector","speed","frameTimeVectorSpeedMultiplier","bounce","timeouts","isTimeVarying","sample","delay","sum","limit","_getPlayClipTimeouts","playClipAction","newStepIndex","CLIP_STOPPED","_stopClipWithData","playClipTimeoutHandler","setInterval","CLIP_STARTED","stopClip","toolState","pause","dynamicCineElement","clearInterval","dynamicVolumeId","addToolState","getToolState","getToolStateByViewportId","addContourSegmentationAnnotation","firstAnnotation","secondAnnotation","firstSegmentation","secondSegmentation","areViewReferencesEqual","contourSegmentationOperation","sourceAnnotationOrUID","targetAnnotationOrUID","getViewportFromAnnotation","intersectionInfo","hasIntersection","copyAnnotation","copyContourSegment","targetSegmentIndex","targetAnnotationUIDsMap","copyContourAnnotation","newAnnotationsUID","newChildAnnotation","findAllIntersectingContours","sourceAABB","targetAABB","lineSegmentsIntersect","projectedPolyline","getViewReferenceFromAnnotation","DEFAULT_CONTOUR_SEG_TOOL_NAME","endPointWorld","originalToolName","interpolationUID","interpolationCompleted","DEFAULT_CONTOUR_SEG_TOOLNAME","LogicalOperation","getPolylinesInfoWorld","polylinesInfo","annotationUIDList","applyLogicalOperation","segment1","segment2","operation","polyLinesInfoCanvas1","polyLinesInfoCanvas2","segmentation1","segmentation2","polyLinesInfoWorld1","polyLinesInfoWorld2","extractPolylinesInCanvasSpace","polylinesMerged","Union","Subtract","Intersect","XOR","polyLinesWorld","resultSegment","existingAnnotationUIDs","currentSet","addPolylinesToSegmentation","segmentData","addSegmentInSegmentation","subtract","intersect","xor","copy","deleteOperation","processMultipleIntersections","holeOperations","mergeOperations","primaryHoleTarget","holeAnnotation","holeContour","holePolylineCanvas","windingDirection","CounterClockwise","createPolylineHole","updateViewportsForAnnotations","allAnnotationsToRemove","allResultPolylines","allHoles","holes","getContourHolesData","sourceStartPoint","shouldMerge","resultPolyline","subtractedPolylines","holeData","baseAnnotation","newAnnotations","createNewAnnotationFromPolyline","parentPolyline","reassignHolesToNewAnnotations","processSequentialIntersections","updatedToolNames","intersectPolylinesSets","set1","set2","polyA","polyB","intersectionRegions","intersectPolylines","region","subtractPolylineSets","polylinesSetA","polylinesSetB","currentPolylines","polylineB","newPolylines","currentPolyline","subtractedPolyline","cleaned","subtractMultiplePolylineSets","basePolylineSet","subtractorSets","subtractAnnotationPolylines","baseAnnotations","subtractorAnnotations","unifyPolylineSets","processedFromA","processedFromB","polylineA","merged","mergedPolyline","unifyMultiplePolylineSets","polylineSets","unifyAnnotationPolylines","annotationsSetA","annotationsSetB","xorPolylinesSets","allIdentical","foundMatch","TOLERANCE","convertContourPolylineToWorld","checkIntersection","combinePolylines","mergePolylines","contourHolesData","unassignedContourHolesSet","reassignedContourHolesMap","assignHoleToPolyline","newPolyline","contourHolesDataArray","contourHoleData","templateAnnotation","removeDuplicatePoints","cleanupPolylines","validPolylines","seenPolylines","polylineKey","AnnotationToPointData","TOOL_NAMES","convert","metadataProvider","validateAnnotation","contourSequence","getContourSequence","random","ReferencedROINumber","ROIDisplayColor","ContourSequence","findNextLink","contourPoints","cell","nextLine","remainingLines","findContours","firstCell","extraContours","findContoursFromReducedSet","findHandlePolylineIndex","closestDistance","testIndex","findIslands","islandIndexes","getSignedArea","getContourHolesDataCanvas","worldHoleContours","canvasHoleContours","worldHoleContour","canvasHoleContour","getContourHolesDataWorld","getDeduplicatedVTKPolyDataPoints","bypass","getLines","pointsArray","getNumberOfPoints","_","getPoint","linesArray","getNumberOfCells","getCell","newPoints","newIndex","areCoplanarContours","firstViewPlaneNormal","secondViewPlaneNormal","firstPolyline","secondPolyline","firstDistance","secondDistance","processContourHoles","useXOR","retContours","closedContours","contourWithHoles","contourWithoutHoles","hContour","outerContour","innerContour","vertices","pointsNotEnclosed","inside","xj","yj","getIsPointInsidePolygon","checkEnclosed","contourHoleSet","holeIndex","isPolygonInsidePolygon","inner","containsPoints","closedPolylines","originalIndex","outerArea","potentialHole","generateContourSetsFromLabelmap","registerComputeWorker","WorkerTypes","GENERATE_CONTOUR_SETS","segVolumeId","getOrCreateSegmentationVolume","vol","segmentationInfo","contourSets","getWebWorkerManager","executeTask","refImages","refImageId","refImageDataMetadata","processedContourSets","contourSet","sliceContours","refImageIndex","imageDataMetadata","scanAxisNormal","FrameNumber","acceptAutogeneratedInterpolations","selector","InterpolationManager","acceptAutoGenerated","polylineData","transforms","polylineWorldPoints","currentClosedState","lastToFirstDist","updatedWindingDirection","sumOverDimensionGroups","dimensionGroups","arrayLength","getScalarDataLength","resultArray","getDimensionGroupScalarData","operationFunctions","SUM","AVERAGE","sumArray","averageOverDimensionGroups","SUBTRACT","scalarData1","scalarData2","generateImageFromTimeData","dynamicVolume","dimensionGroupNumbers","frameNumbers","operationFunction","updateVolumeFromTimeData","targetVolume","targetVoxelManager","resetModifiedSlices","modifiedSlices","maskVolumeId","worldCoordinate","dataInTime","ijkCoords","maskImageData","segVoxelManager","scalarDataLength","nonZeroVoxelIndices","actualLen","getAtIndex","nonZeroVoxelValuesInTime","isSameVolume","valuesInTime","getAtIndexAndDimensionGroup","toIJK","segPointLPS","segValue","segPointIJK","overlapIJKMinMax","perDimensionGroupSum","averageCallback","averageValues","_getDimensionGroupDataMask","coordinate","worldToIndex","scalarIndex","_getDimensionGroupDataCoordinate","getAnnotationNearPoint","getAnnotationNearPointOnEnabledElement","found","findAnnotationNearPointByTool","currentId","CalibrationTypes","PIXEL_UNITS","VOXEL_UNITS","SUPPORTED_REGION_DATA_TYPES","SUPPORTED_LENGTH_VARIANT","SUPPORTED_PROBE_VARIANT","UNIT_MAPPING","SQUARE","calibration","hasPixelSpacing","volumeUnit","calibrationType","sequenceOfUltrasoundRegions","UNCALIBRATED","regions","regionLocationMinX0","regionLocationMaxX1","regionLocationMinY0","regionLocationMaxY1","regionDataType","physicalUnitsXDirection","physicalUnitsYDirection","physicalDeltaX","physicalDeltaY","ERMF","ERROR","PROJECTION","CALIBRATED","getCalibratedProbeUnitsAndValue","supportedRegionsMetadata","referencePixelX0","referencePixelY0","yValue","getCalibratedAspect","getPixelValueUnitsImageId","getPixelValueUnits","generalSeriesModule","petSeriesModule","_handlePTModality","_getSphereBoundsInfo","circlePoints","directionVectors","radiusWorld","row","rowCosine","column","columnCosine","vecNormal","topLeftIJK","bottomRightIJK","pointsIJK","_computeBoundsIJK","getSphereBoundsInfo","scanAxis","getSphereBoundsInfoFromViewport","getEnabledElements","roundNumber","arePolylinesIdentical","poly1","poly2","identicalForward","identicalReverse","cyclicForward","cyclicReverse","numPoint","DEFAULT_EPSILON","epsilonSquared","partitionQueue","polylinePointFlags","numDecimatedPoints","startIndex","endIndex","maxDistIndex","decimatedPolyline","srcIndex","dstIndex","refPoint","aX","aY","bX","numPolylinePoints","distFirstToLastPoints","distanceToPointSquared","findClosestPoint","sourcePoints","minDistance","MAX_SAFE_INTEGER","sourcePoint","_distanceBetween","moveAnnotationToViewPlane","projectedDistance","acquisitionMapping","ijkPrime","fromIJK","jkMapping","ikMapping","normalizeViewportPlane","boundsIJKPrime","mapping","getOrientationStringLPS","orientationX","orientationY","orientationZ","MIN","invertOrientationStringLPS","orientationString","inverted","smoothAnnotation","interpolateSegmentPoints","iniIndex","segmentSize","amountOfKnots","minKnotDistance","interpolationIniIndex","interpolationEndIndex","segmentPointsUnchangedBeg","segmentPointsUnchangedEnd","knotsIndexes","minDistributionDistance","closedInterval","intervalIni","intervalEnd","intervalSize","continuosDistributionValue","getContinuousUniformDistributionValues","pointInSurroundingSphereCallback","spacings","maxRadiusIJK","sphereCornersIJK","getBoundingBoxAroundShape","_computeBoundsIJKWithCamera","_getBounds","createScalarVolumeVoxelManager","pointToString","decimals","idx3","getPolyDataPointIndexes","linesData","findStartingPoint","nextPoint","getPolyDataPoints","contoursIndexes","rawPointsData","contourIndexes","referenceVolume","AllBoundsIJK","pointsToUse","g","accumulator","axisList","isAxisAlignedRectangle","rectangleVec1","rectangleVec2","calculateAnglesWithAxes","vec","registered","workerManager","computeWorkerConfig","computeWorker","maxWorkerInstances","autoTerminateOnIdle","idleTimeThreshold","registerWorker","Worker","uuidv4","ChangeTypesForInterpolation","toolNames","sliceData","getSliceData","hasInterpolationUID","filterData","parentKey","interpolationAnnotations","skipUIDs","interpolationAnnotation","isInterpolationUpdate","SegmentStatsCalculator","calculators","statsInit","statsData","calculator","volumetricStatsCallback","maxIJKs","dataCopy","volumetricGetStatistics","volumeScale","entry","VolumetricCalculator","volumetricState","optionsWithUnit","InstanceVolumetricCalculator","setBrushSizeForToolGroup","newBrushSize","getBrushSizeForToolGroup","toolInstances","brushToolInstance","setBrushThresholdForToolGroup","getBrushThresholdForToolGroup","computeMetabolicStats","segmentationIds","COMPUTE_STATISTICS","labelmapVolumes","mergedLabelmap","createMergedLabelmapForIndex","referenceImageIds","labelmap","firstImage","volumeInfo","getVolumeContainingImageId","getOrCreateImageVolume","getReferenceVolumeForSegmentation","imageInfo","calculateForVolume","contourAndFindLargestBidirectional","containedSegmentIndices","createBidirectionalToolData","bidirectionalData","VoxelManager","RLEVoxelMap","createLabelmapMemo","createRleMemo","isUndo","undoVoxelManager","redoVoxelManager","useVoxelManager","setAtIJKPoint","slices","getArrayOfModifiedSlices","createRLEHistoryVoxelManager","operationType","copyMap","createRLEVolumeVoxelManager","createLabelmapVolumeForViewport","labelmaps","outputData","cachedVolume","mergedVolume","setCompleteScalarDataArray","findLargestBidirectional","maxBidirectional","isInSegment","sliceContour","bidirectional","createBidirectionalForSlice","currentMax","maxMajor","maxMinor","currentMaxMinor","currentMaxMajor","maxMajorPoints","distance2","testCenter","handle0","handle1","unitMajor","maxMinorPoints","lpad","string","character","seed","onBoundary","equals","startNode","permutations","perms","permutation","permute","perm","countNonZeroes","prunedPermutations","stack","visits","currentArgs","flood","job","getArgs","prevArgs","previousArgs","visited","iKey","markAsVisited","node","member","markAsFlooded","nextArgs","pushAdjacent","markAsBoundary","getBrushToolInstances","generateVolumeId","getReferenceVolumeForSegmentationVolume","segmentationVolumeId","indexIJK","onEdge","getNeighborIndex","deltaI","deltaJ","neighborCanvas","isSegmentOnEdge","isSegmentOnEdgeCanvas","segmentationActorEntry","deltaK","neighborIJK","isSegmentOnEdgeIJK","neighborRange","neighborIndex","desiredRepresentation","getScalarValueFromWorld","getSegmentIndexAtWorldForLabelmap","annotationsSet","isPointInsidePolyline3D","getSegmentIndexAtWorldForContour","getSegmentLargestBidirectional","COMPUTE_LARGEST_BIDIRECTIONAL","segData","reconstructableVolume","calculateVolumeBidirectional","isStack","calculateStackBidirectional","radiusForVol1","updateStatsArray","newStat","existingIndex","stat","processSegmentationStatistics","radiusIJK","testMax","testStats","getSphereStats","peakValue","peakPoint","mtv","suvMean","lesionGlycolysis","imageVoxels","centerLPS","_pointLPS","boundsOrig","finalStats","calculateVolumeStatistics","calculateStackStatistics","getUniqueSegmentIndices","cachedResult","keySet","addImageSegmentIndices","addVolumeSegmentIndices","handleLabelmapSegmentation","handleContourSegmentation","handleSurfaceSegmentation","WEBGPU_MEMORY_LIMIT","DEFAULT_GROWCUT_OPTIONS","windowSize","maxProcessingTime","inspection","numCyclesInterval","numCyclesBelowThreshold","referenceVolumeId","workGroupSize","numIterations","volumePixelData","requiredLimits","maxStorageBufferBindingSize","maxBufferSize","adapter","navigator","gpu","requestAdapter","device","requestDevice","BUFFER_SIZE","byteLength","UPDATED_VOXELS_COUNTER_BUFFER_SIZE","Uint32Array","BYTES_PER_ELEMENT","BOUNDS_BUFFER_SIZE","Int32Array","shaderModule","createShaderModule","code","paramsArrayValues","gpuParamsBuffer","createBuffer","usage","GPUBufferUsage","UNIFORM","COPY_DST","gpuVolumePixelDataBuffer","STORAGE","queue","writeBuffer","gpuLabelmapBuffers","COPY_SRC","gpuStrengthBuffers","gpuCounterBuffer","gpuBoundsBuffer","initialBounds","bindGroupLayout","createBindGroupLayout","GPUShaderStage","COMPUTE","bindGroups","outputLabelmapBuffer","outputStrengthBuffer","previouLabelmapBuffer","previousStrengthBuffer","createBindGroup","layout","resource","pipeline","createComputePipeline","createPipelineLayout","bindGroupLayouts","compute","module","entryPoint","constants","workGroupSizeX","workGroupSizeY","workGroupSizeZ","numWorkGroups","gpuUpdatedVoxelsCounterStagingBuffer","MAP_READ","limitProcessingTime","performance","currentInspectionNumCyclesInterval","belowThresholdCounter","commandEncoder","createCommandEncoder","passEncoder","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","copyBufferToBuffer","submit","finish","mapAsync","GPUMapMode","READ","updatedVoxelsCounterResultBuffer","getMappedRange","updatedVoxelsRatio","unmap","outputLabelmapBufferIndex","labelmapStagingBuffer","boundsStagingBuffer","labelmapResultBuffer","labelmapResult","boundsResultBuffer","boundsResult","minZ","maxZ","clearBounds","setBounds","POSITIVE_SEED_VALUE","NEGATIVE_SEED_VALUE","_createAndCacheSegmentationSubVolumeForBoundingBox","subVolume","subVolPixelData","startSliceIndex","stopSliceIndex","pixelsPerSlice","zOffset","_setPositiveSeedValues","sliceOffset","bfs","slicePixelIndex","volumeVoxelIndex","volumeVoxelValue","scanLine","limitX","incX","_setNegativeSeedValues","runGrowCutForBoundingBox","subVolumeBoundsIJK","targetBuffer","POSITIVE_SEED_VARIANCE","NEGATIVE_SEED_VARIANCE","vecColumn","sphereCenterPoint","refVolImageData","topCirclePoint","bottomCirclePoint","sphereBoundsInfo","_getGrowCutSphereBoundsInfo","_createAndCacheSegmentationSubVolumeForSphere","refVolumePixelData","worldStartPos","numPixelsPerSlice","ijkStartPosition","referencePixelValue","positiveSeedVarianceValue","minPositivePixelValue","maxPositivePixelValue","neighborsCoordDelta","startVoxelIndex","ijkVoxel","neighborCoordDelta","nz","neighborVoxelIndex","neighborPixelValue","worldVecRowDir","worldVecSliceDir","ijkSphereCenter","negativeSeedVarianceValue","minNegativePixelValue","maxNegativePixelValue","rotationAngle","worldQuat","vecRotation","worldCircleBorderPoint","ijkCircleBorderPoint","runGrowCutForSphere","ijkVecRowDir","ijkVecColDir","sphereBoundsIJK","_createSubVolumeFromSphere","MAX_POSITIVE_SEEDS","calculateGrowCutSeeds","refImageData","referenceVolumeVoxelManager","neighborhoodRadius","initialNeighborhoodRadius","positiveK","positiveStdDevMultiplier","negativeK","negativeStdDevMultiplier","negativeSeedMargin","negativeSeedsTargetPatches","ijkStart","initialStats","positiveIntensityMin","positiveIntensityMax","startValue","currentQueueIndex","neighborValue","positiveSum","positiveSumSq","positiveCount","positiveMean","positiveVariance","negativeDiffThreshold","minXm","minYm","minZm","maxXm","maxYm","maxZm","attempts","patchesAdded","maxAttempts","rz","centerIndex","centerValue","patchContributed","runOneClickGrowCut","positiveSeedLabel","negativeSeedLabel","isLineInSegment","ijk1","ijk2","testIJK","testSize","unitDelta","createIsInSegment","createIsInSegmentMetadata","SegmentationEnum","IslandRemoval","fillInternalEdge","maxInternalRemove","initialize","segmentationVoxels","hasSource","sourceVoxelManager","previewVoxelManager","previewSegmentIndex","clickedPoints","getBoundsIJK","bound","depth","segmentSet","fillFrom","oldVal","SEGMENT","normalizer","selectedPoints","floodFillSegmentIsland","floodedCount","clickedPoint","iPrime","jPrime","kPrime","ISLAND","removeExternalIslands","rle","clearPoint","rowModified","removeInternalIslands","forEachRow","baseIndex","lastRle","INTERIOR","rowPrev","getRun","rowNext","isLast","isFirst","prevCovers","covers","nextCovers","EXTERIOR","singlePlane","newType","INTERIOR_TEST","INTERIOR_SMALL","rowRle","thresholdVolumeInformation","validToolNames","_validateAnnotations","outputSegmentationVolume","segmentContourAction","configurationData","getSegment","defaultGetSegment","segmentationsList","bidirectionals","hasExistingActiveSegment","existingLargestBidirectionals","existingBidirectionalItem","newBidirectional","existingLargestBidirectional","updateSegment","bidirectionalToolData","segmentationIndex","overlapType","baseVolumeIdx","volumeInfoList","refVoxelManager","volumeSize","_handleSameSizeVolume","overlaps","segScalarDataLength","overlapBounds","callbackOverlap","overlapTest","_handleDifferentSizeVolume","testOverlapRange","voxelSpacing","voxelCenter","testRange","insert","equalsCheck","getVoxelOverlap","halfSpacingX","halfSpacingY","halfSpacingZ","voxelCornersIJK","offsets","xOff","yOff","zOff","processVolumes","segmentationSpacing","segmentIndicesCache","setSegmentationDirty","cached","isDirty","getCachedSegmentIndices","setCachedSegmentIndices","triggerWorkerProgress","workerType","progress","WEB_WORKER_PROGRESS","getSegmentationDataForWorker","refImageIds","prepareVolumeStrategyDataForWorker","prepareStackDataForWorker","segImageId","segImage","segPixelData","refImage","refPixelData","refSpacing","getImageReferenceInfo","cachedImage","scalingModule","validateRepresentationData","segmentationRepresentationData","validatePublic","validate","imageRetrieveMetadataProvider","resetPrefetchTimeout","maxImagesToPrefetch","minBefore","maxAfter","directionExtraImages","preserveExistingPool","priorities","prefetch","priority","stackPrefetchData","stackPrefetch","indicesToRequest","removeFromList","imageIdIndex","indicesToRequestCopy","currentImageIdIndex","getImageLoadObject","isLoaded","imageLoadPoolManager","filterRequests","requestFn","retrieveOptions","IMAGE_RETRIEVE_CONFIGURATION","imageLoader","getCachedImageBasedOnImageURI","decodeTimeInMS","loadTimeInMS","sizeInBytes","getMaxCacheSize","cacheFill","fillTime","fillSize","initialTime","initialSize","updateToolState","lastPrefetchedImageId","STACK_PREFETCH_COMPLETE","doneCallback","requestType","addRequest","onImageUpdated","stackCount","totalBytes","positionFraction","minIndex","maxIndex","promiseRemovedHandler","IMAGE_CACHE_IMAGE_REMOVED","clearRequestStack","nearest","nextImageIdIndex","lowerIndex","low","higherIndex","high","imageIdsToPrefetch","shouldLoadLower","shouldLoadHigher","indexOfCurrentImage","getDeltaPoints","curr","getMeanPoints","_subtractPoints2D","getDeltaDistance","_getDistance2D","_getDistance3D","getDeltaRotation","getDeltaDistanceBetweenIPoints","_getMeanDistanceBetweenAllIPoints","lastDistance","copyPointsList","copyPoints","getMeanTouchPoints","touch","identifier","radiusX","radiusY","force","pairedDistance","triggerAnnotationRenderForToolGroupIds","toolGroupIds","filterViewportsWithFrameOfReferenceUID","numViewports","viewportsWithFrameOfReferenceUID","vpCamera","viewportsWithToolEnabled","_toolGroupHasActiveEnabledOrPassiveTool","toolMode","DEFAULTS","MULTIPLIER","RANGE_TEXT_POSITION","Right","TICKS_BAR_SIZE","Colorbar","_isMouseOver","_isInteracting","_mouseOverCallback","showTicks","_mouseOutCallback","hideTicks","_addVOIEventListeners","initialState","multipliers","getVOIMultipliers","_getPointsFromMouseEvent","startVOIRange","local","voiLower","voiUpper","newVoiRange","_mouseUpCallback","_removeVOIEventListeners","_eventListenersManager","_colormaps","getColormapsMap","_activeColormapName","getInitialColormapName","_canvas","_createCanvas","_ticksBar","_createTicksBar","_rangeTextPosition","ticks","appendTo","rootElement","_addRootElementEventListeners","activeColormapName","colormapName","imageRange","currentVoiRange","onVoiChange","showFullImageRange","showFullPixelValueRange","reset","createRootElement","onContainerResize","updateTicksBar","containerSize","colormaps","items","Name","cm","ticksProps","clientPoint","clientX","clientY","pagePoint","pageX","pageY","getBoundingClientRect","pageXOffset","pageYOffset","containerWidth","containerHeight","ticksBar","rangeTextPosition","ticksBarTop","ticksBarLeft","Top","Left","initialDragState","defaultImageRange","ViewportColorbar","_getImageRange","_getVOIRange","autoHideTicks","_hideTicksTimeoutId","timeLeft","_hideTicksTime","_stackNewImageCallback","_element","_imageVolumeModifiedCallback","_volumeId","_viewportVOIModifiedCallback","showAndAutoHideTicks","_viewportColormapModifiedCallback","_addCornerstoneEventListener","getImageActor","minValue","maxValue","getRGBTransferFunction","ColorbarRangeTextPosition","calculateMinMaxMean","pixelLuminance","globalMin","globalMax","numPixels","spv","extractWindowLevelRegionToolData","extractImageDataVolume","getCornerstoneImage","extractImageDataStack","getLuminanceFromRegion","luminance","spIndex","red","green","blue","version","HASH_UNDEFINED","funcTag","genTag","reIsDeepProp","reIsPlainProp","reLeadingDot","rePropName","reEscapeChar","reIsHostCtor","freeGlobal","freeSelf","self","root","Function","arrayProto","funcProto","objectProto","coreJsData","maskSrcKey","exec","IE_PROTO","funcToString","objectToString","reIsNative","RegExp","getNative","nativeCreate","symbolProto","symbolToString","Hash","ListCache","MapCache","assocIndexOf","eq","baseGet","object","isSymbol","test","isKey","stringToPath","toKey","baseIsNative","isObject","func","pattern","tag","isFunction","isHostObject","toSource","getMapData","__data__","getValue","memoize","baseToString","number","quote","resolver","TypeError","memoized","apply","Cache","other","isObjectLike","exports","defaultValue"],"sourceRoot":""}