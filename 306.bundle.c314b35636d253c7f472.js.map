{"version":3,"file":"306.bundle.c314b35636d253c7f472.js","mappings":"gKAIe,SAAS,EAACA,EAAgBC,GACrC,MAAMC,EAAQF,EAAeE,MAC7B,IAAKF,EAAeG,SAAWH,EAAeE,MAC1C,OAEJ,MAAME,GAAQ,SAQd,GAPAF,EAAMG,MAAQ,CACVC,sBAAuB,EACvBC,0CAA2C,EAC3CC,sBAAuB,EACvBC,gBAAiB,EACjBC,qBAAsB,GAEtBR,EAAO,CACP,IAAIS,EAAST,EAAMS,OACdA,IAEGA,EADAX,EAAeY,SAASC,SACf,IAEJX,EAAMY,MACF,IAGA,KAGjBH,EAAOX,EAAgBC,EAC3B,CACA,MAAMc,GAAiB,SAAQX,EAC/BF,EAAMG,MAAMI,eAAiBM,EAC7Bf,EAAegB,SAAU,EACzBhB,EAAeiB,aAAc,CACjC,C,iDCnCe,SAAS,EAACjB,EAAgBkB,GACrC,MAAMC,EAAY,IAAI,IACtB,IAAKnB,EAAeY,SAASQ,cACzB,OAAOD,EAEXA,EAAUE,UAAUrB,EAAeG,OAAOmB,MAAQ,EAAGtB,EAAeG,OAAOoB,OAAS,GACpF,MAAMC,EAAQxB,EAAeY,SAASa,SACxB,IAAVD,GACAL,EAAUO,OAAQF,EAAQG,KAAKC,GAAM,KAEzC,IAAIC,EAAa7B,EAAeY,SAASM,MACrCY,EAAc9B,EAAeY,SAASM,MAC1C,MAAMI,EAAQtB,EAAeY,SAASQ,cAAcW,KAAKC,GACpDhC,EAAeY,SAASQ,cAAca,KAAKD,EAAI,GAC9CT,EAASvB,EAAeY,SAASQ,cAAcW,KAAKG,GACrDlC,EAAeY,SAASQ,cAAca,KAAKC,EAAI,GACpD,GAAmE,SAA/DlC,EAAeY,SAASQ,cAAce,qBAClCnC,EAAeE,MAAMkC,gBACrBpC,EAAeE,MAAMmC,mBACrBR,GACI7B,EAAeE,MAAMmC,mBACjBrC,EAAeE,MAAMkC,gBAExBpC,EAAeE,MAAMmC,mBAC1BrC,EAAeE,MAAMkC,kBACrBN,GACI9B,EAAeE,MAAMkC,gBACjBpC,EAAeE,MAAMmC,yBAMjC,GAFAR,EAAa7B,EAAeY,SAASQ,cAAciB,mBACnDP,EAAc9B,EAAeY,SAASQ,cAAcgB,gBAEhD,iBADApC,EAAeY,SAASQ,cAAce,qBACtB,CAChB,MAAMG,EAAgBtC,EAAeG,OAAOoB,QAAUA,EAASO,GACzDS,EAAkBvC,EAAeG,OAAOmB,OAASA,EAAQO,GAC/DA,EAAaC,EAAcH,KAAKa,IAAID,EAAiBD,GACjDtC,EAAeY,SAASQ,cAAcgB,gBACtCpC,EAAeY,SAASQ,cAAciB,mBACtCR,GACI7B,EAAeY,SAASQ,cAAciB,mBAClCrC,EAAeY,SAASQ,cAAcgB,gBAEzCpC,EAAeY,SAASQ,cAAciB,mBAC3CrC,EAAeY,SAASQ,cAAcgB,kBACtCN,GACI9B,EAAeY,SAASQ,cAAcgB,gBAClCpC,EAAeY,SAASQ,cAAciB,mBAEtD,CAoBJ,OAlBAlB,EAAUD,MAAMW,EAAYC,GACd,IAAVN,GACAL,EAAUO,QAASF,EAAQG,KAAKC,GAAM,KAE1CT,EAAUE,UAAUrB,EAAeY,SAAS6B,YAAYT,EAAGhC,EAAeY,SAAS6B,YAAYP,GACjF,IAAVV,GACAL,EAAUO,OAAQF,EAAQG,KAAKC,GAAM,UAE3Bc,IAAVxB,GACAC,EAAUD,MAAMA,EAAOA,GAEvBlB,EAAeY,SAAS+B,OACxBxB,EAAUD,OAAO,EAAG,GAEpBlB,EAAeY,SAASgC,OACxBzB,EAAUD,MAAM,GAAI,GAExBC,EAAUE,WAAWC,EAAQ,GAAIC,EAAS,GACnCJ,CACX,C,6DCtEe,SAAS,EAAChB,EAAQD,EAAO2C,EAAUhC,GAC9C,QAAe6B,IAAXvC,EACA,MAAM,IAAI2C,MAAM,8DAEpB,QAAcJ,IAAVxC,EACA,OAAO,SAEX,MAAMgB,GAAQ,OAAiBf,EAAQD,EAAO,GAAG6C,YACjD,IAAIC,EAkBJ,MAjBiB,OAAbH,GAAqB3C,EAAM+C,YAC3BD,EAAM,CACFE,YAAa,EACbC,aAAc,UAGST,IAAtBxC,EAAMgD,kBACYR,IAAvBxC,EAAMiD,eACNH,EAAM,CACFE,YAAaE,MAAMC,QAAQnD,EAAMgD,aAC3BhD,EAAMgD,YAAY,GAClBhD,EAAMgD,YACZC,aAAcC,MAAMC,QAAQnD,EAAMiD,cAC5BjD,EAAMiD,aAAa,GACnBjD,EAAMiD,eAGb,CACHjC,QACAuB,YAAa,CACTT,EAAG,EACHE,EAAG,GAEPc,MACAM,OAAQpD,EAAMoD,OACdC,kBAAkB,EAClB9B,SAAU,EACVkB,OAAO,EACPC,OAAO,EACPY,YAAatD,EAAMsD,YACnBX,WACAY,OAAQvD,EAAMuD,OACd5C,cAAuB6B,IAAb7B,EAAyBA,EAAWX,EAAMW,SACpDO,cAAe,CACXa,KAAM,CACFD,EAAG,EACHE,EAAG,GAEPH,KAAM,CACFC,EAAG9B,EAAMwD,QACTxB,EAAGhC,EAAMyD,MAEbvB,qBAA2CM,IAA1BxC,EAAMkC,gBAAgC,EAAIlC,EAAMkC,gBACjEC,wBAAiDK,IAA7BxC,EAAMmC,mBAAmC,EAAInC,EAAMmC,mBACvEF,qBAAsB,QAGlC,C,ubC1DWyB,E,gLACX,SAAWA,GACPA,EAAuB,IAAI,MAC3BA,EAA4B,SAAI,WAChCA,EAA2B,QAAI,SAClC,CAJD,CAIGA,IAAsBA,EAAoB,CAAC,I,+0BCL9C,MAAMC,EAAmBC,OAAO,mBAC1BC,EAAmBD,OAAO,mBAC1BE,EAAsBF,OAAO,qBAC7BG,EAAaH,OAAO,cACX,MAAMI,EACjB,WAAAC,CAAYC,GACR,MAAMC,EAAaC,OAAOC,OAAQH,aAAgBF,GAAYD,KAAcG,EACtEA,EAAKH,GACL,MACNK,OAAOE,KAAKF,OAAOG,eAAeC,KAAMT,EAAY,CAChDU,MAAON,IAEf,CACA,GAAAO,CAAIC,EAAKF,GACL,OAAOC,EAAIF,KAAKT,GAAaY,EAAKF,EAAO,KAC7C,CACA,GAAAG,CAAID,GACA,OAmIR,SAAaR,EAAYQ,GACrB,OAAOR,EAAWQ,EACtB,CArIeC,CAAIJ,KAAKT,GAAaY,EACjC,CACA,KAAAE,CAAMF,GACF,OA8ER,SAAeR,EAAYW,GACvB,GAAIA,EAAKC,SAAS,KAAM,CACpB,IAAIC,EAAc,EAClB,MAAMC,EAAYH,EACZZ,EAAOe,EAAUC,MAAM,GAAI,GAC3BC,EAA4B,IAAhBjB,EAAKkB,OACvB,IAAK,MAAMT,KAAOR,EACVC,OAAOiB,UAAUC,eAAeC,KAAKpB,EAAYQ,KAChDQ,GAAaR,EAAIa,WAAWP,IAAcN,IAAQT,YAC5CC,EAAWQ,KAChBK,GAGV,OAAOA,EAAc,CACzB,CACA,cAAcb,EAAWW,EAC7B,CA9FeD,CAAML,KAAKT,GAAaY,EAAM,GACzC,CACA,OAAAc,CAAQC,GACJC,EAAQnB,KAAKT,GAAa2B,EAC9B,CACA,MAAAE,GACI,OAAO,IAAI5B,EAASQ,KACxB,CACA,MAAAqB,CAAOC,GACCC,EAAcD,IACd1B,OAAO4B,KAAKF,GAAML,QAASd,IACvBD,EAAIF,KAAKT,GAAaY,EAAKmB,EAAKnB,GAAM,OAGlD,CACA,IAAAsB,GACI,MAAMC,EAAU,CAAC,EAMjB,OALAP,EAAQnB,KAAKT,GAAa,CAACY,EAAKF,UACP,IAAVA,GACP0B,EAAQD,EAASvB,EAAKF,KAGvByB,CACX,CACA,aAAOE,CAAOC,GACV,OAAOA,aAAmBrC,EACpBqC,EACArC,EAASsC,oBACnB,CACA,yBAAOC,CAAmBC,EAAW,MACjC,IAAIC,EAAkBzC,EAASL,GAK/B,GAJM8C,aAA2BzC,IAC7ByC,EAAkB,IAAIzC,EACtBA,EAASL,GAAoB8C,GAE7BD,EAAU,CACV,MAAME,EAAa,CAAC,EAOpB,OANAD,EAAgBhB,QAASX,IACrB,GAAIA,EAAKU,WAAWgB,GAAW,CAC3B,MAAMG,EAAU7B,EAAK8B,MAAM,GAAGJ,MAAa,GAC3CE,EAAWC,GAAWF,EAAgB7B,IAAIE,EAC9C,IAEG4B,CACX,CACA,OAAOD,CACX,CACA,yBAAOH,GACH,IAAIO,EAAkB7C,EAASH,GAK/B,OAJMgD,aAA2B7C,IAC7B6C,EAAkB,IAAI7C,EAASA,EAASuC,sBACxCvC,EAASH,GAAoBgD,GAE1BA,CACX,CACA,wBAAOC,CAAkBT,EAASU,GAC9B,IAAIC,EAAW,KACf,GAAIX,aAAmBrC,EACnBgD,EAAWX,OAEV,GAAuB,iBAAZA,GAAoC,OAAZA,EAAkB,CACtD,IAAIY,EAAoBjD,EAASF,GAC3BmD,aAA6BC,UAC/BD,EAAoB,IAAIC,QACxBlD,EAASF,GAAuBmD,GAEpCD,EAAWC,EAAkBrC,IAAIyB,GAC3BW,aAAoBhD,IACtBgD,EAAW,IAAIhD,EAASA,EAASoC,OAAOpC,EAAS8C,kBAAkBC,KACnEE,EAAkBvC,IAAI2B,EAASW,GAEvC,CACA,OAAOA,CACX,CACA,4BAAOG,GACH,OAAOnD,EAASsC,qBAAqBV,QACzC,EAmBJ,SAASD,EAAQxB,EAAYuB,GACzB,IAAK,MAAMf,KAAOR,EACduB,EAASf,EAAKR,EAAWQ,GAEjC,CAmBA,SAASD,EAAIP,EAAYQ,EAAKF,EAAO2C,GACjC,QAYJ,SAAoBzC,GAChB,IAAI0C,EAAMC,EAASC,EACnB,GAAmB,iBAAR5C,IAAqB0C,EAAO1C,EAAIS,OAAS,GAAK,EACrD,OAAO,EAEXmC,GAAY,EACZ,MAAQD,EAAU3C,EAAI6C,QAAQ,IAAKD,EAAW,KAAO,GAAG,CACpD,GAAID,EAAUC,EAAW,GAAKD,IAAYD,EACtC,OAAO,EAEXE,EAAWD,CACf,CACA,OAAO,CACX,CAzBQG,CAAW9C,KACPoB,EAActB,GApB1B,SAAgBN,EAAYuD,EAAQC,EAAQP,GACxC,IAAIQ,EACJ,GAAIR,EAAWS,IAAIF,GACf,OAAOjD,EAAIP,EAAYuD,EAAQ,KAAMN,GAEzCA,EAAWU,IAAIH,GACfC,EAAY,EACZ,IAAK,MAAMG,KAASJ,EACZvD,OAAOiB,UAAUC,eAAeC,KAAKoC,EAAQI,KAExCrD,EAAIP,EADoB,IAAjB4D,EAAM3C,OAAesC,EAAS,GAAGA,KAAUK,IAC7BJ,EAAOI,GAAQX,MACnCQ,GAKd,OADAR,EAAWY,OAAOL,GACG,IAAdC,CACX,CAImBK,CAAO9D,EAAYQ,EAAKF,EAAO2C,aAAsBc,QAAUd,EAAa,IAAIc,UAE3F/D,EAAWQ,GAAOF,GACX,GAGf,CAkBA,SAASsB,EAAcM,GACnB,GAAuB,iBAAZA,GAAoC,OAAZA,EAAkB,CACjD,MAAMhB,EAAYjB,OAAO+D,eAAe9B,GACxC,GAAIhB,IAAcjB,OAAOiB,WAA2B,OAAdA,EAClC,OAAO,CAEf,CACA,OAAO,CACX,CACA,SAASc,EAAQD,EAASvB,EAAKF,GAC3B,MAAM2D,EAAYzD,EAAI6C,QAAQ,KAC9B,GAAIY,GAAa,EAAG,CAChB,MAAMC,EAAS1D,EAAIO,MAAM,EAAGkD,GAC5B,IAAIE,EAAapC,EAAQmC,GACzB,GAA0B,iBAAfC,GAA0C,OAAfA,EAAqB,CACvD,MAAMC,EAAkBD,EACxBA,EAAa,CAAC,OACiB,IAApBC,IACPD,EAAW,IAAMC,GAErBrC,EAAQmC,GAAUC,CACtB,CACAnC,EAAQmC,EAAY3D,EAAIO,MAAMkD,EAAY,EAAGzD,EAAIS,QAASX,EAC9D,MAEIyB,EAAQvB,GAAOF,CAEvB,CACAT,EAASuC,qBAAqB7B,IAAI,cAAc,G,yWCtLhD,MAAM8D,EAAe,CAAC,EACtB,IAAIC,EACJ,SAASC,EAAyBC,EAASC,GACvC,MAAMC,EAAwB,KAAMC,mBAAmBH,GACvD,GAAIE,EAEA,OADAE,EAAuBF,EAAsBG,QAASL,GAC/CE,EAEX,MAAMI,EAASN,EAAQ/B,MAAM,KAAK,GAC5BsC,EAASV,EAAaS,IAAWR,EACvC,IAAKS,EACD,MAAM,IAAItG,MAAM,+DAA+DqG,MAEnF,MAAME,EAAkBD,EAAOP,EAASC,GAExC,OADAG,EAAuBI,EAAgBH,QAASL,GACzCQ,CACX,CACA,SAASJ,EAAuBK,EAAcT,GAC1CU,QAAQC,QAAQF,GACXG,KAAMvJ,KAYf,SAA4BA,GACxB,IAAKA,EAAMwJ,aAAc,CACrB,MAAM,MAAEpI,EAAK,OAAEC,EAAM,mBAAEoI,GAAuBzJ,EACxCwJ,EAAe,IAAaE,wBAAwB,CACtDC,WAAY3J,EAAM4J,eAClBxI,QACAC,SACAoI,uBAEJzJ,EAAMwJ,aAAeA,EACrBxJ,EAAM4J,aAAe,IAAMJ,EAAaK,uBACjC7J,EAAM8J,WAAWC,SAC5B,CACJ,CAxBQC,CAAmBhK,IACnB,OAAa,IAAa,IAAOiK,aAAc,CAAEjK,YAEhDkK,MAAOC,IACR,MAAMC,EAAe,CACjBzB,UACAwB,UAEJ,OAAa,IAAa,IAAOE,kBAAmBD,IAE5D,CAeO,SAASE,EAAU3B,EAASC,EAAU,CAAE2B,SAAU,EAAGC,YAAa,aACrE,QAAgBhI,IAAZmG,EACA,MAAM,IAAI/F,MAAM,sDAEpB,OAAO8F,EAAyBC,EAASC,GAASI,OACtD,CACO,SAASyB,EAAkB9B,EAASC,EAAU,CAAE2B,SAAU,EAAGC,YAAa,aAC7E,QAAgBhI,IAAZmG,EACA,MAAM,IAAI/F,MAAM,8DAEpB,MAAMuG,EAAkBT,EAAyBC,EAASC,GAI1D,OAHK,KAAME,mBAAmBH,IAC1B,KAAM+B,mBAAmB/B,EAASQ,GAE/BA,EAAgBH,OAC3B,CAUO,SAAS2B,EAA2BC,EAAmBhC,EAAU,CAAC,GACrE,QAA0BpG,IAAtBoI,EACA,MAAM,IAAIhI,MAAM,4EAEIJ,IAApBoG,EAAQD,UACRC,EAAQD,QAAU,YAAW,YAEjC,MAAM,QAAEA,EAAO,iBAAEkC,EAAgB,WAAEC,EAAU,oBAAEC,GAAwBnC,EACjEoC,EAAmB,MAAa,mBAAoBJ,GACpDxF,EAAS4F,EAAiBvH,KAAOuH,EAAiBxH,SAClD,sBAAEyH,IAA0B,OAAuBrC,EAAQsC,cAAcC,KAAM/F,GAC/EgG,EAAkB,IAAIH,EAAsBJ,EAAmB,EAAIzF,GACnEiG,EAAiB1C,EACjB2C,EAA+B,MAAa,mBAAoBV,GACtE,IAAwB9C,IAAIuD,EAAgB,CACxCF,KAAM,mBACNI,SAAUD,IAEd,MAAME,EAAuC,MAAa,sBAAuBZ,GACjF,IAAwB9C,IAAIuD,EAAgB,CACxCF,KAAM,sBACNI,SAAUC,IAEd,IAAwB1D,IAAIuD,EAAgB,CACxCF,KAAM,qBACNI,SAAU,CACNE,eAAgB7C,EAAQ6C,kBAGhC,MAAMC,EAAmB,MAAa,mBAAoBd,GAC1D,IAAwB9C,IAAIuD,EAAgB,CACxCF,KAAM,mBACNI,SAAU,IACHG,EACHC,cAAe,EACfC,WAAY,EACZC,QAAS,EACTC,gBAAiB,EACjBC,oBAAqB,KAG7B,MAAMC,EAAaC,EAAyBtD,EAAS,CACjDgB,WAAYyB,EACZN,aACAD,mBACAK,aAAc,CACVC,KAAMC,EAAgBnH,YAAYa,MAEtCiG,sBACAmB,WAAY,CAAClB,EAAiBxH,QAASwH,EAAiBvH,MACxD0I,QAAS,CACLnB,EAAiB7I,mBACjB6I,EAAiB9I,iBAErBkK,OAAQpB,EAAiBqB,qBACzBC,UAAWtB,EAAiBuB,wBAC5BC,oBAAqBxB,EAAiBwB,oBACtC5B,kBAAmBA,IAMvB,OAJAoB,EAAWpB,kBAAoBA,EAC1B,KAAM9B,mBAAmBH,IAC1B,KAAM8D,aAAa9D,EAASqD,GAEzBA,CACX,CACO,SAASU,EAA4BC,EAAoB/D,EAAU,CAAC,GACvE,GAAkC,IAA9B+D,EAAmBvH,OACnB,MAAM,IAAIxC,MAAM,6EAEpB,MAAMgK,EAAkB,GAaxB,OAZeD,EAAmBE,IAAI,CAACjC,EAAmBkC,KACtD,MAAMC,EAAa,CACfpE,QAASC,GAASoE,oBAAoBpC,IAClC,YAAW,cACZhC,GAGP,OADAgE,EAAgBK,KAAKF,EAAWpE,SACzBgC,EAA2BC,EAAmB,IAC9CmC,EACHtB,eAAgBqB,EAAQ,KAIpC,CACO,SAASb,EAAyBtD,EAASC,GAC9C,MAAM,WAAEe,EAAU,OAAEyC,EAAM,UAAEE,EAAS,aAAEpB,EAAY,iBAAEL,EAAgB,WAAEC,EAAU,oBAAE0B,EAAmB,oBAAEzB,EAAmB,kBAAEH,GAAuBhC,EAC9IsD,EAAatD,EAAQsD,WACrBC,EAAUvD,EAAQuD,QACxB,IAAKD,IAAeC,EAChB,MAAM,IAAIvJ,MAAM,iEAEpB,MAAMxB,EAAQ8K,EAAW,GACnB7K,EAAS6K,EAAW,GACpB/J,EAAqBgK,EAAQ,GAC7BjK,EAAkBiK,EAAQ,GAC1BnB,EAAmB,CACrBwB,sBACA/I,KAAMpC,EACNmC,QAASpC,EACTmL,wBAAyBD,GAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GACtDY,WAAYZ,EAAYA,EAAUpH,MAAM,EAAG,GAAK,CAAC,EAAG,EAAG,GACvDiI,cAAeb,EAAYA,EAAUpH,MAAM,EAAG,GAAK,CAAC,EAAG,EAAG,GAC1DmH,qBAAsBD,GAAU,CAAC,EAAG,EAAG,GACvCgB,aAAc,CAAClL,EAAiBC,GAChCD,gBAAiBA,EACjBC,mBAAoBA,GAElBiD,EAAShE,EAAQC,EACjBoI,EAAqBE,EAAWvE,OAASA,EAC/C,IAAIiI,EAeA1B,EAAeC,EAAYC,EAd/B,GAAIlC,EAAY,CACZ,KAAMA,aAAsB2D,YACxB3D,aAAsB4D,cACtB5D,aAAsB6D,aACtB7D,aAAsB8D,YACtB,MAAM,IAAI7K,MAAM,4GAEpByK,EAAkB1D,CACtB,MACK,IAAKkB,EAAkB,CACxB,MAAM,sBAAEI,IAA0B,OAAuBC,GAAcC,KAAM/F,GAE7EiI,EADwB,IAAIpC,EAAsB7F,EAEtD,CAEA,GAAIiI,aAA2BC,WAC3B3B,EAAgB,EAChBC,EAAa,EACbC,EAAU,OAET,GAAIwB,aAA2BG,YAChC7B,EAAgB,GAChBC,EAAa,GACbC,EAAU,QAET,GAAIwB,aAA2BI,WAChC9B,EAAgB,GAChBC,EAAa,GACbC,EAAU,OAET,MAAIwB,aAA2BE,cAMhC,MAAM,IAAI3K,MAAM,+BALhB+I,EAAgB,GAChBC,EAAa,GACbC,EAAU,EAId,CACA,MAAMH,EAAmB,CACrBI,gBAAiB,EACjB4B,0BAA2BL,EAAgBjI,OAAS8G,EAAW,GAAKA,EAAW,GACzE,MACA,cACNzI,KAAMpC,EACNmC,QAASpC,EACTuK,gBACAC,aACAC,WAEEN,EAAW,CACbP,mBACAU,oBAEJ,CAAC,mBAAoB,oBAAoBjG,QAAS0F,IAC9C,IAAwBrD,IAAIa,EAAS,CACjCwC,OACAI,SAAUA,EAASJ,IAAS,CAAC,MAGrC,MAAMwC,EAAKhF,EACLa,EAAgBuB,IAAwB,IAAiB6C,KAC3D,IAAaC,2BAA2B,CAAE3B,aAAYyB,QACtD,IAAajE,wBAAwB,CACjCrI,SACAD,QACAqI,qBACAE,WAAY0D,EACZM,OAER,IAAIG,EAAgBT,EAAgB,GAChCU,EAAgBV,EAAgB,GACpC,IAAK,IAAIW,EAAI,EAAGA,EAAIX,EAAgBjI,OAAQ4I,IACpCX,EAAgBW,GAAKF,IACrBA,EAAgBT,EAAgBW,IAEhCX,EAAgBW,GAAKD,IACrBA,EAAgBV,EAAgBW,IAGxC,MAAMhO,EAAQ,CACV2I,QAASA,EACTsF,UAAW,EACXhL,aAAc,EACdD,YAAa,EACbpC,MAAsD,QAA/C8K,EAAiBgC,0BACxBjE,mBAAoBiC,EAAiBI,gBACrCoC,SAAUhD,GAAcC,KACxBgD,MAAO,EACPL,gBACAC,gBACAtK,KAAMiI,EAAiBjI,KACvBD,QAASkI,EAAiBlI,QAC1B4K,eAAW5L,EACXnB,OAAQqK,EAAiBjI,KACzBrC,MAAOsK,EAAiBlI,QACxB6K,UAAM7L,EACNL,mBAAoB6I,EAAiB7I,mBACrCD,gBAAiB8I,EAAiB9I,gBAClCoM,oBAAqBtD,EAAiBwB,oBACtCpJ,QAAQ,EACRwG,aAAc,IAAMJ,EAAaK,gBACjCL,eACA+E,YAAa5E,EAAW6E,WACxB5D,qBAIJ,OAFAE,IAAa9K,GACb,KAAMyM,aAAazM,EAAM2I,QAAS3I,GAC3BA,CACX,C,mCC3Se,MAAMyO,SACRjK,KAAKkK,oBAAsB,yCAA2C,CAC/E,sBAAOC,CAAgBhG,GACnB,MAAMiG,EAAQjG,EAAQiG,MAAMpK,KAAKkK,qBACjC,IAAKE,IAAUA,EAAM,GACjB,OAAO,KAEX,MAAMC,EAAQD,EAAM,GAAGhI,MAAM,KAAKiG,IAAKiC,GAAOC,OAAOD,IACrD,OAAqB,IAAjBD,EAAMzJ,OACCyJ,EAAM,GAEVA,CACX,CACA,wBAAOG,CAAkBrG,GACrB,MAAMkG,EAAQrK,KAAKmK,gBAAgBhG,GACnC,OAAOzF,MAAMC,QAAQ0L,GAASA,EAAM,GAAKA,CAC7C,CACA,0BAAOI,CAAoBtG,GACvB,MAAMkG,EAAQrK,KAAKmK,gBAAgBhG,GACnC,OAAOzF,MAAMC,QAAQ0L,GAASA,EAAM,GAAKA,CAC7C,CACA,qBAAOK,CAAeL,GAClB,OAAI3L,MAAMC,QAAQ0L,GACP,GAAGA,EAAM,MAAMA,EAAM,KAEzBM,OAAON,EAClB,CACA,sBAAOO,CAAgBzG,EAASkG,GAC5B,MAAMD,EAAQjG,EAAQiG,MAAMpK,KAAKkK,qBACjC,IAAKE,IAAUA,EAAM,GACjB,OAAO,KAEX,MAAMS,EAAiB7K,KAAK0K,eAAeL,GAC3C,OAAOlG,EAAQ2G,QAAQ9K,KAAKkK,oBAAqB,GAAGE,EAAM,KAAKS,IACnE,E,mCClCW,MAAME,EACjB,WAAAtL,CAAYuL,EAAgB,CAAC,GACzBhL,KAAKiL,YAAc,EACnBjL,KAAKkL,QAAU,EACflL,KAAKmL,UAAY,EACjBnL,KAAKoL,SAAW,IAChB,MAAM,YAAEC,EAAc,KAAI,WAAE3D,EAAa,EAAC,SAAE0D,EAAW,KAASJ,EAC1DM,EAAaD,EAAc3D,EACjC1H,KAAKoL,SAAWA,EAChBpL,KAAKuL,MAAQ,IAAIC,YAAYF,EAAatL,KAAKmL,WAC/CnL,KAAKyL,KAAO,IAAI1C,aAAa/I,KAAKuL,OAClCvL,KAAKiL,YAAcvD,CACvB,CACA,OAAAzG,CAAQyK,GACJ,IAAK,IAAIlC,EAAI,EAAGA,EAAIxJ,KAAKkL,QAAS1B,IAC9BkC,EAAK1L,KAAK2L,SAASnC,GAAIA,EAE/B,CACA,UAAI5I,GACA,OAAOZ,KAAKkL,OAChB,CACA,cAAIxD,GACA,OAAO1H,KAAKiL,WAChB,CACA,mBAAIW,GACA,OAAO5L,KAAKkL,QAAUlL,KAAKiL,WAC/B,CACA,QAAAU,CAASrD,GAIL,GAHIA,EAAQ,IACRA,GAAStI,KAAKkL,SAEd5C,EAAQ,GAAKA,GAAStI,KAAKkL,QAC3B,OAEJ,MAAMW,EAAS7L,KAAKiL,YAAc3C,EAClC,OAAOtI,KAAKyL,KAAKK,SAASD,EAAQA,EAAS7L,KAAKiL,YACpD,CACA,aAAAc,CAAczD,GACV,MAAMiD,EAAQ,GAId,GAHIjD,EAAQ,IACRA,GAAStI,KAAKkL,SAEd5C,EAAQ,GAAKA,GAAStI,KAAKkL,QAC3B,OAEJ,MAAMW,EAAS7L,KAAKiL,YAAc3C,EAClC,IAAK,IAAIkB,EAAI,EAAGA,EAAIxJ,KAAKiL,YAAazB,IAClC+B,EAAM9C,KAAKzI,KAAKyL,KAAKjC,EAAIqC,IAE7B,OAAON,CACX,CACA,IAAAS,CAAKC,EAAiB,EAAGb,EAAWpL,KAAKoL,UACrC,GAAIpL,KAAK4L,gBAAkBK,EAAiBjM,KAAKiL,aAC7CjL,KAAKyL,KAAK7K,OACV,OAEJ,MAAMsL,EAAUlM,KAAKyL,KAAK7K,OAASwK,EAC7Be,EAAW,IAAIX,YAAYU,EAAUlM,KAAKiL,YAAcjL,KAAKmL,WAC7DiB,EAAU,IAAIrD,aAAaoD,GACjCC,EAAQlM,IAAIF,KAAKyL,MACjBzL,KAAKyL,KAAOW,EACZpM,KAAKuL,MAAQY,CACjB,CACA,OAAAE,GACI,MAAMC,EAAYrP,KAAKsP,MAAMvM,KAAKkL,QAAU,GAC5C,IAAK,IAAI1B,EAAI,EAAGA,EAAI8C,EAAW9C,IAAK,CAChC,MAAMgD,EAAahD,EAAIxJ,KAAKiL,YACtBwB,GAAYzM,KAAKkL,QAAU,EAAI1B,GAAKxJ,KAAKiL,YAC/C,IAAK,IAAIyB,EAAY,EAAGA,EAAY1M,KAAKiL,YAAayB,IAAa,CAC/D,MAAMC,EAAa3M,KAAKyL,KAAKe,EAAaE,GAC1C1M,KAAKyL,KAAKe,EAAaE,GAAa1M,KAAKyL,KAAKgB,EAAWC,GACzD1M,KAAKyL,KAAKgB,EAAWC,GAAaC,CACtC,CACJ,CACJ,CACA,aAAAC,GACI,OAAO5M,KAAKyL,IAChB,CACA,IAAAhD,CAAKoE,GACD7M,KAAKgM,KAAK,GACV,MAAMH,EAAS7L,KAAKY,OAASZ,KAAKiL,YAClC,IAAK,IAAIzB,EAAI,EAAGA,EAAIxJ,KAAKiL,YAAazB,IAClCxJ,KAAKyL,KAAKjC,EAAIqC,GAAUgB,EAAMrD,GAElCxJ,KAAKkL,SACT,CACA,GAAA7C,CAAIyE,GACA,MAAMC,EAAU,GAChB,IAAK,IAAIvD,EAAI,EAAGA,EAAIxJ,KAAKkL,QAAS1B,IAC9BuD,EAAQtE,KAAKqE,EAAE9M,KAAK2L,SAASnC,GAAIA,IAErC,OAAOuD,CACX,CACA,UAAIC,GACA,OAAOhN,KAAKqI,IAAK4E,GAAMA,EAC3B,CACA,KAAAC,GACI,MAAMC,EAAM,CAAE7P,EAAG,GAAIE,EAAG,IACpBwC,KAAKiL,aAAe,IACpBkC,EAAIC,EAAI,IAEZ,MAAM,EAAE9P,EAAC,EAAEE,EAAC,EAAE4P,GAAMD,EAQpB,OAPAnN,KAAKiB,QAASgM,IACV3P,EAAEmL,KAAKwE,EAAE,IACTzP,EAAEiL,KAAKwE,EAAE,IACLG,GACAA,EAAE3E,KAAKwE,EAAE,MAGVE,CACX,CACA,cAAOE,EAAQ,EAAE/P,EAAC,EAAEE,EAAC,EAAE4P,IACnB,MAAM7B,EAAQR,EAAcuC,QAAQhQ,EAAEsD,QACtC,IAAIiL,EAAS,EACb,IAAK,IAAIrC,EAAI,EAAGA,EAAIlM,EAAEsD,OAAQ4I,IAC1B+B,EAAME,KAAKI,KAAYvO,EAAEkM,GACzB+B,EAAME,KAAKI,KAAYrO,EAAEgM,GACzB+B,EAAME,KAAKI,KAAYuB,EAAIA,EAAE5D,GAAK,EAGtC,OADA+B,EAAML,QAAU5N,EAAEsD,OACX2K,CACX,CACA,SAAAgC,CAAUC,EAAQ,GAAI3B,EAAS,GAC3B,MAAM4B,EAAW,IAAI1C,EAAc,CAC/BM,YAAamC,EACb9F,WAAY1H,KAAKiL,cAErB,IAAK,IAAIzB,EAAI,EAAGA,EAAIgE,EAAOhE,IAAK,CAC5B,MAAMlB,GAASuD,EAAS5O,KAAKsP,MAAOvM,KAAKY,OAAS4I,EAAKgE,IAAUxN,KAAKY,OACtE6M,EAAShF,KAAKzI,KAAK2L,SAASrD,GAChC,CACA,OAAOmF,CACX,CACA,cAAOH,CAAQjC,EAAc,IAAK2B,GAC9B3B,EAAcpO,KAAKyQ,IAAIrC,EAAa2B,GAAQpM,QAAU,GACtD,MAAM+M,EAAY,IAAI5C,EAAc,CAAEM,cAAa3D,WAAY,IAI/D,OAHIsF,GACAA,EAAO/L,QAAS4L,GAAUc,EAAUlF,KAAKoE,IAEtCc,CACX,CACA,cAAOC,CAAQvC,EAAc,KACzB,OAAO,IAAIN,EAAc,CAAEM,cAAa3D,WAAY,GACxD,E,mCC7IW,MAAMmG,EACjB,WAAApO,CAAYa,GACRN,KAAKM,KAAOA,GAAQ,SACxB,CACA,SAAOwN,CAAGtJ,GACN,GAAIA,EAAQuJ,SACR,OAAOvJ,EAAQuJ,SAEnB,MAAMA,EAAW,IAAIF,EAAoB,eAWzC,OAVArJ,EAAQO,KAAMiJ,IACV,IACID,EAASzK,IAAI0K,GAAG,EACpB,CACA,MAAOC,GACHF,EAASG,OAAOD,EACpB,GACAE,IACAJ,EAASG,OAAOC,KAEbJ,CACX,CACA,GAAAzK,CAAIhG,EAAG8Q,GAAO,GACVpO,KAAKqO,UAAY/Q,EACjB0C,KAAKoO,OAASA,EACVpO,KAAKsO,UACLtO,KAAKsO,QAAQxJ,QAAQxH,GACrB0C,KAAKsO,aAAUtQ,EAEvB,CACA,OAAA8G,GACI9E,KAAKoO,MAAO,EACRpO,KAAKsO,UACLtO,KAAKsO,QAAQxJ,QAAQ9E,KAAKqO,WAC1BrO,KAAKsO,aAAUtQ,EAEvB,CACA,MAAAkQ,CAAOC,GACHnO,KAAKuO,aAAeJ,EACpBnO,KAAKsO,SAASJ,OAAOC,EACzB,CACA,SAAAK,GACI,GAAIxO,KAAKuO,aACL,MAAMvO,KAAKuO,aAEf,OAAOvO,KAAKqO,SAChB,CACA,OAAQjP,OAAOqP,iBACX,MAAQzO,KAAKoO,MAAM,CACf,GAAIpO,KAAKuO,aACL,MAAMvO,KAAKuO,aAEf,QAAuBvQ,IAAnBgC,KAAKqO,kBACCrO,KAAKqO,UACPrO,KAAKoO,MACL,MAGHpO,KAAKsO,UACNtO,KAAKsO,QAAU,CAAC,EAChBtO,KAAKsO,QAAQ9J,QAAU,IAAIK,QAAQ,CAACC,EAASoJ,KACzClO,KAAKsO,QAAQxJ,QAAUA,EACvB9E,KAAKsO,QAAQJ,OAASA,WAGxBlO,KAAKsO,QAAQ9J,OACvB,OACMxE,KAAKqO,SACf,CACA,aAAMpN,CAAQC,EAAUwN,GACpB,IAAIpG,EAAQ,EACZ,IACI,UAAW,MAAMrI,KAASD,KAAM,CAC5B,MAAM,KAAEoO,GAASpO,KACjB,UACUkB,EAASjB,EAAOmO,EAAM9F,GAC5BA,GACJ,CACA,MAAO2F,GACH,IAAKG,EAAM,CACPO,QAAQC,KAAK,yCAA0CX,GACvD,QACJ,CACA,IAAIS,EAIA,MAAMT,EAHNS,EAAcT,EAAGG,EAKzB,CACJ,CACJ,CACA,MAAOH,GACH,IAAIS,EAIA,MAAMT,EAHNS,EAAcT,GAAG,EAKzB,CACJ,CACA,QAAAY,CAASC,EAAiBJ,GACtB,OAAOI,EAAgB9O,KAAMA,KAAKkO,OAAOa,KAAK/O,OAAO+E,KAAK,KACjD/E,KAAKoO,MACNpO,KAAK8E,WAETqJ,IACAnO,KAAKkO,OAAOC,GACRO,EACAA,EAAcP,GAGdQ,QAAQC,KAAK,2BAA4BT,IAGrD,CACA,iBAAMa,GACF,UAAW,MAAMxF,KAAKxJ,KAClB,GAAIwJ,EACA,OAAOA,EAGf,OAAOxJ,KAAKqO,SAChB,CACA,iBAAMY,GACF,UAAW,MAAMzF,KAAKxJ,MAEtB,OAAOA,KAAKqO,SAChB,CACA,cAAAa,GACI,MAAM1K,EAAUxE,KAAKgP,cAErB,OADAxK,EAAQuJ,SAAW/N,KACZwE,CACX,CACA,cAAA2K,GACI,MAAM3K,EAAUxE,KAAKiP,cAErB,OADAzK,EAAQuJ,SAAW/N,KACZwE,CACX,E,mCC3IJ,MAAM4K,EAAe,CACjB,CAAC,GAAI,EAAG,GACR,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,GAAI,GACR,CAAC,EAAG,EAAG,IAELC,EAAwB,CAC1B,CAAC,GAAI,EAAG,GACR,CAAC,EAAG,EAAG,IAELC,EAAc,CAChB,CAAC,GAAI,EAAG,GACR,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,GAAI,IAENC,EAAe,CACjB,CAAC,GAAI,EAAG,GACR,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IAEI,MAAMC,EACjB,cAAOC,CAAQC,EAAaC,GACxB,IAAK,MAAOrH,EAAOsH,KAAQD,EAAO1Q,KAC9ByQ,EAAYzQ,KAAKiB,IAAIoI,EAAOuH,gBAAgBD,GAEpD,CACA,WAAAnQ,CAAY7C,EAAOC,EAAQiT,EAAQ,GAC/B9P,KAAKf,KAAO,IAAI8Q,IAChB/P,KAAKnD,OAAS,EACdmD,KAAKpD,MAAQ,EACboD,KAAK8P,MAAQ,EACb9P,KAAKgQ,UAAY,EACjBhQ,KAAKiQ,UAAY,EACjBjQ,KAAKkQ,SAAW,EAChBlQ,KAAKmQ,qBAAuBrH,WAC5B9I,KAAKoQ,iBAAmB,SAAUjL,GAC9BA,EAAWkL,KAAK,GAOhBrQ,KAAKiB,QANY,CAACqH,EAAOgI,EAAKV,KAC1B,MAAM,MAAElU,EAAK,IAAE6U,EAAG,MAAEtQ,GAAUqQ,EAC9B,IAAK,IAAI9G,EAAI9N,EAAO8N,EAAI+G,EAAK/G,IACzBrE,EAAWmD,EAAQkB,GAAKvJ,GAIpC,EACAD,KAAKI,IAAOkI,IACR,MAAMkB,EAAIlB,EAAQtI,KAAKgQ,UACjBQ,GAAKlI,EAAQkB,GAAKxJ,KAAKgQ,UACvBM,EAAMtQ,KAAKyQ,OAAOjH,EAAGgH,GAC3B,OAAOF,GAAKrQ,OAASD,KAAK0Q,cAE9B1Q,KAAK2Q,OAAS,CAACH,EAAGI,KACd,MAAMC,EAAWL,EAAII,EAAI5Q,KAAKnD,OAC9B,OAAOmD,KAAKf,KAAKmB,IAAIyQ,IAEzB7Q,KAAKE,IAAM,CAACoI,EAAOrI,KACf,QAAcjC,IAAViC,EACA,OAEJ,MAAMuJ,EAAIlB,EAAQtI,KAAKpD,MACjB4T,GAAKlI,EAAQkB,GAAKxJ,KAAKpD,MACvBgT,EAAM5P,KAAKf,KAAKmB,IAAIoQ,GAC1B,IAAKZ,EAED,YADA5P,KAAKf,KAAKiB,IAAIsQ,EAAG,CAAC,CAAE9U,MAAO8N,EAAG+G,IAAK/G,EAAI,EAAGvJ,WAG9C,MAAM6Q,EAAW9Q,KAAK+Q,UAAUnB,EAAKpG,GAC/BwH,EAAOpB,EAAIkB,GACXG,EAAOrB,EAAIkB,EAAW,GAC5B,IAAKE,EACD,OAAKC,GAAQA,EAAKhR,QAAUA,GAASgR,EAAKV,MAAQ/G,OAIlDyH,EAAKV,WAHDX,EAAIkB,GAAY,CAAEpV,MAAO8N,EAAG+G,IAAK/G,EAAI,EAAGvJ,UAMhD,MAAM,MAAEvE,EAAK,IAAE6U,EAAKtQ,MAAOiR,GAAaF,EACxC,GAAI/Q,IAAUiR,GAAY1H,GAAK9N,EAC3B,OAEJ,MAAMyV,EAAY,CAAEzV,MAAO8N,EAAG+G,IAAK/G,EAAI,EAAGvJ,SACpCmR,EAAU5H,EAAI9N,EACd2V,EAAcD,EAAUN,EAAW,EAAIA,EACvCQ,EAAUF,EAAUJ,EAAOC,EACjC,IAAIM,EAAUH,EAAUxB,EAAIkB,EAAW,GAAKE,EAC5C,GAAIM,GAASrR,QAAUA,GAASqR,GAASf,MAAQ/G,EAiB7C,OAhBA8H,EAAQf,WACJgB,GAAStR,QAAUA,GAASsR,EAAQ7V,QAAU8N,EAAI,GAClD8H,EAAQf,IAAMgB,EAAQhB,IACtBX,EAAI4B,OAAOV,EAAU,IAEhBS,GAAS7V,QAAU8N,IACxB+H,EAAQ7V,QACJ6V,EAAQ7V,QAAU6V,EAAQhB,MAC1BX,EAAI4B,OAAOV,EAAU,GACrBS,EAAU3B,EAAIkB,GACVS,GAAS7V,QAAU8N,EAAI,GAAK+H,EAAQtR,QAAUA,IAC9CqR,EAAQf,IAAMgB,EAAQhB,IACtBX,EAAI4B,OAAOV,EAAU,OAMrC,GAAIS,GAAStR,QAAUA,GAASsR,EAAQ7V,QAAU8N,EAAI,EAQlD,OAPA+H,EAAQ7V,aACJ4V,GAASf,IAAM/G,IACf8H,EAAQf,IAAM/G,EACV8H,EAAQf,MAAQe,EAAQ5V,OACxBkU,EAAI4B,OAAOV,EAAU,KAKjC,GAAIS,GAAS7V,QAAU8N,GAAK+H,EAAQhB,MAAQ/G,EAAI,EAAG,CAC/C+H,EAAQtR,MAAQA,EAChB,MAAMwR,EAAW7B,EAAIkB,EAAW,GAKhC,YAJIW,GAAU/V,OAAS8N,EAAI,GAAKiI,EAASxR,QAAUA,IAC/C2P,EAAI4B,OAAOV,EAAW,EAAG,GACzBS,EAAQhB,IAAMkB,EAASlB,KAG/B,CACI/G,IAAM+H,GAAS7V,OACf6V,EAAQ7V,QAER0V,GAAWb,EAAM/G,EAAI,EACrBoG,EAAI4B,OAAOH,EAAa,EAAGF,EAAW,CAClCzV,MAAO8N,EAAI,EACX+G,IAAKe,EAAQf,IACbtQ,MAAOqR,EAAQrR,QAInB2P,EAAI4B,OAAOH,EAAa,EAAGF,GAE3BG,GAASf,IAAM/G,IACf8H,EAAQf,IAAM/G,IAGtBxJ,KAAKpD,MAAQA,EACboD,KAAKnD,OAASA,EACdmD,KAAK8P,MAAQA,EACb9P,KAAKgQ,UAAYpT,EACjBoD,KAAKiQ,UAAYjQ,KAAKgQ,UAAYnT,CACtC,QACSmD,KAAKqF,cAAgB,SAAUqM,EAAYC,mBAChD,MAAMxM,EAAa,IAAIuM,EAAU1R,KAAK4R,WAEtC,OADA5R,KAAKqI,IAAI+H,iBAAiBjL,GACnBA,CACX,CAAG,CACH,KAAA0M,CAAMvJ,GACF,MAAMkB,EAAIlB,EAAQtI,KAAKgQ,UAGvB,MAAO,CAACxG,GAFIlB,EAAQkB,GAAKxJ,KAAKgQ,UAAahQ,KAAKnD,OACtCI,KAAKsP,MAAMjE,EAAQtI,KAAKiQ,WAEtC,CACA,OAAA6B,EAAStI,EAAGgH,EAAGI,IACX,OAAOpH,EAAIoH,EAAI5Q,KAAKiQ,UAAYO,EAAIxQ,KAAKgQ,SAC7C,CACA,MAAAS,CAAOjH,EAAGgH,EAAGI,EAAI,GACb,MAAMhB,EAAM5P,KAAKf,KAAKmB,IAAIoQ,EAAII,EAAI5Q,KAAKnD,QACvC,IAAK+S,EACD,OAEJ,MACMU,EAAMV,EADE5P,KAAK+Q,UAAUnB,EAAKpG,IAElC,OAAOA,GAAK8G,GAAK5U,MAAQ4U,OAAMtS,CACnC,CACA,GAAAqF,CAAIiF,GACA,MAAMkB,EAAIlB,EAAQtI,KAAKgQ,UACjBQ,GAAKlI,EAAQkB,GAAKxJ,KAAKgQ,UACvBM,EAAMtQ,KAAKyQ,OAAOjH,EAAGgH,GAC3B,YAAsBxS,IAAfsS,GAAKrQ,KAChB,CACA,OAAOqI,GACH,MAAMkB,EAAIlB,EAAQtI,KAAKpD,MACjB4T,GAAKlI,EAAQkB,GAAKxJ,KAAKpD,MACvBgT,EAAM5P,KAAKf,KAAKmB,IAAIoQ,GAC1B,IAAKZ,EACD,OAEJ,MAAMkB,EAAW9Q,KAAK+Q,UAAUnB,EAAKpG,GAC/B8G,EAAMV,EAAIkB,GAChB,IAAKR,GAAOA,EAAI5U,MAAQ8N,EACpB,OAEJ,GAAI8G,EAAIC,MAAQ/G,EAAI,EAQhB,OAPA8G,EAAIC,WACAD,EAAI5U,OAAS4U,EAAIC,MACjBX,EAAI4B,OAAOV,EAAU,GAChBlB,EAAIhP,QACLZ,KAAKf,KAAKuE,OAAOgN,KAK7B,GAAIF,EAAI5U,QAAU8N,EAEd,YADA8G,EAAI5U,QAGR,MAAMqW,EAAS,CACX9R,MAAOqQ,EAAIrQ,MACXvE,MAAO8N,EAAI,EACX+G,IAAKD,EAAIC,KAEbD,EAAIC,IAAM/G,EACVoG,EAAI4B,OAAOV,EAAW,EAAG,EAAGiB,EAChC,CACA,SAAAhB,CAAUnB,EAAKpG,GACX,IAAK,IAAIlB,EAAQ,EAAGA,EAAQsH,EAAIhP,OAAQ0H,IAAS,CAC7C,MAAQiI,IAAKyB,GAASpC,EAAItH,GAC1B,GAAIkB,EAAIwI,EACJ,OAAO1J,CAEf,CACA,OAAOsH,EAAIhP,MACf,CACA,OAAAK,CAAQC,EAAUkD,GACd,MAAM6N,EAAc7N,GAAS6N,YAC7B,IAAK,MAAOC,EAAWtC,KAAQ5P,KAAKf,KAAM,CACtC,MAAMkT,EAAWF,EAAc,IAAIrC,GAAOA,EAC1C,IAAK,MAAMU,KAAO6B,EACdjR,EAASgR,EAAYlS,KAAKpD,MAAO0T,EAAKV,EAE9C,CACJ,CACA,UAAAwC,CAAWlR,GACP,IAAK,MAAOgR,EAAWtC,KAAQ5P,KAAKf,KAChCiC,EAASgR,EAAYlS,KAAKpD,MAAOgT,EAEzC,CACA,KAAAyC,GACIrS,KAAKf,KAAKoT,OACd,CACA,IAAA7Q,GACI,MAAO,IAAIxB,KAAKf,KAAKuC,OACzB,CACA,YAAA4D,CAAawL,EAAI,EAAGrL,GACXA,EAIDA,EAAU8K,KAAK,GAHf9K,EAAY,IAAIvF,KAAKmQ,qBAAqBnQ,KAAKpD,MAAQoD,KAAKnD,OAASmD,KAAKkQ,UAK9E,MAAM,MAAEtT,EAAK,OAAEC,EAAM,SAAEqT,GAAalQ,KACpC,IAAK,IAAIwQ,EAAI,EAAGA,EAAI3T,EAAQ2T,IAAK,CAC7B,MAAMZ,EAAM5P,KAAK2Q,OAAOH,EAAGI,GAC3B,GAAKhB,EAGL,GAAiB,IAAbM,EACA,IAAK,MAAMI,KAAOV,EAAK,CACnB,MAAM0C,EAAY9B,EAAI5T,GAChB,MAAElB,EAAK,IAAE6U,EAAG,MAAEtQ,GAAUqQ,EAC9B,IAAK,IAAI9G,EAAI9N,EAAO8N,EAAI+G,EAAK/G,IACzBjE,EAAU+M,EAAY9I,GAAKvJ,CAEnC,MAGA,IAAK,MAAMqQ,KAAOV,EAAK,CACnB,MAAM0C,EAAY9B,EAAI5T,EAAQsT,GACxB,MAAExU,EAAK,IAAE6U,EAAG,MAAEtQ,GAAUqQ,EAC9B,IAAK,IAAI9G,EAAI9N,EAAO8N,EAAI+G,EAAK/G,GAAK0G,EAC9B,IAAK,IAAIqC,EAAO,EAAGA,EAAOrC,EAAUqC,IAChChN,EAAU+M,EAAY9I,EAAI+I,GAAQtS,EAAMsS,EAGpD,CAER,CACA,OAAOhN,CACX,CACA,SAAAiN,CAAUhJ,EAAGgH,EAAGI,EAAG3Q,EAAOmE,GACtB,MAAMkM,EAAMtQ,KAAKyQ,OAAOjH,EAAGgH,EAAGI,GAC9B,IAAKN,EACD,MAAM,IAAIlS,MAAM,iBAAiBoL,KAAKgH,KAAKI,sBAE/C,MAAM6B,EAAQ,CAAC,CAACnC,EAAKE,EAAGI,IAClB8B,EAAepC,EAAIrQ,MACzB,GAAIyS,IAAiBzS,EACjB,MAAM,IAAI7B,MAAM,WAAWsU,uBAAkCzS,oBAEjE,OAAOD,KAAK2S,MAAMF,EAAOC,EAAczS,EAAOmE,EAClD,CACA,KAAAuO,CAAMF,EAAOG,EAAa3S,EAAOmE,GAC7B,IAAIyO,EAAM,EACV,MAAM,OAAEC,GAAS,EAAI,UAAEC,GAAY,EAAI,YAAEC,GAAc,GAAW5O,GAAW,CAAC,EACxE6O,EAAe,CAAEH,SAAQC,YAAWC,eAC1C,KAAOP,EAAM7R,QAAQ,CACjB,MAAMsS,EAAMT,EAAMU,OACXrQ,GAAWoQ,EAClB,GAAIpQ,EAAQ7C,QAAU2S,EAClB,SAEJ9P,EAAQ7C,MAAQA,EAChB4S,GAAO/P,EAAQyN,IAAMzN,EAAQpH,MAC7B,MAAM0X,EAAYpT,KAAKqT,cAAcH,EAAKD,GAAcK,OAAQC,GAAaA,GAAYA,EAAS,GAAGtT,QAAU2S,GAC/GH,EAAMhK,QAAQ2K,EAClB,CACA,OAAOP,CACX,CACA,QAAAW,CAASC,EAAQC,GACb,IAAK,IAAI9C,EAAI8C,EAAU,GAAG,GAAI9C,GAAK8C,EAAU,GAAG,GAAI9C,IAChD,IAAK,IAAIJ,EAAIkD,EAAU,GAAG,GAAIlD,GAAKkD,EAAU,GAAG,GAAIlD,IAAK,CACrD,IAAIF,EACAV,EACJ,IAAK,IAAIpG,EAAIkK,EAAU,GAAG,GAAIlK,GAAKkK,EAAU,GAAG,GAAIlK,IAAK,CACrD,MAAMvJ,EAAQwT,EAAOjK,EAAGgH,EAAGI,QACb5S,IAAViC,GAIC2P,IACDA,EAAM,GACN5P,KAAKf,KAAKiB,IAAIsQ,EAAII,EAAI5Q,KAAKnD,OAAQ+S,IAEnCU,GAAOA,EAAIrQ,QAAUA,IACrBqQ,OAAMtS,GAELsS,IACDA,EAAM,CAAE5U,MAAO8N,EAAG+G,IAAK/G,EAAGvJ,SAC1B2P,EAAInH,KAAK6H,IAEbA,EAAIC,OAdAD,OAAMtS,CAed,CACJ,CAER,CACA,aAAAqV,CAAcM,GAAM,UAAEZ,GAAY,EAAI,OAAED,GAAS,EAAI,YAAEE,GAAc,IACjE,MAAO1C,EAAKE,EAAGI,EAAGgD,GAAkBD,GAC9B,MAAEjY,EAAK,IAAE6U,GAAQD,EACjBuD,EAAUnY,EAAQ,GAAKsE,KAAKyQ,OAAO/U,EAAQ,EAAG8U,EAAGI,GACjDkD,EAAWvD,EAAMvQ,KAAKpD,OAASoD,KAAKyQ,OAAOF,EAAKC,EAAGI,GACnDvG,EAAQ0I,EACR,CAACrX,EAAQ,EAAIA,EAAQ,EAAIA,EAAO6U,EAAMvQ,KAAKpD,MAAQ2T,EAAM,EAAIA,GAC7D,CAAC7U,EAAO6U,GACR6C,EAAY,GACdS,GACAT,EAAU3K,KAAK,CAACoL,EAASrD,EAAGI,IAE5BkD,GACAV,EAAU3K,KAAK,CAACqL,EAAUtD,EAAGI,IAEjC,IAAK,MAAMmD,KAASH,IACfZ,EAAc3D,EAAwBD,GAAe,CACtD,MAAO,CAAE4E,EAAQC,GAAUF,EACrBG,EAAQF,EAASxD,EACjB2D,EAAQF,EAASrD,EACvB,GAAIsD,EAAQ,GAAKA,GAASlU,KAAKnD,OAC3B,SAEJ,GAAIsX,EAAQ,GAAKA,GAASnU,KAAK8P,MAC3B,SAEJ,MAAMF,EAAM5P,KAAK2Q,OAAOuD,EAAOC,GAC/B,GAAKvE,EAGL,IAAK,MAAMwE,KAAWxE,EAAK,CACvB,MAAMyE,EAAmBT,GACpBZ,GAAe3D,GACfyD,GAAUmB,EAAS,GAAK1E,GACxBuD,GAAUmB,EAAS,GAAK3E,GACzBF,EACEgF,EAAQ7D,KAAOlG,EAAM,IAAM+J,EAAQ1Y,OAAS2O,EAAM,IACpD+I,EAAU3K,KAAK,CAAC2L,EAASF,EAAOC,EAAOE,GAE/C,CACJ,CACA,OAAOjB,CACX,E,kBCrXG,SAASkB,EAAaC,GACzB,OAAQC,EAASD,EAAY,cAAgBC,EAASD,EAAY,gBACtE,CACO,SAASC,EAASD,EAAYE,GACjC,MAAMC,EAAe,QAASH,EAAaA,EAAaA,EAAWI,MACnE,QAAKD,KAGIA,EAAaE,IAAIH,EAC9B,C,mFCPe,SAASI,EAAYF,EAAOG,GACvC,MAAMC,EAAqBD,EAAOE,cAC7B5S,MAAM,KACNoP,OAAO,GACPnJ,IAAI4M,aACH,WAAEC,GAiDZ,SAAuBH,GACnB,IAAIjX,EAAMqX,IACNzH,GAAOyH,IACX,IAAK,IAAI3L,EAAI,EAAGA,EAAIuL,EAAmBnU,OAAQ4I,GAAK,EAChD1L,EAAMb,KAAKa,IAAIA,EAAKiX,EAAmBvL,IACvCkE,EAAMzQ,KAAKyQ,IAAIA,EAAKqH,EAAmBvL,IAE3C,MAAM4L,GAAU1H,EAAM5P,GAAO,EAC7B,MAAO,CACHoX,WAAY,EAAEE,EAAQA,GACtBtX,MACA4P,MAER,CA9D2B2H,CAAcN,GAC/BjX,EAAMoX,EAAW,GACjBtY,EAAQsY,EAAW,GAAKA,EAAW,GACnCI,EAAO,mBACPC,EAA+B,GACrC,IAAK,IAAI/L,EAAI,EAAGA,EAAIuL,EAAmBnU,OAAQ4I,GAAK,EAAG,CACnD,IAAIvJ,EAAQ8U,EAAmBvL,GAC/B,MAAMgM,EAAIT,EAAmBvL,EAAI,GAC3BiM,EAAIV,EAAmBvL,EAAI,GAC3BkM,EAAIX,EAAmBvL,EAAI,GACjCvJ,GAASA,EAAQnC,GAAOlB,EACxB2Y,EAA6B9M,KAAK,CAACxI,EAAOuV,EAAGC,EAAGC,GACpD,EAmDJ,SAAkC1I,EAAQ3C,EAAOiL,GAC7C,MAAM1Y,EAAQyN,EAAM,GAAKA,EAAM,GACzBsL,EAAW3I,EAAO3E,IAAI,EAAE/K,EAAGkY,EAAGC,EAAGC,KAAO,CAC1CpY,EAAIV,EAAQyN,EAAM,GAClBmL,EACAC,EACAC,IAEJJ,EAAKM,kBACLD,EAAS1U,QAAQ,EAAE3D,EAAGkY,EAAGC,EAAGC,KAAOJ,EAAKO,YAAYvY,EAAGkY,EAAGC,EAAGC,GAEjE,CA7DII,CAAyBP,EAA8BL,EAAYI,GACnEX,EAAMoB,cAAcC,uBAAuB,EAAGV,GAC9C,MAAMW,EAAqBnB,EAAOoB,cAC7B9T,MAAM,KACNoP,OAAO,GACPnJ,IAAI4M,YACHkB,EAAO,mBACPC,EAAa,GACnB,IAAK,IAAI5M,EAAI,EAAGA,EAAIyM,EAAmBrV,OAAQ4I,GAAK,EAAG,CACnD,IAAIvJ,EAAQgW,EAAmBzM,GAC/B,MAAM6M,EAAUJ,EAAmBzM,EAAI,GACvCvJ,GAASA,EAAQnC,GAAOlB,EACxBwZ,EAAW3N,KAAK,CAACxI,EAAOoW,GAC5B,EAiDJ,SAAwCrJ,EAAQ3C,EAAOiM,GACnD,MAAM1Z,EAAQyN,EAAM,GAAKA,EAAM,GACzBsL,EAAW3I,EAAO3E,IAAI,EAAE/K,EAAGE,KAAO,CAACF,EAAIV,EAAQyN,EAAM,GAAI7M,IAC/D8Y,EAAIV,kBACJD,EAAS1U,QAAQ,EAAE3D,EAAGE,KAAO8Y,EAAIC,SAASjZ,EAAGE,GAEjD,CAtDIgZ,CAA+BJ,EAAYlB,EAAYiB,GACvD,MAAMM,EAAW9B,EAAMoB,cACvBU,EAASC,iBAAiB,EAAGP,GAC7B,MAAOQ,EAAkBC,EAAoBC,EAAkBC,GAAuBhC,EAAOiC,gBAAgB3U,MAAM,KAAKoP,OAAO,GAAGnJ,IAAI4M,YACtIwB,EAASO,sBAAsB,GAAG,GAClCP,EAASQ,+BAA+B,EAAGN,GAC3CF,EAASS,iCAAiC,EAAGN,GAC7CH,EAASU,+BAA+B,EAAGN,GAC3CJ,EAASW,iCAAiC,EAAGN,GAChB,MAAzBhC,EAAOuC,eACPZ,EAASa,mCAEbb,EAASc,SAA0B,MAAjBzC,EAAO0C,OACzB,MAAMC,EAAUxC,WAAWH,EAAO2C,SAC5BC,EAAUzC,WAAWH,EAAO4C,SAC5BC,EAAW1C,WAAWH,EAAO6C,UAC7BC,EAAgB3C,WAAWH,EAAO8C,eACxCnB,EAASoB,WAAWJ,GACpBhB,EAASqB,WAAWJ,GACpBjB,EAASsB,YAAYJ,GACrBlB,EAASuB,iBAAiBJ,EAC9B,C,6DC5BA,QAzBkBK,IACd,MAAMC,EAUV,SAAwDD,GACpD,MAAME,GAAwB,UACxBD,EAAgC,GAUtC,OATAC,EAAsBlX,QAASmX,IAC3B,MAAMC,GAAY,OAAyBJ,GACvCI,EAAUzX,QACVsX,EAA8BzP,KAAK,CAC/B2P,kBACAE,YAAaD,EAAUhQ,IAAKnM,GAAaA,EAASiN,QAIvD+O,CACX,CAvB0CK,CAA+CN,GAChFC,GAA+BtX,QAGpCsX,EAA8BjX,QAAQ,EAAGmX,kBAAiBE,kBACjDF,EAAgBI,kBACjBJ,EAAgBK,gBAAgBH,K,uECDrC,SAASI,EAAoBvU,GAChC,MACMwU,EAAsB,IADH,MAAa,EAAAC,gBAAgBC,YAAa1U,IAwBnE,OApBKwU,EAAoBhb,qBACrBgb,EAAoBhb,mBAAqB,GAExCgb,EAAoBjb,kBACrBib,EAAoBjb,gBAAkB,GAErCib,EAAoBhQ,gBACrBgQ,EAAoBhQ,cAAgB,CAAC,EAAG,EAAG,IAE1CgQ,EAAoBjQ,aACrBiQ,EAAoBjQ,WAAa,CAAC,EAAG,EAAG,IAEvCiQ,EAAoB9Q,uBACrB8Q,EAAoB9Q,qBAAuB,CAAC,EAAG,EAAG,IAEjD8Q,EAAoB5Q,0BACrB4Q,EAAoB5Q,wBAA0B,IAAIgB,aAAa,CAC3D,EAAG,EAAG,EAAG,EAAG,EAAG,KAGhB4P,CACX,CAmBO,SAASG,EAActd,GAC1B,MAAM2I,EAAU3I,EAAM2I,SAChB,oBAAEoD,EAAmB,cAAEJ,EAAa,WAAEC,EAAU,QAAEC,EAAO,0BAAE6B,EAAyB,gBAAE5B,GAAqB,MAAa,mBAAoBnD,IAC5I,YAAE3F,EAAW,aAAEC,EAAY,eAAEsa,GAAmBvd,GAChD,SAAE2C,GAAa,MAAa,sBAAuBgG,GACnD6U,EAAuB,MAAa,gBAAiB7U,GACrD8U,EAAc,MAAa,EAAAL,gBAAgBM,YAAa/U,GACxDgV,EA1DH,SAAgCJ,GACnC,OAAKnZ,OAAOwZ,OAAO,EAAAC,oBAAoBC,SAASP,GAGzCA,EAFI,EAAAM,mBAAmBE,MAGlC,CAqD+BC,CAAuBT,GAElD,MAAO,CACHE,cACAQ,cAAeT,EACfD,eAAgBI,EAChBhb,WACAqI,iBANqBkS,EAAoBvU,GAOzC+C,iBAAkB,CACdC,gBACAC,aACAE,kBACAD,UACA6B,4BACA3B,sBACA/I,YAAaA,EACbC,aAAcA,EACdN,WACA4a,eAAgBI,GAG5B,C,uEC9Ee,SAASO,EAAgCC,GACpD,MAAQ9R,qBAAsB+R,EAA6B,wBAAE7R,GAA6B,MAAa,mBAAoB4R,EAAS,IAC9HE,EAAe,gBAAgB9R,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IAC/G+R,EAAe,gBAAgB/R,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IAC/GgS,EAAiB,cACvB,WAAWA,EAAgBF,EAAcC,GACzC,MAAME,EAAY,gBAAgBJ,EAA8B,GAAIA,EAA8B,GAAIA,EAA8B,IAEpI,IAAIjS,EACJ,SAASsS,EAAY9V,GACjB,MAAM,qBAAE0D,GAAyB,MAAa,mBAAoB1D,GAC5D+V,EAAiB,cACjBC,EAAS,gBAAgBtS,EAAqB,GAAIA,EAAqB,GAAIA,EAAqB,IAEtG,OADA,SAASqS,EAAgBF,EAAWG,GAC7B,SAASD,EAAgBH,EACpC,CACA,GATmD,YAA9BJ,EAAS,GAAGvX,MAAM,KAAK,GAwBvC,CACD,MAAMgY,EAAqB,CACvBT,EAAS,GACTA,EAAS1c,KAAKsP,MAAMoN,EAAS/Y,OAAS,KAIpCyZ,GAFqBJ,EAAYG,EAAmB,IAC9BH,EAAYG,EAAmB,IAC5B,MAAa,mBAAoBA,EAAmB,KACnF,IAAKC,EACD,MAAM,IAAIjc,MAAM,yDAEpB,MAAM8b,EAAiB,cACjBI,EAAe,gBAAgBD,EAAuBxS,qBAAqB,GAAIwS,EAAuBxS,qBAAqB,GAAIwS,EAAuBxS,qBAAqB,IACjL,SAASqS,EAAgBF,EAAWM,GACpC,MAAMC,EAAsC,SAASL,EAAgBH,GACrEpS,EACI1K,KAAKud,IAAID,GACLtd,KAAKsP,MAAMoN,EAAS/Y,OAAS,EACzC,KAjCmB,CACf,MAAM6Z,EAAqBd,EAAStR,IAAKlE,IAE9B,CACHuW,SAFaT,EAAY9V,GAGzBA,aAGRsW,EAAmBE,KAAK,CAACC,EAAGlF,IAAMA,EAAEgF,SAAWE,EAAEF,UACjD,MAAMG,EAAYJ,EAAmB7Z,OACrC+G,EACI1K,KAAKud,IAAIC,EAAmBI,EAAY,GAAGH,SACvCD,EAAmB,GAAGC,WACrBG,EAAY,EACzB,CAoBA,MAAM,eAAEC,EAAc,qBAAEC,GAAyB,MAAa,mBAAoBpB,EAAS,KACrF,gCAAEqB,IAAoC,UAAmBC,UAe/D,OAdiB,IAAZtT,IAAiBuT,MAAMvT,IAAcqT,IAClCD,GACApM,QAAQwM,MAAM,2DACdxT,EAAUoT,GAELD,GACLnM,QAAQwM,MAAM,iFACdxT,EAAUmT,IAGVnM,QAAQwM,MAAM,gHACdxT,EAAU,IAGXA,CACX,C,kBCtEA,SAASyT,EAAMnb,EAAOnC,EAAK4P,GACvB,OAAOzQ,KAAKyQ,IAAI5P,EAAKb,KAAKa,IAAI4P,EAAKzN,GACvC,C,kVCGA,MAAMob,EAAa,IAAItL,IACvB,SAASuL,EAAiBnf,GACtBA,EAASmE,KAAOnE,EAASmE,MAAQnE,EAASof,KAC1CF,EAAWnb,IAAI/D,EAASmE,KAAMnE,EAClC,CACA,SAASqf,EAAYlb,GACjB,OAAO+a,EAAWjb,IAAIE,EAC1B,CACA,SAASmb,IACL,OAAO/c,MAAM6D,KAAK8Y,EAAW7Z,OACjC,CACA,SAASka,EAAqBC,EAAWhH,GACrC,MAAMiH,EAAe,IAAaC,eAAexT,IAAKyT,GAAe,IAAaC,gBAAgBD,IAC5FE,EAAgBP,IAAmBpT,IAAK4T,GAAiBT,EAAYS,IAErEC,EADYN,EAAaO,OAAOH,GACJI,KAAMjgB,IACpC,MAAQkgB,UAAWC,GAAoBngB,EACvC,GAAImgB,EAAgB1b,SAAW+a,EAAU/a,OACrC,OAAO,EAEX,IAAK,IAAI4I,EAAI,EAAGA,EAAI8S,EAAgB1b,OAAQ4I,GAAK,EAC7C,KAAK,QAAQ8S,EAAgB5b,MAAM8I,EAAI,EAAGA,EAAI,GAAImS,EAAUjb,MAAM8I,EAAI,EAAGA,EAAI,IACzE,OAAO,EAGf,OAAO,IAEX,IAAK0S,EACD,OAAO,KAEX,MAAM7F,EAAU,GAChB,IAAI,OAAS1B,EAAO,aAAc,CAC9B,MAAM4H,EAAgB5H,EACjBoB,cACAyG,iBAAiB,GACjBC,iBACL,IAAKF,EACD,MAAO,CACHjc,KAAM4b,EAAgBX,MAG9B,IAAK,IAAI/R,EAAI,EAAGA,EAAI+S,EAAc3b,OAAQ4I,GAAK,EAC3C6M,EAAQ5N,KAAK,CACTxI,MAAOsc,EAAc/S,GACrB6M,QAASkG,EAAc/S,EAAI,IAGvC,CAMA,MALe,CACXlJ,KAAM4b,EAAgBX,QAClB7c,MAAMC,QAAQ0X,IAAYA,EAAQzV,OAAS,GAAK,CAAEyV,cAC/B,iBAAZA,GAAwB,CAAEA,WAG7C,CACO,SAASqG,EAA0CC,GACtD,MAAM,YAAEC,EAAW,OAAE9H,EAAM,QAAEuB,EAAU,GAAG,UAAEwG,EAAY,KAAI,WAAEC,EAAa,CAAC,EAAG,IAAQH,EACxEC,EAAYG,YACpBC,kBAAkB,GACzB,MAAM1H,EAAO,mBACP2H,EAAcnI,GAAU,IAAaiH,gBAAgB,OAC3DzG,EAAK4H,cAAcD,GACnB3H,EAAK6H,gBAAgBL,EAAW,GAAIA,EAAW,IAC/CF,EAAY7G,cAAcC,uBAAuB,EAAGV,GACpD8H,EAA2BR,EAAavG,EAASwG,EACrD,CACO,SAASQ,EAAcT,EAAaU,GAEvCF,EAA2BR,EAAaU,EADfC,EAAkBX,GAE/C,CACO,SAASY,EAAgBZ,EAAaa,GAEzCL,EAA2BR,EADJc,EAAcd,GACmBa,EAC5D,CACA,SAASL,EAA2BR,EAAavG,EAASwG,GACtD,MAAMc,EAAOf,EAAYG,YAAYa,eAAexd,IAAI,gBACxD,IAAKud,GAAM3Y,aACP,MAAM,IAAI5G,MAAM,2HAEpB,MAAMiM,EAAQsT,EAAK3Y,aAAa6Y,WAC1B1H,EAAO,mBACb,GAAkB,OAAd0G,EAAoB,CACpB,MAAM9I,EAAwC,KAAhC9W,KAAKud,IAAInQ,EAAM,GAAKA,EAAM,IAClCyT,EAAiB7gB,KAAKyQ,IAAIrD,EAAM,GAAIpN,KAAKa,IAAIuM,EAAM,GAAIwS,IAC7D1G,EAAKI,SAASlM,EAAM,GAAI,GACxB8L,EAAKI,SAASuH,EAAiB/J,EAAO,GACtCoC,EAAKI,SAASuH,EAAgBzH,GAC9BF,EAAKI,SAASlM,EAAM,GAAIgM,EAC5B,MAEIF,EAAKI,SAASlM,EAAM,GAAIgM,GACxBF,EAAKI,SAASlM,EAAM,GAAIgM,GAE5BuG,EAAY7G,cAAcW,iBAAiB,EAAGP,EAClD,CACA,SAASoH,EAAkBX,GACvB,MAAMmB,EAAkBnB,EAAY7G,cAAcyG,iBAAiB,GACnE,IAAKuB,EACD,OAAO,KAEX,MAAMC,EAAYD,EAAgBtB,iBAClC,IAAKuB,GAAaA,EAAUpd,QAAU,EAClC,OAAO,KAEX,IAAK,IAAI4I,EAAI,EAAGA,EAAIwU,EAAUpd,OAAS,EAAG4I,GAAK,EAAG,CACnCwU,EAAUxU,GAArB,MACMyU,EAAKD,EAAUxU,EAAI,GACnB0U,EAAKF,EAAUxU,EAAI,GACnB2U,EAAKH,EAAUxU,EAAI,GACzB,GAAW,IAAPyU,GAAYE,EAAK,EACjB,OAAOD,CAEf,CACA,OAAO,IACX,CACA,SAASR,EAAcd,GACnB,MAAMmB,EAAkBnB,EAAY7G,cAAcyG,iBAAiB,GACnE,IAAKuB,EACD,OAAO,EAEX,MAAMC,EAAYD,EAAgBtB,iBAClC,IAAKuB,GAAkC,IAArBA,EAAUpd,OACxB,OAAO,EAEX,IAAIwd,EAAa,EACjB,IAAK,IAAI5U,EAAI,EAAGA,EAAIwU,EAAUpd,OAAQ4I,GAAK,EACnCwU,EAAUxU,GAAK4U,IACfA,EAAaJ,EAAUxU,IAG/B,OAAO4U,CACX,C,gDCvIe,SAASC,EAAgCC,GACpD,MAAMhJ,EAAO,mBACb,IAAIiJ,EAAQ,EACRC,EAAQ,KAOZ,YANuBxgB,IAAnBsgB,EAASC,YAA0CvgB,IAAnBsgB,EAASE,QACzCD,EAAQD,EAASC,MACjBC,EAAQF,EAASE,OAErBlJ,EAAKO,YAAY0I,EAAO,EAAK,EAAK,GAClCjJ,EAAKO,YAAY2I,EAAO,EAAK,EAAK,GAC3BlJ,CACX,C,iFCRe,SAASmJ,EAAiCH,EAAUI,EAAqB,MACpF,MAAM,YAAElgB,EAAW,aAAEC,GAAiB,gBAA8B6f,EAASC,MAAOD,EAASE,OAEvFG,EADQjgB,MAAM6D,KAAK,CAAE3B,OAAQ8d,GAAsB,CAACE,EAAGpV,KAAOA,EAAI,IAAMkV,EAAqB,IAC/EG,QAASrhB,GAElB,EADG,OAAMA,EAAGiB,EAAcD,GACtBhB,EAAGA,EAAGA,EAAG,GAAK,IAEvB8X,EAAO,mBAKb,OAJAA,EAAKwJ,uBAAuB,iBAAyB,CACjD1F,OAAQuF,EACR1Z,mBAAoB,KAEjBqQ,CACX,C,kBCjBe,SAASyJ,EAASC,EAAMC,EAAYpT,EAAS,GACxD,MAAMqT,EAAoB,GAC1B,IAAK,IAAI1V,EAAIqC,EAAQrC,EAAIwV,EAAKpe,OAAQ4I,GAAKyV,EACvCC,EAAkBzW,KAAKe,GAE3B,OAAO0V,CACX,C,kCCNO,SAASC,EAAUC,GACtB,GAAY,OAARA,GAA+B,iBAARA,EACvB,OAAOA,EAEX,GAAmB,mBAARA,EACP,OAAOA,EAEX,GAA+B,mBAApBvP,gBACP,OAAOuP,EAEX,GAAI1gB,MAAMC,QAAQygB,GACd,OAAOA,EAAI/W,IAAI8W,GAEd,CACD,MAAME,EAAY,CAAC,EACnB,IAAK,MAAMlf,KAAOif,EACVxf,OAAOiB,UAAUC,eAAeC,KAAKqe,EAAKjf,KAC1Ckf,EAAUlf,GAAOgf,EAAUC,EAAIjf,KAGvC,OAAOkf,CACX,CACJ,C,kCCtBe,SAASC,EAAUC,GAC9B,IAAIC,EAAO,WACX,IAAK,IAAIhW,EAAI,EAAGA,EAAI+V,EAAI3e,OAAQ4I,IAC5BgW,GAAQD,EAAIE,WAAWjW,GACvBgW,IACKA,GAAQ,IAAMA,GAAQ,IAAMA,GAAQ,IAAMA,GAAQ,IAAMA,GAAQ,IAEzE,OAAQA,IAAS,GAAGE,SAAS,GACjC,C,4GCHA,MAAMC,EAAM,EAAAC,QAAQC,UAAU,YAAa,qBAC5B,SAASC,EAAkBC,EAAaC,EAAUC,EAAiB7b,GAC9E,MAAM,UAAE0D,EAAS,QAAEH,EAAO,SAAEgS,GAAaoG,GACnC,cAAEG,GAAgB,GAAU9b,GAAW,CAAC,EAC9C,IAAKuV,GAAU/Y,OACX,OAEJ,MAAMuf,EAAUrY,EAAUpH,MAAM,EAAG,GAC7B0f,EAAa,SAASD,EAASF,GACrC,GAAIhjB,KAAKud,IAAI4F,GAAc,EAAI,EAAAC,QAC3B,OAEJ,IAAIC,EAKAC,EAJJ,IAAKL,EAAe,CAEhBI,GADiC,OAA4B,CAAExY,YAAWH,WAAWsY,GAC3B,CAC9D,CAEA,IAAIO,EAAcrL,IAClB,IAAK,IAAI3L,EAAI,EAAGA,EAAImQ,EAAS/Y,OAAQ4I,IAAK,CACtC,MAAMrF,EAAUwV,EAASnQ,GACnBhD,EAAmB,MAAa,mBAAoBrC,GAC1D,IAAKqC,GAAkBqB,qBAAsB,CACzC8X,EAAI/Q,KAAK,6CAA6CzK,KACtD,QACJ,CACA,MAAM,qBAAE0D,GAAyBrB,EAC3Bia,EAAM,cACZ,SAASA,EAAKT,EAAUnY,GACxB,MAAM6S,EAAWzd,KAAKud,IAAI,SAASiG,EAAKR,IACpCC,EACIxF,EAAW8F,IACXA,EAAc9F,EACd6F,EAAiBpc,GAIjBuW,EAAW4F,GAAgC5F,EAAW8F,IACtDA,EAAc9F,EACd6F,EAAiBpc,EAG7B,CAIA,YAHuBnG,IAAnBuiB,GACAZ,EAAI/Q,KAAK,sFAEN2R,CACX,C,uECjDO,SAASG,EAAqBllB,GACjC,MAAM,iBAAEgL,EAAgB,iBAAEU,EAAgB,eAAE6R,EAAc,SAAE5a,EAAQ,cAAEsb,EAAa,YAAER,IAAiB,QAAczd,GACpH,IAAI,WAAEkN,EAAU,cAAEC,GAAkBnC,EAClB,MAAdkC,GAAuC,MAAjBC,IACtBD,EAAa,CAAC,EAAG,EAAG,GACpBC,EAAgB,CAAC,EAAG,EAAG,IAE3B,MAAMkR,EAAe,gBAAgBnR,EAAW,GAAIA,EAAW,GAAIA,EAAW,IACxEoR,EAAe,gBAAgBnR,EAAc,GAAIA,EAAc,GAAIA,EAAc,IACjFoR,EAAiB,cACvB,WAAWA,EAAgBF,EAAcC,GACzC,IAAIlS,EAASpB,EAAiBqB,qBAChB,MAAVD,IACAA,EAAS,CAAC,EAAG,EAAG,IAEpB,MAAM+Y,EAAWna,EAAiB7I,oBAAsBnC,EAAMmC,mBACxDijB,EAAWpa,EAAiB9I,iBAAmBlC,EAAMkC,gBACrDmjB,EAAUrlB,EAAMwD,QAChB8hB,EAAUtlB,EAAMyD,KAChB8hB,EAAW,EAAAV,QAEZnZ,EAAiBgC,2BAClB1N,EAAMuO,cAAgB,EAAIvO,EAAMoB,MAAQpB,EAAMqB,SAC9CrB,EAAMyJ,mBAAqB,GAI/B,MAAO,CACHA,mBAHuBzJ,EAAMyJ,oBAmBrC,SAAmDiE,GAC/C,IAAIjE,EAAqB,GACS,QAA9BiE,GACAA,GAA2BoQ,SAAS,QACN,kBAA9BpQ,KACAjE,EAAqB,GAEzB,OAAOA,CACX,CA1BQ+b,CAA0C9Z,EAAiBgC,2BAG3DtB,SACAE,UAAW,IAAI+R,KAAiBC,KAAiBC,GACjDrS,WAAY,CAACmZ,EAASC,EAXV,GAYZnZ,QAAS,CAACgZ,EAAUC,EAAUG,GAC9BE,UAAWJ,EAAUC,EAbT,EAcZta,mBACAU,mBACAC,cAAeD,EAAiBC,cAChC4R,iBACA5a,WACAsb,gBACAR,cACAc,eAAgBA,EAExB,C,6DCbA,QA/BA,SAA4C7d,GACxC,MAAMglB,EAAShlB,EAASilB,aAClB,yBAAEC,EAAwB,YAAErB,IAAgB,OAAqC7jB,EAAUglB,GACjG,IAAKnB,EACD,OAEJ,MAAM,gBAAEE,EAAe,WAAEoB,GAAeH,EAClC3M,EAAarY,EACdolB,YACAlF,KAAMxB,GAAMA,EAAE2G,eAAiBxB,EAAY9H,UAC5C2C,EAAE4G,MAAQzB,EAAY9H,UACrB1D,GACD5F,QAAQC,KAAK,sCAAuCmR,EAAY9H,UAEpE,MAAM2E,EAAcrI,EAAWI,MACzB8M,GAAa,OAAc7E,EAAaqD,EAAiBoB,IACzD,IAAEvjB,EAAG,IAAE4P,EAAG,QAAE5K,GAAY2e,EACxBC,EAAiBzkB,KAAK0kB,OAAOjU,EAAM5P,GAAOsjB,GAA4B,EAC5E,IAAIQ,GAAe9e,EAAUhF,IAAQ4P,EAAM5P,GAAQ4jB,EAQnD,OAPAE,EAAa3kB,KAAKsP,MAAMqV,GACpBA,EAAaF,EAAiB,EAC9BE,EAAaF,EAAiB,EAEzBE,EAAa,IAClBA,EAAa,GAEV,CACHF,iBACAE,aAER,C,kDC/Be,SAASC,EAAqB1d,GACzC,MAAM2d,EAAoB,MAAa,oBAAqB3d,IAAY,CAAC,EACnE4d,EAAsB,MAAa,sBAAuB5d,IAAY,CAAC,GACvE,SAAEhG,GAAa4jB,EACfC,EAAoB,CACtBC,aAAcH,EAAkBG,cAAgB,EAChDC,iBAAkBJ,EAAkBI,kBAAoB,EACxD/jB,YAEEgkB,EAAiB,MAAa,gBAAiBhe,IAAY,CAAC,EAClE,MAAO,IACA6d,KACc,OAAb7jB,GAAqB,CACrBikB,MAAOD,EAAeC,MACtBC,OAAQF,EAAeE,OACvBC,OAAQH,EAAeG,WAEV,WAAbnkB,GAAyB,CACzBokB,gBAAiBJ,EAAeK,gBAChCC,cAAeN,EAAeO,cAC9BC,SAAUR,EAAeS,SACzBC,SAAUV,EAAeW,UAGrC,C,wECtBA,MAAMC,EAAgB,EAAA1C,QAAU,EAAAA,QAC1B2C,EAAShV,GAAM/Q,KAAKud,IAAIvd,KAAKud,IAAIxM,GAAK,GAAK+U,EAC3CE,EAAS,CAACjV,EAAGkV,IAAQF,EAAMhV,EAAEkV,KAASF,EAAMhV,EAAEkV,EAAM,KAAOF,EAAMhV,EAAEkV,EAAM,IACzEC,EAAiBnV,GAAMiV,EAAOjV,EAAG,IAAMiV,EAAOjV,EAAG,IAAMiV,EAAOjV,EAAG,GACxD,SAASoV,EAAcxG,EAAaqD,EAAiBoB,GAChE,MAAMgC,EAAYzG,EAAYG,YAAYa,eAC1C,IAAI0F,EACJ,MAAMxb,EAAYub,EAAUE,eAC5B,GAAIJ,EAAcrb,GACdwb,GAAU,OAAsB1G,OAE/B,CACD,MAAO4G,EAAIC,EAAIC,GAAML,EAAUM,gBAW/BL,EAVmB,CACf,CAAC,EAAG,EAAG,GACP,CAACE,EAAK,EAAG,EAAG,GACZ,CAAC,EAAGC,EAAK,EAAG,GACZ,CAACD,EAAK,EAAGC,EAAK,EAAG,GACjB,CAAC,EAAG,EAAGC,EAAK,GACZ,CAACF,EAAK,EAAG,EAAGE,EAAK,GACjB,CAAC,EAAGD,EAAK,EAAGC,EAAK,GACjB,CAACF,EAAK,EAAGC,EAAK,EAAGC,EAAK,IAELrb,IAAKiC,GAAO+Y,EAAUO,aAAatZ,GAC5D,CACA,MAAM7N,EAAY,IACbonB,kBACAC,WACAC,qBAAqB9D,EAAiB,CAAC,EAAG,EAAG,IAClDqD,EAAQriB,QAAS+iB,GAAOvnB,EAAUwnB,MAAMD,IACxC,MAAME,EAAwB,IAAI7C,GAClC5kB,EAAUwnB,MAAMC,GAChB,MAAMC,EAAeD,EAAsB,GAC3C,IAAIE,EAAOjP,IACPkP,GAAQlP,IACZ,IAAK,IAAI3L,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,MAAMlM,EAAIgmB,EAAQ9Z,GAAG,GACjBlM,EAAI+mB,IACJA,EAAO/mB,GAEPA,EAAI8mB,IACJA,EAAO9mB,EAEf,CACA,MAAO,CACHQ,IAAKsmB,EACL1W,IAAK2W,EACLvhB,QAASqhB,EACTxP,MAAOiI,EACPqD,kBACAoB,aAER,C,iDCtDe,SAASiD,EAA4BvE,EAAaE,GAC7D,MAAM,UAAEnY,EAAS,QAAEH,GAAYoY,EACzBwE,EAAUzc,EAAUpH,MAAM,EAAG,GAC7B8jB,EAAU1c,EAAUpH,MAAM,EAAG,GAC7Byf,EAAUrY,EAAUpH,MAAM,EAAG,GAC7B+jB,EAAc,CAChB,SAASF,EAAStE,GAClB,SAASuE,EAASvE,GAClB,SAASE,EAASF,IAEhByE,EAAmB,cACzB,SAASA,EAAkBD,EAAY,GAAK9c,EAAQ,GAAI8c,EAAY,GAAK9c,EAAQ,GAAI8c,EAAY,GAAK9c,EAAQ,IAE9G,OADiC,YAAY+c,EAEjD,C,8FCVA,MAAMC,EAAe,EAAI,EAAAtE,QAEnBuE,EAAmBC,MAAa,IAAAC,0BAAyB1I,KAAM3X,IAAWzD,OAD5Due,EACuEsF,EAAO5M,UADzE8M,EACmFtgB,KAD7D8a,EAAIyF,UAAU,EAAG/nB,KAAKa,IAAIyhB,EAAI3e,OAAQmkB,EAAOnkB,SAAzE,IAAC2e,EAAKwF,IAEV,SAASE,EAAqC/oB,EAAUglB,EAAQgE,EAAUC,GAAmB,GACxG,MAAM,gBAAElF,GAAoBiB,EACtBkE,EAAelpB,EAASolB,YAC9B,IAAK8D,EAAaxkB,OACd,MAAO,CACHwgB,yBAA0B,KAC1BrB,YAAa,KACbsF,SAAU,MAGlB,MAAMC,EAAeF,EAChB/c,IAAKkd,IACN,MAAMF,EAAWE,EAAGhE,cAAgBgE,EAAG/D,IACvC,OAAO,KAAMgE,UAAUH,KAEtB/R,OAAQmS,KAASA,GACtB,GAAIP,EAAU,CACV,MAAMQ,GAAiB,OAAYR,GAC7BS,EAAmBL,EAAavU,UAAW0U,GAAOC,EAAepM,SAASmM,EAAGxN,WAC7E8H,EAAcuF,EAAaK,IACzBnE,IAAK6D,GAAaD,EAAaO,GAEvC,MAAO,CAAE5F,cAAaqB,yBADWwE,EAAmB7F,EAAaE,EAAiB/jB,EAAUipB,GAC5CE,WACpD,CACA,IAAKC,EAAa1kB,OACd,MAAO,CACHwgB,yBAA0B,KAC1BrB,YAAa,KACbsF,SAAU,MAGlB,MAAMQ,EAAW,CACbzE,yBAA0BjM,IAC1B4K,YAAa,KACbsF,SAAU,MAERS,EAAmBR,EAAalJ,KAAKwI,GAC3C,IAAK,IAAIpb,EAAI,EAAGA,EAAI8b,EAAa1kB,OAAQ4I,IAAK,CAC1C,MAAMuW,EAAcuF,EAAa9b,GACjC,GAAIsc,IAAqBlB,EAAgB7E,GACrC,SAEJ,MAAMqB,EAA2BwE,EAAmB7F,EAAaE,EAAiB/jB,GAC9EklB,EAA2BuD,EAC3BkB,EAASzE,2BACTyE,EAASzE,yBAA2BA,EACpCyE,EAAS9F,YAAcA,EACvB8F,EAASR,SAAWD,EAAa5b,GAAGgY,IAE5C,CACA,OAAOqE,CACX,CACA,SAASD,EAAmB7F,EAAaE,EAAiB/jB,EAAUipB,GAAmB,GACnF,MAAM,cAAEY,GAAkB7pB,EAAS8pB,gBACnC,IAAI5E,EAA2B2E,EAI/B,OAHKA,GAAkBZ,IACnB/D,GAA2B,OAA4BrB,EAAaE,IAEjEmB,CACX,C,kDCxDA,QAVA,SAAkCnJ,GAC9B,MAAMgO,GAAmB,UACnBC,EAAkB,GAMxB,OALAD,EAAiBhlB,QAASmX,IACtB,MACM+N,EADY/N,EAAgBgO,qBACE9S,OAAQ+S,GAAOA,EAAGC,YAAYrO,IAClEiO,EAAgBzd,QAAQ0d,KAErBD,CACX,C,kBCVe,SAASK,EAAqCjR,GACzD,IAAIkR,EAAY,GAChB,MAAOjI,EAAOC,GAASlJ,EAAKuI,WAC5BvI,EAAKmR,SAASlI,EAAOC,EAAO,KAAMgI,GAClCA,EAAYA,EAAUlT,OAAO,CAACtF,EAAG4C,IAAMA,EAAI,GAAM,GACjD,MAAM8V,EAAa,IAAIhoB,MAAM,MAAM8C,QAAQ6G,IAAI,CAAC2F,EAAG4C,IACxC2N,GAAUC,EAAQD,GAAS,KAAc3N,GAE9CqN,EAAKuI,EAAU,KACfG,EAAQ1pB,KAAK0iB,KAAK,EAAI1B,GAAMA,GAC5B2I,EAAKF,EAAW,KAChBvI,EAAKqI,EAAU,KACfK,EAAQ5pB,KAAK0iB,KAAK,EAAIxB,GAAMA,GAC5BD,EAAKwI,EAAW,KAChBI,EAAK7pB,KAAK0kB,MAAO,GAAKzD,EAAK0I,IAAQD,EAAQE,IAC3CE,EAAK9pB,KAAK0kB,MAAMiF,EAAME,EAAKH,EAAS,GAC1C,MAAO,CAAC1pB,KAAK0kB,MAAMoF,EAAKD,EAAK,GAAI7pB,KAAK0kB,MAAMoF,EAAKD,EAAK,GAC1D,C,kCCjBe,SAASE,EAAsBpK,GAC1C,MAAMyG,EAAYzG,EAAYG,YAAYa,eACpCqJ,EAAS5D,EAAU6D,eAAe7D,EAAU8D,aAClD,MAAO,CACH,CAACF,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAEtC,C,mDCbO,MAAMG,EAAelC,IACxB,MAAMhiB,EAAS,YACTqc,EAAM2F,EAAS5L,SAASpW,GACxBgiB,EAASF,UAAU9hB,GACnBgiB,EACA5c,EAAQiX,EAAIvc,QAAQ,eAC1B,OAAkB,IAAXsF,EAAeiX,EAAMA,EAAIyF,UAAU,EAAG1c,EAAQ,G,4DCgBzD,QApBA,SAAiCpM,EAAU+b,EAAUkN,GAAmB,GACpE,MAAMjE,EAAShlB,EAASilB,aAClB,WAAEE,EAAU,gBAAEpB,GAAoBiB,GAClC,yBAAEE,EAAwB,SAAEiE,IAAa,OAAqCnpB,EAAUglB,EAAQjJ,EAAUkN,GAChH,IAAKE,EACD,MAAM,IAAIjnB,MAAM,uCAAuC6Z,qBAE3D,MAAM1D,EAAarY,EAASmrB,SAAShC,GACrC,IAAK9Q,EAED,OADA5F,QAAQC,KAAK,sCAAuCyW,GAC7C,KAEX,MAAMzI,EAAcrI,EAAWI,MAE/B,MAAO,CACH8M,YAFe,OAAc7E,EAAaqD,EAAiBoB,GAG3DD,2BACAF,SAER,C,iDCHA,QAjBA,SAAqChlB,EAAU+b,EAAUkN,GAAmB,GACxE,MAAM,WAAE1D,EAAU,yBAAEL,EAAwB,OAAEF,IAAW,OAAwBhlB,EAAU+b,EAAUkN,IAC/F,IAAErnB,EAAG,IAAE4P,EAAG,QAAE5K,GAAY2e,EACxB6F,EAAiBrqB,KAAK0kB,OAAOjU,EAAM5P,GAAOsjB,GAE1CmG,GADYzkB,EAAUhF,IAAQ4P,EAAM5P,GACJwpB,EAEtC,MAAO,CACHA,iBACAE,iBAHqBvqB,KAAK0kB,MAAM4F,GAIhCE,eAAgB,CACZhG,aACAL,2BACAF,UAGZ,C,mCCjBO,MAAMwG,EAA6B1F,GACdpiB,OAAOwZ,OAAO4I,GAAmB2F,KAAM1nB,GAA2B,iBAAVA,IAAuBsK,OAAOqd,UAAU3nB,G,kBCD7G,SAAS4nB,EAAaC,GACjC,OAAIppB,MAAMC,QAAQmpB,GACPA,EAAMH,KAAM1nB,GAAUsK,OAAO2Q,MAAMjb,IAEvCsK,OAAO2Q,MAAM4M,EACxB,C,kCCLe,SAASC,EAAa5jB,GACjC,MAAM6jB,EAAa7jB,EAAQnB,QAAQ,KACnC,OAAOmB,EAAQ6gB,UAAUgD,EAAa,EAC1C,C,kECFA,MAAMC,EAA6B,IAAIlY,IACjCmY,EAA+B,6BAC/BC,EAAgC,CAClCD,+BACA7V,MAAO,KACH4V,EAA2B5V,SAE/B/O,IAAK,CAACnD,EAAKioB,KACPH,EAA2B/nB,IAAIC,EAAKioB,IAExCC,MAAO,IACI,IAAItY,IAAIkY,GAEnBK,QAAUC,IACNN,EAA2B5V,QAC3BkW,EAAMtnB,QAAQ,CAAChB,EAAOE,KAClB8nB,EAA2B/nB,IAAIC,EAAKF,MAG5CG,IAAK,CAACuG,KAAS6hB,KACX,GAAI7hB,IAASuhB,EACT,OAAOM,EACFngB,IAAKogB,GAAUR,EAA2B7nB,IAAIqoB,IAC9CrM,KAAM9R,QAActM,IAAPsM,MAI9B,IAAAoe,aAAYP,EAA8B/nB,IAAI2O,KAAKoZ,IACnD,S,u+FC7BIQ,E,qDACJ,SAAWA,GACPA,EAAoBA,EAA0B,KAAI,GAAK,OACvDA,EAAoBA,EAA6B,QAAI,GAAK,UAC1DA,EAAoBA,EAA4B,OAAI,GAAK,QAC5D,CAJD,CAIGA,IAAwBA,EAAsB,CAAC,IAClD,MAAMC,EACF,WAAAnpB,CAAYopB,GACR7oB,KAAK8oB,gBAAkB,IAAI/Y,IAC3B/P,KAAK+oB,UAAY,IAAIhZ,IACrB/P,KAAKgpB,QAAUH,CACnB,CACA,WAAII,GACA,OAAqC,IAA9BjpB,KAAK8oB,gBAAgBI,MAAsC,IAAxBlpB,KAAK+oB,UAAUG,IAC7D,CACA,gBAAAC,CAAiBxiB,EAAMzF,EAAUkD,GAC7B,MAAMglB,EAAWziB,EAAK3D,QAAQ,KAE9B,IADkC,IAAdomB,EACH,CACb,MAAMC,EAAiB1iB,EAAKqe,UAAU,EAAGoE,GACzC,IAAIE,EAA4BtpB,KAAK+oB,UAAU3oB,IAAIipB,GAC9CC,IACDA,EAA4B,IAAIV,EAAqB5oB,KAAKgpB,SAC1DhpB,KAAK+oB,UAAU7oB,IAAImpB,EAAgBC,IAEvC3iB,EAAOA,EAAKqe,UAAUoE,EAAW,GACjCE,EAA0BH,iBAAiBxiB,EAAMzF,EAAUkD,EAC/D,MAEIpE,KAAKupB,kBAAkB5iB,EAAMzF,EAAUkD,EAE/C,CACA,mBAAAolB,CAAoB7iB,EAAMzF,EAAUkD,GAChC,MAAMglB,EAAWziB,EAAK3D,QAAQ,KAE9B,IADkC,IAAdomB,EACH,CACb,MAAMC,EAAiB1iB,EAAKqe,UAAU,EAAGoE,GACnCE,EAA4BtpB,KAAK+oB,UAAU3oB,IAAIipB,GACrD,IAAKC,EACD,OAEJ3iB,EAAOA,EAAKqe,UAAUoE,EAAW,GACjCE,EAA0BE,oBAAoB7iB,EAAMzF,EAAUkD,GAC1DklB,EAA0BL,SAC1BjpB,KAAK+oB,UAAUvlB,OAAO6lB,EAE9B,MAEIrpB,KAAKypB,qBAAqB9iB,EAAMzF,EAAUkD,EAElD,CACA,KAAAslB,GACIhrB,MAAM6D,KAAKvC,KAAK+oB,UAAUY,WAAW1oB,QAAQ,EAAER,EAAWmpB,MAEtD,GADAA,EAAMF,SACFE,EAAMX,QAIN,MAAM,IAAI7qB,MAAM,4CAHhB4B,KAAK+oB,UAAUvlB,OAAO/C,KAM9BT,KAAK6pB,sBACT,CACA,iBAAAN,CAAkB5iB,EAAMzF,EAAUkD,GAC9B,IAAI0lB,EAAe9pB,KAAK8oB,gBAAgB1oB,IAAIuG,GACvCmjB,IACDA,EAAe,IAAI/Z,IACnB/P,KAAK8oB,gBAAgB5oB,IAAIyG,EAAMmjB,IAEnC,MACMC,EADa3lB,GAAS4lB,UAAW,EAEjCrB,EAAoBsB,QACpBtB,EAAoBuB,OACpBC,EAAmBL,EAAa1pB,IAAIc,IAAaynB,EAAoByB,KACvED,EAAmBJ,EACnBpb,QAAQC,KAAK,oDAGjBkb,EAAa5pB,IAAIgB,EAAUipB,EAAmBJ,GAC9C/pB,KAAKgpB,QAAQG,iBAAiBxiB,EAAMzF,EAAUkD,GAClD,CACA,oBAAAqlB,CAAqB9iB,EAAMzF,EAAUkD,GACjC,MACM2lB,EADa3lB,GAAS4lB,UAAW,EAEjCrB,EAAoBsB,QACpBtB,EAAoBuB,OACpBJ,EAAe9pB,KAAK8oB,gBAAgB1oB,IAAIuG,GAC9C,IAAKmjB,EACD,QAEc5oB,EAAW,CAACA,GAAYxC,MAAM6D,KAAKunB,EAAatoB,SACxDP,QAASopB,IACf,MAAMF,EAAmBL,EAAa1pB,IAAIiqB,IAAiB1B,EAAoByB,KAE/E,OAD2BD,EAAmBJ,GAE1C,OAEJ/pB,KAAKgpB,QAAQQ,oBAAoB7iB,EAAM0jB,EAAcjmB,GACrD,MAAMkmB,EAAmBH,EAAmBJ,EACxCO,IAAqB3B,EAAoByB,KACzCN,EAAatmB,OAAO6mB,GAGpBP,EAAa5pB,IAAImqB,EAAcC,KAGlCR,EAAaZ,MACdlpB,KAAK8oB,gBAAgBtlB,OAAOmD,EAEpC,CACA,uBAAA4jB,CAAwB5jB,EAAMmjB,GAC1BprB,MAAM6D,KAAKunB,EAAaH,WAAW1oB,QAAQ,EAAEupB,EAAUC,MAEnD,IAAK,IAAIC,EADU/B,EAAoBsB,QACHQ,EAAaC,IAAiB,EAAG,CACjE,KAAMD,EAAcC,GAChB,SAEJ,MAAMC,EAAaD,IAAiB/B,EAAoBsB,QACxDjqB,KAAKwpB,oBAAoB7iB,EAAM6jB,EAAU,CAAER,QAASW,IACpDF,GAAeC,CACnB,GAER,CACA,oBAAAb,GACInrB,MAAM6D,KAAKvC,KAAK8oB,gBAAgBa,WAAW1oB,QAAQ,EAAE0F,EAAMmjB,MACvD9pB,KAAKuqB,wBAAwB5jB,EAAMmjB,IAE3C,EC9HJ,MAAMc,EACF,WAAAnrB,GACIO,KAAK6qB,uBAAyB,IAAI9a,GACtC,CACA,gBAAAoZ,CAAiBN,EAAQliB,EAAMzF,EAAUkD,GACrC,IAAI0mB,EAAiB9qB,KAAK6qB,uBAAuBzqB,IAAIyoB,GAChDiC,IACDA,EAAiB,IAAIlC,EAAqBC,GAC1C7oB,KAAK6qB,uBAAuB3qB,IAAI2oB,EAAQiC,IAE5CA,EAAe3B,iBAAiBxiB,EAAMzF,EAAUkD,EACpD,CACA,mBAAAolB,CAAoBX,EAAQliB,EAAMzF,EAAUkD,GACxC,MAAM0mB,EAAiB9qB,KAAK6qB,uBAAuBzqB,IAAIyoB,GAClDiC,IAGLA,EAAetB,oBAAoB7iB,EAAMzF,EAAUkD,GAC/C0mB,EAAe7B,SACfjpB,KAAK6qB,uBAAuBrnB,OAAOqlB,GAE3C,CACA,KAAAa,GACIhrB,MAAM6D,KAAKvC,KAAK6qB,uBAAuBlB,WAAW1oB,QAAQ,EAAE4nB,EAAQkC,MAChEA,EAAqBrB,QACrB1pB,KAAK6qB,uBAAuBrnB,OAAOqlB,IAE3C,E,gDC5BW,SAASmC,EAAyBC,EAAqBxR,GAClE,MAAMyP,EAAO+B,EAAoBC,UACjC,IAAK,IAAI5iB,EAAQ,EAAGA,EAAQ4gB,EAAM5gB,IAAS,CACvC,MAAM6iB,EAAa,GACnBF,EAAoBG,aAAa9iB,EAAO6iB,GACxCA,EAAW,GAAKA,EAAW,GAAK1R,EAChC0R,EAAW,GAAKA,EAAW,GAAK1R,EAChC0R,EAAW,GAAKA,EAAW,GAAK1R,EAChCwR,EAAoBI,aAAa/iB,EAAO6iB,EAC5C,CACJ,C,0BCVe,SAASG,EAAUC,GAC9B,IAEIC,EAFA1tB,EAAMytB,EAAgB,GACtB7d,EAAM6d,EAAgB,GAE1B,MAAME,EAAYF,EAAgB3qB,OAClC,IAAK,IAAI0H,EAAQ,EAAGA,EAAQmjB,EAAWnjB,IACnCkjB,EAAcD,EAAgBjjB,GAC9BxK,EAAMb,KAAKa,IAAIA,EAAK0tB,GACpB9d,EAAMzQ,KAAKyQ,IAAIA,EAAK8d,GAExB,MAAO,CACH1tB,MACA4P,MAER,CCdA,MAAMge,EAAkBtsB,OAAO,iBACzBusB,EAAiB,CAAC,EAClBC,EAAc,WACdC,EAAoB,IACX,SAASC,EAAapqB,EAASkC,EAAW8J,GACrD,OAEJ,SAA0BhM,EAASqqB,EAAQre,GACvC,IAAIse,EAAetqB,EAAQqqB,GACrBC,aAAwBttB,QAC1BstB,EAAe,CAAC,GAChBpsB,OAAOG,eAAe2B,EAASqqB,EAAQ,CAAE9rB,MAAO+rB,KAEpD,IAAK,IAAIC,GAAQ,EAAMziB,EAAI,EAAGyiB,GAASziB,EAAIwiB,EAAaprB,SAAU4I,EAAG,CACjE,IAAI0iB,EAAsB,EAAlBF,EAAaxiB,GACjB0iB,EAAIxe,GACJue,GAAQ,EACRC,GAAQ,IAGRA,EAAI,EACA1iB,EAAI,IAAMwiB,EAAaprB,QACvBorB,EAAavjB,KAAK,IAG1BujB,EAAaxiB,GAAK0iB,CACtB,CACA,OAAOF,CACX,CAvBWG,CAA6B,OAAZzqB,GAAuC,iBAAZA,EAAuBA,EAAUiqB,EAAgBD,GAAiC,iBAARhe,GAAoBA,EAAM,EAAIA,EAAMke,KAAiB,GAAGQ,KAA0B,iBAAdxoB,EAAyBA,EAAYioB,EAC1O,C,eCLA,MAAMtD,EAAQ,CAAC,EAaf,EAZyB,CACrBjlB,IAAK,CAACa,EAASikB,KACX,MAAMiE,GAAW,EAAAtE,EAAA,GAAa5jB,GAC9BokB,EAAM8D,GAAYjE,GAEtBhoB,IAAK,CAACuG,EAAMxC,KACR,GAAa,2BAATwC,EAAmC,CACnC,MAAM0lB,GAAW,EAAAtE,EAAA,GAAa5jB,GAC9B,OAAOokB,EAAM8D,EACjB,I,eCXO,SAASC,EAAWC,EAAIC,EAAIC,EAAY,MACnD,OAAQxvB,KAAKud,IAAI+R,EAAG,GAAKC,EAAG,IAAMC,GAC9BxvB,KAAKud,IAAI+R,EAAG,GAAKC,EAAG,IAAMC,GAC1BxvB,KAAKud,IAAI+R,EAAG,GAAKC,EAAG,IAAMC,CAClC,C,gDCJe,SAASC,EAAsBpkB,EAAOZ,GACjD,QAAIY,EAAM,GAAK,GACXA,EAAM,IAAMZ,EAAW,IACvBY,EAAM,GAAK,GACXA,EAAM,IAAMZ,EAAW,IACvBY,EAAM,GAAK,GACXA,EAAM,IAAMZ,EAAW,GAI/B,C,eCgBA,QAzBA,SAAiDilB,EAAgBC,GAC7D,IAAI3G,EAEAA,EADA2G,EACmB,EAAC,EAAAC,EAAA,IAAmBD,KAGpB,EAAAC,EAAA,MAEvB,MAAMC,EAAuB,GAe7B,OAdA7G,EAAiBhlB,QAASmX,IACtB,MAAM2U,EAAeJ,EAAerL,YAC9BjJ,EAAYD,EAAgBgO,qBAClC,IAAK,MAAMC,KAAMhO,EAAW,CACxB,MAAM2U,EAAW3G,EAAG/E,YACpB,GAAI0L,EAASpsB,SAAWmsB,EAAansB,OACjC,SAEgBmsB,EAAaE,MAAM,EAAGzL,SAAUwL,EAAS5Q,KAAM8Q,GAAY1L,IAAQ0L,EAAQ1L,OAE3FsL,EAAqBrkB,KAAK4d,EAElC,IAEGyG,CACX,E,iHCzBA,MAGA,EAH8BtxB,GACnBA,EAAM2xB,SAASC,QAAU5xB,EAAM2xB,SAASnL,kBAAkBI,MCKtD,SAASiL,EAAkB5xB,EAAQ6xB,EAAenvB,OAAWH,EAAW4uB,EAAoB,cAAeW,EAAkB,CACxIC,YAAa,CAAEC,UAAW,CAAC,EAAG,MAE9B,KAAKhyB,GAAYA,aAAkBiyB,mBAC/B,MAAM,IAAItvB,MAAM,8BAEpB,MAAMuvB,GAAYL,EAAcnpB,QAC1B3I,GAASmyB,GAAYL,EACrBzI,EAAS8I,GAAYL,EAErBM,EAAa,qBADIpyB,EAAM2I,SAAW0gB,EAAO5M,WAEzC4V,EAAUC,SAASC,cAAc,OACjCC,EAAmBC,OAAOD,kBAAoB,EAC/CT,EAAgBC,cACjBD,EAAgBC,YAAc,CAAEC,UAAW,CAAC,EAAG,KAEnD,MAAMS,EAAgBzyB,EAAOmB,MACvBuxB,EAAiB1yB,EAAOoB,OAC9BgxB,EAAQO,MAAMxxB,MAAQ,GAAGsxB,EAAgBF,EAAmB,SAC5DH,EAAQO,MAAMvxB,OAAS,GAAGsxB,EAAiBH,EAAmB,SAC9DH,EAAQO,MAAMC,WAAa,SAC3BR,EAAQO,MAAME,SAAW,WACzBR,SAASS,KAAKC,YAAYX,GAC1B,MAAMY,EAAWb,EAAWxrB,MAAM,KAAKgqB,KAAK,KAC5CyB,EAAQa,aAAa,yBAA0BD,GAC/C,MAAME,GAAkB,EAAAC,EAAA,IAAkBf,GACpCzV,GAAkB,EAAAyU,EAAA,IAAmBD,IACvC,IAAIiC,EAAA,EAAqBjC,GAC7B,IAAI1wB,EAAWkc,EAAgB0W,YAAYlB,GAC3C,IAAK1xB,EAAU,CACX,MAAM6yB,EAAgB,CAClBnB,aACAjnB,KAAMgnB,EAAW,EAAAqB,aAAaC,aAAe,EAAAD,aAAaE,MAC1DrB,UACAsB,eAAgB,IACT5B,EACH6B,gBAAgB,IAGxBhX,EAAgBiX,cAAcN,GAC9B7yB,EAAWkc,EAAgB0W,YAAYlB,EAC3C,CACA,OAAO,IAAI/oB,QAASC,IAChB,IAAIwqB,GAAkB,GAClB,cAAEC,GAAkBhC,EACxB,MAAMiC,EAAmBC,IACrB,GAAIH,EACA,OAEJ,GAAIC,EAAe,CACf,MAAMG,EAAaH,EAInB,OAHAA,EAAgB,KAChBrzB,EAASyzB,iBAAiBD,QAC1BxzB,EAASD,QAEb,CACgBR,EAAOm0B,WAAW,MAC1BC,UAAUlB,EAAiB,EAAG,EAAGA,EAAgB/xB,MAAO+xB,EAAgB9xB,OAAQ,EAAG,EAAGpB,EAAOmB,MAAOnB,EAAOoB,QACnH,MAAM+K,EAAS1L,EAAS4zB,cAAc,CAAC,EAAG,IACpCC,EAAW7zB,EAAS4zB,cAAc,CACpCnB,EAAgB/xB,MAAQoxB,EACxB,IAEEgC,EAAa9zB,EAAS4zB,cAAc,CACtC,EACAnB,EAAgB9xB,OAASmxB,IAEvBiC,EAAc,SAAS,CAAC,EAAG,EAAG,GAAI/zB,EAAS4zB,cAAc,CAAC,EAAI9B,EAAkB,IAAKpmB,GACrFsoB,EAAa,SAAS,CAAC,EAAG,EAAG,GAAIh0B,EAAS4zB,cAAc,CAAC,EAAG,EAAI9B,IAAoBpmB,GAE1F0nB,GAAkB,EAClBzB,EAAQrE,oBAAoB,EAAA2G,OAAOC,eAAgBZ,GACnDa,WAAW,KACPjY,EAAgBkY,eAAe1C,GACdE,SAASyC,iBAAiB,4BAA4B9B,OAC9DxtB,QAAS4sB,IACdA,EAAQ2C,YAEb,GACH1rB,EAAQ,CACJ8C,SACAooB,aACAD,WACAU,YAdgB,EAehBR,cACAC,gBAGRrC,EAAQ1E,iBAAiB,EAAAgH,OAAOC,eAAgBZ,GAC5C7B,EACAzxB,EAASw0B,WAAW,CAAC7L,IAAS,GAAO,GAGrC3oB,EAASy0B,kBAAkBrD,GAE/BpxB,EAAS00B,cACQ,OAAbzyB,GAAsB,EAAqB3C,IAC3CU,EAAS20B,cAAc,CACnBvS,SAAU,CACNC,MAAO/iB,EAAM8N,cACbkV,MAAOhjB,EAAM+N,iBAIzBrN,EAASD,UAEjB,C,mCC7Ge,SAAS60B,EAAkBr1B,EAAQ6xB,EAAenvB,EAAU4yB,EAAoBC,GAE3F,GADe1D,EACJrV,SACP,MAAM,IAAI7Z,MAAM,wCAEpB,MAAM5C,EAAQ8xB,EAERhyB,EAAiB,CACnBG,SACAS,UAHa,EAAA+0B,EAAA,GAAmBx1B,EAAQD,EAAO2C,GAI/C3C,QACA01B,eAAgB,CAAC,GAErB51B,EAAemB,WAAY,EAAA00B,EAAA,GAAmB71B,GAE9C,OAAO,IAAIuJ,QAAQ,CAACC,EAASoJ,MACzB,EAAAkjB,EAAA,GAAc91B,EAFE,MAGhBwJ,EAAQ,OAEhB,C,eCfe,SAASusB,EAAkBjtB,GACtC,MAAM,OAAE3I,EAAM,QAAE0I,EAAO,cAAEorB,EAAa,YAAEvpB,EAAc,EAAAsrB,YAAYC,UAAS,SAAExrB,GAAW,EAAE,kBAAE6mB,EAAoB,cAAa,gBAAE4E,GAAkB,EAAK,UAAEC,GAAY,EAAK,YAAEC,GAAc,EAAOnE,gBAAiBoE,GAAyBvtB,EACpO6T,EAAWsX,GAAetX,SAC1B0V,EAAW1V,IAAa9T,EACxBopB,EAAkBgC,GAAiBoC,EACnC,IAAKA,EAAqBpC,iBAC1BoC,EACAC,EAAWJ,EAAkBV,EAAoBzD,EACvD,OAAO,IAAIxoB,QAAQ,CAACC,EAASoJ,KACzB,SAAS2jB,EAAgBvE,EAAenpB,GACpC,MAAM,SAAEhG,GAAa2zB,EAAS1xB,IAAI,sBAAuB+D,IAAY,CAAC,EAChE3I,GAASmyB,GAAYL,EACrBzI,EAAS8I,GAAYL,EACvB9xB,IACAA,EAAM+C,YAAc/C,EAAM+C,aAAe/C,EAAM2xB,UAAUC,QAEzDqE,IACAh2B,EAAOoB,OAAS,IAChBpB,EAAOmB,MAAQ,KAEf80B,GAAel2B,IACfC,EAAOmB,MAAQpB,GAAUC,EAAOoB,OAASrB,EAAMoB,MAASpB,EAAMqB,QAElEpB,EAAO2yB,MAAMxxB,MAAWnB,EAAOmB,MAAQoxB,iBAAlB,KACrBvyB,EAAO2yB,MAAMvxB,OAAYpB,EAAOoB,OAASmxB,iBAAnB,KAClBnJ,GAAU2M,GACVtjB,EAAO,IAAI9P,MAAM,0CAErBwzB,EAASn2B,EAAQ6xB,EAAenvB,EAAUyuB,EAAmBW,GAAiBxoB,KAAKD,EACvF,CACA,SAAS4J,EAAc/I,EAAOxB,GAC1BwK,QAAQhJ,MAAMA,EAAOxB,GACrB+J,EAAOvI,EACX,CAQA,MAAMvB,EAAU,CACZ2tB,UAAWP,EACXxrB,eAEJ,GAAIiS,EAAU,CACV,MAAM4M,EAASmN,EAAA,GAAMxM,UAAUvN,GAC1B4M,GACD3W,EAAO,IAAI9P,MAAM,aAAa6Z,yBAGlC4Z,EAAgBhN,EADGA,EAAOlL,SAAS,GAEvC,MAEIsY,EAAA,EAAqBC,WApBzB,SAAqB/tB,EAASguB,EAAc/tB,GACxC,OAAO,IAAA6B,mBAAkB9B,EAASC,GAASW,KAAMvJ,IAC7Cq2B,EAAgB9wB,KAAKf,KAAMxE,EAAO2I,IAClCwB,IACA+I,EAAc3N,KAAKf,KAAM2F,EAAOxB,IAExC,EAcgD4K,KAAK,KAAM5K,EAAS,KAAMC,GAAU4B,EAAa,CAAE7B,WAAW4B,IAGtH,C,eChEO,SAASqsB,EAAQze,GACpB,OAAIjV,MAAMC,QAAQgV,GACPA,EAEJ,CAACA,EACZ,CCHA,MAAMwc,GACY,iCADZA,GAEY,iCAEX,MAAMkC,GACT,WAAA5yB,CAAY6yB,EAAQ,QAASpJ,EAAO,IAChClpB,KAAKsuB,UAAY,EACjBtuB,KAAKuyB,cAAgB,EACrBvyB,KAAKwyB,cAAgB,EACrBxyB,KAAKyyB,KAAO,IAAI/zB,MAChBsB,KAAK0yB,oBAAqB,EAC1B1yB,KAAKsyB,MAAQA,EACbtyB,KAAK2yB,MAAQzJ,CACjB,CACA,QAAIA,GACA,OAAOlpB,KAAK2yB,KAChB,CACA,QAAIzJ,CAAKhd,GACLlM,KAAKyyB,KAAO,IAAI/zB,MAAMwN,GACtBlM,KAAK2yB,MAAQzmB,EACblM,KAAKsuB,UAAY,EACjBtuB,KAAKuyB,cAAgB,EACrBvyB,KAAKwyB,cAAgB,CACzB,CACA,WAAII,GACA,OAAO5yB,KAAKwyB,cAAgB,CAChC,CACA,WAAIK,GACA,OAAO7yB,KAAKuyB,cAAgB,CAChC,CACA,IAAAO,CAAKC,EAAQ,GACT,KAAOA,EAAQ,GAAK/yB,KAAKwyB,cAAgB,GAAG,CACxC,MAAM7e,EAAO3T,KAAKyyB,KAAKzyB,KAAKsuB,UAC5B,IAAK,MAAM0E,KAAWZ,EAAQze,GAAMtH,UAChC2mB,EAAQC,aAAY,GACpBjzB,KAAKkzB,qBAAqB,CAAEvf,KAAMqf,EAASG,QAAQ,IAEvDJ,IACA/yB,KAAKuyB,gBACLvyB,KAAKwyB,gBACLxyB,KAAKsuB,UAAYtuB,KAAKsuB,SAAW,EAAItuB,KAAKkpB,MAAQlpB,KAAKkpB,IAC3D,CACJ,CACA,MAAAkK,CAAOC,GACH,SAAIrzB,KAAKwyB,cAAgB,GAAKa,EAAUrzB,KAAKyyB,KAAKzyB,KAAKsuB,cACnDtuB,KAAK8yB,QACE,EAGf,CACA,oBAAAI,EAAqB,KAAEvf,EAAI,OAAEwf,IACrBxf,EAAKxK,IACLmqB,EAAA,EAAYC,cAAc,IAAIC,YAAYL,EAAShD,GAAsBA,GAAqB,CAC1FsD,OAAQ,CACJN,SACAhqB,GAAIwK,EAAKxK,GACTuqB,cAAe/f,EAAK+f,eAAiB,aACrCC,KAAMhgB,KAItB,CACA,IAAAigB,CAAKb,EAAQ,GACT,KAAOA,EAAQ,GAAK/yB,KAAKuyB,cAAgB,GAAG,CACxC,MAAMsB,GAAe7zB,KAAKsuB,SAAW,GAAKtuB,KAAKkpB,KACzCvV,EAAO3T,KAAKyyB,KAAKoB,GACvB,IAAK,MAAMb,KAAWZ,EAAQze,GAAMtH,UAChC2mB,EAAQC,aAAY,GACpBjzB,KAAKkzB,qBAAqB,CAAEvf,KAAMqf,EAASG,QAAQ,IAEvDJ,IACA/yB,KAAKsuB,SAAWuF,EAChB7zB,KAAKwyB,gBACLxyB,KAAKuyB,eACT,CACJ,CACA,mBAAAuB,GACI9zB,KAAKuyB,cAAgB,EACjBvyB,KAAKwyB,cAAgBxyB,KAAK2yB,OAC1B3yB,KAAKwyB,gBAETxyB,KAAKsuB,UAAYtuB,KAAKsuB,SAAW,GAAKtuB,KAAK2yB,MAC3C3yB,KAAKyyB,KAAKzyB,KAAKsuB,UAAY,EAC/B,CACA,mBAAAyF,GACI/zB,KAAK0yB,oBAAqB,EAC1B1yB,KAAK8zB,qBACT,CACA,uBAAAE,GACIh0B,KAAKyyB,KAAKzyB,KAAKsuB,eAAYtwB,EAC3BgC,KAAKsuB,UAAYtuB,KAAKsuB,SAAW,GAAKtuB,KAAK2yB,MAC3C3yB,KAAKwyB,eACT,CACA,iBAAAyB,GACIj0B,KAAK0yB,oBAAqB,EAC1B,MAAMwB,EAAWl0B,KAAKyyB,KAAKzyB,KAAKsuB,UACR5vB,MAAMC,QAAQu1B,IAAiC,IAApBA,EAAStzB,QAExDZ,KAAKg0B,yBAEb,CACA,WAAAG,CAAYR,GACR,MAAMS,EAAWp0B,KAAKyyB,KAAKzyB,KAAKsuB,UAChC,GAAI5vB,MAAMC,QAAQy1B,GAEd,OADAA,EAAS3rB,KAAKkrB,GACPA,EAEX,MAAM,IAAIv1B,MAAM,kDACpB,CACA,IAAAqK,CAAKkL,GACD,IAAKA,EACD,OAEJ,MAAMggB,EAAOhgB,EAAKsf,YACZtf,EACAA,EAAK0gB,eACX,OAAKV,EAGD3zB,KAAK0yB,mBACE1yB,KAAKm0B,YAAYR,IAE5B3zB,KAAKuyB,cAAgB,EACjBvyB,KAAKwyB,cAAgBxyB,KAAK2yB,OAC1B3yB,KAAKwyB,gBAETxyB,KAAKsuB,UAAYtuB,KAAKsuB,SAAW,GAAKtuB,KAAK2yB,MAC3C3yB,KAAKyyB,KAAKzyB,KAAKsuB,UAAYqF,EACpBA,QAZP,CAaJ,EAEJ,MAAMW,GAAqB,IAAIjC,GC7G/B,SAtBA,SAA4BluB,EAASowB,GACjC,MAAM/tB,GAAmB,IAAApG,KAAI,mBAAoB+D,GACjD,IAAKqC,EACD,MAAM,IAAIpI,MAAM,0CAA0C+F,KAE9D,MAAM,cAAEwE,EAAa,WAAED,EAAYb,qBAAsBD,GAAYpB,EACrE,IAAI,mBAAE7I,EAAkB,gBAAED,GAAoB8I,EAC9C7I,IAAuB,EACvBD,IAAoB,EACpB,MAAM82B,EAAY,cAClB,iBAAiBA,EAAW5sB,EAAQe,GAAgBhL,EAAqB,GACzE,iBAAiB62B,EAAWA,EAAW9rB,GAAahL,EAAkB,GACtE,MAAM+2B,EAAM,cAQZ,OAPA,SAASA,EAAKF,EAAaC,GAGP,CAFA,SAASC,EAAK/rB,GAGhBhL,EAFK,SAAS+2B,EAAK9rB,GAGhBhL,EAGzB,ECrBe,SAAS+2B,GAAmBvwB,EAASwwB,GAChD,MAAMnuB,GAAmB,IAAApG,KAAI,mBAAoB+D,GACjD,IAAKqC,EACD,MAAM,IAAIpI,MAAM,0CAA0C+F,KAE9D,MAAM,cAAEwE,EAAa,WAAED,EAAYb,qBAAsBD,GAAYpB,EACrE,IAAI,mBAAE7I,EAAkB,gBAAED,GAAoB8I,EAC9C7I,IAAuB,EACvBD,IAAoB,EACpB,MAAMk3B,EAAqB,cAG3B,OAFA,iBAAiBA,EAAoBhtB,EAAQc,EAAYhL,GAAmBi3B,EAAY,GAAK,KAC7F,iBAAiBC,EAAoBA,EAAoBjsB,EAAehL,GAAsBg3B,EAAY,GAAK,KACxGj2B,MAAM6D,KAAKqyB,EACtB,C,2ECde,SAASC,GAAyBxI,GAC7C,MAAMpG,GAAmB,EAAA4G,EAAA,MACnBxU,EAAY,GASlB,OARA4N,EAAiBhlB,QAASmX,IACcA,EAAgB0c,eACxB7zB,QAAS/E,IAC7BA,EAAS64B,YAAY1I,IACrBhU,EAAU5P,KAAKvM,OAIpBmc,CACX,C,gBCVe,SAAS2c,GAAkCnoB,EAAO3Q,GAC7D,MAAM+4B,EAGH,SAAkDpoB,EAAO3Q,GAC5D,MAAMyd,EAAWzd,EAASg5B,cACpBC,EAAsBj5B,EAASk5B,yBACrC,GAAwB,IAApBzb,EAAS/Y,OACT,OAAO,KAEX,MAAMqZ,EAAe9V,IACjB,MAAMkxB,EA4Cd,SAA0BlxB,GACtB,MAAMmxB,EAAmBxD,EAAS1xB,IAAI,mBAAoB+D,GAC1D,KAAKmxB,GACCA,EAAiB5sB,sBAAsBhK,OACE,IAAvC42B,EAAiB5sB,WAAW9H,QAC9B00B,EAAiB3sB,yBAAyBjK,OACE,IAA1C42B,EAAiB3sB,cAAc/H,QACjC00B,EAAiBztB,gCAAgCnJ,OACE,IAAjD42B,EAAiBztB,qBAAqBjH,QAC1C,OAAO,KAEX,MAAM,WAAE8H,EAAU,cAAEC,EAAa,qBAAEd,GAA0BytB,EACvDC,EAAS,SAAS,iBAAkB7sB,GACpC8sB,EAAS,SAAS,iBAAkB7sB,GACpC8sB,EAAc,WAAW,cAAeF,EAAQC,GACtD,MAAO,CAAE9sB,aAAYC,gBAAed,uBAAsB4tB,cAC9D,CA5D8BC,CAAiBvxB,GACvC,IAAKkxB,EACD,OAAO,KAEX,MAAMM,EAAQ7iB,GAAO8iB,cAAcP,EAAcI,YAAaJ,EAAcxtB,sBAE5E,OADiBiL,GAAO+iB,qBAAqBF,EAAO9oB,IAGlDipB,EAAe,CACjBpb,SAAUT,EAAYN,EAASwb,KAAyBhgB,IACxD7M,MAAO6sB,GAELY,EAAiBpc,EAASjZ,MAAMy0B,EAAsB,GAC5D,IAAK,IAAI3rB,EAAI,EAAGA,EAAIusB,EAAen1B,OAAQ4I,IAAK,CAC5C,MACMkR,EAAWT,EADN8b,EAAevsB,IAE1B,GAAiB,OAAbkR,EAAJ,CAGA,KAAIA,GAAYob,EAAapb,UAKzB,MAJAob,EAAapb,SAAWA,EACxBob,EAAaxtB,MAAQkB,EAAI2rB,EAAsB,CAHnD,CAQJ,CACA,MAAMa,EAAgBrc,EAASjZ,MAAM,EAAGy0B,GACxC,IAAK,IAAI3rB,EAAIwsB,EAAcp1B,OAAS,EAAG4I,GAAK,EAAGA,IAAK,CAChD,MACMkR,EAAWT,EADN+b,EAAcxsB,IAEzB,GAAiB,OAAbkR,GAAqBA,IAAaob,EAAapb,SAAnD,CAGA,KAAIA,EAAWob,EAAapb,UAKxB,MAJAob,EAAapb,SAAWA,EACxBob,EAAaxtB,MAAQkB,CAHzB,CAQJ,CACA,OAAOssB,EAAapb,WAAavF,IAAW,KAAO2gB,CACvD,CArD4BG,CAAyCppB,EAAO3Q,GACxE,OAAO+4B,EAAkBA,EAAgB3sB,MAAQ,IACrD,C,gBCJA,SAAS4tB,GAA8Bh6B,GACnC,MAAQU,MAAOu5B,EAAat5B,OAAQu5B,GAAiBl6B,EAAS0N,aACxD,mBAAEysB,EAAkB,mBAAEC,GAAuBp6B,EAASq6B,mBACtDC,GAAiB,EAAAC,GAAA,GAAqBv6B,EAAU,CAAC,EAAG,IACpDw6B,GAAc,EAAAD,GAAA,GAAqBv6B,EAAU,CAACi6B,EAAc,EAAG,IAC/DQ,GAAc,EAAAF,GAAA,GAAqBv6B,EAAU,CAAC,EAAGk6B,EAAe,IAChEQ,EAAY,SAAS,cAAeF,EAAaF,GACjDK,EAAY,SAAS,cAAeF,EAAaH,GACjDM,EAAc,WAAW,cAAeF,EAAWC,GACzD,eAAeD,EAAWA,GAC1B,eAAeC,EAAWA,GAC1B,eAAeC,EAAaA,GAC5B,MAAMC,EAAe95B,KAAKyQ,IAAIzQ,KAAKud,IAAIoc,EAAU,IAAK35B,KAAKud,IAAIoc,EAAU,IAAK35B,KAAKud,IAAIoc,EAAU,KAC3FI,EAAe/5B,KAAKyQ,IAAIzQ,KAAKud,IAAIqc,EAAU,IAAK55B,KAAKud,IAAIqc,EAAU,IAAK55B,KAAKud,IAAIqc,EAAU,KACjG,IAAK,YAAgB,EAAGE,KAAkB,YAAgB,EAAGC,GACzD,MAAM,IAAI54B,MAAM,0DAEpB,MAAM,aAAE4G,GAAiB9I,EAAS+6B,eAC5BC,EAAgBh7B,EAASq6B,mBACzBpxB,EAAaH,EAAamyB,aAAaD,GAC7C,MAAO,CACHt6B,MAAOs6B,EAAct6B,MACrBC,OAAQq6B,EAAcr6B,OACtBsI,aACAkxB,qBACAC,qBAER,CC3BA,MAAM,GAAQ,CAAC,EACTc,GAAsC,CACxC9zB,IAAK,CAACmlB,EAAOL,KACT,MAAOiP,EAAaC,GAAe7O,EAC7B8O,EAAU,GAAGF,KAAeC,IAC7B,GAAMC,KACP,GAAMA,GAAW,CAAC,GAEtB,GAAMA,GAAWnP,GAErBhoB,IAAK,CAACuG,EAAM0wB,EAAaC,KACrB,GAAa,8BAAT3wB,EACA,OAEJ,MAAM4wB,EAAU,GAAGF,KAAeC,IAClC,GAAI,GAAMC,GACN,OAAO,GAAMA,GAEjB,MAAMC,EAAiB,GAAGF,KAAeD,IACzC,OAAI,GAAMG,GACC,YAAY,cAAe,GAAMA,SAD5C,KAKR,IAAA9O,aAAY0O,GAAoCh3B,IAAI2O,KAAKqoB,KACzD,YCFA,SArBA,SAA+CK,EAAWC,GACtD,MAAMC,EAAWF,EAAUG,gBACrBC,EAAWH,EAAUE,gBACrBE,GAAoB,IAAA13B,KAAI,mBAAoBu3B,EAASjY,YACrDqY,GAAoB,IAAA33B,KAAI,mBAAoBy3B,EAASnY,YAC3D,IAAKoY,IAAsBC,EAEvB,YADAppB,QAAQgR,IAAI,6DAGhB,MAAQ5X,wBAAyBiwB,GAASD,EAE1C,IADyBD,EAAkB/vB,wBAAwBklB,MAAM,CAACjf,EAAGxE,IAAMvM,KAAKud,IAAIxM,EAAIgqB,EAAKxuB,IAXnF,KAcd,YADAmF,QAAQgR,IAAI,qGAAsGmY,GAAmB/vB,wBAAyBgwB,GAAmBhwB,yBAGrL,MAAMkwB,EAAwBH,EAAkBjwB,qBAC1CqwB,EAAwBH,EAAkBlwB,qBAC1C9J,EAAc,cAAc,cAAek6B,EAAuBC,GAClEC,EAAM,qBAAqB,cAAep6B,GAChD,GAAoCuF,IAAI,CAACm0B,EAAUtuB,GAAIuuB,EAAUvuB,IAAKgvB,EAC1E,ECxBe,SAASC,GAA+Bl8B,GACnD,MAAM,UAAEmnB,EAAS,WAAE3b,GAAexL,EAAS+6B,gBAAkB,CAAC,EAC9D,IAAK5T,IAAc3b,EACf,MAAO,GAEX,MAAM,OAAEjM,GAAWS,EACbm8B,EAAQpK,OAAOD,iBAEfsK,EAAiB,CAAC78B,EAAOmB,MAAQy7B,EAAO,GACxCE,EAAoB,CACtB98B,EAAOmB,MAAQy7B,EACf58B,EAAOoB,OAASw7B,GAEdG,EAAmB,CAAC,EAAG/8B,EAAOoB,OAASw7B,GACvCI,EAAev8B,EAAS4zB,cAPR,CAAC,EAAG,IAQpB4I,EAAgBx8B,EAAS4zB,cAAcwI,GACvCK,EAAmBz8B,EAAS4zB,cAAcyI,GAC1CK,EAAkB18B,EAAS4zB,cAAc0I,GACzCK,EAAexV,EAAUyV,aAAaL,GACtCM,EAAgB1V,EAAUyV,aAAaJ,GACvCM,EAAmB3V,EAAUyV,aAAaH,GAC1CM,EAAkB5V,EAAUyV,aAAaF,GAC/C,OAaJ,UAAuC,WAAElxB,EAAU,UAAE2b,EAAS,aAAEwV,EAAY,cAAEE,EAAa,iBAAEC,EAAgB,gBAAEC,EAAe,aAAER,EAAY,cAAEC,EAAa,iBAAEC,EAAgB,gBAAEC,IAC3K,MAAMM,EAAoBC,GAAYN,EAAcnxB,GAC9C+wB,EACApV,EAAUO,aAAa,CAAC,EAAG,EAAG,IAC9BwV,EAAqBD,GAAYJ,EAAerxB,GAChDgxB,EACArV,EAAUO,aAAa,CAAClc,EAAW,GAAK,EAAG,EAAG,IAC9C2xB,EAAwBF,GAAYH,EAAkBtxB,GACtDixB,EACAtV,EAAUO,aAAa,CACrBlc,EAAW,GAAK,EAChBA,EAAW,GAAK,EAChB,IAEF4xB,EAAuBH,GAAYF,EAAiBvxB,GACpDkxB,EACAvV,EAAUO,aAAa,CAAC,EAAGlc,EAAW,GAAK,EAAG,IACpD,MAAO,CACHwxB,EACAE,EACAE,EACAD,EAER,CApCWE,CAA8B,CACjC7xB,aACA2b,YACAwV,eACAE,gBACAC,mBACAC,kBACAR,eACAC,gBACAC,mBACAC,mBAER,CAyBA,SAASO,GAAYK,EAAY9xB,GAC7B,OAAQ8xB,EAAW,GAAK,GACpBA,EAAW,GAAK9xB,EAAW,GAAK,GAChC8xB,EAAW,GAAK,GAChBA,EAAW,GAAK9xB,EAAW,GAAK,GAChC8xB,EAAW,GAAK,GAChBA,EAAW,GAAK9xB,EAAW,GAAK,CACxC,C,wFCrDA,SAXA,SAAwBmmB,GACpB,MAAMvyB,GAAiB,EAAAm+B,GAAA,IAAkB5L,GACzC,IAAKvyB,EACD,OAEJ,MAAM,SAAEY,GAAaZ,EACrB,KAAMY,aAAoBw9B,GAAA,GACtB,MAAM,IAAIt7B,MAAM,qFAAqFlC,EAASyK,QAElH,OAAOzK,EAASy9B,qBACpB,E,mDCVA,SAASC,GAAcjgB,GACnB,GAAIA,EAAS/Y,QAAU,EACnB,OAAO,EAEX,MAAMi5B,EAAWlgB,EAAS,IACpB,SAAExb,EAAQ,kBAAE27B,GAAsBhI,EAAS1xB,IAAI,sBAAuBy5B,IACtE,wBAAE9xB,EAAuB,aAAEa,EAAY,oBAAEZ,EAAmB,QAAEhJ,EAAO,KAAEC,EAAI,mBAAE86B,GAAwBjI,EAAS1xB,IAAI,mBAAoBy5B,GAC5I,GAAIE,EACA,OAAO,EAEX,MAAMC,EAAe,CACjB77B,WACA4J,0BACAa,eACAZ,sBACAhJ,UACAC,OACA66B,qBAEJ,IAAIG,GAAc,EAClB,IAAK,IAAIzwB,EAAI,EAAGA,EAAImQ,EAAS/Y,OAAQ4I,IAAK,CACtC,MAAMrF,EAAUwV,EAASnQ,IACnB,SAAErL,EAAQ,kBAAE27B,GAAsBhI,EAAS1xB,IAAI,sBAAuB+D,IACtE,wBAAE4D,EAAuB,aAAEa,EAAY,QAAE5J,EAAO,KAAEC,GAAS6yB,EAAS1xB,IAAI,mBAAoB+D,GAClG,GAAI21B,IAAsBE,EAAaF,kBAAmB,CACtDG,GAAc,EACd,KACJ,CACA,GAAI97B,IAAa67B,EAAa77B,SAAU,CACpC87B,GAAc,EACd,KACJ,CACA,GAAIj7B,IAAYg7B,EAAah7B,QAAS,CAClCi7B,GAAc,EACd,KACJ,CACA,GAAIh7B,IAAS+6B,EAAa/6B,KAAM,CAC5Bg7B,GAAc,EACd,KACJ,CACA,KAAK,EAAAC,GAAA,IAAQnyB,EAAyBiyB,EAAajyB,yBAA0B,CACzEkyB,GAAc,EACd,KACJ,CACA,KAAK,EAAAC,GAAA,IAAQtxB,EAAcoxB,EAAapxB,cAAe,CACnDqxB,GAAc,EACd,KACJ,CACJ,CACA,OAAOA,CACX,C,oDCpDO,MAAME,GAAY,IAAIC,IAAI,CAC7B,0BACA,4BACA,0BACA,4BACA,0BACA,4BACA,0BACA,4BACA,0BACA,4BACA,0BACA,4BACA,0BACA,4BACA,0BACA,4BAEW,SAASC,GAAsBC,GAC1C,IAAKA,EACD,OAAO,EAGX,OADa57B,MAAMC,QAAQ27B,GAAaA,EAAY,CAACA,IACzCle,KAAMoF,GAAQ2Y,GAAU92B,IAAIme,GAC5C,C,mDCpBA+Y,eAAeC,IAA6B,SAAEt+B,EAAQ,QAAEkI,EAAU,CAAC,IAC/D,MAAMgU,EAAkBlc,EAAS2wB,qBACjC,IAAI5U,EAAW7T,EAAQ6T,UAAY,IAAG,EAAAwiB,EAAA,OACtC,GAAmC,IAA/BxiB,EAAS7V,MAAM,KAAKxB,OAAc,CAElCqX,EAAW,IADI,KAAAyiB,mCACSziB,GAC5B,CACA,MAAM,GAAE9O,EAAE,QAAE0kB,GAAY3xB,EAClB0xB,EAAaxpB,EAAQwpB,YAAczkB,EACnCwQ,EAAWzd,EAASg5B,cACpByF,EAAuBz+B,EAAS0+B,sBAChCC,EAAoB3+B,EAAS4+B,mBACnC1iB,EAAgBiX,cAAc,CAC1BzB,aACAjnB,KAAM,EAAAqoB,aAAaC,aACnBpB,UACAsB,eAAgB,CACZ4L,WAAY32B,EAAQ22B,WACpBC,YAAa52B,EAAQ42B,sBAGP,KAAAC,sBAAqBhjB,EAAU,CACjD0B,cAEGuhB,OACP,MAAMC,EAAiB/iB,EAAgB0W,YAAYlB,SAC7C,SAAuBxV,EAAiB,CAC1C,CACIH,aAEL,CAAC2V,IACJ,MAAMwN,EAAiC,KACnCD,EAAel/B,SACf4xB,EAAQrE,oBAAoB,EAAA2G,OAAOkL,2BAA4BD,IASnE,OANIvN,EAAQ1E,iBAAiB,EAAAgH,OAAOkL,2BAA4BD,GAGhED,EAAeG,oBAAoBX,GACnCQ,EAAexL,iBAAiBkL,GAChCM,EAAel/B,SACRk/B,CACX,C,gBC5CAZ,eAAegB,IAA6B,SAAEr/B,EAAQ,QAAEkI,IACpD,MAAM+2B,EAAiBj/B,GACjB,GAAEiN,EAAE,QAAE0kB,GAAYsN,EAClB/iB,EAAkBlc,EAAS2wB,sBAC3B,WAAEkO,GAAe32B,EACjBwpB,EAAaxpB,EAAQwpB,YAAczkB,EACnC0b,EAASmN,EAAA,GAAMxM,UAAU2V,EAAe/T,eAC9C,KAAMvC,aAAkB2W,GAAA,GACpB,MAAM,IAAIp9B,MAAM,+KAEpB,MAAM2wB,EAAgB,CAClBnB,aACAjnB,KAAM,EAAAqoB,aAAaE,MACnBrB,UACAsB,eAAgB,CACZ4L,eAGFU,EAAWN,EAAeL,mBAChC1iB,EAAgBiX,cAAcN,GAC9B,MAAM2M,EAAgBtjB,EAAgB0W,YAAYlB,GAIlD,aAHM8N,EAAcC,SAAS9W,EAAOlL,UACpC+hB,EAAc/L,iBAAiB8L,GAC/BC,EAAcz/B,SACPy/B,CACX,C,wCCAA,SAASE,GAAiB37B,GACtB,OAAOhD,KAAK0kB,MAAM1hB,EAAQ,GAAAogB,SAAW,GAAAA,OACzC,CAEA,SA/BA,SAASwb,EAAY57B,EAAO67B,EAAY,GACpC,GAAIp9B,MAAMC,QAAQsB,GACd,OAAOA,EAAMoI,IAAK2F,GAAM6tB,EAAY7tB,EAAG8tB,IAAY1P,KAAK,MAE5D,GAAInsB,SAAmD,KAAVA,EACzC,MAAO,MAEXA,EAAQsK,OAAOtK,GACf,MAAM87B,EAAW9+B,KAAKud,IAAIva,GAC1B,GAAI87B,EAAW,KACX,MAAO,GAAG97B,IAEd,MAAM+7B,EAAiBD,GAAY,IAC7BD,EAAY,EACZC,GAAY,GACRD,EAAY,EACZC,GAAY,EACRD,EACAC,GAAY,GACRD,EAAY,EACZC,GAAY,IACRD,EAAY,EACZC,GAAY,KACRD,EAAY,EACZA,EAAY,EACtC,OAAO77B,EAAMg8B,QAAQD,EACzB,EC3Be,SAASE,GAAmB/2B,EAAYvI,EAAOC,GAC1D,MAAMs/B,EAASh3B,EAAWvE,SAAWhE,EAAQC,EAAS,EAChDu/B,EAAQj3B,EAAWvE,SAAWhE,EAAQC,EAAS,EACrD,GAAIs/B,GAAUC,EAAO,CACjB,MAAMC,EAAgB,IAAItzB,aAAanM,EAAQC,GAC/C,IAAIgP,EAAS,EACTywB,EAAa,EACjB,MAAMC,EAAYJ,EAAS,EAAI,EAC/B,IAAK,IAAI7+B,EAAI,EAAGA,EAAIV,EAAOU,IACvB,IAAK,IAAIE,EAAI,EAAGA,EAAIX,EAAQW,IAAK,CAC7B,MAAMgY,EAAIrQ,EAAW0G,GACf4J,EAAItQ,EAAW0G,EAAS,GACxB6J,EAAIvQ,EAAW0G,EAAS,GAC9BwwB,EAAcC,IAAe9mB,EAAIC,EAAIC,GAAK,EAC1C7J,GAAU0wB,EACVD,GACJ,CAEJ,OAAOD,CACX,CAEI,OAAOl3B,CAEf,C,gBCZA,SATA,SAA6BjJ,GACzB,GAAIA,aAAoB,MAAgB,CAEpC,OADe81B,EAAA,GAAMxM,UAAUtpB,EAASkrB,eAC1BzN,QAClB,CACK,GAAIzd,EAASg5B,YACd,OAAOh5B,EAASg5B,aAExB,ECVO,SAASsH,GAAyBjxB,EAAO2d,GAC5C,MAAMuT,EAAc,IAAIlxB,GACxB,OAAI2d,GAAQuT,EAAY77B,QACpB87B,GAAaD,GACNA,IAEXC,GAAaD,GACNA,EAAY/7B,MAAM,EAAGwoB,GAChC,CACA,SAASwT,GAAanxB,GAClB,IAAK,IAAI/B,EAAI+B,EAAM3K,OAAS,EAAG4I,EAAI,EAAGA,IAAK,CACvC,MAAMgH,EAAIvT,KAAKsP,MAAMtP,KAAK0/B,UAAYnzB,EAAI,KACzC+B,EAAM/B,GAAI+B,EAAMiF,IAAM,CAACjF,EAAMiF,GAAIjF,EAAM/B,GAC5C,CACJ,C,2ECdA,SAASozB,GAAeC,GACpB,MAAMC,EAAMD,EAAEnd,SAAS,IACvB,OAAqB,GAAdod,EAAIl8B,OAAc,IAAMk8B,EAAMA,CACzC,CACA,SAASC,GAASvnB,EAAGC,EAAGC,GACpB,MAAO,IAAMknB,GAAepnB,GAAKonB,GAAennB,GAAKmnB,GAAelnB,EACxE,CACA,SAASsnB,GAASF,GACd,MAAMG,EAAS,4CAA4CC,KAAKJ,GAChE,OAAOG,EACD,CACEznB,EAAG2nB,SAASF,EAAO,GAAI,IACvBxnB,EAAG0nB,SAASF,EAAO,GAAI,IACvBvnB,EAAGynB,SAASF,EAAO,GAAI,KAEzB,IACV,CChBO,SAASG,GAAUC,EAAMC,GAC5B,GAAID,IAASC,EACT,OAAO,EAEX,GAAY,MAARD,GAAwB,MAARC,EAChB,OAAO,EAEX,IACI,OAAOC,KAAKC,UAAUH,KAAUE,KAAKC,UAAUF,EACnD,CACA,MAAO33B,GAEH,OADAgJ,QAAQwM,MAAM,kDAAmDxV,GAC1D03B,IAASC,CACpB,CACJ,C,oDCaA,SAASG,GAAUC,EAAWC,GAC1B,MAAMC,EAAe,CAAC,EACtB,IAAIC,EAAwB,GAC5B,MAAMC,EAAYl+B,OAAO4B,KAAKk8B,GAC9B,IAAK,IAAIl0B,EAAI,EAAGA,EAAIs0B,EAAUl9B,OAAQ4I,IAAK,CACvC,MAAMu0B,EAAkB,IAAI3D,IACtB4D,EAASN,EAAUI,EAAUt0B,IACnC,IAAK,IAAIgH,EAAI,EAAGA,EAAIwtB,EAAOp9B,OAAQ4P,IAAK,CACpC,MAAMytB,EAAcN,EAAaK,EAAOxtB,GAAGrM,UAAY,EAIvD,GAHAy5B,EAAaK,GAAeL,EAAaK,IAAgB,GACzDL,EAAaK,GAAax1B,KAAK,CAAEtE,QAAS65B,EAAOxtB,GAAGrM,UACpD45B,EAAgBz6B,IAAI26B,GAChBF,EAAgB7U,KAAO,EAAI1Y,EAC3B,MAER,CACA,GAAS,GAALhH,EACAq0B,EAAwBn/B,MAAM6D,KAAKw7B,QAElC,IAAKG,GAAUL,EAAuBE,GACvC,MAER,CACA,OAAOH,CACX,CACA,SAASO,GAAYh6B,EAASi6B,GAC1B,MAAMn+B,EAAQ6xB,EAAS1xB,IAAIg+B,EAAKj6B,GAChC,IACI,OAAO8Q,WAAWhV,EACtB,CACA,MACI,MACJ,CACJ,CACA,SAASo+B,GAAwBl6B,GAC7B,MAAMlE,EAAQ6xB,EAAS1xB,IAAI,WAAY+D,GACvC,IACI,MAAM,aAAEm6B,GAAiBr+B,EACzB,GAAIq+B,EAAc,CACd,MAAMC,EAAcC,KAAKF,GACnBG,EAAU,IAAIjzB,YAAY+yB,EAAY39B,QACtC89B,EAAK,IAAIC,SAASF,GACxB,IAAK,IAAIj1B,EAAI,EAAGA,EAAI+0B,EAAY39B,OAAQ4I,IACpCk1B,EAAGE,SAASp1B,EAAG+0B,EAAY9e,WAAWjW,IAE1C,OAAO,IAAIT,aAAa01B,GAAS,EACrC,CACA,OAAOxpB,WAAWhV,EACtB,CACA,MACI,MACJ,CACJ,CACA,SAAS4+B,GAAwB16B,GAC7B,IAAIlE,EAAQ6xB,EAAS1xB,IAAI,WAAY+D,IAAY2tB,EAAS1xB,IAAI,WAAY+D,GAC1E,IACI,MAAM,aAAEm6B,GAAiBr+B,EAIzB,OAHIq+B,IACAr+B,EAAQu+B,KAAKF,IAEVrpB,WAAWhV,EACtB,CACA,MACI,MACJ,CACJ,CACA,SAAS6+B,GAAmB36B,GACxB,IAAIlE,EAAQ6xB,EAAS1xB,IAAI,WAAY+D,GACrC,IACI,MAAM,aAAEm6B,GAAiBr+B,EAIzB,OAHIq+B,IACAr+B,EAAQu+B,KAAKF,GAAcl8B,MAAM,OAE9B6S,WAAWhV,EAAM,IAAM,GAClC,CACA,MACI,MACJ,CACJ,CACA,SAASi+B,GAAUa,EAAOC,GACtB,GAAID,EAAMn+B,QAAUo+B,EAAM9V,KACtB,OAAO,EAEX,IAAK,IAAI1f,EAAI,EAAGA,EAAIu1B,EAAMn+B,OAAQ4I,IAC9B,IAAKw1B,EAAM37B,IAAI07B,EAAMv1B,IACjB,OAAO,EAGf,OAAO,CACX,CACA,SAASy1B,GAAyB96B,GAC9B,MAAM+6B,EAAapN,EAAS1xB,IAAI,iBAAkB+D,GAClD,OAAO+6B,EAAaA,EAA+B,mBAAI,CAC3D,CAwCA,SAvCA,SAA+BvlB,GAC3B,MAAMwlB,EAnHV,SAAsBxlB,GAClB,MAAMylB,EAAczlB,EAAStR,IAAKlE,IAC9B,MAAM,qBAAE0D,GAAyBiqB,EAAS1xB,IAAI,mBAAoB+D,IAAY,CAAC,EAC/E,MAAO,CAAEA,UAAS0D,0BAEtB,IAAKu3B,EAAYnS,MAAOtZ,GAASA,EAAK9L,sBAClC,OAAO,KAEX,MAAMs3B,GAdch/B,EAcwB,uBAAbi/B,EAblBC,OAAO,CAACC,EAAIhiC,MACpBgiC,EAAGhiC,EAAE6C,IAAQm/B,EAAGhiC,EAAE6C,KAAS,IAAIsI,KAAKnL,GAC9BgiC,GACR,CAAC,IAJQ,IAAQn/B,EAepB,MAAM29B,EAAYl+B,OAAO4B,KAAK29B,GACxBI,EAAcJ,EAAerB,EAAU,IAAIl9B,OACjD,OAAoB,IAAhB2+B,EACO,KAEezB,EAAU7Q,MAAOrc,GAAMuuB,EAAevuB,GAAGhQ,SAAW2+B,GAIvEJ,EAFI,IAGf,CAgG2BK,CAAa7lB,GACpC,IAAKwlB,EACD,MAAO,CAAEM,cAAe,CAAC9lB,GAAW+lB,aAAc,MAEtD,MAAMC,EAAO,CACT,6BACA,kBACA,cACA,WACA,aACA,uBACA,uBACA,kBACA,yBAEEC,EAAW,CACZz7B,GAAYg6B,GAAYh6B,EAASw7B,EAAK,IACtCx7B,GAAYg6B,GAAYh6B,EAASw7B,EAAK,IACtCx7B,GAAYg6B,GAAYh6B,EAASw7B,EAAK,IACtCx7B,GAAYg6B,GAAYh6B,EAASw7B,EAAK,IACtCx7B,GAAYg6B,GAAYh6B,EAASw7B,EAAK,IACvCtB,GACAQ,GACAC,GACAG,IAEJ,IAAK,IAAIz1B,EAAI,EAAGA,EAAIo2B,EAASh/B,OAAQ4I,IAAK,CACtC,MAAMo0B,EAAeH,GAAU0B,EAAgBS,EAASp2B,IACxD,GAAIo0B,EAAc,CAKd,MAAO,CAAE6B,cAJU7/B,OAAO4B,KAAKo8B,GAC1Bv1B,IAAIkC,OAAO0K,YACX0F,KAAK,CAACC,EAAGlF,IAAMkF,EAAIlF,GACSrN,IAAKlI,GAAQy9B,EAAaz9B,GAAKkI,IAAKsL,GAASA,EAAKxP,UAC3Du7B,aAAcC,EAAKn2B,GAC/C,CACJ,CACA,MAAO,CAAEi2B,cAAe,CAAC9lB,GAAW+lB,aAAc,KACtD,ECzJA,SALA,SAA8B/lB,GAC1B,MAAQ8lB,cAAeI,EAAU,aAAEH,GAAiB,GAAsB/lB,GAE1E,MAAO,CAAEmmB,gBADeD,EAAWj/B,OAAS,EAClBi/B,aAAYH,eAC1C,E,gBCLe,SAASK,GAAWx0B,EAAOyW,GACtC,MAAMge,EAAcz0B,EAAM3K,QACpB,aAAEqhB,EAAY,iBAAEC,EAAgB,MAAEE,GAAUJ,EAClD,GAAmC,OAA/BA,EAAkB7jB,UAAsC,iBAAVikB,EAC9C,IAAK,IAAI5Y,EAAI,EAAGA,EAAIw2B,EAAax2B,IAC7B+B,EAAM/B,GAAK4Y,GAAS7W,EAAM/B,GAAKyY,EAAeC,QAIlD,IAAK,IAAI1Y,EAAI,EAAGA,EAAIw2B,EAAax2B,IAC7B+B,EAAM/B,GAAK+B,EAAM/B,GAAKyY,EAAeC,EAG7C,OAAO3W,CACX,C,gBCdO,SAAS00B,GAAKC,EAAKC,EAAKC,GAC3B,OAAOnjC,KAAKa,IAAIb,KAAKyQ,IAAIyyB,EAAKD,GAAME,EACxC,CAKA,YCAe,SAAS,GAAOlkC,EAAUkI,GAErC,KADuB,EAAAq1B,GAAA,IAAkBv9B,EAAS2xB,SAE9C,MAAM,IAAIzvB,MAAM,0DAEpB,GAAIlC,aAAoB,OACc,IAAlCA,EAASg5B,cAAct0B,OACvB,MAAM,IAAIxC,MAAM,wCAEpB,MAAM,SAAE6Z,EAAQ,MAAElE,EAAK,YAAEssB,GAAgBj8B,EACzC,GAAIlI,aAAoB,OAiBrB,SAAsBA,EAAU+b,EAAUlE,EAAOssB,GAAc,GAClE,MAAMlb,EAAmBkb,GACnB,eAAE/Y,EAAc,iBAAEE,EAAgB,eAAEC,IAAmB,EAAA6Y,GAAA,GAA4BpkC,EAAU+b,EAAUkN,GAC7G,IAAKsC,EACD,OAEJ,MAAM,WAAEhG,EAAU,yBAAEL,EAAwB,OAAEF,GAAWuG,GACnD,WAAEpG,EAAU,gBAAEpB,EAAe,SAAEqO,GAAapN,GAC5C,cAAEqf,EAAa,YAAE1M,IAAgB,EAAA2M,GAAA,GAAsBnf,EAAYiN,EAAU7M,EAAYxB,EAAiBmB,EAA0BrN,GAC1I7X,EAASukC,UAAU,CACfpf,WAAYkf,EACZjS,SAAUuF,IAEd33B,EAASD,SACT,MAAMykC,EAAmBlZ,EAAmBzT,EACtC4sB,EAA0B,CAC5B1oB,WACA/b,WACA6X,QACA2sB,mBACAlZ,mBACAF,iBACAsZ,eAAgB1kC,EAAS2kC,sBAExBH,EAAmBpZ,GAAkBoZ,EAAmB,IACzDxkC,EAAS2kC,qBACT,EAAAC,EAAA,GAAaxN,EAAA,EAAa,EAAAnD,OAAO4Q,qCAAsCJ,IAGvE,EAAAG,EAAA,GAAaxN,EAAA,EAAa,EAAAnD,OAAO6Q,uBAAwBL,EAEjE,CA/CQM,CAAa/kC,EAAU+b,EAAUlE,EAAOssB,OAEvC,CACD,MAAMlO,EAAej2B,EAASk5B,yBAC9B,GAAIjD,EAAepe,EACf7X,EAASg5B,cAAct0B,OAAS,GAChCuxB,EAAepe,EAAQ,EAAG,CAC1B,MAAMmtB,EAAY,CACd/O,eACArqB,UAAWiM,IAEf,EAAA+sB,EAAA,GAAaxN,EAAA,EAAa,EAAAnD,OAAOgR,2BAA4BD,EACjE,CACAhlC,EAASklC,OAAOrtB,EAAO3P,EAAQi9B,gBAAiBj9B,EAAQk9B,KAC5D,CACJ,CC7BA/G,eAAegH,GAAY1T,EAASzpB,EAAU,CAAC,GAC3C,MAAM,WAAEwd,EAAU,gBAAEyf,EAAe,SAAEppB,GAAa7T,EAC5C9I,GAAiB,EAAAm+B,GAAA,IAAkB5L,GACzC,IAAKvyB,EACD,MAAM,IAAI8C,MAAM,6BAEpB,MAAM,SAAElC,GAAaZ,GACbsmB,WAAY4f,EAAiB,eAAE9f,GAK3C,SAA4BxlB,EAAUmlC,GAClC,GAAInlC,aAAoBw9B,GAAA,EACpB,MAAO,CACHhY,eAAgBxlB,EAASg5B,cAAct0B,OACvCghB,WAAYyf,EACNnlC,EAASulC,wBACTvlC,EAASk5B,0BAGvB,MAAO,CACH1T,eAAgBxlB,EAASwlC,oBACzB9f,WAAY1lB,EAAS07B,gBAE7B,CAlB8D+J,CAAmBzlC,EAAUmlC,GACjFO,EAkBV,SAA8BlgB,EAAgBE,GAC1C,MAAMigB,EAAiBngB,EAAiB,EACxC,OAAO,GAAKE,EAAY,EAAGigB,EAC/B,CArB6BC,CAAqBpgB,EAAgBE,GAE9D,GAAO1lB,EAAU,CAAE6X,MADL6tB,EAAmBJ,EACPH,kBAAiBppB,YAC/C,CCVA,SAAS8pB,GAAgBC,EAAoBtuB,EAAWtP,EAAU,CAAC,GAC/D,MAAM69B,EAAmBjQ,EAAA,GAAMxM,UAAUwc,GACzC,IAAKC,EACD,MAAM,IAAI7jC,MAAM,6BAA6B4jC,qBAEjD,MAAM,SAAEj7B,EAAQ,QAAEY,EAAO,UAAEG,EAAWJ,WAAYw6B,GAAkBD,GAC9D,KAAE7d,EAAI,KAAEC,EAAI,KAAE8d,EAAI,KAAEC,EAAI,KAAEC,EAAI,KAAEC,GAAS5uB,EACzC6uB,EAAa,CACftlC,KAAKa,IAAIsmB,EAAMC,GACfpnB,KAAKa,IAAIqkC,EAAMC,GACfnlC,KAAKa,IAAIukC,EAAMC,IAEbE,GAAyB,EAAAC,EAAA,GAAsBR,EAAiB5e,UAAWkf,GAC3E76B,EAAa,CACfzK,KAAKud,IAAI6J,EAAOD,GAAQ,EACxBnnB,KAAKud,IAAI4nB,EAAOD,GAAQ,EACxBllC,KAAKud,IAAI8nB,EAAOD,GAAQ,IAEtB,aAAE37B,GAAiBtC,EACnBs+B,EAAmB,CACrB37B,WACAW,aACAC,UACAC,OAAQ46B,EACR16B,YACApB,eACAvB,WAAmC,iBAAvBuB,GAAcC,KACpB,IAAIoC,aAAarB,EAAW,GAAKA,EAAW,GAAKA,EAAW,SAC5D1J,GAEJ2kC,GAAY,KAAAC,oBAAkB,EAAAnI,EAAA,KAAUiI,GACxCG,EAAgBF,EAAU39B,aAAa89B,6BACvCC,EAAqBr7B,EAAW,GAAKA,EAAW,GAChDs7B,EAAqBd,EAAa,GAAKA,EAAa,GACpDe,EAAgBhB,EAAiBj9B,aAAa89B,6BACpD,IAAK,IAAI11B,EAAI,EAAGA,EAAI1F,EAAW,GAAI0F,IAC/B,IAAK,IAAI5P,EAAI,EAAGA,EAAIkK,EAAW,GAAIlK,IAAK,CACpC,MAAM0lC,GAAgB,EAAAT,EAAA,GAAsBE,EAAUtf,UAAW,CAC7D,EACA7lB,EACA4P,IAEE+1B,GAAuB,EAAAC,EAAA,GAAsBnB,EAAiB5e,UAAW6f,GACzEG,EAA0BF,EAAqB,GAAKH,EACtDG,EAAqB,GAAKjB,EAAa,GACvCiB,EAAqB,GACnBG,EAAUL,EAAcviC,MAAM2iC,EAAyBA,EAA0B37B,EAAW,IAC5F67B,EAA2Bn2B,EAAI21B,EAAqBvlC,EAAIkK,EAAW,GACzEm7B,EAAc3iC,IAAIojC,EAASC,EAC/B,CAGJ,OADAZ,EAAU39B,aAAaw+B,2BAA2BX,GAC3CF,CACX,CCxDA,SAASc,GAA0BpgB,EAAWnC,GAC1C,MAAM,OAAEwiB,EAAM,gBAAEzjB,GAAoBiB,EAC9ByiB,GAAY,EAAAP,EAAA,GAAgC/f,EAAW,CAAC,EAAG,EAAG,IAC9DugB,EAAiB,YAAY,cAAeF,GAC5CG,EAAmB,YAAY,cAAe5jB,GAC9C6jB,EAAiB,WAAW,cAAeF,EAAgBC,GAC3DE,EAAe,SAAS,eAAe,EAAAX,EAAA,GAAgC/f,EAAWugB,GAAiBD,GACnGK,EAAiB,SAAS,eAAe,EAAAZ,EAAA,GAAgC/f,EAAWwgB,GAAmBF,GAC7G,eAAeI,EAAcA,GAC7B,eAAeC,EAAgBA,GAE/B,MAAO,CACHF,iBACAF,iBACAC,mBACAI,aALiB,WAAW,cAAeF,EAAcC,GAMzDD,eACAC,iBAER,C,2BCrBO,SAASE,GAA2B/+B,EAAYuC,EAAYy8B,EAAWC,GAC1E,MAAOxnC,EAAOC,EAAQwnC,GAAa38B,EAC7B48B,EAAoB1nC,EAAQC,EAClC,IAAIgW,EAAM,EACN0xB,EAAQ,EACR/2B,EAAQ,EACZ,MAAOg3B,EAAIC,EAAIC,GAAMP,EAAU97B,IAAIpL,KAAK0kB,OACxC,IAAK,IAAIvU,EAAIs3B,EAAKN,EAAQh3B,GAAKs3B,EAAKN,EAAQh3B,IACxC,KAAIA,EAAI,GAAKA,GAAKi3B,GAGlB,IAAK,IAAI7mC,EAAIinC,EAAKL,EAAQ5mC,GAAKinC,EAAKL,EAAQ5mC,IACxC,KAAIA,EAAI,GAAKA,GAAKX,GAGlB,IAAK,IAAIS,EAAIknC,EAAKJ,EAAQ9mC,GAAKknC,EAAKJ,EAAQ9mC,IAAK,CAC7C,GAAIA,EAAI,GAAKA,GAAKV,EACd,SAEJ,MACMqD,EAAQkF,EADAiI,EAAIk3B,EAAoB9mC,EAAIZ,EAAQU,GAElDuV,GAAO5S,EACPskC,GAAStkC,EAAQA,EACjBuN,GACJ,CAGR,GAAc,IAAVA,EAAa,CACb,MAAMm3B,EAAcD,EAAKJ,EAAoBG,EAAK7nC,EAAQ4nC,EAC1D,GAAIG,GAAe,GAAKA,EAAcx/B,EAAWvE,OAAQ,CAErD,MAAO,CAAEgkC,KADWz/B,EAAWw/B,GACHE,OAAQ,EAAGr3B,MAAO,EAClD,CAEI,MAAO,CAAEo3B,KAAM,EAAGC,OAAQ,EAAGr3B,MAAO,EAE5C,CACA,MAAMo3B,EAAO/xB,EAAMrF,EACbs3B,EAAWP,EAAQ/2B,EAAQo3B,EAAOA,EAExC,MAAO,CAAEA,OAAMC,OADA5nC,KAAK8nC,KAAK9nC,KAAKyQ,IAAI,EAAGo3B,IACdt3B,QAC3B,CCvCA,MAAMw3B,GAAmC,IAAI5K,IAAI,CAC7C,4BACA,8BACA,gCACA,8BACA,gCACA,8BACA,gCACA,+BACA,iCACA,+BACA,iCACA,iCAEE6K,GAAkB,IAAI7K,IAsEb,SAAS8K,GAA2BC,GAC/C,MAAM,aAAEC,EAAY,YAAEC,EAAW,4BAAEC,GAAgCH,EACnE,GAAIG,EACA,OArBR,SAAiCH,GAC7B,MAAM,4BAAEG,GAAgCH,EAClCI,EAAqB7mC,MAAMC,QAAQ2mC,GACzC,GAAIC,GAAsBD,EAA4B1kC,OAAS,EAE3D,YADA+N,QAAQC,KAAK,sHAGjB,MAAM,eAAE42B,EAAc,eAAEC,GAAmBF,EACrCD,EAA4B,GAC5BA,EAKN,MAAO,CACHF,aALmB,CACQ,GAA3BnoC,KAAKud,IAAIgrB,GACkB,GAA3BvoC,KAAKud,IAAIirB,IAKjB,CAIeC,CAAwBP,GAGnC,OADqBH,GAAiC3hC,IAAIgiC,GA1E9D,SAA2CF,GACvC,MAAM,aAAEC,EAAY,mBAAEO,EAAkB,yCAAEC,EAAwC,4BAAEC,EAA2B,mCAAEC,GAAwCX,EACnJY,GAAe,EACrB,IAAKJ,EACD,MAAO,CACHP,eACAz+B,KAAM,EAAAq/B,iBAAiBC,QACvBF,gBAGR,IAAKX,EACD,OAAKQ,EAYE,CACHR,aAF0BO,EAAmBt9B,IAAKO,GAAiBA,EAAeg9B,GAGlFj/B,KAAM,EAAAq/B,iBAAiBE,KACvBH,iBAdKd,GAAgB5hC,IAAI8hC,EAASgB,qBAC9Bx3B,QAAQC,KAAK,qEAAsEu2B,EAASgB,kBAAmB,0CAC/GlB,GAAgB3hC,IAAI6hC,EAASgB,oBAE1B,CACHf,aAAcO,EACdh/B,KAAM,EAAAq/B,iBAAiBI,WACvBL,iBAUZ,OAAI,EAAA7L,GAAA,IAAQkL,EAAcO,GACf,CACHP,eACAz+B,KAAM,EAAAq/B,iBAAiBI,WACvBL,gBAGJF,GAA+BC,EACxB,CACHV,eACAz+B,KAAM,EAAAq/B,iBAAiBK,WACvBN,eACAF,8BACAC,sCAGD,CACHV,eACAz+B,KAAM,EAAAq/B,iBAAiBC,QACvBF,eAER,CA0BeO,CAAkCnB,GAEtC,CACHC,eACAz+B,KAAM,EAAAq/B,iBAAiBO,eACvBR,cAAc,EAEtB,C,gBCFA,MAAMS,GAAsB,CAACtqC,EAAU+b,IClGvC,SAA8B/b,EAAU+b,EAAUuN,GAC9C,IAAKA,EACD,MAAM,IAAIpnB,MAAM,4DAEpB,GAAIlC,EAASiC,SACT,OAAOjC,EAASiC,SAEpB,GAAIjC,EAASw0B,WAAY,CAErB,KADAzY,EAAWA,GAAY/b,EAASkrB,iBACd5B,EACd,OAGJ,OADeA,EAAUvN,GACXlR,SAAS0/B,QAC3B,CACA,MAAM,IAAIroC,MAAM,wBACpB,CDkFoDsoC,CAAqBxqC,EAAU+b,EAAU+Z,EAAA,GAAMxM,U,kBElGpF,SAASmhB,EAA0B1b,GAC9C,IAAKA,EACD,OAEJ,MAAM/B,EAAO+B,EAAoBC,UACjC,IAAK,IAAI5iB,EAAQ,EAAGA,EAAQ4gB,EAAM5gB,IAAS,CACvC,MAAM6iB,EAAa,GACnBF,EAAoBG,aAAa9iB,EAAO6iB,GACxCA,EAAW,GAAK,EAAIA,EAAW,GAC/BA,EAAW,GAAK,EAAIA,EAAW,GAC/BA,EAAW,GAAK,EAAIA,EAAW,GAC/BF,EAAoBI,aAAa/iB,EAAO6iB,EAC5C,CACJ,C,kCCbA,SAASyb,EAA6BC,EAAMC,EAAMra,GAC9C,OAAOxvB,KAAKud,IAAIqsB,EAAOC,IAASra,CACpC,CAYA,SAASsa,EAAa9mC,GAClB,MAAwB,iBAAVA,CAClB,CACA,SAAS+mC,EAAkB/mC,GACvB,OAAQA,GACa,iBAAVA,GACP,WAAYA,GACY,iBAAjBA,EAAMW,QACbX,EAAMW,OAAS,GACK,iBAAbX,EAAM,EACrB,CACO,SAASi6B,EAAQ3N,EAAIC,EAAIC,EAAY,MACxC,cAAWF,UAAcC,GAAa,OAAPD,GAAsB,OAAPC,IAG1Cua,EAAaxa,IAAOwa,EAAava,GAC1Boa,EAA6Bra,EAAIC,EAAIC,MAE5Cua,EAAkBza,KAAOya,EAAkBxa,KA7BnD,SAAwBya,EAAMC,EAAMza,EAAY,MAC5C,GAAIwa,EAAKrmC,SAAWsmC,EAAKtmC,OACrB,OAAO,EAEX,IAAK,IAAI4I,EAAI,EAAGA,EAAIy9B,EAAKrmC,OAAQ4I,IAC7B,IAAKo9B,EAA6BK,EAAKz9B,GAAI09B,EAAK19B,GAAIijB,GAChD,OAAO,EAGf,OAAO,CACX,CAoBe0a,CAAe5a,EAAIC,EAAIC,GAGtC,C,sDACA,MAAM2a,EAAYp5B,GAAmB,iBAANA,GAAkBA,EAAIA,GAAG3F,IAAM2F,EAAE3F,IAAI++B,IAAap5B,EAC3EwM,EAAOxM,GAAmB,iBAANA,EAAiB/Q,KAAKud,IAAIxM,GAAKA,GAAG3F,IAAM2F,EAAE3F,IAAImS,GAAOxM,EAClEq5B,EAAkB,CAAC9a,EAAIC,EAAIC,OAAYzuB,IAAck8B,EAAQ3N,EAAI6a,EAAS5a,GAAKC,GAC/E6a,EAAa,CAAC/a,EAAIC,EAAIC,OAAYzuB,IAAck8B,EAAQ1f,EAAI+R,GAAK/R,EAAIgS,GAAKC,GAChF,SAAS8a,EAASrb,GACrB,OAAIxtB,MAAMC,QAAQutB,GACPqb,EAASrb,EAAE,IAEfsb,SAAStb,KAAOhR,MAAMgR,EACjC,CACA,S,gOC9CA,MAAMub,E,MAAW,gBAIV,SAASC,EAAcpnC,GAC1B,MAAMqnC,EAASF,EAAS5nB,UAAUvf,EAAK,IAIvC,OAHAqnC,EAAO9nB,UAAY,IAAI+nB,IACZF,EAAc,GAAGpnC,KAAQsnC,EAAMxb,KAAK,QAExCub,CACX,CACO,SAAS9nB,KAAavf,GACzB,OAAOonC,EAAcpnC,EAAK8rB,KAAK,KACnC,CAZsB,oBAAX6B,SACPA,OAAOtO,IAAM8nB,GAYV,MAAMI,EAAUH,EAAc,QACxB9nB,EAAUioB,EAAQhoB,UAAU,QAC5BioB,EAAWD,EAAQhoB,UAAU,SAC7BkoB,EAAYF,EAAQhoB,UAAU,oBAC9BmoB,EAAQH,EAAQhoB,UAAU,MAC1BooB,EAAcJ,EAAQhoB,UAAU,YAChCqoB,EAAsBroB,EAAU,cAAe,SAC/CsoB,EAAsBtoB,EAAU,cAAe,Q,iDCrB7C,SAASuoB,EAAmBzuB,GACvC,MAAMkgB,EAAWlgB,EAAS,IACpB,oBAAEpS,EAAmB,cAAEJ,EAAa,WAAEC,EAAU,QAAEC,EAAO,0BAAE6B,EAAyB,gBAAE5B,IAAqB,IAAAlH,KAAI,mBAAoBy5B,GACnIwO,EAAS,GACTC,GAAe,IAAAloC,KAAI,eAAgBy5B,GACzC,IAAI9gB,EACJ,GAAIuvB,EAAc,CACd,MAAM,YAAE9pC,EAAW,aAAEC,GAAiB6pC,EAEtC,GADAvvB,EAAiBuvB,GAAcvvB,eAC3Bra,MAAMC,QAAQH,GACd,IAAK,IAAIgL,EAAI,EAAGA,EAAIhL,EAAYoC,OAAQ4I,IACpC6+B,EAAO5/B,KAAK,CACRjK,YAAaA,EAAYgL,GACzB/K,aAAcA,EAAa+K,UAKnC6+B,EAAO5/B,KAAK,CACRjK,YAAaA,EACbC,aAAcA,GAG1B,MAEI4pC,EAAO5/B,KAAK,CACRjK,iBAAaR,EACbS,kBAAcT,IAGtB,MAAM,SAAEG,EAAQ,kBAAE27B,IAAsB,IAAA15B,KAAI,sBAAuBy5B,IAC7D,wBAAE9xB,EAAuB,aAAEa,EAAY,oBAAEZ,EAAmB,QAAEhJ,EAAO,KAAEC,IAAU,IAAAmB,KAAI,mBAAoBy5B,GAC/G,MAAO,CACH0O,cAAephC,EACfqhC,WAAYphC,EACZqhC,gBAAiBnhC,EACjBohC,QAASrhC,EACTshC,0BAA2Bz/B,EAC3B0/B,oBAAqBrhC,EACrBk/B,SAAUtoC,EACV0qC,wBAAyB9gC,EACzBq9B,aAAcx8B,EACdkB,oBAAqB9B,EACrB8gC,QAAS9pC,EACT+pC,KAAM9pC,EACNopC,SACAW,eAAgBjwB,EAChBotB,kBAAmBrM,EAE3B,C,wLChDA,SAASmP,EAAsBC,EAAIC,EAAIxT,GACnC,MAAOyT,EAAIC,EAAIC,GAAMJ,GACdtiB,EAAI3I,EAAIsrB,GAAMJ,GACdK,EAAGC,EAAGC,EAAGC,GAAKhU,EACf/a,EAAIgM,EAAKwiB,EACT1zB,EAAIuI,EAAKorB,EACTxM,EAAI0M,EAAKD,EACTM,GAAM,GAAKJ,EAAIJ,EAAKK,EAAIJ,EAAKK,EAAIJ,EAAKK,IAAOH,EAAI5uB,EAAI6uB,EAAI/zB,EAAIg0B,EAAI7M,GAIvE,MAAO,CAHGjiB,EAAIgvB,EAAIR,EACR1zB,EAAIk0B,EAAIP,EACRxM,EAAI+M,EAAIN,EAEtB,CACA,SAAS1T,EAAciU,EAAQh9B,EAAOi9B,GAAa,GAC/C,MAAON,EAAGC,EAAGC,GAAKG,EACZF,EAAIH,EAAI38B,EAAM,GAAK48B,EAAI58B,EAAM,GAAK68B,EAAI78B,EAAM,GAClD,GAAIi9B,EAAY,CACZ,MAAMlpC,EAAS3D,KAAK8nC,KAAKyE,EAAIA,EAAIC,EAAIA,EAAIC,EAAIA,GAC7C,MAAO,CAACF,EAAI5oC,EAAQ6oC,EAAI7oC,EAAQ8oC,EAAI9oC,EAAQ+oC,EAAI/oC,EACpD,CACA,MAAO,CAAC4oC,EAAGC,EAAGC,EAAGC,EACrB,CACA,SAASI,EAAuBC,EAAYC,EAAaC,GACrD,MAAOC,EAAIC,EAAIC,EAAIC,GAAMN,GAClBO,EAAIC,EAAIC,EAAIC,GAAMT,GAClBU,EAAIC,EAAIC,EAAIC,GAAMZ,EACnBa,EAAK,gBAAgBZ,EAAII,EAAII,EAAIP,EAAII,EAAII,EAAIP,EAAII,EAAII,GACrDG,EAAK,gBAAgBV,EAAII,EAAII,EAAIV,EAAII,EAAII,EAAIP,EAAII,EAAII,GACrDI,EAAK,gBAAgBd,EAAII,EAAII,EAAIL,EAAII,EAAII,EAAIT,EAAII,EAAII,GACrDK,EAAK,gBAAgBf,EAAII,EAAII,EAAIP,EAAII,EAAII,EAAIN,EAAII,EAAII,GAI3D,MAAO,CAHG,iBAAiBE,GAAM,iBAAiBD,GACxC,iBAAiBE,GAAM,iBAAiBF,GACxC,iBAAiBG,GAAM,iBAAiBH,GAEtD,CACA,SAASlV,EAAqBF,EAAO9oB,EAAOs+B,GAAS,GACjD,MAAO3B,EAAGC,EAAGC,EAAGC,GAAKhU,GACdr4B,EAAGE,EAAG4P,GAAKP,EACZu+B,EAAY5B,EAAIlsC,EAAImsC,EAAIjsC,EAAIksC,EAAIt8B,EAAIu8B,EACpCjvB,EAAWzd,KAAKud,IAAI4wB,GAAanuC,KAAK8nC,KAAKyE,EAAIA,EAAIC,EAAIA,EAAIC,EAAIA,GAErE,OADayB,EAASluC,KAAKouC,KAAKD,GAAa,GAC/B1wB,CAClB,CACA,SAAS4wB,EAAez+B,EAAO8oB,EAAOlJ,EAAY,EAAApM,SAC9C,OAAOwV,EAAqBF,EAAO9oB,GAAS4f,CAChD,C,4DC9CO,SAAS8e,EAAqBloB,EAAWjf,GAC5C,MAAM,eAAEonC,EAAc,SAAEtqC,EAAQ,UAAEwS,EAAS,aAAE+3B,GAAe,GAAUrnC,EACtE,IAAIe,EACJ,GAAIke,EAAUhe,cACVF,EAAake,EAAUhe,oBAEtB,CACD,MAAMqmC,EAAUroB,EAAUsoB,eAAeC,aACzC,GAAIF,EACAvmC,EAAaumC,EAAQG,cAEpB,CACD,MAAM,aAAE7mC,GAAiBqe,EAAUjjB,IAAI,iBAAmB,CAAC,EACvD4E,IACAG,EAAaH,EAAa89B,6BAElC,CACJ,CACA,MAAMp7B,EAAa2b,EAAUM,gBACvBmoB,EAAmB,CACrB,CAAC,EAAGpkC,EAAW,IACf,CAAC,EAAGA,EAAW,IACf,CAAC,EAAGA,EAAW,KAGbqkC,EASH,UAAkC,UAAE1oB,EAAS,OAAE4D,EAAM,WAAE9hB,EAAU,eAAEqmC,EAAc,SAAEtqC,IACtF,OAAQ8qC,EAAMC,IAAQC,EAAMC,IAAQC,EAAMC,IAASplB,GAC7C,SAAE/W,GAAamT,EACf3b,EAAa2b,EAAUM,gBACvBC,GAAe,OAAuBP,GACtCipB,EAAW,CAAC,EAAG,EAAG,GAClBC,EAAYr8B,GACd/K,EAAWvE,OAAS8G,EAAW,GAAKA,EAAW,GAAKA,EAAW,GAC7D8kC,EAAY9kC,EAAW,GAAK6kC,EAC5BE,EAAY/kC,EAAW,GAAK8kC,EAC5BT,EAAgB,GACtB,IAAK,IAAIn7B,EAAIw7B,EAAMx7B,GAAKy7B,EAAMz7B,IAAK,CAC/B07B,EAAS,GAAK17B,EACd,MAAM87B,EAAS97B,EAAI67B,EACnB,IAAK,IAAIj8B,EAAI07B,EAAM17B,GAAK27B,EAAM37B,IAAK,CAC/B87B,EAAS,GAAK97B,EACd,MAAMm8B,EAAUD,EAASl8B,EAAIg8B,EAC7B,IAAK,IAAIhjC,EAAIwiC,EAAMxiC,GAAKyiC,EAAMziC,IAAK,CAC/B8iC,EAAS,GAAK9iC,EACd,MAAMojC,EAAWhpB,EAAa0oB,GAC9B,GAAId,EAAeoB,EAAUN,GAAW,CACpC,MAAMhkC,EAAQqkC,EAAUnjC,EAAI+iC,EAC5B,IAAItsC,EAEAA,EADAssC,EAAY,EACJ,CACJpnC,EAAWmD,GACXnD,EAAWmD,EAAQ,GACnBnD,EAAWmD,EAAQ,IAIfnD,EAAWmD,GAEvByjC,EAActjC,KAAK,CACfxI,QACAqI,QACAgkC,WACAM,SAAUA,EAASlsC,UAEvBQ,EAAS,CAAEjB,QAAOqI,QAAOgkC,WAAUM,YACvC,CACJ,CACJ,CACJ,CACA,OAAOb,CACX,CAtD0Bc,CAAyB,CAC3CxpB,YACA4D,OAHWvT,GAAao4B,EAIxB3mC,aACAqmC,iBACAtqC,aAEJ,OAAOuqC,EAAeM,OAAgB/tC,CAC1C,CA+CO,SAAS8uC,GAAqC,aAAE9nC,EAAY,OAAEiiB,EAAM,UAAE5D,EAAS,eAAEmoB,EAAc,SAAEtqC,EAAQ,aAAEuqC,IAC9G,OAAQO,EAAMC,IAAQC,EAAMC,IAAQC,EAAMC,IAASplB,EAC7CrD,GAAe,OAAuBP,GACtCipB,EAAW,CAAC,EAAG,EAAG,GAClBP,EAAgB,GACtB,IAAK,IAAIn7B,EAAIw7B,EAAMx7B,GAAKy7B,EAAMz7B,IAAK,CAC/B07B,EAAS,GAAK17B,EACd,IAAK,IAAIJ,EAAI07B,EAAM17B,GAAK27B,EAAM37B,IAAK,CAC/B87B,EAAS,GAAK97B,EACd,IAAK,IAAIhH,EAAIwiC,EAAMxiC,GAAKyiC,EAAMziC,IAAK,CAC/B8iC,EAAS,GAAK9iC,EACd,MAAMojC,EAAWhpB,EAAa0oB,GAC9B,GAAId,EAAeoB,EAAUN,GAAW,CACpC,MAAMhkC,EAAQtD,EAAa8M,QAAQw6B,GAC7BrsC,EAAQ+E,EAAa+nC,WAAWzkC,GAClCmjC,GACAM,EAActjC,KAAK,CACfxI,QACAqI,QACAgkC,SAAU,IAAIA,GACdM,SAAUA,EAASlsC,UAG3BQ,IAAW,CAAEjB,QAAOqI,QAAOgkC,WAAUM,YACzC,CACJ,CACJ,CACJ,CACA,OAAOb,CACX,C,iDC7Ge,SAASvL,EAAsBnf,EAAYiN,EAAU7M,EAAYxB,EAAiBmB,EAA0B4rB,GACvH,MAAM,IAAElvC,EAAG,IAAE4P,EAAG,QAAE5K,GAAY2e,EACxBwrB,EAAwB,cAC9B,SAASA,EAAuB3e,EAAUjN,GAC1C,MAAM6rB,EAAQjwC,KAAK0kB,OAAOjU,EAAM5P,GAAOsjB,GAEjCmG,GADYzkB,EAAUhF,IAAQ4P,EAAM5P,GACJovC,EACtC,IAAIC,EAAalwC,KAAK0kB,MAAM4F,GACxBgZ,EAAgB,CAChBlf,EAAW,GACPpB,EAAgB,GAAKsH,EAAqBnG,EAC9CC,EAAW,GACPpB,EAAgB,GAAKsH,EAAqBnG,EAC9CC,EAAW,GACPpB,EAAgB,GAAKsH,EAAqBnG,GAElD+rB,GAAcH,EACVG,EAAaD,EACbC,EAAaD,EAERC,EAAa,IAClBA,EAAa,GAEjB,MAAMC,EAAqBD,EAAa/rB,EACxCmf,EAAgB,CACZA,EAAc,GAAKtgB,EAAgB,GAAKmtB,EACxC7M,EAAc,GAAKtgB,EAAgB,GAAKmtB,EACxC7M,EAAc,GAAKtgB,EAAgB,GAAKmtB,GAO5C,MAAO,CAAE7M,gBAAe1M,YALJ,CAChB0M,EAAc,GAAK0M,EAAsB,GACzC1M,EAAc,GAAK0M,EAAsB,GACzC1M,EAAc,GAAK0M,EAAsB,IAGjD,C,uECjCe,SAASI,EAA0B1zB,EAAUI,GACxD,MAAQlS,qBAAsB+R,EAA6B,wBAAE7R,GAA6B,MAAa,mBAAoB4R,EAAS,IACpI,IAAKI,EAAgB,CACjB,MAAMF,EAAe,gBAAgB9R,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IAC/G+R,EAAe,gBAAgB/R,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IACrHgS,EAAiB,cACjB,WAAWA,EAAgBF,EAAcC,EAC7C,CACA,MAAMwzB,EAA6C,YAA9B3zB,EAAS,GAAGvX,MAAM,KAAK,GACtC2e,GAAW,OAAgCpH,GACjD,IAAI4zB,EACJ,SAAStzB,EAAY9V,GACjB,MAAM,qBAAE0D,GAAyB,MAAa,mBAAoB1D,GAC5D+V,EAAiB,cAEvB,OADA,SAASA,EAAgBN,EAA+B/R,GACjD,SAASqS,EAAgBH,EACpC,CACA,GAAKuzB,EAWA,CACD,MAAMlzB,EAAqB,CACvBT,EAAS,GACTA,EAAS1c,KAAKsP,MAAMoN,EAAS/Y,OAAS,KAE1C2sC,EAAiB5zB,EACUM,EAAYG,EAAmB,IAC9BH,EAAYG,EAAmB,IACZ,GAC3CmzB,EAAelhC,SAEvB,KAtBmB,CACf,MAAMoO,EAAqBd,EAAStR,IAAKlE,IAE9B,CACHuW,SAFaT,EAAY9V,GAGzBA,aAGRsW,EAAmBE,KAAK,CAACC,EAAGlF,IAAMA,EAAEgF,SAAWE,EAAEF,UACjD6yB,EAAiB9yB,EAAmBpS,IAAKuS,GAAMA,EAAEzW,QACrD,CAaA,MAAQ0D,qBAAsBD,GAAW,MAAa,mBAAoB2lC,EAAe,IAMzF,MALe,CACXxsB,WACAnZ,SACA2lC,iBAGR,C,iBClDA,SAASC,EAAyBC,GAC9B,MAAMvkB,EAAOukB,EAAiBviB,UACxB9R,EAAS,GACf,IAAK,IAAI9Q,EAAQ,EAAGA,EAAQ4gB,EAAM5gB,IAAS,CACvC,MAAM6iB,EAAa,GACnBsiB,EAAiBriB,aAAa9iB,EAAO6iB,GACrC/R,EAAO3Q,KAAK0iB,EAChB,CACA,OAAO/R,CACX,CACA,SAASs0B,EAAyBD,EAAkBE,GAC3CA,GAAO/sC,SAGZ6sC,EAAiB73B,kBACjB+3B,EAAM1sC,QAAS2sC,IACXH,EAAiB53B,eAAe+3B,KAExC,C,+HCjBO,SAASnX,EAAqBv6B,EAAU2xC,GAC3C,MAAQxqB,UAAWyqB,GAAiB5xC,EAAS+6B,eACvC8W,EAAa7xC,EAAS4zB,cAAc+d,GAC1C,OAAO,OAAsBC,EAAcC,EAC/C,C,kBCLe,SAAStL,EAAsBpf,EAAW2qB,GACrD,OAAO3qB,EAAUO,aAAaoqB,EAClC,C,kCCFe,SAAS5K,EAAsB/f,EAAWrD,GAGrD,OAFwBqD,EAAUyV,aAAa9Y,GACjB3X,IAAIpL,KAAK0kB,MAE3C,CACO,SAASssB,EAAgC5qB,EAAWrD,GACvD,OAAOqD,EAAUyV,aAAa9Y,EAClC,C,oFCLA,MAAMkuB,EAAwB,IACvB,SAASC,EAAuBnhC,EAAQohC,GAC3C,IAAKphC,GAAQpM,SAAWwtC,EAAUtkC,oBAC9B,OAEJskC,EAAUC,mBAAqB,CAC3BvkC,oBAAqBskC,EAAUtkC,oBAC/B+C,MAAOG,EAAO,GACdshC,eAAgB,KAChBC,eAAgB,MAEpB,MAAM,iBAAEF,GAAqBD,EAC7B,GAAsB,IAAlBphC,EAAOpM,OAGP,OAFAytC,EAAiBC,eAAiB,KAClCD,EAAiBE,eAAiB,KAC3BF,EAEX,MAAM9hB,EAAK,SAAS,cAAevf,EAAO,GAAIA,EAAO/P,KAAKsP,MAAMS,EAAOpM,OAAS,KAChF,eAAe2rB,EAAIA,GACnB8hB,EAAiBC,eAAiB/hB,EAClC8hB,EAAiBE,eAAiB,KAClC,MAAMriB,EAAIlf,EAAOpM,OACjB,GAAIsrB,EAAI,EACJ,IAAK,IAAI1iB,EAAIvM,KAAKsP,MAAM2f,EAAI,GAAI1iB,EAAI0iB,EAAG1iB,IAAK,CACxC,MAAMglC,EAAa,SAAS,cAAexhC,EAAOxD,GAAIwD,EAAO,IACvDpM,EAAS,YAAY4tC,GAC3B,KAAI,QAAQ5tC,EAAQ,IAGhB,SAAS4tC,EAAYH,EAAiBC,gBACtC1tC,EAASstC,EAGT,OAFA,eAAeM,EAAYA,GAC3BH,EAAiBE,eAAiBC,EAC3BH,CAEf,CAEJ,OAAOA,CACX,C,kBCxCA,SAASI,EAAuCC,EAAiBlzC,GAC7D,MAAM+J,EAAY/J,EAAMwJ,aAAaK,gBACrC,IAAKqpC,EAAgB/C,aACjB,OAEJ,MAAMxmC,EAAaupC,EACd/C,eACAC,aACAC,UACL,GAAIrwC,EAAMY,OAASZ,EAAMqO,KAAM,CAC3B,MAAM8kC,EAAe,IAAI7lC,WAAWtN,EAAMwD,QAAUxD,EAAMyD,KAAO,GACjE,IAAK,IAAIuK,EAAI,EAAGA,EAAIhO,EAAMwD,QAAUxD,EAAMyD,KAAMuK,IAC5CmlC,EAAiB,EAAJnlC,GAASjE,EAAc,EAAJiE,GAChCmlC,EAAiB,EAAJnlC,EAAQ,GAAKjE,EAAc,EAAJiE,EAAQ,GAC5CmlC,EAAiB,EAAJnlC,EAAQ,GAAKjE,EAAc,EAAJiE,EAAQ,GAEhDhO,EAAMqO,MAAO,EACbrO,EAAM4J,aAAe,IAAMupC,EAC3BxpC,EAAWjF,IAAIyuC,EACnB,MAEIxpC,EAAWjF,IAAIqF,GAEnBmpC,EAAgBE,UACpB,C,mHCtBA,SAASC,EAAc1O,EAAKC,GAGxB,MAAO,CAAE5hC,YAFWvB,KAAKud,IAAI4lB,EAAOD,GAAO,EAErB1hC,cADA0hC,EAAMC,EAAO,GAAK,EAE5C,CACA,SAAS0O,EAAetwC,EAAaC,EAAcsa,EAAiB,IAAmBQ,QACnF,GAAIR,IAAmB,IAAmBQ,QACtCR,IAAmB,IAAmBg2B,gBACtC,MAAO,CACHxwB,MAAO9f,EAAe,IAAOD,EAAc,GAAK,EAChDggB,MAAO/f,EAAe,IAAOD,EAAc,GAAK,GAGnD,GAAIua,IAAmB,IAAmBi2B,aAC3C,MAAO,CACHzwB,MAAO9f,EAAeD,EAAc,EACpCggB,MAAO/f,EAAeD,EAAc,GAIxC,MAAM,IAAIJ,MAAM,2BAExB,C,0cCxBA,IAAI6wC,E,iBACJ,SAAWA,GACPA,EAAyB,YAAI,cAC7BA,EAA4B,eAAI,iBAChCA,EAA0B,aAAI,eAC9BA,EAA0B,aAAI,eAC9BA,EAAuB,UAAI,YAC3BA,EAAkC,qBAAI,uBACtCA,EAAqB,QAAI,UACzBA,EAAuC,0BAAI,4BAC3CA,EAAyB,YAAI,aAChC,CAVD,CAUGA,IAAgBA,EAAc,CAAC,IAClC,S,kBCZA,IAAIC,GACJ,SAAWA,GACPA,EAAU,GAAI,KACdA,EAAY,KAAI,OAChBA,EAAY,KAAI,OAChBA,EAAa,MAAI,OACpB,CALD,CAKGA,IAAUA,EAAQ,CAAC,G,oQCCtB,MAAMC,EAAsB,CACxBC,SAAU,GACVC,cAAe,GACfC,2BAA4B,CAAC,GAsejC,SAASC,EAA0B5oC,GAC/B,MAAM2O,EAAO,mBACPa,EAAO,mBAEb,OADAA,EAAKI,SAAS,EAAG,GACb5P,IAAS,EAAA6oC,4BAA4BC,SAC9B,CACHn6B,OACAa,QAIG,CAAC,CAEhB,CACA,MAAMu5B,EAAkC,IAlfzB,MACX,WAAAjwC,CAAY+hB,GACRxhB,KAAK2vC,kCAAoC,IAAI5/B,IAC7C/P,KAAK4vC,6BAA+B,IAAI7/B,IACxCyR,IAAQ,qBACRxhB,KAAKuoB,MAAQ3oB,OAAOiwC,OAAO,sBAAkBV,IAC7CnvC,KAAKwhB,IAAMA,CACf,CACA,QAAAsuB,GACI,OAAO9vC,KAAKuoB,KAChB,CACA,WAAAwnB,CAAYC,GACR,MAAMC,EAAW,sBAAkBjwC,KAAKuoB,OACxCynB,EAAQC,GACRjwC,KAAKuoB,MAAQ3oB,OAAOiwC,OAAOI,EAC/B,CACA,WAAAC,CAAYC,GACR,OAAOnwC,KAAKuoB,MAAM6mB,SAASe,EAC/B,CACA,oBAAAC,GACI,OAAOpwC,KAAKuoB,MAAM6mB,SAASxuC,MAC/B,CACA,UAAAyvC,GACIrwC,KAAK2vC,kCAAkCt9B,QACvCrS,KAAK4vC,6BAA6Bv9B,QAClCrS,KAAKuoB,MAAQ3oB,OAAOiwC,OAAO,sBAAkBV,GACjD,CACA,eAAAmB,CAAgBC,GACZ,OAAOvwC,KAAKuoB,MAAM8mB,cAAcjzB,KAAMo0B,GAAiBA,EAAaD,iBAAmBA,EAC3F,CACA,kBAAAE,CAAmBF,EAAgBnoB,GAC/BpoB,KAAK+vC,YAAaW,IACd,MAAMF,EAAeE,EAAWrB,cAAcjzB,KAAMo0B,GAAiBA,EAAaD,iBAAmBA,GAChGC,EAIL5wC,OAAO+wC,OAAOH,EAAcpoB,GAHxBzZ,QAAQC,KAAK,wBAAwB2hC,mCAK7C,IAAAK,6BAA4BL,EAChC,CACA,eAAAM,CAAgBL,GACZ,GAAIxwC,KAAKswC,gBAAgBE,EAAaD,gBAClC,MAAM,IAAInyC,MAAM,wBAAwBoyC,EAAaD,iCAEzDvwC,KAAK+vC,YAAaxnB,IACd,MAAMuoB,EAAkB,sBAAkBN,GAC1C,GAAIM,EAAgBC,mBAAmBtB,UACnC,aAAcqB,EAAgBC,mBAAmBtB,YAC/C,aAAcqB,EAAgBC,mBAAmBtB,UAAW,CAC9D,MAAM91B,EAAW3Z,KAAKgxC,oBAAoBF,EAAgBC,oBAC1DD,EAAgBC,mBACXtB,SAAS91B,SAAWA,CAC7B,CACA4O,EAAM8mB,cAAc5mC,KAAKqoC,MAE7B,OAAyBN,EAAaD,eAC1C,CACA,kBAAAU,CAAmBV,GACfvwC,KAAK+vC,YAAaxnB,IACd,MAAM2oB,EAAwB3oB,EAAM8mB,cAAc/7B,OAAQk9B,GAAiBA,EAAaD,iBAAmBA,GAC3GhoB,EAAM8mB,cAAc79B,OAAO,EAAG+W,EAAM8mB,cAAczuC,UAAWswC,MAEjE,IAAAC,4BAA2BZ,EAC/B,CACA,6BAAAa,CAA8BxjB,EAAY2iB,EAAgB5pC,EAAM0qC,GAE5D,KADuB,IAAAC,+BAA8B1jB,GAEjD,OAE4B5tB,KAAKuxC,+BAA+B3jB,EAAY,CAC5EjnB,KAAMA,EACN4pC,mBAEwB3vC,OAAS,EACjC+N,QAAQwM,MAAM,wCAAyCxU,EAAM,6BAA8BinB,EAAY,mBAAoB2iB,IAG/HvwC,KAAK+vC,YAAaxnB,IACTA,EAAM+mB,2BAA2B1hB,KAClCrF,EAAM+mB,2BAA2B1hB,GAAc,GAC/C,IAAkB4jB,+BAA+B5jB,GAAY,IAE7DjnB,IAAS,EAAA6oC,4BAA4BC,SACrCzvC,KAAKyxC,qCAAqClpB,EAAOqF,EAAY2iB,EAAgB5pC,EAAM0qC,GAGnFrxC,KAAK0xC,0BAA0BnpB,EAAOqF,EAAY2iB,EAAgBc,MAG1E,IAAAM,2CAA0C/jB,EAAY2iB,EAAgB5pC,GAC1E,CACA,oCAAA8qC,CAAqClpB,EAAOqF,EAAY2iB,EAAgB5pC,EAAM0qC,GAC1E,MAAMb,EAAejoB,EAAM8mB,cAAcjzB,KAAMo0B,GAAiBA,EAAaD,iBAAmBA,GAChG,IAAKC,EACD,OAEJ,MAAMoB,EAAc,CAAC,EACrBhyC,OAAO4B,KAAKgvC,EAAaqB,UAAU5wC,QAAS6wC,IACxCF,EAAYrnC,OAAOunC,IAAiB,CAChCC,SAAS,KAGjBxpB,EAAM+mB,2BAA2B1hB,GAAYnlB,KAAK,CAC9C8nC,iBACA5pC,OACAqrC,QAAQ,EACRD,SAAS,EACTE,cAAeZ,GAAiBY,eAAiB,EACjDJ,SAAUD,EACVM,OAAQ,IACD3C,EAA0B5oC,MAC1B0qC,KAGXrxC,KAAKmyC,uBAAuB5pB,EAAOqF,EAAY2iB,EACnD,CACA,yBAAAmB,CAA0BnpB,EAAOqF,EAAY2iB,EAAgBc,EAAkB9B,EAA0B,EAAAC,4BAA4BC,WAEjI,KADuB,IAAA6B,+BAA8B1jB,GAEjD,OAEJ,MAAM4iB,EAAexwC,KAAKswC,gBAAgBC,GAC1C,IAAKC,EACD,OAEJ,MAAM,mBAAEO,GAAuBP,EAC/B,IAAKO,EAAmBtB,SACpB,OAAOzvC,KAAKyxC,qCAAqClpB,EAAOqF,EAAY2iB,EAAgB,EAAAf,4BAA4BC,SAAU4B,GAE9HrxC,KAAKoyC,sCAAsCxkB,EAAY2iB,GACvDvwC,KAAKyxC,qCAAqClpB,EAAOqF,EAAY2iB,EAAgB,EAAAf,4BAA4BC,SAAU4B,EACvH,CACA,2CAAMe,CAAsCxkB,EAAY2iB,GACpD,MAAMj1C,GAAiB,IAAAg2C,+BAA8B1jB,GACrD,IAAKtyB,EACD,OAEJ,MAAMk1C,EAAexwC,KAAKswC,gBAAgBC,GAC1C,IAAKC,EACD,OAEJ,MAAMrV,EAAiB7/B,EAAeY,oBAAoB,EAAAm2C,oBACpD,mBAAEtB,GAAuBP,EACzB8B,EAA2B,aAAcvB,EAAmBtB,SACjDn0C,EAAeY,SAC3Bi/B,GAAmBmX,GACnBtyC,KAAKuyC,0CAA0C3kB,EAAY4iB,EAAaD,eAEjF,CACA,qCAAAiC,CAAsCjC,EAAgBr0C,EAAUu2C,EAAkBC,GAC9E,MAAMC,EAAmBz2C,EAAS2kC,oBAClC,IAAI+R,GAA+B,EACnC,IAAK,MAAMC,KAAmBJ,EAAkB,CACpBv2C,EAAS42C,oBAAoB,CAAE1sC,kBAAmBysC,GAAmB,CAAEE,WAAW,MAEtGH,GAA+B,EAC/B5yC,KAAK2vC,kCACAvvC,IAAImwC,GACJrwC,IAAIyyC,EAAkBE,GAC3B7yC,KAAKgzC,mCAAmC,CACpCzC,iBACAoC,mBACAE,oBAGZ,CAIA,OAHIH,GACAA,EAAex2C,EAAUq0C,EAAgBkC,GAEtCG,EACD5yC,KAAK2vC,kCACFvvC,IAAImwC,GACJnwC,IAAIuyC,QACP30C,CACV,CACA,yCAAAu0C,CAA0C3kB,EAAY2iB,GAClD,MAAMC,EAAexwC,KAAKswC,gBAAgBC,GAC1C,IAAKC,EACD,OAECxwC,KAAK2vC,kCAAkCtsC,IAAIktC,IAC5CvwC,KAAK2vC,kCAAkCzvC,IAAIqwC,EAAgB,IAAIxgC,KAEnE,MAAM,mBAAEghC,GAAuBP,EAC/B,IAAKO,EAAmBtB,SACpB,OAEJ,MAAMgD,EAAmBzyC,KAAKgxC,oBAAoBD,GAE5CrV,GADiB,IAAA4V,+BAA8B1jB,GAChB1xB,SACrC,OAAO8D,KAAKwyC,sCAAsCjC,EAAgB7U,EAAe+W,EAAkB,KACvG,CACA,6CAAAQ,CAA8CrlB,EAAY2iB,GACtD,MAAMC,EAAexwC,KAAKswC,gBAAgBC,GAC1C,IAAKC,EACD,OAECxwC,KAAK2vC,kCAAkCtsC,IAAIktC,IAC5CvwC,KAAK2vC,kCAAkCzvC,IAAIqwC,EAAgB,IAAIxgC,KAEnE,MAAM,mBAAEghC,GAAuBP,EAC/B,IAAKO,EAAmBtB,SACpB,OAEJ,MAAMgD,EAAmBzyC,KAAKgxC,oBAAoBD,GAE5CrV,GADiB,IAAA4V,+BAA8B1jB,GAChB1xB,SACrC8D,KAAKwyC,sCAAsCjC,EAAgB7U,EAAe+W,EAAkB,CAAC/W,EAAe6U,EAAgBkC,KACvG/W,EAAcxG,cACtBj0B,QAAQ,CAAC0xC,EAAkBrqC,KAChC,IAAK,MAAMuqC,KAAmBJ,EAAkB,CACpB/W,EAAcoX,oBAAoB,CAAE1sC,kBAAmBysC,EAAiBK,WAAY5qC,GAAS,CAAEyqC,WAAW,EAAMI,gBAAgB,MAEpJnzC,KAAK2vC,kCACAvvC,IAAImwC,GACJrwC,IAAIyyC,EAAkBE,GAC3B7yC,KAAKgzC,mCAAmC,CACpCzC,iBACAoC,mBACAE,oBAGZ,KAGZ,CACA,mBAAA7B,CAAoBD,GAChB,MAAMqC,EAAerC,EAAmBtB,SACxC,IAAIgD,EACJ,GAAIW,EAAaz5B,SACb84B,EAAmBW,EACdz5B,cAEJ,IAAK84B,GACNW,EAAan7B,SAAU,CACvB,MAAMA,EAAWm7B,EACZn7B,SAELw6B,EADe,EAAAzgB,MAAMxM,UAAUvN,GACL0B,QAC9B,CACA,OAAO84B,CACX,CACA,6BAAAY,CAA8BlvC,EAASosC,GACnC,MAAMpwC,EAAMH,KAAKszC,gBAAgB,CAC7B/C,iBACAoC,iBAAkBxuC,IAEtB,OAAOnE,KAAK4vC,6BAA6BxvC,IAAID,EACjD,CACA,qCAAAozC,CAAsC3lB,EAAY2iB,GAC9C,MAAMj1C,GAAiB,IAAAg2C,+BAA8B1jB,GACrD,IAAKtyB,EACD,OAEJ,MACMq3C,EADgBr3C,EAAeY,SACE2kC,oBACvC,OAAO7gC,KAAKqzC,8BAA8BV,EAAkBpC,EAChE,CACA,oCAAAiD,CAAqC5lB,EAAY2iB,GAC7C,MAAMj1C,GAAiB,IAAAg2C,+BAA8B1jB,GACrD,IAAKtyB,EACD,OAEJ,IAAK0E,KAAK2vC,kCAAkCtsC,IAAIktC,GAC5C,OAEJ,MACM3P,EADgBtlC,EAAeY,SACA2kC,oBAErC,OAD4B7gC,KAAK2vC,kCAAkCvvC,IAAImwC,GAC5CnwC,IAAIwgC,EACnC,CACA,uCAAA6S,CAAwC7lB,EAAY2iB,GAEhD,IADqBvwC,KAAKswC,gBAAgBC,GAEtC,MAAO,GAEXvwC,KAAKizC,8CAA8CrlB,EAAY2iB,GAC/D,MAAM,SAAEr0C,IAAa,IAAAo1C,+BAA8B1jB,GAC7CjU,EAAWzd,EAASg5B,cACpBwe,EAA8C1zC,KAAK2vC,kCAAkCvvC,IAAImwC,GAC/F,OAAO52B,EAAStR,IAAKlE,GACVuvC,EAA4CtzC,IAAI+D,GAE/D,CACA,yCAAAwvC,CAA0C/lB,EAAYgmB,GAClD,MAAMC,EAAyB,GAwC/B,OAvCA7zC,KAAK+vC,YAAaxnB,IACd,IAAKA,EAAM+mB,2BAA2B1hB,GAClC,OAEJ,MAAMkmB,EAAyBvrB,EAAM+mB,2BAA2B1hB,GAChE,IAAImmB,GAA8B,EAClC,IAAKH,GACDh0C,OAAOwZ,OAAOw6B,GAAW3mB,MAAOhtB,QAAoBjC,IAAViC,GAC1C4zC,EAAuBprC,QAAQqrC,UACxBvrB,EAAM+mB,2BAA2B1hB,OAEvC,CACD,MAAM,eAAE2iB,EAAc,KAAE5pC,GAASitC,EACjCrrB,EAAM+mB,2BAA2B1hB,GAC7BkmB,EAAuBxgC,OAAQ0gC,IAC3B,MAAMC,EAAgB1D,GAClB5pC,GACAqtC,EAAezD,iBAAmBA,GAClCyD,EAAertC,OAASA,GACvB4pC,IACI5pC,GACDqtC,EAAezD,iBAAmBA,IACpCA,GAAkB5pC,GAAQqtC,EAAertC,OAASA,EAOxD,OANIstC,IACAJ,EAAuBprC,KAAKurC,GACxBA,EAAehC,SACf+B,GAA8B,KAG9BE,IAE4C,IAAxD1rB,EAAM+mB,2BAA2B1hB,GAAYhtB,cACtC2nB,EAAM+mB,2BAA2B1hB,GAEnCmmB,IACLxrB,EAAM+mB,2BAA2B1hB,GAAY,GAAGokB,QAAS,EAEjE,IAEG6B,CACX,CACA,iCAAAK,CAAkCtmB,EAAYgmB,GAC1C,MAAMC,EAAyB7zC,KAAK2zC,0CAA0C/lB,EAAYgmB,GAC1FC,EAAuB5yC,QAAS+yC,KAC5B,IAAAG,0CAAyCvmB,EAAYomB,EAAezD,eAAgByD,EAAertC,QAEvG,MAAMytC,EAA2Bp0C,KAAKuxC,+BAA+B3jB,GAKrE,OAJIwmB,EAAyBxzC,OAAS,GAClCwzC,EAAyB,GAAGpC,SAC5B,IAAAL,2CAA0C/jB,EAAYwmB,EAAyB,GAAG7D,eAAgB6D,EAAyB,GAAGztC,MAE3HktC,CACX,CACA,gCAAAQ,CAAiCzmB,EAAYgmB,EAAWU,GACpD,MAAMT,EAAyB7zC,KAAK2zC,0CAA0C/lB,EAAYgmB,GAM1F,OALKU,GACDT,EAAuB5yC,QAAQ,EAAGsvC,iBAAgB5pC,YAC9C,IAAAwtC,0CAAyCvmB,EAAY2iB,EAAgB5pC,KAGtEktC,CACX,CACA,kCAAAb,EAAmC,eAAEzC,EAAc,iBAAEoC,EAAgB,gBAAEE,IACnE,MAAM1yC,EAAMH,KAAKszC,gBAAgB,CAAE/C,iBAAgBoC,qBACnD,IAAK3yC,KAAK4vC,6BAA6BvsC,IAAIlD,GAEvC,YADAH,KAAK4vC,6BAA6B1vC,IAAIC,EAAK,CAAC0yC,IAGhD,MAAM0B,EAAgBv0C,KAAK4vC,6BAA6BxvC,IAAID,GACtDq0C,EAAY91C,MAAM6D,KAAK,IAAI63B,IAAI,IAAIma,EAAe1B,KACxD7yC,KAAK4vC,6BAA6B1vC,IAAIC,EAAKq0C,EAC/C,CACA,sBAAArC,CAAuB5pB,EAAOqF,EAAY2iB,GACtC,MAAMr0C,EAAWqsB,EAAM+mB,2BAA2B1hB,GAC7C1xB,GAGLA,EAAS+E,QAAShB,IACdA,EAAM+xC,OAAS/xC,EAAMswC,iBAAmBA,GAEhD,CACA,qBAAAkE,CAAsB7mB,EAAY2iB,GAC9BvwC,KAAK+vC,YAAaxnB,IACd,MAAMrsB,EAAWqsB,EAAM+mB,2BAA2B1hB,GAC7C1xB,GAGLA,EAAS+E,QAAShB,IACdA,EAAM+xC,OAAS/xC,EAAMswC,iBAAmBA,OAGhD,IAAAoB,2CAA0C/jB,EAAY2iB,EAC1D,CACA,qBAAAmE,CAAsB9mB,GAClB,IAAK5tB,KAAKuoB,MAAM+mB,2BAA2B1hB,GACvC,OAEJ,MAAM+mB,EAAe30C,KAAKuoB,MAAM+mB,2BAA2B1hB,GAAYxR,KAAMw4B,GAAWA,EAAO5C,QAC/F,OAAK2C,EAGE30C,KAAKswC,gBAAgBqE,EAAapE,qBAHzC,CAIJ,CACA,8BAAAgB,CAA+B3jB,EAAYgmB,EAAY,CAAC,GACpD,MAAMiB,EAA0B70C,KAAKuoB,MAAM+mB,2BAA2B1hB,GACtE,OAAKinB,EAGAjB,EAAUjtC,MAASitC,EAAUrD,eAG3BsE,EAAwBvhC,OAAQ0gC,IACnC,MAAMc,GAAYlB,EAAUjtC,MACtBqtC,EAAertC,OAASitC,EAAUjtC,KAElCouC,GAAUnB,EAAUrD,gBACpByD,EAAezD,iBAAmBqD,EAAUrD,eAElD,OAAOuE,GAAaC,IATbF,EAHA,EAcf,CACA,6BAAAG,CAA8BpnB,EAAYgmB,GACtC,OAAO5zC,KAAKuxC,+BAA+B3jB,EAAYgmB,GAAW,EACtE,CACA,uCAAAqB,CAAwCrnB,EAAYgmB,GAChD,MAAMsB,EAAyBl1C,KAAKg1C,8BAA8BpnB,EAAYgmB,GAC9E,OAAOsB,GAAwBnD,OACnC,CACA,uCAAAoD,CAAwCvnB,EAAYgmB,EAAW7B,GAC3D/xC,KAAK+vC,YAAaxnB,IACd,MAAMssB,EAA0B70C,KAAKuxC,+BAA+B3jB,EAAYgmB,GAC3EiB,GAGLA,EAAwB5zC,QAAS+yC,IAC7BA,EAAejC,QAAUA,EACzBnyC,OAAO+pB,QAAQqqB,EAAenC,UAAU5wC,QAAQ,EAAE6wC,EAAcsD,MAC5DA,EAAQrD,QAAUA,SAI9B,IAAAJ,2CAA0C/jB,EAAYgmB,EAAUrD,eAAgBqD,EAAUjtC,KAC9F,CACA,WAAA0uC,CAAYjG,EAAUe,GAClBnwC,KAAK+vC,YAAaxnB,IACVA,EAAM6mB,SAASe,IACfxhC,QAAQC,KAAK,+CAEjB2Z,EAAM6mB,SAASe,GAAY,sBAAkBf,IAErD,CACA,cAAAkG,CAAerD,GACXjyC,KAAK+vC,YAAaxnB,WACPA,EAAM6mB,SAAS6C,IAE9B,CACA,sBAAAsD,CAAuB57B,GACnB,OAAOA,EACFtR,IAAKlE,GAAYA,EAAQzD,OAAOzD,KAAK0kB,MAAuB,IAAjBxd,EAAQvD,UACnDwrB,KAAK,IACd,CACA,yCAAAopB,GACI,OAAO51C,OAAO+pB,QAAQ3pB,KAAKuoB,MAAM+mB,4BAA4BjnC,IAAI,EAAEulB,EAAY6nB,MAAqB,CAChG7nB,aACA6nB,oBAER,CACA,8CAAAC,CAA+CnF,GAC3C,MAAMtT,EAAS,GAOf,OANAr9B,OAAO+pB,QAAQ3pB,KAAKuoB,MAAM+mB,4BAA4BruC,QAAQ,EAAE2sB,EAAY+nB,MACxE,MAAMC,EAAeD,EAAariC,OAAQ0gC,GAAmBA,EAAezD,iBAAmBA,GAC3FqF,EAAah1C,OAAS,GACtBq8B,EAAOx0B,KAAK,CAAEmlB,aAAY6nB,gBAAiBG,MAG5C3Y,CACX,CACA,eAAAqW,EAAgB,eAAE/C,EAAc,iBAAEoC,IAC9B,MAAO,GAAGpC,KAAkBoC,GAChC,GAgCiE,U,+EC5frE,SAAS,EAAsB/kB,GAC3B,OAAO,OAAuBA,EAClC,C,uOCmBA,SAASioB,EAAqBjoB,EAAY2iB,EAAgBuB,GACtD,MAAM2D,GAAkB,QAA+B7nB,EAAY,CAC/D2iB,mBAEJ,IAAKkF,GAA8C,IAA3BA,EAAgB70C,OACpC,OAAO,KAEX,MAAMozC,EAAiByB,EAAgB,IACjC,cAAExD,GAAkB+B,EACpB5E,GAAW,OAAa6C,GAC9B,IAAI6D,EAAa1G,EAAS0C,GAC1B,IAAKgE,EAAY,CACb,GAA4B,iBAAjBhE,EAEP,OADAnjC,QAAQC,KAAK,qCAAqCkjC,KAC3C,KAEXgE,EAAa1G,EAAS0C,GAAgB,CAAC,EAAG,EAAG,EAAG,EACpD,CACA,OAAOgE,CACX,CACA,SAASC,EAAqBnoB,EAAY2iB,EAAgBuB,EAAc11C,GACpE,MAAM45C,EAAiBH,EAAqBjoB,EAAY2iB,EAAgBuB,GACxE,IAAK,IAAItoC,EAAI,EAAGA,EAAIpN,EAAMwE,OAAQ4I,IAC9BwsC,EAAexsC,GAAKpN,EAAMoN,IAE9B,IAAAmoC,2CAA0C/jB,EAAY2iB,EAC1D,C,sFChDO,SAASgB,EAA+B3jB,EAAYgmB,EAAY,CAAC,GAEpE,OADiC,KACDrC,+BAA+B3jB,EAAYgmB,EAC/E,CACO,SAASoB,EAA8BpnB,EAAYgmB,GACtD,MAAMqC,EAA2B,KACjC,IAAKrC,EAAUrD,iBAAmBqD,EAAUjtC,KACxC,MAAM,IAAIvI,MAAM,+GAEpB,MAAMq3C,EAAkBQ,EAAyB1E,+BAA+B3jB,EAAYgmB,GAC5F,OAAO6B,IAAkB,EAC7B,C,kSCyBA,SAASS,EAAwB3F,GAC7B,MAAMC,GAAe,OAAgBD,GACrC,IAAKC,EACD,MAAM,IAAIpyC,MAAM,mCAAmCmyC,KAEvD,MAAM,SAAEsB,GAAarB,EAErB,OAD6B5wC,OAAO4B,KAAKqwC,GAAUv+B,OAAQw+B,GAAiBD,EAASC,GAAcqE,QACvE9tC,IAAKypC,GAAiB3U,SAAS2U,GAC/D,C,8HCrCA,MAAMsE,EAAY,CACd,CAAC,EAAA5G,4BAA4BC,UAAW,KACxC,CAAC,EAAAD,4BAA4B6G,SAAU,IACvC,CAAC,EAAA7G,4BAA4B8G,SAAU,MAErCC,EAAwB,IAAIxmC,IAC3B,SAASymC,EAA+Bt6C,EAAUq0C,EAAgBkG,GACrE,MAAMC,EAAiBN,EAAUK,GAAoBE,kBAAkBz6C,GACnEw6C,GAIR,SAAiCnG,EAAgBkG,EAAoBC,GAC5DH,EAAsBlzC,IAAIktC,IAC3BgG,EAAsBr2C,IAAIqwC,EAAgB,IAAIxgC,KAElD,MAAM6mC,EAAcL,EAAsBn2C,IAAImwC,GAC1CqG,EAAYvzC,IAAIozC,IAOxB,SAAoClG,EAAgBkG,GAChD,MAAMG,EAAcL,EAAsBn2C,IAAImwC,GAC9C,IAAKqG,EACD,OAEJ,MAAMpsB,EAAWosB,EAAYx2C,IAAIq2C,GACjC,IAAKjsB,EACD,OAEJ,EAAA8I,YAAY9J,oBAAoB,EAAA2G,OAAO0mB,2BAA4BrsB,GACnEosB,EAAYpzC,OAAOizC,EACvB,CAjBQK,CAA2BvG,EAAgBkG,GAE/C,MAAMjsB,EA0BV,SAA6C+lB,EAAgBkG,EAAoBC,GAC7E,MAAMK,GAAmB,OAAUC,IAC/B,MAAMC,EAAsBD,EAAMvjB,QAAQ8c,eACpCC,GAAe,OAAgByG,GACjCA,IAAwB1G,GACtBC,GAAcO,qBAAqB0F,KACrCC,EAAenG,IACf,IAAAK,6BAA4BL,KAEjC,KACH,OAASyG,IACLD,EAAiBC,EACpB,CACL,CAvCqBE,CAAoC3G,EAAgBkG,EAAoBC,GACzF,EAAApjB,YAAYnK,iBAAiB,EAAAgH,OAAO0mB,2BAA4BrsB,GAChEosB,EAAY12C,IAAIu2C,EAAoBjsB,EACxC,CAdQ2sB,CAAwB5G,EAAgBkG,EAAoBC,EAEpE,C,6YCnBA,IAAIU,EAAe,CAAC,EAIpB,S,sNCcA,MAAM,sBAAEhU,GAA0B,YAClC,MAAMiU,UAA0B,YACnBr3C,KAAKs3C,SAAW,eAAiB,CAC1C,WAAA73C,CAAY83C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCzsC,cAAe,CACX0sC,2BAA2B,EAC3BC,aAAcC,KAGlBC,MAAMN,EAAWC,GACjBx3C,KAAK83C,gBAAkB,CAACjqB,EAASkqB,EAAYC,EAAcC,KACvD,MAAM38C,GAAiB,IAAAm+B,mBAAkB5L,IACnC,SAAE3xB,GAAaZ,GACf,KAAEmQ,GAASssC,GACX,OAAE/qC,GAAWvB,EAAKysC,QACxB,IAAIC,EAAej8C,EAASk8C,cAAcprC,EAAO,IAC7CqrC,EAAen8C,EAASk8C,cAAcprC,EAAO,IAC7CsrC,EAAO,CACP58C,MAAO,CACH4B,EAAG66C,EAAa,GAChB36C,EAAG26C,EAAa,IAEpB5nC,IAAK,CACDjT,EAAG+6C,EAAa,GAChB76C,EAAG66C,EAAa,KAGpBE,EAAkB,kBAA4B,CAACD,EAAK58C,MAAM4B,EAAGg7C,EAAK58C,MAAM8B,GAAI,CAAC86C,EAAK/nC,IAAIjT,EAAGg7C,EAAK/nC,IAAI/S,GAAI,CAACw6C,EAAa,GAAIA,EAAa,KACzI,OAAIO,GAAmBN,IAGvBE,EAAej8C,EAASk8C,cAAcprC,EAAO,IAC7CqrC,EAAen8C,EAASk8C,cAAcprC,EAAO,IAC7CsrC,EAAO,CACH58C,MAAO,CACH4B,EAAG66C,EAAa,GAChB36C,EAAG26C,EAAa,IAEpB5nC,IAAK,CACDjT,EAAG+6C,EAAa,GAChB76C,EAAG66C,EAAa,KAGxBE,EAAkB,kBAA4B,CAACD,EAAK58C,MAAM4B,EAAGg7C,EAAK58C,MAAM8B,GAAI,CAAC86C,EAAK/nC,IAAIjT,EAAGg7C,EAAK/nC,IAAI/S,GAAI,CAACw6C,EAAa,GAAIA,EAAa,KACjIO,GAAmBN,IAK3Bj4C,KAAKw4C,qBAAuB,CAACC,EAAKV,KAC9B,MAAMtoB,EAAcgpB,EAAIhlB,QAClB,QAAE5F,GAAY4B,EACpBsoB,EAAWW,aAAc,EACzB,MAAMC,GAAsB,IAAAC,gCAA+B/qB,EAAS7tB,KAAK64C,eACzE74C,KAAK84C,SAAW,CACZf,aACAY,sBACAI,eAAe,GAEnB/4C,KAAKg5C,gBAAgBnrB,GACrB,MAAMvyB,GAAiB,IAAAm+B,mBAAkB5L,IACnC,gBAAEzV,GAAoB9c,GAC5B,OAAsCq9C,IACtC,IAAAM,mBAAkBprB,GAClB4qB,EAAIS,kBAERl5C,KAAKm5C,uBAAyB,CAACV,EAAKV,EAAYqB,KAC5C,MAAM3pB,EAAcgpB,EAAIhlB,QAClB,QAAE5F,GAAY4B,EACdhkB,EAAOssC,EAAWtsC,KACxBssC,EAAWW,aAAc,EACzB,IACIW,EADAN,GAAgB,EAEhBK,EAAOE,cACPP,GAAgB,EAGhBM,EAAc5tC,EAAKysC,QAAQlrC,OAAO+D,UAAW9D,GAAMA,IAAMmsC,GAE7D,MAAMT,GAAsB,IAAAC,gCAA+B/qB,EAAS7tB,KAAK64C,gBACzE,IAAAI,mBAAkBprB,GAClB7tB,KAAK84C,SAAW,CACZf,aACAY,sBACAU,cACAN,iBAEJ/4C,KAAKg5C,gBAAgBnrB,GACrB,MAAMvyB,GAAiB,IAAAm+B,mBAAkB5L,IACnC,gBAAEzV,GAAoB9c,GAC5B,OAAsCq9C,GACtCF,EAAIS,kBAERl5C,KAAKu5C,aAAgBd,IACjB,MAAMhpB,EAAcgpB,EAAIhlB,QAClB,QAAE5F,GAAY4B,GACd,WAAEsoB,EAAU,oBAAEY,EAAmB,cAAEa,EAAa,SAAEC,GAAaz5C,KAAK84C,UACpE,KAAErtC,GAASssC,EACjB,GAAIyB,IAAkBC,EAClB,OAEJz5C,KAAK05C,eACLjuC,EAAKysC,QAAQyB,kBAAoB,KACjC35C,KAAK45C,kBAAkB/rB,GACvB7tB,KAAK65C,gBAAgBhsB,IACrB,IAAAisB,oBAAmBjsB,GACnB,MAAM,gBAAEzV,IAAoB,IAAAqhB,mBAAkB5L,GAC9C,QAAkC7vB,IAA9BgC,KAAK84C,SAASO,YAA2B,CACzC,MAAM,OAAErsC,GAAWvB,EAAKysC,QAClB6B,EAAyB,cAAc/sC,EAAO,GAAIA,EAAO,IAE/D,GADgC,cAAcA,EAAO,GAAIA,EAAO,IAClC+sC,EAAwB,CAClD,MAAMC,EAAW,CAAC,IAAIhtC,EAAO,IAAK,IAAIA,EAAO,KACvCitC,EAAkB,IAAIjtC,EAAO,IAC7BktC,EAAkB,IAAIltC,EAAO,IAC7BmtC,EAAiB,cACvB,SAASA,EAAgBH,EAAS,GAAG,GAAKA,EAAS,GAAG,GAAIA,EAAS,GAAG,GAAKA,EAAS,GAAG,IACvF,MAAMI,EAA0C,cAChD,SAASA,GAA0CD,EAAe,GAAIA,EAAe,IACrF,MAAME,EAAyB,cAE/B,IAAIC,EADJ,SAASD,EAAwBH,EAAgB,GAAKD,EAAgB,GAAIC,EAAgB,GAAKD,EAAgB,IAG3GK,EADA,SAASD,EAAwBD,GAA2C,EAChE,CAACH,EAAiBC,GAGlB,CAACA,EAAiBD,GAElCxuC,EAAKysC,QAAQlrC,OAAS,CAClBgtC,EAAS,GACTA,EAAS,GACTM,EAAU,GACVA,EAAU,GAElB,CACJ,CACIt6C,KAAKu6C,sBACLv6C,KAAKgL,cAAc0sC,4BACnB,IAAA8C,kBAAiBzC,EAAW0C,gBAEhC,OAAsC9B,GAClCa,IACA,IAAAkB,4BAA2B3C,GAE/B/3C,KAAK84C,SAAW,KAChB94C,KAAK26C,WAAY,GAErB36C,KAAK46C,kBAAqBnC,IACtBz4C,KAAK26C,WAAY,EACjB,MAAMlrB,EAAcgpB,EAAIhlB,QAClB,cAAEonB,EAAa,QAAEhtB,GAAY4B,EAC7Bn0B,GAAiB,IAAAm+B,mBAAkB5L,IACnC,SAAE3xB,GAAaZ,GACf,cAAE88C,GAAkBl8C,GACpB,WAAE67C,EAAU,oBAAEY,EAAmB,YAAEU,EAAW,cAAEG,GAAkBx5C,KAAK84C,SAC7E94C,KAAKq0B,WAAWxG,EAASkqB,EAAY,CAAEyB,kBACvC,MAAM,KAAE/tC,GAASssC,EACX/3B,EAAW66B,EAAcC,MAC/BrvC,EAAKysC,QAAQlrC,OAAOqsC,GAAe,IAAIr5B,GACvC,MAAM+6B,EAAoBtvC,EAAKysC,QAAQlrC,OAAO3E,IAAI+vC,GAC5CJ,EACe,CACbt8C,MAAO,CACH4B,EAAGy9C,EAAkB,GAAG,GACxBv9C,EAAGu9C,EAAkB,GAAG,IAE5BxqC,IAAK,CACDjT,EAAGy9C,EAAkB,GAAG,GACxBv9C,EAAGu9C,EAAkB,GAAG,KAe9BC,GAVSD,EAAkB,GAAG,GACrBA,EAAkB,GAAG,GAGrBA,EAAkB,GAAG,GACrBA,EAAkB,GAAG,GAIvB,cAAcA,EAAkB,GAAIA,EAAkB,IAC5B,GACjCv3B,EAAKw0B,EAA6Bt8C,MAAM4B,EAAI06C,EAA6BznC,IAAIjT,EAC7EmmB,EAAKu0B,EAA6Bt8C,MAAM8B,EAAIw6C,EAA6BznC,IAAI/S,EAC7EoD,EAAS3D,KAAK8nC,KAAKvhB,EAAKA,EAAKC,EAAKA,GAClCw3B,EAAUz3B,EAAK5iB,EACfs6C,EAAUz3B,EAAK7iB,EACfu6C,GAAQnD,EAA6Bt8C,MAAM4B,EAC7C06C,EAA6BznC,IAAIjT,GACjC,EACE89C,GAAQpD,EAA6Bt8C,MAAM8B,EAC7Cw6C,EAA6BznC,IAAI/S,GACjC,EACE69C,EAASF,EAAOH,EAA0BE,EAC1CI,EAASF,EAAOJ,EAA0BC,EAC1CM,EAAOJ,EAAOH,EAA0BE,EACxCM,EAAOJ,EAAOJ,EAA0BC,EAC9CxvC,EAAKysC,QAAQlrC,OAAO,GAAK9Q,EAAS4zB,cAAc,CAACurB,EAAQC,IACzD7vC,EAAKysC,QAAQlrC,OAAO,GAAK9Q,EAAS4zB,cAAc,CAACyrB,EAAMC,IACvDzD,EAAWx8C,aAAc,GACzB,OAAsCo9C,IACtC,IAAA8C,2BAA0B1D,EAAYlqB,EAAS,EAAAohB,YAAYyM,gBAC3D17C,KAAK84C,SAASW,UAAW,GAE7Bz5C,KAAK27C,oBAAuBlD,IACxBz4C,KAAK26C,WAAY,EACjB,MAAMlrB,EAAcgpB,EAAIhlB,QAClB,QAAE5F,GAAY4B,GACd,WAAEsoB,EAAU,oBAAEY,EAAmB,YAAEU,EAAW,cAAEN,EAAa,cAAES,GAAmBx5C,KAAK84C,SAC7F94C,KAAKq0B,WAAWxG,EAASkqB,EAAY,CAAEyB,kBACvC,MAAM,KAAE/tC,GAASssC,EACjB,GAAIgB,EAAe,CACf,MAAM,YAAE6C,GAAgBnsB,EAClBosB,EAAgBD,EAAYd,OAC5B,QAAEgB,GAAYrwC,EAAKysC,SACnB,cAAEoB,GAAkBwC,EAC1BxC,EAAc,IAAMuC,EAAc,GAClCvC,EAAc,IAAMuC,EAAc,GAClCvC,EAAc,IAAMuC,EAAc,GAClCC,EAAQrC,UAAW,CACvB,MACK,QAAoBz7C,IAAhBq7C,EAA2B,CAChC,MAAM,YAAEuC,GAAgBnsB,EAClBosB,EAAgBD,EAAYd,MACnBrvC,EAAKysC,QAAQlrC,OACrB/L,QAAS4L,IACZA,EAAM,IAAMgvC,EAAc,GAC1BhvC,EAAM,IAAMgvC,EAAc,GAC1BhvC,EAAM,IAAMgvC,EAAc,KAE9B9D,EAAWx8C,aAAc,CAC7B,MAEIyE,KAAK+7C,kBAAkBtD,GACvBV,EAAWx8C,aAAc,GAE7B,OAAsCo9C,GAClCZ,EAAWx8C,cACX,IAAAkgD,2BAA0B1D,EAAYlqB,EAAS,EAAAohB,YAAYyM,iBAGnE17C,KAAK+7C,kBAAqBtD,IACtB,MAAMhpB,EAAcgpB,EAAIhlB,QAClB,cAAEonB,EAAa,QAAEhtB,GAAY4B,EAC7Bn0B,GAAiB,IAAAm+B,mBAAkB5L,IACnC,SAAE3xB,GAAaZ,GACf,WAAEy8C,EAAYsB,YAAa2C,GAAsBh8C,KAAK84C,UACtD,KAAErtC,GAASssC,EACX/3B,EAAW66B,EAAcC,MACzBmB,EAA4B,CAC9B//C,EAASk8C,cAAc3sC,EAAKysC,QAAQlrC,OAAO,IAC3C9Q,EAASk8C,cAAc3sC,EAAKysC,QAAQlrC,OAAO,IAC3C9Q,EAASk8C,cAAc3sC,EAAKysC,QAAQlrC,OAAO,IAC3C9Q,EAASk8C,cAAc3sC,EAAKysC,QAAQlrC,OAAO,KAEzCkvC,EAAmB,CACrBxgD,MAAO,CACH4B,EAAG2+C,EAA0B,GAAG,GAChCz+C,EAAGy+C,EAA0B,GAAG,IAEpC1rC,IAAK,CACDjT,EAAG2+C,EAA0B,GAAG,GAChCz+C,EAAGy+C,EAA0B,GAAG,KAGlCE,EAAoB,CACtBzgD,MAAO,CACH4B,EAAG2+C,EAA0B,GAAG,GAChCz+C,EAAGy+C,EAA0B,GAAG,IAEpC1rC,IAAK,CACDjT,EAAG2+C,EAA0B,GAAG,GAChCz+C,EAAGy+C,EAA0B,GAAG,KAGlCG,EAAgB,IAAIp8B,GACpBq8B,EAAsBngD,EAASk8C,cAAcgE,GACnD,GAA0B,IAAtBJ,GAAiD,IAAtBA,EAAyB,CACpD,MACMM,EAAyBL,EADgB,IAAtBD,EAA0B,EAAI,GAEjDO,EAAgC,SAAS,cAAeF,EAAoB,GAAKC,EAAuB,GAAID,EAAoB,GAAKC,EAAuB,IAC5JE,EAA2B,SAAS,cAAeP,EAA0BD,GAAmB,GAClGM,EAAuB,GAAIL,EAA0BD,GAAmB,GACxEM,EAAuB,IAC3B,eAAeC,EAA+BA,GAC9C,eAAeC,EAA0BA,GACzC,MAAMC,EAA2B,CAC7B/gD,MAAO,CACH4B,EAAGg/C,EAAuB,GAC1B9+C,EAAG8+C,EAAuB,IAE9B/rC,IAAK,CACDjT,EAAG++C,EAAoB,GACvB7+C,EAAG6+C,EAAoB,KAG/B,GAAIr8C,KAAK08C,0CAA0CD,EAA0BN,GACzE,OAEJ,MAAMQ,EAAmBL,EACnBx/C,EAAQkD,KAAK48C,gBAAgBJ,EAA0BD,GAC7D,IAAIM,EAAcZ,EAA0B,GAAG,GAC3Ca,EAAcb,EAA0B,GAAG,GAC3Cc,EAAed,EAA0B,GAAG,GAC5Ce,EAAef,EAA0B,GAAG,GAChDY,GAAeF,EAAiB,GAChCG,GAAeH,EAAiB,GAChCI,GAAgBJ,EAAiB,GACjCK,GAAgBL,EAAiB,GACjC,MAAMM,EAAoBJ,EAAc5/C,KAAKigD,IAAIpgD,GAASggD,EAAc7/C,KAAKkgD,IAAIrgD,GAC3EsgD,EAAqBP,EAAc5/C,KAAKkgD,IAAIrgD,GAASggD,EAAc7/C,KAAKigD,IAAIpgD,GAC5EugD,EAAqBN,EAAe9/C,KAAKigD,IAAIpgD,GAASkgD,EAAe//C,KAAKkgD,IAAIrgD,GAC9EwgD,EAAsBP,EAAe9/C,KAAKkgD,IAAIrgD,GAASkgD,EAAe//C,KAAKigD,IAAIpgD,GACrF+/C,EAAcI,EAAoBN,EAAiB,GACnDG,EAAcM,EAAqBT,EAAiB,GACpDI,EAAeM,EAAqBV,EAAiB,GACrDK,EAAeM,EAAsBX,EAAiB,GACtD,MAAMY,EAAgBrhD,EAAS4zB,cAAc,CAAC+sB,EAAaC,IACrDU,EAAiBthD,EAAS4zB,cAAc,CAC1CitB,EACAC,IAEJvxC,EAAKysC,QAAQlrC,OAAOgvC,GAAqBI,EACzC3wC,EAAKysC,QAAQlrC,OAAO,GAAKuwC,EACzB9xC,EAAKysC,QAAQlrC,OAAO,GAAKwwC,CAC7B,KACK,CACD,MAAMC,EAA6C,IAAtBzB,EAA0B,EAAI,EACrD0B,EAAsB,CACxBC,gBAAiB,CACbjiD,MAAOwgD,EAAiBxgD,MACxB6U,IAAK2rC,EAAiB3rC,KAE1BqtC,iBAAkB,CACdliD,MAAOygD,EAAkBzgD,MACzB6U,IAAK4rC,EAAkB5rC,MAGzBstC,EAAqB,cAAc,cAAe,CACpDH,EAAoBC,gBAAgBptC,IAAIjT,EACxCogD,EAAoBC,gBAAgBptC,IAAI/S,GACzC,CACCkgD,EAAoBC,gBAAgBjiD,MAAM4B,EAC1CogD,EAAoBC,gBAAgBjiD,MAAM8B,IAExCsgD,EAA+B,eAAe,cAAeD,GAC7DE,EAAuB,cAAc,cAAe,CAAC1B,EAAoB,GAAIA,EAAoB,IAAK,CACxGJ,EAA0BD,GAAmB,GAC7CC,EAA0BD,GAAmB,KAE3CgC,EAAiB,YAAYD,GAC7BjhD,EAAQkD,KAAK48C,gBAAgBkB,EAA8BC,GAC3DE,EAAiChhD,KAAKigD,IAAIpgD,GAASkhD,EACnDE,EAAqB,iBAAiB,cAAe,CACvDjC,EAA0BwB,GAAsB,GAChDxB,EAA0BwB,GAAsB,IACjDK,EAA8BG,GACjC,GAAIj+C,KAAK08C,0CAA0C,CAC/ChhD,MAAO,CACH4B,EAAG++C,EAAoB,GACvB7+C,EAAG6+C,EAAoB,IAE3B9rC,IAAK,CACDjT,EAAG4gD,EAAmB,GACtB1gD,EAAG0gD,EAAmB,KAE3B,CACCxiD,MAAO,CACH4B,EAAGogD,EAAoBC,gBAAgBjiD,MAAM4B,EAC7CE,EAAGkgD,EAAoBC,gBAAgBjiD,MAAM8B,GAEjD+S,IAAK,CACDjT,EAAGogD,EAAoBC,gBAAgBptC,IAAIjT,EAC3CE,EAAGkgD,EAAoBC,gBAAgBptC,IAAI/S,KAG/C,OAGJ,IAD0B,gBAA0B,CAAC6+C,EAAoB,GAAIA,EAAoB,IAAK,CAAC6B,EAAmB,GAAIA,EAAmB,IAAK,CAAChC,EAAiBxgD,MAAM4B,EAAG4+C,EAAiBxgD,MAAM8B,GAAI,CAAC0+C,EAAiB3rC,IAAIjT,EAAG4+C,EAAiB3rC,IAAI/S,IAEtP,OAEJiO,EAAKysC,QAAQlrC,OAAOywC,GAAwBvhD,EAAS4zB,cAAcouB,GACnEzyC,EAAKysC,QAAQlrC,OAAOgvC,GAAqBI,CAC7C,GAEJp8C,KAAKm+C,OAAUtwB,IACX,GAAI7tB,KAAK26C,UAAW,CAChB36C,KAAK26C,WAAY,EACjB36C,KAAK65C,gBAAgBhsB,GACrB7tB,KAAK45C,kBAAkB/rB,IACvB,IAAAisB,oBAAmBjsB,GACnB,MAAM,WAAEkqB,EAAU,oBAAEY,EAAmB,cAAEa,GAAkBx5C,KAAK84C,UAC1D,KAAErtC,GAASssC,EAQjB,OAPAA,EAAWW,aAAc,EACzBjtC,EAAKysC,QAAQyB,kBAAoB,MACjC,OAAsChB,GAClCa,IACA,IAAAkB,4BAA2B3C,GAE/B/3C,KAAK84C,SAAW,KACTf,EAAW0C,aACtB,GAEJz6C,KAAKo+C,cAAiBvwB,IAClB,KAAMwwB,uBAAwB,EAC9BxwB,EAAQ1E,iBAAiB,EAAAgH,OAAOmuB,SAAUt+C,KAAKu5C,cAC/C1rB,EAAQ1E,iBAAiB,EAAAgH,OAAOouB,WAAYv+C,KAAK46C,mBACjD/sB,EAAQ1E,iBAAiB,EAAAgH,OAAOquB,WAAYx+C,KAAK46C,mBACjD/sB,EAAQ1E,iBAAiB,EAAAgH,OAAOsuB,YAAaz+C,KAAKu5C,cAClD1rB,EAAQ1E,iBAAiB,EAAAgH,OAAOuuB,UAAW1+C,KAAKu5C,cAChD1rB,EAAQ1E,iBAAiB,EAAAgH,OAAOwuB,UAAW3+C,KAAKu5C,cAChD1rB,EAAQ1E,iBAAiB,EAAAgH,OAAOyuB,WAAY5+C,KAAK46C,oBAErD56C,KAAK65C,gBAAmBhsB,IACpB,KAAMwwB,uBAAwB,EAC9BxwB,EAAQrE,oBAAoB,EAAA2G,OAAOmuB,SAAUt+C,KAAKu5C,cAClD1rB,EAAQrE,oBAAoB,EAAA2G,OAAOouB,WAAYv+C,KAAK46C,mBACpD/sB,EAAQrE,oBAAoB,EAAA2G,OAAOquB,WAAYx+C,KAAK46C,mBACpD/sB,EAAQrE,oBAAoB,EAAA2G,OAAOsuB,YAAaz+C,KAAKu5C,cACrD1rB,EAAQrE,oBAAoB,EAAA2G,OAAOuuB,UAAW1+C,KAAKu5C,cACnD1rB,EAAQrE,oBAAoB,EAAA2G,OAAOwuB,UAAW3+C,KAAKu5C,cACnD1rB,EAAQrE,oBAAoB,EAAA2G,OAAOyuB,WAAY5+C,KAAK46C,oBAExD56C,KAAKg5C,gBAAmBnrB,IACpB,KAAMwwB,uBAAwB,EAC9BxwB,EAAQ1E,iBAAiB,EAAAgH,OAAOmuB,SAAUt+C,KAAKu5C,cAC/C1rB,EAAQ1E,iBAAiB,EAAAgH,OAAOouB,WAAYv+C,KAAK27C,qBACjD9tB,EAAQ1E,iBAAiB,EAAAgH,OAAOsuB,YAAaz+C,KAAKu5C,cAClD1rB,EAAQ1E,iBAAiB,EAAAgH,OAAOwuB,UAAW3+C,KAAKu5C,cAChD1rB,EAAQ1E,iBAAiB,EAAAgH,OAAOyuB,WAAY5+C,KAAK27C,qBACjD9tB,EAAQ1E,iBAAiB,EAAAgH,OAAOuuB,UAAW1+C,KAAKu5C,eAEpDv5C,KAAK45C,kBAAqB/rB,IACtB,KAAMwwB,uBAAwB,EAC9BxwB,EAAQrE,oBAAoB,EAAA2G,OAAOmuB,SAAUt+C,KAAKu5C,cAClD1rB,EAAQrE,oBAAoB,EAAA2G,OAAOouB,WAAYv+C,KAAK27C,qBACpD9tB,EAAQrE,oBAAoB,EAAA2G,OAAOsuB,YAAaz+C,KAAKu5C,cACrD1rB,EAAQrE,oBAAoB,EAAA2G,OAAOwuB,UAAW3+C,KAAKu5C,cACnD1rB,EAAQrE,oBAAoB,EAAA2G,OAAOyuB,WAAY5+C,KAAK27C,qBACpD9tB,EAAQrE,oBAAoB,EAAA2G,OAAOuuB,UAAW1+C,KAAKu5C,eAEvDv5C,KAAK6+C,iBAAmB,CAACvjD,EAAgBwjD,KACrC,IAAIC,GAAe,EACnB,MAAM,SAAE7iD,GAAaZ,GACf,QAAEuyB,GAAY3xB,EACpB,IAAI8iD,GAAc,IAAAC,gBAAej/C,KAAK64C,cAAehrB,GACrD,IAAKmxB,GAAap+C,OACd,OAAOm+C,EAGX,GADAC,EAAch/C,KAAKk/C,wCAAwCrxB,EAASmxB,IAC/DA,GAAap+C,OACd,OAAOm+C,EAEX,MAAM75B,EAAWllB,KAAKm/C,YAAYjjD,GAC5Bkc,EAAkBlc,EAAS2wB,qBAC3BuyB,EAAiB,CACnBC,YAAar/C,KAAKq/C,YAClB/H,SAAUt3C,KAAK64C,cACfjrB,WAAYtyB,EAAeY,SAASiN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAIw1C,EAAYp+C,OAAQ4I,IAAK,CACzC,MAAMuuC,EAAaiH,EAAYx1C,IACzB,cAAEixC,EAAa,KAAEhvC,GAASssC,GAC1B,OAAE/qC,EAAM,kBAAE2sC,GAAsBluC,EAAKysC,QACrCoH,EAAoBtyC,EAAO3E,IAAK4E,GAAM/Q,EAASk8C,cAAcnrC,IACnEmyC,EAAe3E,cAAgBA,EAC/B,MAAM,MAAEr+C,EAAK,UAAEmjD,EAAS,SAAEC,EAAQ,OAAEC,GAAWz/C,KAAK0/C,mBAAmB,CACnE3H,aACAqH,mBAcJ,GAZK3zC,EAAKk0C,YAAYz6B,IACiB,MAAnCzZ,EAAKk0C,YAAYz6B,GAAU06B,KAQtB7H,EAAWx8C,aAChByE,KAAK6/C,+BAA+B9H,EAAY3/B,EAAiB9c,IARjEmQ,EAAKk0C,YAAYz6B,GAAY,CACzBtkB,OAAQ,KACRhE,MAAO,KACPgjD,KAAM,MAEV5/C,KAAK8/C,sBAAsB/H,EAAY3/B,EAAiB9c,KAKvDY,EAAS2wB,qBAEV,OADAle,QAAQC,KAAK,uCACNmwC,EAEX,IAAIgB,EACJ,KAAK,IAAAC,qBAAoBvF,GACrB,UAEC,IAAAwF,oBAAmBxF,IACnBz6C,KAAK84C,UACgB,OAAtBa,IACAoG,EAA2B,CAACT,EAAkB3F,KAElD,MAAMuG,EAAoBC,SAAQ,OAAiB,oBAAqB,CAAC,IACzE,GAAIJ,GAA4BG,EAAmB,CAC/C,MAAME,EAAiB,KACvB,IAAAC,aAAevB,EAAkBrE,EAAe2F,EAAgBF,EAAoBZ,EAAoBS,EAA0B,CAC9H3jD,SAER,CACA,MAAMkkD,EAAU,GAAG7F,WACb8F,EAAU,GAAG9F,WACb+F,EAAU,KAChB,IAAAC,UAAY3B,EAAkBrE,EAAe+F,EAASlB,EAAkB,GAAIA,EAAkB,GAAI,CAC9FljD,QACAojD,WACAD,YACAE,UACDa,GACH,MAAMI,EAAgB,KACtB,IAAAD,UAAY3B,EAAkBrE,EAAeiG,EAAepB,EAAkB,GAAIA,EAAkB,GAAI,CACpGljD,QACAojD,WACAD,YACAE,UACDc,GACHxB,GAAe,EACf,MAAM36C,EAAUpE,KAAK2gD,sBAAsBvB,EAAgBrH,GAC3D,IAAK3zC,EAAQiqB,WAAY,CACrB5iB,EAAKysC,QAAQ4D,QAAU,CACnBrC,UAAU,EACVH,cAAe,CAAC,EAAG,EAAG,GACtBsH,iBAAkB,CACdC,QAAS,CAAC,EAAG,EAAG,GAChB9wB,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB8wB,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAMC,EAAY/gD,KAAKgL,cAAc2sC,aAAalsC,EAAMyZ,GACxD,IAAK67B,GAAkC,IAArBA,EAAUngD,OACxB,SAEJ,IAAIogD,EACCv1C,EAAKysC,QAAQ4D,QAAQrC,WACtBuH,GAAsB,IAAAC,wBAAuB3B,GAC7C7zC,EAAKysC,QAAQ4D,QAAQxC,cACjBp9C,EAAS4zB,cAAckxB,IAE/B,MAAME,EAAkBhlD,EAASk8C,cAAc3sC,EAAKysC,QAAQ4D,QAAQxC,eAC9D6H,EAAa,IACbC,GAAc,IAAAC,mBAAqBvC,EAAkBrE,EAAe0G,EAAYJ,EAAWG,EAAiB5B,EAAmB,CAAC,EAAGl7C,IACjI9G,EAAGgkD,EAAM9jD,EAAG0V,EAAG,MAAEtW,EAAK,OAAEC,GAAWukD,EAC3C31C,EAAKysC,QAAQ4D,QAAQ8E,iBAAmB,CACpCC,QAAS3kD,EAAS4zB,cAAc,CAACwxB,EAAMpuC,IACvC6c,SAAU7zB,EAAS4zB,cAAc,CAACwxB,EAAO1kD,EAAOsW,IAChD8c,WAAY9zB,EAAS4zB,cAAc,CAACwxB,EAAMpuC,EAAMrW,IAChDikD,YAAa5kD,EAAS4zB,cAAc,CAACwxB,EAAO1kD,EAAOsW,EAAMrW,IAEjE,CACA,OAAOkiD,GAEX/+C,KAAK08C,0CAA4C,CAACR,EAAkBC,KAChE,MAAMoF,EAA8B,cACpC,SAASA,EAA6BpF,EAAkB5rC,IAAIjT,EAAI6+C,EAAkBzgD,MAAM4B,EAAG6+C,EAAkB5rC,IAAI/S,EAAI2+C,EAAkBzgD,MAAM8B,GAC7I,eAAe+jD,EAA6BA,GAC5C,MAAMC,EAA4B,CAC9B9lD,MAAO,CACH4B,EAAG6+C,EAAkBzgD,MAAM4B,EAAqC,GAAjCikD,EAA4B,GAC3D/jD,EAAG2+C,EAAkBzgD,MAAM8B,EAAqC,GAAjC+jD,EAA4B,IAE/DhxC,IAAK,CACDjT,EAAG6+C,EAAkB5rC,IAAIjT,EAAqC,GAAjCikD,EAA4B,GACzD/jD,EAAG2+C,EAAkB5rC,IAAI/S,EAAqC,GAAjC+jD,EAA4B,KAKjE,OAFkC,gBAA0B,CAACC,EAA0B9lD,MAAM4B,EAAGkkD,EAA0B9lD,MAAM8B,GAAI,CAACgkD,EAA0BjxC,IAAIjT,EAAGkkD,EAA0BjxC,IAAI/S,GAAI,CAAC0+C,EAAiBxgD,MAAM4B,EAAG4+C,EAAiBxgD,MAAM8B,GAAI,CAAC0+C,EAAiB3rC,IAAIjT,EAAG4+C,EAAiB3rC,IAAI/S,KAIhTwC,KAAK8/C,sBAAwB,CAAC/H,EAAY3/B,EAAiB9c,KACvD,MAAM,KAAEmQ,GAASssC,GACX,QAAElqB,GAAYvyB,EAAeY,SAC7BulD,EAAYh2C,EAAKysC,QAAQlrC,OAAO,GAChC00C,EAAYj2C,EAAKysC,QAAQlrC,OAAO,GAChC20C,EAAYl2C,EAAKysC,QAAQlrC,OAAO,GAChC40C,EAAYn2C,EAAKysC,QAAQlrC,OAAO,IAChC,YAAE2yC,GAAgBl0C,EAClBo2C,EAAYjiD,OAAO4B,KAAKm+C,GAC9B,IAAK,IAAIn2C,EAAI,EAAGA,EAAIq4C,EAAUjhD,OAAQ4I,IAAK,CACvC,MAAM0b,EAAW28B,EAAUr4C,GACrBhO,EAAQwE,KAAK8hD,mBAAmB58B,GACtC,IAAK1pB,EACD,SAEJ,MAAM,UAAE6nB,EAAS,WAAE3b,GAAelM,EAC5BumD,EAAS3e,EAAsB/f,EAAWo+B,GAC1CO,EAAS5e,EAAsB/f,EAAWq+B,GAC1CO,EAAS7e,EAAsB/f,EAAWs+B,GAC1CO,EAAS9e,EAAsB/f,EAAWu+B,GAC1CO,EAAW,CAACJ,EAAQC,GACpBI,EAAW,CAACH,EAAQC,IAClB1lD,MAAO6lD,EAAQzC,KAAM0C,IAAW,QAAiC9mD,EAAO2mD,IACxE3lD,MAAO+lD,EAAQ3C,KAAM4C,IAAW,QAAiChnD,EAAO4mD,GAC1EK,EAAQziD,KAAK0iD,iBAAiBjB,EAAWC,GAAaW,EACtDM,EAAQ3iD,KAAK0iD,iBAAiBf,EAAWC,GAAaW,EACtD3hD,EAAS6hD,EAAQE,EAAQF,EAAQE,EACjC/lD,EAAQ6lD,EAAQE,EAAQA,EAAQF,EAChC7C,EAAO6C,EAAQE,EAAQL,EAASE,EAChCI,EAAYH,EAAQE,EAAQH,EAASF,EAC3CtiD,KAAK6iD,gBAAgBd,EAAQC,EAAQC,EAAQC,EAAQx6C,GAC9C1H,KAAKu6C,sBAAuB,EAC5Bv6C,KAAKu6C,sBAAuB,EACnCoF,EAAYz6B,GAAY,CACpBtkB,SACAhE,QACAgjD,OACAgD,YAER,CACA,MAAMrnD,EAAcw8C,EAAWx8C,YAK/B,OAJAw8C,EAAWx8C,aAAc,EACrBA,IACA,IAAAkgD,2BAA0B1D,EAAYlqB,EAAS,EAAAohB,YAAY6T,cAExDnD,GAEX3/C,KAAK6iD,gBAAkB,CAACd,EAAQC,EAAQC,EAAQC,EAAQx6C,IAC5C,kCAA8Bq6C,EAAQr6C,IAC1C,kCAA8Bs6C,EAAQt6C,IACtC,kCAA8Bu6C,EAAQv6C,IACtC,kCAA8Bw6C,EAAQx6C,GAE9C1H,KAAK48C,gBAAkB,CAACmG,EAASC,IACtB/lD,KAAKgmD,MAAMF,EAAQ,GAAKC,EAAQ,GAAKD,EAAQ,GAAKC,EAAQ,GAAID,EAAQ,GAAKC,EAAQ,GAAKD,EAAQ,GAAKC,EAAQ,IAExHhjD,KAAK6/C,gCAAiC,OAAS7/C,KAAK8/C,sBAAuB,IAAK,CAAEoD,UAAU,GAChG,CACA,gBAAAC,CAAiB1K,GACb,MAAMhpB,EAAcgpB,EAAIhlB,QAClB,cAAEonB,EAAa,QAAEhtB,GAAY4B,EAC7BzP,EAAW66B,EAAcC,MAC/B96C,KAAK26C,WAAY,EACjB,MAAM5C,EAAa/3C,KAAKojD,iBAAiB3K,EAAK,CAC1C,IAAIz4B,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,MAER,IAAAqjC,eAActL,EAAYlqB,GAC1B,MAAM8qB,GAAsB,IAAAC,gCAA+B/qB,EAAS7tB,KAAK64C,eAazE,OAZA74C,KAAK84C,SAAW,CACZf,aACAY,sBACAU,YAAa,EACbN,eAAe,EACfS,eAAe,EACfC,UAAU,GAEdz5C,KAAKo+C,cAAcvwB,IACnB,IAAAorB,mBAAkBprB,GAClB4qB,EAAIS,kBACJ,OAAsCP,GAC/BZ,CACX,QACS/3C,KAAKsjD,QAAU,CAAC11B,EAAY21B,EAAMn/C,KACvC,MAAM9I,GAAiB,IAAAg2C,+BAA8B1jB,GACrD,IAAKtyB,EACD,OAEJ,MAAM,oBAAEwO,EAAmB,kBAAE1D,EAAiB,gBAAE6Z,EAAe,SAAEklB,EAAQ,SAAEjpC,GAAc8D,KAAKwjD,YAAYnM,EAAmB/7C,EAAgBioD,EAAK,GAAIn/C,IAC/Iq/C,EAAWC,GAAaH,GACxBI,EAAQC,GAAUH,GAClBI,EAAQC,GAAUJ,EACnB12C,EAAS,CAAC22C,EAAQC,EAAQC,EAAQC,IAClC,aAAEC,KAAiBC,GAAwB5/C,GAAW,CAAC,EACvD2zC,EAAa,CACf0C,cAAer2C,GAASq2C,eAAiB,EAAAwJ,UAAA,SACzCx4C,KAAM,CACFysC,QAAS,CACLlrC,SACA2sC,kBAAmB,KACnBmC,QAAS,CACLrC,UAAU,EACVH,cAAe,CAAC,EAAG,EAAG,GACtBsH,iBAAkB,CACdC,QAAS,CAAC,EAAG,EAAG,GAChB9wB,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB8wB,YAAa,CAAC,EAAG,EAAG,MAIhCnB,YAAa,CAAC,GAElBjH,aAAa,EACbwL,eAAe,EACf3oD,aAAa,EACb4oD,UAAU,EACVC,WAAW,EACXr9C,SAAU,CACNuwC,SAAUnS,EAAS0T,cACnB54B,kBACAnW,sBACA1D,uBACG49C,IAKX,OAFA,IAAAX,eAActL,EAAY77C,EAAS2xB,UACnC,OAAsC,CAAC3xB,EAASiN,KACzC4uC,EACR,CACH,gBAAA2K,CAAiB2B,EAAMC,GACnB,MAAM9gC,EAAK6gC,EAAK,GAAKC,EAAK,GACpB7gC,EAAK4gC,EAAK,GAAKC,EAAK,GACpB5gC,EAAK2gC,EAAK,GAAKC,EAAK,GAC1B,OAAOrnD,KAAK8nC,KAAKvhB,EAAKA,EAAKC,EAAKA,EAAKC,EAAKA,EAC9C,EAEJ,SAASk0B,EAAoBnsC,EAAMyZ,GAC/B,MAAM,YAAEy6B,EAAW,MAAErtB,GAAU7mB,GACzB,OAAE7K,EAAM,MAAEhE,EAAK,KAAEgjD,GAASD,EAAYz6B,GACtC67B,EAAY,GAIlB,OAHIzuB,GACAyuB,EAAUt4C,KAAK6pB,QAEJt0B,IAAX4C,GAGJmgD,EAAUt4C,KAAK,MAAM,wBAAoB7H,MAAWg/C,GAAQA,IAAQ,MAAM,wBAAoBhjD,MAAUgjD,KAF7FmB,CAIf,C,yOC/tBA,MAAMwD,UAAkB,IACpB,WAAA9kD,CAAY83C,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCzsC,cAAe,CACXw5C,WAAY,CACRC,mBAAoB,KACpBC,oBAAqB,IACrBC,mBAAoB,KACpBC,oBAAqB,IACrBC,wBAAyB,IACzBC,wBAAyB,KACzBC,4CAA6C,MAEjDC,gBAAiB,qBACjBC,eAAgB,qBAChBC,UAAW,GACXC,uBAAuB,EACvBC,QAAS,CACLC,SAAS,EACTC,cAAe,CACX,EAAG,CAAC,IAAK,IAAK,IAAK,MAEvBC,cAAe,IACfC,oBAAqB,EACrBC,iBAAkB,EAClBC,WAAY,KAEhBC,QAAS,CACL,CAAC,EAAAC,kBAAkBC,eAAgB,CAC/BC,OAAQ,EAAAF,kBAAkBC,cAC1BE,SAAU,CACN,CACI5lD,IAAK,WAIjB,CAAC,EAAAylD,kBAAkBI,eAAgB,CAC/BF,OAAQ,EAAAF,kBAAkBI,cAC1BD,SAAU,CACN,CACI5lD,IAAK,YAIjB,CAAC,EAAAylD,kBAAkBK,aAAc,CAC7BH,OAAQ,EAAAF,kBAAkBK,YAC1BF,SAAU,CACN,CACI5lD,IAAK,MAGb6K,cAAe,CACXk7C,2BAA2B,EAC3BC,wBAAwB,EACxBC,oBAAoB,IAG5BC,yBAA0B,CACtBP,OAAQ,EAAAF,kBAAkBK,YAC1BF,SAAU,CACN,CACI5lD,IAAK,MAGb6K,cAAe,CAAC,OAK5B6sC,MAAMN,EAAWC,GACjBx3C,KAAKsmD,cAAgB,KACrBtmD,KAAKumD,iBAAoB9N,IACrBz4C,KAAKwmD,iBAETxmD,KAAKymD,iBAAmB,KACpBzmD,KAAKwmD,iBAETxmD,KAAK0mD,kBAAqBjO,IACtBz4C,KAAKwmD,iBAETxmD,KAAK2mD,qBAAwBlO,IACzB,MAAMvX,EAAYuX,EAAIhlB,QAChB,QAAE5F,EAAO,cAAEgtB,GAAkB3Z,EAC7B5lC,GAAiB,IAAAm+B,mBAAkB5L,IACnC,SAAE3xB,GAAaZ,EACrB0E,KAAK4mD,UAAY5mD,KAAK6mD,eAAeh5B,GACrC7tB,KAAKo+C,cAAcvwB,IACnB,IAAAorB,mBAAkBprB,GAClB4qB,EAAIS,iBACJl5C,KAAK8mD,aAAaC,QAAS,EAC3B/mD,KAAK8mD,aAAaE,WAAaC,KAAKC,MACpC,MAAMrZ,EAAc,WAAWgN,EAAcp/C,QACvCsyC,EAAa7xC,EAAS4zB,cAAc,CACtC+d,EAAY,GACZA,EAAY,KAEhB7tC,KAAKsmD,cAAgB,CACjB7qD,OAAQoyC,EACRiN,MAAO,WAAW/M,IAEtB,MAAMoZ,EAAYnnD,KAAKonD,YAAcpnD,KAAKqnD,gBAAgBx5B,IAC1D,OAAuCs5B,EAAUxO,qBACjD,MAAM2O,EAAgBtnD,KAAKunD,iBAAiB15B,GAE5C,OADA7tB,KAAKwnD,4BAA4BlsD,EAAgBgsD,EAAe,EAAA1B,kBAAkB6B,qBAC3E,GAEXznD,KAAK0nD,kBAAqBjP,IACtB,GAAIz4C,KAAK2nD,OAAS,EAAAC,UAAUC,OAAQ,CAEhC,GADA7nD,KAAK8nD,aAAarP,IACbz4C,KAAKgL,cAAco6C,QAAQC,QAC5B,OAEJ,MAAM,cAAEE,EAAa,oBAAEC,EAAmB,iBAAEC,GAAqBzlD,KAAKgL,cAAco6C,SAC9E,cAAEvK,EAAa,QAAEhtB,GAAY4qB,EAAIhlB,QACjC,OAAEh4B,GAAWo/C,GACb,WAAEkN,EAAU,MAAEC,EAAK,WAAEhB,EAAU,OAAED,GAAW/mD,KAAK8mD,aACvD,GAAIC,EACA,OAEJ,MAAMhzC,EAAQ,cAActY,EAAQssD,GAC9BE,EAAOhB,KAAKC,MAAQF,EAW1B,IAVIjzC,EAAQyxC,GACPyC,EAAO1C,GAAiBxxC,EAAQ0xC,KAC7BuC,IACA/5B,OAAOi6B,aAAaF,GACpBhoD,KAAK8mD,aAAakB,MAAQ,MAEzBjB,GACD/mD,KAAKmoD,cAAct6B,KAGtB7tB,KAAK8mD,aAAakB,MAAO,CAC1B,MAAMA,EAAQ/5B,OAAOoC,WAAWrwB,KAAKooD,gBAAiB,KACtDxoD,OAAO+wC,OAAO3wC,KAAK8mD,aAAc,CAC7BE,WAAYC,KAAKC,MACjBc,QACAD,WAAYtsD,EACZoyB,WAER,CACJ,GAEJ7tB,KAAKooD,gBAAkB,KACnB,GAAIpoD,KAAK8mD,aAAaC,OAElB,YADA/mD,KAAK8mD,aAAakB,MAAQ,MAG9BhoD,KAAK8mD,aAAakB,MAAQ,KAC1B,MAAMV,EAAgBtnD,KAAKunD,iBAAiBvnD,KAAK8mD,aAAaj5B,SACxDvyB,GAAiB,IAAAm+B,mBAAkBz5B,KAAK8mD,aAAaj5B,SAC3D,IAAKvyB,EACD,OAEJ,MAAM,SAAEY,GAAaZ,EACf2pD,EAAiBjlD,KAAKgL,cAAci6C,eACpCoD,GAAe,OAAgB,CACjCf,gBACAprD,WACAosD,SAAUrD,IAEd,IAAKqC,EACD,OAEJ,MAAM3zB,EAAO3zB,KAAKq0B,WAAWizB,EAAc/W,eAAgB8X,EAAaE,0BACxEvoD,KAAK8mD,aAAa1B,QAAUplD,KAAKwnD,6BAA4B,IAAA/tB,mBAAkBz5B,KAAK8mD,aAAaj5B,SAAU,IACpGy5B,KACAe,EACH10B,QACD,EAAAiyB,kBAAkB4C,UAEzBxoD,KAAKyoD,cAAiBhQ,IAClB,MAAMvX,EAAYuX,EAAIhlB,QAChB,QAAE5F,EAAO,cAAEgtB,GAAkB3Z,EAC7B5lC,GAAiB,IAAAm+B,mBAAkB5L,IACnC,SAAE3xB,GAAaZ,EACrB0E,KAAK8nD,aAAarP,GAClB,MAAM,oBAAEE,GAAwB34C,KAAKonD,YACrC,OAAuCzO,GACvC,MAAM5kC,EAAQ,cAAc8mC,EAAcp/C,OAAQuE,KAAK8mD,aAAaiB,aAC9D,WAAErC,EAAU,iBAAED,GAAqBzlD,KAAKgL,cAAco6C,QAC5D,IAAKplD,KAAK8mD,aAAaC,QACnBE,KAAKC,MAAQlnD,KAAK8mD,aAAaE,WAAatB,GAC5C3xC,EAAQ0xC,EACR,OAMJ,GAJIzlD,KAAK8mD,aAAakB,QAClB/5B,OAAOi6B,aAAaloD,KAAK8mD,aAAakB,OACtChoD,KAAK8mD,aAAakB,MAAQ,OAEzBhoD,KAAKsmD,cAAe,CACrB,MAAMoC,EAAc1oD,KAAK8mD,aAAaiB,WAChCY,EAAazsD,EAAS4zB,cAAc,CACtC44B,EAAY,GACZA,EAAY,KAEhB1oD,KAAKsmD,cAAgB,CACjB7qD,OAAQ,WAAWitD,GACnB5N,MAAO,WAAW6N,GAE1B,CACA,MAAMC,EAAgB/N,EAAcp/C,OAC9BotD,EAAe3sD,EAAS4zB,cAAc,CACxC84B,EAAc,GACdA,EAAc,KAElB5oD,KAAKonD,WAAapnD,KAAKqnD,gBAAgBx5B,EAAS+6B,GAChD5oD,KAAK8oD,iBAAiBj7B,EAAS+6B,GAC/B,MAAMtB,EAAgBtnD,KAAKunD,iBAAiB15B,GAC5Cy5B,EAAcyB,kBAAoB,CAC9B,WAAW/oD,KAAKsmD,cAAcxL,OAC9B,WAAW+N,IAEf7oD,KAAK8mD,aAAa1B,QAAUplD,KAAKgpD,oBAAoB1tD,EAAgBgsD,GACrE,MAAM2B,EAAqB,WAAWL,GACtC5oD,KAAKsmD,cAAgB,CACjB7qD,OAAQwtD,EACRnO,MAAO,WAAW+N,IAEtB7oD,KAAK8mD,aAAaj5B,QAAUA,EAC5B7tB,KAAK8mD,aAAaE,WAAaC,KAAKC,MAAQxB,EAC5C1lD,KAAK8mD,aAAaC,QAAS,EAC3B/mD,KAAK8mD,aAAaiB,WAAakB,GAEnCjpD,KAAKu5C,aAAgBd,IACjB,MAAMvX,EAAYuX,EAAIhlB,QAChB,QAAE5F,GAAYqT,EACd5lC,GAAiB,IAAAm+B,mBAAkB5L,GACnCy5B,EAAgBtnD,KAAKunD,iBAAiB15B,GACvC7tB,KAAK8mD,aAAa1B,SAAYplD,KAAK8mD,aAAaC,QACjD/mD,KAAKgpD,oBAAoB1tD,EAAgBgsD,GAE7CtnD,KAAK05C,eACL15C,KAAK65C,gBAAgBhsB,IACrB,IAAAisB,oBAAmBjsB,GACnB7tB,KAAK8nD,aAAarP,GAClBz4C,KAAK4mD,UAAY,KACjB5mD,KAAKsmD,cAAgB,KACrBtmD,KAAKwnD,4BAA4BlsD,EAAgBgsD,EAAe,EAAA1B,kBAAkBsD,kBAC7ElpD,KAAK8mD,aAAaC,QACnB/mD,KAAKmpD,cAAct7B,IAG3B7tB,KAAKo+C,cAAiBvwB,IAClBA,EAAQ1E,iBAAiB,EAAAgH,OAAOmuB,SAAUt+C,KAAKu5C,cAC/C1rB,EAAQ1E,iBAAiB,EAAAgH,OAAOouB,WAAYv+C,KAAKyoD,eACjD56B,EAAQ1E,iBAAiB,EAAAgH,OAAOsuB,YAAaz+C,KAAKu5C,eAEtDv5C,KAAK65C,gBAAmBhsB,IACpBA,EAAQrE,oBAAoB,EAAA2G,OAAOmuB,SAAUt+C,KAAKu5C,cAClD1rB,EAAQrE,oBAAoB,EAAA2G,OAAOouB,WAAYv+C,KAAKyoD,eACpD56B,EAAQrE,oBAAoB,EAAA2G,OAAOsuB,YAAaz+C,KAAKu5C,cAE7D,CACA,aAAAiN,GACIxmD,KAAKonD,gBAAappD,EAClBgC,KAAKmoD,eACT,CACA,YAAAL,CAAarP,GACT,MAAMvX,EAAYuX,EAAIhlB,QAChB,QAAE5F,GAAYqT,GACd,cAAE2Z,GAAkB3Z,EACpBkoB,EAAevO,EAAcp/C,OACnCuE,KAAKonD,WAAapnD,KAAKqnD,gBAAgBx5B,EAASu7B,GAChDppD,KAAK8oD,iBAAiBj7B,EAASu7B,GAC1BppD,KAAKonD,aAGV,OAAuCpnD,KAAKonD,WAAWzO,oBAC3D,CACA,gBAAAmQ,CAAiBj7B,EAASu7B,GACtB,MAAM9tD,GAAiB,IAAAm+B,mBAAkB5L,IACnC,SAAE3xB,GAAaZ,GACf,cAAEw0B,GAAkB5zB,EACpBglB,EAAShlB,EAASilB,aAClB,UAAE+jC,GAAcllD,KAAKgL,cACrB04B,EAAS,gBAAgBxiB,EAAOwiB,OAAO,GAAIxiB,EAAOwiB,OAAO,GAAIxiB,EAAOwiB,OAAO,IAC3EzjB,EAAkB,gBAAgBiB,EAAOjB,gBAAgB,GAAIiB,EAAOjB,gBAAgB,GAAIiB,EAAOjB,gBAAgB,IAC/GopC,EAAY,cAClB,WAAWA,EAAW3lB,EAAQzjB,GAC9B,MAAMqpC,EAAsBx5B,EAAc,CACtCs5B,EAAa,GACbA,EAAa,KAEXG,EAAsB,cACtBC,EAAmB,cACnBC,EAAoB,cACpBC,EAAqB,cAC3B,IAAK,IAAIlgD,EAAI,EAAGA,GAAK,EAAGA,IACpB+/C,EAAoB//C,GAAK8/C,EAAoB9/C,GAAKk6B,EAAOl6B,GAAK07C,EAC9DsE,EAAiBhgD,GAAK8/C,EAAoB9/C,GAAKk6B,EAAOl6B,GAAK07C,EAC3DuE,EAAkBjgD,GAAK8/C,EAAoB9/C,GAAK6/C,EAAU7/C,GAAK07C,EAC/DwE,EAAmBlgD,GAAK8/C,EAAoB9/C,GAAK6/C,EAAU7/C,GAAK07C,EAEpE,IAAKllD,KAAKonD,WACN,OAEJ,MAAM,YAAEuC,GAAgB3pD,KAAKonD,YACvB,KAAE37C,GAASk+C,OACI3rD,IAAjByN,EAAKysC,UACLzsC,EAAKysC,QAAU,CAAC,GAEpBzsC,EAAKysC,QAAQlrC,OAAS,CAClBu8C,EACAC,EACAC,EACAC,GAEJ,MAAMzE,EAAiBjlD,KAAKgL,cAAci6C,eACpCqD,EAAWtoD,KAAKgL,cAAcw5C,WAAWS,GACG,mBAAvCqD,GAAUsB,0BACjBtB,EAASsB,yBAAyB,CAC9B5+C,cAAehL,KAAKgL,cACpB9O,aAGRuP,EAAKlQ,aAAc,CACvB,CACA,aAAAsuD,CAAch8B,EAASi8B,GACnB,IAAKj8B,EACD,OAEJ,MAAMvyB,GAAiB,IAAAm+B,mBAAkB5L,GAEzC,OADc7tB,KAAKwnD,4BAA4BlsD,EAAgB0E,KAAKunD,iBAAiB15B,GAAU,EAAA+3B,kBAAkBmE,cAAeD,EAEpI,CACA,aAAA3B,CAAct6B,EAAU7tB,KAAK8mD,aAAaj5B,SACtC,IAAKA,EACD,OAEJ7tB,KAAK05C,eACL,MAAMp+C,GAAiB,IAAAm+B,mBAAkB5L,GACpCvyB,IAGL0E,KAAKwnD,4BAA4BlsD,EAAgB0E,KAAKunD,iBAAiB15B,GAAU,EAAA+3B,kBAAkBI,eACnGhmD,KAAK8mD,aAAa1B,QAAU,KAC5BplD,KAAK8mD,aAAaC,QAAS,EAC/B,CACA,aAAAoC,CAAct7B,EAAU7tB,KAAK8mD,aAAaj5B,SACjCA,GAGLgqB,MAAMsR,cAAct7B,EACxB,CACA,WAAAm8B,CAAYn8B,EAASqkB,GACjB,IAAKrkB,EACD,OAEJ,MAAMvyB,GAAiB,IAAAm+B,mBAAkB5L,GACzC7tB,KAAK8mD,aAAa1B,QAAUplD,KAAKwnD,4BAA4BlsD,EAAgB0E,KAAKunD,iBAAiB15B,GAAU,EAAA+3B,kBAAkBK,YAAa/T,EAAOlnC,eACnJhL,KAAK8mD,aAAaC,QAAS,CAC/B,CACA,qBAAAkD,GACI,QAAwBjsD,IAApBgC,KAAKonD,WACL,OAEJ,MAAM,KAAE37C,GAASzL,KAAKonD,WAAWuC,aAC3B,SAAEztD,GAAa8D,KAAKonD,WAC1B37C,EAAKlQ,aAAc,EACnB,MAAM,aAAE2uD,GAAiBlqD,KAAKmqD,0BAA0BjuD,IAAa,CAAC,EACtE8D,KAAKonD,WAAWuC,YAAY5iD,SAASmjD,aAAeA,CACxD,CACA,gBAAArL,CAAiBvjD,EAAgBwjD,GAC7B,IAAK9+C,KAAKonD,WACN,OAEJ,MAAM,SAAElrD,GAAaZ,EAErB,IAD4B0E,KAAKonD,WAAWzO,oBACnBr/B,SAASpd,EAASiN,IACvC,OAEJ,MAAMwgD,EAAc3pD,KAAKonD,WAAWuC,YACpC,IAAqC,IAAjCA,EAAYl+C,KAAKlQ,YAAsB,CACvC,MAAM,aAAE6tD,GAAiBppD,KAAKonD,YACxB,QAAEv5B,GAAY3xB,EACpB8D,KAAK8oD,iBAAiBj7B,EAASu7B,EACnC,CACA,MAAMgB,EAAeT,EAAY5iD,SACjC,IAAKqjD,EACD,OAEJ,MAAM3P,EAAgB2P,EAAaC,eAC7B5+C,EAAOk+C,EAAYl+C,MACnB,OAAEuB,GAAWvB,EAAKysC,QAClBoH,EAAoBtyC,EAAO3E,IAAK4E,GAAM/Q,EAASk8C,cAAcnrC,IAC7Dq9C,EAAShL,EAAkB,GAC3BpsC,EAAMosC,EAAkB,GACxBlqC,EAAS,CACXnY,KAAKsP,OAAO+9C,EAAO,GAAKp3C,EAAI,IAAM,GAClCjW,KAAKsP,OAAO+9C,EAAO,GAAKp3C,EAAI,IAAM,IAEhCkxB,EAASnnC,KAAKud,IAAI8vC,EAAO,GAAKrtD,KAAKsP,OAAO+9C,EAAO,GAAKp3C,EAAI,IAAM,IAChE9W,EAAQ,OAAOguD,EAAaF,cAAcxpD,MAAM,EAAG,IAAM,CAAC,EAAG,EAAG,MACtE,IAAKxE,EAAS2wB,qBAEV,YADAle,QAAQC,KAAK,wCAIjB,IAAA27C,YAAczL,EAAkBrE,EADd,IACwCrlC,EAAQgvB,EAAQ,CACtEhoC,QACAojD,SAAuD,IAA7Cx/C,KAAKwqD,uBAAuB1Y,aAAqB,CAAC,EAAG,GAAK,OAExE,MAAM,sBAAE2Y,GAA0BzqD,KAAKgL,eAAe6R,WAAa,CAC/D4tC,sBAAuB,GAE3B,GAAIA,EAAuB,CACvB,MAAMC,EAAa,KACnB,IAAAH,YAAczL,EAAkBrE,EAAeiQ,EAAYt1C,EAAQq1C,EAAuB,CACtFruD,SAER,CACJ,EAEJmoD,EAAUjN,SAAW,O,uJClarB,MAAM,sBAAElU,EAAqB,sBAAEX,EAAqB,QAAEvI,GAAY,YAC3D,SAASywB,EAAuCrL,GACnD,MAAOgL,EAAQp3C,EAAKouC,EAAMsJ,GAAStL,EAKnC,MAAO,CAJS,CAACgC,EAAK,GAAIpuC,EAAI,IACV,CAAC03C,EAAM,GAAIN,EAAO,IACnB,CAAChJ,EAAK,GAAIgJ,EAAO,IACnB,CAACM,EAAM,GAAI13C,EAAI,IAEpC,CA0EA,MAAM23C,EAAmB,CACrB,CAAC,EAAAjF,kBAAkBkF,YAAcxD,IAC7B,MAAM,OAAEt6C,EAAM,SAAE9Q,EAAQ,sBAAE6uD,EAAqB,OAAErnB,EAAM,gBAAEzjB,GAAqBqnC,EAC9E,IAAKt6C,EACD,OAEJ,MAAMoI,EAAS,cACXpI,EAAOpM,QAAU,GACjB,SAASwU,EAAQpI,EAAO,GAAIA,EAAO,IACnC,WAAWoI,EAAQA,EAAQ,KAG3B,UAAUA,EAAQpI,EAAO,IAE7Bs6C,EAAc0D,YAAc51C,EAC5BkyC,EAAc2D,UAAY7nB,EAAsB2nB,EAAuB31C,GACvE,MAAM81C,EAAcl+C,EAAOpM,QAAU,EAAI,cAAcoM,EAAO,GAAIA,EAAO,IAAM,EAAI,EAG7Em+C,EADUR,EADU39C,EAAO3E,IAAK4E,GAAM/Q,EAASk8C,cAAcnrC,KAEpC5E,IAAK+iD,GAAWlvD,EAAS4zB,cAAcs7B,IAChEC,EAAmB,gBAAgB3nB,EAAO,GAAIA,EAAO,GAAIA,EAAO,IACtE,eAAe2nB,EAAkBA,GACjC,MAAMC,EAAwB,gBAAgBrrC,EAAgB,GAAIA,EAAgB,GAAIA,EAAgB,IACtG,eAAeqrC,EAAuBA,GACtC,MAAMjC,EAAY,cAClB,WAAWA,EAAWgC,EAAkBC,GACxC,eAAejC,EAAWA,GAC1B,MAIMkC,GAJsBjE,EAAcyB,mBACtCzB,EAAcyB,kBAAkBnoD,OAAS,EACvC0mD,EAAcyB,kBACd,CAACzB,EAAc0D,cACqB3iD,IAAKwE,GAAU,WAAWA,IAC9D2+C,EAAqBD,EAAc1sC,QAAS4sC,GAzG1D,SAAsCr2C,EAAQsuB,EAAQ2lB,EAAWjlB,GAC7D,MAAMsnB,EAAY,gBAAgBt2C,EAAO,GAAIA,EAAO,GAAIA,EAAO,IACzDlC,EAAM,cACZ,iBAAiBA,EAAKw4C,EAAWhoB,EAAQU,GACzC,MAAMkmB,EAAS,cACf,iBAAiBA,EAAQoB,EAAWhoB,GAASU,GAC7C,MAAMwmB,EAAQ,cACd,iBAAiBA,EAAOc,EAAWrC,EAAWjlB,GAC9C,MAAMkd,EAAO,cAEb,OADA,iBAAiBA,EAAMoK,EAAWrC,GAAYjlB,GACvC,CACHkmB,EACAp3C,EACAouC,EACAsJ,EAER,CAyF0Ee,CAA6BF,EAAaJ,EAAkBhC,EAAW6B,IACnIU,EAAmBJ,EAAmBnjD,IAAKyyC,GAAU1X,EAAsB2nB,EAAuBjQ,IAClGpnC,GAAY,IAAAm4C,8BAA6BD,EAAkBb,EAAsBpnC,iBACvF2jC,EAAcyB,kBAAoBwC,EAClCjE,EAAcwE,WAAaC,EAAqBZ,EAAgB,CAC5DpC,kBAAmBwC,EACnBR,wBACA3mB,OAAQ8mB,IAEZ5D,EAAc0E,oBAAsBt4C,IAG5C,SAASq4C,EAAqBZ,EAAiB,GAAI/mD,EAAU,CAAC,GAC1D,IAAK+mD,GAA4C,IAA1BA,EAAevqD,OAClC,MAAM,IAAIxC,MAAM,2DAEpB,MAAOyiD,EAASC,EAAa9wB,EAAYD,GAAYo7B,EAC/C/1C,EAAS,cACf,SAASA,EAAQyrC,EAASC,GAC1B,WAAW1rC,EAAQA,EAAQ,IAC3B,MAAM62C,EAAe,cACrB,cAAcA,EAAcl8B,EAAU8wB,GACtC,MAAMqL,EAAU,YAAYD,GAAgB,EAC5C,eAAeA,EAAcA,GAC7B,MAAME,EAAe,cACrB,cAAcA,EAAcn8B,EAAY6wB,GACxC,MAAMuL,EAAU,YAAYD,GAAgB,EAC5C,eAAeA,EAAcA,GAC7B,MAAMtiB,EAAS,cACf,WAAWA,EAAQoiB,EAAcE,GACjC,eAAetiB,EAAQA,GACvB,MAAMwiB,EAAkBjoD,EAAQggC,QAAUnnC,KAAKyQ,IAAIw+C,EAASE,GACtDE,EAxHV,SAA+BC,EAASnoB,GACpC,IAAKmoB,EAAQ3rD,QAAUwjC,GAAU,EAC7B,OAAO,KAEX,MAAMooB,EAAgBpoB,EAASA,EACzBqoB,EAAaF,EAAQlkD,IAAKwE,GAAU,CAACA,EAAM,GAAIA,EAAM,GAAIA,EAAM,KAC/DglC,EAAW,GACjB,IAAK,IAAIroC,EAAI,EAAGA,EAAIijD,EAAW7rD,OAAQ4I,IAAK,CACxC,MAAM9N,EAAQ+wD,EAAWjjD,EAAI,GACvB+G,EAAMk8C,EAAWjjD,GACjBga,EAAKjT,EAAI,GAAK7U,EAAM,GACpB+nB,EAAKlT,EAAI,GAAK7U,EAAM,GACpBgoB,EAAKnT,EAAI,GAAK7U,EAAM,GACpBgxD,EAAgBlpC,EAAKA,EAAKC,EAAKA,EAAKC,EAAKA,EAC/CmuB,EAASppC,KAAK,CAAE/M,QAAOixD,OAAQ,CAACnpC,EAAIC,EAAIC,GAAKgpC,iBACjD,CACA,OAAQ3e,IACJ,IAAKA,EACD,OAAO,EAEX,IAAK,MAAM2d,KAAae,EAAY,CAChC,MAAMjpC,EAAKuqB,EAAW,GAAK2d,EAAU,GAC/BjoC,EAAKsqB,EAAW,GAAK2d,EAAU,GAC/BhoC,EAAKqqB,EAAW,GAAK2d,EAAU,GACrC,GAAIloC,EAAKA,EAAKC,EAAKA,EAAKC,EAAKA,GAAM8oC,EAC/B,OAAO,CAEf,CACA,IAAK,MAAM,MAAE9wD,EAAK,OAAEixD,EAAM,cAAED,KAAmB7a,EAAU,CACrD,GAAsB,IAAlB6a,EAAqB,CACrB,MAAMlpC,EAAKuqB,EAAW,GAAKryC,EAAM,GAC3B+nB,EAAKsqB,EAAW,GAAKryC,EAAM,GAC3BgoB,EAAKqqB,EAAW,GAAKryC,EAAM,GACjC,GAAI8nB,EAAKA,EAAKC,EAAKA,EAAKC,EAAKA,GAAM8oC,EAC/B,OAAO,EAEX,QACJ,CACA,MAAMhpC,EAAKuqB,EAAW,GAAKryC,EAAM,GAC3B+nB,EAAKsqB,EAAW,GAAKryC,EAAM,GAC3BgoB,EAAKqqB,EAAW,GAAKryC,EAAM,GAC3BkxD,EAAMppC,EAAKmpC,EAAO,GAAKlpC,EAAKkpC,EAAO,GAAKjpC,EAAKipC,EAAO,GACpD/iB,EAAI3sC,KAAKyQ,IAAI,EAAGzQ,KAAKa,IAAI,EAAG8uD,EAAMF,IAClCG,EAAQnxD,EAAM,GAAKixD,EAAO,GAAK/iB,EAC/BkjB,EAAQpxD,EAAM,GAAKixD,EAAO,GAAK/iB,EAC/BmjB,EAAQrxD,EAAM,GAAKixD,EAAO,GAAK/iB,EAC/BojB,EAAQjf,EAAW,GAAK8e,EACxBI,EAAQlf,EAAW,GAAK+e,EACxBI,EAAQnf,EAAW,GAAKgf,EAC9B,GAAIC,EAAQA,EAAQC,EAAQA,EAAQC,EAAQA,GAASV,EACjD,OAAO,CAEf,CACA,OAAO,EAEf,CAiE4BW,CAAsB/oD,EAAQ2kD,mBAAqB,GAAIsD,GAC/E,GAAInyB,EAAQgyB,EAASE,GAAU,CAC3B,MACMgB,EAAY,CACdh4C,SACAgvB,OAHW8nB,EAIXmB,QAJWnB,KAMf,MAAO,CAACtf,EAAUN,KACd,IAAIyB,EAAanB,EAIjB,OAHKmB,GAAczB,GAAYloC,EAAQ2mD,wBACnChd,EAAatL,EAAsBr+B,EAAQ2mD,sBAAuBze,MAEjEyB,MAGDue,IAAkBve,KAGf,OAAcqf,EAAWrf,IAExC,CACA,MAAO,CAACnB,EAAUN,KACd,IAAIyB,EAAanB,EAIjB,IAHKmB,GAAczB,GAAYloC,EAAQ2mD,wBACnChd,EAAatL,EAAsBr+B,EAAQ2mD,sBAAuBze,KAEjEyB,EACD,OAAO,EAEX,GAAIue,IAAkBve,GAClB,OAAO,EAEX,MAAMuf,EAAW,cACjB,cAAcA,EAAUvf,EAAY34B,GACpC,MAAMm4C,EAAc,SAASD,EAAUzjB,GACjC2jB,EAAO,cACb,iBAAiBA,EAAMF,EAAUzjB,GAAS0jB,GAC1C,MAAME,EAAc,cACdC,EAAkB,cACxB,cAAcA,EAAiBt4C,EAAQyrC,GACvC,cAAc4M,EAAaD,EAAME,GACjC,MAAMpwD,EAAI,SAASmwD,EAAaxB,GAC1BzuD,EAAI,SAASiwD,EAAatB,GAChC,OAAQ7uD,EAAIA,GAAM4uD,EAAUA,GAAY1uD,EAAIA,GAAM4uD,EAAUA,IAAY,EAEhF,CACA,MAAMuB,EAAkB,IAAI,IAAc,SAAU,IAAaC,WAAY,IAAaC,SAAUhD,EAAkB,IAAaiD,sBAAuB,IAAa1I,QAAS,IAAa2I,oBACvLC,EAA4B,IAAI,IAAc,kBAAmB,IAAaJ,WAAY,IAAaC,SAAUhD,EAAkB,IAAaiD,sBAAuB,IAAaG,iBAAkB,IAAapxC,UAAW,IAAauoC,QAAS,IAAa8I,cAAe,IAAaH,oBAC7RI,EAAmBR,EAAgBS,iBACnCC,EAAwBL,EAA0BI,gB,uFCrMxD,MAAM,sBAAEhrB,GAA0B,YAC5BkrB,EAAsB,CACxB,CAAC,EAAA1I,kBAAkBkF,YAAcxD,IAC7B,MAAM,OAAEt6C,EAAM,SAAE9Q,EAAQ,sBAAE6uD,GAA2BzD,EACrD,IAAKt6C,EACD,OAEJ,MAAMoI,EAAS,gBAAgB,EAAG,EAAG,GACrCpI,EAAO/L,QAAS4L,IACZ,SAASuI,EAAQA,EAAQvI,KAE7B,WAAWuI,EAAQA,EAAQ,EAAIpI,EAAOpM,QACtC0mD,EAAc0D,YAAc51C,EAC5BkyC,EAAc2D,UAAY7nB,EAAsB2nB,EAAuB31C,GACvE,MAAM,UAAE1B,EAAS,eAAE83B,GAK3B,SAAgCtvC,EAAU8Q,EAAQ+9C,GAC9C,IAAIwD,EAAsBvhD,EAAO3E,IAAKyyC,GAC3B1X,EAAsB2nB,EAAuBjQ,IAExDyT,EAAsBA,EAAoBlmD,IAAKwE,GACpCA,EAAMxE,IAAKmmD,GACPvxD,KAAK0kB,MAAM6sC,KAG1B,MAAM96C,GAAY,IAAAm4C,8BAA6B0C,EAAqBxD,EAAsBpnC,kBACnFulB,EAAIC,EAAIslB,EAAIC,GAAM1hD,EACnB2hD,EAAQ,cACRC,EAAQ,cACd,cAAcD,EAAOxlB,EAAID,GACzB,cAAc0lB,EAAOF,EAAIxlB,GACzB,MAAM2lB,EAAO,YAAYF,GACnBG,EAAO,YAAYF,GACzB,eAAeD,EAAOA,GACtB,eAAeC,EAAOA,GACtB,MAAM/kB,EAAS,cACf,WAAWA,EAAQ8kB,EAAOC,GAC1B,eAAe/kB,EAAQA,GACvB,MAAM/hC,EAAYijD,EAAsBxnC,eAClC5b,EAAUojD,EAAsBgE,cAChC,gBAAE9uC,GAAoB/jB,EAASilB,YAC/B6tC,EAAM,wCAAoC,CAC5ClnD,YACAH,WACDsY,GACGurB,EAAkBoB,IACpB,MAAM5+B,EAAI,cACV,cAAcA,EAAG4+B,EAAU1D,GAC3B,MAAM+lB,EAAI,SAASjhD,EAAG2gD,GAChBO,EAAQ,SAASlhD,EAAG4gD,GACpBO,EAAIlyD,KAAKud,IAAI,SAASxM,EAAG67B,IAC/B,OAAQolB,IAAMD,GACVC,GAAKJ,EAAOG,GACZE,IAAUF,GACVE,GAASJ,EAAOE,GAChBG,GAAKH,GAEb,MAAO,CAAEt7C,YAAW83B,iBACxB,CA/C8C4jB,CAAuBlzD,EAAU8Q,EAAQ+9C,GAC/EzD,EAAcwE,WAAatgB,EAC3B8b,EAAc0E,oBAAsBt4C,IA8C5C,MAAM27C,EAAqB,IAAI,IAAc,YAAa,IAAazB,WAAY,IAAaC,SAAUS,EAAqB,IAAaR,sBAAuB,IAAa1I,QAAS,IAAa2I,oBAChMuB,EAA+B,IAAI,IAAc,qBAAsB,IAAa1B,WAAY,IAAaC,SAAUS,EAAqB,IAAaR,sBAAuB,IAAaG,iBAAkB,IAAapxC,UAAW,IAAauoC,QAAS,IAAa8I,cAAe,IAAaH,oBAChRsB,EAAmBjB,iBACdkB,EAA6BlB,gB,mJCT9D,SAASmB,EAAkCrzD,EAAU8jB,EAAUC,GAC3D,MAAMtG,EAAWzd,EAASg5B,cAC1B,IAAKvb,IAAaA,EAAS/Y,OACvB,OAEJ,MAAM6Z,EAAqBd,EAAStR,IAAKlE,IACrC,MAAM,qBAAE0D,GAAyB,EAAAiqB,SAAA,IAAa,mBAAoB3tB,GAC5DuW,EAMd,SAAkCsF,EAAUwvC,EAAsBvvC,GAC9D,MAAMQ,EAAM,cACZ,SAASA,EAAKT,EAAUwvC,GACxB,MAAM5C,EAAM,SAASnsC,EAAKR,GAC1B,OAAOhjB,KAAKud,IAAIoyC,EACpB,CAXyB6C,CAAyBzvC,EAAUnY,EAAsBoY,GAC1E,MAAO,CAAE9b,UAASuW,cAGtB,OADAD,EAAmBE,KAAK,CAACC,EAAGlF,IAAMkF,EAAEF,SAAWhF,EAAEgF,UAC1CD,EAAmB,GAAGtW,OACjC,C,+DCzEA,MAAM,QAAEkc,GAAY,EAAAqvC,UACpB,SAASC,EAAqB3iD,EAAQtF,EAAYkoD,GAAU,GACxD,IAAIC,EAAO16C,IACP26C,EAAOF,GAAWz6C,IAAW,EAC7B46C,EAAO56C,IACP66C,EAAOJ,GAAWz6C,IAAW,EAC7B86C,EAAO96C,IACP+6C,EAAON,GAAWz6C,IAAW,EACjC,MAAMg7C,EAA6B,IAAtBnjD,EAAO,IAAIpM,OACxB,IAAK,IAAI4I,EAAI,EAAGA,EAAIwD,EAAOpM,OAAQ4I,IAAK,CACpC,MAAMyD,EAAID,EAAOxD,GACjBqmD,EAAO5yD,KAAKa,IAAImP,EAAE,GAAI4iD,GACtBC,EAAO7yD,KAAKyQ,IAAIT,EAAE,GAAI6iD,GACtBC,EAAO9yD,KAAKa,IAAImP,EAAE,GAAI8iD,GACtBC,EAAO/yD,KAAKyQ,IAAIT,EAAE,GAAI+iD,GAClBG,IACAF,EAAOhzD,KAAKa,IAAImP,EAAE,IAAMgjD,EAAMA,GAC9BC,EAAOjzD,KAAKyQ,IAAIT,EAAE,IAAMijD,EAAMA,GAEtC,CAqBA,OApBIxoD,GACAmoD,EAAO5yD,KAAKyQ,IAAIkiD,EAAUloD,EAAW,GAAK2Y,EAAU,EAAGwvC,GACvDC,EAAO7yD,KAAKa,IAAI8xD,EAAUloD,EAAW,GAAK2Y,EAAU3Y,EAAW,GAAK,EAAGooD,GACvEC,EAAO9yD,KAAKyQ,IAAIkiD,EAAUloD,EAAW,GAAK2Y,EAAU,EAAG0vC,GACvDC,EAAO/yD,KAAKa,IAAI8xD,EAAUloD,EAAW,GAAK2Y,EAAU3Y,EAAW,GAAK,EAAGsoD,GACnEG,GAA8B,IAAtBzoD,EAAW9G,SACnBqvD,EAAOhzD,KAAKyQ,IAAIkiD,EAAUloD,EAAW,GAAK2Y,EAAU,EAAG4vC,GACvDC,EAAOjzD,KAAKa,IAAI8xD,EAAUloD,EAAW,GAAK2Y,EAAU3Y,EAAW,GAAK,EAAGwoD,KAGrEN,IACNC,EAAO5yD,KAAKyQ,IAAI,EAAGmiD,GACnBC,EAAO7yD,KAAKa,IAAIqX,IAAU26C,GAC1BC,EAAO9yD,KAAKyQ,IAAI,EAAGqiD,GACnBC,EAAO/yD,KAAKa,IAAIqX,IAAU66C,GACtBG,IACAF,EAAOhzD,KAAKyQ,IAAI,EAAGuiD,GACnBC,EAAOjzD,KAAKa,IAAIqX,IAAU+6C,KAG3BC,EACD,CACE,CAACN,EAAMC,GACP,CAACC,EAAMC,GACP,CAACC,EAAMC,IAET,CAAC,CAACL,EAAMC,GAAO,CAACC,EAAMC,GAAO,KACvC,CACO,SAASnE,EAA6B7+C,EAAQtF,GACjD,OAAOioD,EAAqB3iD,EAAQtF,GAAY,EACpD,C,wZCnDA,SAAS0oD,EAAa9X,EAAM+X,EAAOC,GAC/B,IAAIhoD,GAAS,EASb,GARA+nD,EAAMpvD,QAAQ,CAACsvD,EAAM/mD,KACblB,GAAS,GAGTioD,EAAK31C,GAAK09B,EAAK5iC,IACfpN,EAAQkB,KAGZlB,GAAS,EAAG,CACZ,MAAMkoD,EAAWH,EAAM/nD,GAGvB,OAFA+nD,EAAM7+C,OAAOlJ,EAAO,GACpBgoD,EAAc7nD,KAAK+nD,EAAS96C,GACxB46C,EAAc,IAAME,EAAS96C,EACtB,CACH+6C,eAAgBJ,EAChBC,gBACA3pD,KAAM,iBAGPypD,EAAaI,EAAUH,EAAOC,EACzC,CACA,MAAO,CACHG,eAAgBJ,EAChBC,gBACA3pD,KAAM,cAEd,CACO,SAAS+pD,EAAaL,GACzB,GAAoB,GAAhBA,EAAMzvD,OACN,MAAO,GAEX,MAAM0vD,EAAgB,GAChBK,EAAYN,EAAMO,QACxBN,EAAc7nD,KAAKkoD,EAAU/1C,GAC7B01C,EAAc7nD,KAAKkoD,EAAUj7C,GAC7B,MAAMunB,EAASmzB,EAAaO,EAAWN,EAAOC,GAC9C,GAAoC,GAAhCrzB,EAAOwzB,eAAe7vD,OACtB,MAAO,CACH,CACI+F,KAAMs2B,EAAOt2B,KACb2pD,cAAerzB,EAAOqzB,gBAI7B,CACD,MAAMO,EAAgBH,EAAazzB,EAAOwzB,gBAK1C,OAJAI,EAAcpoD,KAAK,CACf9B,KAAMs2B,EAAOt2B,KACb2pD,cAAerzB,EAAOqzB,gBAEnBO,CACX,CACJ,CACO,SAASC,EAA2BT,GACvC,OAAOK,EAAaL,EACxB,C,0DCvDA,MAAM,QAAEn2B,GAAY,W,kBCFb,SAAS62B,EAAiCC,EAAUC,GAAS,GAChE,MAAMjkD,EAASgkD,EAASE,YAClBb,EAAQW,EAASG,WACjBC,EAAc,IAAI1yD,MAAMsO,EAAOqkD,qBAChChhD,KAAK,GACLhI,IAAI,CAACuW,EAAGpV,IAAMwD,EAAOrB,SAASnC,GAAG9I,SAChC4wD,EAAa,IAAI5yD,MAAM2xD,EAAMkB,oBAAoBlhD,KAAK,GAAGhI,IAAI,CAACuW,EAAGpV,KACnE,MAAM+mD,EAAOF,EAAMmB,QAAY,EAAJhoD,GAAO9I,QAClC,MAAO,CAAEka,EAAG21C,EAAK,GAAI76C,EAAG66C,EAAK,MAEjC,GAAIU,EACA,MAAO,CAAEjkD,OAAQokD,EAAaf,MAAOiB,GAEzC,MAAM3jD,EAAY,GAClB,IAAK,MAAOnE,EAAGwa,KAAOotC,EAAYznC,UAAW,CACzC,MAAMrhB,EAAQqF,EAAUoD,UAAWlE,GAAUA,EAAM,KAAOmX,EAAG,IAAMnX,EAAM,KAAOmX,EAAG,IAAMnX,EAAM,KAAOmX,EAAG,IACzG,GAAI1b,GAAS,EACTgpD,EAAWjpD,IAAKiwC,IACRA,EAAK19B,IAAMpR,IACX8uC,EAAK19B,EAAItS,GAETgwC,EAAK5iC,IAAMlM,IACX8uC,EAAK5iC,EAAIpN,GAENgwC,QAGV,CACD,MAAMmZ,EAAW9jD,EAAU/M,OAC3B+M,EAAUlF,KAAKub,GACfstC,EAAWjpD,IAAKiwC,IACRA,EAAK19B,IAAMpR,IACX8uC,EAAK19B,EAAI62C,GAETnZ,EAAK5iC,IAAMlM,IACX8uC,EAAK5iC,EAAI+7C,GAENnZ,GAEf,CACJ,CAEA,MAAO,CAAEtrC,OAAQW,EAAW0iD,MADXiB,EAAWh+C,OAAQglC,GAASA,EAAK19B,IAAM09B,EAAK5iC,GAEjE,C,uIC1CA,MAAM,iBAAEswB,GAAqB,EAAA0rB,MACvBC,EAAc,KACdC,EAAc,SACdC,EAA8B,CAChC,EACA,EACA,EACA,GAEEC,EAA2B,CAC7B,MACA,OAMEC,EAAe,CACjB,EAAG,KACH,EAAG,UACH,EAAG,KACH,EAAG,KACH,EAAG,UACH,EAAG,QACH,EAAG,aACH,EAAG,SACH,EAAG,MACH,EAAG,QACH,GAAK,WAGHC,EAAS,IACTC,EAAmC,CAACz2D,EAAO08C,KAC7C,MAAM,YAAEj/B,EAAW,gBAAEi5C,GAAoB12D,EACzC,IAAIokD,EAAOsS,EAAkB,KAAOP,EACpC,MAAMQ,EAAaD,EAAkB,MAAWN,EAChD,IAAIQ,EAAWxS,EAAOoS,EAClBx1D,EAAQ,EACR61D,EAAkB,GACtB,IAAKp5C,IACCA,EAAYtS,OAASsS,EAAYq5C,4BACnC,MAAO,CAAE1S,OAAMwS,WAAU51D,QAAO21D,cAEpC,GAAIl5C,EAAYtS,OAASq/B,EAAiBusB,aACtC,MAAO,CACH3S,KAAM+R,EACNS,SAAUT,EAAcK,EACxBx1D,QACA21D,WAAYP,GAGpB,GAAI34C,EAAYq5C,4BAA6B,CACzC,IAAIE,EAAaC,EACjB,GAAI/zD,MAAMC,QAAQu5C,IAA+B,IAAnBA,EAAQt3C,QACjC4xD,EAAaC,GAAeva,OAE5B,GAAuB,mBAAZA,EAAwB,CACpC,MAAMlrC,EAASkrC,IACfsa,EAAcxlD,EAAO,GACrBylD,EAAczlD,EAAO,EACzB,CACA,IAAI0lD,EAAUz5C,EAAYq5C,4BAA4Bh/C,OAAQq/C,GAAWH,EAAY,IAAMG,EAAOC,qBAC9FJ,EAAY,IAAMG,EAAOE,qBACzBL,EAAY,IAAMG,EAAOG,qBACzBN,EAAY,IAAMG,EAAOI,qBACzBN,EAAY,IAAME,EAAOC,qBACzBH,EAAY,IAAME,EAAOE,qBACzBJ,EAAY,IAAME,EAAOG,qBACzBL,EAAY,IAAME,EAAOI,qBAC7B,IAAKL,GAAS9xD,OACV,MAAO,CAAEg/C,OAAMwS,WAAU51D,QAAO21D,cAIpC,GAFAO,EAAUA,EAAQp/C,OAAQq/C,GAAWd,EAA4Bv4C,SAASq5C,EAAOK,iBAC7ElB,EAAyBx4C,SAAS,GAAGq5C,EAAOM,2BAA2BN,EAAOO,6BAC7ER,EAAQ9xD,OACT,MAAO,CACHg/C,KAAM+R,EACNS,SAAUT,EAAcK,EACxBx1D,QACA21D,WAAYP,GAGpB,MAAMe,EAASD,EAAQ,GACjBS,EAAiBl2D,KAAKud,IAAIm4C,EAAOQ,gBACjCC,EAAiBn2D,KAAKud,IAAIm4C,EAAOS,gBAEvC,IAD4B,EAAAnP,UAAA,QAAkBkP,EAAgBC,EAvD1D,MA+DA,MAAO,CACHxT,KAAM+R,EACNS,SAAUT,EAAcK,EACxBx1D,QACA21D,WAAYP,GAVhBp1D,EAAQ,EAAI22D,EACZd,EAAkB,YAClBzS,EAAOmS,EAAaY,EAAOM,0BAA4B,UACvDb,EAAWxS,EAAOoS,CAU1B,MACS/4C,EAAYzc,QACjBA,EAAQyc,EAAYzc,OAaxB,MAXc,CACVwpC,EAAiBE,KACjBF,EAAiBqtB,KACjBrtB,EAAiBstB,MACjBttB,EAAiBI,WACjBJ,EAAiBK,WACjBL,EAAiBC,SAEX3sB,SAASL,GAAatS,QAC5B0rD,EAAkBp5C,EAAYtS,MAE3B,CACHi5C,KAAMA,GAAQyS,EAAkB,IAAIA,IAAoB,IACxDD,SAAUA,GAAYC,EAAkB,IAAIA,IAAoB,IAChE71D,QACA21D,WAAYA,GAAcE,EAAkB,IAAIA,IAAoB,K,sECrH5E,MAAM,sBAAEjvB,GAA0B,YAClC,SAASmwB,EAAqBC,EAAcnwC,EAAWowC,GACnD,MAAOnJ,EAAQp3C,GAAOsgD,EAChBxI,EAAc,iBAAiBV,EAAO,GAAKp3C,EAAI,IAAM,GAAIo3C,EAAO,GAAKp3C,EAAI,IAAM,GAAIo3C,EAAO,GAAKp3C,EAAI,IAAM,GACzGwgD,EAAc,cAAcpJ,EAAQp3C,GAAO,GAC3C,UAAEQ,EAAS,aAAE+kB,EAAY,iBAAEE,GAsCrC,SAA2BtV,EAAWowC,EAAkBD,EAAcxI,EAAa0I,GAC/E,MAAMhsD,EAAa2b,EAAUM,iBACrB/T,IAAK+jD,EAAWC,OAAQC,EAAchqB,OAAQiqB,GAAeL,EAC/Dh7B,EAAe,cACfE,EAAmB,cACzB,iBAAiBF,EAAcuyB,EAAa8I,EAAWJ,GACvD,iBAAiB/6B,EAAkBqyB,EAAa8I,GAAYJ,GAC5D,iBAAiBj7B,EAAcA,EAAco7B,GAAeH,GAC5D,iBAAiB/6B,EAAkBA,EAAkBk7B,EAAcH,GACnE,iBAAiBj7B,EAAcA,EAAck7B,GAAYD,GACzD,iBAAiB/6B,EAAkBA,EAAkBg7B,EAAWD,GAChE,MAAMK,EAAa3wB,EAAsB/f,EAAWoV,GAC9Cu7B,EAAiB5wB,EAAsB/f,EAAWsV,GAClDs7B,EAAYT,EAAanrD,IAAK4E,GAAMm2B,EAAsB/f,EAAWpW,IACrEyG,GAAY,IAAAm4C,8BAA6B,CAACkI,EAAYC,KAAmBC,GAAYvsD,GAC3F,MAAO,CAAEgM,YAAW+kB,eAAcE,mBACtC,CAtD0Du7B,CAAkB7wC,EAAWowC,EAAkBD,EAAcxI,EAAa0I,GAChI,MAAO,CACHhgD,YACAs3C,YAAaA,EACb0I,cACAj7B,aAAcA,EACdE,iBAAkBA,EAE1B,CAcA,SAASw7B,EAAgCX,EAAcnwC,EAAWnnB,GAC9D,IAAKA,EACD,MAAM,IAAIkC,MAAM,gEAEpB,MAAM8iB,EAAShlB,EAASilB,YAClBuiB,EAAS,gBAAgBxiB,EAAOwiB,OAAO,GAAIxiB,EAAOwiB,OAAO,GAAIxiB,EAAOwiB,OAAO,IAC3EzjB,EAAkB,gBAAgBiB,EAAOjB,gBAAgB,GAAIiB,EAAOjB,gBAAgB,GAAIiB,EAAOjB,gBAAgB,IAC/GopC,EAAY,cAClB,WAAWA,EAAW3lB,EAAQzjB,GAM9B,OAAOszC,EAAqBC,EAAcnwC,EALjB,CACrBzT,IAAKy5C,EACLxf,OAAQ5pB,EACR2zC,OAAQ,YAAY,cAAelwB,IAG3C,C,6DC3Ce,SAAS0wB,EAA4BvmC,EAASwmC,GACzD,MAAM/4D,GAAiB,IAAAm+B,mBAAkB5L,IACnC,kBAAEjB,EAAiB,WAAEgB,GAAetyB,EACpCg5D,GAAY,IAAAC,yBAAwB3mC,EAAYhB,GACtD,IAAK0nC,EACD,MAAO,GAEX,MAAME,EAAe,GACfC,EAAqB70D,OAAO4B,KAAK8yD,EAAUI,aACjD,IAAK,IAAIlkD,EAAI,EAAGA,EAAIikD,EAAmB7zD,OAAQ4P,IAAK,CAChD,MAAM8mC,EAAWmd,EAAmBjkD,GAC9BkkD,EAAcJ,EAAUI,YAAYpd,GAC1C,GAAKod,GAGDL,EAAY/6C,SAASo7C,EAAY/M,MAAO,CACxC,MAAM5D,EAAeuQ,EAAUK,gBAAgBrd,GAC/Ckd,EAAa/rD,KAAKs7C,EACtB,CACJ,CACA,OAAOyQ,CACX,C,2GCvBO,MAAMI,GAEN,MAAMC,EACT,WAAAp1D,CAAY2E,GACRpE,KAAK80D,eAAiB1wD,EAAQ0wD,cAClC,CACA,aAAAjL,GACIl7C,QAAQwM,MAAM,0CAClB,E,+TCPW,SAAS45C,EAAuBC,EAAWC,EAASpoD,GAC/D,OAAO,OAA2BmoD,EAAWC,EAASpoD,GAAOqoD,eACjE,C,kDCFe,SAASC,EAA2BH,EAAWC,EAASpoD,GACnE,IAAIuoD,EACJ,MAAMF,GAAkB,IAAAH,wBAAuBC,EAAWC,GAI1D,GAHID,EAAU,KAAOC,EAAQ,IAAMD,EAAU,KAAOC,EAAQ,KACxDG,EAAeJ,IAEdI,EAAc,CACf,MAAMh1C,IAAevT,EAAM,GAAKmoD,EAAU,KAAOC,EAAQ,GAAKD,EAAU,KACnEnoD,EAAM,GAAKmoD,EAAU,KAAOC,EAAQ,GAAKD,EAAU,KACpDE,EAEAE,EADAh1C,EAAa,EACE40C,EAEV50C,EAAa,EACH60C,EAGA,CACXD,EAAU,GAAK50C,GAAc60C,EAAQ,GAAKD,EAAU,IACpDA,EAAU,GAAK50C,GAAc60C,EAAQ,GAAKD,EAAU,IAGhE,CACA,MAAO,CACHnoD,MAAO,IAAIuoD,GACXF,iBAAiB,IAAAH,wBAAuBloD,EAAOuoD,GAEvD,C,kOC5BA,MAAMC,EAAwB,IACf,SAASC,EAAqBN,EAAWC,EAASpoD,GAC7D,MAAMuX,EAAO4wC,EAAU,IAAMC,EAAQ,GAAKD,EAAU,GAAKC,EAAQ,GAC3D5wC,EAAO2wC,EAAU,IAAMC,EAAQ,GAAKD,EAAU,GAAKC,EAAQ,GAC3D9yB,EAAO6yB,EAAU,IAAMC,EAAQ,GAAKD,EAAU,GAAKC,EAAQ,GAC3D7yB,EAAO4yB,EAAU,IAAMC,EAAQ,GAAKD,EAAU,GAAKC,EAAQ,GAKjE,KAJ0BpoD,EAAM,IAAMuX,EAAOixC,GACzCxoD,EAAM,IAAMwX,EAAOgxC,GACnBxoD,EAAM,IAAMs1B,EAAOkzB,GACnBxoD,EAAM,IAAMu1B,EAAOizB,GAEnB,OAAO,EAEX,MAAMr6B,GAAei6B,EAAQ,GAAKD,EAAU,KAAOnoD,EAAM,GAAKooD,EAAQ,KACjEA,EAAQ,GAAKD,EAAU,KAAOnoD,EAAM,GAAKooD,EAAQ,IAEtD,OADuBj6B,GAAe,EAAIA,GAAeA,IAChCq6B,CAC7B,C,kBCjBe,SAASN,EAAuB5rB,EAAIslB,GAC/C,GAAItlB,EAAGvoC,SAAW6tD,EAAG7tD,OACjB,MAAMxC,MAAM,mDAEhB,MAAOwoB,EAAI3I,EAAIsrB,EAAK,GAAKJ,GAClBjrB,EAAIC,EAAIo3C,EAAK,GAAK9G,EACnBjrC,EAAKtF,EAAK0I,EACVnD,EAAKtF,EAAKF,EACVyF,EAAK6xC,EAAKhsB,EAChB,OAAO/lB,EAAKA,EAAKC,EAAKA,EAAKC,EAAKA,CACpC,CCTe,SAAS60B,EAAgBpP,EAAIslB,GACxC,OAAOxxD,KAAK8nC,KAAKgwB,EAAuB5rB,EAAIslB,GAChD,CCHe,SAAS+G,EAAOC,EAAaC,GACxC,MAAO9uC,EAAI3I,GAAMw3C,GACVv3C,EAAIC,GAAMu3C,EAGjB,MAAO,CAFM,EAAIx3C,EAAK0I,EACT,EAAIzI,EAAKF,EAE1B,C,2ICJA,MAmCA,EAnC+B,CAAC4P,EAAS8nC,EAAcC,EAAgBC,KACnE,MAAM,KAAEC,EAAI,KAAEC,EAAI,QAAEpuD,GAAYkuD,EAC1Bv6D,GAAiB,IAAAm+B,mBAAkB5L,IACnC,SAAE3xB,GAAaZ,EACrB,IAAKq6D,EAAa/0D,OAGd,OAFA+0D,EAAaltD,KAAKmtD,GAClBjnD,QAAQgR,IAAI,kCACL,EAEX,MAAMq2C,EAAe95D,EAAS4zB,cAAc6lC,EAAaA,EAAa/0D,OAAS,IACzEq1D,EAAc/5D,EAAS4zB,cAAc8lC,GACrCM,EAAe,cACrB,cAAcA,EAAcD,EAAaD,GACzC,MAAMG,EAAQl5D,KAAKud,IAAI,SAAS07C,EAAcJ,IACxCM,EAAQn5D,KAAKud,IAAI,SAAS07C,EAAcH,IACxCM,EAAiBp5D,KAAKyQ,IAAIzQ,KAAKsP,MAAM4pD,EAAQxuD,EAAQ,IAAK1K,KAAKsP,MAAM6pD,EAAQzuD,EAAQ,KAC3F,GAAI0uD,EAAiB,EAAG,CACpB,MAAMC,EAAkBX,EAAaA,EAAa/0D,OAAS,GACrD21D,EAAa,UAAUD,EAAiBV,GACxCY,EAAY,cAClB,cAAcA,EAAWZ,EAAgBU,GACzC,SAASE,EAAWA,EAAU,GAAKD,EAAYC,EAAU,GAAKD,GAC9D,MAAME,EAAeF,EAAaF,EAClC,IAAK,IAAI7sD,EAAI,EAAGA,GAAK6sD,EAAgB7sD,IACjCmsD,EAAaltD,KAAK,CACd6tD,EAAgB,GAAKG,EAAeD,EAAU,GAAKhtD,EACnD8sD,EAAgB,GAAKG,EAAeD,EAAU,GAAKhtD,GAG/D,MAEImsD,EAAaltD,KAAKmtD,GAEtB,OAAOS,E,kBCnCI,SAASK,EAA4BvtB,EAAIwtB,EAAIlI,EAAImI,GAC5D,IAAI35B,GAAS,EACb,MAAM45B,EAAY1tB,EAAG,GAAKwtB,EAAG,GAAKxtB,EAAG,GAAKwtB,EAAG,GACvCG,EAAY3tB,EAAG,GAAKwtB,EAAG,GAAKxtB,EAAG,GAAKwtB,EAAG,GACvCI,EAAY5tB,EAAG,GAAKwtB,EAAG,GAAKxtB,EAAG,GAAKwtB,EAAG,GACvCK,EAAY7tB,EAAG,GAAKwtB,EAAG,GAAKxtB,EAAG,GAAKwtB,EAAG,GACvCM,EAAYxI,EAAG,GAAKmI,EAAG,GAAKnI,EAAG,GAAKmI,EAAG,GACvCM,EAAYzI,EAAG,GAAKmI,EAAG,GAAKnI,EAAG,GAAKmI,EAAG,GACvCO,EAAY1I,EAAG,GAAKmI,EAAG,GAAKnI,EAAG,GAAKmI,EAAG,GACvCQ,EAAY3I,EAAG,GAAKmI,EAAG,GAAKnI,EAAG,GAAKmI,EAAG,GAC7C,GAAIC,EAAYM,GACZJ,EAAYE,GACZH,EAAYM,GACZJ,EAAYE,EACZ,OAAO,EAEX,MAAMG,EAAS,CACXr8B,EAAYmO,EAAIwtB,EAAIlI,GACpBzzB,EAAYmO,EAAIwtB,EAAIC,GACpB57B,EAAYyzB,EAAImI,EAAIztB,GACpBnO,EAAYyzB,EAAImI,EAAID,IAExB,OAAIU,EAAO,KAAOA,EAAO,IAAMA,EAAO,KAAOA,EAAO,MAGlC,IAAdA,EAAO,IAAYC,EAAUnuB,EAAIslB,EAAIkI,IAGlB,IAAdU,EAAO,IAAYC,EAAUnuB,EAAIytB,EAAID,IAGvB,IAAdU,EAAO,IAAYC,EAAU7I,EAAItlB,EAAIytB,IAGvB,IAAdS,EAAO,IAAYC,EAAU7I,EAAIkI,EAAIC,MAR1C35B,GAAS,GAWNA,EACX,CACA,SAASjC,EAAY/tB,EAAGsqD,EAAG/hD,GACvB,MAAMgiD,GAAoBD,EAAE,GAAKtqD,EAAE,KAAOuI,EAAE,GAAK+hD,EAAE,KAAOA,EAAE,GAAKtqD,EAAE,KAAOuI,EAAE,GAAK+hD,EAAE,IACnF,OAAyB,IAArBC,EACO,EAEJA,EAAmB,EAAI,EAAI,CACtC,CACA,SAASF,EAAUrqD,EAAGsqD,EAAG/hD,GACrB,OAAI+hD,EAAE,IAAMt6D,KAAKyQ,IAAIT,EAAE,GAAIuI,EAAE,KACzB+hD,EAAE,IAAMt6D,KAAKa,IAAImP,EAAE,GAAIuI,EAAE,KACzB+hD,EAAE,IAAMt6D,KAAKyQ,IAAIT,EAAE,GAAIuI,EAAE,KACzB+hD,EAAE,IAAMt6D,KAAKa,IAAImP,EAAE,GAAIuI,EAAE,GAIjC,C,uDC9CIiiD,EAKAC,EAMAC,E,qFAMJ,SAASC,EAAoBC,GACzB,IAAK,IAAIruD,EAAI,EAAGsuD,EAAMD,EAAej3D,OAAQ4I,EAAIsuD,EAAKtuD,IAAK,CACvD,MAAMuuD,EAAeF,EAAeruD,GAC/BuuD,EAAaC,OACdD,EAAaC,KAAOH,EAAeruD,IAAMsuD,EAAM,EAAI,EAAItuD,EAAI,GAEnE,CACJ,CA+GA,SAASyuD,EAAeC,EAAgBC,GACpC,MAAMC,GAAe,OAAWF,GAC1BG,GAAe,OAAWF,GAC1BG,EAAa,SAASD,EAAcD,GACrC,YAAgB,EAAGE,KACpBH,EAAiBA,EAAez3D,QAAQ2L,WAI5C,KAF8B,OAAkB8rD,EAAgBD,KACN,OAAeC,EAAgBD,GAErF,OAAOC,EAAez3D,QAE1B,MAAM,qBAAE63D,GA1HZ,SAAsCL,EAAgBC,GAClD,MAAMI,EAAuB,GACvBC,EAAuB,GACvBC,EAA2B,IAAI1oD,IAErC,IAAI2oD,GADuB,OAAcP,EAAgBD,EAAe,IAElEP,EAAuBgB,QACvBhB,EAAuBiB,SAC7B,IAAK,IAAIpvD,EAAI,EAAGsuD,EAAMI,EAAet3D,OAAQ4I,EAAIsuD,EAAKtuD,IAAK,CACvD,MAAM2/B,EAAK+uB,EAAe1uD,GACpBqvD,GAAc,OAAcV,EAAgBhvB,GAC5C2vB,EAAc,CAChBnyD,KAAM8wD,EAAkBsB,OACxBC,YAAa7vB,EACb7a,SAAUuqC,EACJnB,EAAsBuB,OACtBvB,EAAsBwB,QAC5BC,SAAS,EACTnB,KAAM,MAEVO,EAAqB9vD,KAAKqwD,GAC1B,MAAMnC,EAAKuB,EAAe1uD,IAAMsuD,EAAM,EAAI,EAAItuD,EAAI,GAC5C4vD,GAAoB,OAAmCjB,EAAgBhvB,EAAIwtB,GAAItuD,IAAKgxD,IACtF,MAAMC,EAAsBD,EAAuB,GAC7C5K,EAAK0J,EAAekB,EAAuB,IAC3CzC,EAAKuB,EAAekB,EAAuB,IAC3CE,GAAyB,OAAqBpwB,EAAIwtB,EAAIlI,EAAImI,GAEhE,MAAO,CACH0C,sBACAE,WAAYD,EACZE,4BAJgC,yBAAiCtwB,EAAIowB,MAO7EH,EAAkBz+C,KAAK,CAAC2mC,EAAMsJ,IAAUtJ,EAAKmY,4BAA8B7O,EAAM6O,6BACjFL,EAAkBn4D,QAASy4D,IACvB,MAAM,oBAAEJ,EAAqBE,WAAYD,GAA2BG,EAC9DC,EAAkB,CACpBhzD,KAAM8wD,EAAkBmC,aACxBZ,YAAaO,EACbjrC,SAAUopC,EAAsBmC,KAChC/xD,UAAW4wD,EACXS,SAAS,EACTnB,KAAM,MAEJ8B,EAAkB,IACjBH,EACH7xD,UAAW6vD,EAAuBoC,QAClCC,QAAQ,GAERtB,IAA+Bf,EAAuBiB,SACtDe,EAAgB3B,KAAO8B,EAGvBA,EAAgB9B,KAAO2B,EAE3B,IAAIM,EAA2BxB,EAAyBr4D,IAAIk5D,GACvDW,IACDA,EAA2B,GAC3BxB,EAAyBv4D,IAAIo5D,EAAqBW,IAEtD1B,EAAqB9vD,KAAKkxD,GAC1BM,EAAyBxxD,KAAKqxD,GAC9BpB,IAA+B,GAEvC,CACA,IAAK,IAAIlvD,EAAI,EAAGsuD,EAAMK,EAAev3D,OAAQ4I,EAAIsuD,EAAKtuD,IAAK,CACvD,MAAM0wD,EAAgB1wD,EAChB2/B,EAAKgvB,EAAe3uD,GACpBsvD,EAAc,CAChBnyD,KAAM8wD,EAAkBsB,OACxBC,YAAa7vB,EACbgwB,SAAS,EACTnB,KAAM,MAEVQ,EAAqB/vD,KAAKqwD,GAC1B,MAAMmB,EAA2BxB,EAAyBr4D,IAAI85D,GACzDD,GAA0Br5D,QAG/Bq5D,EACK5xD,IAAK8xD,IAAsB,CAC5BA,oBACAC,wBAAyB,yBAAiCjxB,EAAIgxB,EAAkBnB,gBAE/Er+C,KAAK,CAAC2mC,EAAMsJ,IAAUtJ,EAAK8Y,wBAA0BxP,EAAMwP,yBAC3D/xD,IAAI,EAAG8xD,uBAAwBA,GAC/Bl5D,QAASk5D,GAAsB3B,EAAqB/vD,KAAK0xD,GAClE,CAGA,OAFAvC,EAAoBW,GACpBX,EAAoBY,GACb,CAAED,uBAAsBC,uBACnC,CA8BqC6B,CAA6BnC,EAAgBC,GACxEpQ,EA9BV,SAAkC8P,GAC9B,IAAK,IAAIruD,EAAI,EAAGsuD,EAAMD,EAAej3D,OAAQ4I,EAAIsuD,EAAKtuD,IAAK,CACvD,MAAMqD,EAAQgrD,EAAeruD,GAC7B,IAAKqD,EAAMssD,SACPtsD,EAAMyhB,WAAaopC,EAAsBwB,SACzCrsD,EAAMlG,OAAS8wD,EAAkBsB,OACjC,OAAOlsD,CAEf,CACA,IAAK,IAAIrD,EAAI,EAAGsuD,EAAMD,EAAej3D,OAAQ4I,EAAIsuD,EAAKtuD,IAAK,CACvD,MAAMqD,EAAQgrD,EAAeruD,GAC7B,IAAKqD,EAAMssD,SAAWtsD,EAAMyhB,WAAaopC,EAAsBwB,QAC3D,OAAOrsD,CAEf,CAEJ,CAcuBytD,CAAyB/B,GAC5C,IAAKxQ,EACD,OAAOmQ,EAAex3D,QAE1B,MAAM65D,EAAiB,CAACxS,EAAWiR,aACnC,IAAIjB,EAAehQ,EAAWiQ,KAC1BwC,EAAiB,EACrB,MAAMC,EAAgBvC,EAAet3D,OAASu3D,EAAev3D,OAAS,IACtE,KAAOm3D,IAAiBhQ,GAAcyS,EAAiBC,GAEnD,GADAD,IACIzC,EAAapxD,OAAS8wD,EAAkBmC,cACxC7B,EAAaiC,OACbjC,EAAeA,EAAaC,UAKhC,GAFAuC,EAAe9xD,KAAKsvD,EAAaiB,aACjCjB,EAAeA,EAAaC,MACvBD,EAAc,CACfppD,QAAQC,KAAK,gEACb,KACJ,CAKJ,OAHI4rD,GAAkBC,GAClB9rD,QAAQC,KAAK,iFAEV2rD,CACX,EA7KA,SAAW9C,GACPA,EAAkBA,EAA0B,OAAI,GAAK,SACrDA,EAAkBA,EAAgC,aAAI,GAAK,cAC9D,CAHD,CAGGA,IAAsBA,EAAoB,CAAC,IAE9C,SAAWC,GACPA,EAAsBA,EAA+B,SAAK,GAAK,UAC/DA,EAAsBA,EAA4B,KAAI,GAAK,OAC3DA,EAAsBA,EAA8B,OAAI,GAAK,QAChE,CAJD,CAIGA,IAA0BA,EAAwB,CAAC,IAEtD,SAAWC,GACPA,EAAuBA,EAAgC,SAAK,GAAK,UACjEA,EAAuBA,EAAgC,QAAI,GAAK,UAChEA,EAAuBA,EAAiC,SAAI,GAAK,UACpE,CAJD,CAIGA,IAA2BA,EAAyB,CAAC,G,kDCvBzC,SAAS+C,EAAcC,EAAU9tD,EAAOzI,EAAU,CAC7Dw2D,YAAQ58D,IAER,GAAI28D,EAAS/5D,OAAS,EAClB,OAAO,EAEX,MAAMi6D,EAAoBF,EAAS/5D,OACnC,IAAIk6D,EAAmB,EACvB,MAAM,OAAEF,EAAM,MAAEG,GAAU32D,EAC1B,GAAI22D,GAAOn6D,OACP,IAAK,MAAMo6D,KAAQD,EACf,GAAIL,EAAcM,EAAMnuD,GACpB,OAAO,EAInB,MAAMouD,SAA2Bj9D,IAAX48D,GAAuB,OAASD,GAAYC,GAC5DM,EAAkBP,EAAS/5D,QAAUq6D,EAAc,EAAI,GAC7D,IAAK,IAAIzxD,EAAI,EAAGA,GAAK0xD,EAAiB1xD,IAAK,CACvC,MAAM2/B,EAAKwxB,EAASnxD,GAEdilD,EAAKkM,EADKnxD,IAAMqxD,EAAoB,EAAI,EAAIrxD,EAAI,GAEhD6a,EAAO8kB,EAAG,IAAMslB,EAAG,GAAKtlB,EAAG,GAAKslB,EAAG,GACnCrsB,EAAO+G,EAAG,IAAMslB,EAAG,GAAKtlB,EAAG,GAAKslB,EAAG,GACnCtsB,EAAOgH,EAAG,IAAMslB,EAAG,GAAKtlB,EAAG,GAAKslB,EAAG,GAEzC,GADgC5hD,EAAM,IAAMwX,GAAQxX,EAAM,IAAMs1B,GAAQt1B,EAAM,GAAKu1B,EACtD,CAEzB,IAAI+4B,EADmBhyB,EAAG,KAAOslB,EAAG,GAEpC,IAAK0M,EAAY,CACb,MAAMC,GAAkBvuD,EAAM,GAAKs8B,EAAG,KAAOslB,EAAG,GAAKtlB,EAAG,KAAQslB,EAAG,GAAKtlB,EAAG,IAAMA,EAAG,GACpFgyB,EAAatuD,EAAM,IAAMuuD,CAC7B,CACAN,GAAoBK,EAAa,EAAI,CACzC,CACJ,CACA,SAAUL,EAAmB,EACjC,C,kBCtCe,SAASO,EAAWC,GAC/B,GAAIA,EAAI16D,OAAS,EACb,OAAO06D,EAAI56D,QAEf,MAAMsM,EAASsuD,EACVjzD,IAAK4E,GAAM,CAACA,EAAE,GAAIA,EAAE,KACpB0N,KAAK,CAACC,EAAGlF,IAAMkF,EAAE,KAAOlF,EAAE,GAAKkF,EAAE,GAAKlF,EAAE,GAAKkF,EAAE,GAAKlF,EAAE,IAC3D,SAAS6lD,EAAMC,EAAG5gD,EAAGlF,GACjB,OAAQkF,EAAE,GAAK4gD,EAAE,KAAO9lD,EAAE,GAAK8lD,EAAE,KAAO5gD,EAAE,GAAK4gD,EAAE,KAAO9lD,EAAE,GAAK8lD,EAAE,GACrE,CACA,MAAMj9C,EAAQ,GACd,IAAK,MAAMtR,KAAKD,EAAQ,CACpB,KAAOuR,EAAM3d,QAAU,GACnB26D,EAAMh9C,EAAMA,EAAM3d,OAAS,GAAI2d,EAAMA,EAAM3d,OAAS,GAAIqM,IAAM,GAC9DsR,EAAMpL,MAEVoL,EAAM9V,KAAKwE,EACf,CACA,MAAMuR,EAAQ,GACd,IAAK,IAAIhV,EAAIwD,EAAOpM,OAAS,EAAG4I,GAAK,EAAGA,IAAK,CACzC,MAAMyD,EAAID,EAAOxD,GACjB,KAAOgV,EAAM5d,QAAU,GACnB26D,EAAM/8C,EAAMA,EAAM5d,OAAS,GAAI4d,EAAMA,EAAM5d,OAAS,GAAIqM,IAAM,GAC9DuR,EAAMrL,MAEVqL,EAAM/V,KAAKwE,EACf,CAGA,OAFAsR,EAAMpL,MACNqL,EAAMrL,MACCoL,EAAMpC,OAAOqC,EACxB,C,kCC9Be,SAASi9C,EAAQd,EAAUv2D,GACtC,IAAIs3D,EAAgBf,EACpB,MAAMgB,EAAgBv3D,GAASu3D,eAAiB,EAC1CxL,EAAyB,IAAlBwL,EACb,IAAKj9D,MAAMC,QAAQg8D,EAAS,IAAK,CAC7B,MAAMiB,EAAkBjB,EAClBkB,EAAcD,EAAgBh7D,OAAS+6D,EAC7CD,EAAgB,IAAIh9D,MAAMk9D,EAAgBh7D,OAAS+6D,GACnD,IAAK,IAAInyD,EAAI,EAAGsuD,EAAM+D,EAAaryD,EAAIsuD,EAAKtuD,IACxCkyD,EAAclyD,GAAK,CACfoyD,EAAgBpyD,EAAImyD,GACpBC,EAAgBpyD,EAAImyD,EAAgB,IAEpCxL,GACAuL,EAAclyD,GAAGf,KAAKmzD,EAAgBpyD,EAAImyD,EAAgB,GAGtE,CACA,IAAIv3C,EAAOjP,IACPgtB,EAAOhtB,IACPkP,GAAQlP,IACRitB,GAAQjtB,IACRktB,EAAOltB,IACPmtB,GAAQntB,IAEZ,IAAK,IAAI3L,EAAI,EAAGsuD,EAAM4D,EAAc96D,OAAQ4I,EAAIsuD,EAAKtuD,IAAK,CACtD,MAAOlM,EAAGE,EAAG4P,GAAKsuD,EAAclyD,GAChC4a,EAAOA,EAAO9mB,EAAI8mB,EAAO9mB,EACzB6kC,EAAOA,EAAO3kC,EAAI2kC,EAAO3kC,EACzB6mB,EAAOA,EAAO/mB,EAAI+mB,EAAO/mB,EACzB8kC,EAAOA,EAAO5kC,EAAI4kC,EAAO5kC,EACrB2yD,IACA9tB,EAAOA,EAAOj1B,EAAIi1B,EAAOj1B,EACzBk1B,EAAOA,EAAOl1B,EAAIk1B,EAAOl1B,EAEjC,CACA,OAAO+iD,EACD,CAAE/rC,OAAMC,OAAM8d,OAAMC,OAAMC,OAAMC,QAChC,CAAEle,OAAMC,OAAM8d,OAAMC,OAC9B,C,kCCvCe,SAAS05B,EAAQ9uD,GAC5B,MAAMkf,EAAIlf,EAAOpM,OACjB,IAAIm7D,EAAO,EACPvrD,EAAI0b,EAAI,EACZ,IAAK,IAAI1iB,EAAI,EAAGA,EAAI0iB,EAAG1iB,IACnBuyD,IAAS/uD,EAAOwD,GAAG,GAAKxD,EAAOxD,GAAG,KAAOwD,EAAOwD,GAAG,GAAKxD,EAAOxD,GAAG,IAClEgH,EAAIhH,EAER,OAAOvM,KAAKud,IAAIuhD,EAAO,EAC3B,C,4ECPe,SAASC,EAAkChvD,EAAQm8B,EAAIwtB,EAAIiE,GAAS,GAC/E,IAAIqB,EACAC,EACAtB,GACAsB,EAAUlvD,EAAOpM,OAAS,EAC1Bq7D,EAAiB,IAGjBC,EAAU,EACVD,EAAiB,GAErB,MAAME,EAAgB,GACtB,IAAK,IAAIC,EAAUH,EAAgBG,EAAUpvD,EAAOpM,OAAQw7D,IAAW,CACnE,MAAM3N,EAAKzhD,EAAOkvD,GACZtF,EAAK5pD,EAAOovD,IACd,OAA4BjzB,EAAIwtB,EAAIlI,EAAImI,IACxCuF,EAAc1zD,KAAK,CAACyzD,EAASE,IAEjCF,EAAUE,CACd,CACA,GAA6B,IAAzBD,EAAcv7D,OACd,OAEJ,MAAMy7D,EAAY,GAClBF,EAAcl7D,QAASq7D,IACnB,MAAMC,EAAqB,CACvBvvD,EAAOsvD,EAAa,IACpBtvD,EAAOsvD,EAAa,KAElBE,EAAW,EACZD,EAAmB,GAAG,GAAKA,EAAmB,GAAG,IAAM,GACvDA,EAAmB,GAAG,GAAKA,EAAmB,GAAG,IAAM,GAE5DF,EAAU5zD,KAAK,cAAc+zD,EAAUrzB,MAE3C,MAAM3oB,EAAcvjB,KAAKa,OAAOu+D,GAEhC,MAAO,CACHjnB,QAAS+mB,EAFcE,EAAUr5D,QAAQwd,IAGzC9F,SAAU8F,EAElB,C,iDC1Ce,SAASi8C,EAAuCzvD,EAAQm8B,EAAIwtB,EAAIiE,GAAS,GACpF,IAAI8B,EACAlsD,EACAoqD,GACApqD,EAAIxD,EAAOpM,OAAS,EACpB87D,EAAW,IAGXlsD,EAAI,EACJksD,EAAW,GAEf,IAAK,IAAIlzD,EAAIkzD,EAAUlzD,EAAIwD,EAAOpM,OAAQ4I,IAAK,CAC3C,MAAMilD,EAAKzhD,EAAOwD,GACZomD,EAAK5pD,EAAOxD,GAClB,IAAI,OAA4B2/B,EAAIwtB,EAAIlI,EAAImI,GACxC,MAAO,CAACpmD,EAAGhH,GAEfgH,EAAIhH,CACR,CACJ,C,6DClBe,SAASmzD,EAAuC3vD,EAAQm8B,EAAIwtB,EAAIiE,GAAS,GACpF,MAAM39B,EAAS,GACT2/B,GAAkB,OAAmC5vD,EAAQm8B,EAAIwtB,EAAIiE,GAC3E,IAAK,IAAIpxD,EAAI,EAAGA,EAAIozD,EAAgBh8D,OAAQ4I,IAAK,CAC7C,MAAMilD,EAAKzhD,EAAO4vD,EAAgBpzD,GAAG,IAC/BotD,EAAK5pD,EAAO4vD,EAAgBpzD,GAAG,IAC/B8yD,GAAe,OAAqBnzB,EAAIwtB,EAAIlI,EAAImI,GACtD35B,EAAOx0B,KAAK6zD,EAChB,CACA,OAAOr/B,CACX,C,kDCXe,SAAS4/B,EAAmClC,EAAUxxB,EAAIwtB,EAAIiE,GAAS,GAClF,MAAMuB,EAAgB,GAChBW,EAAYnC,EAAS/5D,OACrBm8D,EAAOD,GAAalC,EAAS,EAAI,GACvC,IAAK,IAAIpxD,EAAI,EAAGA,GAAKuzD,EAAMvzD,IAAK,CAC5B,MAAMilD,EAAKkM,EAASnxD,GACdgH,EAAIhH,IAAMszD,EAAY,EAAI,EAAItzD,EAAI,EAClCotD,EAAK+D,EAASnqD,IAChB,OAA4B24B,EAAIwtB,EAAIlI,EAAImI,IACxCuF,EAAc1zD,KAAK,CAACe,EAAGgH,GAE/B,CACA,OAAO2rD,CACX,C,kDCbA,MAAMa,EAA2B,IAClB,SAASC,EAAqB9zB,EAAIwtB,EAAIlI,EAAImI,GACrD,MAAMsG,EAAW,CAACvG,EAAG,GAAKxtB,EAAG,GAAIwtB,EAAG,GAAKxtB,EAAG,IACtCg0B,EAAW,CAACvG,EAAG,GAAKnI,EAAG,GAAImI,EAAG,GAAKnI,EAAG,IACtC2O,EAAcD,EAAS,GAAKD,EAAS,GAAKC,EAAS,GAAKD,EAAS,GAEvE,IADuBE,GAAe,EAAIA,GAAeA,GACpCJ,EAA0B,CAC3C,MAAMK,EAAY,CACdl0B,EAAG,GAAKwtB,EAAG,GAAKxtB,EAAG,GAAKwtB,EAAG,GAC3BxtB,EAAG,GAAKwtB,EAAG,GAAKxtB,EAAG,GAAKwtB,EAAG,GAC3BxtB,EAAG,GAAKwtB,EAAG,GAAKxtB,EAAG,GAAKwtB,EAAG,GAC3BxtB,EAAG,GAAKwtB,EAAG,GAAKxtB,EAAG,GAAKwtB,EAAG,IAEzB2G,EAAY,CACd7O,EAAG,GAAKmI,EAAG,GAAKnI,EAAG,GAAKmI,EAAG,GAC3BnI,EAAG,GAAKmI,EAAG,GAAKnI,EAAG,GAAKmI,EAAG,GAC3BnI,EAAG,GAAKmI,EAAG,GAAKnI,EAAG,GAAKmI,EAAG,GAC3BnI,EAAG,GAAKmI,EAAG,GAAKnI,EAAG,GAAKmI,EAAG,IAM/B,KAJuByG,EAAU,IAAMC,EAAU,IAC7CD,EAAU,IAAMC,EAAU,IAC1BD,EAAU,IAAMC,EAAU,IAC1BD,EAAU,IAAMC,EAAU,IAE1B,OAKJ,KAHgB,uBAA8Bn0B,EAAIwtB,EAAIlI,IAClD,uBAA8BtlB,EAAIwtB,EAAIC,IACtC,uBAA8BnI,EAAImI,EAAIztB,IAEtC,OAQJ,MAAO,CAFsB,KAJhBk0B,EAAU,GAAKC,EAAU,GAAKD,EAAU,GAAKC,EAAU,KACvDD,EAAU,GAAKC,EAAU,GAAKD,EAAU,GAAKC,EAAU,KAIvC,KAHhBD,EAAU,GAAKC,EAAU,GAAKD,EAAU,GAAKC,EAAU,KACvDD,EAAU,GAAKC,EAAU,GAAKD,EAAU,GAAKC,EAAU,KAIxE,CACA,IAAI1iD,EAAIuuB,EAAG,GAAKslB,EAAG,GACf/4C,EAAIyzB,EAAG,GAAKslB,EAAG,GACnB,MACM8O,EAAaL,EAAS,GAAKtiD,EAAIsiD,EAAS,GAAKxnD,EACnDkF,GAFmBuiD,EAAS,GAAKviD,EAAIuiD,EAAS,GAAKznD,GAElC0nD,EACjB1nD,EAAI6nD,EAAaH,EAGjB,MAAO,CAFSj0B,EAAG,GAAKvuB,EAAIsiD,EAAS,GACrB/zB,EAAG,GAAKvuB,EAAIsiD,EAAS,GAEzC,C,kDCjDe,SAASM,EAAW7C,GAC/B,MAAMoB,GAAO,OAAcpB,GAC3B,MAAO,CAAC,EAAG,EAAGoB,EAAO9+D,KAAKud,IAAIuhD,GAClC,C,iDCiBe,SAAS0B,EAAW9C,GAC/B,MAAM+C,EArBV,SAAwB/C,GACpB,MAAM+C,EAAU,cACVC,EAAWhD,EAAS,GAC1B,IAAK,IAAInxD,EAAI,EAAGsuD,EAAM6C,EAAS/5D,OAAQ4I,EAAIsuD,EAAKtuD,IAAK,CACjD,MAAM2/B,EAAKwxB,EAASnxD,GAEdilD,EAAKkM,EADKnxD,IAAMsuD,EAAM,EAAI,EAAItuD,EAAI,GAElCo0D,EAAKz0B,EAAG,GAAKw0B,EAAS,GACtBE,EAAK10B,EAAG,GAAKw0B,EAAS,GACtBG,EAAK30B,EAAG,GAAKw0B,EAAS,GACtBI,EAAKtP,EAAG,GAAKkP,EAAS,GACtBK,EAAKvP,EAAG,GAAKkP,EAAS,GACtBM,EAAKxP,EAAG,GAAKkP,EAAS,GAC5BD,EAAQ,IAAMG,EAAKI,EAAKH,EAAKE,EAC7BN,EAAQ,IAAMI,EAAKC,EAAKH,EAAKK,EAC7BP,EAAQ,IAAME,EAAKI,EAAKH,EAAKE,CACjC,CAEA,OADA,WAAWL,EAASA,EAAS,IACtBA,CACX,CAEoBQ,CAAevD,GAC/B,OAAO,eAAe+C,EAASA,EACnC,C,4DCtBA,MAAMr9C,EAAU,KAqEhB,EApE0C,CAACnkB,EAAUiiE,KACjD,IAAIx2D,EACAmuD,EACAC,EACJ,GAAI75D,aAAoB,EAAAw9B,cAAe,CACnC,MAAMrW,EAAYnnB,EAAS+6B,eAC3B,IAAK5T,EACD,OAEJyyC,EAAOzyC,EAAUvb,UAAUpH,MAAM,EAAG,GACpCq1D,EAAO1yC,EAAUvb,UAAUpH,MAAM,EAAG,GACpCiH,EAAU0b,EAAU1b,OACxB,KACK,CACD,MAAM0b,EAAYnnB,EAAS+6B,gBACrB,UAAEnvB,EAAWH,QAASy2D,GAAkB/6C,GACxC,gBAAEpD,EAAe,OAAEyjB,GAAWxnC,EAASilB,YACvCoD,EAAUzc,EAAUpH,MAAM,EAAG,GAC7B8jB,EAAU1c,EAAUpH,MAAM,EAAG,GAC7Byf,EAAUrY,EAAUpH,MAAM,EAAG,GAC7B2oD,EAAY,cAClB,WAAWA,EAAW3lB,EAAQzjB,GAC9B,MAAMo+C,EAAmBphE,KAAKud,IAAI,SAAS6uC,EAAW9kC,IAChD+5C,EAAmBrhE,KAAKud,IAAI,SAAS6uC,EAAW7kC,IAChD+5C,EAAmBthE,KAAKud,IAAI,SAAS6uC,EAAWlpC,IACtD,IAAIQ,EACJ,GAAI1jB,KAAKud,IAAI,EAAI6jD,GAAoBh+C,EACjCM,EAAWy9C,EAAc,GACzBtI,EAAOvxC,OAEN,GAAItnB,KAAKud,IAAI,EAAI8jD,GAAoBj+C,EACtCM,EAAWy9C,EAAc,GACzBtI,EAAOtxC,MAEN,MAAIvnB,KAAKud,IAAI,EAAI+jD,GAAoBl+C,GAKtC,MAAM,IAAIjiB,MAAM,oDAJhBuiB,EAAWy9C,EAAc,GACzBtI,EAAO31C,CAIX,CACA,MAAMq+C,EAAgBvhE,KAAKud,IAAI,SAASkpB,EAAQnf,IAC1Ck6C,EAAgBxhE,KAAKud,IAAI,SAASkpB,EAAQlf,IAC1Ck6C,EAAgBzhE,KAAKud,IAAI,SAASkpB,EAAQvjB,IAChD,IAAIS,EACJ,GAAI3jB,KAAKud,IAAI,EAAIgkD,GAAiBn+C,EAC9BO,EAAWw9C,EAAc,GACzBrI,EAAOxxC,OAEN,GAAItnB,KAAKud,IAAI,EAAIikD,GAAiBp+C,EACnCO,EAAWw9C,EAAc,GACzBrI,EAAOvxC,MAEN,MAAIvnB,KAAKud,IAAI,EAAIkkD,GAAiBr+C,GAKnC,MAAM,IAAIjiB,MAAM,oDAJhBwiB,EAAWw9C,EAAc,GACzBrI,EAAO51C,CAIX,CACAxY,EAAU,CAACgZ,EAAUC,EACzB,CAKA,MAAO,CAAEjZ,QAJe,CACpBA,EAAQ,GAAKw2D,EACbx2D,EAAQ,GAAKw2D,GAEkBrI,OAAMC,Q,iDCpE9B,SAAS4I,EAAoBhE,GAExC,OADmB,OAAcA,IACZ,EAAI,GAAK,CAClC,C,+CCHe,SAASiE,EAAkBzG,EAAgBD,GACtD,IAAK,IAAI1uD,EAAI,EAAGq1D,EAAY1G,EAAev3D,OAAQ4I,EAAIq1D,EAAWr1D,IAAK,CACnE,MAAMs1D,EAAW3G,EAAe3uD,GAE1Bu1D,EAAW5G,EADK3uD,IAAMq1D,EAAY,EAAI,EAAIr1D,EAAI,GAE9Cw1D,GAA2B,OAAuC9G,EAAgB4G,EAAUC,GAClG,GAAyC,IAArCC,GAA0Bp+D,OAC1B,OAAO,CAEf,CACA,OAAO,CACX,C,kFCRe,SAASq+D,EAAmBC,EAAgBC,GACvD,GAAID,EAAet+D,OAAS,GAAKu+D,EAAoBv+D,OAAS,EAC1D,MAAO,GAEX,IAAIw+D,EAAiBD,EAAoBz+D,QACzC,MAAM2+D,GAAW,OAAcH,GACzBI,GAAW,OAAcF,GAC/B,GAAIniE,KAAKud,IAAI6kD,GAAY,MAAWpiE,KAAKud,IAAI8kD,GAAY,KACrD,MAAO,GAEPD,EAAW,IACXH,EAAiBA,EAAex+D,QAAQ2L,WAExCizD,EAAW,IACXF,EAAiBA,EAAe1+D,QAAQ2L,WAE5C,MAAMkzD,EAAwBH,EACxBjD,EAAgB,GACtB,IAAK,IAAI3yD,EAAI,EAAGA,EAAI01D,EAAet+D,OAAQ4I,IAAK,CAC5C,MAAM2/B,EAAK+1B,EAAe11D,GACpBilD,EAAKyQ,GAAgB11D,EAAI,GAAK01D,EAAet+D,QACnD,IAAK,IAAI4P,EAAI,EAAGA,EAAI4uD,EAAex+D,OAAQ4P,IAAK,CAC5C,MAAMmmD,EAAKyI,EAAe5uD,GACpBomD,EAAKwI,GAAgB5uD,EAAI,GAAK4uD,EAAex+D,QAC7C4+D,GAAc,QAA0Br2B,EAAIslB,EAAIkI,EAAIC,GAC1D,GAAI4I,EAAa,CACb,MAAMC,EAAOxiE,KAAK8nC,KAAK,qBAAqBoE,EAAIslB,IAC1CiR,EAAOziE,KAAK8nC,KAAK,qBAAqB4xB,EAAIC,IAChDuF,EAAc1zD,KAAK,CACf+lD,MAAO,IAAIgR,GACXG,QAASn2D,EACTo2D,QAASpvD,EACTqvD,OAAQJ,EAAO,KACT,EACAxiE,KAAK8nC,KAAK,qBAAqBoE,EAAIq2B,IAAgBC,EACzDK,OAAQJ,EAAO,KACT,EACAziE,KAAK8nC,KAAK,qBAAqB4xB,EAAI6I,IAAgBE,GAEjE,CACJ,CACJ,CACA,GAA6B,IAAzBvD,EAAcv7D,OACd,OAAI,OAAc2+D,EAAuBL,EAAe,KACpDA,EAAejyC,MAAOjJ,IAAO,OAAcu7C,EAAuBv7C,IAC3D,CAAC,IAAIk7C,EAAe72D,IAAK4E,GAAM,IAAIA,OAE1C,OAAciyD,EAAgBE,EAAe,KAC7CA,EAAenyC,MAAOjJ,IAAO,OAAck7C,EAAgBl7C,IACpD,CAAC,IAAIo7C,EAAe/2D,IAAK4E,GAAM,IAAIA,MAEvC,GAEX,MAAM8yD,EAAqB,CAACC,EAAYC,EAAWC,KAC/C,MAAMC,EAAgB,GACtB,IAAIC,EAAgB,EACpB,IAAK,IAAI52D,EAAI,EAAGA,EAAIw2D,EAAWp/D,OAAQ4I,IAAK,CACxC,MAAM2/B,EAAK62B,EAAWx2D,GACtB22D,EAAc13D,KAAK,CACfU,GAAI,GAAG82D,MAAcG,MACrBpH,YAAa,IAAI7vB,GACjBxiC,KAAM,KAAiBoyD,OACvBsH,kBAAmBJ,EACnBK,oBAAqB92D,EACrBwuD,KAAM,KACNuI,KAAM,KACNC,gBAAgB,EAChBrH,SAAS,EACTsH,iBAAiB,EACjBC,gBAAiB,KAAsB3G,UAE3C,MAAM4G,EAAuBT,EACxB5sD,OAAQstD,IAAyB,IAAdX,EAAkBW,EAAMjB,QAAUiB,EAAMhB,WAAap2D,GACxEmR,KAAK,CAACC,EAAGlF,KAAqB,IAAduqD,EAAkBrlD,EAAEilD,OAASjlD,EAAEklD,SACjC,IAAdG,EAAkBvqD,EAAEmqD,OAASnqD,EAAEoqD,SACpC,IAAK,MAAMc,KAASD,EAAsB,CACtC,GAAIR,EAAcv/D,OAAS,IACvB,QAAeu/D,EAAcA,EAAcv/D,OAAS,GAAGo4D,YAAa4H,EAAMpS,OAAQ,CAClF,MAAMqS,EAAWV,EAAcA,EAAcv/D,OAAS,GACjDigE,EAASL,iBACVK,EAASL,gBAAiB,EAC1BK,EAASnH,iBAAmBkH,EAC5BC,EAASC,MAAsB,IAAdb,EAAkBW,EAAMf,OAASe,EAAMd,OACxDe,EAASl6D,KAAO,KAAiBizD,cAErC,QACJ,CACAuG,EAAc13D,KAAK,CACfU,GAAI,GAAG82D,MAAcG,MACrBpH,YAAa,IAAI4H,EAAMpS,OACvB7nD,KAAM,KAAiBizD,aACvByG,kBAAmBJ,EACnBjI,KAAM,KACNuI,KAAM,KACNC,gBAAgB,EAChBrH,SAAS,EACTsH,iBAAiB,EACjBK,MAAqB,IAAdb,EAAkBW,EAAMf,OAASe,EAAMd,OAC9CpG,iBAAkBkH,EAClBF,gBAAiB,KAAsB3G,SAE/C,CACJ,CACA,MAAMgH,EAAY,GAClB,GAAIZ,EAAcv/D,OAAS,EAAG,CAC1BmgE,EAAUt4D,KAAK03D,EAAc,IAC7B,IAAK,IAAI32D,EAAI,EAAGA,EAAI22D,EAAcv/D,OAAQ4I,IACtC,IAAK,QAAe22D,EAAc32D,GAAGwvD,YAAa+H,EAAUA,EAAUngE,OAAS,GAAGo4D,aAG7E,CACD,MAAMgI,EAAkBD,EAAUA,EAAUngE,OAAS,GACjDu/D,EAAc32D,GAAGg3D,gBACjBL,EAAc32D,GAAGkwD,mBACjBsH,EAAgBR,gBAAiB,EACjCQ,EAAgBtH,iBACZyG,EAAc32D,GAAGkwD,iBACrBsH,EAAgBF,MAAQX,EAAc32D,GAAGs3D,MACzCE,EAAgBr6D,KAAO,KAAiBizD,aAEhD,MAZImH,EAAUt4D,KAAK03D,EAAc32D,GAczC,CACA,GAAIu3D,EAAUngE,OAAS,IACnB,QAAemgE,EAAU,GAAG/H,YAAa+H,EAAUA,EAAUngE,OAAS,GAAGo4D,aAAc,CACvF,MAAMiI,EAAYF,EAAU,GACtBG,EAAiBH,EAAU5tD,MAC7B+tD,EAAeV,iBACdS,EAAUT,gBACXU,EAAexH,mBACfuH,EAAUT,gBAAiB,EAC3BS,EAAUvH,iBAAmBwH,EAAexH,iBAC5CuH,EAAUH,MAAQI,EAAeJ,MACjCG,EAAUt6D,KAAO,KAAiBizD,aAE1C,CACA,GAAImH,EAAUngE,OAAS,EACnB,IAAK,IAAI4I,EAAI,EAAGA,EAAIu3D,EAAUngE,OAAQ4I,IAClCu3D,EAAUv3D,GAAGwuD,KAAO+I,GAAWv3D,EAAI,GAAKu3D,EAAUngE,QAClDmgE,EAAUv3D,GAAG+2D,KACTQ,GAAWv3D,EAAI,EAAIu3D,EAAUngE,QAAUmgE,EAAUngE,QAG7D,OAAOmgE,GAELI,EAAgBpB,EAAmBb,EAAgB,EAAG/C,GACtDiF,EAAgBrB,EAAmBX,EAAgB,EAAGjD,GAC5D,GAA6B,IAAzBgF,EAAcvgE,QAAyC,IAAzBwgE,EAAcxgE,OAC5C,MAAO,GAEXugE,EAAclgE,QAASogE,IACnB,GAAIA,EAASb,gBAAkBa,EAAS3H,iBAAkB,CACtD,MAAM4H,EAAoBD,EAAS3H,iBAC7B6H,EAAcH,EAAchlD,KAAMolD,GAAaA,EAAShB,gBAC1DgB,EAAS9H,mBACT,QAAe8H,EAASxI,YAAaqI,EAASrI,cAC9CwI,EAAS9H,iBAAiBiG,UAAY2B,EAAkB3B,SACxD6B,EAAS9H,iBAAiBkG,UAAY0B,EAAkB1B,SAC5D,GAAI2B,EAAa,CACbF,EAASE,YAAcA,EACvBA,EAAYA,YAAcF,EAC1B,MAAMI,EAAiB,cAAc,cAAeJ,EAASrI,YAAaqI,EAASd,KAAKvH,aAClF0I,EAAmB,cAAc,cAAeH,EAAYvJ,KAAKgB,YAAauI,EAAYvI,aAC1F2I,EAASF,EAAe,GAAKC,EAAiB,GAChDD,EAAe,GAAKC,EAAiB,GACzC,GAAIC,EAAS,KACTN,EAASX,gBAAkB,KAAsB9H,SACjD2I,EAAYb,gBAAkB,KAAsB/H,aAEnD,GAAIgJ,GAAU,KACfN,EAASX,gBAAkB,KAAsB/H,QACjD4I,EAAYb,gBAAkB,KAAsB9H,aAEnD,CACD,MAAMgJ,EAAiB,EAClBP,EAASd,KAAKvH,YAAY,GAAKqI,EAASrI,YAAY,IAAM,GAC1DqI,EAASd,KAAKvH,YAAY,GAAKqI,EAASrI,YAAY,IAAM,IAE3D,OAAcuG,EAAuBqC,IACrCP,EAASX,gBAAkB,KAAsB/H,QACjD4I,EAAYb,gBAAkB,KAAsB9H,WAGpDyI,EAASX,gBAAkB,KAAsB9H,SACjD2I,EAAYb,gBAAkB,KAAsB/H,QAE5D,CACJ,MAEI0I,EAASb,gBAAiB,EAC1Ba,EAAS3H,sBAAmB17D,CAEpC,IAEJ,MAAM6jE,EAAiB,GACvB,IAAK,MAAMC,KAAaX,EAAe,CACnC,IAAKW,EAAUtB,gBACXsB,EAAU3I,SACV2I,EAAUpB,kBAAoB,KAAsB9H,SACpD,SAEJ,IAAImJ,EAAoB,GACpBC,EAAcF,EACdG,GAAa,EACjB,MAAMC,EAAgBJ,EACtB,IAAIK,EAAc,EAClB,MAAMC,EAA0D,GAA/CjB,EAAcvgE,OAASwgE,EAAcxgE,QACtDugE,EAAclgE,QAASirB,GAAOA,EAAEu0C,iBAAkB,GAClDW,EAAcngE,QAASirB,GAAOA,EAAEu0C,iBAAkB,GAClD,EAAG,CACC,GAAI0B,IAAgBC,EAAS,CACzBzzD,QAAQC,KAAK,gDAAiDszD,EAAc/4D,GAAI64D,EAAY74D,IAC5F44D,EAAoB,GACpB,KACJ,CACA,GAAIC,EAAYvB,iBAAmBuB,IAAgBE,EAAe,CAC9DvzD,QAAQC,KAAK,wEAAyEszD,EAAc/4D,GAAI64D,EAAY74D,IACpH44D,EAAoB,GACpB,KACJ,CACAC,EAAYvB,iBAAkB,EAC9BuB,EAAY7I,SAAU,EACW,IAA7B4I,EAAkBnhE,SACjB,QAAemhE,EAAkBA,EAAkBnhE,OAAS,GAAIohE,EAAYhJ,cAC7E+I,EAAkBt5D,KAAK,IAAIu5D,EAAYhJ,cAE3C,IAAIqJ,GAAe,EACfL,EAAYxB,gBAAkBwB,EAAYT,cACtCU,GACAD,EAAcA,EAAYT,YAC1BU,GAAa,EACbI,GAAe,IAGfL,EAAcA,EAAYT,YAC1BU,GAAa,EACbI,GAAe,IAOnBL,EAAcA,EAAYhK,IAElC,OAASgK,IAAgBE,GACpBD,GAAgD,IAAlCD,EAAY3B,oBACzB4B,GAAgD,IAAlCD,EAAY3B,mBAOhC,GANI8B,EAAcC,GAAwC,IAA7BL,EAAkBnhE,QAEtCmhE,EAAkBnhE,OAAS,IAChC,QAAemhE,EAAkB,GAAIA,EAAkBA,EAAkBnhE,OAAS,KAClFmhE,EAAkB5uD,MAElB4uD,EAAkBnhE,QAAU,EAAG,CAC/B,MAAM0hE,GAAa,OAAcP,IAC7B1C,EAAW,GAAKiD,EAAa,GAGxBjD,EAAW,GAAKiD,EAAa,IAFlCP,EAAkB11D,UAKtBw1D,EAAep5D,KAAKs5D,EAAkB15D,IAAK4E,GAAM,IAAIA,IACzD,CACJ,CACA,OAAO40D,CACX,C,4DC5QO,SAASU,EAAwB11D,EAAO8tD,EAAUv2D,EAAU,CAAC,GAChE,MAAM,qBAAEo+D,EAAoB,kBAAEC,IAAsB,IAAAx1D,GAAY0tD,IAC1D,MAAEI,GAAU32D,EACZs+D,EAAiB,GACvB,GAAI3H,EACA,IAAK,IAAIvxD,EAAI,EAAGA,EAAIuxD,EAAMn6D,OAAQ4I,IAAK,CACnC,MAAMwxD,EAAOD,EAAMvxD,GACbm5D,EAAS,GACf,IAAK,IAAInyD,EAAI,EAAGA,EAAIwqD,EAAKp6D,OAAQ4P,IAC7BmyD,EAAOl6D,KAAK,CACRuyD,EAAKxqD,IAAIgyD,EAAuB,GAAK,GACrCxH,EAAKxqD,IAAIgyD,EAAuB,GAAK,KAG7CE,EAAej6D,KAAKk6D,EACxB,CAEJ,MAAMC,EAAU,CACZ/1D,GAAO21D,EAAuB,GAAK,GACnC31D,GAAO21D,EAAuB,GAAK,IAEvC,OAAO,OAAcC,EAAmBG,EAAS,CAAE7H,MAAO2H,GAC9D,C,iDCvBA,MA8BA,EA9B8B,CAACz1D,EAAGk8B,EAAIslB,EAAIxW,KACtC,MAAM4qB,EAAM,CAAC51D,EAAE,GAAKk8B,EAAG,GAAIl8B,EAAE,GAAKk8B,EAAG,IAC/B25B,EAAO,CAACrU,EAAG,GAAKtlB,EAAG,GAAIslB,EAAG,GAAKtlB,EAAG,IAClCyjB,EAAMiW,EAAI,GAAKC,EAAK,GAAKD,EAAI,GAAKC,EAAK,GAC7C,GAAIlW,EAAM,EACN,OAAO,EAEX,MAAMmW,EAAU9lE,KAAK8nC,KAAK+9B,EAAK,GAAKA,EAAK,GAAKA,EAAK,GAAKA,EAAK,IAC7D,GAAgB,IAAZC,EACA,OAAO,EAEX,MAAMC,EAAsBpW,EAAMmW,EAC5BE,EAAiB,CAACH,EAAK,GAAKC,EAASD,EAAK,GAAKC,GAC/CG,EAAmB,CACrBD,EAAe,GAAKD,EACpBC,EAAe,GAAKD,GAElBG,EAAkB,CACpBh6B,EAAG,GAAK+5B,EAAiB,GACzB/5B,EAAG,GAAK+5B,EAAiB,IAG7B,QADiB,cAAcj2D,EAAGk2D,GACnBlrB,MAGX,cAAc9O,EAAIg6B,GAAmB,cAAch6B,EAAIslB,I,iDCzB/D,MAGA,EAH6C,CAACtlB,EAAIslB,EAAI2U,IAC3C,UAAUj6B,EAAIslB,GAAM2U,C,kDCD/B,MAAMC,EAAU,KACT,SAASC,EAAY3I,GACxB,IAAI6H,EACJ,MAAMe,EAAa,EAAAtf,UAAA,yBAAmC0W,EAAU,IAChE,IAAK,IAAInxD,EAAI,EAAGA,EAAI,EAAGA,IACnB,GAAI+5D,EAAWt2C,MAAM,CAACpgB,EAAOvE,EAAOiD,IAAUtO,KAAKud,IAAI3N,EAAMrD,GAAK+B,EAAM,GAAG/B,IAAM65D,GAAU,CACvFb,EAAuBh5D,EACvB,KACJ,CAEJ,QAA6BxL,IAAzBwkE,EACA,MAAM,IAAIpkE,MAAM,6EAEpB,MAAMolE,EAAW,GACXC,GAAYjB,EAAuB,GAAK,EACxCkB,GAAalB,EAAuB,GAAK,EAC/C,IAAK,IAAIh5D,EAAI,EAAGA,EAAImxD,EAAS/5D,OAAQ4I,IACjCg6D,EAAS/6D,KAAK,CAACkyD,EAASnxD,GAAGi6D,GAAW9I,EAASnxD,GAAGk6D,KAEtD,MAAO,CACHlB,uBACAC,kBAAmBe,EAE3B,C,iGCtBO,MAAMnjD,EAAU,KAChB,SAASsjD,EAAW/oD,EAAGlF,GAC1B,OAAOkF,EAAE,GAAKlF,EAAE,GAAKkF,EAAE,GAAKlF,EAAE,EAClC,CACO,SAASkuD,EAAez6B,EAAIslB,GAC/B,OAAO,EAAAxK,UAAA,QAAkB9a,EAAIslB,EAAIpuC,EACrC,CACO,SAASwjD,EAA0B16B,EAAIslB,EAAIkI,EAAIC,GAClD,MAAMphD,EAAI,cAAc,cAAei5C,EAAItlB,GACrC26B,EAAI,cAAc,cAAelN,EAAID,GACrCoN,EAAMJ,EAAWnuD,EAAGsuD,GACpBE,EAAM,cAAc,cAAerN,EAAIxtB,GACvC86B,EAAQN,EAAWK,EAAKxuD,GAC9B,GAAIvY,KAAKud,IAAIupD,GAAO1jD,EAAS,CACzB,GAAIpjB,KAAKud,IAAIypD,GAAS5jD,EAAS,CAC3B,MAAM6jD,EAAQ,SAAS1uD,EAAGA,GACpB2uD,EAAQ,SAASL,EAAGA,GAC1B,GAAII,EAAQ7jD,GAAW8jD,EAAQ9jD,EAC3B,OAAIujD,EAAez6B,EAAIwtB,IAAOiN,EAAez6B,EAAIytB,GACtCztB,EAEPy6B,EAAenV,EAAIkI,IAAOiN,EAAenV,EAAImI,GACtCnI,EAEJ,KAEX,MAAM2V,EAAK,SAAS,cAAc,cAAezN,EAAIxtB,GAAK3zB,GAAK0uD,EACzDG,EAAK,SAAS,cAAc,cAAezN,EAAIztB,GAAK3zB,GAAK0uD,EACzDI,EAAK,SAAS,cAAc,cAAen7B,EAAIwtB,GAAKmN,GAAKK,EACzDI,EAAK,SAAS,cAAc,cAAe9V,EAAIkI,GAAKmN,GAAKK,EACzDK,EAAa56B,GAAMA,IAAMvpB,GAAWupB,GAAK,EAAIvpB,EACnD,GAAImkD,EAAUJ,GAAK,CAEf,GAAIR,EAAejN,EADI,iBAAiB,cAAextB,EAAI3zB,EAAG4uD,IAE1D,OAAOzN,CAEf,CACA,GAAI6N,EAAUH,GAAK,CAEf,GAAIT,EAAehN,EADI,iBAAiB,cAAeztB,EAAI3zB,EAAG6uD,IAE1D,OAAOzN,CAEf,CACA,GAAI4N,EAAUF,GAAK,CAEf,GAAIV,EAAez6B,EADI,iBAAiB,cAAewtB,EAAImN,EAAGQ,IAE1D,OAAOn7B,CAEf,CACA,GAAIq7B,EAAUD,GAAK,CAEf,GAAIX,EAAenV,EADI,iBAAiB,cAAekI,EAAImN,EAAGS,IAE1D,OAAO9V,CAEf,CACJ,CACA,OAAO,IACX,CACA,MAAM7kB,EAAI+5B,EAAWK,EAAKF,GAAKC,EACzB9U,EAAIgV,EAAQF,EAClB,OAAIn6B,IAAMvpB,GAAWupB,GAAK,EAAIvpB,GAAW4uC,IAAM5uC,GAAW4uC,GAAK,EAAI5uC,EACxD,CAAC8oB,EAAG,GAAKS,EAAIp0B,EAAE,GAAI2zB,EAAG,GAAKS,EAAIp0B,EAAE,IAErC,IACX,CACO,IAAIivD,EAKAC,GAJX,SAAWD,GACPA,EAAiBA,EAAyB,OAAI,GAAK,SACnDA,EAAiBA,EAA+B,aAAI,GAAK,cAC5D,CAHD,CAGGA,IAAqBA,EAAmB,CAAC,IAE5C,SAAWC,GACPA,EAAsBA,EAAgC,SAAI,GAAK,WAC/DA,EAAsBA,EAA+B,QAAI,GAAK,UAC9DA,EAAsBA,EAA+B,QAAI,GAAK,SACjE,CAJD,CAIGA,IAA0BA,EAAwB,CAAC,G,4FCxEvC,SAASC,EAAkBC,EAAsBC,GAC5D,GAAID,EAAqBhkE,OAAS,EAC9B,MAAO,GAEX,GAAIikE,EAA0BjkE,OAAS,EACnC,MAAO,CAACgkE,EAAqBlkE,SAEjC,MAAMokE,EAAuBD,EAA0BnkE,QACvD,IAAI,OAAsBkkE,EAAsBC,GAC5C,MAAO,GAEX,MAAME,GAAa,OAAcH,GAC3BI,GAAa,OAAcF,GAC7B7nE,KAAKouC,KAAK05B,KAAgB9nE,KAAKouC,KAAK25B,IACpC/nE,KAAKud,IAAIwqD,GAAc,MACvBF,EAAqBz4D,UAEzB,MAAM8vD,EAAgB,GACtB,IAAK,IAAI3yD,EAAI,EAAGA,EAAIo7D,EAAqBhkE,OAAQ4I,IAAK,CAClD,MAAM2/B,EAAKy7B,EAAqBp7D,GAC1BilD,EAAKmW,GAAsBp7D,EAAI,GAAKo7D,EAAqBhkE,QAC/D,IAAK,IAAI4P,EAAI,EAAGA,EAAIs0D,EAAqBlkE,OAAQ4P,IAAK,CAClD,MAAMmmD,EAAKmO,EAAqBt0D,GAC1BomD,EAAKkO,GAAsBt0D,EAAI,GAAKs0D,EAAqBlkE,QACzD4+D,GAAc,QAA0Br2B,EAAIslB,EAAIkI,EAAIC,GAC1D,GAAI4I,EAAa,CACb,MAAMC,EAAOxiE,KAAK8nC,KAAK,qBAAqBoE,EAAIslB,IAC1CiR,EAAOziE,KAAK8nC,KAAK,qBAAqB4xB,EAAIC,IAChDuF,EAAc1zD,KAAK,CACf+lD,MAAOgR,EACPG,QAASn2D,EACTo2D,QAASpvD,EACTqvD,OAAQJ,EAAO,KACT,EACAxiE,KAAK8nC,KAAK,qBAAqBoE,EAAIq2B,IAAgBC,EACzDK,OAAQJ,EAAO,KACT,EACAziE,KAAK8nC,KAAK,qBAAqB4xB,EAAI6I,IAAgBE,GAEjE,CACJ,CACJ,CACA,MAAMK,EAAqB,CAACC,EAAYC,EAAWC,KAC/C,MAAMC,EAAgB,GACtB,IAAIC,EAAgB,EACpB,IAAK,IAAI52D,EAAI,EAAGA,EAAIw2D,EAAWp/D,OAAQ4I,IAAK,CACxC,MAAM2/B,EAAK62B,EAAWx2D,GACtB22D,EAAc13D,KAAK,CACfU,GAAI,GAAG82D,MAAcG,MACrBpH,YAAa7vB,EACbxiC,KAAM,KAAiBoyD,OACvBsH,kBAAmBJ,EACnBK,oBAAqB92D,EACrBwuD,KAAM,KACNuI,KAAM,KACNC,gBAAgB,EAChBrH,SAAS,IAEb,MAAMwH,EAAuBT,EACxB5sD,OAAQstD,IAAyB,IAAdX,EAAkBW,EAAMjB,QAAUiB,EAAMhB,WAAap2D,GACxEmR,KAAK,CAACC,EAAGlF,KAAqB,IAAduqD,EAAkBrlD,EAAEilD,OAASjlD,EAAEklD,SACjC,IAAdG,EAAkBvqD,EAAEmqD,OAASnqD,EAAEoqD,SACpC,IAAK,MAAMc,KAASD,EACZR,EAAcv/D,OAAS,IACvB,QAAeu/D,EAAcA,EAAcv/D,OAAS,GAAGo4D,YAAa4H,EAAMpS,OACrE2R,EAAcA,EAAcv/D,OAAS,GAAG4/D,iBACzCL,EAAcA,EAAcv/D,OAAS,GAAG4/D,gBAAiB,EACzDL,EAAcA,EAAcv/D,OAAS,GAAG84D,iBAAmBkH,EAC3DT,EAAcA,EAAcv/D,OAAS,GAAGkgE,MACtB,IAAdb,EAAkBW,EAAMf,OAASe,EAAMd,QAInDK,EAAc13D,KAAK,CACfU,GAAI,GAAG82D,MAAcG,MACrBpH,YAAa4H,EAAMpS,MACnB7nD,KAAM,KAAiBizD,aACvByG,kBAAmBJ,EACnBjI,KAAM,KACNuI,KAAM,KACNC,gBAAgB,EAChBrH,SAAS,EACT2H,MAAqB,IAAdb,EAAkBW,EAAMf,OAASe,EAAMd,OAC9CpG,iBAAkBkH,GAG9B,CACA,MAAMG,EAAY,GAClB,GAAIZ,EAAcv/D,OAAS,EAAG,CAC1BmgE,EAAUt4D,KAAK03D,EAAc,IAC7B,IAAK,IAAI32D,EAAI,EAAGA,EAAI22D,EAAcv/D,OAAQ4I,KACjC,QAAe22D,EAAc32D,GAAGwvD,YAAa+H,EAAUA,EAAUngE,OAAS,GAAGo4D,aAI1EmH,EAAc32D,GAAGg3D,iBACjBO,EAAUA,EAAUngE,OAAS,GAAG4/D,gBAAiB,EACjDO,EAAUA,EAAUngE,OAAS,GAAG84D,iBAC5ByG,EAAc32D,GAAGkwD,iBACrBqH,EAAUA,EAAUngE,OAAS,GAAGkgE,MAAQX,EAAc32D,GAAGs3D,OAP7DC,EAAUt4D,KAAK03D,EAAc32D,GAWzC,CACA,GAAIu3D,EAAUngE,OAAS,EACnB,IAAK,IAAI4I,EAAI,EAAGA,EAAIu3D,EAAUngE,OAAQ4I,IAClCu3D,EAAUv3D,GAAGwuD,KAAO+I,GAAWv3D,EAAI,GAAKu3D,EAAUngE,QAClDmgE,EAAUv3D,GAAG+2D,KACTQ,GAAWv3D,EAAI,EAAIu3D,EAAUngE,QAAUmgE,EAAUngE,QAG7D,OAAOmgE,GAELkE,EAAkBlF,EAAmB6E,EAAsB,EAAGzI,GAC9D+I,EAAkBnF,EAAmB+E,EAAsB,EAAG3I,GACpE8I,EAAgBhkE,QAASkkE,IACrB,GAAIA,EAAM3E,eAAgB,CACtB,MAAM4E,EAAQD,EAAMzL,iBACd2L,EAAUH,EAAgB9oD,KAAMkpD,GAAUA,EAAM9E,iBAClD,QAAe8E,EAAMtM,YAAamM,EAAMnM,cACxCsM,EAAM5L,iBAAiBiG,UACnByF,EAAMzF,SACV2F,EAAM5L,iBAAiBkG,UAAYwF,EAAMxF,SAC7C,GAAIyF,EAAS,CACTF,EAAM5D,YAAc8D,EACpBA,EAAQ9D,YAAc4D,EACtB,MAAMI,EAASJ,EAAM5E,KAAKvH,YACpBwM,EAASL,EAAMnM,YACfyM,EAAgBJ,EAAQrN,KAAKgB,YAG7B0M,GAFmB,cAAc,cAAeF,EAAQD,GACnC,cAAc,cAAeE,EAAeD,GAC9C,EACpBL,EAAM5E,KAAKvH,YAAY,GAAKmM,EAAMnM,YAAY,IAAM,GACpDmM,EAAM5E,KAAKvH,YAAY,GAAKmM,EAAMnM,YAAY,IAAM,IAEnD2M,GAA8B,OAAcd,EAA2Ba,GAEzEP,EAAMzE,gBADNiF,EACwB,KAAsBhN,QAGtB,KAAsBC,QAEtD,MAEIuM,EAAM3E,gBAAiB,CAE/B,IAEJyE,EAAgBhkE,QAASirB,UAAaA,EAAEwtC,kBACxCwL,EAAgBjkE,QAASirB,UAAaA,EAAEwtC,kBACxC,MAAMkM,EAAkB,GACxB,IAAK,IAAIp8D,EAAI,EAAGA,EAAIy7D,EAAgBrkE,OAAQ4I,IAAK,CAC7C,MAAMq8D,EAAYZ,EAAgBz7D,GAClC,GAAIq8D,EAAU1M,SAAW0M,EAAUrF,eAC/B,SAEJ,IAAI,OAAcqE,EAA2BgB,EAAU7M,aACnD,SAEJ,MAAM+I,EAAoB,GAC1B,IAAIC,EAAc6D,EACdC,GAAe,EACf3D,EAAc,EAClB,MAAMC,EAA8D,GAAnD6C,EAAgBrkE,OAASskE,EAAgBtkE,QAC1D,EAAG,CACC,GAAIuhE,IAAgBC,EAAS,CACzBzzD,QAAQC,KAAK,gEACb,KACJ,CACAozD,EAAY7I,SAAU,EACW,IAA7B4I,EAAkBnhE,SACjB,QAAemhE,EAAkBA,EAAkBnhE,OAAS,GAAIohE,EAAYhJ,cAC7E+I,EAAkBt5D,KAAKu5D,EAAYhJ,aAEnCgJ,EAAYxB,iBACRsF,EACI9D,EAAYtB,kBAAoB,KAAsB9H,UACtDoJ,EAAYT,cACZS,EAAcA,EAAYT,YAC1BuE,GAAe,GAIf9D,EAAYT,aACZS,EAAcA,EAAYT,YAC1BuE,GAAe,GAGfn3D,QAAQC,KAAK,yDAIzBozD,EAAcA,EAAYhK,IAC9B,OAASgK,IAAgB6D,IAAcC,GACnC/D,EAAkBnhE,QAAU,KACxB,QAAemhE,EAAkB,GAAIA,EAAkBA,EAAkBnhE,OAAS,KAClFmhE,EAAkB5uD,MAElB4uD,EAAkBnhE,QAAU,GAC5BglE,EAAgBn9D,KAAKs5D,GAGjC,CACA,OAAO6D,CACX,C,+SCzMgC,IACK,IACE,IACR,IACM,IACV,IACS,IACV,G,4DCb1B,MAAMvlD,EAAU,IAkBT,SAAS0lD,EAA4BC,EAAcC,EAAaC,EAAa,CAAEC,SAAU,EAAGC,SAAU,IACzG,MAAM,OAAEp5D,GAAWg5D,EAAahV,UACxBoV,SAAUC,EAAiBF,SAAUG,GAAoBJ,EACjE,IAEIK,EAFAJ,EAAWG,EAAkBA,EAC7BF,EAAWC,EAAkBA,EAEjC,IAAK,IAAItkB,EAAS,EAAGA,EAAS/0C,EAAOpM,OAAQmhD,IACzC,IAAK,IAAIC,EAASD,EAAS,EAAGC,EAASh1C,EAAOpM,OAAQohD,IAAU,CAC5D,MAAMwkB,EAASx5D,EAAO+0C,GAChB0kB,EAASz5D,EAAOg1C,GAChB0kB,EAAY,aAAaF,EAAQC,GACnCC,EAAYP,IAGZO,EAAYrmD,EAAU8lD,EAAW9lD,GAAWkmD,GAG3CN,EAAYU,WAAWH,EAAQC,KAG/B,QAAgBD,EAAQC,EAAQR,KAGrCE,EAAWO,EAAYrmD,EACvBkmD,EAAiB,CAACxkB,EAAQC,GAC1BokB,EAAW,GACf,CAEJ,IAAKG,EACD,OAEJJ,EAAWlpE,KAAK8nC,KAAKohC,EAAW9lD,GAChC,MAAMumD,EAAU55D,EAAOu5D,EAAe,IAChCM,EAAU75D,EAAOu5D,EAAe,IAChCO,EAAY,SAAS,cAAeF,EAASC,GAEnD,IAAIE,EADJ,WAAWD,EAAWA,EAAW,EAAIX,GAErC,IAAK,IAAIpkB,EAAS,EAAGA,EAAS/0C,EAAOpM,OAAQmhD,IACzC,IAAK,IAAIC,EAASD,EAAS,EAAGC,EAASh1C,EAAOpM,OAAQohD,IAAU,CAC5D,MAAMwkB,EAASx5D,EAAO+0C,GAChB0kB,EAASz5D,EAAOg1C,GAChB0kB,EAAY,aAAaF,EAAQC,GACvC,GAAIC,GAAaN,EACb,SAEJ,MAAMryD,EAAQ,SAAS,cAAeyyD,EAAQC,GAClCxpE,KAAKud,IAAI,SAASzG,EAAO+yD,IAAc7pE,KAAK8nC,KAAK2hC,GACnDrmD,GAGL4lD,EAAYU,WAAWH,EAAQC,KAG/B,QAAgBD,EAAQC,EAAQR,KAGrCG,EAAWM,EACXK,EAAiB,CAAChlB,EAAQC,GAC9B,CAEJ,IAAK+kB,EACD,OAEJX,EAAWnpE,KAAK8nC,KAAKqhC,GAUrB,MAPsB,CAClB3iB,UAAW,CAACmjB,EAASC,GACrBnjB,UAAW,CAJC12C,EAAO+5D,EAAe,IACtB/5D,EAAO+5D,EAAe,KAIlCZ,WACAC,cACGJ,EAGX,C,uGC5Fe,SAASgB,EAAgBR,EAAQC,EAAQR,GACpD,MAAMgB,EAAOhB,EAAYp0D,MAAM20D,GACzBU,EAAOjB,EAAYp0D,MAAM40D,GACzBU,EAAY,eACZ,QAAEC,GAAYnB,EACdlyD,EAAQ,SAAS,cAAekzD,EAAMC,GACtCG,EAAWpqE,KAAK0kB,MAAM1kB,KAAKyQ,OAAOqG,EAAM1L,IAAIpL,KAAKud,OACvD,GAAI6sD,EAAW,EACX,OAAO,EAEX,MAAMC,EAAY,WAAW,cAAevzD,EAAO,EAAIszD,GACvD,IAAK,IAAI79D,EAAI,EAAGA,EAAI69D,EAAU79D,IAE1B,GADA,iBAAiB29D,EAAWD,EAAMI,EAAW99D,IACxC49D,EAAQD,GACT,OAAO,EAGf,OAAO,CACX,CACA,SAASI,GAA0B,WAAE7/D,EAAU,UAAE2b,EAAS,aAAEre,EAAY,aAAE8sC,EAAY,wBAAE01B,IACpF,MAAM5qE,EAAQ8K,EAAW,GACnB+/D,EAAiB7qE,EAAQ8K,EAAW,GAC1C,MAAO,CACHi/D,WAAY,CAACH,EAAQC,KACjB,MAAM55D,EAAQ,SAAS,cAAe25D,EAAQC,GAAQp+D,IAAKiC,GAAOA,EAAK,GACjEo9D,EAAMrkD,EAAUyV,aAAajsB,GAAOxE,IAAIpL,KAAK0kB,QAC5CnY,EAAGgH,EAAGI,GAAK82D,EACZp/D,EAAQkB,EAAIgH,EAAI5T,EAAQgU,EAAI62D,EAC5BxnE,EAAQ+E,EAAa+nC,WAAWzkC,GACtC,OAAOrI,IAAU6xC,GAAgB01B,GAAyBnkE,IAAIpD,IAElE4R,MAAQhF,GAAUwW,EAAUyV,aAAajsB,GACzCu6D,QAAUM,IACN,MAAOl+D,EAAGgH,EAAGI,GAAK82D,EACZp/D,EAAQrL,KAAK0kB,MAAMnY,GAAKvM,KAAK0kB,MAAMnR,GAAK5T,EAAQK,KAAK0kB,MAAM/Q,GAAK62D,EAChExnE,EAAQ+E,EAAa+nC,WAAWzkC,GACtC,OAAOrI,IAAU6xC,GAAgB01B,GAAyBnkE,IAAIpD,IAG1E,C,wECtCO,SAAS0nE,EAAuCC,GACnDA,EAAa3mE,QAASo+C,IAClB,MAAMiV,GAAY,IAAAuT,cAAaxoB,GAC/B,IAAKiV,EAED,YADA3lD,QAAQC,KAAK,+BAA+BywC,KAG1BiV,EAAUwT,mBAClB7mE,QAAS8mE,IACnB,MAAM,kBAAEn7C,EAAiB,WAAEgB,GAAem6C,EACpC3vD,GAAkB,IAAAyU,oBAAmBD,GAC3C,IAAKxU,EAED,YADAzJ,QAAQC,KAAK,qCAAqCge,KAGtD,MAAM1wB,EAAWkc,EAAgB0W,YAAYlB,IAC7C,OAAwB1xB,EAAS2xB,YAG7C,C,6DCDA,QAnBO,SAA+C8qB,GAC7CA,EAAoB/3C,QAGzB+3C,EAAoB13C,QAAS2sB,IACzB,MAAMtyB,GAAiB,IAAAg2C,+BAA8B1jB,GACrD,IAAKtyB,EAED,YADAqT,QAAQC,KAAK,8BAA8Bgf,KAG/C,MAAM,SAAE1xB,GAAaZ,EACrB,IAAKY,EAED,YADAyS,QAAQC,KAAK,8BAA8Bgf,KAG/C,MAAMC,EAAU3xB,EAAS2xB,SACzB,OAAwBA,IAEhC,C,+JCnBe,MAAMm6C,SACRhoE,KAAKioE,YAAc,IAAIl4D,GAAO,QAC9B/P,KAAKkoE,QAAU,EAAI,QACnBloE,KAAK2nD,KAAO,YAAc,CACnC,gBAAOwgB,CAAU/jE,GACb,MAAM,eAAE0wD,EAAc,QAAEoT,EAAO,KAAEvgB,GAASvjD,EAC1CpE,KAAK2nD,KAAOA,EACZ3nD,KAAKkoE,QAAUA,EACfloE,KAAKioE,YAAY51D,QACC,eAAdrS,KAAK2nD,KACLugB,EAAQjnE,QAASqH,IACbtI,KAAKioE,YAAY/nE,IAAIoI,EAAO,IAAI,KAA6B,CAAEwsD,sBAInE90D,KAAKioE,YAAY/nE,IAAIgoE,EAAS,IAAI,KAA6B,CAAEpT,mBAEzE,CACA,oBAAOsT,CAAc38D,GACjB,MAAM,aAAEqmC,KAAiBu2B,GAAc58D,EACvC,IAAKqmC,EACD,MAAM,IAAI1zC,MAAM,mDAEpB,MAAMkqE,EAA2B,eAAdtoE,KAAK2nD,KAClB3nD,KAAKioE,YAAY7nE,IAAI0xC,GACrB9xC,KAAKioE,YAAY7nE,IAAIJ,KAAKkoE,SAChC,IAAKI,EACD,MAAM,IAAIlqE,MAAM,mCAAmC0zC,KAEvDw2B,EAAWF,cAAcC,EAC7B,CACA,oBAAOxe,CAAczlD,GACjB,GAAkB,eAAdpE,KAAK2nD,KAAuB,CAC5B,MAAM1qB,EAAS,CAAC,EAIhB,OAHAj9B,KAAKioE,YAAYhnE,QAAQ,CAACqnE,EAAYx2B,KAClC7U,EAAO6U,GAAgBw2B,EAAWze,cAAczlD,KAE7C64B,CACX,CAEA,OADmBj9B,KAAKioE,YAAY7nE,IAAIJ,KAAKkoE,SAC3Bre,cAAczlD,EACpC,E,wKC7BJ,MAAMgyC,EAAY,CACd,CAAC,IAAgB3G,UAAW84B,EAAA,GAC5B,CAAC,IAAgBlyB,SAAUmyB,EAAA,EAC3B,CAAC,IAAgBlyB,SAAUmyB,EAAA,IAEzBC,EAAwBC,EAAA,EAAsCrxB,SAsJhC,IArJpC,MACI,WAAA73C,GACIO,KAAK4oE,aAAe,IAAIxuC,IACxBp6B,KAAK6oE,oBAAsB,GAC3B7oE,KAAK8oE,oBAAqB,EAC1B9oE,KAAK+oE,sBAAwB,KAC7B/oE,KAAKgpE,iBAAmB,KACI,IAAAC,uBACDpqD,QAASzG,GAAoBA,EAAgB0c,gBAExE90B,KAAKkpE,4BAA8B,KAC/BlpE,KAAKmpE,oBAQL,GAPoBzqE,MAAM6D,KAAKvC,KAAK4oE,cACxB3nE,QAAS2sB,IACjB5tB,KAAKopE,eAAex7C,KAExB5tB,KAAK4oE,aAAav2D,QAClBrS,KAAK8oE,oBAAqB,EAC1B9oE,KAAK+oE,sBAAwB,KACzB/oE,KAAK6oE,oBAAoBjoE,OAAS,EAAG,CACrC,MAAMyoE,EAAkBrpE,KAAK6oE,oBAAoBjY,QAC7CyY,GAAmBA,EAAgBzoE,OAAS,GAC5CZ,KAAKspE,mCAAmCD,EAEhD,EAER,CACA,8BAAAE,CAA+B37C,GAC3B,MAAMtV,EAAcsV,EACd,CAACA,GACD5tB,KAAKwpE,iCACXxpE,KAAKspE,mCAAmChxD,EAC5C,CACA,kBAAAmxD,CAAmBl5B,GACf,MAAMj4B,EAActY,KAAKwpE,+BAA+Bj5B,GACxDvwC,KAAKspE,mCAAmChxD,EAC5C,CACA,8BAAAkxD,CAA+Bj5B,GAC3B,MAAMl4B,EAAYrY,KAAKgpE,mBACjB1wD,EAAc,GACpB,IAAK,MAAMpc,KAAYmc,EAAW,CAC9B,MAAMuV,EAAa1xB,EAASiN,GAC5B,GAAIonC,EAAgB,CAChB,MAAMm5B,GAA8B,EAAA10B,EAAA,IAA+BpnB,EAAY,CAAE2iB,mBAC7Em5B,GAA6B9oE,OAAS,GACtC0X,EAAY7P,KAAKmlB,EAEzB,KACK,CACD,MAAM87C,GAA8B,EAAA10B,EAAA,IAA+BpnB,GAC/D87C,GAA6B9oE,OAAS,GACtC0X,EAAY7P,KAAKmlB,EAEzB,CACJ,CACA,OAAOtV,CACX,CACA,iBAAA6wD,GACI,GAAInpE,KAAKwY,iBACL,MAAM,IAAIpa,MAAM,uHAExB,CACA,kCAAAkrE,CAAmChxD,GAC3BtY,KAAK8oE,mBACL9oE,KAAK6oE,oBAAoBpgE,KAAK6P,IAGlCA,EAAYrX,QAAS2sB,IACjB5tB,KAAK4oE,aAAatlE,IAAIsqB,KAE1B5tB,KAAK2pE,UACT,CACA,OAAAA,GACQ3pE,KAAK4oE,aAAa1/C,KAAO,IAAiC,IAA5BlpB,KAAK8oE,qBACnC9oE,KAAK+oE,sBAAwB96C,OAAO27C,sBAAsB5pE,KAAKkpE,6BAC/DlpE,KAAK8oE,oBAAqB,EAElC,CACA,cAAAM,CAAex7C,GACX,MAAM87C,GAA8B,EAAA10B,EAAA,IAA+BpnB,GACnE,IAAK87C,GAA6B9oE,OAC9B,OAEJ,MAAM,SAAE1E,IAAa,IAAAo1C,+BAA8B1jB,IAAe,CAAC,EACnE,IAAK1xB,EACD,OAEJ,MAAM2tE,EAAyBH,EAA4BrhE,IAAK2rC,IACxDA,EAAertC,OAAS,EAAA6oC,4BAA4B6G,SACpDr2C,KAAK8pE,+BAA+B5tE,GAExC,MAAM6tE,EAAU3zB,EAAUpC,EAAertC,MAEnCqjE,OAAkFhsE,KADnE,OAAgBg2C,EAAezD,gBACRQ,mBAAmBiD,EAAertC,MAC9E,IACIojE,EAAQ9tE,OAAOC,EAAU83C,GAAgBjvC,KAAK,KACrCilE,IACD,QAA+B9tE,EAAU83C,EAAezD,eAAgByD,EAAertC,OAGnG,CACA,MAAOhB,GACHgJ,QAAQhJ,MAAMA,EAClB,CACA,OAAOd,QAAQC,QAAQ,CACnByrC,eAAgByD,EAAezD,eAC/B5pC,KAAMqtC,EAAertC,SAG7B9B,QAAQolE,WAAWJ,GAAwB9kE,KAAMmlE,IAC7C,MAAMC,EAAsBD,EACvB52D,OAAQkC,GAAmB,cAAbA,EAAE40D,QAChB/hE,IAAKmN,GAAMA,EAAEvV,OAeF/D,EAAS2xB,QACjB1E,iBAAiB,EAAAuoC,MAAA,OAAathC,eAftC,SAASi6C,EAAqB5xB,GAC1B,MAAM,QAAE5qB,EAAO,WAAED,GAAe6qB,EAAIhlB,OACpC5F,EAAQrE,oBAAoB,EAAAkoC,MAAA,OAAathC,eAAgBi6C,GACzDF,EAAoBlpE,QAASwyB,IACzB,MAAMhE,EAAc,CAChB7B,aACA2iB,eAAgB9c,EAAO8c,eACvB5pC,KAAM8sB,EAAO9sB,OAEjB,IAAAm6B,cAAa,EAAAxN,YAAa,SAAcg3C,sBAAuB,IACxD76C,KAGf,GAGAvzB,EAASD,UAEjB,CACA,8BAAA6tE,CAA+B5tE,GACrBwsE,KAAyBngD,EAAA,GAAMgiD,QACjC,EAAAC,EAAA,IAAQ7B,EAAA,GAEZ,MAAMrU,GAAY,IAAAC,yBAAwBr4D,EAASiN,IAC9CmrD,EAAUmW,QAAQ/B,KACnBpU,EAAUkW,QAAQ9B,GAClBpU,EAAUoW,eAAehC,GAEjC,G,6IC5JJ,MAAM,sBAAEtlC,GAA0B,YCJ3B,MCGCA,sBAAqB,GAAK,Y,+JCHlC,MAAMunC,EACJ,WAAAlrE,GACE,IAAImrE,EAAWC,UAAUjqE,OAAS,QAAsB5C,IAAjB6sE,UAAU,IAAmBA,UAAU,GAC9E7qE,KAAK4qE,SAAWA,EAChB5qE,KAAK8qE,QAAU,IAAI/6D,GACrB,CACA,UAAAg7D,GACE/qE,KAAK8qE,QAAQz4D,OACf,CACA,cAAA24D,CAAeC,EAAUC,GACvB,OAAOlrE,KAAK4qE,UAAYK,EAAWC,EAE5BD,EAAWC,EAAlB,IAA+BD,EAAWC,EAAW,GAAKA,EAAkBA,EAAWD,EAAlB,IAA+BC,EAAWD,EAAW,GAAKA,CACjI,CACA,gBAAAE,CAAiBF,EAAUC,EAAUE,GAEnC,MAAMjrE,EAAMH,KAAKgrE,eAAeC,EAAUC,GAC1C,IAAIt9B,EAAO5tC,KAAK8qE,QAAQ1qE,IAAID,GAU5B,OATKytC,IAEHA,EAAO,CACLztC,MACAkrE,OAAQrrE,KAAK8qE,QAAQ5hD,KACrBjpB,MAAOmrE,GAETprE,KAAK8qE,QAAQ5qE,IAAIC,EAAKytC,IAEjBA,CACT,CACA,UAAA09B,CAAWL,EAAUC,EAAUE,GAE7B,MAAMjrE,EAAMH,KAAKgrE,eAAeC,EAAUC,GACpCt9B,EAAO,CACXztC,MACAkrE,OAAQrrE,KAAK8qE,QAAQ5hD,KACrBjpB,MAAOmrE,GAGT,OADAprE,KAAK8qE,QAAQ5qE,IAAIC,EAAKytC,GACfA,CACT,CACA,cAAA29B,CAAeN,EAAUC,GACvB,MAAM/qE,EAAMH,KAAKgrE,eAAeC,EAAUC,GAC1C,OAAOlrE,KAAK8qE,QAAQ1qE,IAAID,EAC1B,CACA,sBAAOqrE,CAAgB59B,GACrB,MAAM1hB,EAAI,KAAQ,EAAIjvB,KAAK8nC,KAAK,EAAI6I,EAAKztC,IAAM,IACzC8qE,EAAWr9B,EAAKztC,IAAM,IAAO+rB,EAAI,GAAKA,EAE5C,MAAO,CAAC++C,EADS/+C,EAAI++C,EAEvB,EAMF,IAAIQ,EAAiB,CACnBC,YALF,WAEE,OAAO,IAAIf,GADSE,UAAUjqE,OAAS,QAAsB5C,IAAjB6sE,UAAU,GAAmBA,UAAU,GAAK,CAAC,GACpDD,SACvC,GChDA,MAAMe,EAAyB,CAAC,EAAE,GAAI,GAAI,GAAI,GAAI,GAAY,CAAC,EAAG,GAAI,GAAI,GAAI,GAAY,CAAC,EAAG,GAAI,GAAI,GAAI,GAAY,CAAC,EAAG,GAAI,GAAI,GAAI,GAAY,CAAC,EAAG,GAAI,GAAI,GAAI,GAAY,CAAC,EAAG,EAAG,EAAG,GAAI,GAAY,CAAC,EAAG,GAAI,GAAI,GAAI,GAAY,CAAC,EAAG,GAAI,GAAI,GAAI,GAAY,CAAC,EAAG,GAAI,GAAI,GAAI,GAAY,CAAC,EAAG,GAAI,GAAI,GAAI,GAAY,CAAC,EAAG,EAAG,EAAG,GAAI,GAAa,CAAC,EAAG,GAAI,GAAI,GAAI,GAAa,CAAC,EAAG,GAAI,GAAI,GAAI,GAAa,CAAC,EAAG,GAAI,GAAI,GAAI,GAAa,CAAC,EAAG,GAAI,GAAI,GAAI,GAAa,EAAE,GAAI,GAAI,GAAI,GAAI,IAEndC,EAAQ,CAAC,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,GAAI,CAAC,EAAG,IAa3C,IAAIC,EAAe,CACjBC,QAbF,SAAiBxjE,GACf,OAAOqjE,EAAuBrjE,EAChC,EAYEyjE,QATF,SAAiBC,GACf,OAAOJ,EAAMI,EACf,GCXA,MAAM,cACJC,EAAa,cACbC,GACE,EAAAC,EAMJ,SAASC,EAAwBC,EAAWC,GAmB1CA,EAAMC,eAAe9jE,KAAK,2BAM1B4jE,EAAUG,iBAAmB,IAAMF,EAAMG,cAMzCJ,EAAUK,iBAAmBC,IAC3BL,EAAMG,cAAgBE,EACtBN,EAAUz9B,YAEZ,MAAMg+B,EAAM,GACNC,EAAe,GACfC,EAAW,GACXC,EAActB,EAAeC,cAWnCW,EAAUW,gBAAkB,CAACtF,EAAKuF,EAAMvhC,EAASwhC,EAAYC,EAASC,KACpE,MAAO5jE,EAAGgH,EAAGI,GAAK82D,EAGlBkF,EAAI,GAAKh8D,EAAIq8D,EAAK,GAAKA,EAAK,GAAKz8D,EAAIy8D,EAAK,GAAKzjE,EAC/CojE,EAAI,GAAKA,EAAI,GAAKM,EAAWC,GAC7BP,EAAI,GAAKA,EAAI,GAAKM,EAAWE,GAC7BR,EAAI,GAAKA,EAAI,GAAKM,EAAWC,GAG7B,IAAK,IAAIE,EAAK,EAAGA,EAAK,IAAKA,EACzBR,EAAaQ,GAAM3hC,EAAQkhC,EAAIS,KAYnChB,EAAUiB,eAAiB,CAAC5F,EAAK9/D,EAAQD,EAASwlE,EAASC,KACzD,MAAM5jE,EAAIk+D,EAAIyF,GACR38D,EAAIk3D,EAAI0F,GAGdN,EAAS,GAAKllE,EAAOulE,GAAW3jE,EAAI7B,EAAQwlE,GAC5CL,EAAS,GAAKllE,EAAOwlE,GAAW58D,EAAI7I,EAAQylE,GAC5CN,EAAS,GAAKA,EAAS,GAAKnlE,EAAQwlE,GACpCL,EAAS,GAAKA,EAAS,GACvBA,EAAS,GAAKA,EAAS,GACvBA,EAAS,GAAKA,EAAS,GAAKnlE,EAAQylE,GACpCN,EAAS,GAAKA,EAAS,GACvBA,EAAS,GAAKA,EAAS,IAiBzBT,EAAUkB,aAAe,CAACC,EAAM9F,EAAKuF,EAAMrlE,EAAQD,EAAS+jC,EAAS1+B,EAAQqjD,EAAO6c,EAAYC,EAASC,KACvG,MAAMx8D,EAAI82D,EAAI4E,EAAMmB,aACdC,EAAY,CAAC,EAAG,EAAG,EAAG,GACtBvgE,EAAM,GACZ,IAAIwgE,EACJtB,EAAUW,gBAAgBtF,EAAKuF,EAAMvhC,EAASwhC,EAAYC,EAASC,GACnE,IAAI9kE,EAAQ,EACZ,IAAK,IAAIslE,EAAM,EAAGA,EAAM,EAAGA,IACrBf,EAAae,IAAQJ,IACvBllE,GAASolE,EAAUE,IAIvB,MAAMC,EAAahC,EAAaC,QAAQxjE,GACxC,GAAIulE,EAAW,GAAK,EAClB,OAGFxB,EAAUiB,eAAe5F,EAAK9/D,EAAQD,EAASwlE,EAASC,GACxD,MAAMhgE,EAAIxF,EAAO0kE,EAAMmB,aAAe78D,EAAIjJ,EAAQ2kE,EAAMmB,aACxD,IAAK,IAAIG,EAAM,EAAGC,EAAWD,IAAQ,EAAGA,GAAO,EAAG,CAChDvd,EAAM5nD,KAAK,GACX,IAAK,IAAIujE,EAAM,EAAGA,EAAM,EAAGA,IAAO,CAChC,MAAM8B,EAAYjC,EAAaE,QAAQ8B,EAAWD,EAAM5B,IAKxD,GAJA2B,OAAM3vE,EACFsuE,EAAMyB,cACRJ,EAAMZ,EAAYxB,eAAeqB,EAAIkB,EAAU,IAAKlB,EAAIkB,EAAU,MAAM7tE,YAE9DjC,IAAR2vE,EAAmB,CACrB,MAAM/jC,GAAK4jC,EAAOX,EAAaiB,EAAU,MAAQjB,EAAaiB,EAAU,IAAMjB,EAAaiB,EAAU,KAC/F1kC,EAAK0jC,EAASpsE,MAAqB,EAAfotE,EAAU,GAA6B,GAApBA,EAAU,GAAK,IACtDlnD,EAAKkmD,EAASpsE,MAAqB,EAAfotE,EAAU,GAA6B,GAApBA,EAAU,GAAK,IAC5D3gE,EAAIggE,GAAW/jC,EAAG,GAAKQ,GAAKhjB,EAAG,GAAKwiB,EAAG,IACvCj8B,EAAIigE,GAAWhkC,EAAG,GAAKQ,GAAKhjB,EAAG,GAAKwiB,EAAG,IACvCj8B,EAAIm/D,EAAMmB,aAAergE,EACzBugE,EAAM3gE,EAAOpM,OAAS,EACtBoM,EAAOvE,KAAK0E,EAAI,GAAIA,EAAI,GAAIA,EAAI,IAC5Bm/D,EAAMyB,aACRhB,EAAYzB,WAAWsB,EAAIkB,EAAU,IAAKlB,EAAIkB,EAAU,IAAKH,EAEjE,CACAtd,EAAM5nD,KAAKklE,EACb,CACF,GAEFtB,EAAU2B,YAAc,CAACC,EAAQC,KAE/B,MAAMpmD,EAAQmmD,EAAO,GACrB,IAAKnmD,EAEH,YADAmkD,EAAc,4BAGhB,GAAyB,MAArBK,EAAMmB,aAAuBnB,EAAMmB,YAAc,GAAKnB,EAAMmB,YAAc,EAE5E,YADAxB,EAAc,mCAGhBt9D,QAAQs5C,KAAK,YAGb,MAAMrgD,EAASkgB,EAAMqmD,YACfxmE,EAAUmgB,EAAMinC,aAChBke,EAAOnlD,EAAMnE,gBACbyqD,EAAStmD,EAAMX,YACf+lD,EAAaplD,EAAMumD,kBAAkBD,GACrC1iC,EAAU5jB,EAAM6jB,eAAeC,aAAaC,WAC3CshC,EAASC,GAjKlB,WACE,IAAID,EAAU,EACVC,EAAU,EAQd,OAP0B,IAAtBd,EAAMmB,aACRN,EAAU,EACVC,EAAU,GACqB,IAAtBd,EAAMmB,cACfN,EAAU,EACVC,EAAU,GAEL,CAACD,EAASC,EACnB,CAsJ6BkB,GAGrBthE,EAAS,GAGTqjD,EAAQ,GAGd,IAAIz/C,EAAI3T,KAAK0kB,MAAM2qD,EAAM5rE,OACrBkQ,GAAKq8D,EAAKX,EAAMmB,eAClB78D,EAAI,GAIN,MAAM82D,EAAM,CAAC,EAAG,EAAG,GACnBA,EAAI4E,EAAMmB,aAAe78D,EACzB,IAAK,IAAI29D,EAAK,EAAGA,EAAKjC,EAAMG,cAAc7rE,SAAU2tE,EAAI,CACtD,IAAK,IAAI/9D,EAAI,EAAGA,EAAIy8D,EAAKG,GAAW,IAAK58D,EAAG,CAC1Ck3D,EAAI0F,GAAW58D,EACf,IAAK,IAAIhH,EAAI,EAAGA,EAAIyjE,EAAKE,GAAW,IAAK3jE,EACvCk+D,EAAIyF,GAAW3jE,EACf6iE,EAAUkB,aAAajB,EAAMG,cAAc8B,GAAK7G,EAAKuF,EAAMrlE,EAAQD,EAAS+jC,EAAS1+B,EAAQqjD,EAAO6c,EAAYC,EAASC,EAE7H,CACAL,EAAYhC,YACd,CAGA,MAAMyD,EAAW,mBACjBA,EAAStd,YAAYud,QAAQ,IAAI1lE,aAAaiE,GAAS,GACvDwhE,EAASrd,WAAWsd,QAAQ,IAAIC,YAAYre,IAC5C6d,EAAQ,GAAKM,EACbtC,EAAc,mBACdv9D,QAAQggE,QAAQ,YAEpB,CAMA,MAAMC,EAAiB,CACrBnC,cAAe,GACfgB,YAAa,EACb/sE,MAAO,EACPqtE,aAAa,GAKf,SAAS3sE,EAAOirE,EAAWC,GACzB,IAAIuC,EAAgBhE,UAAUjqE,OAAS,QAAsB5C,IAAjB6sE,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzFjrE,OAAO+wC,OAAO27B,EAAOsC,EAAgBC,GAGrC,EAAA1C,EAAM/sD,IAAIitD,EAAWC,GAGrB,EAAAH,EAAM2C,KAAKzC,EAAWC,EAAO,EAAG,GAChC,EAAAH,EAAM4C,OAAO1C,EAAWC,EAAO,CAAC,cAAe,QAAS,gBAGxD,EAAAH,EAAM2C,KAAKzC,EAAWC,EAAO,EAAG,GAChCF,EAAwBC,EAAWC,EACrC,CAQA,IAAI0C,EAA4B,CAC9BtD,YALkB,EAAAS,EAAMT,YAAYtqE,EAAQ,2BAM5CA,U,kECpPF,MAAM,aAAE6tE,GAAiB,EAAAhrB,UACnBirB,EAAgB,CAClBC,mBAAoB,CAACznE,EAAYvC,IACtB8pE,EAAaG,+BAA+B,CAC/C1nE,aACAvC,eAGRkqE,oBAAsBC,IAClB,MAAM,WAAEnqE,EAAU,WAAEuC,EAAU,QAAEC,EAAO,OAAEC,EAAM,UAAEE,GAAcwnE,EAE/D,MAAO,CACHtqE,aAFiBkqE,EAAcC,mBAAmBznE,EAAYvC,GAG9DuC,aACAC,UACAC,SACAE,YACA3C,eAGRoqE,mBAAoB,CAAC7nE,EAAYE,EAAQE,EAAWH,EAASxC,KACzD,MAAMke,EAAY,mBAKlB,GAJAA,EAAUmsD,cAAc9nE,GACxB2b,EAAUosD,UAAU7nE,GACpByb,EAAUqsD,aAAa5nE,GACvBub,EAAUssD,WAAWhoE,IAChBxC,EACD,OAAOke,EAEX,MAAMusD,EAAc,iBAAyB,CACzCtvE,KAAM,UACN2E,mBAAoB,EACpBmU,OAAQjU,IAGZ,OADAke,EAAUsoB,eAAekkC,WAAWD,GAC7BvsD,GAEXysD,yBAA0B,EAAGC,kBAAiBC,oBAAmB9H,UAASjhD,SAAQ5D,gBAC9E0sD,EAAgB9uE,QAAQ,EAAGhB,QAAOqsC,WAAUM,WAAUtkC,YAClD,IAAgC,IAA5B4/D,EAAQllE,QAAQ/C,GAChB,OAEJ,MAAMgwE,EAAaD,EAAkBjjC,WAAWzkC,GAChD0/D,EAAuBI,cAAc,CACjCt2B,aAAc7xC,EACdA,MAAOgwE,EACP3jC,WACAM,cAEL,CACCl5B,UAAWuT,GAAU+oD,EAAkBE,mBACvC7sD,eAGR8sD,uBAAwB,CAAC9sD,EAAW6vB,EAAa,KAAMu6B,EAAc,QACjE,MAAMrpE,EAAU,CAAC,EACE,OAAf8uC,IACA9uC,EAAQ1D,MAAQwyC,GAEA,OAAhBu6B,IACArpE,EAAQqpE,YAAcA,GAE1B,MAAM2C,EAAW,cAAoChsE,GAIrD,OAHAgsE,EAASC,aAAahtD,GACtB+sD,EAAS1D,iBAAiB,CAAC,IAC3B0D,EAASE,gBAAe,GACjBF,EAASG,iBAEpBC,2BAA4B,CAACC,EAAUv9B,EAAa,QAChD,MAAMw9B,GAAa,EAAA3f,EAAA,GAAiC0f,GACpD,GAAIC,EAAW1jE,QAAQpM,OAAQ,CAE3B,MAAO,CACH+vE,UAFa,QAA2BD,EAAWrgB,OAGnDW,SAAU0f,EAElB,CACA,OAAO,MAEXE,0BAA4B1I,GACjB,CAAC,QAASA,EAAQ7/D,IAAKC,IAAU,CAAGwpC,aAAcxpC,MAE7DuoE,gBAAkBC,IACd,MAAM,iBAAEC,EAAgB,UAAEC,GAAcF,EAOxC,MAAO,CACHtgC,aAAcugC,GANP7B,EAAcG,oBAAoB0B,GAOzCv1E,MAAOw1E,GAJA9B,EAAcG,oBAAoB2B,KAOjDC,kCAAoCH,IAChC,MAAM,KAAEnpB,EAAI,QAAEugB,EAAO,KAAEtoB,GAASkxB,GAC1B,aAAEtgC,EAAY,MAAEh1C,GAAU0zE,EAAc2B,gBAAgBC,IACtD9rE,aAAc+qE,EAAiBpoE,QAASupE,GAAwB1gC,GAChExrC,aAAcgrE,GAAsBx0E,EACtC6nB,EAAY6rD,EAAcK,mBAAmB/+B,EAAa9oC,WAAY8oC,EAAa5oC,OAAQ4oC,EAAa1oC,UAAW0oC,EAAa7oC,SACtIqgE,EAAuBG,UAAU,CAAErT,gBAAgB,EAAOoT,UAASvgB,SACnEunB,EAAcY,yBAAyB,CACnCC,kBACAC,oBACA9H,UACA7kD,cAOJ,OALc2kD,EAAuBne,cAAc,CAC/CliD,QAASupE,EACTvpB,OACA/H,UAIR,qBAAAuxB,EAAsB,iBAAEJ,EAAgB,UAAEC,IACtC,MAAM,WAAE7rE,EAAU,WAAEuC,EAAU,QAAEC,EAAO,OAAEC,EAAM,UAAEE,GAAcipE,GACvDppE,QAASypE,EAAc1pE,WAAY2pE,EAAiBvpE,UAAWwpE,EAAgB1pE,OAAQ2pE,EAAapsE,WAAYyB,GAAqBoqE,EACvIjB,EAAkBb,EAAcC,mBAAmB4B,EAAiBrpE,WAAYqpE,EAAiB5rE,YACjGqsE,EAAkBtC,EAAcC,mBAAmBkC,EAAiBzqE,GAC1E,IAAI6qE,EAAM,EACNxwD,EAAY,EAChB,MAAMywD,EAAmB3B,EAAgB4B,sBACzC,IAAK,IAAInoE,EAAI,EAAGA,EAAIkoE,EAAkBloE,IACI,IAAlCumE,EAAgBhjC,WAAWvjC,KAC3BioE,GAAOD,EAAgBzkC,WAAWvjC,GAClCyX,KAWR,MAAO,CACH2wD,KATS,KAAO3wD,EAAYtZ,EAAQ,GAAKA,EAAQ,GAAKA,EAAQ,GAU9DkqE,KATe5wD,EAAY,EAAIwwD,EAAMxwD,EAAY,GAEjDA,EACAmwD,EAAa,GACbA,EAAa,GACbA,EAAa,GACb,KAKR,EACAU,iCAAmChB,IAC/B,MAAM,iBAAEC,EAAgB,UAAEC,EAAS,QAAE9I,EAAO,KAAEvgB,GAASmpB,EACvD9I,EAAuBG,UAAU,CAAErT,gBAAgB,EAAMoT,UAASvgB,SAClE,IAAK,IAAIn+C,EAAI,EAAGA,EAAIunE,EAAiBnwE,OAAQ4I,IAAK,CAC9C,MAAMuoE,EAAUhB,EAAiBvnE,GAC3BwoE,EAAUhB,EAAUxnE,GACpByoE,EAAgB,CAClBF,EAAQrqE,WAAW,GACnBqqE,EAAQrqE,WAAW,GACnB,GAEEqoE,EAAkBb,EAAcC,mBAAmB8C,EAAeF,EAAQ5sE,YAC1E6qE,EAAoBd,EAAcC,mBAAmB8C,EAAeD,EAAQ7sE,YAC5Eke,EAAY6rD,EAAcK,mBAAmB0C,EAAeF,EAAQnqE,OAAQmqE,EAAQjqE,UAAWiqE,EAAQpqE,SAC7GunE,EAAcY,yBAAyB,CACnCC,kBACAC,oBACA9H,UACA7kD,aAER,CACA,MAAM1b,EAAUopE,EAAiB,GAAGppE,QAKpC,OAJcqgE,EAAuBne,cAAc,CAC/CliD,UACAggD,UAIRuqB,uCAAyCpB,IACrC,MAAM,iBAAEC,EAAgB,UAAEC,EAAS,QAAE9I,EAAO,KAAEvgB,EAAI,QAAEwqB,GAAYrB,EAChE,IAAItgC,EASJ,QAJOA,gBAJF2hC,EAImBjD,EAAc2B,gBAAgB,CAC9CE,iBAAkBA,EAAiB,KAJnB7B,EAAc2B,gBAAgBC,IAO/CqB,EACDjD,EAAckD,4BAA4B,CACxCrB,mBACA7I,UACAvgB,SAEFunB,EAAcmD,iCAAiC,CAC7C7hC,eACA03B,UACAvgB,UAGZ2qB,qCAAsC,CAAC3B,EAAU1K,EAAan0B,KAC1D,IAAIygC,EACJ,IAAK,MAAMvM,KAAgB2K,EAAU,CACjC,MAAM6B,GAAgB,OAA4BxM,EAAcC,EAAasM,GACxEC,IAGLD,EAAmBC,EACvB,CACA,OAAID,EACO,CACHzgC,eACA2R,UAAW8uB,EAAiB9uB,UAC5BC,UAAW6uB,EAAiB7uB,UAC5ByiB,SAAUoM,EAAiBpM,SAC3BC,SAAUmM,EAAiBnM,UAG5B,MAEXgM,4BAA6B,EAAGrB,mBAAkB7I,UAASvgB,WACvD,MAAM9V,EAAWq9B,EAAc0B,0BAA0B1I,GACzD,IAAIuK,EAAuB,GAC3B,IAAK,IAAIjpE,EAAI,EAAGA,EAAIunE,EAAiBnwE,OAAQ4I,IAAK,CAC9C,MAAMuoE,EAAUhB,EAAiBvnE,GAC3B9B,EAAaqqE,EAAQrqE,WACrBgrE,EAAgBX,EAAQ5sE,YACxB,QAAEwC,EAAO,UAAEG,EAAS,OAAEF,GAAWmqE,EACjC/sE,EAAekqE,EAAcC,mBAAmBznE,EAAYgrE,GAC5DjL,EAAiB//D,EAAW,GAAKA,EAAW,GAClD,IAAK,IAAIirE,EAAW,EAAGA,EAAW9gC,EAASjxC,OAAQ+xE,IAAY,CAC3D,MAAMv9B,EAAUvD,EAAS8gC,GACzB,IAAKv9B,EACD,SAEJ,MAAMtD,EAAesD,EAAQtD,aAC7B,GAAIo9B,EAAc0D,6BAA6B,EAAGF,EAAejL,EAAgB31B,GAC7E,SAEJ,MAAM+gC,EAAgB,GAChBC,EAAe,IAAIhqE,WAAW4pE,EAAc9xE,QAClD,IAAK,IAAI4I,EAAI,EAAGA,EAAIkpE,EAAc9xE,OAAQ4I,IACtCspE,EAAatpE,GAAKkpE,EAAclpE,KAAOsoC,EAAe,EAAI,EAE9D,MAAM89B,EAAc,iBAAyB,CACzCtvE,KAAM,SACN2E,mBAAoB,EACpBmU,OAAQ05D,IAENzvD,EAAY6rD,EAAcK,mBAAmB7nE,EAAYE,EAAQE,EAAW,CAACH,EAAQ,GAAIA,EAAQ,GAAI,IAC3G0b,EAAUsoB,eAAekkC,WAAWD,GACpC,IACI,MAAMa,EAAWvB,EAAciB,uBAAuB9sD,EAAW,KAAM,GACjE0vD,EAAc7D,EAAcsB,2BAA2BC,GACzDsC,GACAF,EAAcpqE,KAAKsqE,EAE3B,CACA,MAAO9kE,GACHU,QAAQC,KAAKX,EACjB,CACA,MAAMg4D,GAAc,QAA0B,CAC1Cv+D,aACA2b,YACAre,eACA8sC,iBAEEkhC,EAAsB9D,EAAcoD,qCAAqCO,EAAe5M,EAAan0B,GACvGkhC,GACAP,EAAqBhqE,KAAKuqE,EAElC,CACJ,CACA,OAAOP,GAEXJ,iCAAkC,EAAG7hC,eAAc03B,UAASvgB,WACxD,MAAM,aAAE3iD,EAAY,WAAE0C,EAAU,OAAEE,EAAM,UAAEE,EAAS,QAAEH,GAAY6oC,EAC3DntB,EAAY6rD,EAAcK,mBAAmB7nE,EAAYE,EAAQE,EAAWH,GAC5EsrE,EAAc/D,EAAcgE,sCAAsC,CACpE1iC,eACA03B,UACA7kD,YACAskC,SAEE8qB,EAAuB,GAC7B,IAAK,IAAIjpE,EAAI,EAAGA,EAAIypE,EAAYryE,OAAQ4I,IAAK,CACzC,MAAM2pE,EAAaF,EAAYzpE,IACzB,aAAEsoC,GAAiBqhC,EAAW/9B,QAC9Bu7B,EAAWwC,EAAWN,cACtB5M,GAAc,QAA0B,CAC1Cv+D,aACA2b,YACAre,eACA8sC,iBAEEkhC,EAAsB9D,EAAcoD,qCAAqC3B,EAAU1K,EAAan0B,GAClGkhC,GACAP,EAAqBhqE,KAAKuqE,EAElC,CACA,OAAOP,GAEXS,sCAAwCpC,IACpC,MAAM,aAAEtgC,EAAY,QAAE03B,GAAY4I,GAC5B,WAAEppE,EAAU,WAAEvC,EAAU,OAAEyC,EAAM,UAAEE,EAAS,QAAEH,GAAY6oC,EAC/D,IAAIntB,EAAYytD,EAAKztD,UAChBA,IACDA,EAAY6rD,EAAcK,mBAAmB7nE,EAAYE,EAAQE,EAAWH,IAEhF,MAAM08B,EAAY38B,EAAW,GACvB+/D,EAAiB//D,EAAW,GAAKA,EAAW,GAC5CmqC,EAAWq9B,EAAc0B,0BAA0B1I,GACzD,IAAK,IAAI96D,EAAI,EAAGA,EAAIi3B,EAAWj3B,IAC3B,IAAK,IAAI5P,EAAI,EAAGA,EAAIkK,EAAW,GAAIlK,IAAK,CACpC,MAAM8K,EAAQ9K,EAAIkK,EAAW,GAAK0F,EAAIq6D,EACtCtiE,EAAWmD,GAAS,EACpBnD,EAAWmD,EAAQZ,EAAW,GAAK,GAAK,CAC5C,CAEJ,MAAM0rE,EAAc,GACdC,EAAcxhC,EAASjxC,OAC7B,IAAK,IAAI+xE,EAAW,EAAGA,EAAWU,EAAaV,IAAY,CACvD,MAAMv9B,EAAUvD,EAAS8gC,GACzB,IAAKv9B,EACD,SAEJ,MAAMtD,EAAesD,EAAQtD,aACvB+gC,EAAgB,GAChBnnC,EAAU,iBAAyB,CACrCprC,KAAM,UACN2E,mBAAoB,EACpBikB,KAAMu+C,EAAiBpjC,EACvB36B,SAAU,eAEd,IAAK,IAAIwpC,EAAa,EAAGA,EAAa7O,EAAW6O,IAAc,CAC3D,GAAIg8B,EAAc0D,6BAA6B1/B,EAAY/tC,EAAYsiE,EAAgB31B,GACnF,SAEJ,MAAMwhC,EAAapgC,EAAau0B,EAChC,IACI,IAAK,IAAIj+D,EAAI,EAAGA,EAAIi+D,EAAgBj+D,IAAK,CACvBrE,EAAWqE,EAAI8pE,KACfxhC,EACVpG,EAAQmiB,SAASrkD,EAAI8pE,EAAY,GAGjC5nC,EAAQmiB,SAASrkD,EAAG,EAE5B,CACA,MAAM+pE,EAAgB,mBACtBA,EAAcC,YAAYnwD,GAC1BkwD,EAAc5nC,eAAekkC,WAAWnkC,GACxC,MAAM+kC,EAAWvB,EAAciB,uBAAuBoD,EAAergC,GAC/D6/B,EAAc7D,EAAcsB,2BAA2BC,EAAUv9B,GACnE6/B,GACAF,EAAcpqE,KAAKsqE,EAE3B,CACA,MAAO9kE,GACHU,QAAQC,KAAKskC,GACbvkC,QAAQC,KAAKX,EACjB,CACJ,CACA,MAAMwlE,EAAa,CACfZ,gBACAz9B,WAEJg+B,EAAY3qE,KAAKgrE,EACrB,CACA,OAAOL,GAEXR,6BAA8B,CAAC1/B,EAAYwgC,EAASjM,EAAgBkL,KAChE,MAAMgB,EAAWzgC,EAAau0B,EACxBmM,EAASD,EAAWlM,EAC1B,IAAK,IAAIj+D,EAAImqE,EAAUnqE,EAAIoqE,EAAQpqE,IAC/B,GAAIkqE,EAAQlqE,KAAOmpE,EACf,OAAO,EAGf,OAAO,KAGf,OAAOzD,E,oCC9UP,IAAI2E,EAAY,CACdC,wBAjB8B,CAC9BC,UAAW,EACXC,YAAa,EACbC,SAAU,EACVC,QAAS,GAcTC,oBA3C0B,CAC1BC,IAAK,EACLC,MAAO,EACPC,QAAS,GAyCTC,eAvDqB,CACrBC,QAAS,EACTC,QAAS,EACTC,QAAS,EACTC,QAAS,EACTC,QAAS,EACTC,UAAW,EACXC,YAAa,EACbC,SAAU,EACVC,eAAgB,GA+ChBC,eAxCqB,CACrBC,cAAe,EAEfC,qBAAsB,EAEtBC,oBAAqB,EAErBC,YAAa,EAEbC,aAAc,GAEdC,WAAY,IA8BZC,uBAb6B,CAC7BC,QAAS,EAETC,OAAQ,EAERC,OAAQ,GASRC,gBA5BsB,CACtBC,eAAgB,EAEhBC,YAAa,GA0BbC,eAhBqB,e,oHCnCvB,MAAM,cACJ9J,GACE,EAAAE,EAwTJ,MAAMyC,EAAiB,CACrB9mE,UAAW,KAEX8b,aAAc,KAEdkV,aAAc,KAEdnxB,QAAS,CAAC,EAAK,EAAK,GACpBC,OAAQ,CAAC,EAAK,EAAK,GACnBwmE,OAAQ,CAAC,GAAI,EAAG,GAAI,EAAG,GAAI,GAC3B4H,gBAAiB,IAAeC,OAKlC,SAAS70E,EAAOirE,EAAWC,GACzB,IAAIuC,EAAgBhE,UAAUjqE,OAAS,QAAsB5C,IAAjB6sE,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzFjrE,OAAO+wC,OAAO27B,EAAOsC,EAAgBC,GAGrC,YAAkBxC,EAAWC,EAAOuC,GAC/BvC,EAAMxkE,UAEApJ,MAAMC,QAAQ2tE,EAAMxkE,aAC7BwkE,EAAMxkE,UAAY,IAAIouE,aAAa5J,EAAMxkE,UAAUpH,MAAM,EAAG,KAF5D4rE,EAAMxkE,UAAY,cAAc,IAAIouE,aAAa,IAInD5J,EAAM1oD,aAAe,IAAIsyD,aAAa,IACtC5J,EAAMxzC,aAAe,IAAIo9C,aAAa,IAGtC,EAAA/J,EAAM/rE,IAAIisE,EAAWC,EAAO,CAAC,eAAgB,iBAC7C,EAAAH,EAAMgK,YAAY9J,EAAWC,EAAO,CAAC,SAAU,WAAY,GAC3D,EAAAH,EAAMgK,YAAY9J,EAAWC,EAAO,CAAC,aAAc,GACnD,EAAAH,EAAMiK,SAAS/J,EAAWC,EAAO,CAAC,UAAW,GAnV/C,SAAsBD,EAAWC,GAE/BA,EAAMC,eAAe9jE,KAAK,gBAC1B4jE,EAAUgK,UAAY,WACpB,GAAI/J,EAAMgK,QAER,OADArK,EAAc,8CACP,EAET,IAAK,IAAIsK,EAAO1L,UAAUjqE,OAAQ41E,EAAW,IAAI93E,MAAM63E,GAAOE,EAAO,EAAGA,EAAOF,EAAME,IACnFD,EAASC,GAAQ5L,UAAU4L,GAE7B,MAAMC,EAAkC,IAApBF,EAAS51E,OAAe41E,EAAS,GAAKA,EAC1D,GAA2B,IAAvBE,EAAY91E,OACd,OAAO,EAET,MAAM+1E,EAAiBrK,EAAM8B,OAAOzmD,KAAK,CAAChU,EAAMrL,IAAUqL,IAAS+iE,EAAYpuE,IAM/E,OALIquE,IACFrK,EAAM8B,OAASsI,EAAYh2E,QAC3B4rE,EAAM0J,gBAAkB,iCAA+C1J,EAAM8B,QAC7E/B,EAAUz9B,YAEL+nC,CACT,EACAtK,EAAUmD,cAAgB,WACxB,IAAIhmE,EACAgH,EACAI,EACJ,GAAI07D,EAAMgK,QACRrK,EAAc,iDADhB,CAIA,GAAyB,IAArBpB,UAAUjqE,OAAc,CAC1B,MAAM2K,EAAQs/D,UAAUjqE,QAAU,OAAI5C,EAAY6sE,UAAU,GAC5DrhE,EAAI+B,EAAM,GACViF,EAAIjF,EAAM,GACVqF,EAAIrF,EAAM,EACZ,KAAO,IAAyB,IAArBs/D,UAAUjqE,OAMnB,YADAqrE,EAAc,+BAJdziE,EAAIqhE,UAAUjqE,QAAU,OAAI5C,EAAY6sE,UAAU,GAClDr6D,EAAIq6D,UAAUjqE,QAAU,OAAI5C,EAAY6sE,UAAU,GAClDj6D,EAAIi6D,UAAUjqE,QAAU,OAAI5C,EAAY6sE,UAAU,EAIpD,CACAwB,EAAUgK,UAAU,EAAG7sE,EAAI,EAAG,EAAGgH,EAAI,EAAG,EAAGI,EAAI,EAd/C,CAeF,EACAy7D,EAAU1oD,cAAgB,IAAM,CAAC2oD,EAAM8B,OAAO,GAAK9B,EAAM8B,OAAO,GAAK,EAAG9B,EAAM8B,OAAO,GAAK9B,EAAM8B,OAAO,GAAK,EAAG9B,EAAM8B,OAAO,GAAK9B,EAAM8B,OAAO,GAAK,GACnJ/B,EAAU9a,iBAAmB,KAC3B,MAAM0b,EAAOZ,EAAU1oD,gBACvB,IAAIizD,EAAS,EACb,IAAK,IAAIptE,EAAI,EAAGA,EAAI,EAAGA,IAAK,CAC1B,GAAgB,IAAZyjE,EAAKzjE,GACP,OAAO,EAELyjE,EAAKzjE,GAAK,IACZotE,GAAU3J,EAAKzjE,GAAK,EAExB,CACA,OAAOotE,GAETvK,EAAUhb,kBAAoB,KAC5B,MAAM4b,EAAOZ,EAAU1oD,gBACvB,OAAOspD,EAAK,GAAKA,EAAK,GAAKA,EAAK,IAElCZ,EAAU1gE,SAAWrD,IACnB,MAAM2kE,EAAOZ,EAAU1oD,gBACvB,GAAgB,IAAZspD,EAAK,IAAwB,IAAZA,EAAK,IAAwB,IAAZA,EAAK,GAEzC,OADAhB,EAAc,2CACP,KAET,MAAMvE,EAAM,IAAIwO,aAAa,GAC7B,OAAQ5J,EAAM0J,iBACZ,KAAK,IAAeC,MAClB,OAAO,KACT,KAAK,IAAeY,aAClB,MACF,KAAK,IAAeC,OAClBpP,EAAI,GAAKp/D,EACT,MACF,KAAK,IAAeyuE,OAClBrP,EAAI,GAAKp/D,EACT,MACF,KAAK,IAAe0uE,OAClBtP,EAAI,GAAKp/D,EACT,MACF,KAAK,IAAe2uE,SAClBvP,EAAI,GAAKp/D,EAAQ2kE,EAAK,GACtBvF,EAAI,GAAKp/D,EAAQ2kE,EAAK,GACtB,MACF,KAAK,IAAeiK,SAClBxP,EAAI,GAAKp/D,EAAQ2kE,EAAK,GACtBvF,EAAI,GAAKp/D,EAAQ2kE,EAAK,GACtB,MACF,KAAK,IAAekK,SAClBzP,EAAI,GAAKp/D,EAAQ2kE,EAAK,GACtBvF,EAAI,GAAKp/D,EAAQ2kE,EAAK,GACtB,MACF,KAAK,IAAemK,SAClB1P,EAAI,GAAKp/D,EAAQ2kE,EAAK,GACtBvF,EAAI,GAAKp/D,EAAQ2kE,EAAK,GAAKA,EAAK,GAChCvF,EAAI,GAAKp/D,GAAS2kE,EAAK,GAAKA,EAAK,IACjC,MACF,QACEhB,EAAc,2BAGlB,MAAMoL,EAAS,CAAC,EAAG,EAAG,GAEtB,OADAhL,EAAUzoD,aAAa8jD,EAAK2P,GACrBA,GA8BThL,EAAUiL,UAAY,IAAMjL,EAAUnlD,eAAemlD,EAAUkL,oBAC/DlL,EAAUnlD,eAAiBswD,GAAM,qBAA+BA,EAAIlL,EAAM1oD,cAC1EyoD,EAAUkL,iBAAmB,IAAM,aAAuB,IAAIjL,EAAM8B,QAAS,IAG7E/B,EAAUoL,kBAAoB,KAC5B,qBAAqBnL,EAAM1oD,aAAc0oD,EAAM1kE,QAC/C0kE,EAAM1oD,aAAa,GAAK0oD,EAAMxkE,UAAU,GACxCwkE,EAAM1oD,aAAa,GAAK0oD,EAAMxkE,UAAU,GACxCwkE,EAAM1oD,aAAa,GAAK0oD,EAAMxkE,UAAU,GACxCwkE,EAAM1oD,aAAa,GAAK0oD,EAAMxkE,UAAU,GACxCwkE,EAAM1oD,aAAa,GAAK0oD,EAAMxkE,UAAU,GACxCwkE,EAAM1oD,aAAa,GAAK0oD,EAAMxkE,UAAU,GACxCwkE,EAAM1oD,aAAa,GAAK0oD,EAAMxkE,UAAU,GACxCwkE,EAAM1oD,aAAa,GAAK0oD,EAAMxkE,UAAU,GACxCwkE,EAAM1oD,aAAa,IAAM0oD,EAAMxkE,UAAU,GACzC,WAAWwkE,EAAM1oD,aAAc0oD,EAAM1oD,aAAc0oD,EAAM3kE,SACzD,YAAY2kE,EAAMxzC,aAAcwzC,EAAM1oD,eAExCyoD,EAAUzoD,aAAe,SAAU8zD,GACjC,IAAIC,EAAO9M,UAAUjqE,OAAS,QAAsB5C,IAAjB6sE,UAAU,GAAmBA,UAAU,GAAK,GAE/E,OADA,mBAAmB8M,EAAMD,EAAKpL,EAAM1oD,cAC7B+zD,CACT,EACAtL,EAAUuL,iBAAmBvL,EAAUzoD,aACvCyoD,EAAUvzC,aAAe,SAAU4+C,GACjC,IAAIC,EAAO9M,UAAUjqE,OAAS,QAAsB5C,IAAjB6sE,UAAU,GAAmBA,UAAU,GAAK,GAE/E,OADA,mBAAmB8M,EAAMD,EAAKpL,EAAMxzC,cAC7B6+C,CACT,EACAtL,EAAUwL,iBAAmBxL,EAAUvzC,aACvCuzC,EAAUyL,mBAAqB,SAAUC,GACvC,IAAIC,EAAOnN,UAAUjqE,OAAS,QAAsB5C,IAAjB6sE,UAAU,GAAmBA,UAAU,GAAK,GAC/E,OAAO,qBAA+BkN,EAAKzL,EAAM1oD,aAAco0D,EACjE,EACA3L,EAAU4L,mBAAqB,SAAUF,GACvC,IAAIC,EAAOnN,UAAUjqE,OAAS,QAAsB5C,IAAjB6sE,UAAU,GAAmBA,UAAU,GAAK,GAC/E,OAAO,qBAA+BkN,EAAKzL,EAAMxzC,aAAck/C,EACjE,EAGA3L,EAAU6L,WAAW7L,EAAUoL,mBAC/BpL,EAAUoL,oBACVpL,EAAU8L,UAAY,IAAM,eAAyB9L,EAAUiL,aAC/DjL,EAAU+L,iBAAmB,SAAUC,GACrC,IAAIC,EAAgBzN,UAAUjqE,OAAS,QAAsB5C,IAAjB6sE,UAAU,GAAmBA,UAAU,GAAK,KACxF,MAAM5jD,EAAS,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GAC/BolD,EAAU4L,mBAAmBI,EAAapxD,GAC1C,MAAMu/C,EAAS,CAAC,EAAG,EAAG,GAChBC,EAAS,CAAC,EAAG,EAAG,GACtB,yBAAmCx/C,EAAQu/C,EAAQC,IACnD,OAAYD,EAAQA,IACpB,OAAYC,EAAQA,GACpB,MAAM/+D,EAAa2kE,EAAU1oD,iBAC7B,IAAAkZ,GAAY2pC,EAAQ,CAAC,EAAG,EAAG,GAAI,CAAC9+D,EAAW,GAAK,EAAGA,EAAW,GAAK,EAAGA,EAAW,GAAK,GAAI8+D,IAC1F,IAAA3pC,GAAY4pC,EAAQ,CAAC,EAAG,EAAG,GAAI,CAAC/+D,EAAW,GAAK,EAAGA,EAAW,GAAK,EAAGA,EAAW,GAAK,GAAI++D,GAC1F,MAAM8R,EAAU7wE,EAAW,GACrB8wE,EAAU9wE,EAAW,GAAKA,EAAW,GACrC+wE,EAASpM,EAAU1gC,eAAeC,aAAaC,UACrD,IAAI6sC,GAAU,IACVC,EAAUxjE,IACVyjE,EAAe,EACfC,EAAO,EACPC,EAAO,EACX,IAAK,IAAI1rE,EAAIo5D,EAAO,GAAIp5D,GAAKq5D,EAAO,GAAIr5D,IACtC,IAAK,IAAI5P,EAAIgpE,EAAO,GAAIhpE,GAAKipE,EAAO,GAAIjpE,IAAK,CAC3C,IAAI8K,EAAQk+D,EAAO,GAAKhpE,EAAI+6E,EAAUnrE,EAAIorE,EAC1C,IAAK,IAAIl7E,EAAIkpE,EAAO,GAAIlpE,GAAKmpE,EAAO,GAAInpE,IAAK,CAC3C,IAAKg7E,GAAiBA,EAAc,CAACh7E,EAAGE,EAAG4P,GAAI6Z,GAAS,CACtD,MAAM8xD,EAAQN,EAAOnwE,GACjBywE,EAAQL,IAASA,EAAUK,GAC3BA,EAAQJ,IAASA,EAAUI,GAC/BH,GAAgBG,EAAQA,EACxBF,GAAQE,EACRD,GAAQ,CACV,GACExwE,CACJ,CACF,CAEF,MAAM0wE,EAAUF,EAAO,EAAID,EAAOC,EAAO,EACnCh0C,EAAWg0C,EAAO77E,KAAKud,IAAIo+D,EAAeE,EAAOE,EAAUA,GAAW,EAE5E,MAAO,CACLL,UACAD,UACAM,UACAl0C,WACAm0C,MANYh8E,KAAK8nC,KAAKD,GAOtBt3B,MAAOsrE,EAEX,EAIAzM,EAAUgC,kBAAoB,SAAUD,GAEtC,MAAMlB,EAAa,GACnB,IAAIgM,EAFqBrO,UAAUjqE,OAAS,QAAsB5C,IAAjB6sE,UAAU,GAAmBA,UAAU,GAAK,EAM7F,IAAK,IAAI+C,EAAM,EAAGA,EAAM,IAAKA,EAC3BV,EAAWU,GAAOsL,EAClBA,GAAQ9K,EAAa,EAANR,EAAU,GAAKQ,EAAa,EAANR,GAAW,EAElD,OAAOV,CACT,EAMAb,EAAU8M,mBAAqBC,IAC7B,IAAK5vE,EAAGgH,EAAGI,GAAKwoE,EAChB,MAAMhL,EAAS/B,EAAUllD,YACnBliB,EAAqBonE,EAAU1gC,eAAeC,aAAaytC,wBAC3DnM,EAAab,EAAUgC,kBAAkBD,EAAQnpE,GAIvD,OAAOhI,KAAKsP,OAAOtP,KAAK0kB,MAAMnY,GAAK4kE,EAAO,IAAMlB,EAAW,IAAMjwE,KAAK0kB,MAAMnR,GAAK49D,EAAO,IAAMlB,EAAW,IAAMjwE,KAAK0kB,MAAM/Q,GAAKw9D,EAAO,IAAMlB,EAAW,KAOzJb,EAAUiN,wBAA0BnsE,IAClC,MAAMihE,EAAS/B,EAAUllD,YACnB7e,EAAQ+jE,EAAUvzC,aAAa3rB,GAGrC,IAAK,IAAIygE,EAAM,EAAGA,EAAM,IAAKA,EAC3B,GAAItlE,EAAMslE,GAAOQ,EAAa,EAANR,IAAYtlE,EAAMslE,GAAOQ,EAAa,EAANR,EAAU,GAEhE,OADA3B,EAAc,2BAA2B3jE,wCAA4C8lE,KAC9EmL,IAKX,OAAOlN,EAAU8M,mBAAmB7wE,IAOtC+jE,EAAUmN,wBAA0B,SAAUrsE,GAC5C,IAAIoF,EAAOs4D,UAAUjqE,OAAS,QAAsB5C,IAAjB6sE,UAAU,GAAmBA,UAAU,GAAK,EAC/E,MAAM5lE,EAAqBonE,EAAU1gC,eAAeC,aAAaytC,wBACjE,GAAI9mE,EAAO,GAAKA,GAAQtN,EAEtB,OADAgnE,EAAc,sCAAsC15D,8DAAiEtN,KAC9Gs0E,IAET,MAAME,EAAcpN,EAAUiN,wBAAwBnsE,GACtD,OAAI5C,OAAO2Q,MAAMu+D,GAERA,EAEFpN,EAAU1gC,eAAeC,aAAa8tC,aAAaD,EAAalnE,EACzE,CACF,CA0CEu7B,CAAau+B,EAAWC,EAC1B,CAQA,IAAIqN,EAAiB,CACnBjO,YALkB,EAAAS,EAAMT,YAAYtqE,EAAQ,gBAM5CA,S,kFC5WF,MAAM,WACJw4E,EAAU,MACVC,GACE,MACE,oBACJC,GACE,MACE,cACJ5N,EAAa,cACbD,EAAa,gBACb8N,GACE,EAAA5N,EASJ,SAAS6N,EAAiCC,EAAKC,GAC7C,MAAMC,EAAIF,EAAI,GACRr/D,EAAIq/D,EAAI,GACRvkE,EAAIukE,EAAI,GACRG,EAAIn9E,KAAK8nC,KAAKo1C,EAAIA,EAAIv/D,EAAIA,EAAIlF,EAAIA,GAClCouD,EAAIsW,EAAI,KAAQn9E,KAAKo9E,KAAKF,EAAIC,GAAK,EACnCE,EAAIxW,EAAI,KAAQ7mE,KAAKgmD,MAAMvtC,EAAGkF,GAAK,EACzCs/D,EAAI,GAAKE,EACTF,EAAI,GAAKpW,EACToW,EAAI,GAAKI,CACX,CAYA,SAASC,EAAkCL,EAAKM,GAC9C,GAAIN,EAAI,IAAMM,EAAS,GAErB,OAAON,EAAI,GAKb,MAAMO,EAAUP,EAAI,GAAKj9E,KAAK8nC,KAAKy1C,EAASA,EAASN,EAAI,GAAKA,EAAI,KAAOA,EAAI,GAAKj9E,KAAKkgD,IAAI+8B,EAAI,KAE/F,OAAIA,EAAI,IAAM,GAAMj9E,KAAKC,GAChBg9E,EAAI,GAAKO,EAEXP,EAAI,GAAKO,CAClB,CAgBA,SAASC,EAA6C5W,EAAG6W,EAAMC,EAAM39C,GACnE,MAAM49C,EAAO,GACPC,EAAO,IACb,OAAQH,EAAME,IACd,OAAQD,EAAME,GACd,MAAMC,EAAO,GACPC,EAAO,GACbhB,EAAiCa,EAAME,GACvCf,EAAiCc,EAAME,GAIvC,IAAIC,EAASnX,EACb,GAAIiX,EAAK,GAAK,KAAQC,EAAK,GAAK,KA5BlC,SAA2CE,EAAIC,GAC7C,IAAIC,EAAQF,EAAKC,EAIjB,IAHIC,EAAQ,IACVA,GAASA,GAEJA,GAAS,EAAMn+E,KAAKC,IACzBk+E,GAAS,EAAMn+E,KAAKC,GAKtB,OAHIk+E,EAAQn+E,KAAKC,KACfk+E,EAAQ,EAAMn+E,KAAKC,GAAKk+E,GAEnBA,CACT,CAgB0CC,CAAkCN,EAAK,GAAIC,EAAK,IAAM,IAAO/9E,KAAKC,GAAI,CAG5G,IAAIo+E,EAAOr+E,KAAKyQ,IAAIqtE,EAAK,GAAIC,EAAK,IAClCM,EAAOr+E,KAAKyQ,IAAI,GAAM4tE,GAClBxX,EAAI,IACNkX,EAAK,GAAKM,EACVN,EAAK,GAAK,EACVA,EAAK,GAAK,EACVC,GAAU,IAEVF,EAAK,GAAKO,EACVP,EAAK,GAAK,EACVA,EAAK,GAAK,EACVE,EAAS,EAAMA,EAAS,EAE5B,CAKIF,EAAK,GAAK,KAAQC,EAAK,GAAK,IAC9BD,EAAK,GAAKR,EAAkCS,EAAMD,EAAK,IAC9CC,EAAK,GAAK,KAAQD,EAAK,GAAK,MACrCC,EAAK,GAAKT,EAAkCQ,EAAMC,EAAK,KAEzD,MAAMO,EAAS,GACfA,EAAO,IAAM,EAAIN,GAAUF,EAAK,GAAKE,EAASD,EAAK,GACnDO,EAAO,IAAM,EAAIN,GAAUF,EAAK,GAAKE,EAASD,EAAK,GACnDO,EAAO,IAAM,EAAIN,GAAUF,EAAK,GAAKE,EAASD,EAAK,GAGnD,MAAMQ,EAAS,IAtFjB,SAA0CtB,EAAKD,GAC7C,MAAMG,EAAIF,EAAI,GACRpW,EAAIoW,EAAI,GACRI,EAAIJ,EAAI,GACdD,EAAI,GAAKG,EAAIn9E,KAAKigD,IAAI4mB,GACtBmW,EAAI,GAAKG,EAAIn9E,KAAKkgD,IAAI2mB,GAAK7mE,KAAKigD,IAAIo9B,GACpCL,EAAI,GAAKG,EAAIn9E,KAAKkgD,IAAI2mB,GAAK7mE,KAAKkgD,IAAIm9B,EACtC,CAgFEmB,CAAiCF,EAAQC,IACzC,OAAQA,EAAQv+C,EAClB,CAsgCA,MAAM2xC,EAAiB,CACrB8M,UAAU,EACVC,WAAY/B,EAAWgC,IACvBC,SAAS,EACTr/E,MAAOq9E,EAAMtgE,OACbuiE,SAAU,KACVC,gBAAiB,KACjBC,gBAAiB,KACjBC,oBAAoB,EACpBC,oBAAoB,EACpBC,uBAAuB,EACvBx9D,MAAO,KACPy9D,UAAW,EACXC,UAAW,KACX1uC,MAAO,KACP2uC,YAAY,EACZC,eAAgB,KAKlB,SAASn7E,EAAOirE,EAAWC,GACzB,IAAIuC,EAAgBhE,UAAUjqE,OAAS,QAAsB5C,IAAjB6sE,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzFjrE,OAAO+wC,OAAO27B,EAAOsC,EAAgBC,GAGrC,YAA0BxC,EAAWC,EAAOuC,GAG5CvC,EAAM3tD,MAAQ,GACd2tD,EAAM3+B,MAAQ,GACd2+B,EAAMwP,SAAW,CAAC,GAAK,EAAK,EAAK,GACjCxP,EAAMyP,gBAAkB,CAAC,EAAK,EAAK,EAAK,GACxCzP,EAAM0P,gBAAkB,CAAC,EAAK,EAAK,EAAK,GACxC1P,EAAM+P,UAAY,CAAC,EACnB,EAAAlQ,EAAM/sD,IAAIktD,EAAM+P,WAGhB,EAAAlQ,EAAM/rE,IAAIisE,EAAWC,EAAO,CAAC,YAAa,iBAG1C,EAAAH,EAAM4C,OAAO1C,EAAWC,EAAO,CAAC,qBAAsB,qBAAsB,aAAc,iBAAkB,CAC1G3lE,KAAM,OACNrG,KAAM,aACNk8E,KAAM5C,GACL,CACDjzE,KAAM,OACNrG,KAAM,QACNk8E,KAAM3C,KAER,EAAA1N,EAAMsQ,SAASpQ,EAAWC,EAAO,CAAC,WAAY,kBAAmB,mBAAoB,GAGrF,EAAAH,EAAMiK,SAAS/J,EAAWC,EAAO,CAAC,WAAY,kBAAmB,oBArjCnE,SAAkCD,EAAWC,GAE3CA,EAAMC,eAAe9jE,KAAK,4BAG1B4jE,EAAUnhD,QAAU,IAAMohD,EAAM3+B,MAAM/sC,OAItCyrE,EAAUx2D,YAAc,CAACvY,EAAGkY,EAAGC,EAAGC,IAAM22D,EAAUqQ,gBAAgBp/E,EAAGkY,EAAGC,EAAGC,EAAG,GAAK,GAInF22D,EAAUqQ,gBAAkB,SAAUp/E,EAAGkY,EAAGC,EAAGC,GAC7C,IAAI8mD,EAAWqO,UAAUjqE,OAAS,QAAsB5C,IAAjB6sE,UAAU,GAAmBA,UAAU,GAAK,GAC/E8R,EAAY9R,UAAUjqE,OAAS,QAAsB5C,IAAjB6sE,UAAU,GAAmBA,UAAU,GAAK,EAEpF,GAAIrO,EAAW,GAAOA,EAAW,EAE/B,OADAyP,EAAc,sCACN,EAEV,GAAI0Q,EAAY,GAAOA,EAAY,EAEjC,OADA1Q,EAAc,uCACN,EAILK,EAAM6P,uBACT9P,EAAUuQ,YAAYt/E,GAIxB,MAAMswC,EAAO,CACXtwC,IACAkY,IACAC,IACAC,IACA8mD,WACAmgB,aAIFrQ,EAAM3+B,MAAMllC,KAAKmlC,GACjBy+B,EAAUwQ,qBAIV,IAAIrzE,EAAI,EACR,KAAOA,EAAI8iE,EAAM3+B,MAAM/sC,QACjB0rE,EAAM3+B,MAAMnkC,GAAGlM,IAAMA,EADIkM,KAQ/B,OAAIA,EAAI8iE,EAAM3+B,MAAM/sC,OACX4I,GAED,CACV,EAIA6iE,EAAUyQ,YAAc,CAACx/E,EAAGg9E,EAAGxW,EAAG91D,IAAMq+D,EAAU0Q,gBAAgBz/E,EAAGg9E,EAAGxW,EAAG91D,EAAG,GAAK,GAInFq+D,EAAU0Q,gBAAkB,SAAUz/E,EAAGg9E,EAAGxW,EAAG91D,GAC7C,IAAIwuD,EAAWqO,UAAUjqE,OAAS,QAAsB5C,IAAjB6sE,UAAU,GAAmBA,UAAU,GAAK,GAC/E8R,EAAY9R,UAAUjqE,OAAS,QAAsB5C,IAAjB6sE,UAAU,GAAmBA,UAAU,GAAK,EACpF,MAAMmS,EAAM,GACNC,EAAM,CAAC3C,EAAGxW,EAAG91D,GAEnB,OADA,IAAAssE,GAAQ2C,EAAKD,GACN3Q,EAAUx2D,YAAYvY,EAAG0/E,EAAI,GAAIA,EAAI,GAAIA,EAAI,GAAIxgB,EAAUmgB,EACpE,EAIAtQ,EAAU6Q,SAAWvvC,IACnB,GAAI2+B,EAAM3+B,QAAUA,EAAO,CACzB,MAAMwvC,EAAS5/C,KAAKC,UAAU8uC,EAAM3+B,OACpC2+B,EAAM3+B,MAAQA,EACd,MAAMyvC,EAAQ7/C,KAAKC,UAAU8uC,EAAM3+B,OACnC,GAAI0+B,EAAUwQ,sBAAwBM,IAAWC,EAE/C,OADA/Q,EAAUz9B,YACH,CAEX,CACA,OAAO,GAMTy9B,EAAUwQ,mBAAqB,KAC7B,MAAMM,EAAS5/C,KAAKC,UAAU8uC,EAAM3+B,OACpC2+B,EAAM3+B,MAAMhzB,KAAK,CAACC,EAAGlF,IAAMkF,EAAEtd,EAAIoY,EAAEpY,GACnC,MAAM8/E,EAAQ7/C,KAAKC,UAAU8uC,EAAM3+B,OAC7B0vC,EAAkBhR,EAAUiR,cAElC,OAAKD,GAAmBF,IAAWC,EAI5BC,GAHLhR,EAAUz9B,YACH,IAMXy9B,EAAUiR,YAAc,KACtB,MAAMC,EAAW,CAAC,GAClBA,EAAS,GAAKjR,EAAMkR,aAAa,GACjCD,EAAS,GAAKjR,EAAMkR,aAAa,GACjC,MAAMt0D,EAAOojD,EAAM3+B,MAAM/sC,OAUzB,OATIsoB,GACFojD,EAAMkR,aAAa,GAAKlR,EAAM3+B,MAAM,GAAGrwC,EACvCgvE,EAAMkR,aAAa,GAAKlR,EAAM3+B,MAAMzkB,EAAO,GAAG5rB,IAE9CgvE,EAAMkR,aAAa,GAAK,EACxBlR,EAAMkR,aAAa,GAAK,IAItBD,EAAS,KAAOjR,EAAMkR,aAAa,IAAMD,EAAS,KAAOjR,EAAMkR,aAAa,MAGhFnR,EAAUz9B,YACH,IAKTy9B,EAAUuQ,YAAct/E,IAGtB,IAAIkM,EAAI,EACR,KAAOA,EAAI8iE,EAAM3+B,MAAM/sC,QACjB0rE,EAAM3+B,MAAMnkC,GAAGlM,IAAMA,EADIkM,KAK/B,MAAMi0E,EAASj0E,EAGf,GAAIA,GAAK8iE,EAAM3+B,MAAM/sC,OACnB,OAAQ,EAKV,IAAIy8E,GAAkB,EAQtB,OAPA/Q,EAAM3+B,MAAMn8B,OAAOhI,EAAG,GACZ,IAANA,GAAWA,IAAM8iE,EAAM3+B,MAAM/sC,SAC/By8E,EAAkBhR,EAAUiR,eAEzBD,GACHhR,EAAUz9B,WAEL6uC,GAITpR,EAAUqR,UAAY,CAACC,EAAMC,KAC3B,GAAID,IAASC,EAAb,CAIAvR,EAAUuQ,YAAYgB,GACtB,IAAK,IAAIp0E,EAAI,EAAGA,EAAI8iE,EAAM3+B,MAAM/sC,OAAQ4I,IACtC,GAAI8iE,EAAM3+B,MAAMnkC,GAAGlM,IAAMqgF,EAAM,CAC7BrR,EAAM3+B,MAAMnkC,GAAGlM,EAAIsgF,EACnBvR,EAAUwQ,qBACV,KACF,CAPF,GAaFxQ,EAAUz2D,gBAAkB,KAC1B02D,EAAM3+B,MAAQ,GACd0+B,EAAUwQ,sBAKZxQ,EAAUwR,cAAgB,CAACj3D,EAAIk3D,EAAIC,EAAIC,EAAI9/D,EAAI+/D,EAAIC,EAAIC,KAErD9R,EAAUwQ,qBACV,IAAK,IAAIrzE,EAAI,EAAGA,EAAI8iE,EAAM3+B,MAAM/sC,QAC1B0rE,EAAM3+B,MAAMnkC,GAAGlM,GAAKspB,GAAM0lD,EAAM3+B,MAAMnkC,GAAGlM,GAAK4gB,EAChDouD,EAAM3+B,MAAMn8B,OAAOhI,EAAG,GAEtBA,IAKJ6iE,EAAUqQ,gBAAgB91D,EAAIk3D,EAAIC,EAAIC,EAAI,GAAK,GAC/C3R,EAAUqQ,gBAAgBx+D,EAAI+/D,EAAIC,EAAIC,EAAI,GAAK,GAC/C9R,EAAUz9B,YAKZy9B,EAAU+R,cAAgB,CAACx3D,EAAIy3D,EAAIC,EAAI/xD,EAAIrO,EAAIqgE,EAAIC,EAAIhyD,KACrD,MAAMiyD,EAAO,CAACJ,EAAIC,EAAI/xD,GAChBmyD,EAAO,CAACH,EAAIC,EAAIhyD,GAChBmuD,EAAO,GACPC,EAAO,IACb,IAAAN,GAAQmE,EAAM9D,IACd,IAAAL,GAAQoE,EAAM9D,GACdvO,EAAUwR,cAAcj3D,EAAI+zD,EAAK,GAAIA,EAAK,GAAIA,EAAK,GAAIz8D,EAAI08D,EAAK,GAAIA,EAAK,GAAIA,EAAK,KAKpFvO,EAAUsS,SAAWrhF,IACnB,MAAM0/E,EAAM,GAEZ,OADA3Q,EAAUuS,SAASthF,EAAG0/E,GACf,CAAC//E,KAAKsP,MAAM,IAAQywE,EAAI,GAAK,IAAM//E,KAAKsP,MAAM,IAAQywE,EAAI,GAAK,IAAM//E,KAAKsP,MAAM,IAAQywE,EAAI,GAAK,IAAM,MAKhH3Q,EAAUuS,SAAW,CAACthF,EAAG0/E,KACvB,GAAI1Q,EAAMuS,cAAe,CACvB,MAAMC,EAAWzS,EAAUnhD,UAErB0iD,EAAMvB,EAAU0S,+BAA+BzhF,GACrD,GAAIswE,EAAM,GAAkB,IAAbkR,EAAgB,CAC7B,MAAMhD,EAAWzP,EAAU2S,yBAC3BhC,EAAI,GAAKlB,EAAS,GAClBkB,EAAI,GAAKlB,EAAS,GAClBkB,EAAI,GAAKlB,EAAS,EACpB,KAAO,CACL,MAAMmD,EAAU,GAChB5S,EAAUjhD,aAAawiD,EAAMkR,EAAUG,GAEvCjC,EAAI,GAAKiC,EAAQ,GACjBjC,EAAI,GAAKiC,EAAQ,GACjBjC,EAAI,GAAKiC,EAAQ,EACnB,CACA,MACF,CACA5S,EAAU5lD,SAASnpB,EAAGA,EAAG,EAAG0/E,IAK9B3Q,EAAU6S,YAAc5hF,IACtB,MAAM0/E,EAAM,GAEZ,OADA3Q,EAAUuS,SAASthF,EAAG0/E,GACfA,EAAI,IAKb3Q,EAAU8S,cAAgB7hF,IACxB,MAAM0/E,EAAM,GAEZ,OADA3Q,EAAUuS,SAASthF,EAAG0/E,GACfA,EAAI,IAKb3Q,EAAU+S,aAAe9hF,IACvB,MAAM0/E,EAAM,GAEZ,OADA3Q,EAAUuS,SAASthF,EAAG0/E,GACfA,EAAI,IAKb3Q,EAAU5lD,SAAW,CAAC44D,EAASC,EAAOp2D,EAAMvK,KAE1C,MAAM4gE,EAASh1E,OAAO80E,GAChBG,EAAOj1E,OAAO+0E,GAKpB,IAAI,IAAA91E,GAAM+1E,KAAW,IAAA/1E,GAAMg2E,GAAO,CAChC,IAAK,IAAIh2E,EAAI,EAAGA,EAAI0f,EAAM1f,IACxBmV,EAAU,EAAJnV,EAAQ,GAAK8iE,EAAMwP,SAAS,GAClCn9D,EAAU,EAAJnV,EAAQ,GAAK8iE,EAAMwP,SAAS,GAClCn9D,EAAU,EAAJnV,EAAQ,GAAK8iE,EAAMwP,SAAS,GAEpC,MACF,CACA,IAAIlO,EAAM,EACV,MAAMkR,EAAWxS,EAAM3+B,MAAM/sC,OAK7B,IAAI6+E,EAAQ,EACRC,EAAQ,EACRC,EAAQ,EACK,IAAbb,IACFW,EAAQnT,EAAM3+B,MAAMmxC,EAAW,GAAGtpE,EAClCkqE,EAAQpT,EAAM3+B,MAAMmxC,EAAW,GAAGrpE,EAClCkqE,EAAQrT,EAAM3+B,MAAMmxC,EAAW,GAAGppE,GAEpC,IAAIpY,EAAI,EACJspB,EAAK,EACL1I,EAAK,EACT,MAAMy8D,EAAO,CAAC,EAAK,EAAK,GAClBC,EAAO,CAAC,EAAK,EAAK,GACxB,IAAIpe,EAAW,EACXmgB,EAAY,EAChB,MAAMiD,EAAS,GAGf,IAAIC,EAAgBvT,EAAM9vE,QAAUq9E,EAAMiG,MACtCD,IAEFA,EAAgBvT,EAAMkR,aAAa,GAAK,GAE1C,IAAIuC,EAAW,EACXC,EAAS,EACTC,EAAO,EACPJ,IACFE,EAAW9iF,KAAKijF,MAAMX,GACtBS,EAAS/iF,KAAKijF,MAAMV,IAItB,IAAK,IAAIh2E,EAAI,EAAGA,EAAI0f,EAAM1f,IAAK,CAE7B,MAAM22E,EAAO,EAAI32E,EAsBjB,GAjBI0f,EAAO,EACL22D,GACFI,EAAOF,EAAWv2E,GAAK0f,EAAO,IAAQ82D,EAASD,GAC/CziF,EAAI,IAAQ2iF,GAEZ3iF,EAAIiiF,EAAS/1E,GAAK0f,EAAO,IAAQs2D,EAAOD,GAEjCM,GACTI,EAAO,IAAOF,EAAWC,GACzB1iF,EAAI,IAAQ2iF,GAEZ3iF,EAAI,IAAOiiF,EAASC,GAMlBlT,EAAMgQ,WAAY,CACpB,MAAMjyE,EAAQiiE,EAAMkR,aACpB,GAAIlgF,GAAK+M,EAAM,IAAM/M,GAAK+M,EAAM,GAAI,CAClC,MAAMkyE,EAAiBjQ,EAAMiQ,eACvB6D,EAAa/1E,EAAM,GAAKA,EAAM,GACpC,GAAIkyE,GAAkB,EACpBj/E,EAAI+M,EAAM,GAAK+1E,EAAa,MACvB,CAEL,MAAMC,GAAM/iF,EAAI+M,EAAM,IAAM+1E,EAEtBE,GAAkB,OAAM/D,EAAiB8D,GAE/C/iF,EAAI+M,EAAM,GAAKi2E,GAAmB/D,EAAiB,GAAK6D,CAC1D,CACF,CACF,CAGA,KAAOxS,EAAMkR,GAAYxhF,EAAIgvE,EAAM3+B,MAAMigC,GAAKtwE,GAC5CswE,IAKIA,EAAMkR,IACRl4D,EAAK0lD,EAAM3+B,MAAMigC,EAAM,GAAGtwE,EAC1B4gB,EAAKouD,EAAM3+B,MAAMigC,GAAKtwE,EAClBuiF,IACFj5D,EAAK3pB,KAAKijF,MAAMt5D,GAChB1I,EAAKjhB,KAAKijF,MAAMhiE,IAElBy8D,EAAK,GAAKrO,EAAM3+B,MAAMigC,EAAM,GAAGp4D,EAC/BolE,EAAK,GAAKtO,EAAM3+B,MAAMigC,GAAKp4D,EAC3BmlE,EAAK,GAAKrO,EAAM3+B,MAAMigC,EAAM,GAAGn4D,EAC/BmlE,EAAK,GAAKtO,EAAM3+B,MAAMigC,GAAKn4D,EAC3BklE,EAAK,GAAKrO,EAAM3+B,MAAMigC,EAAM,GAAGl4D,EAC/BklE,EAAK,GAAKtO,EAAM3+B,MAAMigC,GAAKl4D,EAI3B8mD,EAAW8P,EAAM3+B,MAAMigC,EAAM,GAAGpR,SAChCmgB,EAAYrQ,EAAM3+B,MAAMigC,EAAM,GAAG+O,UAI7BngB,EAAW,OACbA,EAAW,MAETA,EAAW,SACbA,EAAW,SAMjB,GAAIl/D,EAAIgvE,EAAMkR,aAAa,GACzB7+D,EAAMwhE,GAAQ,EACdxhE,EAAMwhE,EAAO,GAAK,EAClBxhE,EAAMwhE,EAAO,GAAK,EACd7T,EAAMoP,WACJrP,EAAUkU,yBACZ5hE,EAAMwhE,GAAQ7T,EAAM0P,gBAAgB,GACpCr9D,EAAMwhE,EAAO,GAAK7T,EAAM0P,gBAAgB,GACxCr9D,EAAMwhE,EAAO,GAAK7T,EAAM0P,gBAAgB,KAExCr9D,EAAMwhE,GAAQV,EACd9gE,EAAMwhE,EAAO,GAAKT,EAClB/gE,EAAMwhE,EAAO,GAAKR,SAGjB,GAAIriF,EAAIgvE,EAAMkR,aAAa,KAAM,OAAMlgF,IAAMA,EAAI,EAGtDqhB,EAAMwhE,GAAQ,EACdxhE,EAAMwhE,EAAO,GAAK,EAClBxhE,EAAMwhE,EAAO,GAAK,EACd7T,EAAMoP,WACJrP,EAAUmU,yBACZ7hE,EAAMwhE,GAAQ7T,EAAMyP,gBAAgB,GACpCp9D,EAAMwhE,EAAO,GAAK7T,EAAMyP,gBAAgB,GACxCp9D,EAAMwhE,EAAO,GAAK7T,EAAMyP,gBAAgB,IAC/B+C,EAAW,IACpBngE,EAAMwhE,GAAQ7T,EAAM3+B,MAAM,GAAGn4B,EAC7BmJ,EAAMwhE,EAAO,GAAK7T,EAAM3+B,MAAM,GAAGl4B,EACjCkJ,EAAMwhE,EAAO,GAAK7T,EAAM3+B,MAAM,GAAGj4B,SAGhC,GAAY,IAARk4D,IAAc3wE,KAAKud,IAAIld,EAAIiiF,GAAU,MAAQjT,EAAMgQ,YACxDwC,EAAW,GACbngE,EAAMwhE,GAAQ7T,EAAM3+B,MAAM,GAAGn4B,EAC7BmJ,EAAMwhE,EAAO,GAAK7T,EAAM3+B,MAAM,GAAGl4B,EACjCkJ,EAAMwhE,EAAO,GAAK7T,EAAM3+B,MAAM,GAAGj4B,IAEjCiJ,EAAMwhE,GAAQ,EACdxhE,EAAMwhE,EAAO,GAAK,EAClBxhE,EAAMwhE,EAAO,GAAK,OAEf,CAML,IAAIrc,EAAI,EAgBR,GAdEA,EADE+b,GACGI,EAAOr5D,IAAO1I,EAAK0I,IAEnBtpB,EAAIspB,IAAO1I,EAAK0I,GAKrBk9C,EADEA,EAAItH,EACF,GAAMsH,EAAItH,EAEV,GAAM,IAAOsH,EAAItH,IAAa,EAAMA,GAKtCmgB,EAAY,IAAM,CAEpB,GAAI7Y,EAAI,GAAK,CACXnlD,EAAMwhE,GAAQxF,EAAK,GACnBh8D,EAAMwhE,EAAO,GAAKxF,EAAK,GACvBh8D,EAAMwhE,EAAO,GAAKxF,EAAK,GACvB,QACF,CAEEh8D,EAAMwhE,GAAQvF,EAAK,GACnBj8D,EAAMwhE,EAAO,GAAKvF,EAAK,GACvBj8D,EAAMwhE,EAAO,GAAKvF,EAAK,GACvB,QAEJ,CAIA,GAAI+B,EAAY,IAAM,CAEpB,GAAIrQ,EAAMqP,aAAe/B,EAAWgC,IAClCj9D,EAAMwhE,IAAS,EAAIrc,GAAK6W,EAAK,GAAK7W,EAAI8W,EAAK,GAC3Cj8D,EAAMwhE,EAAO,IAAM,EAAIrc,GAAK6W,EAAK,GAAK7W,EAAI8W,EAAK,GAC/Cj8D,EAAMwhE,EAAO,IAAM,EAAIrc,GAAK6W,EAAK,GAAK7W,EAAI8W,EAAK,QAC1C,GAAItO,EAAMqP,aAAe/B,EAAW6G,IAAK,CAC9C,MAAMhC,EAAO,GACPC,EAAO,IACb,OAAQ/D,EAAM8D,IACd,OAAQ7D,EAAM8D,GACVpS,EAAMuP,UAAY4C,EAAK,GAAKC,EAAK,GAAK,IAAOA,EAAK,GAAKD,EAAK,GAAK,MAC/DA,EAAK,GAAKC,EAAK,GACjBD,EAAK,IAAM,EAEXC,EAAK,IAAM,GAGf,MAAMgC,EAAS,GACfA,EAAO,IAAM,EAAM5c,GAAK2a,EAAK,GAAK3a,EAAI4a,EAAK,GACvCgC,EAAO,GAAK,IACdA,EAAO,IAAM,GAEfA,EAAO,IAAM,EAAM5c,GAAK2a,EAAK,GAAK3a,EAAI4a,EAAK,GAC3CgC,EAAO,IAAM,EAAM5c,GAAK2a,EAAK,GAAK3a,EAAI4a,EAAK,IAG3C,IAAApE,GAAQoG,EAAQd,GAChBjhE,EAAMwhE,GAAQP,EAAO,GACrBjhE,EAAMwhE,EAAO,GAAKP,EAAO,GACzBjhE,EAAMwhE,EAAO,GAAKP,EAAO,EAC3B,MAAO,GAAItT,EAAMqP,aAAe/B,EAAW+G,IAAK,CAC9C,MAAM9F,EAAO,GACPC,EAAO,IACb,OAAQH,EAAME,IACd,OAAQD,EAAME,GACd,MAAMU,EAAS,GACfA,EAAO,IAAM,EAAI1X,GAAK+W,EAAK,GAAK/W,EAAIgX,EAAK,GACzCU,EAAO,IAAM,EAAI1X,GAAK+W,EAAK,GAAK/W,EAAIgX,EAAK,GACzCU,EAAO,IAAM,EAAI1X,GAAK+W,EAAK,GAAK/W,EAAIgX,EAAK,IAGzC,OAAQU,EAAQoE,GAChBjhE,EAAMwhE,GAAQP,EAAO,GACrBjhE,EAAMwhE,EAAO,GAAKP,EAAO,GACzBjhE,EAAMwhE,EAAO,GAAKP,EAAO,EAC3B,MAAWtT,EAAMqP,aAAe/B,EAAWgH,WACzClG,EAA6C5W,EAAG6W,EAAMC,EAAMgF,GAC5DjhE,EAAMwhE,GAAQP,EAAO,GACrBjhE,EAAMwhE,EAAO,GAAKP,EAAO,GACzBjhE,EAAMwhE,EAAO,GAAKP,EAAO,IAEzB3T,EAAc,mCAAoCK,EAAMqP,YAE1D,QACF,CASI7X,EAAI,GACNA,EAAI,IAAW,EAAJA,KAAa,EAAM,GAAO6Y,GAC5B7Y,EAAI,KACbA,EAAI,EAAM,IAAmB,GAAX,EAAMA,MAAY,EAAI,GAAO6Y,IAIjD,MAAMkE,EAAK/c,EAAIA,EACTgd,EAAMD,EAAK/c,EACXua,EAAK,EAAMyC,EAAM,EAAID,EAAK,EAC1BtC,GAAM,EAAIuC,EAAM,EAAID,EACpBE,EAAKD,EAAM,EAAID,EAAK/c,EACpBkd,EAAKF,EAAMD,EACjB,IAAIl3E,EACAigC,EACJ,GAAI0iC,EAAMqP,aAAe/B,EAAWgC,IAClC,IAAK,IAAIprE,EAAI,EAAGA,EAAI,EAAGA,IAErB7G,EAAQixE,EAAKpqE,GAAKmqE,EAAKnqE,GACvBo5B,GAAK,EAAM+yC,GAAahzE,EAGxBgV,EAAMwhE,EAAO3vE,GAAK6tE,EAAK1D,EAAKnqE,GAAK+tE,EAAK3D,EAAKpqE,GAAKuwE,EAAKn3C,EAAIo3C,EAAKp3C,OAE3D,GAAI0iC,EAAMqP,aAAe/B,EAAW6G,IAAK,CAC9C,MAAMhC,EAAO,GACPC,EAAO,IACb,OAAQ/D,EAAM8D,IACd,OAAQ7D,EAAM8D,GACVpS,EAAMuP,UAAY4C,EAAK,GAAKC,EAAK,GAAK,IAAOA,EAAK,GAAKD,EAAK,GAAK,MAC/DA,EAAK,GAAKC,EAAK,GACjBD,EAAK,IAAM,EAEXC,EAAK,IAAM,GAGf,MAAMgC,EAAS,GACf,IAAK,IAAIlwE,EAAI,EAAGA,EAAI,EAAGA,IAErB7G,EAAQ+0E,EAAKluE,GAAKiuE,EAAKjuE,GACvBo5B,GAAK,EAAM+yC,GAAahzE,EAGxB+2E,EAAOlwE,GAAK6tE,EAAKI,EAAKjuE,GAAK+tE,EAAKG,EAAKluE,GAAKuwE,EAAKn3C,EAAIo3C,EAAKp3C,EAC9C,IAANp5B,GAAWkwE,EAAOlwE,GAAK,IACzBkwE,EAAOlwE,IAAM,IAIjB,IAAA8pE,GAAQoG,EAAQd,GAChBjhE,EAAMwhE,GAAQP,EAAO,GACrBjhE,EAAMwhE,EAAO,GAAKP,EAAO,GACzBjhE,EAAMwhE,EAAO,GAAKP,EAAO,EAC3B,MAAO,GAAItT,EAAMqP,aAAe/B,EAAW+G,IAAK,CAC9C,MAAM9F,EAAO,GACPC,EAAO,IACb,OAAQH,EAAME,IACd,OAAQD,EAAME,GACd,MAAMU,EAAS,GACf,IAAK,IAAIhrE,EAAI,EAAGA,EAAI,EAAGA,IAErB7G,EAAQmxE,EAAKtqE,GAAKqqE,EAAKrqE,GACvBo5B,GAAK,EAAM+yC,GAAahzE,EAGxB6xE,EAAOhrE,GAAK6tE,EAAKxD,EAAKrqE,GAAK+tE,EAAKzD,EAAKtqE,GAAKuwE,EAAKn3C,EAAIo3C,EAAKp3C,GAG1D,OAAQ4xC,EAAQoE,GAChBjhE,EAAMwhE,GAAQP,EAAO,GACrBjhE,EAAMwhE,EAAO,GAAKP,EAAO,GACzBjhE,EAAMwhE,EAAO,GAAKP,EAAO,EAC3B,MAAWtT,EAAMqP,aAAe/B,EAAWgH,WAIzClG,EAA6C5W,EAAG6W,EAAMC,EAAMgF,GAC5DjhE,EAAMwhE,GAAQP,EAAO,GACrBjhE,EAAMwhE,EAAO,GAAKP,EAAO,GACzBjhE,EAAMwhE,EAAO,GAAKP,EAAO,IAEzB3T,EAAc,oCAIhB,IAAK,IAAIz7D,EAAI,EAAGA,EAAI,EAAGA,IACrBmO,EAAMwhE,EAAO3vE,GAAKmO,EAAMwhE,EAAO3vE,GAAK,EAAM,EAAMmO,EAAMwhE,EAAO3vE,GAC7DmO,EAAMwhE,EAAO3vE,GAAKmO,EAAMwhE,EAAO3vE,GAAK,EAAM,EAAMmO,EAAMwhE,EAAO3vE,EAEjE,CACF,GAIF67D,EAAU4U,cAAgB,SAAU1B,EAAQC,EAAMt2D,GAChD,IAAIg4D,EAAYrW,UAAUjqE,OAAS,QAAsB5C,IAAjB6sE,UAAU,IAAmBA,UAAU,GAC/E,GAAIwB,EAAU8U,YAAc7U,EAAM+P,WAAa/P,EAAM8P,YAAclzD,GAAQojD,EAAM8U,iBAAmBF,EAClG,OAAO5U,EAAM3tD,MAEf,GAA2B,IAAvB2tD,EAAM3+B,MAAM/sC,OAEd,OADAqrE,EAAc,+DACPK,EAAM3tD,MAEf,MAAM0iE,EAAaH,EAAY,EAAI,EAC/B5U,EAAM8P,YAAclzD,GAAQojD,EAAM8U,iBAAmBF,IACvD5U,EAAM3tD,MAAQ,IAAI7V,WAAWogB,EAAOm4D,GACpC/U,EAAM8P,UAAYlzD,EAClBojD,EAAM8U,eAAiBF,GAEzB,MAAMI,EAAW,GACjBjV,EAAU5lD,SAAS84D,EAAQC,EAAMt2D,EAAMo4D,GACvC,IAAK,IAAI93E,EAAI,EAAGA,EAAI0f,EAAM1f,IACxB8iE,EAAM3tD,MAAMnV,EAAI63E,EAAa,GAAKpkF,KAAKsP,MAA4B,IAAtB+0E,EAAa,EAAJ93E,EAAQ,GAAa,IAC3E8iE,EAAM3tD,MAAMnV,EAAI63E,EAAa,GAAKpkF,KAAKsP,MAA4B,IAAtB+0E,EAAa,EAAJ93E,EAAQ,GAAa,IAC3E8iE,EAAM3tD,MAAMnV,EAAI63E,EAAa,GAAKpkF,KAAKsP,MAA4B,IAAtB+0E,EAAa,EAAJ93E,EAAQ,GAAa,IACvE03E,IACF5U,EAAM3tD,MAAMnV,EAAI63E,EAAa,GAAK,KAItC,OADA/U,EAAM+P,UAAUztC,WACT09B,EAAM3tD,KACf,EACA0tD,EAAUvtD,uBAAyBvT,IACjC8gE,EAAUz2D,kBACV,MAAM2rE,EAAgBh2E,EAAM8tE,wBAC5B,IAAK,IAAI7vE,EAAI,EAAGA,EAAI+B,EAAMi2E,oBAAqBh4E,IAC7C,OAAQ+3E,GACN,KAAK,EAEDjV,EAAM3+B,MAAMllC,KAAK,CACfnL,EAAGkM,EACHgM,EAAGjK,EAAMmuE,aAAalwE,EAAG,GACzBiM,EAAGlK,EAAMmuE,aAAalwE,EAAG,GACzBkM,EAAGnK,EAAMmuE,aAAalwE,EAAG,GACzBgzD,SAAU,GACVmgB,UAAW,IAEb,MAEJ,KAAK,EAEDrQ,EAAM3+B,MAAMllC,KAAK,CACfnL,EAAGiO,EAAMmuE,aAAalwE,EAAG,GACzBgM,EAAGjK,EAAMmuE,aAAalwE,EAAG,GACzBiM,EAAGlK,EAAMmuE,aAAalwE,EAAG,GACzBkM,EAAGnK,EAAMmuE,aAAalwE,EAAG,GACzBgzD,SAAU,GACVmgB,UAAW,IAEb,MAEJ,KAAK,EAEDrQ,EAAM3+B,MAAMllC,KAAK,CACfnL,EAAGkM,EACHgM,EAAGjK,EAAMmuE,aAAalwE,EAAG,GACzBiM,EAAGlK,EAAMmuE,aAAalwE,EAAG,GACzBkM,EAAGnK,EAAMmuE,aAAalwE,EAAG,GACzBgzD,SAAUjxD,EAAMmuE,aAAalwE,EAAG,GAChCmzE,UAAWpxE,EAAMmuE,aAAalwE,EAAG,KAEnC,MAEJ,KAAK,EAED8iE,EAAM3+B,MAAMllC,KAAK,CACfnL,EAAGiO,EAAMmuE,aAAalwE,EAAG,GACzBgM,EAAGjK,EAAMmuE,aAAalwE,EAAG,GACzBiM,EAAGlK,EAAMmuE,aAAalwE,EAAG,GACzBkM,EAAGnK,EAAMmuE,aAAalwE,EAAG,GACzBgzD,SAAUjxD,EAAMmuE,aAAalwE,EAAG,GAChCmzE,UAAWpxE,EAAMmuE,aAAalwE,EAAG,KAM3C6iE,EAAUwQ,sBAIZxQ,EAAUoV,uBAAyB,CAAClC,EAAQC,EAAMt2D,EAAMvK,KACtD,IAAI+iE,EAAM,EACVrV,EAAUz2D,kBACNsT,EAAO,IACTw4D,GAAOlC,EAAOD,IAAWr2D,EAAO,IAElC,IAAK,IAAI1f,EAAI,EAAGA,EAAI0f,EAAM1f,IAAK,CAC7B,MAAMokC,EAAO,CACXtwC,EAAGiiF,EAASmC,EAAMl4E,EAClBgM,EAAGmJ,EAAU,EAAJnV,GACTiM,EAAGkJ,EAAU,EAAJnV,EAAQ,GACjBkM,EAAGiJ,EAAU,EAAJnV,EAAQ,GACjBmzE,UAAW,EACXngB,SAAU,IAEZ8P,EAAM3+B,MAAMllC,KAAKmlC,EACnB,CACAy+B,EAAUwQ,sBAKZxQ,EAAUjhD,aAAe,CAAC9iB,EAAO43B,IAC3B53B,EAAQ,GAAKA,GAASgkE,EAAM3+B,MAAM/sC,QACpCqrE,EAAc,wBACN,IAEV/rC,EAAI,GAAKosC,EAAM3+B,MAAMrlC,GAAOhL,EAC5B4iC,EAAI,GAAKosC,EAAM3+B,MAAMrlC,GAAOkN,EAC5B0qB,EAAI,GAAKosC,EAAM3+B,MAAMrlC,GAAOmN,EAC5ByqB,EAAI,GAAKosC,EAAM3+B,MAAMrlC,GAAOoN,EAC5BwqB,EAAI,GAAKosC,EAAM3+B,MAAMrlC,GAAOk0D,SAC5Bt8B,EAAI,GAAKosC,EAAM3+B,MAAMrlC,GAAOq0E,UACrB,GAKTtQ,EAAUhhD,aAAe,CAAC/iB,EAAO43B,KAC/B,GAAI53B,EAAQ,GAAKA,GAASgkE,EAAM3+B,MAAM/sC,OAEpC,OADAqrE,EAAc,wBACN,EAEV,MAAM0R,EAAOrR,EAAM3+B,MAAMrlC,GAAOhL,EAgBhC,OAfAgvE,EAAM3+B,MAAMrlC,GAAOhL,EAAI4iC,EAAI,GAC3BosC,EAAM3+B,MAAMrlC,GAAOkN,EAAI0qB,EAAI,GAC3BosC,EAAM3+B,MAAMrlC,GAAOmN,EAAIyqB,EAAI,GAC3BosC,EAAM3+B,MAAMrlC,GAAOoN,EAAIwqB,EAAI,GAC3BosC,EAAM3+B,MAAMrlC,GAAOk0D,SAAWt8B,EAAI,GAClCosC,EAAM3+B,MAAMrlC,GAAOq0E,UAAYz8C,EAAI,GAC/By9C,IAASz9C,EAAI,GAGfmsC,EAAUwQ,qBAIVxQ,EAAUz9B,WAEL,GAITy9B,EAAUsV,2BAA6B,KACrC,GAAIrV,EAAMuS,eAAiBxS,EAAUnhD,UACnC,OAAOmhD,EAAUnhD,UAEnB,GAAIohD,EAAM8P,UAIR,OAAO9P,EAAM8P,UAEf,MAAMwF,EAAStV,EAAM3+B,OAAO/sC,QAAU,EAEtC,OAAO3D,KAAKyQ,IAAI,KAAMk0E,IAIxBvV,EAAUwV,gBAAkB,CAACjU,EAAK/jE,KAChC,MAAMqiB,EAAImgD,EAAUnhD,UACpB,GAAIgB,EAAI,GAAK0hD,GAAO,EAAG,CACrB,MAAMkU,EAAY,GAClBzV,EAAUjhD,aAAawiD,EAAM1hD,EAAG41D,GAChC,IAAK,IAAItxE,EAAI,EAAGA,EAAI,IAAKA,EACvB3G,EAAK2G,GAAKsxE,EAAUtxE,EAAI,GAG1B,YADA3G,EAAK,GAAK,EAEZ,CACA,MAAMiyE,EAAWzP,EAAU2S,yBAC3Bn1E,EAAK,GAAKiyE,EAAS,GACnBjyE,EAAK,GAAKiyE,EAAS,GACnBjyE,EAAK,GAAKiyE,EAAS,GACnBjyE,EAAK,GAAK,GAIZwiE,EAAU0V,oBAAsB,CAACC,EAAIC,KACnC,KAAID,GAAM,IAAMC,EAAhB,CAGA5V,EAAUz2D,kBACV,IAAK,IAAIpM,EAAI,EAAGA,EAAIw4E,EAAIx4E,IACtB6iE,EAAUx2D,YAAYosE,EAAQ,EAAJz4E,GAAQy4E,EAAQ,EAAJz4E,EAAQ,GAAIy4E,EAAQ,EAAJz4E,EAAQ,GAAIy4E,EAAQ,EAAJz4E,EAAQ,GAHhF,GAQF6iE,EAAUlvD,gBAAkB,CAACrf,EAAK4P,KAChC,MAAMrD,EAAQ,CAACvM,EAAK4P,GACdw0E,EAAgB7V,EAAUxuD,WAChC,GAAIqkE,EAAc,KAAO73E,EAAM,IAAM63E,EAAc,KAAO73E,EAAM,GAC9D,OAEF,GAAIA,EAAM,KAAOA,EAAM,GAErB,YADA4hE,EAAc,yCAGhB,MAAMzvE,GAAS6N,EAAM,GAAKA,EAAM,KAAO63E,EAAc,GAAKA,EAAc,IAClEtxB,EAAQvmD,EAAM,GAAK63E,EAAc,GAAK1lF,EAC5C,IAAK,IAAIgN,EAAI,EAAGA,EAAI8iE,EAAM3+B,MAAM/sC,SAAU4I,EACxC8iE,EAAM3+B,MAAMnkC,GAAGlM,EAAIgvE,EAAM3+B,MAAMnkC,GAAGlM,EAAId,EAAQo0D,EAEhD0b,EAAMkR,aAAa,GAAKnzE,EAAM,GAC9BiiE,EAAMkR,aAAa,GAAKnzE,EAAM,GAC9BgiE,EAAUz9B,YAIZy9B,EAAU8V,YAAc93E,IACtB,MAAM+3E,EAAgB/V,EAAUxuD,WAG1Bm/D,EAAM,GACRoF,EAAc,GAAK/3E,EAAM,IAC3BgiE,EAAUuS,SAASv0E,EAAM,GAAI2yE,GAC7B3Q,EAAUx2D,YAAYxL,EAAM,GAAI2yE,EAAI,GAAIA,EAAI,GAAIA,EAAI,MAEpD3Q,EAAUuS,SAASwD,EAAc,GAAIpF,GACrC3Q,EAAUx2D,YAAYxL,EAAM,GAAI2yE,EAAI,GAAIA,EAAI,GAAIA,EAAI,KAElDoF,EAAc,GAAK/3E,EAAM,IAC3BgiE,EAAUuS,SAASv0E,EAAM,GAAI2yE,GAC7B3Q,EAAUx2D,YAAYxL,EAAM,GAAI2yE,EAAI,GAAIA,EAAI,GAAIA,EAAI,MAEpD3Q,EAAUuS,SAASwD,EAAc,GAAIpF,GACrC3Q,EAAUx2D,YAAYxL,EAAM,GAAI2yE,EAAI,GAAIA,EAAI,GAAIA,EAAI,KAItD3Q,EAAUwQ,qBACV,IAAK,IAAIrzE,EAAI,EAAGA,EAAI8iE,EAAM3+B,MAAM/sC,QAC1B0rE,EAAM3+B,MAAMnkC,GAAGlM,GAAK+M,EAAM,IAAMiiE,EAAM3+B,MAAMnkC,GAAGlM,GAAK+M,EAAM,GAC5DiiE,EAAM3+B,MAAMn8B,OAAOhI,EAAG,KAEpBA,EAGN,OAAO,GAIT6iE,EAAUgW,2BAA6B,CAACz7D,EAAI1I,KAC1C,MAAMixC,EAAIkd,EAAUiW,uBACpB,OAAOrlF,KAAKslF,MAAMrkE,EAAK0I,GAAMuoC,IAI/Bkd,EAAUiW,qBAAuB,KAC/B,GAAIhW,EAAM3+B,MAAM/sC,OAAS,EACvB,OAAQ,EAEV,IAAI8Z,EAAWnQ,OAAOi4E,UACtB,IAAK,IAAIh5E,EAAI,EAAGA,EAAI8iE,EAAM3+B,MAAM/sC,OAAS,EAAG4I,IAAK,CAC/C,MAAMi5E,EAAcnW,EAAM3+B,MAAMnkC,EAAI,GAAGlM,EAAIgvE,EAAM3+B,MAAMnkC,GAAGlM,EACtDmlF,EAAc/nE,IAChBA,EAAW+nE,EAEf,CACA,OAAO/nE,GAET2xD,EAAUqW,uBAAyB,CAAC56D,EAAO66D,EAAQC,EAAWC,KAChC,IAAxBxW,EAAUnhD,UAIVohD,EAAMuS,cACRxS,EAAUyW,eAAeh7D,EAAO66D,EAAQC,EAAWC,GAEnDxW,EAAUt/D,QAAQ+a,EAAO66D,EAAQC,EAAWC,GAN5C3W,EAAc,qCAWlBG,EAAUt/D,QAAU,CAAC+a,EAAO66D,EAAQC,EAAWC,KAC7C,GAA4B,IAAxBxW,EAAUnhD,UAEZ,YADA6uD,EAAgB,oCAGlB,MAAMjZ,EAAQ7jE,KAAKsP,MAA6B,IAAvB8/D,EAAU0W,WAAqB,IAClDniF,EAASknB,EAAM05D,oBACfwB,EAASl7D,EAAMuxD,wBACf4J,EAAUN,EAAO92C,UACjBq3C,EAASp7D,EAAM+jB,UACfmxC,EAAM,GACZ,GAAI4F,IAAc9I,EAAoBqJ,KACpC,IAAK,IAAI35E,EAAI,EAAGA,EAAI5I,EAAQ4I,IAAK,CAC/B,MAAMlM,EAAI4lF,EAAO15E,EAAIw5E,EAASH,GAC9BxW,EAAUuS,SAASthF,EAAG0/E,GACtBiG,EAAY,EAAJz5E,GAASvM,KAAKsP,MAAe,IAATywE,EAAI,GAAa,IAC7CiG,EAAY,EAAJz5E,EAAQ,GAAKvM,KAAKsP,MAAe,IAATywE,EAAI,GAAa,IACjDiG,EAAY,EAAJz5E,EAAQ,GAAKvM,KAAKsP,MAAe,IAATywE,EAAI,GAAa,IACjDiG,EAAY,EAAJz5E,EAAQ,GAAKs3D,CACvB,CAEF,GAAI8hB,IAAc9I,EAAoB8B,IACpC,IAAK,IAAIpyE,EAAI,EAAGA,EAAI5I,EAAQ4I,IAAK,CAC/B,MAAMlM,EAAI4lF,EAAO15E,EAAIw5E,EAASH,GAC9BxW,EAAUuS,SAASthF,EAAG0/E,GACtBiG,EAAY,EAAJz5E,GAASvM,KAAKsP,MAAe,IAATywE,EAAI,GAAa,IAC7CiG,EAAY,EAAJz5E,EAAQ,GAAKvM,KAAKsP,MAAe,IAATywE,EAAI,GAAa,IACjDiG,EAAY,EAAJz5E,EAAQ,GAAKvM,KAAKsP,MAAe,IAATywE,EAAI,GAAa,GACnD,CAEF,GAAI4F,IAAc9I,EAAoBsJ,UACpC,IAAK,IAAI55E,EAAI,EAAGA,EAAI5I,EAAQ4I,IAAK,CAC/B,MAAMlM,EAAI4lF,EAAO15E,EAAIw5E,EAASH,GAC9BxW,EAAUuS,SAASthF,EAAG0/E,GACtBiG,EAAQz5E,GAAKvM,KAAKsP,MAAe,KAATywE,EAAI,GAAqB,OAATA,EAAI,GAAuB,MAATA,EAAI,GAAa,GAC7E,CAEF,GAAI4F,IAAc9I,EAAoBuJ,gBACpC,IAAK,IAAI75E,EAAI,EAAGA,EAAI5I,EAAQ4I,IAAK,CAC/B,MAAMlM,EAAI4lF,EAAO15E,EAAIw5E,EAASH,GAC9BxW,EAAUuS,SAASthF,EAAG0/E,GACtBiG,EAAY,EAAJz5E,GAASvM,KAAKsP,MAAe,KAATywE,EAAI,GAAqB,OAATA,EAAI,GAAuB,MAATA,EAAI,GAAa,IAC/EiG,EAAY,EAAJz5E,EAAQ,GAAKs3D,CACvB,GAKJuL,EAAUnvD,cAAgBomE,IACxB,MAAMC,EAAgBhmD,KAAKC,UAAU8uC,EAAMqP,YACvC2H,EAAS1J,aACXtN,EAAMqP,WAAa/B,EAAW0J,EAAS1J,WAAW4J,oBACzBxlF,IAArBsuE,EAAMqP,aACR1P,EAAc,cAAcqX,EAAS1J,+CACrCtN,EAAMqP,WAAa/B,EAAWgC,MAGlC,IAAI6H,EAAaF,IAAkBhmD,KAAKC,UAAU8uC,EAAMqP,YACxD,MAAM+H,EAAcD,GAAclmD,KAAKC,UAAU8uC,EAAMwP,UACvD,GAAIwH,EAASK,SAEX,IADArX,EAAMwP,SAAW,GAAG3/D,OAAOmnE,EAASK,UAC7BrX,EAAMwP,SAASl7E,OAAS,GAC7B0rE,EAAMwP,SAASrzE,KAAK,GAGxBg7E,EAAaA,GAAcC,IAAgBnmD,KAAKC,UAAU8uC,EAAMwP,UAChE,MAAM8H,EAAWH,GAAclmD,KAAKC,UAAU8uC,EAAM3+B,OACpD,GAAI21C,EAASjnE,UAAW,CACtB,MAAM6M,EAAOo6D,EAASjnE,UAAUzb,OAChC0rE,EAAM3+B,MAAQ,GACd,MAAM6uB,EAAW,GACXmgB,EAAY,EAClB,IAAK,IAAInzE,EAAI,EAAGA,EAAI0f,EAAM1f,GAAK,EAC7B8iE,EAAM3+B,MAAMllC,KAAK,CACfnL,EAAGgmF,EAASjnE,UAAU7S,GACtBgM,EAAG8tE,EAASjnE,UAAU7S,EAAI,GAC1BiM,EAAG6tE,EAASjnE,UAAU7S,EAAI,GAC1BkM,EAAG4tE,EAASjnE,UAAU7S,EAAI,GAC1BgzD,WACAmgB,aAGN,CACA,MAAMU,EAAkBhR,EAAUwQ,qBAC5BgH,GAAgBxG,IAAoBoG,GAAcG,IAAarmD,KAAKC,UAAU8uC,EAAM3+B,QAE1F,OADIk2C,GAAcxX,EAAUz9B,WACrByuC,GAAmBwG,EAE9B,CAgEEC,CAAyBzX,EAAWC,EACtC,CAQA,IAAIyX,EAA6B,CAC/BrY,YALkB,EAAAS,EAAMT,YAAYtqE,EAAQ,4BAM5CA,YACG,K,qrBC7rCE,SAASvB,IACd,IAAImkF,EAAM,IAAI,aAAoB,GAQlC,OANI,cAAuBj7E,eACzBi7E,EAAI,GAAK,EACTA,EAAI,GAAK,EACTA,EAAI,GAAK,GAGJA,CACT,CAQO,SAAS37D,EAAMzN,GACpB,IAAIopE,EAAM,IAAI,aAAoB,GAIlC,OAHAA,EAAI,GAAKppE,EAAE,GACXopE,EAAI,GAAKppE,EAAE,GACXopE,EAAI,GAAKppE,EAAE,GACJopE,CACT,CAQO,SAASpjF,EAAOga,GACrB,IAAItd,EAAIsd,EAAE,GACNpd,EAAIod,EAAE,GACNxN,EAAIwN,EAAE,GACV,OAAO3d,KAAKgnF,MAAM3mF,EAAGE,EAAG4P,EAC1B,CAUO,SAAS82E,EAAW5mF,EAAGE,EAAG4P,GAC/B,IAAI42E,EAAM,IAAI,aAAoB,GAIlC,OAHAA,EAAI,GAAK1mF,EACT0mF,EAAI,GAAKxmF,EACTwmF,EAAI,GAAK52E,EACF42E,CACT,CASO,SAASG,EAAKH,EAAKppE,GAIxB,OAHAopE,EAAI,GAAKppE,EAAE,GACXopE,EAAI,GAAKppE,EAAE,GACXopE,EAAI,GAAKppE,EAAE,GACJopE,CACT,CAWO,SAAS9jF,EAAI8jF,EAAK1mF,EAAGE,EAAG4P,GAI7B,OAHA42E,EAAI,GAAK1mF,EACT0mF,EAAI,GAAKxmF,EACTwmF,EAAI,GAAK52E,EACF42E,CACT,CAUO,SAAS1gF,EAAI0gF,EAAKppE,EAAGlF,GAI1B,OAHAsuE,EAAI,GAAKppE,EAAE,GAAKlF,EAAE,GAClBsuE,EAAI,GAAKppE,EAAE,GAAKlF,EAAE,GAClBsuE,EAAI,GAAKppE,EAAE,GAAKlF,EAAE,GACXsuE,CACT,CAUO,SAASI,EAASJ,EAAKppE,EAAGlF,GAI/B,OAHAsuE,EAAI,GAAKppE,EAAE,GAAKlF,EAAE,GAClBsuE,EAAI,GAAKppE,EAAE,GAAKlF,EAAE,GAClBsuE,EAAI,GAAKppE,EAAE,GAAKlF,EAAE,GACXsuE,CACT,CAUO,SAASK,EAASL,EAAKppE,EAAGlF,GAI/B,OAHAsuE,EAAI,GAAKppE,EAAE,GAAKlF,EAAE,GAClBsuE,EAAI,GAAKppE,EAAE,GAAKlF,EAAE,GAClBsuE,EAAI,GAAKppE,EAAE,GAAKlF,EAAE,GACXsuE,CACT,CAUO,SAASM,EAAON,EAAKppE,EAAGlF,GAI7B,OAHAsuE,EAAI,GAAKppE,EAAE,GAAKlF,EAAE,GAClBsuE,EAAI,GAAKppE,EAAE,GAAKlF,EAAE,GAClBsuE,EAAI,GAAKppE,EAAE,GAAKlF,EAAE,GACXsuE,CACT,CASO,SAASzB,EAAKyB,EAAKppE,GAIxB,OAHAopE,EAAI,GAAK/mF,KAAKslF,KAAK3nE,EAAE,IACrBopE,EAAI,GAAK/mF,KAAKslF,KAAK3nE,EAAE,IACrBopE,EAAI,GAAK/mF,KAAKslF,KAAK3nE,EAAE,IACdopE,CACT,CASO,SAASz3E,EAAMy3E,EAAKppE,GAIzB,OAHAopE,EAAI,GAAK/mF,KAAKsP,MAAMqO,EAAE,IACtBopE,EAAI,GAAK/mF,KAAKsP,MAAMqO,EAAE,IACtBopE,EAAI,GAAK/mF,KAAKsP,MAAMqO,EAAE,IACfopE,CACT,CAUO,SAASlmF,EAAIkmF,EAAKppE,EAAGlF,GAI1B,OAHAsuE,EAAI,GAAK/mF,KAAKa,IAAI8c,EAAE,GAAIlF,EAAE,IAC1BsuE,EAAI,GAAK/mF,KAAKa,IAAI8c,EAAE,GAAIlF,EAAE,IAC1BsuE,EAAI,GAAK/mF,KAAKa,IAAI8c,EAAE,GAAIlF,EAAE,IACnBsuE,CACT,CAUO,SAASt2E,EAAIs2E,EAAKppE,EAAGlF,GAI1B,OAHAsuE,EAAI,GAAK/mF,KAAKyQ,IAAIkN,EAAE,GAAIlF,EAAE,IAC1BsuE,EAAI,GAAK/mF,KAAKyQ,IAAIkN,EAAE,GAAIlF,EAAE,IAC1BsuE,EAAI,GAAK/mF,KAAKyQ,IAAIkN,EAAE,GAAIlF,EAAE,IACnBsuE,CACT,CASO,SAASriE,EAAMqiE,EAAKppE,GAIzB,OAHAopE,EAAI,GAAK/mF,KAAK0kB,MAAM/G,EAAE,IACtBopE,EAAI,GAAK/mF,KAAK0kB,MAAM/G,EAAE,IACtBopE,EAAI,GAAK/mF,KAAK0kB,MAAM/G,EAAE,IACfopE,CACT,CAUO,SAASxnF,EAAMwnF,EAAKppE,EAAGlF,GAI5B,OAHAsuE,EAAI,GAAKppE,EAAE,GAAKlF,EAChBsuE,EAAI,GAAKppE,EAAE,GAAKlF,EAChBsuE,EAAI,GAAKppE,EAAE,GAAKlF,EACTsuE,CACT,CAWO,SAASO,EAAYP,EAAKppE,EAAGlF,EAAGlZ,GAIrC,OAHAwnF,EAAI,GAAKppE,EAAE,GAAKlF,EAAE,GAAKlZ,EACvBwnF,EAAI,GAAKppE,EAAE,GAAKlF,EAAE,GAAKlZ,EACvBwnF,EAAI,GAAKppE,EAAE,GAAKlF,EAAE,GAAKlZ,EAChBwnF,CACT,CASO,SAAStpE,EAASE,EAAGlF,GAC1B,IAAIpY,EAAIoY,EAAE,GAAKkF,EAAE,GACbpd,EAAIkY,EAAE,GAAKkF,EAAE,GACbxN,EAAIsI,EAAE,GAAKkF,EAAE,GACjB,OAAO3d,KAAKgnF,MAAM3mF,EAAGE,EAAG4P,EAC1B,CASO,SAASo3E,EAAgB5pE,EAAGlF,GACjC,IAAIpY,EAAIoY,EAAE,GAAKkF,EAAE,GACbpd,EAAIkY,EAAE,GAAKkF,EAAE,GACbxN,EAAIsI,EAAE,GAAKkF,EAAE,GACjB,OAAOtd,EAAIA,EAAIE,EAAIA,EAAI4P,EAAIA,CAC7B,CAQO,SAASq3E,EAAc7pE,GAC5B,IAAItd,EAAIsd,EAAE,GACNpd,EAAIod,EAAE,GACNxN,EAAIwN,EAAE,GACV,OAAOtd,EAAIA,EAAIE,EAAIA,EAAI4P,EAAIA,CAC7B,CASO,SAASs3E,EAAOV,EAAKppE,GAI1B,OAHAopE,EAAI,IAAMppE,EAAE,GACZopE,EAAI,IAAMppE,EAAE,GACZopE,EAAI,IAAMppE,EAAE,GACLopE,CACT,CASO,SAASW,EAAQX,EAAKppE,GAI3B,OAHAopE,EAAI,GAAK,EAAMppE,EAAE,GACjBopE,EAAI,GAAK,EAAMppE,EAAE,GACjBopE,EAAI,GAAK,EAAMppE,EAAE,GACVopE,CACT,CASO,SAASY,EAAUZ,EAAKppE,GAC7B,IAAItd,EAAIsd,EAAE,GACNpd,EAAIod,EAAE,GACNxN,EAAIwN,EAAE,GACNk9C,EAAMx6D,EAAIA,EAAIE,EAAIA,EAAI4P,EAAIA,EAU9B,OARI0qD,EAAM,IAERA,EAAM,EAAI76D,KAAK8nC,KAAK+yB,IAGtBksB,EAAI,GAAKppE,EAAE,GAAKk9C,EAChBksB,EAAI,GAAKppE,EAAE,GAAKk9C,EAChBksB,EAAI,GAAKppE,EAAE,GAAKk9C,EACTksB,CACT,CASO,SAASp3B,EAAIhyC,EAAGlF,GACrB,OAAOkF,EAAE,GAAKlF,EAAE,GAAKkF,EAAE,GAAKlF,EAAE,GAAKkF,EAAE,GAAKlF,EAAE,EAC9C,CAUO,SAAS6lD,EAAMyoB,EAAKppE,EAAGlF,GAC5B,IAAImvE,EAAKjqE,EAAE,GACPkqE,EAAKlqE,EAAE,GACPmqE,EAAKnqE,EAAE,GACPoqE,EAAKtvE,EAAE,GACPuvE,EAAKvvE,EAAE,GACPwvE,EAAKxvE,EAAE,GAIX,OAHAsuE,EAAI,GAAKc,EAAKI,EAAKH,EAAKE,EACxBjB,EAAI,GAAKe,EAAKC,EAAKH,EAAKK,EACxBlB,EAAI,GAAKa,EAAKI,EAAKH,EAAKE,EACjBhB,CACT,CAWO,SAASmB,EAAKnB,EAAKppE,EAAGlF,EAAGk0B,GAC9B,IAAIi7C,EAAKjqE,EAAE,GACPkqE,EAAKlqE,EAAE,GACPmqE,EAAKnqE,EAAE,GAIX,OAHAopE,EAAI,GAAKa,EAAKj7C,GAAKl0B,EAAE,GAAKmvE,GAC1Bb,EAAI,GAAKc,EAAKl7C,GAAKl0B,EAAE,GAAKovE,GAC1Bd,EAAI,GAAKe,EAAKn7C,GAAKl0B,EAAE,GAAKqvE,GACnBf,CACT,CAaO,SAASoB,EAAQpB,EAAKppE,EAAGlF,EAAGmnB,EAAGsyB,EAAGvlB,GACvC,IAAIy7C,EAAez7C,EAAIA,EACnB07C,EAAUD,GAAgB,EAAIz7C,EAAI,GAAK,EACvC27C,EAAUF,GAAgBz7C,EAAI,GAAKA,EACnC47C,EAAUH,GAAgBz7C,EAAI,GAC9B67C,EAAUJ,GAAgB,EAAI,EAAIz7C,GAItC,OAHAo6C,EAAI,GAAKppE,EAAE,GAAK0qE,EAAU5vE,EAAE,GAAK6vE,EAAU1oD,EAAE,GAAK2oD,EAAUr2B,EAAE,GAAKs2B,EACnEzB,EAAI,GAAKppE,EAAE,GAAK0qE,EAAU5vE,EAAE,GAAK6vE,EAAU1oD,EAAE,GAAK2oD,EAAUr2B,EAAE,GAAKs2B,EACnEzB,EAAI,GAAKppE,EAAE,GAAK0qE,EAAU5vE,EAAE,GAAK6vE,EAAU1oD,EAAE,GAAK2oD,EAAUr2B,EAAE,GAAKs2B,EAC5DzB,CACT,CAaO,SAAS0B,EAAO1B,EAAKppE,EAAGlF,EAAGmnB,EAAGsyB,EAAGvlB,GACtC,IAAI+7C,EAAgB,EAAI/7C,EACpBg8C,EAAwBD,EAAgBA,EACxCN,EAAez7C,EAAIA,EACnB07C,EAAUM,EAAwBD,EAClCJ,EAAU,EAAI37C,EAAIg8C,EAClBJ,EAAU,EAAIH,EAAeM,EAC7BF,EAAUJ,EAAez7C,EAI7B,OAHAo6C,EAAI,GAAKppE,EAAE,GAAK0qE,EAAU5vE,EAAE,GAAK6vE,EAAU1oD,EAAE,GAAK2oD,EAAUr2B,EAAE,GAAKs2B,EACnEzB,EAAI,GAAKppE,EAAE,GAAK0qE,EAAU5vE,EAAE,GAAK6vE,EAAU1oD,EAAE,GAAK2oD,EAAUr2B,EAAE,GAAKs2B,EACnEzB,EAAI,GAAKppE,EAAE,GAAK0qE,EAAU5vE,EAAE,GAAK6vE,EAAU1oD,EAAE,GAAK2oD,EAAUr2B,EAAE,GAAKs2B,EAC5DzB,CACT,CASO,SAASrnD,EAAOqnD,EAAKxnF,GAC1BA,EAAQA,GAAS,EACjB,IAAIgZ,EAAwB,EAApB,WAA0BvY,KAAKC,GACnCkQ,EAAwB,EAApB,WAA0B,EAC9By4E,EAAS5oF,KAAK8nC,KAAK,EAAM33B,EAAIA,GAAK5Q,EAItC,OAHAwnF,EAAI,GAAK/mF,KAAKigD,IAAI1nC,GAAKqwE,EACvB7B,EAAI,GAAK/mF,KAAKkgD,IAAI3nC,GAAKqwE,EACvB7B,EAAI,GAAK52E,EAAI5Q,EACNwnF,CACT,CAWO,SAAS8B,EAAc9B,EAAKppE,EAAGuxD,GACpC,IAAI7uE,EAAIsd,EAAE,GACNpd,EAAIod,EAAE,GACNxN,EAAIwN,EAAE,GACNmrE,EAAI5Z,EAAE,GAAK7uE,EAAI6uE,EAAE,GAAK3uE,EAAI2uE,EAAE,IAAM/+D,EAAI++D,EAAE,IAK5C,OAJA4Z,EAAIA,GAAK,EACT/B,EAAI,IAAM7X,EAAE,GAAK7uE,EAAI6uE,EAAE,GAAK3uE,EAAI2uE,EAAE,GAAK/+D,EAAI++D,EAAE,KAAO4Z,EACpD/B,EAAI,IAAM7X,EAAE,GAAK7uE,EAAI6uE,EAAE,GAAK3uE,EAAI2uE,EAAE,GAAK/+D,EAAI++D,EAAE,KAAO4Z,EACpD/B,EAAI,IAAM7X,EAAE,GAAK7uE,EAAI6uE,EAAE,GAAK3uE,EAAI2uE,EAAE,IAAM/+D,EAAI++D,EAAE,KAAO4Z,EAC9C/B,CACT,CAUO,SAASgC,EAAchC,EAAKppE,EAAGuxD,GACpC,IAAI7uE,EAAIsd,EAAE,GACNpd,EAAIod,EAAE,GACNxN,EAAIwN,EAAE,GAIV,OAHAopE,EAAI,GAAK1mF,EAAI6uE,EAAE,GAAK3uE,EAAI2uE,EAAE,GAAK/+D,EAAI++D,EAAE,GACrC6X,EAAI,GAAK1mF,EAAI6uE,EAAE,GAAK3uE,EAAI2uE,EAAE,GAAK/+D,EAAI++D,EAAE,GACrC6X,EAAI,GAAK1mF,EAAI6uE,EAAE,GAAK3uE,EAAI2uE,EAAE,GAAK/+D,EAAI++D,EAAE,GAC9B6X,CACT,CAWO,SAASiC,EAAcjC,EAAKppE,EAAG28C,GAEpC,IAAI2uB,EAAK3uB,EAAE,GACP4uB,EAAK5uB,EAAE,GACP6uB,EAAK7uB,EAAE,GACP8uB,EAAK9uB,EAAE,GACPj6D,EAAIsd,EAAE,GACNpd,EAAIod,EAAE,GACNxN,EAAIwN,EAAE,GAGN0rE,EAAMH,EAAK/4E,EAAIg5E,EAAK5oF,EACpB+oF,EAAMH,EAAK9oF,EAAI4oF,EAAK94E,EACpBo5E,EAAMN,EAAK1oF,EAAI2oF,EAAK7oF,EAEpBmpF,EAAON,EAAKK,EAAMJ,EAAKG,EACvBG,EAAON,EAAKE,EAAMJ,EAAKM,EACvBG,EAAOT,EAAKK,EAAMJ,EAAKG,EAEvBM,EAAU,EAALP,EAYT,OAXAC,GAAOM,EACPL,GAAOK,EACPJ,GAAOI,EAEPH,GAAQ,EACRC,GAAQ,EACRC,GAAQ,EAER3C,EAAI,GAAK1mF,EAAIgpF,EAAMG,EACnBzC,EAAI,GAAKxmF,EAAI+oF,EAAMG,EACnB1C,EAAI,GAAK52E,EAAIo5E,EAAMG,EACZ3C,CACT,CAUO,SAAS6C,EAAQ7C,EAAKppE,EAAGlF,EAAGoxE,GACjC,IAAI75E,EAAI,GACJuI,EAAI,GAaR,OAXAvI,EAAE,GAAK2N,EAAE,GAAKlF,EAAE,GAChBzI,EAAE,GAAK2N,EAAE,GAAKlF,EAAE,GAChBzI,EAAE,GAAK2N,EAAE,GAAKlF,EAAE,GAEhBF,EAAE,GAAKvI,EAAE,GACTuI,EAAE,GAAKvI,EAAE,GAAKhQ,KAAKigD,IAAI4pC,GAAO75E,EAAE,GAAKhQ,KAAKkgD,IAAI2pC,GAC9CtxE,EAAE,GAAKvI,EAAE,GAAKhQ,KAAKkgD,IAAI2pC,GAAO75E,EAAE,GAAKhQ,KAAKigD,IAAI4pC,GAE9C9C,EAAI,GAAKxuE,EAAE,GAAKE,EAAE,GAClBsuE,EAAI,GAAKxuE,EAAE,GAAKE,EAAE,GAClBsuE,EAAI,GAAKxuE,EAAE,GAAKE,EAAE,GACXsuE,CACT,CAUO,SAAS+C,EAAQ/C,EAAKppE,EAAGlF,EAAGoxE,GACjC,IAAI75E,EAAI,GACJuI,EAAI,GAaR,OAXAvI,EAAE,GAAK2N,EAAE,GAAKlF,EAAE,GAChBzI,EAAE,GAAK2N,EAAE,GAAKlF,EAAE,GAChBzI,EAAE,GAAK2N,EAAE,GAAKlF,EAAE,GAEhBF,EAAE,GAAKvI,EAAE,GAAKhQ,KAAKkgD,IAAI2pC,GAAO75E,EAAE,GAAKhQ,KAAKigD,IAAI4pC,GAC9CtxE,EAAE,GAAKvI,EAAE,GACTuI,EAAE,GAAKvI,EAAE,GAAKhQ,KAAKigD,IAAI4pC,GAAO75E,EAAE,GAAKhQ,KAAKkgD,IAAI2pC,GAE9C9C,EAAI,GAAKxuE,EAAE,GAAKE,EAAE,GAClBsuE,EAAI,GAAKxuE,EAAE,GAAKE,EAAE,GAClBsuE,EAAI,GAAKxuE,EAAE,GAAKE,EAAE,GACXsuE,CACT,CAUO,SAASgD,EAAQhD,EAAKppE,EAAGlF,EAAGoxE,GACjC,IAAI75E,EAAI,GACJuI,EAAI,GAaR,OAXAvI,EAAE,GAAK2N,EAAE,GAAKlF,EAAE,GAChBzI,EAAE,GAAK2N,EAAE,GAAKlF,EAAE,GAChBzI,EAAE,GAAK2N,EAAE,GAAKlF,EAAE,GAEhBF,EAAE,GAAKvI,EAAE,GAAKhQ,KAAKigD,IAAI4pC,GAAO75E,EAAE,GAAKhQ,KAAKkgD,IAAI2pC,GAC9CtxE,EAAE,GAAKvI,EAAE,GAAKhQ,KAAKkgD,IAAI2pC,GAAO75E,EAAE,GAAKhQ,KAAKigD,IAAI4pC,GAC9CtxE,EAAE,GAAKvI,EAAE,GAET+2E,EAAI,GAAKxuE,EAAE,GAAKE,EAAE,GAClBsuE,EAAI,GAAKxuE,EAAE,GAAKE,EAAE,GAClBsuE,EAAI,GAAKxuE,EAAE,GAAKE,EAAE,GACXsuE,CACT,CAQO,SAASlnF,EAAM8d,EAAGlF,GACvB,IAAImvE,EAAKjqE,EAAE,GACPkqE,EAAKlqE,EAAE,GACPmqE,EAAKnqE,EAAE,GACPoqE,EAAKtvE,EAAE,GACPuvE,EAAKvvE,EAAE,GACPwvE,EAAKxvE,EAAE,GAGPuxE,EAFOhqF,KAAK8nC,KAAK8/C,EAAKA,EAAKC,EAAKA,EAAKC,EAAKA,GACnC9nF,KAAK8nC,KAAKigD,EAAKA,EAAKC,EAAKA,EAAKC,EAAKA,GAE1CgC,EAASD,GAAOr6B,EAAIhyC,EAAGlF,GAAKuxE,EAChC,OAAOhqF,KAAKo9E,KAAKp9E,KAAKa,IAAIb,KAAKyQ,IAAIw5E,GAAS,GAAI,GAClD,CAQO,SAASC,EAAKnD,GAInB,OAHAA,EAAI,GAAK,EACTA,EAAI,GAAK,EACTA,EAAI,GAAK,EACFA,CACT,CAQO,SAASzkE,EAAI3E,GAClB,MAAO,QAAUA,EAAE,GAAK,KAAOA,EAAE,GAAK,KAAOA,EAAE,GAAK,GACtD,CASO,SAASwsE,EAAYxsE,EAAGlF,GAC7B,OAAOkF,EAAE,KAAOlF,EAAE,IAAMkF,EAAE,KAAOlF,EAAE,IAAMkF,EAAE,KAAOlF,EAAE,EACtD,CASO,SAAS2xE,EAAOzsE,EAAGlF,GACxB,IAAI4xE,EAAK1sE,EAAE,GACPsgE,EAAKtgE,EAAE,GACPugE,EAAKvgE,EAAE,GACP2sE,EAAK7xE,EAAE,GACPsoE,EAAKtoE,EAAE,GACPyoE,EAAKzoE,EAAE,GACX,OAAOzY,KAAKud,IAAI8sE,EAAKC,IAAO,UAAmBtqF,KAAKyQ,IAAI,EAAKzQ,KAAKud,IAAI8sE,GAAKrqF,KAAKud,IAAI+sE,KAAQtqF,KAAKud,IAAI0gE,EAAK8C,IAAO,UAAmB/gF,KAAKyQ,IAAI,EAAKzQ,KAAKud,IAAI0gE,GAAKj+E,KAAKud,IAAIwjE,KAAQ/gF,KAAKud,IAAI2gE,EAAKgD,IAAO,UAAmBlhF,KAAKyQ,IAAI,EAAKzQ,KAAKud,IAAI2gE,GAAKl+E,KAAKud,IAAI2jE,GAChQ,CAMO,IAmDDqJ,EAnDK/yD,EAAM2vD,EAMNqD,EAAMpD,EAMNqD,EAAMpD,EAMNqD,EAAOjtE,EAMPktE,EAAUpD,EAMV1sB,EAAMl3D,EAMNinF,EAASpD,EAcTxjF,GACLumF,EAAM3nF,IACH,SAAU+a,EAAGktE,EAAQj8E,EAAQ2B,EAAOu6E,EAAIC,GAC7C,IAAIx+E,EAAGy+E,EAgBP,IAdKH,IACHA,EAAS,GAGNj8E,IACHA,EAAS,GAITo8E,EADEz6E,EACEvQ,KAAKa,IAAI0P,EAAQs6E,EAASj8E,EAAQ+O,EAAEha,QAEpCga,EAAEha,OAGH4I,EAAIqC,EAAQrC,EAAIy+E,EAAGz+E,GAAKs+E,EAC3BN,EAAI,GAAK5sE,EAAEpR,GACXg+E,EAAI,GAAK5sE,EAAEpR,EAAI,GACfg+E,EAAI,GAAK5sE,EAAEpR,EAAI,GACfu+E,EAAGP,EAAKA,EAAKQ,GACbptE,EAAEpR,GAAKg+E,EAAI,GACX5sE,EAAEpR,EAAI,GAAKg+E,EAAI,GACf5sE,EAAEpR,EAAI,GAAKg+E,EAAI,GAGjB,OAAO5sE,CACT,E,6DC9wBa,SAASstE,EAASp7E,GAC/B,IAAIq7E,EAAUC,EAAUr0E,EAiBxB,SAASutC,EAAK1mC,EAAGtd,EAAG+qF,EAAK,EAAGC,EAAK1tE,EAAEha,QACjC,GAAIynF,EAAKC,EAAI,CACX,GAAuB,IAAnBH,EAAS7qF,EAAGA,GAAU,OAAOgrF,EACjC,EAAG,CACD,MAAMC,EAAOF,EAAKC,IAAQ,EACtBF,EAASxtE,EAAE2tE,GAAMjrF,GAAK,EAAG+qF,EAAKE,EAAM,EACnCD,EAAKC,CACZ,OAASF,EAAKC,EAChB,CACA,OAAOD,CACT,CAmBA,OAvCiB,IAAbv7E,EAAElM,QACJunF,EAAW,IACXC,EAAW,CAACj5B,EAAG7xD,KAAM,OAAUwP,EAAEqiD,GAAI7xD,GACrCyW,EAAQ,CAACo7C,EAAG7xD,IAAMwP,EAAEqiD,GAAK7xD,IAEzB6qF,EAAWr7E,IAAM,KAAaA,IAAM,IAAaA,EAAIq6E,EACrDiB,EAAWt7E,EACXiH,EAAQjH,GAgCH,CAACw0C,OAAMlsC,OALd,SAAgBwF,EAAGtd,EAAG+qF,EAAK,EAAGC,EAAK1tE,EAAEha,QACnC,MAAM4I,EAAI83C,EAAK1mC,EAAGtd,EAAG+qF,EAAIC,EAAK,GAC9B,OAAO9+E,EAAI6+E,GAAMt0E,EAAM6G,EAAEpR,EAAI,GAAIlM,IAAMyW,EAAM6G,EAAEpR,GAAIlM,GAAKkM,EAAI,EAAIA,CAClE,EAEsBohD,MAjBtB,SAAehwC,EAAGtd,EAAG+qF,EAAK,EAAGC,EAAK1tE,EAAEha,QAClC,GAAIynF,EAAKC,EAAI,CACX,GAAuB,IAAnBH,EAAS7qF,EAAGA,GAAU,OAAOgrF,EACjC,EAAG,CACD,MAAMC,EAAOF,EAAKC,IAAQ,EACtBF,EAASxtE,EAAE2tE,GAAMjrF,IAAM,EAAG+qF,EAAKE,EAAM,EACpCD,EAAKC,CACZ,OAASF,EAAKC,EAChB,CACA,OAAOD,CACT,EAQF,CAEA,SAASlB,IACP,OAAO,CACT,C,kDCrDe,SAASqB,IACtB,OAAO,OAAU3d,UACnB,C,mCCJA,QAAevtE,GAAK,IAAMA,C,kBCAX,WAASsd,EAAGlF,GACzB,OAAOkF,GAAKA,EAAGlF,GAAKA,EAAG,SAASk0B,GAC9B,OAAOhvB,GAAK,EAAIgvB,GAAKl0B,EAAIk0B,CAC3B,CACF,C,kCCJe,WAAS6+C,EAAcv8D,GAEpC,IADA,IAAIw8D,EAAU,IAAIhqF,MAAMwtB,GACf1iB,EAAI,EAAGA,EAAI0iB,IAAK1iB,EAAGk/E,EAAQl/E,GAAKi/E,EAAaj/E,GAAK0iB,EAAI,IAC/D,OAAOw8D,CACT,C,kCCJe,WAAS9tE,EAAGlF,GACzB,OAAOkF,GAAKA,EAAGlF,GAAKA,EAAG,SAASk0B,GAC9B,OAAO3sC,KAAK0kB,MAAM/G,GAAK,EAAIgvB,GAAKl0B,EAAIk0B,EACtC,CACF,C","sources":["webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/drawImageSync.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/calculateTransform.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getDefaultViewport.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/enums/GenerateImageType.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/Settings.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/loaders/imageLoader.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/FrameRange.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/PointsManager.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/ProgressiveIterator.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/RLEVoxelMap.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/actorCheck.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/applyPreset.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/autoLoad.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/buildMetadata.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calculateSpacingBetweenImageIds.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/clamp.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/colormap.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createLinearRGBTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createSigmoidRGBTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/decimate.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepClone.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/fnv1aHash.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getClosestImageId.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageDataMetadata.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageSliceDataForVolumeViewport.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getScalingParameters.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSliceRange.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSpacingInNormalDirection.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getTargetVolumeAndSpacingInNormalDir.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportsWithVolumeId.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVoiFromSigmoidRGBTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeActorCorners.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeId.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeSliceRangeInfo.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeViewportScrollInfo.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/hasFloatScalingParameters.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/hasNaNValues.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageIdToURI.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageRetrieveMetadataProvider.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/eventListener/TargetEventListeners.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/eventListener/MultiTargetEventListenerManager.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/scaleRgbTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getMinMax.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getRuntimeId.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calibratedPixelSpacingMetadataProvider.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isOpposite.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/indexWithinDimensions.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeViewportsContainingSameVolumes.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isPTPrescaledWithSUV.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/renderToCanvasGPU.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/renderToCanvasCPU.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/loadImageToCanvas.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/asArray.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/historyMemo/index.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/worldToImageCoords.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageToWorldCoords.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportsWithImageURI.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getClosestStackImageIndexForPoint.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getCurrentVolumeViewportSlice.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/spatialRegistrationMetadataProvider.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calculateViewportsSpatialRegistration.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportImageCornersInWorld.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageLegacy.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isValidVolume.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isVideoTransferSyntax.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertStackToVolumeViewport.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertVolumeToStackViewport.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/roundNumber.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertToGrayscale.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportImageIds.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getRandomSampleFromArray.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/color.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepEqual.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/splitImageIdsBy4DTags.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getDynamicVolumeInfo.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/scaleArray.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/clip.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/scroll.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/jumpToSlice.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createSubVolume.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeDirectionVectors.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calculateNeighborhoodStats.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getPixelSpacingInformation.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/index.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportModality.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/invertRgbTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isEqual.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/logger.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/makeVolumeMetadata.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/planar.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/pointInShapeCallback.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/snapFocalPointToSlice.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/sortImageIdsAndGetSpacing.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transferFunctionUtils.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformCanvasToIJK.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformIndexToWorld.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformWorldToIndex.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/updatePlaneRestriction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/updateVTKImageDataWithCornerstoneImage.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/windowLevel.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ChangeTypes.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Touch.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentLocking.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationEventManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/svgNodeCache.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/BidirectionalTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/BrushTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillCircle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillRectangle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/annotationHydration.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/getBoundingBoxAroundShape.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/contourFinder.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findHandlePolylineIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/getDeduplicatedVTKPolyDataPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getSphereBoundsInfo.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getToolsWithModesForElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/Calculator.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPointSquared.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPointSquaredInfo.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/isPointOnLineSegment.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/distanceToPointSquared.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/distanceToPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/point/mirror.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/addCanvasPointsToArray.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/areLineSegmentsIntersecting.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/combinePolyline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/containsPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/convexHull.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getAABB.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getArea.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getClosestLineSegmentIntersection.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getFirstLineSegmentIntersectionIndexes.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLineSegmentIntersectionsCoordinates.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLineSegmentIntersectionsIndexes.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getLinesIntersection.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getNormal2.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getNormal3.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getSubPixelSpacingAndXYDirections.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/getWindingDirection.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/intersectPolyline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/intersectPolylines.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/isPointInsidePolyline3D.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/pointCanProjectOnLine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/pointsAreWithinCloseContourProximity.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/projectTo2D.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/robustSegmentIntersection.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/polyline/subtractPolylines.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/findLargestBidirectional.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/isLineInSegment.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForToolGroupIds.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/SegmentStatsCalculator.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/constants.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runOneClickGrowCut.js","webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/EdgeLocator.js","webpack:///../../../node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares/caseTable.js","webpack:///../../../node_modules/@kitware/vtk.js/Filters/General/ImageMarchingSquares.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/workers/computeWorker.js","webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/Constants.js","webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js","webpack:///../../../node_modules/gl-matrix/esm/vec3.js","webpack:///../../../node_modules/d3-array/src/bisector.js","webpack:///../../../node_modules/d3-array/src/zip.js","webpack:///../../../node_modules/d3-interpolate/src/constant.js","webpack:///../../../node_modules/d3-interpolate/src/number.js","webpack:///../../../node_modules/d3-interpolate/src/quantize.js","webpack:///../../../node_modules/d3-interpolate/src/round.js"],"sourcesContent":["import now from './rendering/now';\nimport { renderColorImage } from './rendering/renderColorImage';\nimport { renderGrayscaleImage } from './rendering/renderGrayscaleImage';\nimport { renderPseudoColorImage } from './rendering/renderPseudoColorImage';\nexport default function (enabledElement, invalidated) {\n    const image = enabledElement.image;\n    if (!enabledElement.canvas || !enabledElement.image) {\n        return;\n    }\n    const start = now();\n    image.stats = {\n        lastGetPixelDataTime: -1.0,\n        lastStoredPixelDataToCanvasImageDataTime: -1.0,\n        lastPutImageDataTime: -1.0,\n        lastRenderTime: -1.0,\n        lastLutGenerateTime: -1.0,\n    };\n    if (image) {\n        let render = image.render;\n        if (!render) {\n            if (enabledElement.viewport.colormap) {\n                render = renderPseudoColorImage;\n            }\n            else if (image.color) {\n                render = renderColorImage;\n            }\n            else {\n                render = renderGrayscaleImage;\n            }\n        }\n        render(enabledElement, invalidated);\n    }\n    const renderTimeInMs = now() - start;\n    image.stats.lastRenderTime = renderTimeInMs;\n    enabledElement.invalid = false;\n    enabledElement.needsRedraw = false;\n}\n","import { Transform } from './transform';\nexport default function (enabledElement, scale) {\n    const transform = new Transform();\n    if (!enabledElement.viewport.displayedArea) {\n        return transform;\n    }\n    transform.translate(enabledElement.canvas.width / 2, enabledElement.canvas.height / 2);\n    const angle = enabledElement.viewport.rotation;\n    if (angle !== 0) {\n        transform.rotate((angle * Math.PI) / 180);\n    }\n    let widthScale = enabledElement.viewport.scale;\n    let heightScale = enabledElement.viewport.scale;\n    const width = enabledElement.viewport.displayedArea.brhc.x -\n        (enabledElement.viewport.displayedArea.tlhc.x - 1);\n    const height = enabledElement.viewport.displayedArea.brhc.y -\n        (enabledElement.viewport.displayedArea.tlhc.y - 1);\n    if (enabledElement.viewport.displayedArea.presentationSizeMode === 'NONE') {\n        if (enabledElement.image.rowPixelSpacing <\n            enabledElement.image.columnPixelSpacing) {\n            widthScale *=\n                enabledElement.image.columnPixelSpacing /\n                    enabledElement.image.rowPixelSpacing;\n        }\n        else if (enabledElement.image.columnPixelSpacing <\n            enabledElement.image.rowPixelSpacing) {\n            heightScale *=\n                enabledElement.image.rowPixelSpacing /\n                    enabledElement.image.columnPixelSpacing;\n        }\n    }\n    else {\n        widthScale = enabledElement.viewport.displayedArea.columnPixelSpacing;\n        heightScale = enabledElement.viewport.displayedArea.rowPixelSpacing;\n        if (enabledElement.viewport.displayedArea.presentationSizeMode ===\n            'SCALE TO FIT') {\n            const verticalScale = enabledElement.canvas.height / (height * heightScale);\n            const horizontalScale = enabledElement.canvas.width / (width * widthScale);\n            widthScale = heightScale = Math.min(horizontalScale, verticalScale);\n            if (enabledElement.viewport.displayedArea.rowPixelSpacing <\n                enabledElement.viewport.displayedArea.columnPixelSpacing) {\n                widthScale *=\n                    enabledElement.viewport.displayedArea.columnPixelSpacing /\n                        enabledElement.viewport.displayedArea.rowPixelSpacing;\n            }\n            else if (enabledElement.viewport.displayedArea.columnPixelSpacing <\n                enabledElement.viewport.displayedArea.rowPixelSpacing) {\n                heightScale *=\n                    enabledElement.viewport.displayedArea.rowPixelSpacing /\n                        enabledElement.viewport.displayedArea.columnPixelSpacing;\n            }\n        }\n    }\n    transform.scale(widthScale, heightScale);\n    if (angle !== 0) {\n        transform.rotate((-angle * Math.PI) / 180);\n    }\n    transform.translate(enabledElement.viewport.translation.x, enabledElement.viewport.translation.y);\n    if (angle !== 0) {\n        transform.rotate((angle * Math.PI) / 180);\n    }\n    if (scale !== undefined) {\n        transform.scale(scale, scale);\n    }\n    if (enabledElement.viewport.hflip) {\n        transform.scale(-1, 1);\n    }\n    if (enabledElement.viewport.vflip) {\n        transform.scale(1, -1);\n    }\n    transform.translate(-width / 2, -height / 2);\n    return transform;\n}\n","import createViewport from './createViewport';\nimport getImageFitScale from './getImageFitScale';\nexport default function (canvas, image, modality, colormap) {\n    if (canvas === undefined) {\n        throw new Error('getDefaultViewport: parameter canvas must not be undefined');\n    }\n    if (image === undefined) {\n        return createViewport();\n    }\n    const scale = getImageFitScale(canvas, image, 0).scaleFactor;\n    let voi;\n    if (modality === 'PT' && image.isPreScaled) {\n        voi = {\n            windowWidth: 5,\n            windowCenter: 2.5,\n        };\n    }\n    else if (image.windowWidth !== undefined &&\n        image.windowCenter !== undefined) {\n        voi = {\n            windowWidth: Array.isArray(image.windowWidth)\n                ? image.windowWidth[0]\n                : image.windowWidth,\n            windowCenter: Array.isArray(image.windowCenter)\n                ? image.windowCenter[0]\n                : image.windowCenter,\n        };\n    }\n    return {\n        scale,\n        translation: {\n            x: 0,\n            y: 0,\n        },\n        voi,\n        invert: image.invert,\n        pixelReplication: false,\n        rotation: 0,\n        hflip: false,\n        vflip: false,\n        modalityLUT: image.modalityLUT,\n        modality,\n        voiLUT: image.voiLUT,\n        colormap: colormap !== undefined ? colormap : image.colormap,\n        displayedArea: {\n            tlhc: {\n                x: 1,\n                y: 1,\n            },\n            brhc: {\n                x: image.columns,\n                y: image.rows,\n            },\n            rowPixelSpacing: image.rowPixelSpacing === undefined ? 1 : image.rowPixelSpacing,\n            columnPixelSpacing: image.columnPixelSpacing === undefined ? 1 : image.columnPixelSpacing,\n            presentationSizeMode: 'NONE',\n        },\n    };\n}\n","export var GenerateImageType;\n(function (GenerateImageType) {\n    GenerateImageType[\"SUM\"] = \"SUM\";\n    GenerateImageType[\"SUBTRACT\"] = \"SUBTRACT\";\n    GenerateImageType[\"AVERAGE\"] = \"AVERAGE\";\n})(GenerateImageType || (GenerateImageType = {}));\n","const DEFAULT_SETTINGS = Symbol('DefaultSettings');\nconst RUNTIME_SETTINGS = Symbol('RuntimeSettings');\nconst OBJECT_SETTINGS_MAP = Symbol('ObjectSettingsMap');\nconst DICTIONARY = Symbol('Dictionary');\nexport default class Settings {\n    constructor(base) {\n        const dictionary = Object.create((base instanceof Settings && DICTIONARY in base\n            ? base[DICTIONARY]\n            : null));\n        Object.seal(Object.defineProperty(this, DICTIONARY, {\n            value: dictionary,\n        }));\n    }\n    set(key, value) {\n        return set(this[DICTIONARY], key, value, null);\n    }\n    get(key) {\n        return get(this[DICTIONARY], key);\n    }\n    unset(key) {\n        return unset(this[DICTIONARY], key + '');\n    }\n    forEach(callback) {\n        iterate(this[DICTIONARY], callback);\n    }\n    extend() {\n        return new Settings(this);\n    }\n    import(root) {\n        if (isPlainObject(root)) {\n            Object.keys(root).forEach((key) => {\n                set(this[DICTIONARY], key, root[key], null);\n            });\n        }\n    }\n    dump() {\n        const context = {};\n        iterate(this[DICTIONARY], (key, value) => {\n            if (typeof value !== 'undefined') {\n                deepSet(context, key, value);\n            }\n        });\n        return context;\n    }\n    static assert(subject) {\n        return subject instanceof Settings\n            ? subject\n            : Settings.getRuntimeSettings();\n    }\n    static getDefaultSettings(subfield = null) {\n        let defaultSettings = Settings[DEFAULT_SETTINGS];\n        if (!(defaultSettings instanceof Settings)) {\n            defaultSettings = new Settings();\n            Settings[DEFAULT_SETTINGS] = defaultSettings;\n        }\n        if (subfield) {\n            const settingObj = {};\n            defaultSettings.forEach((name) => {\n                if (name.startsWith(subfield)) {\n                    const setting = name.split(`${subfield}.`)[1];\n                    settingObj[setting] = defaultSettings.get(name);\n                }\n            });\n            return settingObj;\n        }\n        return defaultSettings;\n    }\n    static getRuntimeSettings() {\n        let runtimeSettings = Settings[RUNTIME_SETTINGS];\n        if (!(runtimeSettings instanceof Settings)) {\n            runtimeSettings = new Settings(Settings.getDefaultSettings());\n            Settings[RUNTIME_SETTINGS] = runtimeSettings;\n        }\n        return runtimeSettings;\n    }\n    static getObjectSettings(subject, from) {\n        let settings = null;\n        if (subject instanceof Settings) {\n            settings = subject;\n        }\n        else if (typeof subject === 'object' && subject !== null) {\n            let objectSettingsMap = Settings[OBJECT_SETTINGS_MAP];\n            if (!(objectSettingsMap instanceof WeakMap)) {\n                objectSettingsMap = new WeakMap();\n                Settings[OBJECT_SETTINGS_MAP] = objectSettingsMap;\n            }\n            settings = objectSettingsMap.get(subject);\n            if (!(settings instanceof Settings)) {\n                settings = new Settings(Settings.assert(Settings.getObjectSettings(from)));\n                objectSettingsMap.set(subject, settings);\n            }\n        }\n        return settings;\n    }\n    static extendRuntimeSettings() {\n        return Settings.getRuntimeSettings().extend();\n    }\n}\nfunction unset(dictionary, name) {\n    if (name.endsWith('.')) {\n        let deleteCount = 0;\n        const namespace = name;\n        const base = namespace.slice(0, -1);\n        const deleteAll = base.length === 0;\n        for (const key in dictionary) {\n            if (Object.prototype.hasOwnProperty.call(dictionary, key) &&\n                (deleteAll || key.startsWith(namespace) || key === base)) {\n                delete dictionary[key];\n                ++deleteCount;\n            }\n        }\n        return deleteCount > 0;\n    }\n    return delete dictionary[name];\n}\nfunction iterate(dictionary, callback) {\n    for (const key in dictionary) {\n        callback(key, dictionary[key]);\n    }\n}\nfunction setAll(dictionary, prefix, record, references) {\n    let failCount;\n    if (references.has(record)) {\n        return set(dictionary, prefix, null, references);\n    }\n    references.add(record);\n    failCount = 0;\n    for (const field in record) {\n        if (Object.prototype.hasOwnProperty.call(record, field)) {\n            const key = field.length === 0 ? prefix : `${prefix}.${field}`;\n            if (!set(dictionary, key, record[field], references)) {\n                ++failCount;\n            }\n        }\n    }\n    references.delete(record);\n    return failCount === 0;\n}\nfunction set(dictionary, key, value, references) {\n    if (isValidKey(key)) {\n        if (isPlainObject(value)) {\n            return setAll(dictionary, key, value, references instanceof WeakSet ? references : new WeakSet());\n        }\n        dictionary[key] = value;\n        return true;\n    }\n    return false;\n}\nfunction get(dictionary, key) {\n    return dictionary[key];\n}\nfunction isValidKey(key) {\n    let last, current, previous;\n    if (typeof key !== 'string' || (last = key.length - 1) < 0) {\n        return false;\n    }\n    previous = -1;\n    while ((current = key.indexOf('.', previous + 1)) >= 0) {\n        if (current - previous < 2 || current === last) {\n            return false;\n        }\n        previous = current;\n    }\n    return true;\n}\nfunction isPlainObject(subject) {\n    if (typeof subject === 'object' && subject !== null) {\n        const prototype = Object.getPrototypeOf(subject);\n        if (prototype === Object.prototype || prototype === null) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction deepSet(context, key, value) {\n    const separator = key.indexOf('.');\n    if (separator >= 0) {\n        const subKey = key.slice(0, separator);\n        let subContext = context[subKey];\n        if (typeof subContext !== 'object' || subContext === null) {\n            const subContextValue = subContext;\n            subContext = {};\n            if (typeof subContextValue !== 'undefined') {\n                subContext[''] = subContextValue;\n            }\n            context[subKey] = subContext;\n        }\n        deepSet(subContext, key.slice(separator + 1, key.length), value);\n    }\n    else {\n        context[key] = value;\n    }\n}\nSettings.getDefaultSettings().set('useCursors', true);\n","import cache from '../cache/cache';\nimport Events from '../enums/Events';\nimport eventTarget from '../eventTarget';\nimport genericMetadataProvider from '../utilities/genericMetadataProvider';\nimport { getBufferConfiguration } from '../utilities/getBufferConfiguration';\nimport triggerEvent from '../utilities/triggerEvent';\nimport uuidv4 from '../utilities/uuidv4';\nimport VoxelManager from '../utilities/VoxelManager';\nimport imageLoadPoolManager from '../requestPool/imageLoadPoolManager';\nimport * as metaData from '../metaData';\nimport VoxelManagerEnum from '../enums/VoxelManagerEnum';\nconst imageLoaders = {};\nlet unknownImageLoader;\nfunction loadImageFromImageLoader(imageId, options) {\n    const cachedImageLoadObject = cache.getImageLoadObject(imageId);\n    if (cachedImageLoadObject) {\n        handleImageLoadPromise(cachedImageLoadObject.promise, imageId);\n        return cachedImageLoadObject;\n    }\n    const scheme = imageId.split(':')[0];\n    const loader = imageLoaders[scheme] || unknownImageLoader;\n    if (!loader) {\n        throw new Error(`loadImageFromImageLoader: No image loader found for scheme '${scheme}'`);\n    }\n    const imageLoadObject = loader(imageId, options);\n    handleImageLoadPromise(imageLoadObject.promise, imageId);\n    return imageLoadObject;\n}\nfunction handleImageLoadPromise(imagePromise, imageId) {\n    Promise.resolve(imagePromise)\n        .then((image) => {\n        ensureVoxelManager(image);\n        triggerEvent(eventTarget, Events.IMAGE_LOADED, { image });\n    })\n        .catch((error) => {\n        const errorDetails = {\n            imageId,\n            error,\n        };\n        triggerEvent(eventTarget, Events.IMAGE_LOAD_FAILED, errorDetails);\n    });\n}\nfunction ensureVoxelManager(image) {\n    if (!image.voxelManager) {\n        const { width, height, numberOfComponents } = image;\n        const voxelManager = VoxelManager.createImageVoxelManager({\n            scalarData: image.getPixelData(),\n            width,\n            height,\n            numberOfComponents,\n        });\n        image.voxelManager = voxelManager;\n        image.getPixelData = () => voxelManager.getScalarData();\n        delete image.imageFrame.pixelData;\n    }\n}\nexport function loadImage(imageId, options = { priority: 0, requestType: 'prefetch' }) {\n    if (imageId === undefined) {\n        throw new Error('loadImage: parameter imageId must not be undefined');\n    }\n    return loadImageFromImageLoader(imageId, options).promise;\n}\nexport function loadAndCacheImage(imageId, options = { priority: 0, requestType: 'prefetch' }) {\n    if (imageId === undefined) {\n        throw new Error('loadAndCacheImage: parameter imageId must not be undefined');\n    }\n    const imageLoadObject = loadImageFromImageLoader(imageId, options);\n    if (!cache.getImageLoadObject(imageId)) {\n        cache.putImageLoadObject(imageId, imageLoadObject);\n    }\n    return imageLoadObject.promise;\n}\nexport function loadAndCacheImages(imageIds, options = { priority: 0, requestType: 'prefetch' }) {\n    if (!imageIds || imageIds.length === 0) {\n        throw new Error('loadAndCacheImages: parameter imageIds must be list of image Ids');\n    }\n    const allPromises = imageIds.map((imageId) => {\n        return loadAndCacheImage(imageId, options);\n    });\n    return allPromises;\n}\nexport function createAndCacheDerivedImage(referencedImageId, options = {}) {\n    if (referencedImageId === undefined) {\n        throw new Error('createAndCacheDerivedImage: parameter imageId must not be undefined');\n    }\n    if (options.imageId === undefined) {\n        options.imageId = `derived:${uuidv4()}`;\n    }\n    const { imageId, skipCreateBuffer, onCacheAdd, voxelRepresentation } = options;\n    const imagePlaneModule = metaData.get('imagePlaneModule', referencedImageId);\n    const length = imagePlaneModule.rows * imagePlaneModule.columns;\n    const { TypedArrayConstructor } = getBufferConfiguration(options.targetBuffer?.type, length);\n    const imageScalarData = new TypedArrayConstructor(skipCreateBuffer ? 1 : length);\n    const derivedImageId = imageId;\n    const referencedImagePlaneMetadata = metaData.get('imagePlaneModule', referencedImageId);\n    genericMetadataProvider.add(derivedImageId, {\n        type: 'imagePlaneModule',\n        metadata: referencedImagePlaneMetadata,\n    });\n    const referencedImageGeneralSeriesMetadata = metaData.get('generalSeriesModule', referencedImageId);\n    genericMetadataProvider.add(derivedImageId, {\n        type: 'generalSeriesModule',\n        metadata: referencedImageGeneralSeriesMetadata,\n    });\n    genericMetadataProvider.add(derivedImageId, {\n        type: 'generalImageModule',\n        metadata: {\n            instanceNumber: options.instanceNumber,\n        },\n    });\n    const imagePixelModule = metaData.get('imagePixelModule', referencedImageId);\n    genericMetadataProvider.add(derivedImageId, {\n        type: 'imagePixelModule',\n        metadata: {\n            ...imagePixelModule,\n            bitsAllocated: 8,\n            bitsStored: 8,\n            highBit: 7,\n            samplesPerPixel: 1,\n            pixelRepresentation: 0,\n        },\n    });\n    const localImage = createAndCacheLocalImage(imageId, {\n        scalarData: imageScalarData,\n        onCacheAdd,\n        skipCreateBuffer,\n        targetBuffer: {\n            type: imageScalarData.constructor.name,\n        },\n        voxelRepresentation,\n        dimensions: [imagePlaneModule.columns, imagePlaneModule.rows],\n        spacing: [\n            imagePlaneModule.columnPixelSpacing,\n            imagePlaneModule.rowPixelSpacing,\n        ],\n        origin: imagePlaneModule.imagePositionPatient,\n        direction: imagePlaneModule.imageOrientationPatient,\n        frameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\n        referencedImageId: referencedImageId,\n    });\n    localImage.referencedImageId = referencedImageId;\n    if (!cache.getImageLoadObject(imageId)) {\n        cache.putImageSync(imageId, localImage);\n    }\n    return localImage;\n}\nexport function createAndCacheDerivedImages(referencedImageIds, options = {}) {\n    if (referencedImageIds.length === 0) {\n        throw new Error('createAndCacheDerivedImages: parameter imageIds must be list of image Ids');\n    }\n    const derivedImageIds = [];\n    const images = referencedImageIds.map((referencedImageId, index) => {\n        const newOptions = {\n            imageId: options?.getDerivedImageId?.(referencedImageId) ||\n                `derived:${uuidv4()}`,\n            ...options,\n        };\n        derivedImageIds.push(newOptions.imageId);\n        return createAndCacheDerivedImage(referencedImageId, {\n            ...newOptions,\n            instanceNumber: index + 1,\n        });\n    });\n    return images;\n}\nexport function createAndCacheLocalImage(imageId, options) {\n    const { scalarData, origin, direction, targetBuffer, skipCreateBuffer, onCacheAdd, frameOfReferenceUID, voxelRepresentation, referencedImageId, } = options;\n    const dimensions = options.dimensions;\n    const spacing = options.spacing;\n    if (!dimensions || !spacing) {\n        throw new Error('createAndCacheLocalImage: dimensions and spacing are required');\n    }\n    const width = dimensions[0];\n    const height = dimensions[1];\n    const columnPixelSpacing = spacing[0];\n    const rowPixelSpacing = spacing[1];\n    const imagePlaneModule = {\n        frameOfReferenceUID,\n        rows: height,\n        columns: width,\n        imageOrientationPatient: direction ?? [1, 0, 0, 0, 1, 0],\n        rowCosines: direction ? direction.slice(0, 3) : [1, 0, 0],\n        columnCosines: direction ? direction.slice(3, 6) : [0, 1, 0],\n        imagePositionPatient: origin ?? [0, 0, 0],\n        pixelSpacing: [rowPixelSpacing, columnPixelSpacing],\n        rowPixelSpacing: rowPixelSpacing,\n        columnPixelSpacing: columnPixelSpacing,\n    };\n    const length = width * height;\n    const numberOfComponents = scalarData.length / length;\n    let scalarDataToUse;\n    if (scalarData) {\n        if (!(scalarData instanceof Uint8Array ||\n            scalarData instanceof Float32Array ||\n            scalarData instanceof Uint16Array ||\n            scalarData instanceof Int16Array)) {\n            throw new Error('createAndCacheLocalImage: scalarData must be of type Uint8Array, Uint16Array, Int16Array or Float32Array');\n        }\n        scalarDataToUse = scalarData;\n    }\n    else if (!skipCreateBuffer) {\n        const { TypedArrayConstructor } = getBufferConfiguration(targetBuffer?.type, length);\n        const imageScalarData = new TypedArrayConstructor(length);\n        scalarDataToUse = imageScalarData;\n    }\n    let bitsAllocated, bitsStored, highBit;\n    if (scalarDataToUse instanceof Uint8Array) {\n        bitsAllocated = 8;\n        bitsStored = 8;\n        highBit = 7;\n    }\n    else if (scalarDataToUse instanceof Uint16Array) {\n        bitsAllocated = 16;\n        bitsStored = 16;\n        highBit = 15;\n    }\n    else if (scalarDataToUse instanceof Int16Array) {\n        bitsAllocated = 16;\n        bitsStored = 16;\n        highBit = 15;\n    }\n    else if (scalarDataToUse instanceof Float32Array) {\n        bitsAllocated = 32;\n        bitsStored = 32;\n        highBit = 31;\n    }\n    else {\n        throw new Error('Unsupported scalarData type');\n    }\n    const imagePixelModule = {\n        samplesPerPixel: 1,\n        photometricInterpretation: scalarDataToUse.length > dimensions[0] * dimensions[1]\n            ? 'RGB'\n            : 'MONOCHROME2',\n        rows: height,\n        columns: width,\n        bitsAllocated,\n        bitsStored,\n        highBit,\n    };\n    const metadata = {\n        imagePlaneModule,\n        imagePixelModule,\n    };\n    ['imagePlaneModule', 'imagePixelModule'].forEach((type) => {\n        genericMetadataProvider.add(imageId, {\n            type,\n            metadata: metadata[type] || {},\n        });\n    });\n    const id = imageId;\n    const voxelManager = (voxelRepresentation === VoxelManagerEnum.RLE &&\n        VoxelManager.createRLEImageVoxelManager({ dimensions, id })) ||\n        VoxelManager.createImageVoxelManager({\n            height,\n            width,\n            numberOfComponents,\n            scalarData: scalarDataToUse,\n            id,\n        });\n    let minPixelValue = scalarDataToUse[0];\n    let maxPixelValue = scalarDataToUse[0];\n    for (let i = 1; i < scalarDataToUse.length; i++) {\n        if (scalarDataToUse[i] < minPixelValue) {\n            minPixelValue = scalarDataToUse[i];\n        }\n        if (scalarDataToUse[i] > maxPixelValue) {\n            maxPixelValue = scalarDataToUse[i];\n        }\n    }\n    const image = {\n        imageId: imageId,\n        intercept: 0,\n        windowCenter: 0,\n        windowWidth: 0,\n        color: imagePixelModule.photometricInterpretation === 'RGB',\n        numberOfComponents: imagePixelModule.samplesPerPixel,\n        dataType: targetBuffer?.type,\n        slope: 1,\n        minPixelValue,\n        maxPixelValue,\n        rows: imagePixelModule.rows,\n        columns: imagePixelModule.columns,\n        getCanvas: undefined,\n        height: imagePixelModule.rows,\n        width: imagePixelModule.columns,\n        rgba: undefined,\n        columnPixelSpacing: imagePlaneModule.columnPixelSpacing,\n        rowPixelSpacing: imagePlaneModule.rowPixelSpacing,\n        FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\n        invert: false,\n        getPixelData: () => voxelManager.getScalarData(),\n        voxelManager,\n        sizeInBytes: scalarData.byteLength,\n        referencedImageId,\n    };\n    onCacheAdd?.(image);\n    cache.putImageSync(image.imageId, image);\n    return image;\n}\nexport function cancelLoadImage(imageId) {\n    const filterFunction = ({ additionalDetails }) => {\n        if (additionalDetails.imageId) {\n            return additionalDetails.imageId !== imageId;\n        }\n        return true;\n    };\n    imageLoadPoolManager.filterRequests(filterFunction);\n    const imageLoadObject = cache.getImageLoadObject(imageId);\n    if (imageLoadObject) {\n        imageLoadObject.cancelFn();\n    }\n}\nexport function cancelLoadImages(imageIds) {\n    imageIds.forEach((imageId) => {\n        cancelLoadImage(imageId);\n    });\n}\nexport function cancelLoadAll() {\n    const requestPool = imageLoadPoolManager.getRequestPool();\n    Object.keys(requestPool).forEach((type) => {\n        const requests = requestPool[type];\n        Object.keys(requests).forEach((priority) => {\n            const requestDetails = requests[priority].pop();\n            if (!requestDetails) {\n                return;\n            }\n            const additionalDetails = requestDetails.additionalDetails;\n            const { imageId, volumeId } = additionalDetails;\n            let loadObject;\n            if (imageId) {\n                loadObject = cache.getImageLoadObject(imageId);\n            }\n            else if (volumeId) {\n                loadObject = cache.getVolumeLoadObject(volumeId);\n            }\n            if (loadObject) {\n                loadObject.cancel();\n            }\n        });\n        imageLoadPoolManager.clearRequestStack(type);\n    });\n}\nexport function registerImageLoader(scheme, imageLoader) {\n    imageLoaders[scheme] = imageLoader;\n}\nexport function registerUnknownImageLoader(imageLoader) {\n    const oldImageLoader = unknownImageLoader;\n    unknownImageLoader = imageLoader;\n    return oldImageLoader;\n}\nexport function unregisterAllImageLoaders() {\n    Object.keys(imageLoaders).forEach((imageLoader) => delete imageLoaders[imageLoader]);\n    unknownImageLoader = undefined;\n}\nexport function createAndCacheDerivedLabelmapImages(referencedImageIds, options = {}) {\n    return createAndCacheDerivedImages(referencedImageIds, {\n        ...options,\n        targetBuffer: { type: 'Uint8Array' },\n    });\n}\nexport function createAndCacheDerivedLabelmapImage(referencedImageId, options = {}) {\n    return createAndCacheDerivedImage(referencedImageId, {\n        ...options,\n        targetBuffer: { type: 'Uint8Array' },\n    });\n}\n","export default class FrameRange {\n    static { this.frameRangeExtractor = /(\\/frames\\/|[&?]frameNumber=)([^/&?]*)/i; }\n    static imageIdToFrames(imageId) {\n        const match = imageId.match(this.frameRangeExtractor);\n        if (!match || !match[2]) {\n            return null;\n        }\n        const range = match[2].split('-').map((it) => Number(it));\n        if (range.length === 1) {\n            return range[0];\n        }\n        return range;\n    }\n    static imageIdToFrameEnd(imageId) {\n        const range = this.imageIdToFrames(imageId);\n        return Array.isArray(range) ? range[1] : range;\n    }\n    static imageIdToFrameStart(imageId) {\n        const range = this.imageIdToFrames(imageId);\n        return Array.isArray(range) ? range[0] : range;\n    }\n    static framesToString(range) {\n        if (Array.isArray(range)) {\n            return `${range[0]}-${range[1]}`;\n        }\n        return String(range);\n    }\n    static framesToImageId(imageId, range) {\n        const match = imageId.match(this.frameRangeExtractor);\n        if (!match || !match[2]) {\n            return null;\n        }\n        const newRangeString = this.framesToString(range);\n        return imageId.replace(this.frameRangeExtractor, `${match[1]}${newRangeString}`);\n    }\n}\n","export default class PointsManager {\n    constructor(configuration = {}) {\n        this._dimensions = 3;\n        this._length = 0;\n        this._byteSize = 4;\n        this.growSize = 128;\n        const { initialSize = 1024, dimensions = 3, growSize = 128, } = configuration;\n        const itemLength = initialSize * dimensions;\n        this.growSize = growSize;\n        this.array = new ArrayBuffer(itemLength * this._byteSize);\n        this.data = new Float32Array(this.array);\n        this._dimensions = dimensions;\n    }\n    forEach(func) {\n        for (let i = 0; i < this._length; i++) {\n            func(this.getPoint(i), i);\n        }\n    }\n    get length() {\n        return this._length;\n    }\n    get dimensions() {\n        return this._dimensions;\n    }\n    get dimensionLength() {\n        return this._length * this._dimensions;\n    }\n    getPoint(index) {\n        if (index < 0) {\n            index += this._length;\n        }\n        if (index < 0 || index >= this._length) {\n            return;\n        }\n        const offset = this._dimensions * index;\n        return this.data.subarray(offset, offset + this._dimensions);\n    }\n    getPointArray(index) {\n        const array = [];\n        if (index < 0) {\n            index += this._length;\n        }\n        if (index < 0 || index >= this._length) {\n            return;\n        }\n        const offset = this._dimensions * index;\n        for (let i = 0; i < this._dimensions; i++) {\n            array.push(this.data[i + offset]);\n        }\n        return array;\n    }\n    grow(additionalSize = 1, growSize = this.growSize) {\n        if (this.dimensionLength + additionalSize * this._dimensions <=\n            this.data.length) {\n            return;\n        }\n        const newSize = this.data.length + growSize;\n        const newArray = new ArrayBuffer(newSize * this._dimensions * this._byteSize);\n        const newData = new Float32Array(newArray);\n        newData.set(this.data);\n        this.data = newData;\n        this.array = newArray;\n    }\n    reverse() {\n        const midLength = Math.floor(this._length / 2);\n        for (let i = 0; i < midLength; i++) {\n            const indexStart = i * this._dimensions;\n            const indexEnd = (this._length - 1 - i) * this._dimensions;\n            for (let dimension = 0; dimension < this._dimensions; dimension++) {\n                const valueStart = this.data[indexStart + dimension];\n                this.data[indexStart + dimension] = this.data[indexEnd + dimension];\n                this.data[indexEnd + dimension] = valueStart;\n            }\n        }\n    }\n    getTypedArray() {\n        return this.data;\n    }\n    push(point) {\n        this.grow(1);\n        const offset = this.length * this._dimensions;\n        for (let i = 0; i < this._dimensions; i++) {\n            this.data[i + offset] = point[i];\n        }\n        this._length++;\n    }\n    map(f) {\n        const mapData = [];\n        for (let i = 0; i < this._length; i++) {\n            mapData.push(f(this.getPoint(i), i));\n        }\n        return mapData;\n    }\n    get points() {\n        return this.map((p) => p);\n    }\n    toXYZ() {\n        const xyz = { x: [], y: [] };\n        if (this._dimensions >= 3) {\n            xyz.z = [];\n        }\n        const { x, y, z } = xyz;\n        this.forEach((p) => {\n            x.push(p[0]);\n            y.push(p[1]);\n            if (z) {\n                z.push(p[2]);\n            }\n        });\n        return xyz;\n    }\n    static fromXYZ({ x, y, z }) {\n        const array = PointsManager.create3(x.length);\n        let offset = 0;\n        for (let i = 0; i < x.length; i++) {\n            array.data[offset++] = x[i];\n            array.data[offset++] = y[i];\n            array.data[offset++] = z ? z[i] : 0;\n        }\n        array._length = x.length;\n        return array;\n    }\n    subselect(count = 10, offset = 0) {\n        const selected = new PointsManager({\n            initialSize: count,\n            dimensions: this._dimensions,\n        });\n        for (let i = 0; i < count; i++) {\n            const index = (offset + Math.floor((this.length * i) / count)) % this.length;\n            selected.push(this.getPoint(index));\n        }\n        return selected;\n    }\n    static create3(initialSize = 128, points) {\n        initialSize = Math.max(initialSize, points?.length || 0);\n        const newPoints = new PointsManager({ initialSize, dimensions: 3 });\n        if (points) {\n            points.forEach((point) => newPoints.push(point));\n        }\n        return newPoints;\n    }\n    static create2(initialSize = 128) {\n        return new PointsManager({ initialSize, dimensions: 2 });\n    }\n}\n","export class PromiseIterator extends Promise {\n}\nexport default class ProgressiveIterator {\n    constructor(name) {\n        this.name = name || 'unknown';\n    }\n    static as(promise) {\n        if (promise.iterator) {\n            return promise.iterator;\n        }\n        const iterator = new ProgressiveIterator('as iterator');\n        promise.then((v) => {\n            try {\n                iterator.add(v, true);\n            }\n            catch (e) {\n                iterator.reject(e);\n            }\n        }, (reason) => {\n            iterator.reject(reason);\n        });\n        return iterator;\n    }\n    add(x, done = false) {\n        this.nextValue = x;\n        this.done ||= done;\n        if (this.waiting) {\n            this.waiting.resolve(x);\n            this.waiting = undefined;\n        }\n    }\n    resolve() {\n        this.done = true;\n        if (this.waiting) {\n            this.waiting.resolve(this.nextValue);\n            this.waiting = undefined;\n        }\n    }\n    reject(reason) {\n        this.rejectReason = reason;\n        this.waiting?.reject(reason);\n    }\n    getRecent() {\n        if (this.rejectReason) {\n            throw this.rejectReason;\n        }\n        return this.nextValue;\n    }\n    async *[Symbol.asyncIterator]() {\n        while (!this.done) {\n            if (this.rejectReason) {\n                throw this.rejectReason;\n            }\n            if (this.nextValue !== undefined) {\n                yield this.nextValue;\n                if (this.done) {\n                    break;\n                }\n            }\n            if (!this.waiting) {\n                this.waiting = {};\n                this.waiting.promise = new Promise((resolve, reject) => {\n                    this.waiting.resolve = resolve;\n                    this.waiting.reject = reject;\n                });\n            }\n            await this.waiting.promise;\n        }\n        yield this.nextValue;\n    }\n    async forEach(callback, errorCallback) {\n        let index = 0;\n        try {\n            for await (const value of this) {\n                const { done } = this;\n                try {\n                    await callback(value, done, index);\n                    index++;\n                }\n                catch (e) {\n                    if (!done) {\n                        console.warn('Caught exception in intermediate value', e);\n                        continue;\n                    }\n                    if (errorCallback) {\n                        errorCallback(e, done);\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n        }\n        catch (e) {\n            if (errorCallback) {\n                errorCallback(e, true);\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n    generate(processFunction, errorCallback) {\n        return processFunction(this, this.reject.bind(this)).then(() => {\n            if (!this.done) {\n                this.resolve();\n            }\n        }, (reason) => {\n            this.reject(reason);\n            if (errorCallback) {\n                errorCallback(reason);\n            }\n            else {\n                console.warn(\"Couldn't process because\", reason);\n            }\n        });\n    }\n    async nextPromise() {\n        for await (const i of this) {\n            if (i) {\n                return i;\n            }\n        }\n        return this.nextValue;\n    }\n    async donePromise() {\n        for await (const i of this) {\n        }\n        return this.nextValue;\n    }\n    getNextPromise() {\n        const promise = this.nextPromise();\n        promise.iterator = this;\n        return promise;\n    }\n    getDonePromise() {\n        const promise = this.donePromise();\n        promise.iterator = this;\n        return promise;\n    }\n}\n","const ADJACENT_ALL = [\n    [0, -1, 0],\n    [0, 1, 0],\n    [0, 0, -1],\n    [0, 0, 1],\n];\nconst ADJACENT_SINGLE_PLANE = [\n    [0, -1, 0],\n    [0, 1, 0],\n];\nconst ADJACENT_IN = [\n    [0, -1, 0],\n    [0, 1, 0],\n    [0, 0, -1],\n];\nconst ADJACENT_OUT = [\n    [0, -1, 0],\n    [0, 1, 0],\n    [0, 0, 1],\n];\nexport default class RLEVoxelMap {\n    static copyMap(destination, source) {\n        for (const [index, row] of source.rows) {\n            destination.rows.set(index, structuredClone(row));\n        }\n    }\n    constructor(width, height, depth = 1) {\n        this.rows = new Map();\n        this.height = 1;\n        this.width = 1;\n        this.depth = 1;\n        this.jMultiple = 1;\n        this.kMultiple = 1;\n        this.numComps = 1;\n        this.pixelDataConstructor = Uint8Array;\n        this.updateScalarData = function (scalarData) {\n            scalarData.fill(0);\n            const callback = (index, rle, row) => {\n                const { start, end, value } = rle;\n                for (let i = start; i < end; i++) {\n                    scalarData[index + i] = value;\n                }\n            };\n            this.forEach(callback);\n        };\n        this.get = (index) => {\n            const i = index % this.jMultiple;\n            const j = (index - i) / this.jMultiple;\n            const rle = this.getRLE(i, j);\n            return rle?.value ?? this.defaultValue;\n        };\n        this.getRun = (j, k) => {\n            const runIndex = j + k * this.height;\n            return this.rows.get(runIndex);\n        };\n        this.set = (index, value) => {\n            if (value === undefined) {\n                return;\n            }\n            const i = index % this.width;\n            const j = (index - i) / this.width;\n            const row = this.rows.get(j);\n            if (!row) {\n                this.rows.set(j, [{ start: i, end: i + 1, value }]);\n                return;\n            }\n            const rleIndex = this.findIndex(row, i);\n            const rle1 = row[rleIndex];\n            const rle0 = row[rleIndex - 1];\n            if (!rle1) {\n                if (!rle0 || rle0.value !== value || rle0.end !== i) {\n                    row[rleIndex] = { start: i, end: i + 1, value };\n                    return;\n                }\n                rle0.end++;\n                return;\n            }\n            const { start, end, value: oldValue } = rle1;\n            if (value === oldValue && i >= start) {\n                return;\n            }\n            const rleInsert = { start: i, end: i + 1, value };\n            const isAfter = i > start;\n            const insertIndex = isAfter ? rleIndex + 1 : rleIndex;\n            const rlePrev = isAfter ? rle1 : rle0;\n            let rleNext = isAfter ? row[rleIndex + 1] : rle1;\n            if (rlePrev?.value === value && rlePrev?.end === i) {\n                rlePrev.end++;\n                if (rleNext?.value === value && rleNext.start === i + 1) {\n                    rlePrev.end = rleNext.end;\n                    row.splice(rleIndex, 1);\n                }\n                else if (rleNext?.start === i) {\n                    rleNext.start++;\n                    if (rleNext.start === rleNext.end) {\n                        row.splice(rleIndex, 1);\n                        rleNext = row[rleIndex];\n                        if (rleNext?.start === i + 1 && rleNext.value === value) {\n                            rlePrev.end = rleNext.end;\n                            row.splice(rleIndex, 1);\n                        }\n                    }\n                }\n                return;\n            }\n            if (rleNext?.value === value && rleNext.start === i + 1) {\n                rleNext.start--;\n                if (rlePrev?.end > i) {\n                    rlePrev.end = i;\n                    if (rlePrev.end === rlePrev.start) {\n                        row.splice(rleIndex, 1);\n                    }\n                }\n                return;\n            }\n            if (rleNext?.start === i && rleNext.end === i + 1) {\n                rleNext.value = value;\n                const nextnext = row[rleIndex + 1];\n                if (nextnext?.start == i + 1 && nextnext.value === value) {\n                    row.splice(rleIndex + 1, 1);\n                    rleNext.end = nextnext.end;\n                }\n                return;\n            }\n            if (i === rleNext?.start) {\n                rleNext.start++;\n            }\n            if (isAfter && end > i + 1) {\n                row.splice(insertIndex, 0, rleInsert, {\n                    start: i + 1,\n                    end: rlePrev.end,\n                    value: rlePrev.value,\n                });\n            }\n            else {\n                row.splice(insertIndex, 0, rleInsert);\n            }\n            if (rlePrev?.end > i) {\n                rlePrev.end = i;\n            }\n        };\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        this.jMultiple = width;\n        this.kMultiple = this.jMultiple * height;\n    }\n    static { this.getScalarData = function (ArrayType = Uint8ClampedArray) {\n        const scalarData = new ArrayType(this.frameSize);\n        this.map.updateScalarData(scalarData);\n        return scalarData;\n    }; }\n    toIJK(index) {\n        const i = index % this.jMultiple;\n        const j = ((index - i) / this.jMultiple) % this.height;\n        const k = Math.floor(index / this.kMultiple);\n        return [i, j, k];\n    }\n    toIndex([i, j, k]) {\n        return i + k * this.kMultiple + j * this.jMultiple;\n    }\n    getRLE(i, j, k = 0) {\n        const row = this.rows.get(j + k * this.height);\n        if (!row) {\n            return;\n        }\n        const index = this.findIndex(row, i);\n        const rle = row[index];\n        return i >= rle?.start ? rle : undefined;\n    }\n    has(index) {\n        const i = index % this.jMultiple;\n        const j = (index - i) / this.jMultiple;\n        const rle = this.getRLE(i, j);\n        return rle?.value !== undefined;\n    }\n    delete(index) {\n        const i = index % this.width;\n        const j = (index - i) / this.width;\n        const row = this.rows.get(j);\n        if (!row) {\n            return;\n        }\n        const rleIndex = this.findIndex(row, i);\n        const rle = row[rleIndex];\n        if (!rle || rle.start > i) {\n            return;\n        }\n        if (rle.end === i + 1) {\n            rle.end--;\n            if (rle.start >= rle.end) {\n                row.splice(rleIndex, 1);\n                if (!row.length) {\n                    this.rows.delete(j);\n                }\n            }\n            return;\n        }\n        if (rle.start === i) {\n            rle.start++;\n            return;\n        }\n        const newRle = {\n            value: rle.value,\n            start: i + 1,\n            end: rle.end,\n        };\n        rle.end = i;\n        row.splice(rleIndex + 1, 0, newRle);\n    }\n    findIndex(row, i) {\n        for (let index = 0; index < row.length; index++) {\n            const { end: iEnd } = row[index];\n            if (i < iEnd) {\n                return index;\n            }\n        }\n        return row.length;\n    }\n    forEach(callback, options) {\n        const rowModified = options?.rowModified;\n        for (const [baseIndex, row] of this.rows) {\n            const rowToUse = rowModified ? [...row] : row;\n            for (const rle of rowToUse) {\n                callback(baseIndex * this.width, rle, row);\n            }\n        }\n    }\n    forEachRow(callback) {\n        for (const [baseIndex, row] of this.rows) {\n            callback(baseIndex * this.width, row);\n        }\n    }\n    clear() {\n        this.rows.clear();\n    }\n    keys() {\n        return [...this.rows.keys()];\n    }\n    getPixelData(k = 0, pixelData) {\n        if (!pixelData) {\n            pixelData = new this.pixelDataConstructor(this.width * this.height * this.numComps);\n        }\n        else {\n            pixelData.fill(0);\n        }\n        const { width, height, numComps } = this;\n        for (let j = 0; j < height; j++) {\n            const row = this.getRun(j, k);\n            if (!row) {\n                continue;\n            }\n            if (numComps === 1) {\n                for (const rle of row) {\n                    const rowOffset = j * width;\n                    const { start, end, value } = rle;\n                    for (let i = start; i < end; i++) {\n                        pixelData[rowOffset + i] = value;\n                    }\n                }\n            }\n            else {\n                for (const rle of row) {\n                    const rowOffset = j * width * numComps;\n                    const { start, end, value } = rle;\n                    for (let i = start; i < end; i += numComps) {\n                        for (let comp = 0; comp < numComps; comp++) {\n                            pixelData[rowOffset + i + comp] = value[comp];\n                        }\n                    }\n                }\n            }\n        }\n        return pixelData;\n    }\n    floodFill(i, j, k, value, options) {\n        const rle = this.getRLE(i, j, k);\n        if (!rle) {\n            throw new Error(`Initial point ${i},${j},${k} isn't in the RLE`);\n        }\n        const stack = [[rle, j, k]];\n        const replaceValue = rle.value;\n        if (replaceValue === value) {\n            throw new Error(`source (${replaceValue}) and destination (${value}) are identical`);\n        }\n        return this.flood(stack, replaceValue, value, options);\n    }\n    flood(stack, sourceValue, value, options) {\n        let sum = 0;\n        const { planar = true, diagonals = true, singlePlane = false, } = options || {};\n        const childOptions = { planar, diagonals, singlePlane };\n        while (stack.length) {\n            const top = stack.pop();\n            const [current] = top;\n            if (current.value !== sourceValue) {\n                continue;\n            }\n            current.value = value;\n            sum += current.end - current.start;\n            const adjacents = this.findAdjacents(top, childOptions).filter((adjacent) => adjacent && adjacent[0].value === sourceValue);\n            stack.push(...adjacents);\n        }\n        return sum;\n    }\n    fillFrom(getter, boundsIJK) {\n        for (let k = boundsIJK[2][0]; k <= boundsIJK[2][1]; k++) {\n            for (let j = boundsIJK[1][0]; j <= boundsIJK[1][1]; j++) {\n                let rle;\n                let row;\n                for (let i = boundsIJK[0][0]; i <= boundsIJK[0][1]; i++) {\n                    const value = getter(i, j, k);\n                    if (value === undefined) {\n                        rle = undefined;\n                        continue;\n                    }\n                    if (!row) {\n                        row = [];\n                        this.rows.set(j + k * this.height, row);\n                    }\n                    if (rle && rle.value !== value) {\n                        rle = undefined;\n                    }\n                    if (!rle) {\n                        rle = { start: i, end: i, value };\n                        row.push(rle);\n                    }\n                    rle.end++;\n                }\n            }\n        }\n    }\n    findAdjacents(item, { diagonals = true, planar = true, singlePlane = false }) {\n        const [rle, j, k, adjacentsDelta] = item;\n        const { start, end } = rle;\n        const leftRle = start > 0 && this.getRLE(start - 1, j, k);\n        const rightRle = end < this.width && this.getRLE(end, j, k);\n        const range = diagonals\n            ? [start > 0 ? start - 1 : start, end < this.width ? end + 1 : end]\n            : [start, end];\n        const adjacents = [];\n        if (leftRle) {\n            adjacents.push([leftRle, j, k]);\n        }\n        if (rightRle) {\n            adjacents.push([rightRle, j, k]);\n        }\n        for (const delta of adjacentsDelta ||\n            (singlePlane ? ADJACENT_SINGLE_PLANE : ADJACENT_ALL)) {\n            const [, delta1, delta2] = delta;\n            const testJ = delta1 + j;\n            const testK = delta2 + k;\n            if (testJ < 0 || testJ >= this.height) {\n                continue;\n            }\n            if (testK < 0 || testK >= this.depth) {\n                continue;\n            }\n            const row = this.getRun(testJ, testK);\n            if (!row) {\n                continue;\n            }\n            for (const testRle of row) {\n                const newAdjacentDelta = adjacentsDelta ||\n                    (singlePlane && ADJACENT_SINGLE_PLANE) ||\n                    (planar && delta2 > 0 && ADJACENT_OUT) ||\n                    (planar && delta2 < 0 && ADJACENT_IN) ||\n                    ADJACENT_ALL;\n                if (!(testRle.end <= range[0] || testRle.start >= range[1])) {\n                    adjacents.push([testRle, testJ, testK, newAdjacentDelta]);\n                }\n            }\n        }\n        return adjacents;\n    }\n}\n","export function isImageActor(actorEntry) {\n    return (actorIsA(actorEntry, 'vtkVolume') || actorIsA(actorEntry, 'vtkImageSlice'));\n}\nexport function actorIsA(actorEntry, actorType) {\n    const actorToCheck = 'isA' in actorEntry ? actorEntry : actorEntry.actor;\n    if (!actorToCheck) {\n        return false;\n    }\n    return !!actorToCheck.isA(actorType);\n}\n","import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nexport default function applyPreset(actor, preset) {\n    const colorTransferArray = preset.colorTransfer\n        .split(' ')\n        .splice(1)\n        .map(parseFloat);\n    const { shiftRange } = getShiftRange(colorTransferArray);\n    const min = shiftRange[0];\n    const width = shiftRange[1] - shiftRange[0];\n    const cfun = vtkColorTransferFunction.newInstance();\n    const normColorTransferValuePoints = [];\n    for (let i = 0; i < colorTransferArray.length; i += 4) {\n        let value = colorTransferArray[i];\n        const r = colorTransferArray[i + 1];\n        const g = colorTransferArray[i + 2];\n        const b = colorTransferArray[i + 3];\n        value = (value - min) / width;\n        normColorTransferValuePoints.push([value, r, g, b]);\n    }\n    applyPointsToRGBFunction(normColorTransferValuePoints, shiftRange, cfun);\n    actor.getProperty().setRGBTransferFunction(0, cfun);\n    const scalarOpacityArray = preset.scalarOpacity\n        .split(' ')\n        .splice(1)\n        .map(parseFloat);\n    const ofun = vtkPiecewiseFunction.newInstance();\n    const normPoints = [];\n    for (let i = 0; i < scalarOpacityArray.length; i += 2) {\n        let value = scalarOpacityArray[i];\n        const opacity = scalarOpacityArray[i + 1];\n        value = (value - min) / width;\n        normPoints.push([value, opacity]);\n    }\n    applyPointsToPiecewiseFunction(normPoints, shiftRange, ofun);\n    const property = actor.getProperty();\n    property.setScalarOpacity(0, ofun);\n    const [gradientMinValue, gradientMinOpacity, gradientMaxValue, gradientMaxOpacity,] = preset.gradientOpacity.split(' ').splice(1).map(parseFloat);\n    property.setUseGradientOpacity(0, true);\n    property.setGradientOpacityMinimumValue(0, gradientMinValue);\n    property.setGradientOpacityMinimumOpacity(0, gradientMinOpacity);\n    property.setGradientOpacityMaximumValue(0, gradientMaxValue);\n    property.setGradientOpacityMaximumOpacity(0, gradientMaxOpacity);\n    if (preset.interpolation === '1') {\n        property.setInterpolationTypeToFastLinear();\n    }\n    property.setShade(preset.shade === '1');\n    const ambient = parseFloat(preset.ambient);\n    const diffuse = parseFloat(preset.diffuse);\n    const specular = parseFloat(preset.specular);\n    const specularPower = parseFloat(preset.specularPower);\n    property.setAmbient(ambient);\n    property.setDiffuse(diffuse);\n    property.setSpecular(specular);\n    property.setSpecularPower(specularPower);\n}\nfunction getShiftRange(colorTransferArray) {\n    let min = Infinity;\n    let max = -Infinity;\n    for (let i = 0; i < colorTransferArray.length; i += 4) {\n        min = Math.min(min, colorTransferArray[i]);\n        max = Math.max(max, colorTransferArray[i]);\n    }\n    const center = (max - min) / 2;\n    return {\n        shiftRange: [-center, center],\n        min,\n        max,\n    };\n}\nfunction applyPointsToRGBFunction(points, range, cfun) {\n    const width = range[1] - range[0];\n    const rescaled = points.map(([x, r, g, b]) => [\n        x * width + range[0],\n        r,\n        g,\n        b,\n    ]);\n    cfun.removeAllPoints();\n    rescaled.forEach(([x, r, g, b]) => cfun.addRGBPoint(x, r, g, b));\n    return rescaled;\n}\nfunction applyPointsToPiecewiseFunction(points, range, pwf) {\n    const width = range[1] - range[0];\n    const rescaled = points.map(([x, y]) => [x * width + range[0], y]);\n    pwf.removeAllPoints();\n    rescaled.forEach(([x, y]) => pwf.addPoint(x, y));\n    return rescaled;\n}\n","import { getRenderingEngines } from '../RenderingEngine/getRenderingEngine';\nimport getViewportsWithVolumeId from './getViewportsWithVolumeId';\nconst autoLoad = (volumeId) => {\n    const renderingEngineAndViewportIds = getRenderingEngineAndViewportsContainingVolume(volumeId);\n    if (!renderingEngineAndViewportIds?.length) {\n        return;\n    }\n    renderingEngineAndViewportIds.forEach(({ renderingEngine, viewportIds }) => {\n        if (!renderingEngine.hasBeenDestroyed) {\n            renderingEngine.renderViewports(viewportIds);\n        }\n    });\n};\nfunction getRenderingEngineAndViewportsContainingVolume(volumeId) {\n    const renderingEnginesArray = getRenderingEngines();\n    const renderingEngineAndViewportIds = [];\n    renderingEnginesArray.forEach((renderingEngine) => {\n        const viewports = getViewportsWithVolumeId(volumeId);\n        if (viewports.length) {\n            renderingEngineAndViewportIds.push({\n                renderingEngine,\n                viewportIds: viewports.map((viewport) => viewport.id),\n            });\n        }\n    });\n    return renderingEngineAndViewportIds;\n}\nexport default autoLoad;\n","import * as metaData from '../metaData';\nimport { MetadataModules, VOILUTFunctionType } from '../enums';\nexport function getValidVOILUTFunction(voiLUTFunction) {\n    if (!Object.values(VOILUTFunctionType).includes(voiLUTFunction)) {\n        return VOILUTFunctionType.LINEAR;\n    }\n    return voiLUTFunction;\n}\nexport function getImagePlaneModule(imageId) {\n    const imagePlaneModule = metaData.get(MetadataModules.IMAGE_PLANE, imageId);\n    const newImagePlaneModule = {\n        ...imagePlaneModule,\n    };\n    if (!newImagePlaneModule.columnPixelSpacing) {\n        newImagePlaneModule.columnPixelSpacing = 1;\n    }\n    if (!newImagePlaneModule.rowPixelSpacing) {\n        newImagePlaneModule.rowPixelSpacing = 1;\n    }\n    if (!newImagePlaneModule.columnCosines) {\n        newImagePlaneModule.columnCosines = [0, 1, 0];\n    }\n    if (!newImagePlaneModule.rowCosines) {\n        newImagePlaneModule.rowCosines = [1, 0, 0];\n    }\n    if (!newImagePlaneModule.imagePositionPatient) {\n        newImagePlaneModule.imagePositionPatient = [0, 0, 0];\n    }\n    if (!newImagePlaneModule.imageOrientationPatient) {\n        newImagePlaneModule.imageOrientationPatient = new Float32Array([\n            1, 0, 0, 0, 1, 0,\n        ]);\n    }\n    return newImagePlaneModule;\n}\nexport function calibrateImagePlaneModule(imageId, imagePlaneModule, currentCalibration) {\n    const calibration = metaData.get('calibratedPixelSpacing', imageId);\n    const isUpdated = currentCalibration !== calibration;\n    const { scale } = calibration || {};\n    const hasPixelSpacing = scale > 0 || imagePlaneModule.rowPixelSpacing > 0;\n    imagePlaneModule.calibration = calibration;\n    if (!isUpdated) {\n        return { imagePlaneModule, hasPixelSpacing };\n    }\n    return {\n        imagePlaneModule,\n        hasPixelSpacing,\n        calibrationEvent: {\n            scale,\n            calibration,\n        },\n    };\n}\nexport function buildMetadata(image) {\n    const imageId = image.imageId;\n    const { pixelRepresentation, bitsAllocated, bitsStored, highBit, photometricInterpretation, samplesPerPixel, } = metaData.get('imagePixelModule', imageId);\n    const { windowWidth, windowCenter, voiLUTFunction } = image;\n    const { modality } = metaData.get('generalSeriesModule', imageId);\n    const imageIdScalingFactor = metaData.get('scalingModule', imageId);\n    const calibration = metaData.get(MetadataModules.CALIBRATION, imageId);\n    const voiLUTFunctionEnum = getValidVOILUTFunction(voiLUTFunction);\n    const imagePlaneModule = getImagePlaneModule(imageId);\n    return {\n        calibration,\n        scalingFactor: imageIdScalingFactor,\n        voiLUTFunction: voiLUTFunctionEnum,\n        modality,\n        imagePlaneModule,\n        imagePixelModule: {\n            bitsAllocated,\n            bitsStored,\n            samplesPerPixel,\n            highBit,\n            photometricInterpretation,\n            pixelRepresentation,\n            windowWidth: windowWidth,\n            windowCenter: windowCenter,\n            modality,\n            voiLUTFunction: voiLUTFunctionEnum,\n        },\n    };\n}\n","import { vec3 } from 'gl-matrix';\nimport * as metaData from '../metaData';\nimport { getConfiguration } from '../init';\nexport default function calculateSpacingBetweenImageIds(imageIds) {\n    const { imagePositionPatient: referenceImagePositionPatient, imageOrientationPatient, } = metaData.get('imagePlaneModule', imageIds[0]);\n    const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n    const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n    const scanAxisNormal = vec3.create();\n    vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\n    const refIppVec = vec3.fromValues(referenceImagePositionPatient[0], referenceImagePositionPatient[1], referenceImagePositionPatient[2]);\n    const usingWadoUri = imageIds[0].split(':')[0] === 'wadouri';\n    let spacing;\n    function getDistance(imageId) {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const positionVector = vec3.create();\n        const ippVec = vec3.fromValues(imagePositionPatient[0], imagePositionPatient[1], imagePositionPatient[2]);\n        vec3.sub(positionVector, refIppVec, ippVec);\n        return vec3.dot(positionVector, scanAxisNormal);\n    }\n    if (!usingWadoUri) {\n        const distanceImagePairs = imageIds.map((imageId) => {\n            const distance = getDistance(imageId);\n            return {\n                distance,\n                imageId,\n            };\n        });\n        distanceImagePairs.sort((a, b) => b.distance - a.distance);\n        const numImages = distanceImagePairs.length;\n        spacing =\n            Math.abs(distanceImagePairs[numImages - 1].distance -\n                distanceImagePairs[0].distance) /\n                (numImages - 1);\n    }\n    else {\n        const prefetchedImageIds = [\n            imageIds[0],\n            imageIds[Math.floor(imageIds.length / 2)],\n        ];\n        const firstImageDistance = getDistance(prefetchedImageIds[0]);\n        const middleImageDistance = getDistance(prefetchedImageIds[1]);\n        const metadataForMiddleImage = metaData.get('imagePlaneModule', prefetchedImageIds[1]);\n        if (!metadataForMiddleImage) {\n            throw new Error('Incomplete metadata required for volume construction.');\n        }\n        const positionVector = vec3.create();\n        const middleIppVec = vec3.fromValues(metadataForMiddleImage.imagePositionPatient[0], metadataForMiddleImage.imagePositionPatient[1], metadataForMiddleImage.imagePositionPatient[2]);\n        vec3.sub(positionVector, refIppVec, middleIppVec);\n        const distanceBetweenFirstAndMiddleImages = vec3.dot(positionVector, scanAxisNormal);\n        spacing =\n            Math.abs(distanceBetweenFirstAndMiddleImages) /\n                Math.floor(imageIds.length / 2);\n    }\n    const { sliceThickness, spacingBetweenSlices } = metaData.get('imagePlaneModule', imageIds[0]);\n    const { strictZSpacingForVolumeViewport } = getConfiguration().rendering;\n    if ((spacing === 0 || isNaN(spacing)) && !strictZSpacingForVolumeViewport) {\n        if (spacingBetweenSlices) {\n            console.debug('Could not calculate spacing. Using spacingBetweenSlices');\n            spacing = spacingBetweenSlices;\n        }\n        else if (sliceThickness) {\n            console.debug('Could not calculate spacing and no spacingBetweenSlices. Using sliceThickness');\n            spacing = sliceThickness;\n        }\n        else {\n            console.debug('Could not calculate spacing. The VolumeViewport visualization is compromised. Setting spacing to 1 to render');\n            spacing = 1;\n        }\n    }\n    return spacing;\n}\n","function clamp(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\nexport { clamp as default, clamp };\n","import vtkColorMaps from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nimport isEqual from './isEqual';\nimport { actorIsA } from './actorCheck';\nconst _colormaps = new Map();\nfunction registerColormap(colormap) {\n    colormap.name = colormap.name || colormap.Name;\n    _colormaps.set(colormap.name, colormap);\n}\nfunction getColormap(name) {\n    return _colormaps.get(name);\n}\nfunction getColormapNames() {\n    return Array.from(_colormaps.keys());\n}\nfunction findMatchingColormap(rgbPoints, actor) {\n    const colormapsVTK = vtkColorMaps.rgbPresetNames.map((presetName) => vtkColorMaps.getPresetByName(presetName));\n    const colormapsCS3D = getColormapNames().map((colormapName) => getColormap(colormapName));\n    const colormaps = colormapsVTK.concat(colormapsCS3D);\n    const matchedColormap = colormaps.find((colormap) => {\n        const { RGBPoints: presetRGBPoints } = colormap;\n        if (presetRGBPoints.length !== rgbPoints.length) {\n            return false;\n        }\n        for (let i = 0; i < presetRGBPoints.length; i += 4) {\n            if (!isEqual(presetRGBPoints.slice(i + 1, i + 4), rgbPoints.slice(i + 1, i + 4))) {\n                return false;\n            }\n        }\n        return true;\n    });\n    if (!matchedColormap) {\n        return null;\n    }\n    const opacity = [];\n    if (actorIsA(actor, 'vtkVolume')) {\n        const opacityPoints = actor\n            .getProperty()\n            .getScalarOpacity(0)\n            .getDataPointer();\n        if (!opacityPoints) {\n            return {\n                name: matchedColormap.Name,\n            };\n        }\n        for (let i = 0; i < opacityPoints.length; i += 2) {\n            opacity.push({\n                value: opacityPoints[i],\n                opacity: opacityPoints[i + 1],\n            });\n        }\n    }\n    const result = {\n        name: matchedColormap.Name,\n        ...(Array.isArray(opacity) && opacity.length > 0 && { opacity }),\n        ...(typeof opacity === 'number' && { opacity }),\n    };\n    return result;\n}\nexport function setColorMapTransferFunctionForVolumeActor(volumeInfo) {\n    const { volumeActor, preset, opacity = 0.9, threshold = null, colorRange = [0, 5], } = volumeInfo;\n    const mapper = volumeActor.getMapper();\n    mapper.setSampleDistance(1.0);\n    const cfun = vtkColorTransferFunction.newInstance();\n    const presetToUse = preset || vtkColorMaps.getPresetByName('hsv');\n    cfun.applyColorMap(presetToUse);\n    cfun.setMappingRange(colorRange[0], colorRange[1]);\n    volumeActor.getProperty().setRGBTransferFunction(0, cfun);\n    updateOpacityWithThreshold(volumeActor, opacity, threshold);\n}\nexport function updateOpacity(volumeActor, newOpacity) {\n    const currentThreshold = getThresholdValue(volumeActor);\n    updateOpacityWithThreshold(volumeActor, newOpacity, currentThreshold);\n}\nexport function updateThreshold(volumeActor, newThreshold) {\n    const currentOpacity = getMaxOpacity(volumeActor);\n    updateOpacityWithThreshold(volumeActor, currentOpacity, newThreshold);\n}\nfunction updateOpacityWithThreshold(volumeActor, opacity, threshold) {\n    const meta = volumeActor.getMapper().getInputData().get('voxelManager');\n    if (!meta?.voxelManager) {\n        throw new Error('No voxel manager was found for the volume actor, or you cannot yet update opacity with a threshold using stacked images');\n    }\n    const range = meta.voxelManager.getRange();\n    const ofun = vtkPiecewiseFunction.newInstance();\n    if (threshold !== null) {\n        const delta = Math.abs(range[1] - range[0]) * 0.001;\n        const thresholdValue = Math.max(range[0], Math.min(range[1], threshold));\n        ofun.addPoint(range[0], 0);\n        ofun.addPoint(thresholdValue - delta, 0);\n        ofun.addPoint(thresholdValue, opacity);\n        ofun.addPoint(range[1], opacity);\n    }\n    else {\n        ofun.addPoint(range[0], opacity);\n        ofun.addPoint(range[1], opacity);\n    }\n    volumeActor.getProperty().setScalarOpacity(0, ofun);\n}\nfunction getThresholdValue(volumeActor) {\n    const opacityFunction = volumeActor.getProperty().getScalarOpacity(0);\n    if (!opacityFunction) {\n        return null;\n    }\n    const dataArray = opacityFunction.getDataPointer();\n    if (!dataArray || dataArray.length <= 4) {\n        return null;\n    }\n    for (let i = 0; i < dataArray.length - 2; i += 2) {\n        const x1 = dataArray[i];\n        const y1 = dataArray[i + 1];\n        const x2 = dataArray[i + 2];\n        const y2 = dataArray[i + 3];\n        if (y1 === 0 && y2 > 0) {\n            return x2;\n        }\n    }\n    return null;\n}\nfunction getMaxOpacity(volumeActor) {\n    const opacityFunction = volumeActor.getProperty().getScalarOpacity(0);\n    if (!opacityFunction) {\n        return 1.0;\n    }\n    const dataArray = opacityFunction.getDataPointer();\n    if (!dataArray || dataArray.length === 0) {\n        return 1.0;\n    }\n    let maxOpacity = 0;\n    for (let i = 1; i < dataArray.length; i += 2) {\n        if (dataArray[i] > maxOpacity) {\n            maxOpacity = dataArray[i];\n        }\n    }\n    return maxOpacity;\n}\nexport { getColormap, getColormapNames, registerColormap, findMatchingColormap, getThresholdValue, getMaxOpacity, };\n","import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nexport default function createLinearRGBTransferFunction(voiRange) {\n    const cfun = vtkColorTransferFunction.newInstance();\n    let lower = 0;\n    let upper = 1024;\n    if (voiRange.lower !== undefined && voiRange.upper !== undefined) {\n        lower = voiRange.lower;\n        upper = voiRange.upper;\n    }\n    cfun.addRGBPoint(lower, 0.0, 0.0, 0.0);\n    cfun.addRGBPoint(upper, 1.0, 1.0, 1.0);\n    return cfun;\n}\n","import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport * as windowLevelUtil from './windowLevel';\nimport { logit } from './logit';\nexport default function createSigmoidRGBTransferFunction(voiRange, approximationNodes = 1024) {\n    const { windowWidth, windowCenter } = windowLevelUtil.toWindowLevel(voiRange.lower, voiRange.upper);\n    const range = Array.from({ length: approximationNodes }, (_, i) => (i + 1) / (approximationNodes + 2));\n    const table = range.flatMap((y) => {\n        const x = logit(y, windowCenter, windowWidth);\n        return [x, y, y, y, 0.5, 0.0];\n    });\n    const cfun = vtkColorTransferFunction.newInstance();\n    cfun.buildFunctionFromArray(vtkDataArray.newInstance({\n        values: table,\n        numberOfComponents: 6,\n    }));\n    return cfun;\n}\n","export default function decimate(list, interleave, offset = 0) {\n    const interleaveIndices = [];\n    for (let i = offset; i < list.length; i += interleave) {\n        interleaveIndices.push(i);\n    }\n    return interleaveIndices;\n}\n","export function deepClone(obj) {\n    if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }\n    if (typeof obj === 'function') {\n        return obj;\n    }\n    if (typeof structuredClone === 'function') {\n        return obj;\n    }\n    if (Array.isArray(obj)) {\n        return obj.map(deepClone);\n    }\n    else {\n        const clonedObj = {};\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clonedObj[key] = deepClone(obj[key]);\n            }\n        }\n        return clonedObj;\n    }\n}\n","export default function fnv1aHash(str) {\n    let hash = 0x811c9dc5;\n    for (let i = 0; i < str.length; i++) {\n        hash ^= str.charCodeAt(i);\n        hash +=\n            (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n    }\n    return (hash >>> 0).toString(36);\n}\n","import { vec3 } from 'gl-matrix';\nimport * as metaData from '../metaData';\nimport { coreLog } from './logger';\nimport getSpacingInNormalDirection from './getSpacingInNormalDirection';\nimport { EPSILON } from '../constants';\nconst log = coreLog.getLogger('utilities', 'getClosestImageId');\nexport default function getClosestImageId(imageVolume, worldPos, viewPlaneNormal, options) {\n    const { direction, spacing, imageIds } = imageVolume;\n    const { ignoreSpacing = false } = options || {};\n    if (!imageIds?.length) {\n        return;\n    }\n    const kVector = direction.slice(6, 9);\n    const dotProduct = vec3.dot(kVector, viewPlaneNormal);\n    if (Math.abs(dotProduct) < 1 - EPSILON) {\n        return;\n    }\n    let halfSpacingInNormalDirection;\n    if (!ignoreSpacing) {\n        const spacingInNormalDirection = getSpacingInNormalDirection({ direction, spacing }, viewPlaneNormal);\n        halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    }\n    let closestImageId;\n    let minDistance = Infinity;\n    for (let i = 0; i < imageIds.length; i++) {\n        const imageId = imageIds[i];\n        const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\n        if (!imagePlaneModule?.imagePositionPatient) {\n            log.warn(`Missing imagePositionPatient for imageId: ${imageId}`);\n            continue;\n        }\n        const { imagePositionPatient } = imagePlaneModule;\n        const dir = vec3.create();\n        vec3.sub(dir, worldPos, imagePositionPatient);\n        const distance = Math.abs(vec3.dot(dir, viewPlaneNormal));\n        if (ignoreSpacing) {\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestImageId = imageId;\n            }\n        }\n        else {\n            if (distance < halfSpacingInNormalDirection && distance < minDistance) {\n                minDistance = distance;\n                closestImageId = imageId;\n            }\n        }\n    }\n    if (closestImageId === undefined) {\n        log.warn('No imageId found within the specified criteria (half spacing or absolute closest).');\n    }\n    return closestImageId;\n}\n","import { vec3 } from 'gl-matrix';\nimport { EPSILON } from '../constants';\nimport { buildMetadata } from './buildMetadata';\nexport function getImageDataMetadata(image) {\n    const { imagePlaneModule, imagePixelModule, voiLUTFunction, modality, scalingFactor, calibration, } = buildMetadata(image);\n    let { rowCosines, columnCosines } = imagePlaneModule;\n    if (rowCosines == null || columnCosines == null) {\n        rowCosines = [1, 0, 0];\n        columnCosines = [0, 1, 0];\n    }\n    const rowCosineVec = vec3.fromValues(rowCosines[0], rowCosines[1], rowCosines[2]);\n    const colCosineVec = vec3.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);\n    const scanAxisNormal = vec3.create();\n    vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\n    let origin = imagePlaneModule.imagePositionPatient;\n    if (origin == null) {\n        origin = [0, 0, 0];\n    }\n    const xSpacing = imagePlaneModule.columnPixelSpacing || image.columnPixelSpacing;\n    const ySpacing = imagePlaneModule.rowPixelSpacing || image.rowPixelSpacing;\n    const xVoxels = image.columns;\n    const yVoxels = image.rows;\n    const zSpacing = EPSILON;\n    const zVoxels = 1;\n    if (!imagePixelModule.photometricInterpretation &&\n        image.sizeInBytes === 3 * image.width * image.height) {\n        image.numberOfComponents = 3;\n    }\n    const numberOfComponents = image.numberOfComponents ||\n        _getNumCompsFromPhotometricInterpretation(imagePixelModule.photometricInterpretation);\n    return {\n        numberOfComponents,\n        origin,\n        direction: [...rowCosineVec, ...colCosineVec, ...scanAxisNormal],\n        dimensions: [xVoxels, yVoxels, zVoxels],\n        spacing: [xSpacing, ySpacing, zSpacing],\n        numVoxels: xVoxels * yVoxels * zVoxels,\n        imagePlaneModule,\n        imagePixelModule,\n        bitsAllocated: imagePixelModule.bitsAllocated,\n        voiLUTFunction,\n        modality,\n        scalingFactor,\n        calibration,\n        scanAxisNormal: scanAxisNormal,\n    };\n}\nfunction _getNumCompsFromPhotometricInterpretation(photometricInterpretation) {\n    let numberOfComponents = 1;\n    if (photometricInterpretation === 'RGB' ||\n        photometricInterpretation?.includes('YBR') ||\n        photometricInterpretation === 'PALETTE COLOR') {\n        numberOfComponents = 3;\n    }\n    return numberOfComponents;\n}\n","import getSliceRange from './getSliceRange';\nimport getTargetVolumeAndSpacingInNormalDir from './getTargetVolumeAndSpacingInNormalDir';\nfunction getImageSliceDataForVolumeViewport(viewport) {\n    const camera = viewport.getCamera();\n    const { spacingInNormalDirection, imageVolume } = getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n    if (!imageVolume) {\n        return;\n    }\n    const { viewPlaneNormal, focalPoint } = camera;\n    const actorEntry = viewport\n        .getActors()\n        .find((a) => a.referencedId === imageVolume.volumeId ||\n        a.uid === imageVolume.volumeId);\n    if (!actorEntry) {\n        console.warn('No actor found for with actorUID of', imageVolume.volumeId);\n    }\n    const volumeActor = actorEntry.actor;\n    const sliceRange = getSliceRange(volumeActor, viewPlaneNormal, focalPoint);\n    const { min, max, current } = sliceRange;\n    const numberOfSlices = Math.round((max - min) / spacingInNormalDirection) + 1;\n    let imageIndex = ((current - min) / (max - min)) * numberOfSlices;\n    imageIndex = Math.floor(imageIndex);\n    if (imageIndex > numberOfSlices - 1) {\n        imageIndex = numberOfSlices - 1;\n    }\n    else if (imageIndex < 0) {\n        imageIndex = 0;\n    }\n    return {\n        numberOfSlices,\n        imageIndex,\n    };\n}\nexport default getImageSliceDataForVolumeViewport;\n","import * as metaData from '../metaData';\nexport default function getScalingParameters(imageId) {\n    const modalityLutModule = metaData.get('modalityLutModule', imageId) || {};\n    const generalSeriesModule = metaData.get('generalSeriesModule', imageId) || {};\n    const { modality } = generalSeriesModule;\n    const scalingParameters = {\n        rescaleSlope: modalityLutModule.rescaleSlope || 1,\n        rescaleIntercept: modalityLutModule.rescaleIntercept ?? 0,\n        modality,\n    };\n    const scalingModules = metaData.get('scalingModule', imageId) || {};\n    return {\n        ...scalingParameters,\n        ...(modality === 'PT' && {\n            suvbw: scalingModules.suvbw,\n            suvbsa: scalingModules.suvbsa,\n            suvlbm: scalingModules.suvlbm,\n        }),\n        ...(modality === 'RTDOSE' && {\n            doseGridScaling: scalingModules.DoseGridScaling,\n            doseSummation: scalingModules.DoseSummation,\n            doseType: scalingModules.DoseType,\n            doseUnit: scalingModules.DoseUnit,\n        }),\n    };\n}\n","import vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\nimport getVolumeActorCorners from './getVolumeActorCorners';\nimport { EPSILON } from '../constants';\nconst SMALL_EPSILON = EPSILON * EPSILON;\nconst isOne = (v) => Math.abs(Math.abs(v) - 1) < SMALL_EPSILON;\nconst isUnit = (v, off) => isOne(v[off]) || isOne(v[off + 1]) || isOne(v[off + 2]);\nconst isOrthonormal = (v) => isUnit(v, 0) && isUnit(v, 3) && isUnit(v, 6);\nexport default function getSliceRange(volumeActor, viewPlaneNormal, focalPoint) {\n    const imageData = volumeActor.getMapper().getInputData();\n    let corners;\n    const direction = imageData.getDirection();\n    if (isOrthonormal(direction)) {\n        corners = getVolumeActorCorners(volumeActor);\n    }\n    else {\n        const [dx, dy, dz] = imageData.getDimensions();\n        const cornersIdx = [\n            [0, 0, 0],\n            [dx - 1, 0, 0],\n            [0, dy - 1, 0],\n            [dx - 1, dy - 1, 0],\n            [0, 0, dz - 1],\n            [dx - 1, 0, dz - 1],\n            [0, dy - 1, dz - 1],\n            [dx - 1, dy - 1, dz - 1],\n        ];\n        corners = cornersIdx.map((it) => imageData.indexToWorld(it));\n    }\n    const transform = vtkMatrixBuilder\n        .buildFromDegree()\n        .identity()\n        .rotateFromDirections(viewPlaneNormal, [1, 0, 0]);\n    corners.forEach((pt) => transform.apply(pt));\n    const transformedFocalPoint = [...focalPoint];\n    transform.apply(transformedFocalPoint);\n    const currentSlice = transformedFocalPoint[0];\n    let minX = Infinity;\n    let maxX = -Infinity;\n    for (let i = 0; i < 8; i++) {\n        const x = corners[i][0];\n        if (x > maxX) {\n            maxX = x;\n        }\n        if (x < minX) {\n            minX = x;\n        }\n    }\n    return {\n        min: minX,\n        max: maxX,\n        current: currentSlice,\n        actor: volumeActor,\n        viewPlaneNormal,\n        focalPoint,\n    };\n}\n","import { vec3 } from 'gl-matrix';\nexport default function getSpacingInNormalDirection(imageVolume, viewPlaneNormal) {\n    const { direction, spacing } = imageVolume;\n    const iVector = direction.slice(0, 3);\n    const jVector = direction.slice(3, 6);\n    const kVector = direction.slice(6, 9);\n    const dotProducts = [\n        vec3.dot(iVector, viewPlaneNormal),\n        vec3.dot(jVector, viewPlaneNormal),\n        vec3.dot(kVector, viewPlaneNormal),\n    ];\n    const projectedSpacing = vec3.create();\n    vec3.set(projectedSpacing, dotProducts[0] * spacing[0], dotProducts[1] * spacing[1], dotProducts[2] * spacing[2]);\n    const spacingInNormalDirection = vec3.length(projectedSpacing);\n    return spacingInNormalDirection;\n}\n","import cache from '../cache/cache';\nimport { EPSILON } from '../constants';\nimport getSpacingInNormalDirection from './getSpacingInNormalDirection';\nimport { getVolumeLoaderSchemes } from '../loaders/volumeLoader';\nimport { getVolumeId } from './getVolumeId';\nconst EPSILON_PART = 1 + EPSILON;\nconst startsWith = (str, starts) => starts === str.substring(0, Math.min(str.length, starts.length));\nconst isPrimaryVolume = (volume) => !!getVolumeLoaderSchemes().find((scheme) => startsWith(volume.volumeId, scheme));\nexport default function getTargetVolumeAndSpacingInNormalDir(viewport, camera, targetId, useSlabThickness = false) {\n    const { viewPlaneNormal } = camera;\n    const volumeActors = viewport.getActors();\n    if (!volumeActors.length) {\n        return {\n            spacingInNormalDirection: null,\n            imageVolume: null,\n            actorUID: null,\n        };\n    }\n    const imageVolumes = volumeActors\n        .map((va) => {\n        const actorUID = va.referencedId ?? va.uid;\n        return cache.getVolume(actorUID);\n    })\n        .filter((iv) => !!iv);\n    if (targetId) {\n        const targetVolumeId = getVolumeId(targetId);\n        const imageVolumeIndex = imageVolumes.findIndex((iv) => targetVolumeId.includes(iv.volumeId));\n        const imageVolume = imageVolumes[imageVolumeIndex];\n        const { uid: actorUID } = volumeActors[imageVolumeIndex];\n        const spacingInNormalDirection = getSpacingInNormal(imageVolume, viewPlaneNormal, viewport, useSlabThickness);\n        return { imageVolume, spacingInNormalDirection, actorUID };\n    }\n    if (!imageVolumes.length) {\n        return {\n            spacingInNormalDirection: null,\n            imageVolume: null,\n            actorUID: null,\n        };\n    }\n    const smallest = {\n        spacingInNormalDirection: Infinity,\n        imageVolume: null,\n        actorUID: null,\n    };\n    const hasPrimaryVolume = imageVolumes.find(isPrimaryVolume);\n    for (let i = 0; i < imageVolumes.length; i++) {\n        const imageVolume = imageVolumes[i];\n        if (hasPrimaryVolume && !isPrimaryVolume(imageVolume)) {\n            continue;\n        }\n        const spacingInNormalDirection = getSpacingInNormal(imageVolume, viewPlaneNormal, viewport);\n        if (spacingInNormalDirection * EPSILON_PART <\n            smallest.spacingInNormalDirection) {\n            smallest.spacingInNormalDirection = spacingInNormalDirection;\n            smallest.imageVolume = imageVolume;\n            smallest.actorUID = volumeActors[i].uid;\n        }\n    }\n    return smallest;\n}\nfunction getSpacingInNormal(imageVolume, viewPlaneNormal, viewport, useSlabThickness = false) {\n    const { slabThickness } = viewport.getProperties();\n    let spacingInNormalDirection = slabThickness;\n    if (!slabThickness || !useSlabThickness) {\n        spacingInNormalDirection = getSpacingInNormalDirection(imageVolume, viewPlaneNormal);\n    }\n    return spacingInNormalDirection;\n}\n","import { getRenderingEngines } from '../RenderingEngine/getRenderingEngine';\nfunction getViewportsWithVolumeId(volumeId) {\n    const renderingEngines = getRenderingEngines();\n    const targetViewports = [];\n    renderingEngines.forEach((renderingEngine) => {\n        const viewports = renderingEngine.getVolumeViewports();\n        const filteredViewports = viewports.filter((vp) => vp.hasVolumeId(volumeId));\n        targetViewports.push(...filteredViewports);\n    });\n    return targetViewports;\n}\nexport default getViewportsWithVolumeId;\n","export default function getVoiFromSigmoidRGBTransferFunction(cfun) {\n    let cfunRange = [];\n    const [lower, upper] = cfun.getRange();\n    cfun.getTable(lower, upper, 1024, cfunRange);\n    cfunRange = cfunRange.filter((v, k) => k % 3 === 0);\n    const cfunDomain = [...Array(1024).keys()].map((v, k) => {\n        return lower + ((upper - lower) / (1024 - 1)) * k;\n    });\n    const y1 = cfunRange[256];\n    const logy1 = Math.log((1 - y1) / y1);\n    const x1 = cfunDomain[256];\n    const y2 = cfunRange[256 * 3];\n    const logy2 = Math.log((1 - y2) / y2);\n    const x2 = cfunDomain[256 * 3];\n    const ww = Math.round((4 * (x2 - x1)) / (logy1 - logy2));\n    const wc = Math.round(x1 + (ww * logy1) / 4);\n    return [Math.round(wc - ww / 2), Math.round(wc + ww / 2)];\n}\n","export default function getVolumeActorCorners(volumeActor) {\n    const imageData = volumeActor.getMapper().getInputData();\n    const bounds = imageData.extentToBounds(imageData.getExtent());\n    return [\n        [bounds[0], bounds[2], bounds[4]],\n        [bounds[0], bounds[2], bounds[5]],\n        [bounds[0], bounds[3], bounds[4]],\n        [bounds[0], bounds[3], bounds[5]],\n        [bounds[1], bounds[2], bounds[4]],\n        [bounds[1], bounds[2], bounds[5]],\n        [bounds[1], bounds[3], bounds[4]],\n        [bounds[1], bounds[3], bounds[5]],\n    ];\n}\n","export const getVolumeId = (targetId) => {\n    const prefix = 'volumeId:';\n    const str = targetId.includes(prefix)\n        ? targetId.substring(prefix.length)\n        : targetId;\n    const index = str.indexOf('sliceIndex=');\n    return index === -1 ? str : str.substring(0, index - 1);\n};\n","import getSliceRange from './getSliceRange';\nimport getTargetVolumeAndSpacingInNormalDir from './getTargetVolumeAndSpacingInNormalDir';\nfunction getVolumeSliceRangeInfo(viewport, volumeId, useSlabThickness = false) {\n    const camera = viewport.getCamera();\n    const { focalPoint, viewPlaneNormal } = camera;\n    const { spacingInNormalDirection, actorUID } = getTargetVolumeAndSpacingInNormalDir(viewport, camera, volumeId, useSlabThickness);\n    if (!actorUID) {\n        throw new Error(`Could not find image volume with id ${volumeId} in the viewport`);\n    }\n    const actorEntry = viewport.getActor(actorUID);\n    if (!actorEntry) {\n        console.warn('No actor found for with actorUID of', actorUID);\n        return null;\n    }\n    const volumeActor = actorEntry.actor;\n    const sliceRange = getSliceRange(volumeActor, viewPlaneNormal, focalPoint);\n    return {\n        sliceRange,\n        spacingInNormalDirection,\n        camera,\n    };\n}\nexport default getVolumeSliceRangeInfo;\n","import getVolumeSliceRangeInfo from './getVolumeSliceRangeInfo';\nfunction getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness = false) {\n    const { sliceRange, spacingInNormalDirection, camera } = getVolumeSliceRangeInfo(viewport, volumeId, useSlabThickness);\n    const { min, max, current } = sliceRange;\n    const numScrollSteps = Math.round((max - min) / spacingInNormalDirection);\n    const fraction = (current - min) / (max - min);\n    const floatingStepNumber = fraction * numScrollSteps;\n    const currentStepIndex = Math.round(floatingStepNumber);\n    return {\n        numScrollSteps,\n        currentStepIndex,\n        sliceRangeInfo: {\n            sliceRange,\n            spacingInNormalDirection,\n            camera,\n        },\n    };\n}\nexport default getVolumeViewportScrollInfo;\n","export const hasFloatScalingParameters = (scalingParameters) => {\n    const hasFloatRescale = Object.values(scalingParameters).some((value) => typeof value === 'number' && !Number.isInteger(value));\n    return hasFloatRescale;\n};\n","export default function hasNaNValues(input) {\n    if (Array.isArray(input)) {\n        return input.some((value) => Number.isNaN(value));\n    }\n    return Number.isNaN(input);\n}\n","export default function imageIdToURI(imageId) {\n    const colonIndex = imageId.indexOf(':');\n    return imageId.substring(colonIndex + 1);\n}\n","import { addProvider } from '../metaData';\nconst retrieveConfigurationState = new Map();\nconst IMAGE_RETRIEVE_CONFIGURATION = 'imageRetrieveConfiguration';\nconst imageRetrieveMetadataProvider = {\n    IMAGE_RETRIEVE_CONFIGURATION,\n    clear: () => {\n        retrieveConfigurationState.clear();\n    },\n    add: (key, payload) => {\n        retrieveConfigurationState.set(key, payload);\n    },\n    clone: () => {\n        return new Map(retrieveConfigurationState);\n    },\n    restore: (state) => {\n        retrieveConfigurationState.clear();\n        state.forEach((value, key) => {\n            retrieveConfigurationState.set(key, value);\n        });\n    },\n    get: (type, ...queries) => {\n        if (type === IMAGE_RETRIEVE_CONFIGURATION) {\n            return queries\n                .map((query) => retrieveConfigurationState.get(query))\n                .find((it) => it !== undefined);\n        }\n    },\n};\naddProvider(imageRetrieveMetadataProvider.get.bind(imageRetrieveMetadataProvider));\nexport default imageRetrieveMetadataProvider;\n","var EventListenerPhases;\n(function (EventListenerPhases) {\n    EventListenerPhases[EventListenerPhases[\"None\"] = 0] = \"None\";\n    EventListenerPhases[EventListenerPhases[\"Capture\"] = 1] = \"Capture\";\n    EventListenerPhases[EventListenerPhases[\"Bubble\"] = 2] = \"Bubble\";\n})(EventListenerPhases || (EventListenerPhases = {}));\nclass TargetEventListeners {\n    constructor(target) {\n        this._eventListeners = new Map();\n        this._children = new Map();\n        this._target = target;\n    }\n    get isEmpty() {\n        return this._eventListeners.size === 0 && this._children.size === 0;\n    }\n    addEventListener(type, callback, options) {\n        const dotIndex = type.indexOf('.');\n        const isNamespace = dotIndex !== -1;\n        if (isNamespace) {\n            const namespaceToken = type.substring(0, dotIndex);\n            let childElementEventListener = this._children.get(namespaceToken);\n            if (!childElementEventListener) {\n                childElementEventListener = new TargetEventListeners(this._target);\n                this._children.set(namespaceToken, childElementEventListener);\n            }\n            type = type.substring(dotIndex + 1);\n            childElementEventListener.addEventListener(type, callback, options);\n        }\n        else {\n            this._addEventListener(type, callback, options);\n        }\n    }\n    removeEventListener(type, callback, options) {\n        const dotIndex = type.indexOf('.');\n        const isNamespace = dotIndex !== -1;\n        if (isNamespace) {\n            const namespaceToken = type.substring(0, dotIndex);\n            const childElementEventListener = this._children.get(namespaceToken);\n            if (!childElementEventListener) {\n                return;\n            }\n            type = type.substring(dotIndex + 1);\n            childElementEventListener.removeEventListener(type, callback, options);\n            if (childElementEventListener.isEmpty) {\n                this._children.delete(namespaceToken);\n            }\n        }\n        else {\n            this._removeEventListener(type, callback, options);\n        }\n    }\n    reset() {\n        Array.from(this._children.entries()).forEach(([namespace, child]) => {\n            child.reset();\n            if (child.isEmpty) {\n                this._children.delete(namespace);\n            }\n            else {\n                throw new Error('Child is not empty and cannot be removed');\n            }\n        });\n        this._unregisterAllEvents();\n    }\n    _addEventListener(type, callback, options) {\n        let listenersMap = this._eventListeners.get(type);\n        if (!listenersMap) {\n            listenersMap = new Map();\n            this._eventListeners.set(type, listenersMap);\n        }\n        const useCapture = options?.capture ?? false;\n        const listenerPhase = useCapture\n            ? EventListenerPhases.Capture\n            : EventListenerPhases.Bubble;\n        const registeredPhases = listenersMap.get(callback) ?? EventListenerPhases.None;\n        if (registeredPhases & listenerPhase) {\n            console.warn('A listener is already registered for this phase');\n            return;\n        }\n        listenersMap.set(callback, registeredPhases | listenerPhase);\n        this._target.addEventListener(type, callback, options);\n    }\n    _removeEventListener(type, callback, options) {\n        const useCapture = options?.capture ?? false;\n        const listenerPhase = useCapture\n            ? EventListenerPhases.Capture\n            : EventListenerPhases.Bubble;\n        const listenersMap = this._eventListeners.get(type);\n        if (!listenersMap) {\n            return;\n        }\n        const callbacks = callback ? [callback] : Array.from(listenersMap.keys());\n        callbacks.forEach((callbackItem) => {\n            const registeredPhases = listenersMap.get(callbackItem) ?? EventListenerPhases.None;\n            const phaseRegistered = !!(registeredPhases & listenerPhase);\n            if (!phaseRegistered) {\n                return;\n            }\n            this._target.removeEventListener(type, callbackItem, options);\n            const newListenerPhase = registeredPhases ^ listenerPhase;\n            if (newListenerPhase === EventListenerPhases.None) {\n                listenersMap.delete(callbackItem);\n            }\n            else {\n                listenersMap.set(callbackItem, newListenerPhase);\n            }\n        });\n        if (!listenersMap.size) {\n            this._eventListeners.delete(type);\n        }\n    }\n    _unregisterAllListeners(type, listenersMap) {\n        Array.from(listenersMap.entries()).forEach(([listener, eventPhases]) => {\n            const startPhase = EventListenerPhases.Capture;\n            for (let currentPhase = startPhase; eventPhases; currentPhase <<= 1) {\n                if (!(eventPhases & currentPhase)) {\n                    continue;\n                }\n                const useCapture = currentPhase === EventListenerPhases.Capture ? true : false;\n                this.removeEventListener(type, listener, { capture: useCapture });\n                eventPhases ^= currentPhase;\n            }\n        });\n    }\n    _unregisterAllEvents() {\n        Array.from(this._eventListeners.entries()).forEach(([type, listenersMap]) => {\n            this._unregisterAllListeners(type, listenersMap);\n        });\n    }\n}\nexport { TargetEventListeners as default, TargetEventListeners };\n","import TargetEventListeners from './TargetEventListeners';\nclass MultiTargetEventListenerManager {\n    constructor() {\n        this._targetsEventListeners = new Map();\n    }\n    addEventListener(target, type, callback, options) {\n        let eventListeners = this._targetsEventListeners.get(target);\n        if (!eventListeners) {\n            eventListeners = new TargetEventListeners(target);\n            this._targetsEventListeners.set(target, eventListeners);\n        }\n        eventListeners.addEventListener(type, callback, options);\n    }\n    removeEventListener(target, type, callback, options) {\n        const eventListeners = this._targetsEventListeners.get(target);\n        if (!eventListeners) {\n            return;\n        }\n        eventListeners.removeEventListener(type, callback, options);\n        if (eventListeners.isEmpty) {\n            this._targetsEventListeners.delete(target);\n        }\n    }\n    reset() {\n        Array.from(this._targetsEventListeners.entries()).forEach(([target, targetEventListeners]) => {\n            targetEventListeners.reset();\n            this._targetsEventListeners.delete(target);\n        });\n    }\n}\nexport { MultiTargetEventListenerManager as default, MultiTargetEventListenerManager, };\n","export default function scaleRGBTransferFunction(rgbTransferFunction, scalingFactor) {\n    const size = rgbTransferFunction.getSize();\n    for (let index = 0; index < size; index++) {\n        const nodeValue1 = [];\n        rgbTransferFunction.getNodeValue(index, nodeValue1);\n        nodeValue1[1] = nodeValue1[1] * scalingFactor;\n        nodeValue1[2] = nodeValue1[2] * scalingFactor;\n        nodeValue1[3] = nodeValue1[3] * scalingFactor;\n        rgbTransferFunction.setNodeValue(index, nodeValue1);\n    }\n}\n","export default function getMinMax(storedPixelData) {\n    let min = storedPixelData[0];\n    let max = storedPixelData[0];\n    let storedPixel;\n    const numPixels = storedPixelData.length;\n    for (let index = 1; index < numPixels; index++) {\n        storedPixel = storedPixelData[index];\n        min = Math.min(min, storedPixel);\n        max = Math.max(max, storedPixel);\n    }\n    return {\n        min,\n        max,\n    };\n}\n","const LAST_RUNTIME_ID = Symbol('LastRuntimeId');\nconst GLOBAL_CONTEXT = {};\nconst DEFAULT_MAX = 0xffffffff;\nconst DEFAULT_SEPARATOR = '-';\nexport default function getRuntimeId(context, separator, max) {\n    return getNextRuntimeId(context !== null && typeof context === 'object' ? context : GLOBAL_CONTEXT, LAST_RUNTIME_ID, (typeof max === 'number' && max > 0 ? max : DEFAULT_MAX) >>> 0).join(typeof separator === 'string' ? separator : DEFAULT_SEPARATOR);\n}\nfunction getNextRuntimeId(context, symbol, max) {\n    let idComponents = context[symbol];\n    if (!(idComponents instanceof Array)) {\n        idComponents = [0];\n        Object.defineProperty(context, symbol, { value: idComponents });\n    }\n    for (let carry = true, i = 0; carry && i < idComponents.length; ++i) {\n        let n = idComponents[i] | 0;\n        if (n < max) {\n            carry = false;\n            n = n + 1;\n        }\n        else {\n            n = 0;\n            if (i + 1 === idComponents.length) {\n                idComponents.push(0);\n            }\n        }\n        idComponents[i] = n;\n    }\n    return idComponents;\n}\n","import imageIdToURI from './imageIdToURI';\nconst state = {};\nconst metadataProvider = {\n    add: (imageId, payload) => {\n        const imageURI = imageIdToURI(imageId);\n        state[imageURI] = payload;\n    },\n    get: (type, imageId) => {\n        if (type === 'calibratedPixelSpacing') {\n            const imageURI = imageIdToURI(imageId);\n            return state[imageURI];\n        }\n    },\n};\nexport default metadataProvider;\n","export default function isOpposite(v1, v2, tolerance = 1e-5) {\n    return (Math.abs(v1[0] + v2[0]) < tolerance &&\n        Math.abs(v1[1] + v2[1]) < tolerance &&\n        Math.abs(v1[2] + v2[2]) < tolerance);\n}\n","export default function indexWithinDimensions(index, dimensions) {\n    if (index[0] < 0 ||\n        index[0] >= dimensions[0] ||\n        index[1] < 0 ||\n        index[1] >= dimensions[1] ||\n        index[2] < 0 ||\n        index[2] >= dimensions[2]) {\n        return false;\n    }\n    return true;\n}\n","import { getRenderingEngines, getRenderingEngine, } from '../RenderingEngine/getRenderingEngine';\nfunction getVolumeViewportsContainingSameVolumes(targetViewport, renderingEngineId) {\n    let renderingEngines;\n    if (renderingEngineId) {\n        renderingEngines = [getRenderingEngine(renderingEngineId)];\n    }\n    else {\n        renderingEngines = getRenderingEngines();\n    }\n    const sameVolumesViewports = [];\n    renderingEngines.forEach((renderingEngine) => {\n        const targetActors = targetViewport.getActors();\n        const viewports = renderingEngine.getVolumeViewports();\n        for (const vp of viewports) {\n            const vpActors = vp.getActors();\n            if (vpActors.length !== targetActors.length) {\n                continue;\n            }\n            const sameVolumes = targetActors.every(({ uid }) => vpActors.find((vpActor) => uid === vpActor.uid));\n            if (sameVolumes) {\n                sameVolumesViewports.push(vp);\n            }\n        }\n    });\n    return sameVolumesViewports;\n}\nexport default getVolumeViewportsContainingSameVolumes;\n","const isPTPrescaledWithSUV = (image) => {\n    return image.preScale.scaled && image.preScale.scalingParameters.suvbw;\n};\nexport default isPTPrescaledWithSUV;\n","import { vec3 } from 'gl-matrix';\nimport getOrCreateCanvas, { EPSILON, } from '../RenderingEngine/helpers/getOrCreateCanvas';\nimport { ViewportType, Events } from '../enums';\nimport { getRenderingEngine } from '../RenderingEngine/getRenderingEngine';\nimport TiledRenderingEngine from '../RenderingEngine/TiledRenderingEngine';\nimport isPTPrescaledWithSUV from './isPTPrescaledWithSUV';\nexport default function renderToCanvasGPU(canvas, imageOrVolume, modality = undefined, renderingEngineId = '_thumbnails', viewportOptions = {\n    displayArea: { imageArea: [1, 1] },\n}) {\n    if (!canvas || !(canvas instanceof HTMLCanvasElement)) {\n        throw new Error('canvas element is required');\n    }\n    const isVolume = !imageOrVolume.imageId;\n    const image = !isVolume && imageOrVolume;\n    const volume = isVolume && imageOrVolume;\n    const imageIdToPrint = image.imageId || volume.volumeId;\n    const viewportId = `renderGPUViewport-${imageIdToPrint}`;\n    const element = document.createElement('div');\n    const devicePixelRatio = window.devicePixelRatio || 1;\n    if (!viewportOptions.displayArea) {\n        viewportOptions.displayArea = { imageArea: [1, 1] };\n    }\n    const originalWidth = canvas.width;\n    const originalHeight = canvas.height;\n    element.style.width = `${originalWidth / devicePixelRatio + EPSILON}px`;\n    element.style.height = `${originalHeight / devicePixelRatio + EPSILON}px`;\n    element.style.visibility = 'hidden';\n    element.style.position = 'absolute';\n    document.body.appendChild(element);\n    const uniqueId = viewportId.split(':').join('-');\n    element.setAttribute('viewport-id-for-remove', uniqueId);\n    const temporaryCanvas = getOrCreateCanvas(element);\n    const renderingEngine = getRenderingEngine(renderingEngineId) ||\n        new TiledRenderingEngine(renderingEngineId);\n    let viewport = renderingEngine.getViewport(viewportId);\n    if (!viewport) {\n        const viewportInput = {\n            viewportId,\n            type: isVolume ? ViewportType.ORTHOGRAPHIC : ViewportType.STACK,\n            element,\n            defaultOptions: {\n                ...viewportOptions,\n                suppressEvents: true,\n            },\n        };\n        renderingEngine.enableElement(viewportInput);\n        viewport = renderingEngine.getViewport(viewportId);\n    }\n    return new Promise((resolve) => {\n        let elementRendered = false;\n        let { viewReference } = viewportOptions;\n        const onImageRendered = (eventDetail) => {\n            if (elementRendered) {\n                return;\n            }\n            if (viewReference) {\n                const useViewRef = viewReference;\n                viewReference = null;\n                viewport.setViewReference(useViewRef);\n                viewport.render();\n                return;\n            }\n            const context = canvas.getContext('2d');\n            context.drawImage(temporaryCanvas, 0, 0, temporaryCanvas.width, temporaryCanvas.height, 0, 0, canvas.width, canvas.height);\n            const origin = viewport.canvasToWorld([0, 0]);\n            const topRight = viewport.canvasToWorld([\n                temporaryCanvas.width / devicePixelRatio,\n                0,\n            ]);\n            const bottomLeft = viewport.canvasToWorld([\n                0,\n                temporaryCanvas.height / devicePixelRatio,\n            ]);\n            const rightVector = vec3.sub([0, 0, 0], viewport.canvasToWorld([1 / devicePixelRatio, 0]), origin);\n            const downVector = vec3.sub([0, 0, 0], viewport.canvasToWorld([0, 1 / devicePixelRatio]), origin);\n            const thicknessMm = 1;\n            elementRendered = true;\n            element.removeEventListener(Events.IMAGE_RENDERED, onImageRendered);\n            setTimeout(() => {\n                renderingEngine.disableElement(viewportId);\n                const elements = document.querySelectorAll(`[viewport-id-for-remove=\"${uniqueId}\"]`);\n                elements.forEach((element) => {\n                    element.remove();\n                });\n            }, 0);\n            resolve({\n                origin,\n                bottomLeft,\n                topRight,\n                thicknessMm,\n                rightVector,\n                downVector,\n            });\n        };\n        element.addEventListener(Events.IMAGE_RENDERED, onImageRendered);\n        if (isVolume) {\n            viewport.setVolumes([volume], false, true);\n        }\n        else {\n            viewport.renderImageObject(imageOrVolume);\n        }\n        viewport.resetCamera();\n        if (modality === 'PT' && !isPTPrescaledWithSUV(image)) {\n            viewport.setProperties({\n                voiRange: {\n                    lower: image.minPixelValue,\n                    upper: image.maxPixelValue,\n                },\n            });\n        }\n        viewport.render();\n    });\n}\n","import getDefaultViewport from '../RenderingEngine/helpers/cpuFallback/rendering/getDefaultViewport';\nimport calculateTransform from '../RenderingEngine/helpers/cpuFallback/rendering/calculateTransform';\nimport drawImageSync from '../RenderingEngine/helpers/cpuFallback/drawImageSync';\nexport default function renderToCanvasCPU(canvas, imageOrVolume, modality, _renderingEngineId, _viewportOptions) {\n    const volume = imageOrVolume;\n    if (volume.volumeId) {\n        throw new Error('Unsupported volume rendering for CPU');\n    }\n    const image = imageOrVolume;\n    const viewport = getDefaultViewport(canvas, image, modality);\n    const enabledElement = {\n        canvas,\n        viewport,\n        image,\n        renderingTools: {},\n    };\n    enabledElement.transform = calculateTransform(enabledElement);\n    const invalidated = true;\n    return new Promise((resolve, reject) => {\n        drawImageSync(enabledElement, invalidated);\n        resolve(null);\n    });\n}\n","import { loadAndCacheImage } from '../loaders/imageLoader';\nimport * as metaData from '../metaData';\nimport { RequestType } from '../enums';\nimport imageLoadPoolManager from '../requestPool/imageLoadPoolManager';\nimport renderToCanvasGPU from './renderToCanvasGPU';\nimport renderToCanvasCPU from './renderToCanvasCPU';\nimport cache from '../cache/cache';\nexport default function loadImageToCanvas(options) {\n    const { canvas, imageId, viewReference, requestType = RequestType.Thumbnail, priority = -5, renderingEngineId = '_thumbnails', useCPURendering = false, thumbnail = false, imageAspect = false, viewportOptions: baseViewportOptions, } = options;\n    const volumeId = viewReference?.volumeId;\n    const isVolume = volumeId && !imageId;\n    const viewportOptions = viewReference && baseViewportOptions\n        ? { ...baseViewportOptions, viewReference }\n        : baseViewportOptions;\n    const renderFn = useCPURendering ? renderToCanvasCPU : renderToCanvasGPU;\n    return new Promise((resolve, reject) => {\n        function successCallback(imageOrVolume, imageId) {\n            const { modality } = metaData.get('generalSeriesModule', imageId) || {};\n            const image = !isVolume && imageOrVolume;\n            const volume = isVolume && imageOrVolume;\n            if (image) {\n                image.isPreScaled = image.isPreScaled || image.preScale?.scaled;\n            }\n            if (thumbnail) {\n                canvas.height = 256;\n                canvas.width = 256;\n            }\n            if (imageAspect && image) {\n                canvas.width = image && (canvas.height * image.width) / image.height;\n            }\n            canvas.style.width = `${canvas.width / devicePixelRatio}px`;\n            canvas.style.height = `${canvas.height / devicePixelRatio}px`;\n            if (volume && useCPURendering) {\n                reject(new Error('CPU rendering of volume not supported'));\n            }\n            renderFn(canvas, imageOrVolume, modality, renderingEngineId, viewportOptions).then(resolve);\n        }\n        function errorCallback(error, imageId) {\n            console.error(error, imageId);\n            reject(error);\n        }\n        function sendRequest(imageId, imageIdIndex, options) {\n            return loadAndCacheImage(imageId, options).then((image) => {\n                successCallback.call(this, image, imageId);\n            }, (error) => {\n                errorCallback.call(this, error, imageId);\n            });\n        }\n        const options = {\n            useRGBA: !!useCPURendering,\n            requestType,\n        };\n        if (volumeId) {\n            const volume = cache.getVolume(volumeId);\n            if (!volume) {\n                reject(new Error(`Volume id ${volumeId} not found in cache`));\n            }\n            const useImageId = volume.imageIds[0];\n            successCallback(volume, useImageId);\n        }\n        else {\n            imageLoadPoolManager.addRequest(sendRequest.bind(null, imageId, null, options), requestType, { imageId }, priority);\n        }\n    });\n}\n","export function asArray(item) {\n    if (Array.isArray(item)) {\n        return item;\n    }\n    return [item];\n}\n","import eventTarget from '../../eventTarget';\nimport { asArray } from '../asArray';\nconst Events = {\n    HISTORY_UNDO: 'CORNERSTONE_TOOLS_HISTORY_UNDO',\n    HISTORY_REDO: 'CORNERSTONE_TOOLS_HISTORY_REDO',\n};\nexport class HistoryMemo {\n    constructor(label = 'Tools', size = 50) {\n        this.position = -1;\n        this.redoAvailable = 0;\n        this.undoAvailable = 0;\n        this.ring = new Array();\n        this.isRecordingGrouped = false;\n        this.label = label;\n        this._size = size;\n    }\n    get size() {\n        return this._size;\n    }\n    set size(newSize) {\n        this.ring = new Array(newSize);\n        this._size = newSize;\n        this.position = -1;\n        this.redoAvailable = 0;\n        this.undoAvailable = 0;\n    }\n    get canUndo() {\n        return this.undoAvailable > 0;\n    }\n    get canRedo() {\n        return this.redoAvailable > 0;\n    }\n    undo(items = 1) {\n        while (items > 0 && this.undoAvailable > 0) {\n            const item = this.ring[this.position];\n            for (const subitem of asArray(item).reverse()) {\n                subitem.restoreMemo(true);\n                this.dispatchHistoryEvent({ item: subitem, isUndo: true });\n            }\n            items--;\n            this.redoAvailable++;\n            this.undoAvailable--;\n            this.position = (this.position - 1 + this.size) % this.size;\n        }\n    }\n    undoIf(condition) {\n        if (this.undoAvailable > 0 && condition(this.ring[this.position])) {\n            this.undo();\n            return true;\n        }\n        return false;\n    }\n    dispatchHistoryEvent({ item, isUndo }) {\n        if (item.id) {\n            eventTarget.dispatchEvent(new CustomEvent(isUndo ? Events.HISTORY_UNDO : Events.HISTORY_REDO, {\n                detail: {\n                    isUndo,\n                    id: item.id,\n                    operationType: item.operationType || 'annotation',\n                    memo: item,\n                },\n            }));\n        }\n    }\n    redo(items = 1) {\n        while (items > 0 && this.redoAvailable > 0) {\n            const newPosition = (this.position + 1) % this.size;\n            const item = this.ring[newPosition];\n            for (const subitem of asArray(item).reverse()) {\n                subitem.restoreMemo(false);\n                this.dispatchHistoryEvent({ item: subitem, isUndo: false });\n            }\n            items--;\n            this.position = newPosition;\n            this.undoAvailable++;\n            this.redoAvailable--;\n        }\n    }\n    initializeGroupItem() {\n        this.redoAvailable = 0;\n        if (this.undoAvailable < this._size) {\n            this.undoAvailable++;\n        }\n        this.position = (this.position + 1) % this._size;\n        this.ring[this.position] = [];\n    }\n    startGroupRecording() {\n        this.isRecordingGrouped = true;\n        this.initializeGroupItem();\n    }\n    rollbackUnusedGroupItem() {\n        this.ring[this.position] = undefined;\n        this.position = (this.position - 1) % this._size;\n        this.undoAvailable--;\n    }\n    endGroupRecording() {\n        this.isRecordingGrouped = false;\n        const lastItem = this.ring[this.position];\n        const lastItemIsEmpty = Array.isArray(lastItem) && lastItem.length === 0;\n        if (lastItemIsEmpty) {\n            this.rollbackUnusedGroupItem();\n        }\n    }\n    pushGrouped(memo) {\n        const lastMemo = this.ring[this.position];\n        if (Array.isArray(lastMemo)) {\n            lastMemo.push(memo);\n            return memo;\n        }\n        throw new Error('Last item should be an array for grouped memos.');\n    }\n    push(item) {\n        if (!item) {\n            return;\n        }\n        const memo = item.restoreMemo\n            ? item\n            : item.createMemo?.();\n        if (!memo) {\n            return;\n        }\n        if (this.isRecordingGrouped) {\n            return this.pushGrouped(memo);\n        }\n        this.redoAvailable = 0;\n        if (this.undoAvailable < this._size) {\n            this.undoAvailable++;\n        }\n        this.position = (this.position + 1) % this._size;\n        this.ring[this.position] = memo;\n        return memo;\n    }\n}\nconst DefaultHistoryMemo = new HistoryMemo();\nexport { DefaultHistoryMemo };\n","import { vec3 } from 'gl-matrix';\nimport { get } from '../metaData';\nfunction worldToImageCoords(imageId, worldCoords) {\n    const imagePlaneModule = get('imagePlaneModule', imageId);\n    if (!imagePlaneModule) {\n        throw new Error(`No imagePlaneModule found for imageId: ${imageId}`);\n    }\n    const { columnCosines, rowCosines, imagePositionPatient: origin, } = imagePlaneModule;\n    let { columnPixelSpacing, rowPixelSpacing } = imagePlaneModule;\n    columnPixelSpacing ||= 1;\n    rowPixelSpacing ||= 1;\n    const newOrigin = vec3.create();\n    vec3.scaleAndAdd(newOrigin, origin, columnCosines, -columnPixelSpacing / 2);\n    vec3.scaleAndAdd(newOrigin, newOrigin, rowCosines, -rowPixelSpacing / 2);\n    const sub = vec3.create();\n    vec3.sub(sub, worldCoords, newOrigin);\n    const rowDistance = vec3.dot(sub, rowCosines);\n    const columnDistance = vec3.dot(sub, columnCosines);\n    const imageCoords = [\n        rowDistance / rowPixelSpacing,\n        columnDistance / columnPixelSpacing,\n    ];\n    return imageCoords;\n}\nexport default worldToImageCoords;\n","import { vec3 } from 'gl-matrix';\nimport { get } from '../metaData';\nexport default function imageToWorldCoords(imageId, imageCoords) {\n    const imagePlaneModule = get('imagePlaneModule', imageId);\n    if (!imagePlaneModule) {\n        throw new Error(`No imagePlaneModule found for imageId: ${imageId}`);\n    }\n    const { columnCosines, rowCosines, imagePositionPatient: origin, } = imagePlaneModule;\n    let { columnPixelSpacing, rowPixelSpacing } = imagePlaneModule;\n    columnPixelSpacing ||= 1;\n    rowPixelSpacing ||= 1;\n    const imageCoordsInWorld = vec3.create();\n    vec3.scaleAndAdd(imageCoordsInWorld, origin, rowCosines, rowPixelSpacing * (imageCoords[0] - 0.5));\n    vec3.scaleAndAdd(imageCoordsInWorld, imageCoordsInWorld, columnCosines, columnPixelSpacing * (imageCoords[1] - 0.5));\n    return Array.from(imageCoordsInWorld);\n}\n","import { getRenderingEngines } from '../RenderingEngine/getRenderingEngine';\nexport default function getViewportsWithImageURI(imageURI) {\n    const renderingEngines = getRenderingEngines();\n    const viewports = [];\n    renderingEngines.forEach((renderingEngine) => {\n        const viewportsForRenderingEngine = renderingEngine.getViewports();\n        viewportsForRenderingEngine.forEach((viewport) => {\n            if (viewport.hasImageURI(imageURI)) {\n                viewports.push(viewport);\n            }\n        });\n    });\n    return viewports;\n}\n","import { vec3 } from 'gl-matrix';\nimport * as planar from './planar';\nimport * as metaData from '../metaData';\nexport default function getClosestStackImageIndexForPoint(point, viewport) {\n    const minimalDistance = calculateMinimalDistanceForStackViewport(point, viewport);\n    return minimalDistance ? minimalDistance.index : null;\n}\nexport function calculateMinimalDistanceForStackViewport(point, viewport) {\n    const imageIds = viewport.getImageIds();\n    const currentImageIdIndex = viewport.getCurrentImageIdIndex();\n    if (imageIds.length === 0) {\n        return null;\n    }\n    const getDistance = (imageId) => {\n        const planeMetadata = getPlaneMetadata(imageId);\n        if (!planeMetadata) {\n            return null;\n        }\n        const plane = planar.planeEquation(planeMetadata.planeNormal, planeMetadata.imagePositionPatient);\n        const distance = planar.planeDistanceToPoint(plane, point);\n        return distance;\n    };\n    const closestStack = {\n        distance: getDistance(imageIds[currentImageIdIndex]) ?? Infinity,\n        index: currentImageIdIndex,\n    };\n    const higherImageIds = imageIds.slice(currentImageIdIndex + 1);\n    for (let i = 0; i < higherImageIds.length; i++) {\n        const id = higherImageIds[i];\n        const distance = getDistance(id);\n        if (distance === null) {\n            continue;\n        }\n        if (distance <= closestStack.distance) {\n            closestStack.distance = distance;\n            closestStack.index = i + currentImageIdIndex + 1;\n        }\n        else {\n            break;\n        }\n    }\n    const lowerImageIds = imageIds.slice(0, currentImageIdIndex);\n    for (let i = lowerImageIds.length - 1; i >= 0; i--) {\n        const id = lowerImageIds[i];\n        const distance = getDistance(id);\n        if (distance === null || distance === closestStack.distance) {\n            continue;\n        }\n        if (distance < closestStack.distance) {\n            closestStack.distance = distance;\n            closestStack.index = i;\n        }\n        else {\n            break;\n        }\n    }\n    return closestStack.distance === Infinity ? null : closestStack;\n}\nfunction getPlaneMetadata(imageId) {\n    const targetImagePlane = metaData.get('imagePlaneModule', imageId);\n    if (!targetImagePlane ||\n        !(targetImagePlane.rowCosines instanceof Array &&\n            targetImagePlane.rowCosines.length === 3) ||\n        !(targetImagePlane.columnCosines instanceof Array &&\n            targetImagePlane.columnCosines.length === 3) ||\n        !(targetImagePlane.imagePositionPatient instanceof Array &&\n            targetImagePlane.imagePositionPatient.length === 3)) {\n        return null;\n    }\n    const { rowCosines, columnCosines, imagePositionPatient, } = targetImagePlane;\n    const rowVec = vec3.set(vec3.create(), ...rowCosines);\n    const colVec = vec3.set(vec3.create(), ...columnCosines);\n    const planeNormal = vec3.cross(vec3.create(), rowVec, colVec);\n    return { rowCosines, columnCosines, imagePositionPatient, planeNormal };\n}\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport { transformCanvasToIJK } from './transformCanvasToIJK';\nfunction getCurrentVolumeViewportSlice(viewport) {\n    const { width: canvasWidth, height: canvasHeight } = viewport.getCanvas();\n    const { sliceToIndexMatrix, indexToSliceMatrix } = viewport.getSliceViewInfo();\n    const ijkOriginPoint = transformCanvasToIJK(viewport, [0, 0]);\n    const ijkRowPoint = transformCanvasToIJK(viewport, [canvasWidth - 1, 0]);\n    const ijkColPoint = transformCanvasToIJK(viewport, [0, canvasHeight - 1]);\n    const ijkRowVec = vec3.sub(vec3.create(), ijkRowPoint, ijkOriginPoint);\n    const ijkColVec = vec3.sub(vec3.create(), ijkColPoint, ijkOriginPoint);\n    const ijkSliceVec = vec3.cross(vec3.create(), ijkRowVec, ijkColVec);\n    vec3.normalize(ijkRowVec, ijkRowVec);\n    vec3.normalize(ijkColVec, ijkColVec);\n    vec3.normalize(ijkSliceVec, ijkSliceVec);\n    const maxIJKRowVec = Math.max(Math.abs(ijkRowVec[0]), Math.abs(ijkRowVec[1]), Math.abs(ijkRowVec[2]));\n    const maxIJKColVec = Math.max(Math.abs(ijkColVec[0]), Math.abs(ijkColVec[1]), Math.abs(ijkColVec[2]));\n    if (!glMatrix.equals(1, maxIJKRowVec) || !glMatrix.equals(1, maxIJKColVec)) {\n        throw new Error('Livewire is not available for rotate/oblique viewports');\n    }\n    const { voxelManager } = viewport.getImageData();\n    const sliceViewInfo = viewport.getSliceViewInfo();\n    const scalarData = voxelManager.getSliceData(sliceViewInfo);\n    return {\n        width: sliceViewInfo.width,\n        height: sliceViewInfo.height,\n        scalarData,\n        sliceToIndexMatrix,\n        indexToSliceMatrix,\n    };\n}\nexport { getCurrentVolumeViewportSlice as default, getCurrentVolumeViewportSlice, };\n","import { mat4 } from 'gl-matrix';\nimport { addProvider } from '../metaData';\nconst state = {};\nconst spatialRegistrationMetadataProvider = {\n    add: (query, payload) => {\n        const [viewportId1, viewportId2] = query;\n        const entryId = `${viewportId1}_${viewportId2}`;\n        if (!state[entryId]) {\n            state[entryId] = {};\n        }\n        state[entryId] = payload;\n    },\n    get: (type, viewportId1, viewportId2) => {\n        if (type !== 'spatialRegistrationModule') {\n            return;\n        }\n        const entryId = `${viewportId1}_${viewportId2}`;\n        if (state[entryId]) {\n            return state[entryId];\n        }\n        const entryIdReverse = `${viewportId2}_${viewportId1}`;\n        if (state[entryIdReverse]) {\n            return mat4.invert(mat4.create(), state[entryIdReverse]);\n        }\n    },\n};\naddProvider(spatialRegistrationMetadataProvider.get.bind(spatialRegistrationMetadataProvider));\nexport default spatialRegistrationMetadataProvider;\n","import { vec3, mat4 } from 'gl-matrix';\nimport spatialRegistrationMetadataProvider from './spatialRegistrationMetadataProvider';\nimport { get } from '../metaData';\nconst ALLOWED_DELTA = 0.05;\nfunction calculateViewportsSpatialRegistration(viewport1, viewport2) {\n    const imageId1 = viewport1.getSliceIndex();\n    const imageId2 = viewport2.getSliceIndex();\n    const imagePlaneModule1 = get('imagePlaneModule', imageId1.toString());\n    const imagePlaneModule2 = get('imagePlaneModule', imageId2.toString());\n    if (!imagePlaneModule1 || !imagePlaneModule2) {\n        console.log('Viewport spatial registration requires image plane module');\n        return;\n    }\n    const { imageOrientationPatient: iop2 } = imagePlaneModule2;\n    const isSameImagePlane = imagePlaneModule1.imageOrientationPatient.every((v, i) => Math.abs(v - iop2[i]) < ALLOWED_DELTA);\n    if (!isSameImagePlane) {\n        console.log('Viewport spatial registration only supported for same orientation (hence translation only) for now', imagePlaneModule1?.imageOrientationPatient, imagePlaneModule2?.imageOrientationPatient);\n        return;\n    }\n    const imagePositionPatient1 = imagePlaneModule1.imagePositionPatient;\n    const imagePositionPatient2 = imagePlaneModule2.imagePositionPatient;\n    const translation = vec3.subtract(vec3.create(), imagePositionPatient1, imagePositionPatient2);\n    const mat = mat4.fromTranslation(mat4.create(), translation);\n    spatialRegistrationMetadataProvider.add([viewport1.id, viewport2.id], mat);\n}\nexport default calculateViewportsSpatialRegistration;\n","export default function getViewportImageCornersInWorld(viewport) {\n    const { imageData, dimensions } = viewport.getImageData() || {};\n    if (!imageData || !dimensions) {\n        return [];\n    }\n    const { canvas } = viewport;\n    const ratio = window.devicePixelRatio;\n    const topLeftCanvas = [0, 0];\n    const topRightCanvas = [canvas.width / ratio, 0];\n    const bottomRightCanvas = [\n        canvas.width / ratio,\n        canvas.height / ratio,\n    ];\n    const bottomLeftCanvas = [0, canvas.height / ratio];\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const topRightWorld = viewport.canvasToWorld(topRightCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const bottomLeftWorld = viewport.canvasToWorld(bottomLeftCanvas);\n    const topLeftImage = imageData.worldToIndex(topLeftWorld);\n    const topRightImage = imageData.worldToIndex(topRightWorld);\n    const bottomRightImage = imageData.worldToIndex(bottomRightWorld);\n    const bottomLeftImage = imageData.worldToIndex(bottomLeftWorld);\n    return _getStackViewportImageCorners({\n        dimensions,\n        imageData,\n        topLeftImage,\n        topRightImage,\n        bottomRightImage,\n        bottomLeftImage,\n        topLeftWorld,\n        topRightWorld,\n        bottomRightWorld,\n        bottomLeftWorld,\n    });\n}\nfunction _getStackViewportImageCorners({ dimensions, imageData, topLeftImage, topRightImage, bottomRightImage, bottomLeftImage, topLeftWorld, topRightWorld, bottomRightWorld, bottomLeftWorld, }) {\n    const topLeftImageWorld = _isInBounds(topLeftImage, dimensions)\n        ? topLeftWorld\n        : imageData.indexToWorld([0, 0, 0]);\n    const topRightImageWorld = _isInBounds(topRightImage, dimensions)\n        ? topRightWorld\n        : imageData.indexToWorld([dimensions[0] - 1, 0, 0]);\n    const bottomRightImageWorld = _isInBounds(bottomRightImage, dimensions)\n        ? bottomRightWorld\n        : imageData.indexToWorld([\n            dimensions[0] - 1,\n            dimensions[1] - 1,\n            0,\n        ]);\n    const bottomLeftImageWorld = _isInBounds(bottomLeftImage, dimensions)\n        ? bottomLeftWorld\n        : imageData.indexToWorld([0, dimensions[1] - 1, 0]);\n    return [\n        topLeftImageWorld,\n        topRightImageWorld,\n        bottomLeftImageWorld,\n        bottomRightImageWorld,\n    ];\n}\nfunction _isInBounds(imageCoord, dimensions) {\n    return (imageCoord[0] > 0 ||\n        imageCoord[0] < dimensions[0] - 1 ||\n        imageCoord[1] > 0 ||\n        imageCoord[1] < dimensions[1] - 1 ||\n        imageCoord[2] > 0 ||\n        imageCoord[2] < dimensions[2] - 1);\n}\n","import StackViewport from '../RenderingEngine/StackViewport';\nimport getEnabledElement from '../getEnabledElement';\nfunction getImageLegacy(element) {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    if (!(viewport instanceof StackViewport)) {\n        throw new Error(`An image can only be fetched for a stack viewport and not for a viewport of type: ${viewport.type}`);\n    }\n    return viewport.getCornerstoneImage();\n}\nexport default getImageLegacy;\n","import * as metaData from '../metaData';\nimport isEqual from './isEqual';\nfunction isValidVolume(imageIds) {\n    if (imageIds.length <= 1) {\n        return false;\n    }\n    const imageId0 = imageIds[0];\n    const { modality, seriesInstanceUID } = metaData.get('generalSeriesModule', imageId0);\n    const { imageOrientationPatient, pixelSpacing, frameOfReferenceUID, columns, rows, usingDefaultValues, } = metaData.get('imagePlaneModule', imageId0);\n    if (usingDefaultValues) {\n        return false;\n    }\n    const baseMetadata = {\n        modality,\n        imageOrientationPatient,\n        pixelSpacing,\n        frameOfReferenceUID,\n        columns,\n        rows,\n        seriesInstanceUID,\n    };\n    let validVolume = true;\n    for (let i = 0; i < imageIds.length; i++) {\n        const imageId = imageIds[i];\n        const { modality, seriesInstanceUID } = metaData.get('generalSeriesModule', imageId);\n        const { imageOrientationPatient, pixelSpacing, columns, rows } = metaData.get('imagePlaneModule', imageId);\n        if (seriesInstanceUID !== baseMetadata.seriesInstanceUID) {\n            validVolume = false;\n            break;\n        }\n        if (modality !== baseMetadata.modality) {\n            validVolume = false;\n            break;\n        }\n        if (columns !== baseMetadata.columns) {\n            validVolume = false;\n            break;\n        }\n        if (rows !== baseMetadata.rows) {\n            validVolume = false;\n            break;\n        }\n        if (!isEqual(imageOrientationPatient, baseMetadata.imageOrientationPatient)) {\n            validVolume = false;\n            break;\n        }\n        if (!isEqual(pixelSpacing, baseMetadata.pixelSpacing)) {\n            validVolume = false;\n            break;\n        }\n    }\n    return validVolume;\n}\nexport { isValidVolume };\n","export const videoUIDs = new Set([\n    '1.2.840.10008.1.2.4.100',\n    '1.2.840.10008.1.2.4.100.1',\n    '1.2.840.10008.1.2.4.101',\n    '1.2.840.10008.1.2.4.101.1',\n    '1.2.840.10008.1.2.4.102',\n    '1.2.840.10008.1.2.4.102.1',\n    '1.2.840.10008.1.2.4.103',\n    '1.2.840.10008.1.2.4.103.1',\n    '1.2.840.10008.1.2.4.104',\n    '1.2.840.10008.1.2.4.104.1',\n    '1.2.840.10008.1.2.4.105',\n    '1.2.840.10008.1.2.4.105.1',\n    '1.2.840.10008.1.2.4.106',\n    '1.2.840.10008.1.2.4.106.1',\n    '1.2.840.10008.1.2.4.107',\n    '1.2.840.10008.1.2.4.108',\n]);\nexport default function isVideoTransferSyntax(uidOrUids) {\n    if (!uidOrUids) {\n        return false;\n    }\n    const uids = Array.isArray(uidOrUids) ? uidOrUids : [uidOrUids];\n    return uids.find((uid) => videoUIDs.has(uid));\n}\n","import { setVolumesForViewports } from '../RenderingEngine/helpers';\nimport { createAndCacheVolume, getUnknownVolumeLoaderSchema, } from '../loaders/volumeLoader';\nimport { Events, ViewportType } from '../enums';\nimport uuidv4 from './uuidv4';\nasync function convertStackToVolumeViewport({ viewport, options = {}, }) {\n    const renderingEngine = viewport.getRenderingEngine();\n    let volumeId = options.volumeId || `${uuidv4()}`;\n    if (volumeId.split(':').length === 0) {\n        const schema = getUnknownVolumeLoaderSchema();\n        volumeId = `${schema}:${volumeId}`;\n    }\n    const { id, element } = viewport;\n    const viewportId = options.viewportId || id;\n    const imageIds = viewport.getImageIds();\n    const prevViewPresentation = viewport.getViewPresentation();\n    const prevViewReference = viewport.getViewReference();\n    renderingEngine.enableElement({\n        viewportId,\n        type: ViewportType.ORTHOGRAPHIC,\n        element,\n        defaultOptions: {\n            background: options.background,\n            orientation: options.orientation,\n        },\n    });\n    const volume = (await createAndCacheVolume(volumeId, {\n        imageIds,\n    }));\n    volume.load();\n    const volumeViewport = renderingEngine.getViewport(viewportId);\n    await setVolumesForViewports(renderingEngine, [\n        {\n            volumeId,\n        },\n    ], [viewportId]);\n    const volumeViewportNewVolumeHandler = () => {\n        volumeViewport.render();\n        element.removeEventListener(Events.VOLUME_VIEWPORT_NEW_VOLUME, volumeViewportNewVolumeHandler);\n    };\n    const addVolumeViewportNewVolumeListener = () => {\n        element.addEventListener(Events.VOLUME_VIEWPORT_NEW_VOLUME, volumeViewportNewVolumeHandler);\n    };\n    addVolumeViewportNewVolumeListener();\n    volumeViewport.setViewPresentation(prevViewPresentation);\n    volumeViewport.setViewReference(prevViewReference);\n    volumeViewport.render();\n    return volumeViewport;\n}\nexport { convertStackToVolumeViewport };\n","import cache from '../cache/cache';\nimport { ImageVolume } from '../cache/classes/ImageVolume';\nimport { ViewportType } from '../enums';\nasync function convertVolumeToStackViewport({ viewport, options, }) {\n    const volumeViewport = viewport;\n    const { id, element } = volumeViewport;\n    const renderingEngine = viewport.getRenderingEngine();\n    const { background } = options;\n    const viewportId = options.viewportId || id;\n    const volume = cache.getVolume(volumeViewport.getVolumeId());\n    if (!(volume instanceof ImageVolume)) {\n        throw new Error('Currently, you cannot decache a volume that is not an ImageVolume. So, unfortunately, volumes such as nifti  (which are basic Volume, without imageIds) cannot be decached.');\n    }\n    const viewportInput = {\n        viewportId,\n        type: ViewportType.STACK,\n        element,\n        defaultOptions: {\n            background,\n        },\n    };\n    const prevView = volumeViewport.getViewReference();\n    renderingEngine.enableElement(viewportInput);\n    const stackViewport = renderingEngine.getViewport(viewportId);\n    await stackViewport.setStack(volume.imageIds);\n    stackViewport.setViewReference(prevView);\n    stackViewport.render();\n    return stackViewport;\n}\nexport { convertVolumeToStackViewport };\n","import { EPSILON } from '../constants';\nfunction roundNumber(value, precision = 2) {\n    if (Array.isArray(value)) {\n        return value.map((v) => roundNumber(v, precision)).join(', ');\n    }\n    if (value === undefined || value === null || value === '') {\n        return 'NaN';\n    }\n    value = Number(value);\n    const absValue = Math.abs(value);\n    if (absValue < 0.0001) {\n        return `${value}`;\n    }\n    const fixedPrecision = absValue >= 100\n        ? precision - 2\n        : absValue >= 10\n            ? precision - 1\n            : absValue >= 1\n                ? precision\n                : absValue >= 0.1\n                    ? precision + 1\n                    : absValue >= 0.01\n                        ? precision + 2\n                        : absValue >= 0.001\n                            ? precision + 3\n                            : precision + 4;\n    return value.toFixed(fixedPrecision);\n}\nfunction roundToPrecision(value) {\n    return Math.round(value / EPSILON) * EPSILON;\n}\nexport { roundToPrecision };\nexport default roundNumber;\n","export default function convertToGrayscale(scalarData, width, height) {\n    const isRGBA = scalarData.length === width * height * 4;\n    const isRGB = scalarData.length === width * height * 3;\n    if (isRGBA || isRGB) {\n        const newScalarData = new Float32Array(width * height);\n        let offset = 0;\n        let destOffset = 0;\n        const increment = isRGBA ? 4 : 3;\n        for (let x = 0; x < width; x++) {\n            for (let y = 0; y < height; y++) {\n                const r = scalarData[offset];\n                const g = scalarData[offset + 1];\n                const b = scalarData[offset + 2];\n                newScalarData[destOffset] = (r + g + b) / 3;\n                offset += increment;\n                destOffset++;\n            }\n        }\n        return newScalarData;\n    }\n    else {\n        return scalarData;\n    }\n}\n","import { VolumeViewport } from '../RenderingEngine';\nimport cache from '../cache/cache';\nfunction getViewportImageIds(viewport) {\n    if (viewport instanceof VolumeViewport) {\n        const volume = cache.getVolume(viewport.getVolumeId());\n        return volume.imageIds;\n    }\n    else if (viewport.getImageIds) {\n        return viewport.getImageIds();\n    }\n}\nexport default getViewportImageIds;\n","export function getRandomSampleFromArray(array, size) {\n    const clonedArray = [...array];\n    if (size >= clonedArray.length) {\n        shuffleArray(clonedArray);\n        return clonedArray;\n    }\n    shuffleArray(clonedArray);\n    return clonedArray.slice(0, size);\n}\nfunction shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n}\n","function componentToHex(c) {\n    const hex = c.toString(16);\n    return hex.length == 1 ? '0' + hex : hex;\n}\nfunction rgbToHex(r, g, b) {\n    return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);\n}\nfunction hexToRgb(hex) {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result\n        ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16),\n        }\n        : null;\n}\nexport { hexToRgb, rgbToHex };\n","export function deepEqual(obj1, obj2) {\n    if (obj1 === obj2) {\n        return true;\n    }\n    if (obj1 == null || obj2 == null) {\n        return false;\n    }\n    try {\n        return JSON.stringify(obj1) === JSON.stringify(obj2);\n    }\n    catch (error) {\n        console.debug('Error in JSON.stringify during deep comparison:', error);\n        return obj1 === obj2;\n    }\n}\n","import * as metaData from '../metaData';\nconst groupBy = (array, key) => {\n    return array.reduce((rv, x) => {\n        (rv[x[key]] = rv[x[key]] || []).push(x);\n        return rv;\n    }, {});\n};\nfunction getIPPGroups(imageIds) {\n    const ippMetadata = imageIds.map((imageId) => {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId) || {};\n        return { imageId, imagePositionPatient };\n    });\n    if (!ippMetadata.every((item) => item.imagePositionPatient)) {\n        return null;\n    }\n    const positionGroups = groupBy(ippMetadata, 'imagePositionPatient');\n    const positions = Object.keys(positionGroups);\n    const frame_count = positionGroups[positions[0]].length;\n    if (frame_count === 1) {\n        return null;\n    }\n    const frame_count_equal = positions.every((k) => positionGroups[k].length === frame_count);\n    if (!frame_count_equal) {\n        return null;\n    }\n    return positionGroups;\n}\nfunction test4DTag(IPPGroups, value_getter) {\n    const frame_groups = {};\n    let first_frame_value_set = [];\n    const positions = Object.keys(IPPGroups);\n    for (let i = 0; i < positions.length; i++) {\n        const frame_value_set = new Set();\n        const frames = IPPGroups[positions[i]];\n        for (let j = 0; j < frames.length; j++) {\n            const frame_value = value_getter(frames[j].imageId) || 0;\n            frame_groups[frame_value] = frame_groups[frame_value] || [];\n            frame_groups[frame_value].push({ imageId: frames[j].imageId });\n            frame_value_set.add(frame_value);\n            if (frame_value_set.size - 1 < j) {\n                return undefined;\n            }\n        }\n        if (i == 0) {\n            first_frame_value_set = Array.from(frame_value_set);\n        }\n        else if (!setEquals(first_frame_value_set, frame_value_set)) {\n            return undefined;\n        }\n    }\n    return frame_groups;\n}\nfunction getTagValue(imageId, tag) {\n    const value = metaData.get(tag, imageId);\n    try {\n        return parseFloat(value);\n    }\n    catch {\n        return undefined;\n    }\n}\nfunction getPhilipsPrivateBValue(imageId) {\n    const value = metaData.get('20011003', imageId);\n    try {\n        const { InlineBinary } = value;\n        if (InlineBinary) {\n            const value_bytes = atob(InlineBinary);\n            const ary_buf = new ArrayBuffer(value_bytes.length);\n            const dv = new DataView(ary_buf);\n            for (let i = 0; i < value_bytes.length; i++) {\n                dv.setUint8(i, value_bytes.charCodeAt(i));\n            }\n            return new Float32Array(ary_buf)[0];\n        }\n        return parseFloat(value);\n    }\n    catch {\n        return undefined;\n    }\n}\nfunction getSiemensPrivateBValue(imageId) {\n    let value = metaData.get('0019100c', imageId) || metaData.get('0019100C', imageId);\n    try {\n        const { InlineBinary } = value;\n        if (InlineBinary) {\n            value = atob(InlineBinary);\n        }\n        return parseFloat(value);\n    }\n    catch {\n        return undefined;\n    }\n}\nfunction getGEPrivateBValue(imageId) {\n    let value = metaData.get('00431039', imageId);\n    try {\n        const { InlineBinary } = value;\n        if (InlineBinary) {\n            value = atob(InlineBinary).split('//');\n        }\n        return parseFloat(value[0]) % 100000;\n    }\n    catch {\n        return undefined;\n    }\n}\nfunction setEquals(set_a, set_b) {\n    if (set_a.length != set_b.size) {\n        return false;\n    }\n    for (let i = 0; i < set_a.length; i++) {\n        if (!set_b.has(set_a[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getPetFrameReferenceTime(imageId) {\n    const moduleInfo = metaData.get('petImageModule', imageId);\n    return moduleInfo ? moduleInfo['frameReferenceTime'] : 0;\n}\nfunction splitImageIdsBy4DTags(imageIds) {\n    const positionGroups = getIPPGroups(imageIds);\n    if (!positionGroups) {\n        return { imageIdGroups: [imageIds], splittingTag: null };\n    }\n    const tags = [\n        'TemporalPositionIdentifier',\n        'DiffusionBValue',\n        'TriggerTime',\n        'EchoTime',\n        'EchoNumber',\n        'PhilipsPrivateBValue',\n        'SiemensPrivateBValue',\n        'GEPrivateBValue',\n        'PetFrameReferenceTime',\n    ];\n    const fncList2 = [\n        (imageId) => getTagValue(imageId, tags[0]),\n        (imageId) => getTagValue(imageId, tags[1]),\n        (imageId) => getTagValue(imageId, tags[2]),\n        (imageId) => getTagValue(imageId, tags[3]),\n        (imageId) => getTagValue(imageId, tags[4]),\n        getPhilipsPrivateBValue,\n        getSiemensPrivateBValue,\n        getGEPrivateBValue,\n        getPetFrameReferenceTime,\n    ];\n    for (let i = 0; i < fncList2.length; i++) {\n        const frame_groups = test4DTag(positionGroups, fncList2[i]);\n        if (frame_groups) {\n            const sortedKeys = Object.keys(frame_groups)\n                .map(Number.parseFloat)\n                .sort((a, b) => a - b);\n            const imageIdGroups = sortedKeys.map((key) => frame_groups[key].map((item) => item.imageId));\n            return { imageIdGroups, splittingTag: tags[i] };\n        }\n    }\n    return { imageIdGroups: [imageIds], splittingTag: null };\n}\nexport default splitImageIdsBy4DTags;\n","import splitImageIdsBy4DTags from './splitImageIdsBy4DTags';\nfunction getDynamicVolumeInfo(imageIds) {\n    const { imageIdGroups: timePoints, splittingTag } = splitImageIdsBy4DTags(imageIds);\n    const isDynamicVolume = timePoints.length > 1;\n    return { isDynamicVolume, timePoints, splittingTag };\n}\nexport default getDynamicVolumeInfo;\n","export default function scaleArray(array, scalingParameters) {\n    const arrayLength = array.length;\n    const { rescaleSlope, rescaleIntercept, suvbw } = scalingParameters;\n    if (scalingParameters.modality === 'PT' && typeof suvbw === 'number') {\n        for (let i = 0; i < arrayLength; i++) {\n            array[i] = suvbw * (array[i] * rescaleSlope + rescaleIntercept);\n        }\n    }\n    else {\n        for (let i = 0; i < arrayLength; i++) {\n            array[i] = array[i] * rescaleSlope + rescaleIntercept;\n        }\n    }\n    return array;\n}\n","export function clip(val, low, high) {\n    return Math.min(Math.max(low, val), high);\n}\nexport function clipToBox(point, box) {\n    point.x = clip(point.x, 0, box.width);\n    point.y = clip(point.y, 0, box.height);\n}\nexport default clip;\n","import { Events } from '../enums';\nimport { StackViewport, VolumeViewport } from '../RenderingEngine';\nimport getVolumeViewportScrollInfo from './getVolumeViewportScrollInfo';\nimport snapFocalPointToSlice from './snapFocalPointToSlice';\nimport getEnabledElement from '../getEnabledElement';\nimport triggerEvent from './triggerEvent';\nimport eventTarget from '../eventTarget';\nexport default function scroll(viewport, options) {\n    const enabledElement = getEnabledElement(viewport.element);\n    if (!enabledElement) {\n        throw new Error('Scroll::Viewport is not enabled (it might be disabled)');\n    }\n    if (viewport instanceof StackViewport &&\n        viewport.getImageIds().length === 0) {\n        throw new Error('Scroll::Stack Viewport has no images');\n    }\n    const { volumeId, delta, scrollSlabs } = options;\n    if (viewport instanceof VolumeViewport) {\n        scrollVolume(viewport, volumeId, delta, scrollSlabs);\n    }\n    else {\n        const imageIdIndex = viewport.getCurrentImageIdIndex();\n        if (imageIdIndex + delta >\n            viewport.getImageIds().length - 1 ||\n            imageIdIndex + delta < 0) {\n            const eventData = {\n                imageIdIndex,\n                direction: delta,\n            };\n            triggerEvent(eventTarget, Events.STACK_SCROLL_OUT_OF_BOUNDS, eventData);\n        }\n        viewport.scroll(delta, options.debounceLoading, options.loop);\n    }\n}\nexport function scrollVolume(viewport, volumeId, delta, scrollSlabs = false) {\n    const useSlabThickness = scrollSlabs;\n    const { numScrollSteps, currentStepIndex, sliceRangeInfo } = getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness);\n    if (!sliceRangeInfo) {\n        return;\n    }\n    const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;\n    const { focalPoint, viewPlaneNormal, position } = camera;\n    const { newFocalPoint, newPosition } = snapFocalPointToSlice(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, delta);\n    viewport.setCamera({\n        focalPoint: newFocalPoint,\n        position: newPosition,\n    });\n    viewport.render();\n    const desiredStepIndex = currentStepIndex + delta;\n    const VolumeScrollEventDetail = {\n        volumeId,\n        viewport,\n        delta,\n        desiredStepIndex,\n        currentStepIndex,\n        numScrollSteps,\n        currentImageId: viewport.getCurrentImageId(),\n    };\n    if ((desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&\n        viewport.getCurrentImageId()) {\n        triggerEvent(eventTarget, Events.VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS, VolumeScrollEventDetail);\n    }\n    else {\n        triggerEvent(eventTarget, Events.VOLUME_VIEWPORT_SCROLL, VolumeScrollEventDetail);\n    }\n}\n","import clip from './clip';\nimport scroll from './scroll';\nimport getEnabledElement from '../getEnabledElement';\nimport StackViewport from '../RenderingEngine/StackViewport';\nasync function jumpToSlice(element, options = {}) {\n    const { imageIndex, debounceLoading, volumeId } = options;\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        throw new Error('Element has been disabled');\n    }\n    const { viewport } = enabledElement;\n    const { imageIndex: currentImageIndex, numberOfSlices } = _getImageSliceData(viewport, debounceLoading);\n    const imageIndexToJump = _getImageIndexToJump(numberOfSlices, imageIndex);\n    const delta = imageIndexToJump - currentImageIndex;\n    scroll(viewport, { delta, debounceLoading, volumeId });\n}\nfunction _getImageSliceData(viewport, debounceLoading) {\n    if (viewport instanceof StackViewport) {\n        return {\n            numberOfSlices: viewport.getImageIds().length,\n            imageIndex: debounceLoading\n                ? viewport.getTargetImageIdIndex()\n                : viewport.getCurrentImageIdIndex(),\n        };\n    }\n    return {\n        numberOfSlices: viewport.getNumberOfSlices(),\n        imageIndex: viewport.getSliceIndex(),\n    };\n}\nfunction _getImageIndexToJump(numberOfSlices, imageIndex) {\n    const lastSliceIndex = numberOfSlices - 1;\n    return clip(imageIndex, 0, lastSliceIndex);\n}\nexport { jumpToSlice };\n","import transformWorldToIndex from './transformWorldToIndex';\nimport transformIndexToWorld from './transformIndexToWorld';\nimport uuidv4 from './uuidv4';\nimport { createLocalVolume } from '../loaders/volumeLoader';\nimport cache from '../cache/cache';\nfunction createSubVolume(referencedVolumeId, boundsIJK, options = {}) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    if (!referencedVolume) {\n        throw new Error(`Referenced volume with id ${referencedVolumeId} does not exist.`);\n    }\n    const { metadata, spacing, direction, dimensions: refVolumeDim, } = referencedVolume;\n    const { minX, maxX, minY, maxY, minZ, maxZ } = boundsIJK;\n    const ijkTopLeft = [\n        Math.min(minX, maxX),\n        Math.min(minY, maxY),\n        Math.min(minZ, maxZ),\n    ];\n    const boundingBoxOriginWorld = transformIndexToWorld(referencedVolume.imageData, ijkTopLeft);\n    const dimensions = [\n        Math.abs(maxX - minX) + 1,\n        Math.abs(maxY - minY) + 1,\n        Math.abs(maxZ - minZ) + 1,\n    ];\n    const { targetBuffer } = options;\n    const subVolumeOptions = {\n        metadata,\n        dimensions,\n        spacing,\n        origin: boundingBoxOriginWorld,\n        direction,\n        targetBuffer,\n        scalarData: targetBuffer?.type === 'Float32Array'\n            ? new Float32Array(dimensions[0] * dimensions[1] * dimensions[2])\n            : undefined,\n    };\n    const subVolume = createLocalVolume(uuidv4(), subVolumeOptions);\n    const subVolumeData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const subVolumeSliceSize = dimensions[0] * dimensions[1];\n    const refVolumeSliceSize = refVolumeDim[0] * refVolumeDim[1];\n    const refVolumeData = referencedVolume.voxelManager.getCompleteScalarDataArray();\n    for (let z = 0; z < dimensions[2]; z++) {\n        for (let y = 0; y < dimensions[1]; y++) {\n            const rowStartWorld = transformIndexToWorld(subVolume.imageData, [\n                0,\n                y,\n                z,\n            ]);\n            const refVolumeRowStartIJK = transformWorldToIndex(referencedVolume.imageData, rowStartWorld);\n            const refVolumeRowStartOffset = refVolumeRowStartIJK[2] * refVolumeSliceSize +\n                refVolumeRowStartIJK[1] * refVolumeDim[0] +\n                refVolumeRowStartIJK[0];\n            const rowData = refVolumeData.slice(refVolumeRowStartOffset, refVolumeRowStartOffset + dimensions[0]);\n            const subVolumeLineStartOffset = z * subVolumeSliceSize + y * dimensions[0];\n            subVolumeData.set(rowData, subVolumeLineStartOffset);\n        }\n    }\n    subVolume.voxelManager.setCompleteScalarDataArray(subVolumeData);\n    return subVolume;\n}\nexport { createSubVolume as default, createSubVolume };\n","import { vec3 } from 'gl-matrix';\nimport { transformWorldToIndexContinuous } from './transformWorldToIndex';\nfunction getVolumeDirectionVectors(imageData, camera) {\n    const { viewUp, viewPlaneNormal } = camera;\n    const ijkOrigin = transformWorldToIndexContinuous(imageData, [0, 0, 0]);\n    const worldVecColDir = vec3.negate(vec3.create(), viewUp);\n    const worldVecSliceDir = vec3.negate(vec3.create(), viewPlaneNormal);\n    const worldVecRowDir = vec3.cross(vec3.create(), worldVecColDir, worldVecSliceDir);\n    const ijkVecColDir = vec3.sub(vec3.create(), transformWorldToIndexContinuous(imageData, worldVecColDir), ijkOrigin);\n    const ijkVecSliceDir = vec3.sub(vec3.create(), transformWorldToIndexContinuous(imageData, worldVecSliceDir), ijkOrigin);\n    vec3.normalize(ijkVecColDir, ijkVecColDir);\n    vec3.normalize(ijkVecSliceDir, ijkVecSliceDir);\n    const ijkVecRowDir = vec3.cross(vec3.create(), ijkVecColDir, ijkVecSliceDir);\n    return {\n        worldVecRowDir,\n        worldVecColDir,\n        worldVecSliceDir,\n        ijkVecRowDir,\n        ijkVecColDir,\n        ijkVecSliceDir,\n    };\n}\nexport { getVolumeDirectionVectors as default, getVolumeDirectionVectors };\n","export function calculateNeighborhoodStats(scalarData, dimensions, centerIjk, radius) {\n    const [width, height, numSlices] = dimensions;\n    const numPixelsPerSlice = width * height;\n    let sum = 0;\n    let sumSq = 0;\n    let count = 0;\n    const [cx, cy, cz] = centerIjk.map(Math.round);\n    for (let z = cz - radius; z <= cz + radius; z++) {\n        if (z < 0 || z >= numSlices) {\n            continue;\n        }\n        for (let y = cy - radius; y <= cy + radius; y++) {\n            if (y < 0 || y >= height) {\n                continue;\n            }\n            for (let x = cx - radius; x <= cx + radius; x++) {\n                if (x < 0 || x >= width) {\n                    continue;\n                }\n                const index = z * numPixelsPerSlice + y * width + x;\n                const value = scalarData[index];\n                sum += value;\n                sumSq += value * value;\n                count++;\n            }\n        }\n    }\n    if (count === 0) {\n        const centerIndex = cz * numPixelsPerSlice + cy * width + cx;\n        if (centerIndex >= 0 && centerIndex < scalarData.length) {\n            const centerValue = scalarData[centerIndex];\n            return { mean: centerValue, stdDev: 0, count: 1 };\n        }\n        else {\n            return { mean: 0, stdDev: 0, count: 0 };\n        }\n    }\n    const mean = sum / count;\n    const variance = sumSq / count - mean * mean;\n    const stdDev = Math.sqrt(Math.max(0, variance));\n    return { mean, stdDev, count };\n}\n","import { isEqual } from './isEqual';\nimport { CalibrationTypes } from '../enums';\nconst projectionRadiographSOPClassUIDs = new Set([\n    '1.2.840.10008.5.1.4.1.1.1',\n    '1.2.840.10008.5.1.4.1.1.1.1',\n    '1.2.840.10008.5.1.4.1.1.1.1.1',\n    '1.2.840.10008.5.1.4.1.1.1.2',\n    '1.2.840.10008.5.1.4.1.1.1.2.1',\n    '1.2.840.10008.5.1.4.1.1.1.3',\n    '1.2.840.10008.5.1.4.1.1.1.3.1',\n    '1.2.840.10008.5.1.4.1.1.12.1',\n    '1.2.840.10008.5.1.4.1.1.12.1.1',\n    '1.2.840.10008.5.1.4.1.1.12.2',\n    '1.2.840.10008.5.1.4.1.1.12.2.1',\n    '1.2.840.10008.5.1.4.1.1.12.3',\n]);\nconst alreadySeenWarn = new Set();\nfunction calculateRadiographicPixelSpacing(instance) {\n    const { PixelSpacing, ImagerPixelSpacing, EstimatedRadiographicMagnificationFactor, PixelSpacingCalibrationType, PixelSpacingCalibrationDescription, } = instance;\n    const isProjection = true;\n    if (!ImagerPixelSpacing) {\n        return {\n            PixelSpacing,\n            type: CalibrationTypes.UNKNOWN,\n            isProjection,\n        };\n    }\n    if (!PixelSpacing) {\n        if (!EstimatedRadiographicMagnificationFactor) {\n            if (!alreadySeenWarn.has(instance.SeriesInstanceUID)) {\n                console.warn('EstimatedRadiographicMagnificationFactor was not present on series', instance.SeriesInstanceUID, ' Unable to correct ImagerPixelSpacing.');\n                alreadySeenWarn.add(instance.SeriesInstanceUID);\n            }\n            return {\n                PixelSpacing: ImagerPixelSpacing,\n                type: CalibrationTypes.PROJECTION,\n                isProjection,\n            };\n        }\n        const correctedPixelSpacing = ImagerPixelSpacing.map((pixelSpacing) => pixelSpacing / EstimatedRadiographicMagnificationFactor);\n        return {\n            PixelSpacing: correctedPixelSpacing,\n            type: CalibrationTypes.ERMF,\n            isProjection,\n        };\n    }\n    if (isEqual(PixelSpacing, ImagerPixelSpacing)) {\n        return {\n            PixelSpacing,\n            type: CalibrationTypes.PROJECTION,\n            isProjection,\n        };\n    }\n    if (PixelSpacingCalibrationType || PixelSpacingCalibrationDescription) {\n        return {\n            PixelSpacing,\n            type: CalibrationTypes.CALIBRATED,\n            isProjection,\n            PixelSpacingCalibrationType,\n            PixelSpacingCalibrationDescription,\n        };\n    }\n    return {\n        PixelSpacing,\n        type: CalibrationTypes.UNKNOWN,\n        isProjection,\n    };\n}\nfunction calculateUSPixelSpacing(instance) {\n    const { SequenceOfUltrasoundRegions } = instance;\n    const isArrayOfSequences = Array.isArray(SequenceOfUltrasoundRegions);\n    if (isArrayOfSequences && SequenceOfUltrasoundRegions.length > 1) {\n        console.warn('Sequence of Ultrasound Regions > one entry. This is not yet implemented, all measurements will be shown in pixels.');\n        return;\n    }\n    const { PhysicalDeltaX, PhysicalDeltaY } = isArrayOfSequences\n        ? SequenceOfUltrasoundRegions[0]\n        : SequenceOfUltrasoundRegions;\n    const USPixelSpacing = [\n        Math.abs(PhysicalDeltaX) * 10,\n        Math.abs(PhysicalDeltaY) * 10,\n    ];\n    return {\n        PixelSpacing: USPixelSpacing,\n    };\n}\nexport default function getPixelSpacingInformation(instance) {\n    const { PixelSpacing, SOPClassUID, SequenceOfUltrasoundRegions } = instance;\n    if (SequenceOfUltrasoundRegions) {\n        return calculateUSPixelSpacing(instance);\n    }\n    const isProjection = projectionRadiographSOPClassUIDs.has(SOPClassUID);\n    if (isProjection) {\n        return calculateRadiographicPixelSpacing(instance);\n    }\n    return {\n        PixelSpacing,\n        type: CalibrationTypes.NOT_APPLICABLE,\n        isProjection: false,\n    };\n}\n","import * as eventListener from './eventListener';\nimport csUtils from './invertRgbTransferFunction';\nimport createSigmoidRGBTransferFunction from './createSigmoidRGBTransferFunction';\nimport getVoiFromSigmoidRGBTransferFunction from './getVoiFromSigmoidRGBTransferFunction';\nimport createLinearRGBTransferFunction from './createLinearRGBTransferFunction';\nimport scaleRgbTransferFunction from './scaleRgbTransferFunction';\nimport triggerEvent from './triggerEvent';\nimport uuidv4 from './uuidv4';\nimport getMinMax from './getMinMax';\nimport getRuntimeId from './getRuntimeId';\nimport imageIdToURI from './imageIdToURI';\nimport calibratedPixelSpacingMetadataProvider from './calibratedPixelSpacingMetadataProvider';\nimport clamp from './clamp';\nimport isOpposite from './isOpposite';\nimport getClosestImageId from './getClosestImageId';\nimport getSpacingInNormalDirection from './getSpacingInNormalDirection';\nimport getTargetVolumeAndSpacingInNormalDir from './getTargetVolumeAndSpacingInNormalDir';\nimport getVolumeActorCorners from './getVolumeActorCorners';\nimport indexWithinDimensions from './indexWithinDimensions';\nimport getVolumeViewportsContainingSameVolumes from './getVolumeViewportsContainingSameVolumes';\nimport getViewportsWithVolumeId from './getViewportsWithVolumeId';\nimport transformWorldToIndex, { transformWorldToIndexContinuous, } from './transformWorldToIndex';\nimport transformIndexToWorld from './transformIndexToWorld';\nimport loadImageToCanvas from './loadImageToCanvas';\nimport * as HistoryMemo from './historyMemo';\nimport renderToCanvasCPU from './renderToCanvasCPU';\nimport renderToCanvasGPU from './renderToCanvasGPU';\nimport worldToImageCoords from './worldToImageCoords';\nimport imageToWorldCoords from './imageToWorldCoords';\nimport getVolumeSliceRangeInfo from './getVolumeSliceRangeInfo';\nimport getVolumeViewportScrollInfo from './getVolumeViewportScrollInfo';\nimport getSliceRange from './getSliceRange';\nimport snapFocalPointToSlice from './snapFocalPointToSlice';\nimport getImageSliceDataForVolumeViewport from './getImageSliceDataForVolumeViewport';\nimport { isImageActor, actorIsA } from './actorCheck';\nimport getViewportsWithImageURI from './getViewportsWithImageURI';\nimport getClosestStackImageIndexForPoint from './getClosestStackImageIndexForPoint';\nimport getCurrentVolumeViewportSlice from './getCurrentVolumeViewportSlice';\nimport calculateViewportsSpatialRegistration from './calculateViewportsSpatialRegistration';\nimport spatialRegistrationMetadataProvider from './spatialRegistrationMetadataProvider';\nimport getViewportImageCornersInWorld from './getViewportImageCornersInWorld';\nimport hasNaNValues from './hasNaNValues';\nimport applyPreset from './applyPreset';\nimport PointsManager from './PointsManager';\nimport deepMerge from './deepMerge';\nimport getScalingParameters from './getScalingParameters';\nimport isPTPrescaledWithSUV from './isPTPrescaledWithSUV';\nimport getImageLegacy from './getImageLegacy';\nimport sortImageIdsAndGetSpacing from './sortImageIdsAndGetSpacing';\nimport makeVolumeMetadata from './makeVolumeMetadata';\nimport genericMetadataProvider from './genericMetadataProvider';\nimport { isValidVolume } from './isValidVolume';\nimport { updateVTKImageDataWithCornerstoneImage } from './updateVTKImageDataWithCornerstoneImage';\nimport ProgressiveIterator from './ProgressiveIterator';\nimport decimate from './decimate';\nimport imageRetrieveMetadataProvider from './imageRetrieveMetadataProvider';\nimport isVideoTransferSyntax from './isVideoTransferSyntax';\nimport { getBufferConfiguration } from './getBufferConfiguration';\nimport { generateVolumePropsFromImageIds } from './generateVolumePropsFromImageIds';\nimport { convertStackToVolumeViewport } from './convertStackToVolumeViewport';\nimport { convertVolumeToStackViewport } from './convertVolumeToStackViewport';\nimport VoxelManager from './VoxelManager';\nimport RLEVoxelMap from './RLEVoxelMap';\nimport roundNumber, { roundToPrecision } from './roundNumber';\nimport convertToGrayscale from './convertToGrayscale';\nimport getViewportImageIds from './getViewportImageIds';\nimport { getRandomSampleFromArray } from './getRandomSampleFromArray';\nimport { getVolumeId } from './getVolumeId';\nimport { hasFloatScalingParameters } from './hasFloatScalingParameters';\nimport { pointInShapeCallback } from './pointInShapeCallback';\nexport * as planar from './planar';\nimport * as windowLevel from './windowLevel';\nimport * as colormap from './colormap';\nimport * as transferFunctionUtils from './transferFunctionUtils';\nimport * as color from './color';\nimport { deepEqual } from './deepEqual';\nimport FrameRange from './FrameRange';\nimport fnv1aHash from './fnv1aHash';\nimport { getImageDataMetadata } from './getImageDataMetadata';\nimport { buildMetadata } from './buildMetadata';\nimport { _getViewportModality } from './getViewportModality';\nimport cache from '../cache/cache';\nimport getDynamicVolumeInfo from './getDynamicVolumeInfo';\nimport autoLoad from './autoLoad';\nimport scaleArray from './scaleArray';\nimport splitImageIdsBy4DTags from './splitImageIdsBy4DTags';\nimport { deepClone } from './deepClone';\nimport { jumpToSlice } from './jumpToSlice';\nimport scroll from './scroll';\nimport clip from './clip';\nimport createSubVolume from './createSubVolume';\nimport getVolumeDirectionVectors from './getVolumeDirectionVectors';\nimport calculateSpacingBetweenImageIds from './calculateSpacingBetweenImageIds';\nexport * as logger from './logger';\nimport { calculateNeighborhoodStats } from './calculateNeighborhoodStats';\nimport getPixelSpacingInformation from './getPixelSpacingInformation';\nimport { asArray } from './asArray';\nexport { updatePlaneRestriction } from './updatePlaneRestriction';\nconst getViewportModality = (viewport, volumeId) => _getViewportModality(viewport, volumeId, cache.getVolume);\nexport * from './isEqual';\nexport { FrameRange, eventListener, csUtils as invertRgbTransferFunction, createSigmoidRGBTransferFunction, getVoiFromSigmoidRGBTransferFunction, createLinearRGBTransferFunction, scaleRgbTransferFunction, triggerEvent, imageIdToURI, fnv1aHash, calibratedPixelSpacingMetadataProvider, clamp, uuidv4, getMinMax, getRuntimeId, isOpposite, getViewportModality, windowLevel, convertToGrayscale, getClosestImageId, getSpacingInNormalDirection, getTargetVolumeAndSpacingInNormalDir, getVolumeActorCorners, indexWithinDimensions, getVolumeViewportsContainingSameVolumes, getViewportsWithVolumeId, transformWorldToIndex, transformIndexToWorld, loadImageToCanvas, renderToCanvasCPU, renderToCanvasGPU, worldToImageCoords, imageToWorldCoords, getVolumeSliceRangeInfo, getVolumeViewportScrollInfo, getSliceRange, snapFocalPointToSlice, getImageSliceDataForVolumeViewport, isImageActor, isPTPrescaledWithSUV, actorIsA, getViewportsWithImageURI, getClosestStackImageIndexForPoint, getCurrentVolumeViewportSlice, calculateViewportsSpatialRegistration, spatialRegistrationMetadataProvider, getViewportImageCornersInWorld, hasNaNValues, applyPreset, deepMerge, PointsManager, getScalingParameters, colormap, getImageLegacy, ProgressiveIterator, decimate, imageRetrieveMetadataProvider, transferFunctionUtils, updateVTKImageDataWithCornerstoneImage, sortImageIdsAndGetSpacing, makeVolumeMetadata, isValidVolume, genericMetadataProvider, isVideoTransferSyntax, HistoryMemo, generateVolumePropsFromImageIds, getBufferConfiguration, VoxelManager, RLEVoxelMap, convertStackToVolumeViewport, convertVolumeToStackViewport, roundNumber, roundToPrecision, getViewportImageIds, getRandomSampleFromArray, getVolumeId, color, hasFloatScalingParameters, getDynamicVolumeInfo, autoLoad, scaleArray, deepClone, splitImageIdsBy4DTags, pointInShapeCallback, deepEqual, jumpToSlice, scroll, clip, transformWorldToIndexContinuous, createSubVolume, getVolumeDirectionVectors, calculateSpacingBetweenImageIds, getImageDataMetadata, buildMetadata, calculateNeighborhoodStats, getPixelSpacingInformation, asArray, };\n","function _getViewportModality(viewport, volumeId, getVolume) {\n    if (!getVolume) {\n        throw new Error('getVolume is required, use the utilities export instead ');\n    }\n    if (viewport.modality) {\n        return viewport.modality;\n    }\n    if (viewport.setVolumes) {\n        volumeId = volumeId ?? viewport.getVolumeId();\n        if (!volumeId || !getVolume) {\n            return;\n        }\n        const volume = getVolume(volumeId);\n        return volume.metadata.Modality;\n    }\n    throw new Error('Invalid viewport type');\n}\nexport { _getViewportModality };\n","export default function invertRgbTransferFunction(rgbTransferFunction) {\n    if (!rgbTransferFunction) {\n        return;\n    }\n    const size = rgbTransferFunction.getSize();\n    for (let index = 0; index < size; index++) {\n        const nodeValue1 = [];\n        rgbTransferFunction.getNodeValue(index, nodeValue1);\n        nodeValue1[1] = 1 - nodeValue1[1];\n        nodeValue1[2] = 1 - nodeValue1[2];\n        nodeValue1[3] = 1 - nodeValue1[3];\n        rgbTransferFunction.setNodeValue(index, nodeValue1);\n    }\n}\n","function areNumbersEqualWithTolerance(num1, num2, tolerance) {\n    return Math.abs(num1 - num2) <= tolerance;\n}\nfunction areArraysEqual(arr1, arr2, tolerance = 1e-5) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for (let i = 0; i < arr1.length; i++) {\n        if (!areNumbersEqualWithTolerance(arr1[i], arr2[i], tolerance)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isNumberType(value) {\n    return typeof value === 'number';\n}\nfunction isNumberArrayLike(value) {\n    return (value &&\n        typeof value === 'object' &&\n        'length' in value &&\n        typeof value.length === 'number' &&\n        value.length > 0 &&\n        typeof value[0] === 'number');\n}\nexport function isEqual(v1, v2, tolerance = 1e-5) {\n    if (typeof v1 !== typeof v2 || v1 === null || v2 === null) {\n        return false;\n    }\n    if (isNumberType(v1) && isNumberType(v2)) {\n        return areNumbersEqualWithTolerance(v1, v2, tolerance);\n    }\n    if (isNumberArrayLike(v1) && isNumberArrayLike(v2)) {\n        return areArraysEqual(v1, v2, tolerance);\n    }\n    return false;\n}\nconst negative = (v) => typeof v === 'number' ? -v : v?.map ? v.map(negative) : !v;\nconst abs = (v) => typeof v === 'number' ? Math.abs(v) : v?.map ? v.map(abs) : v;\nexport const isEqualNegative = (v1, v2, tolerance = undefined) => isEqual(v1, negative(v2), tolerance);\nexport const isEqualAbs = (v1, v2, tolerance = undefined) => isEqual(abs(v1), abs(v2), tolerance);\nexport function isNumber(n) {\n    if (Array.isArray(n)) {\n        return isNumber(n[0]);\n    }\n    return isFinite(n) && !isNaN(n);\n}\nexport default isEqual;\n","import loglevelImport from 'loglevel';\nconst loglevel = loglevelImport.noConflict();\nif (typeof window !== 'undefined') {\n    window.log = loglevel;\n}\nexport function getRootLogger(name) {\n    const logger = loglevel.getLogger(name[0]);\n    logger.getLogger = (...names) => {\n        return getRootLogger(`${name}.${names.join('.')}`);\n    };\n    return logger;\n}\nexport function getLogger(...name) {\n    return getRootLogger(name.join('.'));\n}\nexport const cs3dLog = getRootLogger('cs3d');\nexport const coreLog = cs3dLog.getLogger('core');\nexport const toolsLog = cs3dLog.getLogger('tools');\nexport const loaderLog = cs3dLog.getLogger('dicomImageLoader');\nexport const aiLog = cs3dLog.getLogger('ai');\nexport const examplesLog = cs3dLog.getLogger('examples');\nexport const dicomConsistencyLog = getLogger('consistency', 'dicom');\nexport const imageConsistencyLog = getLogger('consistency', 'image');\n","import { get } from '../metaData';\nexport default function makeVolumeMetadata(imageIds) {\n    const imageId0 = imageIds[0];\n    const { pixelRepresentation, bitsAllocated, bitsStored, highBit, photometricInterpretation, samplesPerPixel, } = get('imagePixelModule', imageId0);\n    const voiLut = [];\n    const voiLutModule = get('voiLutModule', imageId0);\n    let voiLUTFunction;\n    if (voiLutModule) {\n        const { windowWidth, windowCenter } = voiLutModule;\n        voiLUTFunction = voiLutModule?.voiLUTFunction;\n        if (Array.isArray(windowWidth)) {\n            for (let i = 0; i < windowWidth.length; i++) {\n                voiLut.push({\n                    windowWidth: windowWidth[i],\n                    windowCenter: windowCenter[i],\n                });\n            }\n        }\n        else {\n            voiLut.push({\n                windowWidth: windowWidth,\n                windowCenter: windowCenter,\n            });\n        }\n    }\n    else {\n        voiLut.push({\n            windowWidth: undefined,\n            windowCenter: undefined,\n        });\n    }\n    const { modality, seriesInstanceUID } = get('generalSeriesModule', imageId0);\n    const { imageOrientationPatient, pixelSpacing, frameOfReferenceUID, columns, rows, } = get('imagePlaneModule', imageId0);\n    return {\n        BitsAllocated: bitsAllocated,\n        BitsStored: bitsStored,\n        SamplesPerPixel: samplesPerPixel,\n        HighBit: highBit,\n        PhotometricInterpretation: photometricInterpretation,\n        PixelRepresentation: pixelRepresentation,\n        Modality: modality,\n        ImageOrientationPatient: imageOrientationPatient,\n        PixelSpacing: pixelSpacing,\n        FrameOfReferenceUID: frameOfReferenceUID,\n        Columns: columns,\n        Rows: rows,\n        voiLut,\n        VOILUTFunction: voiLUTFunction,\n        SeriesInstanceUID: seriesInstanceUID,\n    };\n}\n","import { mat3 } from 'gl-matrix';\nimport { EPSILON } from '../constants';\nfunction linePlaneIntersection(p0, p1, plane) {\n    const [x0, y0, z0] = p0;\n    const [x1, y1, z1] = p1;\n    const [A, B, C, D] = plane;\n    const a = x1 - x0;\n    const b = y1 - y0;\n    const c = z1 - z0;\n    const t = (-1 * (A * x0 + B * y0 + C * z0 - D)) / (A * a + B * b + C * c);\n    const X = a * t + x0;\n    const Y = b * t + y0;\n    const Z = c * t + z0;\n    return [X, Y, Z];\n}\nfunction planeEquation(normal, point, normalized = false) {\n    const [A, B, C] = normal;\n    const D = A * point[0] + B * point[1] + C * point[2];\n    if (normalized) {\n        const length = Math.sqrt(A * A + B * B + C * C);\n        return [A / length, B / length, C / length, D / length];\n    }\n    return [A, B, C, D];\n}\nfunction threePlaneIntersection(firstPlane, secondPlane, thirdPlane) {\n    const [A1, B1, C1, D1] = firstPlane;\n    const [A2, B2, C2, D2] = secondPlane;\n    const [A3, B3, C3, D3] = thirdPlane;\n    const m0 = mat3.fromValues(A1, A2, A3, B1, B2, B3, C1, C2, C3);\n    const m1 = mat3.fromValues(D1, D2, D3, B1, B2, B3, C1, C2, C3);\n    const m2 = mat3.fromValues(A1, A2, A3, D1, D2, D3, C1, C2, C3);\n    const m3 = mat3.fromValues(A1, A2, A3, B1, B2, B3, D1, D2, D3);\n    const x = mat3.determinant(m1) / mat3.determinant(m0);\n    const y = mat3.determinant(m2) / mat3.determinant(m0);\n    const z = mat3.determinant(m3) / mat3.determinant(m0);\n    return [x, y, z];\n}\nfunction planeDistanceToPoint(plane, point, signed = false) {\n    const [A, B, C, D] = plane;\n    const [x, y, z] = point;\n    const numerator = A * x + B * y + C * z - D;\n    const distance = Math.abs(numerator) / Math.sqrt(A * A + B * B + C * C);\n    const sign = signed ? Math.sign(numerator) : 1;\n    return sign * distance;\n}\nfunction isPointOnPlane(point, plane, tolerance = EPSILON) {\n    return planeDistanceToPoint(plane, point) < tolerance;\n}\nexport { linePlaneIntersection, planeEquation, threePlaneIntersection, planeDistanceToPoint, isPointOnPlane, };\n","import { createPositionCallback } from './createPositionCallback';\nexport function pointInShapeCallback(imageData, options) {\n    const { pointInShapeFn, callback, boundsIJK, returnPoints = false } = options;\n    let scalarData;\n    if (imageData.getScalarData) {\n        scalarData = imageData.getScalarData();\n    }\n    else {\n        const scalars = imageData.getPointData().getScalars();\n        if (scalars) {\n            scalarData = scalars.getData();\n        }\n        else {\n            const { voxelManager } = imageData.get('voxelManager') || {};\n            if (voxelManager) {\n                scalarData = voxelManager.getCompleteScalarDataArray();\n            }\n        }\n    }\n    const dimensions = imageData.getDimensions();\n    const defaultBoundsIJK = [\n        [0, dimensions[0]],\n        [0, dimensions[1]],\n        [0, dimensions[2]],\n    ];\n    const bounds = boundsIJK || defaultBoundsIJK;\n    const pointsInShape = iterateOverPointsInShape({\n        imageData,\n        bounds,\n        scalarData,\n        pointInShapeFn,\n        callback,\n    });\n    return returnPoints ? pointsInShape : undefined;\n}\nexport function iterateOverPointsInShape({ imageData, bounds, scalarData, pointInShapeFn, callback, }) {\n    const [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = bounds;\n    const { numComps } = imageData;\n    const dimensions = imageData.getDimensions();\n    const indexToWorld = createPositionCallback(imageData);\n    const pointIJK = [0, 0, 0];\n    const xMultiple = numComps ||\n        scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n    const yMultiple = dimensions[0] * xMultiple;\n    const zMultiple = dimensions[1] * yMultiple;\n    const pointsInShape = [];\n    for (let k = kMin; k <= kMax; k++) {\n        pointIJK[2] = k;\n        const indexK = k * zMultiple;\n        for (let j = jMin; j <= jMax; j++) {\n            pointIJK[1] = j;\n            const indexJK = indexK + j * yMultiple;\n            for (let i = iMin; i <= iMax; i++) {\n                pointIJK[0] = i;\n                const pointLPS = indexToWorld(pointIJK);\n                if (pointInShapeFn(pointLPS, pointIJK)) {\n                    const index = indexJK + i * xMultiple;\n                    let value;\n                    if (xMultiple > 2) {\n                        value = [\n                            scalarData[index],\n                            scalarData[index + 1],\n                            scalarData[index + 2],\n                        ];\n                    }\n                    else {\n                        value = scalarData[index];\n                    }\n                    pointsInShape.push({\n                        value,\n                        index,\n                        pointIJK,\n                        pointLPS: pointLPS.slice(),\n                    });\n                    callback({ value, index, pointIJK, pointLPS });\n                }\n            }\n        }\n    }\n    return pointsInShape;\n}\nexport function iterateOverPointsInShapeVoxelManager({ voxelManager, bounds, imageData, pointInShapeFn, callback, returnPoints, }) {\n    const [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = bounds;\n    const indexToWorld = createPositionCallback(imageData);\n    const pointIJK = [0, 0, 0];\n    const pointsInShape = [];\n    for (let k = kMin; k <= kMax; k++) {\n        pointIJK[2] = k;\n        for (let j = jMin; j <= jMax; j++) {\n            pointIJK[1] = j;\n            for (let i = iMin; i <= iMax; i++) {\n                pointIJK[0] = i;\n                const pointLPS = indexToWorld(pointIJK);\n                if (pointInShapeFn(pointLPS, pointIJK)) {\n                    const index = voxelManager.toIndex(pointIJK);\n                    const value = voxelManager.getAtIndex(index);\n                    if (returnPoints) {\n                        pointsInShape.push({\n                            value,\n                            index,\n                            pointIJK: [...pointIJK],\n                            pointLPS: pointLPS.slice(),\n                        });\n                    }\n                    callback?.({ value, index, pointIJK, pointLPS });\n                }\n            }\n        }\n    }\n    return pointsInShape;\n}\n","import { vec3 } from 'gl-matrix';\nexport default function snapFocalPointToSlice(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, deltaFrames) {\n    const { min, max, current } = sliceRange;\n    const posDiffFromFocalPoint = vec3.create();\n    vec3.sub(posDiffFromFocalPoint, position, focalPoint);\n    const steps = Math.round((max - min) / spacingInNormalDirection);\n    const fraction = (current - min) / (max - min);\n    const floatingStepNumber = fraction * steps;\n    let frameIndex = Math.round(floatingStepNumber);\n    let newFocalPoint = [\n        focalPoint[0] -\n            viewPlaneNormal[0] * floatingStepNumber * spacingInNormalDirection,\n        focalPoint[1] -\n            viewPlaneNormal[1] * floatingStepNumber * spacingInNormalDirection,\n        focalPoint[2] -\n            viewPlaneNormal[2] * floatingStepNumber * spacingInNormalDirection,\n    ];\n    frameIndex += deltaFrames;\n    if (frameIndex > steps) {\n        frameIndex = steps;\n    }\n    else if (frameIndex < 0) {\n        frameIndex = 0;\n    }\n    const newSlicePosFromMin = frameIndex * spacingInNormalDirection;\n    newFocalPoint = [\n        newFocalPoint[0] + viewPlaneNormal[0] * newSlicePosFromMin,\n        newFocalPoint[1] + viewPlaneNormal[1] * newSlicePosFromMin,\n        newFocalPoint[2] + viewPlaneNormal[2] * newSlicePosFromMin,\n    ];\n    const newPosition = [\n        newFocalPoint[0] + posDiffFromFocalPoint[0],\n        newFocalPoint[1] + posDiffFromFocalPoint[1],\n        newFocalPoint[2] + posDiffFromFocalPoint[2],\n    ];\n    return { newFocalPoint, newPosition };\n}\n","import { vec3 } from 'gl-matrix';\nimport * as metaData from '../metaData';\nimport calculateSpacingBetweenImageIds from './calculateSpacingBetweenImageIds';\nexport default function sortImageIdsAndGetSpacing(imageIds, scanAxisNormal) {\n    const { imagePositionPatient: referenceImagePositionPatient, imageOrientationPatient, } = metaData.get('imagePlaneModule', imageIds[0]);\n    if (!scanAxisNormal) {\n        const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n        const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n        scanAxisNormal = vec3.create();\n        vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\n    }\n    const usingWadoUri = imageIds[0].split(':')[0] === 'wadouri';\n    const zSpacing = calculateSpacingBetweenImageIds(imageIds);\n    let sortedImageIds;\n    function getDistance(imageId) {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const positionVector = vec3.create();\n        vec3.sub(positionVector, referenceImagePositionPatient, imagePositionPatient);\n        return vec3.dot(positionVector, scanAxisNormal);\n    }\n    if (!usingWadoUri) {\n        const distanceImagePairs = imageIds.map((imageId) => {\n            const distance = getDistance(imageId);\n            return {\n                distance,\n                imageId,\n            };\n        });\n        distanceImagePairs.sort((a, b) => b.distance - a.distance);\n        sortedImageIds = distanceImagePairs.map((a) => a.imageId);\n    }\n    else {\n        const prefetchedImageIds = [\n            imageIds[0],\n            imageIds[Math.floor(imageIds.length / 2)],\n        ];\n        sortedImageIds = imageIds;\n        const firstImageDistance = getDistance(prefetchedImageIds[0]);\n        const middleImageDistance = getDistance(prefetchedImageIds[1]);\n        if (firstImageDistance - middleImageDistance < 0) {\n            sortedImageIds.reverse();\n        }\n    }\n    const { imagePositionPatient: origin } = metaData.get('imagePlaneModule', sortedImageIds[0]);\n    const result = {\n        zSpacing,\n        origin,\n        sortedImageIds,\n    };\n    return result;\n}\n","function getTransferFunctionNodes(transferFunction) {\n    const size = transferFunction.getSize();\n    const values = [];\n    for (let index = 0; index < size; index++) {\n        const nodeValue1 = [];\n        transferFunction.getNodeValue(index, nodeValue1);\n        values.push(nodeValue1);\n    }\n    return values;\n}\nfunction setTransferFunctionNodes(transferFunction, nodes) {\n    if (!nodes?.length) {\n        return;\n    }\n    transferFunction.removeAllPoints();\n    nodes.forEach((node) => {\n        transferFunction.addRGBPoint(...node);\n    });\n}\nexport { getTransferFunctionNodes, setTransferFunctionNodes };\n","import transformWorldToIndex from './transformWorldToIndex';\nexport function transformCanvasToIJK(viewport, canvasPoint) {\n    const { imageData: vtkImageData } = viewport.getImageData();\n    const worldPoint = viewport.canvasToWorld(canvasPoint);\n    return transformWorldToIndex(vtkImageData, worldPoint);\n}\n","export default function transformIndexToWorld(imageData, voxelPos) {\n    return imageData.indexToWorld(voxelPos);\n}\n","export default function transformWorldToIndex(imageData, worldPos) {\n    const continuousIndex = imageData.worldToIndex(worldPos);\n    const index = continuousIndex.map(Math.round);\n    return index;\n}\nexport function transformWorldToIndexContinuous(imageData, worldPos) {\n    return imageData.worldToIndex(worldPos);\n}\n","import { isEqual } from '../utilities/isEqual';\nimport { vec3 } from 'gl-matrix';\nconst ORTHOGONAL_TEST_VALUE = 0.95;\nexport function updatePlaneRestriction(points, reference) {\n    if (!points?.length || !reference.FrameOfReferenceUID) {\n        return;\n    }\n    reference.planeRestriction ||= {\n        FrameOfReferenceUID: reference.FrameOfReferenceUID,\n        point: points[0],\n        inPlaneVector1: null,\n        inPlaneVector2: null,\n    };\n    const { planeRestriction } = reference;\n    if (points.length === 1) {\n        planeRestriction.inPlaneVector1 = null;\n        planeRestriction.inPlaneVector2 = null;\n        return planeRestriction;\n    }\n    const v1 = vec3.sub(vec3.create(), points[0], points[Math.floor(points.length / 2)]);\n    vec3.normalize(v1, v1);\n    planeRestriction.inPlaneVector1 = v1;\n    planeRestriction.inPlaneVector2 = null;\n    const n = points.length;\n    if (n > 2) {\n        for (let i = Math.floor(n / 3); i < n; i++) {\n            const testVector = vec3.sub(vec3.create(), points[i], points[0]);\n            const length = vec3.length(testVector);\n            if (isEqual(length, 0)) {\n                continue;\n            }\n            if (vec3.dot(testVector, planeRestriction.inPlaneVector1) <\n                length * ORTHOGONAL_TEST_VALUE) {\n                vec3.normalize(testVector, testVector);\n                planeRestriction.inPlaneVector2 = testVector;\n                return planeRestriction;\n            }\n        }\n    }\n    return planeRestriction;\n}\n","function updateVTKImageDataWithCornerstoneImage(sourceImageData, image) {\n    const pixelData = image.voxelManager.getScalarData();\n    if (!sourceImageData.getPointData) {\n        return;\n    }\n    const scalarData = sourceImageData\n        .getPointData()\n        .getScalars()\n        .getData();\n    if (image.color && image.rgba) {\n        const newPixelData = new Uint8Array(image.columns * image.rows * 3);\n        for (let i = 0; i < image.columns * image.rows; i++) {\n            newPixelData[i * 3] = pixelData[i * 4];\n            newPixelData[i * 3 + 1] = pixelData[i * 4 + 1];\n            newPixelData[i * 3 + 2] = pixelData[i * 4 + 2];\n        }\n        image.rgba = false;\n        image.getPixelData = () => newPixelData;\n        scalarData.set(newPixelData);\n    }\n    else {\n        scalarData.set(pixelData);\n    }\n    sourceImageData.modified();\n}\nexport { updateVTKImageDataWithCornerstoneImage };\n","import VOILUTFunctionType from '../enums/VOILUTFunctionType';\nimport { logit } from './logit';\nfunction toWindowLevel(low, high) {\n    const windowWidth = Math.abs(high - low) + 1;\n    const windowCenter = (low + high + 1) / 2;\n    return { windowWidth, windowCenter };\n}\nfunction toLowHighRange(windowWidth, windowCenter, voiLUTFunction = VOILUTFunctionType.LINEAR) {\n    if (voiLUTFunction === VOILUTFunctionType.LINEAR ||\n        voiLUTFunction === VOILUTFunctionType.SAMPLED_SIGMOID) {\n        return {\n            lower: windowCenter - 0.5 - (windowWidth - 1) / 2,\n            upper: windowCenter - 0.5 + (windowWidth - 1) / 2,\n        };\n    }\n    else if (voiLUTFunction === VOILUTFunctionType.LINEAR_EXACT) {\n        return {\n            lower: windowCenter - windowWidth / 2,\n            upper: windowCenter + windowWidth / 2,\n        };\n    }\n    else {\n        throw new Error('Invalid VOI LUT function');\n    }\n}\nexport { toWindowLevel, toLowHighRange };\n","var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"Interaction\"] = \"Interaction\";\n    ChangeTypes[\"HandlesUpdated\"] = \"HandlesUpdated\";\n    ChangeTypes[\"StatsUpdated\"] = \"StatsUpdated\";\n    ChangeTypes[\"InitialSetup\"] = \"InitialSetup\";\n    ChangeTypes[\"Completed\"] = \"Completed\";\n    ChangeTypes[\"InterpolationUpdated\"] = \"InterpolationUpdated\";\n    ChangeTypes[\"History\"] = \"History\";\n    ChangeTypes[\"MetadataReferenceModified\"] = \"MetadataReferenceModified\";\n    ChangeTypes[\"LabelChange\"] = \"LabelChange\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n","var Swipe;\n(function (Swipe) {\n    Swipe[\"UP\"] = \"UP\";\n    Swipe[\"DOWN\"] = \"DOWN\";\n    Swipe[\"LEFT\"] = \"LEFT\";\n    Swipe[\"RIGHT\"] = \"RIGHT\";\n})(Swipe || (Swipe = {}));\nexport { Swipe };\n","import { BaseVolumeViewport, cache, utilities as csUtils, getEnabledElementByViewportId, volumeLoader, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nimport { triggerSegmentationModified, triggerSegmentationRemoved, triggerSegmentationRepresentationModified, triggerSegmentationRepresentationRemoved, } from './triggerSegmentationEvents';\nimport { segmentationStyle } from './SegmentationStyle';\nimport { triggerSegmentationAdded } from './events/triggerSegmentationAdded';\nconst initialDefaultState = {\n    colorLUT: [],\n    segmentations: [],\n    viewportSegRepresentations: {},\n};\nexport default class SegmentationStateManager {\n    constructor(uid) {\n        this._stackLabelmapImageIdReferenceMap = new Map();\n        this._labelmapImageIdReferenceMap = new Map();\n        uid ||= csUtils.uuidv4();\n        this.state = Object.freeze(csUtils.deepClone(initialDefaultState));\n        this.uid = uid;\n    }\n    getState() {\n        return this.state;\n    }\n    updateState(updater) {\n        const newState = csUtils.deepClone(this.state);\n        updater(newState);\n        this.state = Object.freeze(newState);\n    }\n    getColorLUT(lutIndex) {\n        return this.state.colorLUT[lutIndex];\n    }\n    getNextColorLUTIndex() {\n        return this.state.colorLUT.length;\n    }\n    resetState() {\n        this._stackLabelmapImageIdReferenceMap.clear();\n        this._labelmapImageIdReferenceMap.clear();\n        this.state = Object.freeze(csUtils.deepClone(initialDefaultState));\n    }\n    getSegmentation(segmentationId) {\n        return this.state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n    }\n    updateSegmentation(segmentationId, payload) {\n        this.updateState((draftState) => {\n            const segmentation = draftState.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n            if (!segmentation) {\n                console.warn(`Segmentation with id ${segmentationId} not found. Update aborted.`);\n                return;\n            }\n            Object.assign(segmentation, payload);\n        });\n        triggerSegmentationModified(segmentationId);\n    }\n    addSegmentation(segmentation) {\n        if (this.getSegmentation(segmentation.segmentationId)) {\n            throw new Error(`Segmentation with id ${segmentation.segmentationId} already exists`);\n        }\n        this.updateState((state) => {\n            const newSegmentation = csUtils.deepClone(segmentation);\n            if (newSegmentation.representationData.Labelmap &&\n                'volumeId' in newSegmentation.representationData.Labelmap &&\n                !('imageIds' in newSegmentation.representationData.Labelmap)) {\n                const imageIds = this.getLabelmapImageIds(newSegmentation.representationData);\n                newSegmentation.representationData\n                    .Labelmap.imageIds = imageIds;\n            }\n            state.segmentations.push(newSegmentation);\n        });\n        triggerSegmentationAdded(segmentation.segmentationId);\n    }\n    removeSegmentation(segmentationId) {\n        this.updateState((state) => {\n            const filteredSegmentations = state.segmentations.filter((segmentation) => segmentation.segmentationId !== segmentationId);\n            state.segmentations.splice(0, state.segmentations.length, ...filteredSegmentations);\n        });\n        triggerSegmentationRemoved(segmentationId);\n    }\n    addSegmentationRepresentation(viewportId, segmentationId, type, renderingConfig) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const existingRepresentations = this.getSegmentationRepresentations(viewportId, {\n            type: type,\n            segmentationId,\n        });\n        if (existingRepresentations.length > 0) {\n            console.debug('A segmentation representation of type', type, 'already exists in viewport', viewportId, 'for segmentation', segmentationId);\n            return;\n        }\n        this.updateState((state) => {\n            if (!state.viewportSegRepresentations[viewportId]) {\n                state.viewportSegRepresentations[viewportId] = [];\n                segmentationStyle.setRenderInactiveSegmentations(viewportId, true);\n            }\n            if (type !== SegmentationRepresentations.Labelmap) {\n                this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig);\n            }\n            else {\n                this.addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig);\n            }\n        });\n        triggerSegmentationRepresentationModified(viewportId, segmentationId, type);\n    }\n    addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig) {\n        const segmentation = state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const segmentReps = {};\n        Object.keys(segmentation.segments).forEach((segmentIndex) => {\n            segmentReps[Number(segmentIndex)] = {\n                visible: true,\n            };\n        });\n        state.viewportSegRepresentations[viewportId].push({\n            segmentationId,\n            type,\n            active: true,\n            visible: true,\n            colorLUTIndex: renderingConfig?.colorLUTIndex || 0,\n            segments: segmentReps,\n            config: {\n                ...getDefaultRenderingConfig(type),\n                ...renderingConfig,\n            },\n        });\n        this._setActiveSegmentation(state, viewportId, segmentationId);\n    }\n    addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig = getDefaultRenderingConfig(SegmentationRepresentations.Labelmap)) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, SegmentationRepresentations.Labelmap, renderingConfig);\n        }\n        this.processLabelmapRepresentationAddition(viewportId, segmentationId);\n        this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, SegmentationRepresentations.Labelmap, renderingConfig);\n    }\n    async processLabelmapRepresentationAddition(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const volumeViewport = enabledElement.viewport instanceof BaseVolumeViewport;\n        const { representationData } = segmentation;\n        const isBaseVolumeSegmentation = 'volumeId' in representationData.Labelmap;\n        const viewport = enabledElement.viewport;\n        if (!volumeViewport && !isBaseVolumeSegmentation) {\n            !this.updateLabelmapSegmentationImageReferences(viewportId, segmentation.segmentationId);\n        }\n    }\n    _updateLabelmapSegmentationReferences(segmentationId, viewport, labelmapImageIds, updateCallback) {\n        const referenceImageId = viewport.getCurrentImageId();\n        let viewableLabelmapImageIdFound = false;\n        for (const labelmapImageId of labelmapImageIds) {\n            const viewableImageId = viewport.isReferenceViewable({ referencedImageId: labelmapImageId }, { asOverlay: true });\n            if (viewableImageId) {\n                viewableLabelmapImageIdFound = true;\n                this._stackLabelmapImageIdReferenceMap\n                    .get(segmentationId)\n                    .set(referenceImageId, labelmapImageId);\n                this._updateLabelmapImageIdReferenceMap({\n                    segmentationId,\n                    referenceImageId,\n                    labelmapImageId,\n                });\n            }\n        }\n        if (updateCallback) {\n            updateCallback(viewport, segmentationId, labelmapImageIds);\n        }\n        return viewableLabelmapImageIdFound\n            ? this._stackLabelmapImageIdReferenceMap\n                .get(segmentationId)\n                .get(referenceImageId)\n            : undefined;\n    }\n    updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return;\n        }\n        const labelmapImageIds = this.getLabelmapImageIds(representationData);\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        const stackViewport = enabledElement.viewport;\n        return this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, null);\n    }\n    _updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return;\n        }\n        const labelmapImageIds = this.getLabelmapImageIds(representationData);\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        const stackViewport = enabledElement.viewport;\n        this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, (stackViewport, segmentationId, labelmapImageIds) => {\n            const imageIds = stackViewport.getImageIds();\n            imageIds.forEach((referenceImageId, index) => {\n                for (const labelmapImageId of labelmapImageIds) {\n                    const viewableImageId = stackViewport.isReferenceViewable({ referencedImageId: labelmapImageId, sliceIndex: index }, { asOverlay: true, withNavigation: true });\n                    if (viewableImageId) {\n                        this._stackLabelmapImageIdReferenceMap\n                            .get(segmentationId)\n                            .set(referenceImageId, labelmapImageId);\n                        this._updateLabelmapImageIdReferenceMap({\n                            segmentationId,\n                            referenceImageId,\n                            labelmapImageId,\n                        });\n                    }\n                }\n            });\n        });\n    }\n    getLabelmapImageIds(representationData) {\n        const labelmapData = representationData.Labelmap;\n        let labelmapImageIds;\n        if (labelmapData.imageIds) {\n            labelmapImageIds = labelmapData\n                .imageIds;\n        }\n        else if (!labelmapImageIds &&\n            labelmapData.volumeId) {\n            const volumeId = labelmapData\n                .volumeId;\n            const volume = cache.getVolume(volumeId);\n            labelmapImageIds = volume.imageIds;\n        }\n        return labelmapImageIds;\n    }\n    getLabelmapImageIdsForImageId(imageId, segmentationId) {\n        const key = this._generateMapKey({\n            segmentationId,\n            referenceImageId: imageId,\n        });\n        return this._labelmapImageIdReferenceMap.get(key);\n    }\n    getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const stackViewport = enabledElement.viewport;\n        const referenceImageId = stackViewport.getCurrentImageId();\n        return this.getLabelmapImageIdsForImageId(referenceImageId, segmentationId);\n    }\n    getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            return;\n        }\n        const stackViewport = enabledElement.viewport;\n        const currentImageId = stackViewport.getCurrentImageId();\n        const imageIdReferenceMap = this._stackLabelmapImageIdReferenceMap.get(segmentationId);\n        return imageIdReferenceMap.get(currentImageId);\n    }\n    getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return [];\n        }\n        this._updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId);\n        const { viewport } = getEnabledElementByViewportId(viewportId);\n        const imageIds = viewport.getImageIds();\n        const associatedReferenceImageAndLabelmapImageIds = this._stackLabelmapImageIdReferenceMap.get(segmentationId);\n        return imageIds.map((imageId) => {\n            return associatedReferenceImageAndLabelmapImageIds.get(imageId);\n        });\n    }\n    removeSegmentationRepresentationsInternal(viewportId, specifier) {\n        const removedRepresentations = [];\n        this.updateState((state) => {\n            if (!state.viewportSegRepresentations[viewportId]) {\n                return;\n            }\n            const currentRepresentations = state.viewportSegRepresentations[viewportId];\n            let activeRepresentationRemoved = false;\n            if (!specifier ||\n                Object.values(specifier).every((value) => value === undefined)) {\n                removedRepresentations.push(...currentRepresentations);\n                delete state.viewportSegRepresentations[viewportId];\n            }\n            else {\n                const { segmentationId, type } = specifier;\n                state.viewportSegRepresentations[viewportId] =\n                    currentRepresentations.filter((representation) => {\n                        const shouldRemove = (segmentationId &&\n                            type &&\n                            representation.segmentationId === segmentationId &&\n                            representation.type === type) ||\n                            (segmentationId &&\n                                !type &&\n                                representation.segmentationId === segmentationId) ||\n                            (!segmentationId && type && representation.type === type);\n                        if (shouldRemove) {\n                            removedRepresentations.push(representation);\n                            if (representation.active) {\n                                activeRepresentationRemoved = true;\n                            }\n                        }\n                        return !shouldRemove;\n                    });\n                if (state.viewportSegRepresentations[viewportId].length === 0) {\n                    delete state.viewportSegRepresentations[viewportId];\n                }\n                else if (activeRepresentationRemoved) {\n                    state.viewportSegRepresentations[viewportId][0].active = true;\n                }\n            }\n        });\n        return removedRepresentations;\n    }\n    removeSegmentationRepresentations(viewportId, specifier) {\n        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);\n        removedRepresentations.forEach((representation) => {\n            triggerSegmentationRepresentationRemoved(viewportId, representation.segmentationId, representation.type);\n        });\n        const remainingRepresentations = this.getSegmentationRepresentations(viewportId);\n        if (remainingRepresentations.length > 0 &&\n            remainingRepresentations[0].active) {\n            triggerSegmentationRepresentationModified(viewportId, remainingRepresentations[0].segmentationId, remainingRepresentations[0].type);\n        }\n        return removedRepresentations;\n    }\n    removeSegmentationRepresentation(viewportId, specifier, suppressEvent) {\n        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);\n        if (!suppressEvent) {\n            removedRepresentations.forEach(({ segmentationId, type }) => {\n                triggerSegmentationRepresentationRemoved(viewportId, segmentationId, type);\n            });\n        }\n        return removedRepresentations;\n    }\n    _updateLabelmapImageIdReferenceMap({ segmentationId, referenceImageId, labelmapImageId, }) {\n        const key = this._generateMapKey({ segmentationId, referenceImageId });\n        if (!this._labelmapImageIdReferenceMap.has(key)) {\n            this._labelmapImageIdReferenceMap.set(key, [labelmapImageId]);\n            return;\n        }\n        const currentValues = this._labelmapImageIdReferenceMap.get(key);\n        const newValues = Array.from(new Set([...currentValues, labelmapImageId]));\n        this._labelmapImageIdReferenceMap.set(key, newValues);\n    }\n    _setActiveSegmentation(state, viewportId, segmentationId) {\n        const viewport = state.viewportSegRepresentations[viewportId];\n        if (!viewport) {\n            return;\n        }\n        viewport.forEach((value) => {\n            value.active = value.segmentationId === segmentationId;\n        });\n    }\n    setActiveSegmentation(viewportId, segmentationId) {\n        this.updateState((state) => {\n            const viewport = state.viewportSegRepresentations[viewportId];\n            if (!viewport) {\n                return;\n            }\n            viewport.forEach((value) => {\n                value.active = value.segmentationId === segmentationId;\n            });\n        });\n        triggerSegmentationRepresentationModified(viewportId, segmentationId);\n    }\n    getActiveSegmentation(viewportId) {\n        if (!this.state.viewportSegRepresentations[viewportId]) {\n            return;\n        }\n        const activeSegRep = this.state.viewportSegRepresentations[viewportId].find((segRep) => segRep.active);\n        if (!activeSegRep) {\n            return;\n        }\n        return this.getSegmentation(activeSegRep.segmentationId);\n    }\n    getSegmentationRepresentations(viewportId, specifier = {}) {\n        const viewportRepresentations = this.state.viewportSegRepresentations[viewportId];\n        if (!viewportRepresentations) {\n            return [];\n        }\n        if (!specifier.type && !specifier.segmentationId) {\n            return viewportRepresentations;\n        }\n        return viewportRepresentations.filter((representation) => {\n            const typeMatch = specifier.type\n                ? representation.type === specifier.type\n                : true;\n            const idMatch = specifier.segmentationId\n                ? representation.segmentationId === specifier.segmentationId\n                : true;\n            return typeMatch && idMatch;\n        });\n    }\n    getSegmentationRepresentation(viewportId, specifier) {\n        return this.getSegmentationRepresentations(viewportId, specifier)[0];\n    }\n    getSegmentationRepresentationVisibility(viewportId, specifier) {\n        const viewportRepresentation = this.getSegmentationRepresentation(viewportId, specifier);\n        return viewportRepresentation?.visible;\n    }\n    setSegmentationRepresentationVisibility(viewportId, specifier, visible) {\n        this.updateState((state) => {\n            const viewportRepresentations = this.getSegmentationRepresentations(viewportId, specifier);\n            if (!viewportRepresentations) {\n                return;\n            }\n            viewportRepresentations.forEach((representation) => {\n                representation.visible = visible;\n                Object.entries(representation.segments).forEach(([segmentIndex, segment]) => {\n                    segment.visible = visible;\n                });\n            });\n        });\n        triggerSegmentationRepresentationModified(viewportId, specifier.segmentationId, specifier.type);\n    }\n    addColorLUT(colorLUT, lutIndex) {\n        this.updateState((state) => {\n            if (state.colorLUT[lutIndex]) {\n                console.warn('Color LUT table already exists, overwriting');\n            }\n            state.colorLUT[lutIndex] = csUtils.deepClone(colorLUT);\n        });\n    }\n    removeColorLUT(colorLUTIndex) {\n        this.updateState((state) => {\n            delete state.colorLUT[colorLUTIndex];\n        });\n    }\n    _getStackIdForImageIds(imageIds) {\n        return imageIds\n            .map((imageId) => imageId.slice(-Math.round(imageId.length * 0.15)))\n            .join('_');\n    }\n    getAllViewportSegmentationRepresentations() {\n        return Object.entries(this.state.viewportSegRepresentations).map(([viewportId, representations]) => ({\n            viewportId,\n            representations,\n        }));\n    }\n    getSegmentationRepresentationsBySegmentationId(segmentationId) {\n        const result = [];\n        Object.entries(this.state.viewportSegRepresentations).forEach(([viewportId, viewportReps]) => {\n            const filteredReps = viewportReps.filter((representation) => representation.segmentationId === segmentationId);\n            if (filteredReps.length > 0) {\n                result.push({ viewportId, representations: filteredReps });\n            }\n        });\n        return result;\n    }\n    _generateMapKey({ segmentationId, referenceImageId }) {\n        return `${segmentationId}-${referenceImageId}`;\n    }\n}\nasync function internalComputeVolumeLabelmapFromStack({ imageIds, options, }) {\n    const segmentationImageIds = imageIds;\n    const volumeId = options?.volumeId || csUtils.uuidv4();\n    await volumeLoader.createAndCacheVolumeFromImages(volumeId, segmentationImageIds);\n    return { volumeId };\n}\nasync function internalConvertStackToVolumeLabelmap({ segmentationId, options, }) {\n    const segmentation = defaultSegmentationStateManager.getSegmentation(segmentationId);\n    const data = segmentation.representationData\n        .Labelmap;\n    const { volumeId } = await internalComputeVolumeLabelmapFromStack({\n        imageIds: data.imageIds,\n        options,\n    });\n    segmentation.representationData.Labelmap.volumeId = volumeId;\n}\nfunction getDefaultRenderingConfig(type) {\n    const cfun = vtkColorTransferFunction.newInstance();\n    const ofun = vtkPiecewiseFunction.newInstance();\n    ofun.addPoint(0, 0);\n    if (type === SegmentationRepresentations.Labelmap) {\n        return {\n            cfun,\n            ofun,\n        };\n    }\n    else {\n        return {};\n    }\n}\nconst defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');\nexport { internalConvertStackToVolumeLabelmap, internalComputeVolumeLabelmapFromStack, defaultSegmentationStateManager, };\n","import { getActiveSegmentation as _getActiveSegmentation } from './getActiveSegmentation';\nimport { setActiveSegmentation as _setActiveSegmentation } from './setActiveSegmentation';\nfunction getActiveSegmentation(viewportId) {\n    return _getActiveSegmentation(viewportId);\n}\nfunction setActiveSegmentation(viewportId, segmentationId) {\n    _setActiveSegmentation(viewportId, segmentationId);\n}\nexport { getActiveSegmentation, setActiveSegmentation, };\n","import { addColorLUT as _addColorLUT } from '../addColorLUT';\nimport { getColorLUT as _getColorLUT } from '../getColorLUT';\nimport { getSegmentationRepresentations } from '../getSegmentationRepresentation';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nfunction addColorLUT(colorLUT, colorLUTIndex) {\n    if (!colorLUT) {\n        throw new Error('addColorLUT: colorLUT is required');\n    }\n    return _addColorLUT(colorLUT, colorLUTIndex);\n}\nfunction setColorLUT(viewportId, segmentationId, colorLUTsIndex) {\n    if (!_getColorLUT(colorLUTsIndex)) {\n        throw new Error(`setColorLUT: could not find colorLUT with index ${colorLUTsIndex}`);\n    }\n    const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n    if (!segmentationRepresentations) {\n        throw new Error(`viewport specific state for viewport ${viewportId} does not exist`);\n    }\n    segmentationRepresentations.forEach((segmentationRepresentation) => {\n        segmentationRepresentation.colorLUTIndex = colorLUTsIndex;\n    });\n    triggerSegmentationRepresentationModified(viewportId, segmentationId);\n}\nfunction getSegmentIndexColor(viewportId, segmentationId, segmentIndex) {\n    const representations = getSegmentationRepresentations(viewportId, {\n        segmentationId,\n    });\n    if (!representations || representations.length === 0) {\n        return null;\n    }\n    const representation = representations[0];\n    const { colorLUTIndex } = representation;\n    const colorLUT = _getColorLUT(colorLUTIndex);\n    let colorValue = colorLUT[segmentIndex];\n    if (!colorValue) {\n        if (typeof segmentIndex !== 'number') {\n            console.warn(`Can't create colour for LUT index ${segmentIndex}`);\n            return null;\n        }\n        colorValue = colorLUT[segmentIndex] = [0, 0, 0, 0];\n    }\n    return colorValue;\n}\nfunction setSegmentIndexColor(viewportId, segmentationId, segmentIndex, color) {\n    const colorReference = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n    for (let i = 0; i < color.length; i++) {\n        colorReference[i] = color[i];\n    }\n    triggerSegmentationRepresentationModified(viewportId, segmentationId);\n}\nexport { getSegmentIndexColor, addColorLUT, setColorLUT, setSegmentIndexColor };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentationRepresentations(viewportId, specifier = {}) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);\n}\nexport function getSegmentationRepresentation(viewportId, specifier) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    if (!specifier.segmentationId || !specifier.type) {\n        throw new Error('getSegmentationRepresentation: No segmentationId or type provided, you need to provide at least one of them');\n    }\n    const representations = segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);\n    return representations?.[0];\n}\nexport function getSegmentationRepresentationsBySegmentationId(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentationsBySegmentationId(segmentationId);\n}\n","import { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { setAnnotationLocked } from '../annotation/annotationLocking';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport { getAnnotationsUIDMapFromSegmentation } from './utilities';\nfunction _setContourSegmentationSegmentAnnotationsLocked(segmentation, segmentIndex, locked) {\n    const annotationUIDsMap = getAnnotationsUIDMapFromSegmentation(segmentation.segmentationId);\n    if (!annotationUIDsMap) {\n        return;\n    }\n    const annotationUIDs = annotationUIDsMap.get(segmentIndex);\n    if (!annotationUIDs) {\n        return;\n    }\n    annotationUIDs.forEach((annotationUID) => {\n        setAnnotationLocked(annotationUID, locked);\n    });\n}\nfunction isSegmentIndexLocked(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    return segments[segmentIndex].locked;\n}\nfunction setSegmentIndexLocked(segmentationId, segmentIndex, locked = true) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    segments[segmentIndex].locked = locked;\n    if (segmentation?.representationData?.Contour) {\n        _setContourSegmentationSegmentAnnotationsLocked(segmentation, segmentIndex, locked);\n    }\n    triggerSegmentationModified(segmentationId);\n}\nfunction getLockedSegmentIndices(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    const lockedSegmentIndices = Object.keys(segments).filter((segmentIndex) => segments[segmentIndex].locked);\n    return lockedSegmentIndices.map((segmentIndex) => parseInt(segmentIndex));\n}\nexport { isSegmentIndexLocked, setSegmentIndexLocked, getLockedSegmentIndices };\n","import { eventTarget } from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport debounce from '../../utilities/debounce';\nimport surfaceDisplay from '../../tools/displayTools/Surface/surfaceDisplay';\nimport contourDisplay from '../../tools/displayTools/Contour/contourDisplay';\nimport labelmapDisplay from '../../tools/displayTools/Labelmap/labelmapDisplay';\nimport { getSegmentation } from './getSegmentation';\nconst renderers = {\n    [SegmentationRepresentations.Labelmap]: labelmapDisplay,\n    [SegmentationRepresentations.Contour]: contourDisplay,\n    [SegmentationRepresentations.Surface]: surfaceDisplay,\n};\nconst segmentationListeners = new Map();\nexport function addDefaultSegmentationListener(viewport, segmentationId, representationType) {\n    const updateFunction = renderers[representationType].getUpdateFunction(viewport);\n    if (updateFunction) {\n        addSegmentationListener(segmentationId, representationType, updateFunction);\n    }\n}\nfunction addSegmentationListener(segmentationId, representationType, updateFunction) {\n    if (!segmentationListeners.has(segmentationId)) {\n        segmentationListeners.set(segmentationId, new Map());\n    }\n    const listenerMap = segmentationListeners.get(segmentationId);\n    if (listenerMap.has(representationType)) {\n        removeSegmentationListener(segmentationId, representationType);\n    }\n    const listener = createDebouncedSegmentationListener(segmentationId, representationType, updateFunction);\n    eventTarget.addEventListener(Events.SEGMENTATION_DATA_MODIFIED, listener);\n    listenerMap.set(representationType, listener);\n}\nfunction removeSegmentationListener(segmentationId, representationType) {\n    const listenerMap = segmentationListeners.get(segmentationId);\n    if (!listenerMap) {\n        return;\n    }\n    const listener = listenerMap.get(representationType);\n    if (!listener) {\n        return;\n    }\n    eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, listener);\n    listenerMap.delete(representationType);\n}\nfunction removeAllSegmentationListeners(segmentationId) {\n    const listenerMap = segmentationListeners.get(segmentationId);\n    if (!listenerMap) {\n        return;\n    }\n    for (const listener of listenerMap.values()) {\n        eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, listener);\n    }\n    segmentationListeners.delete(segmentationId);\n}\nfunction createDebouncedSegmentationListener(segmentationId, representationType, updateFunction) {\n    const debouncedHandler = debounce((event) => {\n        const eventSegmentationId = event.detail?.segmentationId;\n        const segmentation = getSegmentation(eventSegmentationId);\n        if (eventSegmentationId === segmentationId &&\n            !!segmentation?.representationData?.[representationType]) {\n            updateFunction(segmentationId);\n            triggerSegmentationModified(segmentationId);\n        }\n    }, 300);\n    return ((event) => {\n        debouncedHandler(event);\n    });\n}\nexport { addSegmentationListener, removeSegmentationListener, removeAllSegmentationListeners, };\n","let svgNodeCache = {};\nexport function resetSvgNodeCache() {\n    svgNodeCache = {};\n}\nexport default svgNodeCache;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, utilities, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawLine as drawLineSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass BidirectionalTool extends AnnotationTool {\n    static { this.toolName = 'Bidirectional'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            let canvasPoint1 = viewport.worldToCanvas(points[0]);\n            let canvasPoint2 = viewport.worldToCanvas(points[1]);\n            let line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            let distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            canvasPoint1 = viewport.worldToCanvas(points[2]);\n            canvasPoint2 = viewport.worldToCanvas(points[3]);\n            line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const data = annotation.data;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            hideElementCursor(element);\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            if (this.editData.handleIndex !== undefined) {\n                const { points } = data.handles;\n                const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n                const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n                if (secondLineSegmentLength > firstLineSegmentLength) {\n                    const longAxis = [[...points[2]], [...points[3]]];\n                    const shortAxisPoint0 = [...points[0]];\n                    const shortAxisPoint1 = [...points[1]];\n                    const longAxisVector = vec2.create();\n                    vec2.set(longAxisVector, longAxis[1][0] - longAxis[0][0], longAxis[1][1] - longAxis[1][0]);\n                    const counterClockWisePerpendicularToLongAxis = vec2.create();\n                    vec2.set(counterClockWisePerpendicularToLongAxis, -longAxisVector[1], longAxisVector[0]);\n                    const currentShortAxisVector = vec2.create();\n                    vec2.set(currentShortAxisVector, shortAxisPoint1[0] - shortAxisPoint0[0], shortAxisPoint1[1] - shortAxisPoint0[0]);\n                    let shortAxis;\n                    if (vec2.dot(currentShortAxisVector, counterClockWisePerpendicularToLongAxis) > 0) {\n                        shortAxis = [shortAxisPoint0, shortAxisPoint1];\n                    }\n                    else {\n                        shortAxis = [shortAxisPoint1, shortAxisPoint0];\n                    }\n                    data.handles.points = [\n                        longAxis[0],\n                        longAxis[1],\n                        shortAxis[0],\n                        shortAxis[1],\n                    ];\n                }\n            }\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { worldToCanvas } = viewport;\n            const { annotation, viewportIdsToRender, handleIndex, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            data.handles.points[handleIndex] = [...worldPos];\n            const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n            const canvasCoords = {\n                longLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[0][0],\n                        y: canvasCoordPoints[0][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[1][0],\n                        y: canvasCoordPoints[1][1],\n                    },\n                },\n                shortLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[2][0],\n                        y: canvasCoordPoints[2][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[3][0],\n                        y: canvasCoordPoints[3][1],\n                    },\n                },\n            };\n            const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n            const shortAxisDistFromCenter = dist / 3;\n            const dx = canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n            const dy = canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n            const length = Math.sqrt(dx * dx + dy * dy);\n            const vectorX = dx / length;\n            const vectorY = dy / length;\n            const xMid = (canvasCoords.longLineSegment.start.x +\n                canvasCoords.longLineSegment.end.x) /\n                2;\n            const yMid = (canvasCoords.longLineSegment.start.y +\n                canvasCoords.longLineSegment.end.y) /\n                2;\n            const startX = xMid + shortAxisDistFromCenter * vectorY;\n            const startY = yMid - shortAxisDistFromCenter * vectorX;\n            const endX = xMid - shortAxisDistFromCenter * vectorY;\n            const endY = yMid + shortAxisDistFromCenter * vectorX;\n            data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n            data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            this.editData.hasMoved = true;\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragModifyHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this._dragModifyHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { annotation, handleIndex: movingHandleIndex } = this.editData;\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            const canvasCoordHandlesCurrent = [\n                viewport.worldToCanvas(data.handles.points[0]),\n                viewport.worldToCanvas(data.handles.points[1]),\n                viewport.worldToCanvas(data.handles.points[2]),\n                viewport.worldToCanvas(data.handles.points[3]),\n            ];\n            const firstLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[0][0],\n                    y: canvasCoordHandlesCurrent[0][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[1][0],\n                    y: canvasCoordHandlesCurrent[1][1],\n                },\n            };\n            const secondLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[2][0],\n                    y: canvasCoordHandlesCurrent[2][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[3][0],\n                    y: canvasCoordHandlesCurrent[3][1],\n                },\n            };\n            const proposedPoint = [...worldPos];\n            const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n            if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n                const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n                const fixedHandleCanvasCoord = canvasCoordHandlesCurrent[fixedHandleIndex];\n                const fixedHandleToProposedCoordVec = vec2.set(vec2.create(), proposedCanvasCoord[0] - fixedHandleCanvasCoord[0], proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]);\n                const fixedHandleToOldCoordVec = vec2.set(vec2.create(), canvasCoordHandlesCurrent[movingHandleIndex][0] -\n                    fixedHandleCanvasCoord[0], canvasCoordHandlesCurrent[movingHandleIndex][1] -\n                    fixedHandleCanvasCoord[1]);\n                vec2.normalize(fixedHandleToProposedCoordVec, fixedHandleToProposedCoordVec);\n                vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n                const proposedFirstLineSegment = {\n                    start: {\n                        x: fixedHandleCanvasCoord[0],\n                        y: fixedHandleCanvasCoord[1],\n                    },\n                    end: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                };\n                if (this._movingLongAxisWouldPutItThroughShortAxis(proposedFirstLineSegment, secondLineSegment)) {\n                    return;\n                }\n                const centerOfRotation = fixedHandleCanvasCoord;\n                const angle = this._getSignedAngle(fixedHandleToOldCoordVec, fixedHandleToProposedCoordVec);\n                let firstPointX = canvasCoordHandlesCurrent[2][0];\n                let firstPointY = canvasCoordHandlesCurrent[2][1];\n                let secondPointX = canvasCoordHandlesCurrent[3][0];\n                let secondPointY = canvasCoordHandlesCurrent[3][1];\n                firstPointX -= centerOfRotation[0];\n                firstPointY -= centerOfRotation[1];\n                secondPointX -= centerOfRotation[0];\n                secondPointY -= centerOfRotation[1];\n                const rotatedFirstPoint = firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n                const rotatedFirstPointY = firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n                const rotatedSecondPoint = secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n                const rotatedSecondPointY = secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n                firstPointX = rotatedFirstPoint + centerOfRotation[0];\n                firstPointY = rotatedFirstPointY + centerOfRotation[1];\n                secondPointX = rotatedSecondPoint + centerOfRotation[0];\n                secondPointY = rotatedSecondPointY + centerOfRotation[1];\n                const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n                const newSecondPoint = viewport.canvasToWorld([\n                    secondPointX,\n                    secondPointY,\n                ]);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n                data.handles.points[2] = newFirstPoint;\n                data.handles.points[3] = newSecondPoint;\n            }\n            else {\n                const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n                const canvasCoordsCurrent = {\n                    longLineSegment: {\n                        start: firstLineSegment.start,\n                        end: firstLineSegment.end,\n                    },\n                    shortLineSegment: {\n                        start: secondLineSegment.start,\n                        end: secondLineSegment.end,\n                    },\n                };\n                const longLineSegmentVec = vec2.subtract(vec2.create(), [\n                    canvasCoordsCurrent.longLineSegment.end.x,\n                    canvasCoordsCurrent.longLineSegment.end.y,\n                ], [\n                    canvasCoordsCurrent.longLineSegment.start.x,\n                    canvasCoordsCurrent.longLineSegment.start.y,\n                ]);\n                const longLineSegmentVecNormalized = vec2.normalize(vec2.create(), longLineSegmentVec);\n                const proposedToCurrentVec = vec2.subtract(vec2.create(), [proposedCanvasCoord[0], proposedCanvasCoord[1]], [\n                    canvasCoordHandlesCurrent[movingHandleIndex][0],\n                    canvasCoordHandlesCurrent[movingHandleIndex][1],\n                ]);\n                const movementLength = vec2.length(proposedToCurrentVec);\n                const angle = this._getSignedAngle(longLineSegmentVecNormalized, proposedToCurrentVec);\n                const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n                const newTranslatedPoint = vec2.scaleAndAdd(vec2.create(), [\n                    canvasCoordHandlesCurrent[translateHandleIndex][0],\n                    canvasCoordHandlesCurrent[translateHandleIndex][1],\n                ], longLineSegmentVecNormalized, movementAlongLineSegmentLength);\n                if (this._movingLongAxisWouldPutItThroughShortAxis({\n                    start: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                    end: {\n                        x: newTranslatedPoint[0],\n                        y: newTranslatedPoint[1],\n                    },\n                }, {\n                    start: {\n                        x: canvasCoordsCurrent.longLineSegment.start.x,\n                        y: canvasCoordsCurrent.longLineSegment.start.y,\n                    },\n                    end: {\n                        x: canvasCoordsCurrent.longLineSegment.end.x,\n                        y: canvasCoordsCurrent.longLineSegment.end.y,\n                    },\n                })) {\n                    return;\n                }\n                const intersectionPoint = lineSegment.intersectLine([proposedCanvasCoord[0], proposedCanvasCoord[1]], [newTranslatedPoint[0], newTranslatedPoint[1]], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n                if (!intersectionPoint) {\n                    return;\n                }\n                data.handles.points[translateHandleIndex] = viewport.canvasToWorld(newTranslatedPoint);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = true;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        width: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, showHandlesAlways ? canvasCoordinates : activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId1 = `${annotationUID}-line-1`;\n                const dataId2 = `${annotationUID}-line-2`;\n                const lineUID = '0';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId1);\n                const secondLineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId2);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._movingLongAxisWouldPutItThroughShortAxis = (firstLineSegment, secondLineSegment) => {\n            const vectorInSecondLineDirection = vec2.create();\n            vec2.set(vectorInSecondLineDirection, secondLineSegment.end.x - secondLineSegment.start.x, secondLineSegment.end.y - secondLineSegment.start.y);\n            vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n            const extendedSecondLineSegment = {\n                start: {\n                    x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n                },\n                end: {\n                    x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n                },\n            };\n            const proposedIntersectionPoint = lineSegment.intersectLine([extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y], [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n            const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n            return wouldPutThroughShortAxis;\n        };\n        this._calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { element } = enabledElement.viewport;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[1];\n            const worldPos3 = data.handles.points[2];\n            const worldPos4 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, dimensions } = image;\n                const index1 = transformWorldToIndex(imageData, worldPos1);\n                const index2 = transformWorldToIndex(imageData, worldPos2);\n                const index3 = transformWorldToIndex(imageData, worldPos3);\n                const index4 = transformWorldToIndex(imageData, worldPos4);\n                const handles1 = [index1, index2];\n                const handles2 = [index3, index4];\n                const { scale: scale1, unit: units1 } = getCalibratedLengthUnitsAndScale(image, handles1);\n                const { scale: scale2, unit: units2 } = getCalibratedLengthUnitsAndScale(image, handles2);\n                const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;\n                const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;\n                const length = dist1 > dist2 ? dist1 : dist2;\n                const width = dist1 > dist2 ? dist2 : dist1;\n                const unit = dist1 > dist2 ? units1 : units2;\n                const widthUnit = dist1 > dist2 ? units2 : units1;\n                this._isInsideVolume(index1, index2, index3, index4, dimensions)\n                    ? (this.isHandleOutsideImage = false)\n                    : (this.isHandleOutsideImage = true);\n                cachedStats[targetId] = {\n                    length,\n                    width,\n                    unit,\n                    widthUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, index3, index4, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions) &&\n                csUtils.indexWithinDimensions(index3, dimensions) &&\n                csUtils.indexWithinDimensions(index4, dimensions));\n        };\n        this._getSignedAngle = (vector1, vector2) => {\n            return Math.atan2(vector1[0] * vector2[1] - vector1[1] * vector2[0], vector1[0] * vector2[0] + vector1[1] * vector2[1]);\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const worldPos = currentPoints.world;\n        this.isDrawing = true;\n        const annotation = this.createAnnotation(evt, [\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n        ]);\n        addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex: 1,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n        };\n        this._activateDraw(element);\n        hideElementCursor(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    static { this.hydrate = (viewportId, axis, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(BidirectionalTool, enabledElement, axis[0], options);\n        const [majorAxis, minorAxis] = axis;\n        const [major0, major1] = majorAxis;\n        const [minor0, minor1] = minorAxis;\n        const points = [major0, major1, minor0, minor1];\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                },\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n        return annotation;\n    }; }\n    _calculateLength(pos1, pos2) {\n        const dx = pos1[0] - pos2[0];\n        const dy = pos1[1] - pos2[1];\n        const dz = pos1[2] - pos2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const { cachedStats, label } = data;\n    const { length, width, unit } = cachedStats[targetId];\n    const textLines = [];\n    if (label) {\n        textLines.push(label);\n    }\n    if (length === undefined) {\n        return textLines;\n    }\n    textLines.push(`L: ${csUtils.roundNumber(length)} ${unit || unit}`, `W: ${csUtils.roundNumber(width)} ${unit}`);\n    return textLines;\n}\nexport default BidirectionalTool;\n","import { getEnabledElement, eventTarget } from '@cornerstonejs/core';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { Events, ToolModes, StrategyCallbacks } from '../../enums';\nimport { fillInsideSphere, thresholdInsideSphere, thresholdInsideSphereIsland, } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { thresholdInsideCircle, fillInsideCircle, } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nimport { getStrategyData } from './strategies/utils/getStrategyData';\nclass BrushTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE_CIRCLE: fillInsideCircle,\n                ERASE_INSIDE_CIRCLE: eraseInsideCircle,\n                FILL_INSIDE_SPHERE: fillInsideSphere,\n                ERASE_INSIDE_SPHERE: eraseInsideSphere,\n                THRESHOLD_INSIDE_CIRCLE: thresholdInsideCircle,\n                THRESHOLD_INSIDE_SPHERE: thresholdInsideSphere,\n                THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL: thresholdInsideSphereIsland,\n            },\n            defaultStrategy: 'FILL_INSIDE_CIRCLE',\n            activeStrategy: 'FILL_INSIDE_CIRCLE',\n            brushSize: 25,\n            useCenterSegmentIndex: false,\n            preview: {\n                enabled: false,\n                previewColors: {\n                    0: [255, 255, 255, 128],\n                },\n                previewTimeMs: 250,\n                previewMoveDistance: 8,\n                dragMoveDistance: 4,\n                dragTimeMs: 500,\n            },\n            actions: {\n                [StrategyCallbacks.AcceptPreview]: {\n                    method: StrategyCallbacks.AcceptPreview,\n                    bindings: [\n                        {\n                            key: 'Enter',\n                        },\n                    ],\n                },\n                [StrategyCallbacks.RejectPreview]: {\n                    method: StrategyCallbacks.RejectPreview,\n                    bindings: [\n                        {\n                            key: 'Escape',\n                        },\n                    ],\n                },\n                [StrategyCallbacks.Interpolate]: {\n                    method: StrategyCallbacks.Interpolate,\n                    bindings: [\n                        {\n                            key: 'i',\n                        },\n                    ],\n                    configuration: {\n                        useBallStructuringElement: true,\n                        noUseDistanceTransform: true,\n                        noUseExtrapolation: true,\n                    },\n                },\n                interpolateExtrapolation: {\n                    method: StrategyCallbacks.Interpolate,\n                    bindings: [\n                        {\n                            key: 'e',\n                        },\n                    ],\n                    configuration: {},\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._lastDragInfo = null;\n        this.onSetToolPassive = (evt) => {\n            this.disableCursor();\n        };\n        this.onSetToolEnabled = () => {\n            this.disableCursor();\n        };\n        this.onSetToolDisabled = (evt) => {\n            this.disableCursor();\n        };\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this._editData = this.createEditData(element);\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            this._previewData.isDrag = false;\n            this._previewData.timerStart = Date.now();\n            const canvasPoint = vec2.clone(currentPoints.canvas);\n            const worldPoint = viewport.canvasToWorld([\n                canvasPoint[0],\n                canvasPoint[1],\n            ]);\n            this._lastDragInfo = {\n                canvas: canvasPoint,\n                world: vec3.clone(worldPoint),\n            };\n            const hoverData = this._hoverData || this.createHoverData(element);\n            triggerAnnotationRenderForViewportUIDs(hoverData.viewportIdsToRender);\n            const operationData = this.getOperationData(element);\n            this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.OnInteractionStart);\n            return true;\n        };\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode === ToolModes.Active) {\n                this.updateCursor(evt);\n                if (!this.configuration.preview.enabled) {\n                    return;\n                }\n                const { previewTimeMs, previewMoveDistance, dragMoveDistance } = this.configuration.preview;\n                const { currentPoints, element } = evt.detail;\n                const { canvas } = currentPoints;\n                const { startPoint, timer, timerStart, isDrag } = this._previewData;\n                if (isDrag) {\n                    return;\n                }\n                const delta = vec2.distance(canvas, startPoint);\n                const time = Date.now() - timerStart;\n                if (delta > previewMoveDistance ||\n                    (time > previewTimeMs && delta > dragMoveDistance)) {\n                    if (timer) {\n                        window.clearTimeout(timer);\n                        this._previewData.timer = null;\n                    }\n                    if (!isDrag) {\n                        this.rejectPreview(element);\n                    }\n                }\n                if (!this._previewData.timer) {\n                    const timer = window.setTimeout(this.previewCallback, 250);\n                    Object.assign(this._previewData, {\n                        timerStart: Date.now(),\n                        timer,\n                        startPoint: canvas,\n                        element,\n                    });\n                }\n            }\n        };\n        this.previewCallback = () => {\n            if (this._previewData.isDrag) {\n                this._previewData.timer = null;\n                return;\n            }\n            this._previewData.timer = null;\n            const operationData = this.getOperationData(this._previewData.element);\n            const enabledElement = getEnabledElement(this._previewData.element);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            const activeStrategy = this.configuration.activeStrategy;\n            const strategyData = getStrategyData({\n                operationData,\n                viewport,\n                strategy: activeStrategy,\n            });\n            if (!operationData) {\n                return;\n            }\n            const memo = this.createMemo(operationData.segmentationId, strategyData.segmentationVoxelManager);\n            this._previewData.preview = this.applyActiveStrategyCallback(getEnabledElement(this._previewData.element), {\n                ...operationData,\n                ...strategyData,\n                memo,\n            }, StrategyCallbacks.Preview);\n        };\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.updateCursor(evt);\n            const { viewportIdsToRender } = this._hoverData;\n            triggerAnnotationRenderForViewportUIDs(viewportIdsToRender);\n            const delta = vec2.distance(currentPoints.canvas, this._previewData.startPoint);\n            const { dragTimeMs, dragMoveDistance } = this.configuration.preview;\n            if (!this._previewData.isDrag &&\n                Date.now() - this._previewData.timerStart < dragTimeMs &&\n                delta < dragMoveDistance) {\n                return;\n            }\n            if (this._previewData.timer) {\n                window.clearTimeout(this._previewData.timer);\n                this._previewData.timer = null;\n            }\n            if (!this._lastDragInfo) {\n                const startCanvas = this._previewData.startPoint;\n                const startWorld = viewport.canvasToWorld([\n                    startCanvas[0],\n                    startCanvas[1],\n                ]);\n                this._lastDragInfo = {\n                    canvas: vec2.clone(startCanvas),\n                    world: vec3.clone(startWorld),\n                };\n            }\n            const currentCanvas = currentPoints.canvas;\n            const currentWorld = viewport.canvasToWorld([\n                currentCanvas[0],\n                currentCanvas[1],\n            ]);\n            this._hoverData = this.createHoverData(element, currentCanvas);\n            this._calculateCursor(element, currentCanvas);\n            const operationData = this.getOperationData(element);\n            operationData.strokePointsWorld = [\n                vec3.clone(this._lastDragInfo.world),\n                vec3.clone(currentWorld),\n            ];\n            this._previewData.preview = this.applyActiveStrategy(enabledElement, operationData);\n            const currentCanvasClone = vec2.clone(currentCanvas);\n            this._lastDragInfo = {\n                canvas: currentCanvasClone,\n                world: vec3.clone(currentWorld),\n            };\n            this._previewData.element = element;\n            this._previewData.timerStart = Date.now() + dragTimeMs;\n            this._previewData.isDrag = true;\n            this._previewData.startPoint = currentCanvasClone;\n        };\n        this._endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const operationData = this.getOperationData(element);\n            if (!this._previewData.preview && !this._previewData.isDrag) {\n                this.applyActiveStrategy(enabledElement, operationData);\n            }\n            this.doneEditMemo();\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.updateCursor(evt);\n            this._editData = null;\n            this._lastDragInfo = null;\n            this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.OnInteractionEnd);\n            if (!this._previewData.isDrag) {\n                this.acceptPreview(element);\n            }\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    disableCursor() {\n        this._hoverData = undefined;\n        this.rejectPreview();\n    }\n    updateCursor(evt) {\n        const eventData = evt.detail;\n        const { element } = eventData;\n        const { currentPoints } = eventData;\n        const centerCanvas = currentPoints.canvas;\n        this._hoverData = this.createHoverData(element, centerCanvas);\n        this._calculateCursor(element, centerCanvas);\n        if (!this._hoverData) {\n            return;\n        }\n        triggerAnnotationRenderForViewportUIDs(this._hoverData.viewportIdsToRender);\n    }\n    _calculateCursor(element, centerCanvas) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { canvasToWorld } = viewport;\n        const camera = viewport.getCamera();\n        const { brushSize } = this.configuration;\n        const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n        const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n        const viewRight = vec3.create();\n        vec3.cross(viewRight, viewUp, viewPlaneNormal);\n        const centerCursorInWorld = canvasToWorld([\n            centerCanvas[0],\n            centerCanvas[1],\n        ]);\n        const bottomCursorInWorld = vec3.create();\n        const topCursorInWorld = vec3.create();\n        const leftCursorInWorld = vec3.create();\n        const rightCursorInWorld = vec3.create();\n        for (let i = 0; i <= 2; i++) {\n            bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;\n            topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;\n            leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;\n            rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;\n        }\n        if (!this._hoverData) {\n            return;\n        }\n        const { brushCursor } = this._hoverData;\n        const { data } = brushCursor;\n        if (data.handles === undefined) {\n            data.handles = {};\n        }\n        data.handles.points = [\n            bottomCursorInWorld,\n            topCursorInWorld,\n            leftCursorInWorld,\n            rightCursorInWorld,\n        ];\n        const activeStrategy = this.configuration.activeStrategy;\n        const strategy = this.configuration.strategies[activeStrategy];\n        if (typeof strategy?.computeInnerCircleRadius === 'function') {\n            strategy.computeInnerCircleRadius({\n                configuration: this.configuration,\n                viewport,\n            });\n        }\n        data.invalidated = false;\n    }\n    getStatistics(element, segmentIndices) {\n        if (!element) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const stats = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.GetStatistics, segmentIndices);\n        return stats;\n    }\n    rejectPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        this.doneEditMemo();\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.RejectPreview);\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    acceptPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        super.acceptPreview(element);\n    }\n    interpolate(element, config) {\n        if (!element) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        this._previewData.preview = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.Interpolate, config.configuration);\n        this._previewData.isDrag = true;\n    }\n    invalidateBrushCursor() {\n        if (this._hoverData === undefined) {\n            return;\n        }\n        const { data } = this._hoverData.brushCursor;\n        const { viewport } = this._hoverData;\n        data.invalidated = true;\n        const { segmentColor } = this.getActiveSegmentationData(viewport) || {};\n        this._hoverData.brushCursor.metadata.segmentColor = segmentColor;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this._hoverData) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const viewportIdsToRender = this._hoverData.viewportIdsToRender;\n        if (!viewportIdsToRender.includes(viewport.id)) {\n            return;\n        }\n        const brushCursor = this._hoverData.brushCursor;\n        if (brushCursor.data.invalidated === true) {\n            const { centerCanvas } = this._hoverData;\n            const { element } = viewport;\n            this._calculateCursor(element, centerCanvas);\n        }\n        const toolMetadata = brushCursor.metadata;\n        if (!toolMetadata) {\n            return;\n        }\n        const annotationUID = toolMetadata.brushCursorUID;\n        const data = brushCursor.data;\n        const { points } = data.handles;\n        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n        const bottom = canvasCoordinates[0];\n        const top = canvasCoordinates[1];\n        const center = [\n            Math.floor((bottom[0] + top[0]) / 2),\n            Math.floor((bottom[1] + top[1]) / 2),\n        ];\n        const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n        const color = `rgb(${toolMetadata.segmentColor?.slice(0, 3) || [0, 0, 0]})`;\n        if (!viewport.getRenderingEngine()) {\n            console.warn('Rendering Engine has been destroyed');\n            return;\n        }\n        const circleUID = '0';\n        drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n            color,\n            lineDash: this.centerSegmentIndexInfo.segmentIndex === 0 ? [1, 2] : null,\n        });\n        const { dynamicRadiusInCanvas } = this.configuration?.threshold || {\n            dynamicRadiusInCanvas: 0,\n        };\n        if (dynamicRadiusInCanvas) {\n            const circleUID1 = '1';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID1, center, dynamicRadiusInCanvas, {\n                color,\n            });\n        }\n    }\n}\nBrushTool.toolName = 'Brush';\nexport default BrushTool;\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../../../utilities/boundingBox';\nimport BrushStrategy from './BrushStrategy';\nimport { StrategyCallbacks } from '../../../enums';\nimport compositions from './compositions';\nimport { pointInSphere } from '../../../utilities/math/sphere';\nconst { transformWorldToIndex, transformIndexToWorld, isEqual } = csUtils;\nexport function getEllipseCornersFromCanvasCoordinates(canvasCoordinates) {\n    const [bottom, top, left, right] = canvasCoordinates;\n    const topLeft = [left[0], top[1]];\n    const bottomRight = [right[0], bottom[1]];\n    const bottomLeft = [left[0], bottom[1]];\n    const topRight = [right[0], top[1]];\n    return [topLeft, bottomRight, bottomLeft, topRight];\n}\nfunction createCircleCornersForCenter(center, viewUp, viewRight, radius) {\n    const centerVec = vec3.fromValues(center[0], center[1], center[2]);\n    const top = vec3.create();\n    vec3.scaleAndAdd(top, centerVec, viewUp, radius);\n    const bottom = vec3.create();\n    vec3.scaleAndAdd(bottom, centerVec, viewUp, -radius);\n    const right = vec3.create();\n    vec3.scaleAndAdd(right, centerVec, viewRight, radius);\n    const left = vec3.create();\n    vec3.scaleAndAdd(left, centerVec, viewRight, -radius);\n    return [\n        bottom,\n        top,\n        left,\n        right,\n    ];\n}\nfunction createStrokePredicate(centers, radius) {\n    if (!centers.length || radius <= 0) {\n        return null;\n    }\n    const radiusSquared = radius * radius;\n    const centerVecs = centers.map((point) => [point[0], point[1], point[2]]);\n    const segments = [];\n    for (let i = 1; i < centerVecs.length; i++) {\n        const start = centerVecs[i - 1];\n        const end = centerVecs[i];\n        const dx = end[0] - start[0];\n        const dy = end[1] - start[1];\n        const dz = end[2] - start[2];\n        const lengthSquared = dx * dx + dy * dy + dz * dz;\n        segments.push({ start, vector: [dx, dy, dz], lengthSquared });\n    }\n    return (worldPoint) => {\n        if (!worldPoint) {\n            return false;\n        }\n        for (const centerVec of centerVecs) {\n            const dx = worldPoint[0] - centerVec[0];\n            const dy = worldPoint[1] - centerVec[1];\n            const dz = worldPoint[2] - centerVec[2];\n            if (dx * dx + dy * dy + dz * dz <= radiusSquared) {\n                return true;\n            }\n        }\n        for (const { start, vector, lengthSquared } of segments) {\n            if (lengthSquared === 0) {\n                const dx = worldPoint[0] - start[0];\n                const dy = worldPoint[1] - start[1];\n                const dz = worldPoint[2] - start[2];\n                if (dx * dx + dy * dy + dz * dz <= radiusSquared) {\n                    return true;\n                }\n                continue;\n            }\n            const dx = worldPoint[0] - start[0];\n            const dy = worldPoint[1] - start[1];\n            const dz = worldPoint[2] - start[2];\n            const dot = dx * vector[0] + dy * vector[1] + dz * vector[2];\n            const t = Math.max(0, Math.min(1, dot / lengthSquared));\n            const projX = start[0] + vector[0] * t;\n            const projY = start[1] + vector[1] * t;\n            const projZ = start[2] + vector[2] * t;\n            const distX = worldPoint[0] - projX;\n            const distY = worldPoint[1] - projY;\n            const distZ = worldPoint[2] - projZ;\n            if (distX * distX + distY * distY + distZ * distZ <= radiusSquared) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nconst initializeCircle = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, viewport, segmentationImageData, viewUp, viewPlaneNormal, } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.create();\n        if (points.length >= 2) {\n            vec3.add(center, points[0], points[1]);\n            vec3.scale(center, center, 0.5);\n        }\n        else {\n            vec3.copy(center, points[0]);\n        }\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const brushRadius = points.length >= 2 ? vec3.distance(points[0], points[1]) / 2 : 0;\n        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n        const corners = getEllipseCornersFromCanvasCoordinates(canvasCoordinates);\n        const cornersInWorld = corners.map((corner) => viewport.canvasToWorld(corner));\n        const normalizedViewUp = vec3.fromValues(viewUp[0], viewUp[1], viewUp[2]);\n        vec3.normalize(normalizedViewUp, normalizedViewUp);\n        const normalizedPlaneNormal = vec3.fromValues(viewPlaneNormal[0], viewPlaneNormal[1], viewPlaneNormal[2]);\n        vec3.normalize(normalizedPlaneNormal, normalizedPlaneNormal);\n        const viewRight = vec3.create();\n        vec3.cross(viewRight, normalizedViewUp, normalizedPlaneNormal);\n        vec3.normalize(viewRight, viewRight);\n        const strokeCentersSource = operationData.strokePointsWorld &&\n            operationData.strokePointsWorld.length > 0\n            ? operationData.strokePointsWorld\n            : [operationData.centerWorld];\n        const strokeCenters = strokeCentersSource.map((point) => vec3.clone(point));\n        const strokeCornersWorld = strokeCenters.flatMap((centerPoint) => createCircleCornersForCenter(centerPoint, normalizedViewUp, viewRight, brushRadius));\n        const circleCornersIJK = strokeCornersWorld.map((world) => transformWorldToIndex(segmentationImageData, world));\n        const boundsIJK = getBoundingBoxAroundShapeIJK(circleCornersIJK, segmentationImageData.getDimensions());\n        operationData.strokePointsWorld = strokeCenters;\n        operationData.isInObject = createPointInEllipse(cornersInWorld, {\n            strokePointsWorld: strokeCenters,\n            segmentationImageData,\n            radius: brushRadius,\n        });\n        operationData.isInObjectBoundsIJK = boundsIJK;\n    },\n};\nfunction createPointInEllipse(cornersInWorld = [], options = {}) {\n    if (!cornersInWorld || cornersInWorld.length !== 4) {\n        throw new Error('createPointInEllipse: cornersInWorld must have 4 points');\n    }\n    const [topLeft, bottomRight, bottomLeft, topRight] = cornersInWorld;\n    const center = vec3.create();\n    vec3.add(center, topLeft, bottomRight);\n    vec3.scale(center, center, 0.5);\n    const majorAxisVec = vec3.create();\n    vec3.subtract(majorAxisVec, topRight, topLeft);\n    const xRadius = vec3.length(majorAxisVec) / 2;\n    vec3.normalize(majorAxisVec, majorAxisVec);\n    const minorAxisVec = vec3.create();\n    vec3.subtract(minorAxisVec, bottomLeft, topLeft);\n    const yRadius = vec3.length(minorAxisVec) / 2;\n    vec3.normalize(minorAxisVec, minorAxisVec);\n    const normal = vec3.create();\n    vec3.cross(normal, majorAxisVec, minorAxisVec);\n    vec3.normalize(normal, normal);\n    const radiusForStroke = options.radius ?? Math.max(xRadius, yRadius);\n    const strokePredicate = createStrokePredicate(options.strokePointsWorld || [], radiusForStroke);\n    if (isEqual(xRadius, yRadius)) {\n        const radius = xRadius;\n        const sphereObj = {\n            center,\n            radius,\n            radius2: radius * radius,\n        };\n        return (pointLPS, pointIJK) => {\n            let worldPoint = pointLPS;\n            if (!worldPoint && pointIJK && options.segmentationImageData) {\n                worldPoint = transformIndexToWorld(options.segmentationImageData, pointIJK);\n            }\n            if (!worldPoint) {\n                return false;\n            }\n            if (strokePredicate?.(worldPoint)) {\n                return true;\n            }\n            return pointInSphere(sphereObj, worldPoint);\n        };\n    }\n    return (pointLPS, pointIJK) => {\n        let worldPoint = pointLPS;\n        if (!worldPoint && pointIJK && options.segmentationImageData) {\n            worldPoint = transformIndexToWorld(options.segmentationImageData, pointIJK);\n        }\n        if (!worldPoint) {\n            return false;\n        }\n        if (strokePredicate?.(worldPoint)) {\n            return true;\n        }\n        const pointVec = vec3.create();\n        vec3.subtract(pointVec, worldPoint, center);\n        const distToPlane = vec3.dot(pointVec, normal);\n        const proj = vec3.create();\n        vec3.scaleAndAdd(proj, pointVec, normal, -distToPlane);\n        const fromTopLeft = vec3.create();\n        const centerToTopLeft = vec3.create();\n        vec3.subtract(centerToTopLeft, center, topLeft);\n        vec3.subtract(fromTopLeft, proj, centerToTopLeft);\n        const x = vec3.dot(fromTopLeft, majorAxisVec);\n        const y = vec3.dot(fromTopLeft, minorAxisVec);\n        return (x * x) / (xRadius * xRadius) + (y * y) / (yRadius * yRadius) <= 1;\n    };\n}\nconst CIRCLE_STRATEGY = new BrushStrategy('Circle', compositions.regionFill, compositions.setValue, initializeCircle, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics);\nconst CIRCLE_THRESHOLD_STRATEGY = new BrushStrategy('CircleThreshold', compositions.regionFill, compositions.setValue, initializeCircle, compositions.determineSegmentIndex, compositions.dynamicThreshold, compositions.threshold, compositions.preview, compositions.islandRemoval, compositions.labelmapStatistics);\nconst fillInsideCircle = CIRCLE_STRATEGY.strategyFunction;\nconst thresholdInsideCircle = CIRCLE_THRESHOLD_STRATEGY.strategyFunction;\nexport function fillOutsideCircle() {\n    throw new Error('Not yet implemented');\n}\nexport { CIRCLE_STRATEGY, CIRCLE_THRESHOLD_STRATEGY, fillInsideCircle, thresholdInsideCircle, createPointInEllipse, createPointInEllipse as createEllipseInPoint, };\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils, StackViewport } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../../../utilities/boundingBox';\nimport BrushStrategy from './BrushStrategy';\nimport { StrategyCallbacks } from '../../../enums';\nimport compositions from './compositions';\nconst { transformWorldToIndex } = csUtils;\nconst initializeRectangle = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, viewport, segmentationImageData, } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.fromValues(0, 0, 0);\n        points.forEach((point) => {\n            vec3.add(center, center, point);\n        });\n        vec3.scale(center, center, 1 / points.length);\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const { boundsIJK, pointInShapeFn } = createPointInRectangle(viewport, points, segmentationImageData);\n        operationData.isInObject = pointInShapeFn;\n        operationData.isInObjectBoundsIJK = boundsIJK;\n    },\n};\nfunction createPointInRectangle(viewport, points, segmentationImageData) {\n    let rectangleCornersIJK = points.map((world) => {\n        return transformWorldToIndex(segmentationImageData, world);\n    });\n    rectangleCornersIJK = rectangleCornersIJK.map((point) => {\n        return point.map((coord) => {\n            return Math.round(coord);\n        });\n    });\n    const boundsIJK = getBoundingBoxAroundShapeIJK(rectangleCornersIJK, segmentationImageData.getDimensions());\n    const [p0, p1, p2, p3] = points;\n    const axisU = vec3.create();\n    const axisV = vec3.create();\n    vec3.subtract(axisU, p1, p0);\n    vec3.subtract(axisV, p3, p0);\n    const uLen = vec3.length(axisU);\n    const vLen = vec3.length(axisV);\n    vec3.normalize(axisU, axisU);\n    vec3.normalize(axisV, axisV);\n    const normal = vec3.create();\n    vec3.cross(normal, axisU, axisV);\n    vec3.normalize(normal, normal);\n    const direction = segmentationImageData.getDirection();\n    const spacing = segmentationImageData.getSpacing();\n    const { viewPlaneNormal } = viewport.getCamera();\n    const EPS = csUtils.getSpacingInNormalDirection({\n        direction,\n        spacing,\n    }, viewPlaneNormal);\n    const pointInShapeFn = (pointLPS) => {\n        const v = vec3.create();\n        vec3.subtract(v, pointLPS, p0);\n        const u = vec3.dot(v, axisU);\n        const vproj = vec3.dot(v, axisV);\n        const d = Math.abs(vec3.dot(v, normal));\n        return (u >= -EPS &&\n            u <= uLen + EPS &&\n            vproj >= -EPS &&\n            vproj <= vLen + EPS &&\n            d <= EPS);\n    };\n    return { boundsIJK, pointInShapeFn };\n}\nconst RECTANGLE_STRATEGY = new BrushStrategy('Rectangle', compositions.regionFill, compositions.setValue, initializeRectangle, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics);\nconst RECTANGLE_THRESHOLD_STRATEGY = new BrushStrategy('RectangleThreshold', compositions.regionFill, compositions.setValue, initializeRectangle, compositions.determineSegmentIndex, compositions.dynamicThreshold, compositions.threshold, compositions.preview, compositions.islandRemoval, compositions.labelmapStatistics);\nconst fillInsideRectangle = RECTANGLE_STRATEGY.strategyFunction;\nconst thresholdInsideRectangle = RECTANGLE_THRESHOLD_STRATEGY.strategyFunction;\nexport { RECTANGLE_STRATEGY, RECTANGLE_THRESHOLD_STRATEGY, fillInsideRectangle, thresholdInsideRectangle, };\n","import { utilities, BaseVolumeViewport, StackViewport, cache, metaData, } from '@cornerstonejs/core';\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\nimport { vec3 } from 'gl-matrix';\nfunction annotationHydration(viewport, toolName, worldPoints, options) {\n    const viewReference = viewport.getViewReference();\n    const { viewPlaneNormal, FrameOfReferenceUID } = viewReference;\n    const annotation = {\n        annotationUID: options?.annotationUID || utilities.uuidv4(),\n        data: {\n            handles: {\n                points: worldPoints,\n            },\n        },\n        highlighted: false,\n        autoGenerated: false,\n        invalidated: false,\n        isLocked: false,\n        isVisible: true,\n        metadata: {\n            toolName,\n            viewPlaneNormal,\n            FrameOfReferenceUID,\n            referencedImageId: getReferencedImageId(viewport, worldPoints[0], viewPlaneNormal),\n            ...options,\n        },\n    };\n    addAnnotation(annotation, viewport.element);\n    return annotation;\n}\nfunction getReferencedImageId(viewport, worldPos, viewPlaneNormal) {\n    let referencedImageId;\n    if (viewport instanceof StackViewport) {\n        referencedImageId = getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal);\n    }\n    else if (viewport instanceof BaseVolumeViewport) {\n        const targetId = getTargetId(viewport);\n        const volumeId = utilities.getVolumeId(targetId);\n        const imageVolume = cache.getVolume(volumeId);\n        referencedImageId = utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n    }\n    else {\n        throw new Error('getReferencedImageId: viewport must be a StackViewport or BaseVolumeViewport');\n    }\n    return referencedImageId;\n}\nfunction getTargetId(viewport) {\n    const targetId = viewport.getViewReferenceId?.();\n    if (targetId) {\n        return targetId;\n    }\n    if (viewport instanceof BaseVolumeViewport) {\n        return `volumeId:${getTargetVolumeId(viewport)}`;\n    }\n    throw new Error('getTargetId: viewport must have a getTargetId method');\n}\nfunction getTargetVolumeId(viewport) {\n    const actorEntries = viewport.getActors();\n    if (!actorEntries) {\n        return;\n    }\n    return actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume')?.uid;\n}\nfunction getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal) {\n    const imageIds = viewport.getImageIds();\n    if (!imageIds || !imageIds.length) {\n        return;\n    }\n    const distanceImagePairs = imageIds.map((imageId) => {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const distance = calculateDistanceToImage(worldPos, imagePositionPatient, viewPlaneNormal);\n        return { imageId, distance };\n    });\n    distanceImagePairs.sort((a, b) => a.distance - b.distance);\n    return distanceImagePairs[0].imageId;\n}\nfunction calculateDistanceToImage(worldPos, ImagePositionPatient, viewPlaneNormal) {\n    const dir = vec3.create();\n    vec3.sub(dir, worldPos, ImagePositionPatient);\n    const dot = vec3.dot(dir, viewPlaneNormal);\n    return Math.abs(dot);\n}\nexport { annotationHydration, getClosestImageIdForStackViewport };\n","import { CONSTANTS } from '@cornerstonejs/core';\nconst { EPSILON } = CONSTANTS;\nfunction calculateBoundingBox(points, dimensions, isWorld = false) {\n    let xMin = Infinity;\n    let xMax = isWorld ? -Infinity : 0;\n    let yMin = Infinity;\n    let yMax = isWorld ? -Infinity : 0;\n    let zMin = Infinity;\n    let zMax = isWorld ? -Infinity : 0;\n    const is3D = points[0]?.length === 3;\n    for (let i = 0; i < points.length; i++) {\n        const p = points[i];\n        xMin = Math.min(p[0], xMin);\n        xMax = Math.max(p[0], xMax);\n        yMin = Math.min(p[1], yMin);\n        yMax = Math.max(p[1], yMax);\n        if (is3D) {\n            zMin = Math.min(p[2] ?? zMin, zMin);\n            zMax = Math.max(p[2] ?? zMax, zMax);\n        }\n    }\n    if (dimensions) {\n        xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);\n        xMax = Math.min(isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1, xMax);\n        yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);\n        yMax = Math.min(isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1, yMax);\n        if (is3D && dimensions.length === 3) {\n            zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);\n            zMax = Math.min(isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1, zMax);\n        }\n    }\n    else if (!isWorld) {\n        xMin = Math.max(0, xMin);\n        xMax = Math.min(Infinity, xMax);\n        yMin = Math.max(0, yMin);\n        yMax = Math.min(Infinity, yMax);\n        if (is3D) {\n            zMin = Math.max(0, zMin);\n            zMax = Math.min(Infinity, zMax);\n        }\n    }\n    return is3D\n        ? [\n            [xMin, xMax],\n            [yMin, yMax],\n            [zMin, zMax],\n        ]\n        : [[xMin, xMax], [yMin, yMax], null];\n}\nexport function getBoundingBoxAroundShapeIJK(points, dimensions) {\n    return calculateBoundingBox(points, dimensions, false);\n}\nexport function getBoundingBoxAroundShapeWorld(points, clipBounds) {\n    return calculateBoundingBox(points, clipBounds, true);\n}\n","function findNextLink(line, lines, contourPoints) {\n    let index = -1;\n    lines.forEach((cell, i) => {\n        if (index >= 0) {\n            return;\n        }\n        if (cell.a == line.b) {\n            index = i;\n        }\n    });\n    if (index >= 0) {\n        const nextLine = lines[index];\n        lines.splice(index, 1);\n        contourPoints.push(nextLine.b);\n        if (contourPoints[0] == nextLine.b) {\n            return {\n                remainingLines: lines,\n                contourPoints,\n                type: 'CLOSED_PLANAR',\n            };\n        }\n        return findNextLink(nextLine, lines, contourPoints);\n    }\n    return {\n        remainingLines: lines,\n        contourPoints,\n        type: 'OPEN_PLANAR',\n    };\n}\nexport function findContours(lines) {\n    if (lines.length == 0) {\n        return [];\n    }\n    const contourPoints = [];\n    const firstCell = lines.shift();\n    contourPoints.push(firstCell.a);\n    contourPoints.push(firstCell.b);\n    const result = findNextLink(firstCell, lines, contourPoints);\n    if (result.remainingLines.length == 0) {\n        return [\n            {\n                type: result.type,\n                contourPoints: result.contourPoints,\n            },\n        ];\n    }\n    else {\n        const extraContours = findContours(result.remainingLines);\n        extraContours.push({\n            type: result.type,\n            contourPoints: result.contourPoints,\n        });\n        return extraContours;\n    }\n}\nexport function findContoursFromReducedSet(lines) {\n    return findContours(lines);\n}\nexport default {\n    findContours,\n    findContoursFromReducedSet,\n};\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nconst { isEqual } = csUtils;\nexport default function findHandlePolylineIndex(annotation, handleIndex) {\n    const { polyline } = annotation.data.contour;\n    const { points } = annotation.data.handles;\n    const { length } = points;\n    if (handleIndex === length) {\n        return polyline.length;\n    }\n    if (handleIndex < 0) {\n        handleIndex = (handleIndex + length) % length;\n    }\n    if (handleIndex === 0) {\n        return 0;\n    }\n    const handle = points[handleIndex];\n    const index = polyline.findIndex((point) => isEqual(handle, point));\n    if (index !== -1) {\n        return index;\n    }\n    let closestDistance = Infinity;\n    return polyline.reduce((closestIndex, point, testIndex) => {\n        const distance = vec3.squaredDistance(point, handle);\n        if (distance < closestDistance) {\n            closestDistance = distance;\n            return testIndex;\n        }\n        return closestIndex;\n    }, -1);\n}\n","export function getDeduplicatedVTKPolyDataPoints(polyData, bypass = false) {\n    const points = polyData.getPoints();\n    const lines = polyData.getLines();\n    const pointsArray = new Array(points.getNumberOfPoints())\n        .fill(0)\n        .map((_, i) => points.getPoint(i).slice());\n    const linesArray = new Array(lines.getNumberOfCells()).fill(0).map((_, i) => {\n        const cell = lines.getCell(i * 3).slice();\n        return { a: cell[0], b: cell[1] };\n    });\n    if (bypass) {\n        return { points: pointsArray, lines: linesArray };\n    }\n    const newPoints = [];\n    for (const [i, pt] of pointsArray.entries()) {\n        const index = newPoints.findIndex((point) => point[0] === pt[0] && point[1] === pt[1] && point[2] === pt[2]);\n        if (index >= 0) {\n            linesArray.map((line) => {\n                if (line.a === i) {\n                    line.a = index;\n                }\n                if (line.b === i) {\n                    line.b = index;\n                }\n                return line;\n            });\n        }\n        else {\n            const newIndex = newPoints.length;\n            newPoints.push(pt);\n            linesArray.map((line) => {\n                if (line.a === i) {\n                    line.a = newIndex;\n                }\n                if (line.b === i) {\n                    line.b = newIndex;\n                }\n                return line;\n            });\n        }\n    }\n    const newLines = linesArray.filter((line) => line.a !== line.b);\n    return { points: newPoints, lines: newLines };\n}\nexport default { getDeduplicatedVTKPolyDataPoints };\n","import { Enums, utilities } from '@cornerstonejs/core';\nconst { CalibrationTypes } = Enums;\nconst PIXEL_UNITS = 'px';\nconst VOXEL_UNITS = 'voxels';\nconst SUPPORTED_REGION_DATA_TYPES = [\n    1,\n    2,\n    3,\n    4,\n];\nconst SUPPORTED_LENGTH_VARIANT = [\n    '3,3',\n    '4,7',\n];\nconst SUPPORTED_PROBE_VARIANT = [\n    '4,3',\n    '4,7',\n];\nconst UNIT_MAPPING = {\n    0: 'px',\n    1: 'percent',\n    2: 'dB',\n    3: 'cm',\n    4: 'seconds',\n    5: 'hertz',\n    6: 'dB/seconds',\n    7: 'cm/sec',\n    8: 'cm\\xb2',\n    9: 'cm\\xb2/s',\n    0xc: 'degrees',\n};\nconst EPS = 1e-3;\nconst SQUARE = '\\xb2';\nconst getCalibratedLengthUnitsAndScale = (image, handles) => {\n    const { calibration, hasPixelSpacing } = image;\n    let unit = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\n    const volumeUnit = hasPixelSpacing ? 'mm\\xb3' : VOXEL_UNITS;\n    let areaUnit = unit + SQUARE;\n    let scale = 1;\n    let calibrationType = '';\n    if (!calibration ||\n        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {\n        return { unit, areaUnit, scale, volumeUnit };\n    }\n    if (calibration.type === CalibrationTypes.UNCALIBRATED) {\n        return {\n            unit: PIXEL_UNITS,\n            areaUnit: PIXEL_UNITS + SQUARE,\n            scale,\n            volumeUnit: VOXEL_UNITS,\n        };\n    }\n    if (calibration.sequenceOfUltrasoundRegions) {\n        let imageIndex1, imageIndex2;\n        if (Array.isArray(handles) && handles.length === 2) {\n            [imageIndex1, imageIndex2] = handles;\n        }\n        else if (typeof handles === 'function') {\n            const points = handles();\n            imageIndex1 = points[0];\n            imageIndex2 = points[1];\n        }\n        let regions = calibration.sequenceOfUltrasoundRegions.filter((region) => imageIndex1[0] >= region.regionLocationMinX0 &&\n            imageIndex1[0] <= region.regionLocationMaxX1 &&\n            imageIndex1[1] >= region.regionLocationMinY0 &&\n            imageIndex1[1] <= region.regionLocationMaxY1 &&\n            imageIndex2[0] >= region.regionLocationMinX0 &&\n            imageIndex2[0] <= region.regionLocationMaxX1 &&\n            imageIndex2[1] >= region.regionLocationMinY0 &&\n            imageIndex2[1] <= region.regionLocationMaxY1);\n        if (!regions?.length) {\n            return { unit, areaUnit, scale, volumeUnit };\n        }\n        regions = regions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n            SUPPORTED_LENGTH_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));\n        if (!regions.length) {\n            return {\n                unit: PIXEL_UNITS,\n                areaUnit: PIXEL_UNITS + SQUARE,\n                scale,\n                volumeUnit: VOXEL_UNITS,\n            };\n        }\n        const region = regions[0];\n        const physicalDeltaX = Math.abs(region.physicalDeltaX);\n        const physicalDeltaY = Math.abs(region.physicalDeltaY);\n        const isSamePhysicalDelta = utilities.isEqual(physicalDeltaX, physicalDeltaY, EPS);\n        if (isSamePhysicalDelta) {\n            scale = 1 / physicalDeltaX;\n            calibrationType = 'US Region';\n            unit = UNIT_MAPPING[region.physicalUnitsXDirection] || 'unknown';\n            areaUnit = unit + SQUARE;\n        }\n        else {\n            return {\n                unit: PIXEL_UNITS,\n                areaUnit: PIXEL_UNITS + SQUARE,\n                scale,\n                volumeUnit: VOXEL_UNITS,\n            };\n        }\n    }\n    else if (calibration.scale) {\n        scale = calibration.scale;\n    }\n    const types = [\n        CalibrationTypes.ERMF,\n        CalibrationTypes.USER,\n        CalibrationTypes.ERROR,\n        CalibrationTypes.PROJECTION,\n        CalibrationTypes.CALIBRATED,\n        CalibrationTypes.UNKNOWN,\n    ];\n    if (types.includes(calibration?.type)) {\n        calibrationType = calibration.type;\n    }\n    return {\n        unit: unit + (calibrationType ? ` ${calibrationType}` : ''),\n        areaUnit: areaUnit + (calibrationType ? ` ${calibrationType}` : ''),\n        scale,\n        volumeUnit: volumeUnit + (calibrationType ? ` ${calibrationType}` : ''),\n    };\n};\nconst getCalibratedProbeUnitsAndValue = (image, handles) => {\n    const [imageIndex] = handles;\n    const { calibration } = image;\n    let units = ['raw'];\n    let values = [null];\n    let calibrationType = '';\n    if (!calibration ||\n        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {\n        return { units, values };\n    }\n    if (calibration.sequenceOfUltrasoundRegions) {\n        const supportedRegionsMetadata = calibration.sequenceOfUltrasoundRegions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n            SUPPORTED_PROBE_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));\n        if (!supportedRegionsMetadata?.length) {\n            return { units, values };\n        }\n        const region = supportedRegionsMetadata.find((region) => imageIndex[0] >= region.regionLocationMinX0 &&\n            imageIndex[0] <= region.regionLocationMaxX1 &&\n            imageIndex[1] >= region.regionLocationMinY0 &&\n            imageIndex[1] <= region.regionLocationMaxY1);\n        if (!region) {\n            return { units, values };\n        }\n        const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;\n        const { physicalDeltaX, physicalDeltaY } = region;\n        const yValue = (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *\n            physicalDeltaY;\n        const xValue = (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *\n            physicalDeltaX;\n        calibrationType = 'US Region';\n        values = [xValue, yValue];\n        units = [\n            UNIT_MAPPING[region.physicalUnitsXDirection],\n            UNIT_MAPPING[region.physicalUnitsYDirection],\n        ];\n    }\n    return {\n        units,\n        values,\n        calibrationType,\n    };\n};\nconst getCalibratedAspect = (image) => image.calibration?.aspect || 1;\nexport { getCalibratedLengthUnitsAndScale, getCalibratedAspect, getCalibratedProbeUnitsAndValue, };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { getBoundingBoxAroundShapeIJK } from './boundingBox';\nconst { transformWorldToIndex } = csUtils;\nfunction _getSphereBoundsInfo(circlePoints, imageData, directionVectors) {\n    const [bottom, top] = circlePoints;\n    const centerWorld = vec3.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);\n    const radiusWorld = vec3.distance(bottom, top) / 2;\n    const { boundsIJK, topLeftWorld, bottomRightWorld } = _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld);\n    return {\n        boundsIJK,\n        centerWorld: centerWorld,\n        radiusWorld,\n        topLeftWorld: topLeftWorld,\n        bottomRightWorld: bottomRightWorld,\n    };\n}\nfunction getSphereBoundsInfo(circlePoints, imageData) {\n    const direction = imageData.getDirection();\n    const rowCosine = vec3.fromValues(direction[0], direction[1], direction[2]);\n    const columnCosine = vec3.fromValues(direction[3], direction[4], direction[5]);\n    const scanAxis = vec3.fromValues(direction[6], direction[7], direction[8]);\n    const viewPlaneNormal = vec3.negate(vec3.create(), scanAxis);\n    const directionVectors = {\n        row: rowCosine,\n        column: columnCosine,\n        normal: viewPlaneNormal,\n    };\n    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);\n}\nfunction getSphereBoundsInfoFromViewport(circlePoints, imageData, viewport) {\n    if (!viewport) {\n        throw new Error('viewport is required in order to calculate the sphere bounds');\n    }\n    const camera = viewport.getCamera();\n    const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n    const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const directionVectors = {\n        row: viewRight,\n        normal: viewPlaneNormal,\n        column: vec3.negate(vec3.create(), viewUp),\n    };\n    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);\n}\nfunction _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld) {\n    const dimensions = imageData.getDimensions();\n    const { row: rowCosine, column: columnCosine, normal: vecNormal, } = directionVectors;\n    const topLeftWorld = vec3.create();\n    const bottomRightWorld = vec3.create();\n    vec3.scaleAndAdd(topLeftWorld, centerWorld, vecNormal, radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, centerWorld, vecNormal, -radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, columnCosine, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, columnCosine, radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, rowCosine, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, rowCosine, radiusWorld);\n    const topLeftIJK = transformWorldToIndex(imageData, topLeftWorld);\n    const bottomRightIJK = transformWorldToIndex(imageData, bottomRightWorld);\n    const pointsIJK = circlePoints.map((p) => transformWorldToIndex(imageData, p));\n    const boundsIJK = getBoundingBoxAroundShapeIJK([topLeftIJK, bottomRightIJK, ...pointsIJK], dimensions);\n    return { boundsIJK, topLeftWorld, bottomRightWorld };\n}\nexport { getSphereBoundsInfo, getSphereBoundsInfoFromViewport };\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nexport default function getToolsWithModesForElement(element, modesFilter) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngineId, viewportId } = enabledElement;\n    const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n    if (!toolGroup) {\n        return [];\n    }\n    const enabledTools = [];\n    const toolGroupToolNames = Object.keys(toolGroup.toolOptions);\n    for (let j = 0; j < toolGroupToolNames.length; j++) {\n        const toolName = toolGroupToolNames[j];\n        const toolOptions = toolGroup.toolOptions[toolName];\n        if (!toolOptions) {\n            continue;\n        }\n        if (modesFilter.includes(toolOptions.mode)) {\n            const toolInstance = toolGroup.getToolInstance(toolName);\n            enabledTools.push(toolInstance);\n        }\n    }\n    return enabledTools;\n}\n","export class Calculator {\n}\nexport class InstanceCalculator {\n    constructor(options) {\n        this.storePointData = options.storePointData;\n    }\n    getStatistics() {\n        console.debug('InstanceCalculator getStatistics called');\n    }\n}\n","import distanceToPointSquaredInfo from './distanceToPointSquaredInfo';\nexport default function distanceToPointSquared(lineStart, lineEnd, point) {\n    return distanceToPointSquaredInfo(lineStart, lineEnd, point).distanceSquared;\n}\n","import { distanceToPointSquared } from '../point';\nexport default function distanceToPointSquaredInfo(lineStart, lineEnd, point) {\n    let closestPoint;\n    const distanceSquared = distanceToPointSquared(lineStart, lineEnd);\n    if (lineStart[0] === lineEnd[0] && lineStart[1] === lineEnd[1]) {\n        closestPoint = lineStart;\n    }\n    if (!closestPoint) {\n        const dotProduct = ((point[0] - lineStart[0]) * (lineEnd[0] - lineStart[0]) +\n            (point[1] - lineStart[1]) * (lineEnd[1] - lineStart[1])) /\n            distanceSquared;\n        if (dotProduct < 0) {\n            closestPoint = lineStart;\n        }\n        else if (dotProduct > 1) {\n            closestPoint = lineEnd;\n        }\n        else {\n            closestPoint = [\n                lineStart[0] + dotProduct * (lineEnd[0] - lineStart[0]),\n                lineStart[1] + dotProduct * (lineEnd[1] - lineStart[1]),\n            ];\n        }\n    }\n    return {\n        point: [...closestPoint],\n        distanceSquared: distanceToPointSquared(point, closestPoint),\n    };\n}\n","const ORIENTATION_TOLERANCE = 1e-2;\nexport default function isPointOnLineSegment(lineStart, lineEnd, point) {\n    const minX = lineStart[0] <= lineEnd[0] ? lineStart[0] : lineEnd[0];\n    const maxX = lineStart[0] >= lineEnd[0] ? lineStart[0] : lineEnd[0];\n    const minY = lineStart[1] <= lineEnd[1] ? lineStart[1] : lineEnd[1];\n    const maxY = lineStart[1] >= lineEnd[1] ? lineStart[1] : lineEnd[1];\n    const aabbContainsPoint = point[0] >= minX - ORIENTATION_TOLERANCE &&\n        point[0] <= maxX + ORIENTATION_TOLERANCE &&\n        point[1] >= minY - ORIENTATION_TOLERANCE &&\n        point[1] <= maxY + ORIENTATION_TOLERANCE;\n    if (!aabbContainsPoint) {\n        return false;\n    }\n    const orientation = (lineEnd[1] - lineStart[1]) * (point[0] - lineEnd[0]) -\n        (lineEnd[0] - lineStart[0]) * (point[1] - lineEnd[1]);\n    const absOrientation = orientation >= 0 ? orientation : -orientation;\n    return absOrientation <= ORIENTATION_TOLERANCE;\n}\n","export default function distanceToPointSquared(p1, p2) {\n    if (p1.length !== p2.length) {\n        throw Error('Both points should have the same dimensionality');\n    }\n    const [x1, y1, z1 = 0] = p1;\n    const [x2, y2, z2 = 0] = p2;\n    const dx = x2 - x1;\n    const dy = y2 - y1;\n    const dz = z2 - z1;\n    return dx * dx + dy * dy + dz * dz;\n}\n","import distanceToPointSquared from './distanceToPointSquared';\nexport default function distanceToPoint(p1, p2) {\n    return Math.sqrt(distanceToPointSquared(p1, p2));\n}\n","export default function mirror(mirrorPoint, staticPoint) {\n    const [x1, y1] = mirrorPoint;\n    const [x2, y2] = staticPoint;\n    const newX = 2 * x2 - x1;\n    const newY = 2 * y2 - y1;\n    return [newX, newY];\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { vec2, vec3 } from 'gl-matrix';\nconst addCanvasPointsToArray = (element, canvasPoints, newCanvasPoint, commonData) => {\n    const { xDir, yDir, spacing } = commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    if (!canvasPoints.length) {\n        canvasPoints.push(newCanvasPoint);\n        console.log('>>>>> !canvasPoints. :: RETURN');\n        return 1;\n    }\n    const lastWorldPos = viewport.canvasToWorld(canvasPoints[canvasPoints.length - 1]);\n    const newWorldPos = viewport.canvasToWorld(newCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, newWorldPos, lastWorldPos);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    const numPointsToAdd = Math.max(Math.floor(xDist / spacing[0]), Math.floor(yDist / spacing[0]));\n    if (numPointsToAdd > 1) {\n        const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n        const canvasDist = vec2.dist(lastCanvasPoint, newCanvasPoint);\n        const canvasDir = vec2.create();\n        vec2.subtract(canvasDir, newCanvasPoint, lastCanvasPoint);\n        vec2.set(canvasDir, canvasDir[0] / canvasDist, canvasDir[1] / canvasDist);\n        const distPerPoint = canvasDist / numPointsToAdd;\n        for (let i = 1; i <= numPointsToAdd; i++) {\n            canvasPoints.push([\n                lastCanvasPoint[0] + distPerPoint * canvasDir[0] * i,\n                lastCanvasPoint[1] + distPerPoint * canvasDir[1] * i,\n            ]);\n        }\n    }\n    else {\n        canvasPoints.push(newCanvasPoint);\n    }\n    return numPointsToAdd;\n};\nexport default addCanvasPointsToArray;\n","export default function areLineSegmentsIntersecting(p1, q1, p2, q2) {\n    let result = false;\n    const line1MinX = p1[0] < q1[0] ? p1[0] : q1[0];\n    const line1MinY = p1[1] < q1[1] ? p1[1] : q1[1];\n    const line1MaxX = p1[0] > q1[0] ? p1[0] : q1[0];\n    const line1MaxY = p1[1] > q1[1] ? p1[1] : q1[1];\n    const line2MinX = p2[0] < q2[0] ? p2[0] : q2[0];\n    const line2MinY = p2[1] < q2[1] ? p2[1] : q2[1];\n    const line2MaxX = p2[0] > q2[0] ? p2[0] : q2[0];\n    const line2MaxY = p2[1] > q2[1] ? p2[1] : q2[1];\n    if (line1MinX > line2MaxX ||\n        line1MaxX < line2MinX ||\n        line1MinY > line2MaxY ||\n        line1MaxY < line2MinY) {\n        return false;\n    }\n    const orient = [\n        orientation(p1, q1, p2),\n        orientation(p1, q1, q2),\n        orientation(p2, q2, p1),\n        orientation(p2, q2, q1),\n    ];\n    if (orient[0] !== orient[1] && orient[2] !== orient[3]) {\n        return true;\n    }\n    if (orient[0] === 0 && onSegment(p1, p2, q1)) {\n        result = true;\n    }\n    else if (orient[1] === 0 && onSegment(p1, q2, q1)) {\n        result = true;\n    }\n    else if (orient[2] === 0 && onSegment(p2, p1, q2)) {\n        result = true;\n    }\n    else if (orient[3] === 0 && onSegment(p2, q1, q2)) {\n        result = true;\n    }\n    return result;\n}\nfunction orientation(p, q, r) {\n    const orientationValue = (q[1] - p[1]) * (r[0] - q[0]) - (q[0] - p[0]) * (r[1] - q[1]);\n    if (orientationValue === 0) {\n        return 0;\n    }\n    return orientationValue > 0 ? 1 : 2;\n}\nfunction onSegment(p, q, r) {\n    if (q[0] <= Math.max(p[0], r[0]) &&\n        q[0] >= Math.min(p[0], r[0]) &&\n        q[1] <= Math.max(p[1], r[1]) &&\n        q[1] >= Math.min(p[1], r[1])) {\n        return true;\n    }\n    return false;\n}\n","import * as mathPoint from '../point';\nimport getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\nimport containsPoint from './containsPoint';\nimport containsPoints from './containsPoints';\nimport intersectPolyline from './intersectPolyline';\nimport getNormal2 from './getNormal2';\nimport { glMatrix, vec3 } from 'gl-matrix';\nimport getLinesIntersection from './getLinesIntersection';\nvar PolylinePointType;\n(function (PolylinePointType) {\n    PolylinePointType[PolylinePointType[\"Vertex\"] = 0] = \"Vertex\";\n    PolylinePointType[PolylinePointType[\"Intersection\"] = 1] = \"Intersection\";\n})(PolylinePointType || (PolylinePointType = {}));\nvar PolylinePointPosition;\n(function (PolylinePointPosition) {\n    PolylinePointPosition[PolylinePointPosition[\"Outside\"] = -1] = \"Outside\";\n    PolylinePointPosition[PolylinePointPosition[\"Edge\"] = 0] = \"Edge\";\n    PolylinePointPosition[PolylinePointPosition[\"Inside\"] = 1] = \"Inside\";\n})(PolylinePointPosition || (PolylinePointPosition = {}));\nvar PolylinePointDirection;\n(function (PolylinePointDirection) {\n    PolylinePointDirection[PolylinePointDirection[\"Exiting\"] = -1] = \"Exiting\";\n    PolylinePointDirection[PolylinePointDirection[\"Unknown\"] = 0] = \"Unknown\";\n    PolylinePointDirection[PolylinePointDirection[\"Entering\"] = 1] = \"Entering\";\n})(PolylinePointDirection || (PolylinePointDirection = {}));\nfunction ensuresNextPointers(polylinePoints) {\n    for (let i = 0, len = polylinePoints.length; i < len; i++) {\n        const currentPoint = polylinePoints[i];\n        if (!currentPoint.next) {\n            currentPoint.next = polylinePoints[i === len - 1 ? 0 : i + 1];\n        }\n    }\n}\nfunction getSourceAndTargetPointsList(targetPolyline, sourcePolyline) {\n    const targetPolylinePoints = [];\n    const sourcePolylinePoints = [];\n    const sourceIntersectionsCache = new Map();\n    const isFirstPointInside = containsPoint(sourcePolyline, targetPolyline[0]);\n    let intersectionPointDirection = isFirstPointInside\n        ? PolylinePointDirection.Exiting\n        : PolylinePointDirection.Entering;\n    for (let i = 0, len = targetPolyline.length; i < len; i++) {\n        const p1 = targetPolyline[i];\n        const pointInside = containsPoint(sourcePolyline, p1);\n        const vertexPoint = {\n            type: PolylinePointType.Vertex,\n            coordinates: p1,\n            position: pointInside\n                ? PolylinePointPosition.Inside\n                : PolylinePointPosition.Outside,\n            visited: false,\n            next: null,\n        };\n        targetPolylinePoints.push(vertexPoint);\n        const q1 = targetPolyline[i === len - 1 ? 0 : i + 1];\n        const intersectionsInfo = getLineSegmentIntersectionsIndexes(sourcePolyline, p1, q1).map((intersectedLineSegment) => {\n            const sourceLineSegmentId = intersectedLineSegment[0];\n            const p2 = sourcePolyline[intersectedLineSegment[0]];\n            const q2 = sourcePolyline[intersectedLineSegment[1]];\n            const intersectionCoordinate = getLinesIntersection(p1, q1, p2, q2);\n            const targetStartPointDistSquared = mathPoint.distanceToPointSquared(p1, intersectionCoordinate);\n            return {\n                sourceLineSegmentId,\n                coordinate: intersectionCoordinate,\n                targetStartPointDistSquared,\n            };\n        });\n        intersectionsInfo.sort((left, right) => left.targetStartPointDistSquared - right.targetStartPointDistSquared);\n        intersectionsInfo.forEach((intersectionInfo) => {\n            const { sourceLineSegmentId, coordinate: intersectionCoordinate } = intersectionInfo;\n            const targetEdgePoint = {\n                type: PolylinePointType.Intersection,\n                coordinates: intersectionCoordinate,\n                position: PolylinePointPosition.Edge,\n                direction: intersectionPointDirection,\n                visited: false,\n                next: null,\n            };\n            const sourceEdgePoint = {\n                ...targetEdgePoint,\n                direction: PolylinePointDirection.Unknown,\n                cloned: true,\n            };\n            if (intersectionPointDirection === PolylinePointDirection.Entering) {\n                targetEdgePoint.next = sourceEdgePoint;\n            }\n            else {\n                sourceEdgePoint.next = targetEdgePoint;\n            }\n            let sourceIntersectionPoints = sourceIntersectionsCache.get(sourceLineSegmentId);\n            if (!sourceIntersectionPoints) {\n                sourceIntersectionPoints = [];\n                sourceIntersectionsCache.set(sourceLineSegmentId, sourceIntersectionPoints);\n            }\n            targetPolylinePoints.push(targetEdgePoint);\n            sourceIntersectionPoints.push(sourceEdgePoint);\n            intersectionPointDirection *= -1;\n        });\n    }\n    for (let i = 0, len = sourcePolyline.length; i < len; i++) {\n        const lineSegmentId = i;\n        const p1 = sourcePolyline[i];\n        const vertexPoint = {\n            type: PolylinePointType.Vertex,\n            coordinates: p1,\n            visited: false,\n            next: null,\n        };\n        sourcePolylinePoints.push(vertexPoint);\n        const sourceIntersectionPoints = sourceIntersectionsCache.get(lineSegmentId);\n        if (!sourceIntersectionPoints?.length) {\n            continue;\n        }\n        sourceIntersectionPoints\n            .map((intersectionPoint) => ({\n            intersectionPoint,\n            lineSegStartDistSquared: mathPoint.distanceToPointSquared(p1, intersectionPoint.coordinates),\n        }))\n            .sort((left, right) => left.lineSegStartDistSquared - right.lineSegStartDistSquared)\n            .map(({ intersectionPoint }) => intersectionPoint)\n            .forEach((intersectionPoint) => sourcePolylinePoints.push(intersectionPoint));\n    }\n    ensuresNextPointers(targetPolylinePoints);\n    ensuresNextPointers(sourcePolylinePoints);\n    return { targetPolylinePoints, sourcePolylinePoints };\n}\nfunction getUnvisitedOutsidePoint(polylinePoints) {\n    for (let i = 0, len = polylinePoints.length; i < len; i++) {\n        const point = polylinePoints[i];\n        if (!point.visited &&\n            point.position === PolylinePointPosition.Outside &&\n            point.type === PolylinePointType.Vertex) {\n            return point;\n        }\n    }\n    for (let i = 0, len = polylinePoints.length; i < len; i++) {\n        const point = polylinePoints[i];\n        if (!point.visited && point.position === PolylinePointPosition.Outside) {\n            return point;\n        }\n    }\n    return undefined;\n}\nfunction mergePolylines(targetPolyline, sourcePolyline) {\n    const targetNormal = getNormal2(targetPolyline);\n    const sourceNormal = getNormal2(sourcePolyline);\n    const dotNormals = vec3.dot(sourceNormal, targetNormal);\n    if (!glMatrix.equals(1, dotNormals)) {\n        sourcePolyline = sourcePolyline.slice().reverse();\n    }\n    const lineSegmentsIntersect = intersectPolyline(sourcePolyline, targetPolyline);\n    const targetContainedInSource = !lineSegmentsIntersect && containsPoints(sourcePolyline, targetPolyline);\n    if (targetContainedInSource) {\n        return sourcePolyline.slice();\n    }\n    const { targetPolylinePoints } = getSourceAndTargetPointsList(targetPolyline, sourcePolyline);\n    const startPoint = getUnvisitedOutsidePoint(targetPolylinePoints);\n    if (!startPoint) {\n        return targetPolyline.slice();\n    }\n    const mergedPolyline = [startPoint.coordinates];\n    let currentPoint = startPoint.next;\n    let iterationCount = 0;\n    const maxIterations = targetPolyline.length + sourcePolyline.length + 1000;\n    while (currentPoint !== startPoint && iterationCount < maxIterations) {\n        iterationCount++;\n        if (currentPoint.type === PolylinePointType.Intersection &&\n            currentPoint.cloned) {\n            currentPoint = currentPoint.next;\n            continue;\n        }\n        mergedPolyline.push(currentPoint.coordinates);\n        currentPoint = currentPoint.next;\n        if (!currentPoint) {\n            console.warn('Broken linked list detected in mergePolylines, breaking loop');\n            break;\n        }\n    }\n    if (iterationCount >= maxIterations) {\n        console.warn('Maximum iterations reached in mergePolylines, possible infinite loop detected');\n    }\n    return mergedPolyline;\n}\nexport { mergePolylines };\n","import isClosed from './isClosed';\nexport default function containsPoint(polyline, point, options = {\n    closed: undefined,\n}) {\n    if (polyline.length < 3) {\n        return false;\n    }\n    const numPolylinePoints = polyline.length;\n    let numIntersections = 0;\n    const { closed, holes } = options;\n    if (holes?.length) {\n        for (const hole of holes) {\n            if (containsPoint(hole, point)) {\n                return false;\n            }\n        }\n    }\n    const shouldClose = !(closed === undefined ? isClosed(polyline) : closed);\n    const maxSegmentIndex = polyline.length - (shouldClose ? 1 : 2);\n    for (let i = 0; i <= maxSegmentIndex; i++) {\n        const p1 = polyline[i];\n        const p2Index = i === numPolylinePoints - 1 ? 0 : i + 1;\n        const p2 = polyline[p2Index];\n        const maxX = p1[0] >= p2[0] ? p1[0] : p2[0];\n        const maxY = p1[1] >= p2[1] ? p1[1] : p2[1];\n        const minY = p1[1] <= p2[1] ? p1[1] : p2[1];\n        const mayIntersectLineSegment = point[0] <= maxX && point[1] >= minY && point[1] < maxY;\n        if (mayIntersectLineSegment) {\n            const isVerticalLine = p1[0] === p2[0];\n            let intersects = isVerticalLine;\n            if (!intersects) {\n                const xIntersection = ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\n                intersects = point[0] <= xIntersection;\n            }\n            numIntersections += intersects ? 1 : 0;\n        }\n    }\n    return !!(numIntersections % 2);\n}\n","export default function convexHull(pts) {\n    if (pts.length < 3) {\n        return pts.slice();\n    }\n    const points = pts\n        .map((p) => [p[0], p[1]])\n        .sort((a, b) => a[0] === b[0] ? a[1] - b[1] : a[0] - b[0]);\n    function cross(o, a, b) {\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n    }\n    const lower = [];\n    for (const p of points) {\n        while (lower.length >= 2 &&\n            cross(lower[lower.length - 2], lower[lower.length - 1], p) <= 0) {\n            lower.pop();\n        }\n        lower.push(p);\n    }\n    const upper = [];\n    for (let i = points.length - 1; i >= 0; i--) {\n        const p = points[i];\n        while (upper.length >= 2 &&\n            cross(upper[upper.length - 2], upper[upper.length - 1], p) <= 0) {\n            upper.pop();\n        }\n        upper.push(p);\n    }\n    lower.pop();\n    upper.pop();\n    return lower.concat(upper);\n}\n","export default function getAABB(polyline, options) {\n    let polylineToUse = polyline;\n    const numDimensions = options?.numDimensions || 2;\n    const is3D = numDimensions === 3;\n    if (!Array.isArray(polyline[0])) {\n        const currentPolyline = polyline;\n        const totalPoints = currentPolyline.length / numDimensions;\n        polylineToUse = new Array(currentPolyline.length / numDimensions);\n        for (let i = 0, len = totalPoints; i < len; i++) {\n            polylineToUse[i] = [\n                currentPolyline[i * numDimensions],\n                currentPolyline[i * numDimensions + 1],\n            ];\n            if (is3D) {\n                polylineToUse[i].push(currentPolyline[i * numDimensions + 2]);\n            }\n        }\n    }\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n    let minZ = Infinity;\n    let maxZ = -Infinity;\n    polylineToUse = polylineToUse;\n    for (let i = 0, len = polylineToUse.length; i < len; i++) {\n        const [x, y, z] = polylineToUse[i];\n        minX = minX < x ? minX : x;\n        minY = minY < y ? minY : y;\n        maxX = maxX > x ? maxX : x;\n        maxY = maxY > y ? maxY : y;\n        if (is3D) {\n            minZ = minZ < z ? minZ : z;\n            maxZ = maxZ > z ? maxZ : z;\n        }\n    }\n    return is3D\n        ? { minX, maxX, minY, maxY, minZ, maxZ }\n        : { minX, maxX, minY, maxY };\n}\n","export default function getArea(points) {\n    const n = points.length;\n    let area = 0.0;\n    let j = n - 1;\n    for (let i = 0; i < n; i++) {\n        area += (points[j][0] + points[i][0]) * (points[j][1] - points[i][1]);\n        j = i;\n    }\n    return Math.abs(area / 2.0);\n}\n","import { vec2 } from 'gl-matrix';\nimport areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\nexport default function getClosestLineSegmentIntersection(points, p1, q1, closed = true) {\n    let initialQ2Index;\n    let p2Index;\n    if (closed) {\n        p2Index = points.length - 1;\n        initialQ2Index = 0;\n    }\n    else {\n        p2Index = 0;\n        initialQ2Index = 1;\n    }\n    const intersections = [];\n    for (let q2Index = initialQ2Index; q2Index < points.length; q2Index++) {\n        const p2 = points[p2Index];\n        const q2 = points[q2Index];\n        if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n            intersections.push([p2Index, q2Index]);\n        }\n        p2Index = q2Index;\n    }\n    if (intersections.length === 0) {\n        return;\n    }\n    const distances = [];\n    intersections.forEach((intersection) => {\n        const intersectionPoints = [\n            points[intersection[0]],\n            points[intersection[1]],\n        ];\n        const midpoint = [\n            (intersectionPoints[0][0] + intersectionPoints[1][0]) / 2,\n            (intersectionPoints[0][1] + intersectionPoints[1][1]) / 2,\n        ];\n        distances.push(vec2.distance(midpoint, p1));\n    });\n    const minDistance = Math.min(...distances);\n    const indexOfMinDistance = distances.indexOf(minDistance);\n    return {\n        segment: intersections[indexOfMinDistance],\n        distance: minDistance,\n    };\n}\n","import areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\nexport default function getFirstLineSegmentIntersectionIndexes(points, p1, q1, closed = true) {\n    let initialI;\n    let j;\n    if (closed) {\n        j = points.length - 1;\n        initialI = 0;\n    }\n    else {\n        j = 0;\n        initialI = 1;\n    }\n    for (let i = initialI; i < points.length; i++) {\n        const p2 = points[j];\n        const q2 = points[i];\n        if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n            return [j, i];\n        }\n        j = i;\n    }\n}\n","import getLineSegmentIntersectionsIndexes from './getLineSegmentIntersectionsIndexes';\nimport getLinesIntersection from './getLinesIntersection';\nexport default function getLineSegmentIntersectionsCoordinates(points, p1, q1, closed = true) {\n    const result = [];\n    const polylineIndexes = getLineSegmentIntersectionsIndexes(points, p1, q1, closed);\n    for (let i = 0; i < polylineIndexes.length; i++) {\n        const p2 = points[polylineIndexes[i][0]];\n        const q2 = points[polylineIndexes[i][1]];\n        const intersection = getLinesIntersection(p1, q1, p2, q2);\n        result.push(intersection);\n    }\n    return result;\n}\n","import areLineSegmentsIntersecting from './areLineSegmentsIntersecting';\nexport default function getLineSegmentIntersectionsIndexes(polyline, p1, q1, closed = true) {\n    const intersections = [];\n    const numPoints = polyline.length;\n    const maxI = numPoints - (closed ? 1 : 2);\n    for (let i = 0; i <= maxI; i++) {\n        const p2 = polyline[i];\n        const j = i === numPoints - 1 ? 0 : i + 1;\n        const q2 = polyline[j];\n        if (areLineSegmentsIntersecting(p1, q1, p2, q2)) {\n            intersections.push([i, j]);\n        }\n    }\n    return intersections;\n}\n","import * as mathLine from '../line';\nconst PARALLEL_LINES_TOLERANCE = 1e-2;\nexport default function getLinesIntersection(p1, q1, p2, q2) {\n    const diffQ1P1 = [q1[0] - p1[0], q1[1] - p1[1]];\n    const diffQ2P2 = [q2[0] - p2[0], q2[1] - p2[1]];\n    const denominator = diffQ2P2[1] * diffQ1P1[0] - diffQ2P2[0] * diffQ1P1[1];\n    const absDenominator = denominator >= 0 ? denominator : -denominator;\n    if (absDenominator < PARALLEL_LINES_TOLERANCE) {\n        const line1AABB = [\n            p1[0] < q1[0] ? p1[0] : q1[0],\n            p1[0] > q1[0] ? p1[0] : q1[0],\n            p1[1] < q1[1] ? p1[1] : q1[1],\n            p1[1] > q1[1] ? p1[1] : q1[1],\n        ];\n        const line2AABB = [\n            p2[0] < q2[0] ? p2[0] : q2[0],\n            p2[0] > q2[0] ? p2[0] : q2[0],\n            p2[1] < q2[1] ? p2[1] : q2[1],\n            p2[1] > q2[1] ? p2[1] : q2[1],\n        ];\n        const aabbIntersects = line1AABB[0] <= line2AABB[1] &&\n            line1AABB[1] >= line2AABB[0] &&\n            line1AABB[2] <= line2AABB[3] &&\n            line1AABB[3] >= line2AABB[2];\n        if (!aabbIntersects) {\n            return;\n        }\n        const overlap = mathLine.isPointOnLineSegment(p1, q1, p2) ||\n            mathLine.isPointOnLineSegment(p1, q1, q2) ||\n            mathLine.isPointOnLineSegment(p2, q2, p1);\n        if (!overlap) {\n            return;\n        }\n        const minX = line1AABB[0] > line2AABB[0] ? line1AABB[0] : line2AABB[0];\n        const maxX = line1AABB[1] < line2AABB[1] ? line1AABB[1] : line2AABB[1];\n        const minY = line1AABB[2] > line2AABB[2] ? line1AABB[2] : line2AABB[2];\n        const maxY = line1AABB[3] < line2AABB[3] ? line1AABB[3] : line2AABB[3];\n        const midX = (minX + maxX) * 0.5;\n        const midY = (minY + maxY) * 0.5;\n        return [midX, midY];\n    }\n    let a = p1[1] - p2[1];\n    let b = p1[0] - p2[0];\n    const numerator1 = diffQ2P2[0] * a - diffQ2P2[1] * b;\n    const numerator2 = diffQ1P1[0] * a - diffQ1P1[1] * b;\n    a = numerator1 / denominator;\n    b = numerator2 / denominator;\n    const resultX = p1[0] + a * diffQ1P1[0];\n    const resultY = p1[1] + a * diffQ1P1[1];\n    return [resultX, resultY];\n}\n","import getSignedArea from './getSignedArea';\nexport default function getNormal2(polyline) {\n    const area = getSignedArea(polyline);\n    return [0, 0, area / Math.abs(area)];\n}\n","import { vec3 } from 'gl-matrix';\nfunction _getAreaVector(polyline) {\n    const vecArea = vec3.create();\n    const refPoint = polyline[0];\n    for (let i = 0, len = polyline.length; i < len; i++) {\n        const p1 = polyline[i];\n        const p2Index = i === len - 1 ? 0 : i + 1;\n        const p2 = polyline[p2Index];\n        const aX = p1[0] - refPoint[0];\n        const aY = p1[1] - refPoint[1];\n        const aZ = p1[2] - refPoint[2];\n        const bX = p2[0] - refPoint[0];\n        const bY = p2[1] - refPoint[1];\n        const bZ = p2[2] - refPoint[2];\n        vecArea[0] += aY * bZ - aZ * bY;\n        vecArea[1] += aZ * bX - aX * bZ;\n        vecArea[2] += aX * bY - aY * bX;\n    }\n    vec3.scale(vecArea, vecArea, 0.5);\n    return vecArea;\n}\nexport default function getNormal3(polyline) {\n    const vecArea = _getAreaVector(polyline);\n    return vec3.normalize(vecArea, vecArea);\n}\n","import { StackViewport } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nconst EPSILON = 1e-3;\nconst getSubPixelSpacingAndXYDirections = (viewport, subPixelResolution) => {\n    let spacing;\n    let xDir;\n    let yDir;\n    if (viewport instanceof StackViewport) {\n        const imageData = viewport.getImageData();\n        if (!imageData) {\n            return;\n        }\n        xDir = imageData.direction.slice(0, 3);\n        yDir = imageData.direction.slice(3, 6);\n        spacing = imageData.spacing;\n    }\n    else {\n        const imageData = viewport.getImageData();\n        const { direction, spacing: volumeSpacing } = imageData;\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        const iVector = direction.slice(0, 3);\n        const jVector = direction.slice(3, 6);\n        const kVector = direction.slice(6, 9);\n        const viewRight = vec3.create();\n        vec3.cross(viewRight, viewUp, viewPlaneNormal);\n        const absViewRightDotI = Math.abs(vec3.dot(viewRight, iVector));\n        const absViewRightDotJ = Math.abs(vec3.dot(viewRight, jVector));\n        const absViewRightDotK = Math.abs(vec3.dot(viewRight, kVector));\n        let xSpacing;\n        if (Math.abs(1 - absViewRightDotI) < EPSILON) {\n            xSpacing = volumeSpacing[0];\n            xDir = iVector;\n        }\n        else if (Math.abs(1 - absViewRightDotJ) < EPSILON) {\n            xSpacing = volumeSpacing[1];\n            xDir = jVector;\n        }\n        else if (Math.abs(1 - absViewRightDotK) < EPSILON) {\n            xSpacing = volumeSpacing[2];\n            xDir = kVector;\n        }\n        else {\n            throw new Error('No support yet for oblique plane planar contours');\n        }\n        const absViewUpDotI = Math.abs(vec3.dot(viewUp, iVector));\n        const absViewUpDotJ = Math.abs(vec3.dot(viewUp, jVector));\n        const absViewUpDotK = Math.abs(vec3.dot(viewUp, kVector));\n        let ySpacing;\n        if (Math.abs(1 - absViewUpDotI) < EPSILON) {\n            ySpacing = volumeSpacing[0];\n            yDir = iVector;\n        }\n        else if (Math.abs(1 - absViewUpDotJ) < EPSILON) {\n            ySpacing = volumeSpacing[1];\n            yDir = jVector;\n        }\n        else if (Math.abs(1 - absViewUpDotK) < EPSILON) {\n            ySpacing = volumeSpacing[2];\n            yDir = kVector;\n        }\n        else {\n            throw new Error('No support yet for oblique plane planar contours');\n        }\n        spacing = [xSpacing, ySpacing];\n    }\n    const subPixelSpacing = [\n        spacing[0] / subPixelResolution,\n        spacing[1] / subPixelResolution,\n    ];\n    return { spacing: subPixelSpacing, xDir, yDir };\n};\nexport default getSubPixelSpacingAndXYDirections;\n","import getSignedArea from './getSignedArea';\nexport default function getWindingDirection(polyline) {\n    const signedArea = getSignedArea(polyline);\n    return signedArea >= 0 ? 1 : -1;\n}\n","import getFirstLineSegmentIntersectionIndexes from './getFirstLineSegmentIntersectionIndexes';\nexport default function intersectPolyline(sourcePolyline, targetPolyline) {\n    for (let i = 0, sourceLen = sourcePolyline.length; i < sourceLen; i++) {\n        const sourceP1 = sourcePolyline[i];\n        const sourceP2Index = i === sourceLen - 1 ? 0 : i + 1;\n        const sourceP2 = sourcePolyline[sourceP2Index];\n        const intersectionPointIndexes = getFirstLineSegmentIntersectionIndexes(targetPolyline, sourceP1, sourceP2);\n        if (intersectionPointIndexes?.length === 2) {\n            return true;\n        }\n    }\n    return false;\n}\n","import { vec2 } from 'gl-matrix';\nimport containsPoint from './containsPoint';\nimport getSignedArea from './getSignedArea';\nimport { EPSILON, IntersectionDirection, pointsAreEqual, PolylineNodeType, robustSegmentIntersection, } from './robustSegmentIntersection';\nexport default function intersectPolylines(mainPolyCoords, clipPolyCoordsInput) {\n    if (mainPolyCoords.length < 3 || clipPolyCoordsInput.length < 3) {\n        return [];\n    }\n    let clipPolyCoords = clipPolyCoordsInput.slice();\n    const mainArea = getSignedArea(mainPolyCoords);\n    const clipArea = getSignedArea(clipPolyCoords);\n    if (Math.abs(mainArea) < EPSILON || Math.abs(clipArea) < EPSILON) {\n        return [];\n    }\n    if (mainArea < 0) {\n        mainPolyCoords = mainPolyCoords.slice().reverse();\n    }\n    if (clipArea < 0) {\n        clipPolyCoords = clipPolyCoords.slice().reverse();\n    }\n    const currentClipPolyForPIP = clipPolyCoords;\n    const intersections = [];\n    for (let i = 0; i < mainPolyCoords.length; i++) {\n        const p1 = mainPolyCoords[i];\n        const p2 = mainPolyCoords[(i + 1) % mainPolyCoords.length];\n        for (let j = 0; j < clipPolyCoords.length; j++) {\n            const q1 = clipPolyCoords[j];\n            const q2 = clipPolyCoords[(j + 1) % clipPolyCoords.length];\n            const intersectPt = robustSegmentIntersection(p1, p2, q1, q2);\n            if (intersectPt) {\n                const lenP = Math.sqrt(vec2.squaredDistance(p1, p2));\n                const lenQ = Math.sqrt(vec2.squaredDistance(q1, q2));\n                intersections.push({\n                    coord: [...intersectPt],\n                    seg1Idx: i,\n                    seg2Idx: j,\n                    alpha1: lenP < EPSILON\n                        ? 0\n                        : Math.sqrt(vec2.squaredDistance(p1, intersectPt)) / lenP,\n                    alpha2: lenQ < EPSILON\n                        ? 0\n                        : Math.sqrt(vec2.squaredDistance(q1, intersectPt)) / lenQ,\n                });\n            }\n        }\n    }\n    if (intersections.length === 0) {\n        if (containsPoint(currentClipPolyForPIP, mainPolyCoords[0]) &&\n            mainPolyCoords.every((pt) => containsPoint(currentClipPolyForPIP, pt))) {\n            return [[...mainPolyCoords.map((p) => [...p])]];\n        }\n        if (containsPoint(mainPolyCoords, clipPolyCoords[0]) &&\n            clipPolyCoords.every((pt) => containsPoint(mainPolyCoords, pt))) {\n            return [[...clipPolyCoords.map((p) => [...p])]];\n        }\n        return [];\n    }\n    const buildAugmentedList = (polyCoords, polyIndex, allIntersections) => {\n        const augmentedList = [];\n        let nodeIdCounter = 0;\n        for (let i = 0; i < polyCoords.length; i++) {\n            const p1 = polyCoords[i];\n            augmentedList.push({\n                id: `${polyIndex}_v${nodeIdCounter++}`,\n                coordinates: [...p1],\n                type: PolylineNodeType.Vertex,\n                originalPolyIndex: polyIndex,\n                originalVertexIndex: i,\n                next: null,\n                prev: null,\n                isIntersection: false,\n                visited: false,\n                processedInPath: false,\n                intersectionDir: IntersectionDirection.Unknown,\n            });\n            const segmentIntersections = allIntersections\n                .filter((isect) => (polyIndex === 0 ? isect.seg1Idx : isect.seg2Idx) === i)\n                .sort((a, b) => (polyIndex === 0 ? a.alpha1 : a.alpha2) -\n                (polyIndex === 0 ? b.alpha1 : b.alpha2));\n            for (const isect of segmentIntersections) {\n                if (augmentedList.length > 0 &&\n                    pointsAreEqual(augmentedList[augmentedList.length - 1].coordinates, isect.coord)) {\n                    const lastNode = augmentedList[augmentedList.length - 1];\n                    if (!lastNode.isIntersection) {\n                        lastNode.isIntersection = true;\n                        lastNode.intersectionInfo = isect;\n                        lastNode.alpha = polyIndex === 0 ? isect.alpha1 : isect.alpha2;\n                        lastNode.type = PolylineNodeType.Intersection;\n                    }\n                    continue;\n                }\n                augmentedList.push({\n                    id: `${polyIndex}_i${nodeIdCounter++}`,\n                    coordinates: [...isect.coord],\n                    type: PolylineNodeType.Intersection,\n                    originalPolyIndex: polyIndex,\n                    next: null,\n                    prev: null,\n                    isIntersection: true,\n                    visited: false,\n                    processedInPath: false,\n                    alpha: polyIndex === 0 ? isect.alpha1 : isect.alpha2,\n                    intersectionInfo: isect,\n                    intersectionDir: IntersectionDirection.Unknown,\n                });\n            }\n        }\n        const finalList = [];\n        if (augmentedList.length > 0) {\n            finalList.push(augmentedList[0]);\n            for (let i = 1; i < augmentedList.length; i++) {\n                if (!pointsAreEqual(augmentedList[i].coordinates, finalList[finalList.length - 1].coordinates)) {\n                    finalList.push(augmentedList[i]);\n                }\n                else {\n                    const lastNodeInFinal = finalList[finalList.length - 1];\n                    if (augmentedList[i].isIntersection &&\n                        augmentedList[i].intersectionInfo) {\n                        lastNodeInFinal.isIntersection = true;\n                        lastNodeInFinal.intersectionInfo =\n                            augmentedList[i].intersectionInfo;\n                        lastNodeInFinal.alpha = augmentedList[i].alpha;\n                        lastNodeInFinal.type = PolylineNodeType.Intersection;\n                    }\n                }\n            }\n        }\n        if (finalList.length > 1 &&\n            pointsAreEqual(finalList[0].coordinates, finalList[finalList.length - 1].coordinates)) {\n            const firstNode = finalList[0];\n            const lastNodePopped = finalList.pop();\n            if (lastNodePopped.isIntersection &&\n                !firstNode.isIntersection &&\n                lastNodePopped.intersectionInfo) {\n                firstNode.isIntersection = true;\n                firstNode.intersectionInfo = lastNodePopped.intersectionInfo;\n                firstNode.alpha = lastNodePopped.alpha;\n                firstNode.type = PolylineNodeType.Intersection;\n            }\n        }\n        if (finalList.length > 0) {\n            for (let i = 0; i < finalList.length; i++) {\n                finalList[i].next = finalList[(i + 1) % finalList.length];\n                finalList[i].prev =\n                    finalList[(i - 1 + finalList.length) % finalList.length];\n            }\n        }\n        return finalList;\n    };\n    const mainAugmented = buildAugmentedList(mainPolyCoords, 0, intersections);\n    const clipAugmented = buildAugmentedList(clipPolyCoords, 1, intersections);\n    if (mainAugmented.length === 0 || clipAugmented.length === 0) {\n        return [];\n    }\n    mainAugmented.forEach((mainNode) => {\n        if (mainNode.isIntersection && mainNode.intersectionInfo) {\n            const mainIntersectData = mainNode.intersectionInfo;\n            const partnerNode = clipAugmented.find((clipNode) => clipNode.isIntersection &&\n                clipNode.intersectionInfo &&\n                pointsAreEqual(clipNode.coordinates, mainNode.coordinates) &&\n                clipNode.intersectionInfo.seg1Idx === mainIntersectData.seg1Idx &&\n                clipNode.intersectionInfo.seg2Idx === mainIntersectData.seg2Idx);\n            if (partnerNode) {\n                mainNode.partnerNode = partnerNode;\n                partnerNode.partnerNode = mainNode;\n                const v_arrival_main = vec2.subtract(vec2.create(), mainNode.coordinates, mainNode.prev.coordinates);\n                const v_departure_clip = vec2.subtract(vec2.create(), partnerNode.next.coordinates, partnerNode.coordinates);\n                const crossZ = v_arrival_main[0] * v_departure_clip[1] -\n                    v_arrival_main[1] * v_departure_clip[0];\n                if (crossZ > EPSILON) {\n                    mainNode.intersectionDir = IntersectionDirection.Entering;\n                    partnerNode.intersectionDir = IntersectionDirection.Exiting;\n                }\n                else if (crossZ < -EPSILON) {\n                    mainNode.intersectionDir = IntersectionDirection.Exiting;\n                    partnerNode.intersectionDir = IntersectionDirection.Entering;\n                }\n                else {\n                    const midPrevMainSeg = [\n                        (mainNode.prev.coordinates[0] + mainNode.coordinates[0]) / 2,\n                        (mainNode.prev.coordinates[1] + mainNode.coordinates[1]) / 2,\n                    ];\n                    if (containsPoint(currentClipPolyForPIP, midPrevMainSeg)) {\n                        mainNode.intersectionDir = IntersectionDirection.Exiting;\n                        partnerNode.intersectionDir = IntersectionDirection.Entering;\n                    }\n                    else {\n                        mainNode.intersectionDir = IntersectionDirection.Entering;\n                        partnerNode.intersectionDir = IntersectionDirection.Exiting;\n                    }\n                }\n            }\n            else {\n                mainNode.isIntersection = false;\n                mainNode.intersectionInfo = undefined;\n            }\n        }\n    });\n    const resultPolygons = [];\n    for (const startCand of mainAugmented) {\n        if (!startCand.isIntersection ||\n            startCand.visited ||\n            startCand.intersectionDir !== IntersectionDirection.Entering) {\n            continue;\n        }\n        let currentPathCoords = [];\n        let currentNode = startCand;\n        let onMainList = true;\n        const pathStartNode = startCand;\n        let safetyBreak = 0;\n        const maxIter = (mainAugmented.length + clipAugmented.length) * 2;\n        mainAugmented.forEach((n) => (n.processedInPath = false));\n        clipAugmented.forEach((n) => (n.processedInPath = false));\n        do {\n            if (safetyBreak++ > maxIter) {\n                console.warn('Intersection: Max iterations in path tracing.', pathStartNode.id, currentNode.id);\n                currentPathCoords = [];\n                break;\n            }\n            if (currentNode.processedInPath && currentNode !== pathStartNode) {\n                console.warn('Intersection: Path processing loop detected, discarding path segment.', pathStartNode.id, currentNode.id);\n                currentPathCoords = [];\n                break;\n            }\n            currentNode.processedInPath = true;\n            currentNode.visited = true;\n            if (currentPathCoords.length === 0 ||\n                !pointsAreEqual(currentPathCoords[currentPathCoords.length - 1], currentNode.coordinates)) {\n                currentPathCoords.push([...currentNode.coordinates]);\n            }\n            let switchedList = false;\n            if (currentNode.isIntersection && currentNode.partnerNode) {\n                if (onMainList) {\n                    currentNode = currentNode.partnerNode;\n                    onMainList = false;\n                    switchedList = true;\n                }\n                else {\n                    currentNode = currentNode.partnerNode;\n                    onMainList = true;\n                    switchedList = true;\n                }\n            }\n            if (!switchedList) {\n                currentNode = currentNode.next;\n            }\n            else {\n                currentNode = currentNode.next;\n            }\n        } while (currentNode !== pathStartNode ||\n            (onMainList && currentNode.originalPolyIndex !== 0) ||\n            (!onMainList && currentNode.originalPolyIndex !== 1));\n        if (safetyBreak > maxIter || currentPathCoords.length === 0) {\n        }\n        else if (currentPathCoords.length > 0 &&\n            pointsAreEqual(currentPathCoords[0], currentPathCoords[currentPathCoords.length - 1])) {\n            currentPathCoords.pop();\n        }\n        if (currentPathCoords.length >= 3) {\n            const resultArea = getSignedArea(currentPathCoords);\n            if (mainArea > 0 && resultArea < 0) {\n                currentPathCoords.reverse();\n            }\n            else if (mainArea < 0 && resultArea > 0) {\n                currentPathCoords.reverse();\n            }\n            resultPolygons.push(currentPathCoords.map((p) => [...p]));\n        }\n    }\n    return resultPolygons;\n}\n","import containsPoint from './containsPoint';\nimport { projectTo2D } from './projectTo2D';\nexport function isPointInsidePolyline3D(point, polyline, options = {}) {\n    const { sharedDimensionIndex, projectedPolyline } = projectTo2D(polyline);\n    const { holes } = options;\n    const projectedHoles = [];\n    if (holes) {\n        for (let i = 0; i < holes.length; i++) {\n            const hole = holes[i];\n            const hole2D = [];\n            for (let j = 0; j < hole.length; j++) {\n                hole2D.push([\n                    hole[j][(sharedDimensionIndex + 1) % 3],\n                    hole[j][(sharedDimensionIndex + 2) % 3],\n                ]);\n            }\n            projectedHoles.push(hole2D);\n        }\n    }\n    const point2D = [\n        point[(sharedDimensionIndex + 1) % 3],\n        point[(sharedDimensionIndex + 2) % 3],\n    ];\n    return containsPoint(projectedPolyline, point2D, { holes: projectedHoles });\n}\n","import { vec2 } from 'gl-matrix';\nconst pointCanProjectOnLine = (p, p1, p2, proximity) => {\n    const p1p = [p[0] - p1[0], p[1] - p1[1]];\n    const p1p2 = [p2[0] - p1[0], p2[1] - p1[1]];\n    const dot = p1p[0] * p1p2[0] + p1p[1] * p1p2[1];\n    if (dot < 0) {\n        return false;\n    }\n    const p1p2Mag = Math.sqrt(p1p2[0] * p1p2[0] + p1p2[1] * p1p2[1]);\n    if (p1p2Mag === 0) {\n        return false;\n    }\n    const projectionVectorMag = dot / p1p2Mag;\n    const p1p2UnitVector = [p1p2[0] / p1p2Mag, p1p2[1] / p1p2Mag];\n    const projectionVector = [\n        p1p2UnitVector[0] * projectionVectorMag,\n        p1p2UnitVector[1] * projectionVectorMag,\n    ];\n    const projectionPoint = [\n        p1[0] + projectionVector[0],\n        p1[1] + projectionVector[1],\n    ];\n    const distance = vec2.distance(p, projectionPoint);\n    if (distance > proximity) {\n        return false;\n    }\n    if (vec2.distance(p1, projectionPoint) > vec2.distance(p1, p2)) {\n        return false;\n    }\n    return true;\n};\nexport default pointCanProjectOnLine;\n","import { vec2 } from 'gl-matrix';\nconst pointsAreWithinCloseContourProximity = (p1, p2, closeContourProximity) => {\n    return vec2.dist(p1, p2) < closeContourProximity;\n};\nexport default pointsAreWithinCloseContourProximity;\n","import { utilities } from '@cornerstonejs/core';\nconst epsilon = 1e-6;\nexport function projectTo2D(polyline) {\n    let sharedDimensionIndex;\n    const testPoints = utilities.getRandomSampleFromArray(polyline, 50);\n    for (let i = 0; i < 3; i++) {\n        if (testPoints.every((point, index, array) => Math.abs(point[i] - array[0][i]) < epsilon)) {\n            sharedDimensionIndex = i;\n            break;\n        }\n    }\n    if (sharedDimensionIndex === undefined) {\n        throw new Error('Cannot find a shared dimension index for polyline, probably oblique plane');\n    }\n    const points2D = [];\n    const firstDim = (sharedDimensionIndex + 1) % 3;\n    const secondDim = (sharedDimensionIndex + 2) % 3;\n    for (let i = 0; i < polyline.length; i++) {\n        points2D.push([polyline[i][firstDim], polyline[i][secondDim]]);\n    }\n    return {\n        sharedDimensionIndex,\n        projectedPolyline: points2D,\n    };\n}\n","import { utilities } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\nexport const EPSILON = 1e-7;\nexport function vec2CrossZ(a, b) {\n    return a[0] * b[1] - a[1] * b[0];\n}\nexport function pointsAreEqual(p1, p2) {\n    return utilities.isEqual(p1, p2, EPSILON);\n}\nexport function robustSegmentIntersection(p1, p2, q1, q2) {\n    const r = vec2.subtract(vec2.create(), p2, p1);\n    const s = vec2.subtract(vec2.create(), q2, q1);\n    const rxs = vec2CrossZ(r, s);\n    const qmp = vec2.subtract(vec2.create(), q1, p1);\n    const qmpxr = vec2CrossZ(qmp, r);\n    if (Math.abs(rxs) < EPSILON) {\n        if (Math.abs(qmpxr) < EPSILON) {\n            const rDotR = vec2.dot(r, r);\n            const sDotS = vec2.dot(s, s);\n            if (rDotR < EPSILON || sDotS < EPSILON) {\n                if (pointsAreEqual(p1, q1) || pointsAreEqual(p1, q2)) {\n                    return p1;\n                }\n                if (pointsAreEqual(p2, q1) || pointsAreEqual(p2, q2)) {\n                    return p2;\n                }\n                return null;\n            }\n            const t0 = vec2.dot(vec2.subtract(vec2.create(), q1, p1), r) / rDotR;\n            const t1 = vec2.dot(vec2.subtract(vec2.create(), q2, p1), r) / rDotR;\n            const u0 = vec2.dot(vec2.subtract(vec2.create(), p1, q1), s) / sDotS;\n            const u1 = vec2.dot(vec2.subtract(vec2.create(), p2, q1), s) / sDotS;\n            const isInRange = (t) => t >= -EPSILON && t <= 1 + EPSILON;\n            if (isInRange(t0)) {\n                const projectedPoint = vec2.scaleAndAdd(vec2.create(), p1, r, t0);\n                if (pointsAreEqual(q1, projectedPoint)) {\n                    return q1;\n                }\n            }\n            if (isInRange(t1)) {\n                const projectedPoint = vec2.scaleAndAdd(vec2.create(), p1, r, t1);\n                if (pointsAreEqual(q2, projectedPoint)) {\n                    return q2;\n                }\n            }\n            if (isInRange(u0)) {\n                const projectedPoint = vec2.scaleAndAdd(vec2.create(), q1, s, u0);\n                if (pointsAreEqual(p1, projectedPoint)) {\n                    return p1;\n                }\n            }\n            if (isInRange(u1)) {\n                const projectedPoint = vec2.scaleAndAdd(vec2.create(), q1, s, u1);\n                if (pointsAreEqual(p2, projectedPoint)) {\n                    return p2;\n                }\n            }\n        }\n        return null;\n    }\n    const t = vec2CrossZ(qmp, s) / rxs;\n    const u = qmpxr / rxs;\n    if (t >= -EPSILON && t <= 1 + EPSILON && u >= -EPSILON && u <= 1 + EPSILON) {\n        return [p1[0] + t * r[0], p1[1] + t * r[1]];\n    }\n    return null;\n}\nexport var PolylineNodeType;\n(function (PolylineNodeType) {\n    PolylineNodeType[PolylineNodeType[\"Vertex\"] = 0] = \"Vertex\";\n    PolylineNodeType[PolylineNodeType[\"Intersection\"] = 1] = \"Intersection\";\n})(PolylineNodeType || (PolylineNodeType = {}));\nexport var IntersectionDirection;\n(function (IntersectionDirection) {\n    IntersectionDirection[IntersectionDirection[\"Entering\"] = 0] = \"Entering\";\n    IntersectionDirection[IntersectionDirection[\"Exiting\"] = 1] = \"Exiting\";\n    IntersectionDirection[IntersectionDirection[\"Unknown\"] = 2] = \"Unknown\";\n})(IntersectionDirection || (IntersectionDirection = {}));\n","import { vec2 } from 'gl-matrix';\nimport getSignedArea from './getSignedArea';\nimport { EPSILON, IntersectionDirection, pointsAreEqual, PolylineNodeType, robustSegmentIntersection, } from './robustSegmentIntersection';\nimport containsPoint from './containsPoint';\nimport arePolylinesIdentical from './arePolylinesIdentical';\nexport default function subtractPolylines(targetPolylineCoords, sourcePolylineCoordsInput) {\n    if (targetPolylineCoords.length < 3) {\n        return [];\n    }\n    if (sourcePolylineCoordsInput.length < 3) {\n        return [targetPolylineCoords.slice()];\n    }\n    const sourcePolylineCoords = sourcePolylineCoordsInput.slice();\n    if (arePolylinesIdentical(targetPolylineCoords, sourcePolylineCoordsInput)) {\n        return [];\n    }\n    const targetArea = getSignedArea(targetPolylineCoords);\n    const sourceArea = getSignedArea(sourcePolylineCoords);\n    if (Math.sign(targetArea) === Math.sign(sourceArea) &&\n        Math.abs(sourceArea) > EPSILON) {\n        sourcePolylineCoords.reverse();\n    }\n    const intersections = [];\n    for (let i = 0; i < targetPolylineCoords.length; i++) {\n        const p1 = targetPolylineCoords[i];\n        const p2 = targetPolylineCoords[(i + 1) % targetPolylineCoords.length];\n        for (let j = 0; j < sourcePolylineCoords.length; j++) {\n            const q1 = sourcePolylineCoords[j];\n            const q2 = sourcePolylineCoords[(j + 1) % sourcePolylineCoords.length];\n            const intersectPt = robustSegmentIntersection(p1, p2, q1, q2);\n            if (intersectPt) {\n                const lenP = Math.sqrt(vec2.squaredDistance(p1, p2));\n                const lenQ = Math.sqrt(vec2.squaredDistance(q1, q2));\n                intersections.push({\n                    coord: intersectPt,\n                    seg1Idx: i,\n                    seg2Idx: j,\n                    alpha1: lenP < EPSILON\n                        ? 0\n                        : Math.sqrt(vec2.squaredDistance(p1, intersectPt)) / lenP,\n                    alpha2: lenQ < EPSILON\n                        ? 0\n                        : Math.sqrt(vec2.squaredDistance(q1, intersectPt)) / lenQ,\n                });\n            }\n        }\n    }\n    const buildAugmentedList = (polyCoords, polyIndex, allIntersections) => {\n        const augmentedList = [];\n        let nodeIdCounter = 0;\n        for (let i = 0; i < polyCoords.length; i++) {\n            const p1 = polyCoords[i];\n            augmentedList.push({\n                id: `${polyIndex}_v${nodeIdCounter++}`,\n                coordinates: p1,\n                type: PolylineNodeType.Vertex,\n                originalPolyIndex: polyIndex,\n                originalVertexIndex: i,\n                next: null,\n                prev: null,\n                isIntersection: false,\n                visited: false,\n            });\n            const segmentIntersections = allIntersections\n                .filter((isect) => (polyIndex === 0 ? isect.seg1Idx : isect.seg2Idx) === i)\n                .sort((a, b) => (polyIndex === 0 ? a.alpha1 : a.alpha2) -\n                (polyIndex === 0 ? b.alpha1 : b.alpha2));\n            for (const isect of segmentIntersections) {\n                if (augmentedList.length > 0 &&\n                    pointsAreEqual(augmentedList[augmentedList.length - 1].coordinates, isect.coord)) {\n                    if (!augmentedList[augmentedList.length - 1].isIntersection) {\n                        augmentedList[augmentedList.length - 1].isIntersection = true;\n                        augmentedList[augmentedList.length - 1].intersectionInfo = isect;\n                        augmentedList[augmentedList.length - 1].alpha =\n                            polyIndex === 0 ? isect.alpha1 : isect.alpha2;\n                    }\n                    continue;\n                }\n                augmentedList.push({\n                    id: `${polyIndex}_i${nodeIdCounter++}`,\n                    coordinates: isect.coord,\n                    type: PolylineNodeType.Intersection,\n                    originalPolyIndex: polyIndex,\n                    next: null,\n                    prev: null,\n                    isIntersection: true,\n                    visited: false,\n                    alpha: polyIndex === 0 ? isect.alpha1 : isect.alpha2,\n                    intersectionInfo: isect,\n                });\n            }\n        }\n        const finalList = [];\n        if (augmentedList.length > 0) {\n            finalList.push(augmentedList[0]);\n            for (let i = 1; i < augmentedList.length; i++) {\n                if (!pointsAreEqual(augmentedList[i].coordinates, finalList[finalList.length - 1].coordinates)) {\n                    finalList.push(augmentedList[i]);\n                }\n                else {\n                    if (augmentedList[i].isIntersection) {\n                        finalList[finalList.length - 1].isIntersection = true;\n                        finalList[finalList.length - 1].intersectionInfo =\n                            augmentedList[i].intersectionInfo;\n                        finalList[finalList.length - 1].alpha = augmentedList[i].alpha;\n                    }\n                }\n            }\n        }\n        if (finalList.length > 0) {\n            for (let i = 0; i < finalList.length; i++) {\n                finalList[i].next = finalList[(i + 1) % finalList.length];\n                finalList[i].prev =\n                    finalList[(i - 1 + finalList.length) % finalList.length];\n            }\n        }\n        return finalList;\n    };\n    const targetAugmented = buildAugmentedList(targetPolylineCoords, 0, intersections);\n    const sourceAugmented = buildAugmentedList(sourcePolylineCoords, 1, intersections);\n    targetAugmented.forEach((tnode) => {\n        if (tnode.isIntersection) {\n            const tData = tnode.intersectionInfo;\n            const partner = sourceAugmented.find((snode) => snode.isIntersection &&\n                pointsAreEqual(snode.coordinates, tnode.coordinates) &&\n                snode.intersectionInfo.seg1Idx ===\n                    tData.seg1Idx &&\n                snode.intersectionInfo.seg2Idx === tData.seg2Idx);\n            if (partner) {\n                tnode.partnerNode = partner;\n                partner.partnerNode = tnode;\n                const p_prev = tnode.prev.coordinates;\n                const p_curr = tnode.coordinates;\n                const p_next_source = partner.next.coordinates;\n                const v_target_arrival = vec2.subtract(vec2.create(), p_curr, p_prev);\n                const v_source_departure = vec2.subtract(vec2.create(), p_next_source, p_curr);\n                const midPrevTargetSeg = [\n                    (tnode.prev.coordinates[0] + tnode.coordinates[0]) / 2,\n                    (tnode.prev.coordinates[1] + tnode.coordinates[1]) / 2,\n                ];\n                const prevSegMidpointInsideSource = containsPoint(sourcePolylineCoordsInput, midPrevTargetSeg);\n                if (prevSegMidpointInsideSource) {\n                    tnode.intersectionDir = IntersectionDirection.Exiting;\n                }\n                else {\n                    tnode.intersectionDir = IntersectionDirection.Entering;\n                }\n            }\n            else {\n                tnode.isIntersection = false;\n            }\n        }\n    });\n    targetAugmented.forEach((n) => delete n.intersectionInfo);\n    sourceAugmented.forEach((n) => delete n.intersectionInfo);\n    const resultPolylines = [];\n    for (let i = 0; i < targetAugmented.length; i++) {\n        const startNode = targetAugmented[i];\n        if (startNode.visited || startNode.isIntersection) {\n            continue;\n        }\n        if (containsPoint(sourcePolylineCoordsInput, startNode.coordinates)) {\n            continue;\n        }\n        const currentPathCoords = [];\n        let currentNode = startNode;\n        let onTargetList = true;\n        let safetyBreak = 0;\n        const maxIter = (targetAugmented.length + sourceAugmented.length) * 2;\n        do {\n            if (safetyBreak++ > maxIter) {\n                console.warn('Subtraction: Max iterations reached, possible infinite loop.');\n                break;\n            }\n            currentNode.visited = true;\n            if (currentPathCoords.length === 0 ||\n                !pointsAreEqual(currentPathCoords[currentPathCoords.length - 1], currentNode.coordinates)) {\n                currentPathCoords.push(currentNode.coordinates);\n            }\n            if (currentNode.isIntersection) {\n                if (onTargetList) {\n                    if (currentNode.intersectionDir === IntersectionDirection.Entering &&\n                        currentNode.partnerNode) {\n                        currentNode = currentNode.partnerNode;\n                        onTargetList = false;\n                    }\n                }\n                else {\n                    if (currentNode.partnerNode) {\n                        currentNode = currentNode.partnerNode;\n                        onTargetList = true;\n                    }\n                    else {\n                        console.warn('Subtraction: Intersection on source without partner.');\n                    }\n                }\n            }\n            currentNode = currentNode.next;\n        } while (currentNode !== startNode || !onTargetList);\n        if (currentPathCoords.length >= 3) {\n            if (pointsAreEqual(currentPathCoords[0], currentPathCoords[currentPathCoords.length - 1])) {\n                currentPathCoords.pop();\n            }\n            if (currentPathCoords.length >= 3) {\n                resultPolylines.push(currentPathCoords);\n            }\n        }\n    }\n    return resultPolylines;\n}\n","import filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nimport getWorldWidthAndHeightFromCorners from './getWorldWidthAndHeightFromCorners';\nimport filterAnnotationsForDisplay from './filterAnnotationsForDisplay';\nimport getWorldWidthAndHeightFromTwoPoints from './getWorldWidthAndHeightFromTwoPoints';\nimport { getPointInLineOfSightWithCriteria, getPointsInLineOfSight, } from './getPointInLineOfSightWithCriteria';\nimport { isPlaneIntersectingAABB } from './isPlaneIntersectingAABB';\nimport { filterAnnotationsWithinSamePlane } from './filterAnnotationsWithinPlane';\nexport default {\n    filterAnnotationsWithinSlice,\n    getWorldWidthAndHeightFromCorners,\n    getWorldWidthAndHeightFromTwoPoints,\n    filterAnnotationsForDisplay,\n    getPointInLineOfSightWithCriteria,\n    isPlaneIntersectingAABB,\n    filterAnnotationsWithinSamePlane,\n    getPointsInLineOfSight,\n};\nexport { filterAnnotationsWithinSlice, getWorldWidthAndHeightFromCorners, getWorldWidthAndHeightFromTwoPoints, filterAnnotationsForDisplay, getPointInLineOfSightWithCriteria, isPlaneIntersectingAABB, filterAnnotationsWithinSamePlane, getPointsInLineOfSight, };\n","import { vec3 } from 'gl-matrix';\nimport { createIsInSegment, isLineInSegment } from './isLineInSegment';\nconst EPSILON = 1e-2;\nexport default function findLargestBidirectional(contours, segVolumeId, segment) {\n    const { sliceContours } = contours;\n    const { segmentIndex, containedSegmentIndices } = segment;\n    let maxBidirectional;\n    const isInSegment = createIsInSegment(segVolumeId, segmentIndex, containedSegmentIndices);\n    for (const sliceContour of sliceContours) {\n        const bidirectional = createBidirectionalForSlice(sliceContour, isInSegment, maxBidirectional);\n        if (!bidirectional) {\n            continue;\n        }\n        maxBidirectional = bidirectional;\n    }\n    if (maxBidirectional) {\n        Object.assign(maxBidirectional, segment);\n    }\n    return maxBidirectional;\n}\nexport function createBidirectionalForSlice(sliceContour, isInSegment, currentMax = { maxMajor: 0, maxMinor: 0 }) {\n    const { points } = sliceContour.polyData;\n    const { maxMinor: currentMaxMinor, maxMajor: currentMaxMajor } = currentMax;\n    let maxMajor = currentMaxMajor * currentMaxMajor;\n    let maxMinor = currentMaxMinor * currentMaxMinor;\n    let maxMajorPoints;\n    for (let index1 = 0; index1 < points.length; index1++) {\n        for (let index2 = index1 + 1; index2 < points.length; index2++) {\n            const point1 = points[index1];\n            const point2 = points[index2];\n            const distance2 = vec3.sqrDist(point1, point2);\n            if (distance2 < maxMajor) {\n                continue;\n            }\n            if (distance2 - EPSILON < maxMajor + EPSILON && maxMajorPoints) {\n                continue;\n            }\n            if (!isInSegment.testCenter(point1, point2)) {\n                continue;\n            }\n            if (!isLineInSegment(point1, point2, isInSegment)) {\n                continue;\n            }\n            maxMajor = distance2 - EPSILON;\n            maxMajorPoints = [index1, index2];\n            maxMinor = 0;\n        }\n    }\n    if (!maxMajorPoints) {\n        return;\n    }\n    maxMajor = Math.sqrt(maxMajor + EPSILON);\n    const handle0 = points[maxMajorPoints[0]];\n    const handle1 = points[maxMajorPoints[1]];\n    const unitMajor = vec3.sub(vec3.create(), handle0, handle1);\n    vec3.scale(unitMajor, unitMajor, 1 / maxMajor);\n    let maxMinorPoints;\n    for (let index1 = 0; index1 < points.length; index1++) {\n        for (let index2 = index1 + 1; index2 < points.length; index2++) {\n            const point1 = points[index1];\n            const point2 = points[index2];\n            const distance2 = vec3.sqrDist(point1, point2);\n            if (distance2 <= maxMinor) {\n                continue;\n            }\n            const delta = vec3.sub(vec3.create(), point1, point2);\n            const dot = Math.abs(vec3.dot(delta, unitMajor)) / Math.sqrt(distance2);\n            if (dot > EPSILON) {\n                continue;\n            }\n            if (!isInSegment.testCenter(point1, point2)) {\n                continue;\n            }\n            if (!isLineInSegment(point1, point2, isInSegment)) {\n                continue;\n            }\n            maxMinor = distance2;\n            maxMinorPoints = [index1, index2];\n        }\n    }\n    if (!maxMinorPoints) {\n        return;\n    }\n    maxMinor = Math.sqrt(maxMinor);\n    const handle2 = points[maxMinorPoints[0]];\n    const handle3 = points[maxMinorPoints[1]];\n    const bidirectional = {\n        majorAxis: [handle0, handle1],\n        minorAxis: [handle2, handle3],\n        maxMajor,\n        maxMinor,\n        ...sliceContour,\n    };\n    return bidirectional;\n}\n","import { cache } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nexport default function isLineInSegment(point1, point2, isInSegment) {\n    const ijk1 = isInSegment.toIJK(point1);\n    const ijk2 = isInSegment.toIJK(point2);\n    const testPoint = vec3.create();\n    const { testIJK } = isInSegment;\n    const delta = vec3.sub(vec3.create(), ijk1, ijk2);\n    const testSize = Math.round(Math.max(...delta.map(Math.abs)));\n    if (testSize < 2) {\n        return true;\n    }\n    const unitDelta = vec3.scale(vec3.create(), delta, 1 / testSize);\n    for (let i = 1; i < testSize; i++) {\n        vec3.scaleAndAdd(testPoint, ijk2, unitDelta, i);\n        if (!testIJK(testPoint)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction createIsInSegmentMetadata({ dimensions, imageData, voxelManager, segmentIndex, containedSegmentIndices, }) {\n    const width = dimensions[0];\n    const pixelsPerSlice = width * dimensions[1];\n    return {\n        testCenter: (point1, point2) => {\n            const point = vec3.add(vec3.create(), point1, point2).map((it) => it / 2);\n            const ijk = imageData.worldToIndex(point).map(Math.round);\n            const [i, j, k] = ijk;\n            const index = i + j * width + k * pixelsPerSlice;\n            const value = voxelManager.getAtIndex(index);\n            return value === segmentIndex || containedSegmentIndices?.has(value);\n        },\n        toIJK: (point) => imageData.worldToIndex(point),\n        testIJK: (ijk) => {\n            const [i, j, k] = ijk;\n            const index = Math.round(i) + Math.round(j) * width + Math.round(k) * pixelsPerSlice;\n            const value = voxelManager.getAtIndex(index);\n            return value === segmentIndex || containedSegmentIndices?.has(value);\n        },\n    };\n}\nfunction createIsInSegment(segVolumeId, segmentIndex, containedSegmentIndices) {\n    const vol = cache.getVolume(segVolumeId);\n    if (!vol) {\n        console.warn(`No volume found for ${segVolumeId}`);\n        return;\n    }\n    return createIsInSegmentMetadata({\n        dimensions: vol.dimensions,\n        imageData: vol.imageData,\n        voxelManager: vol.voxelManager,\n        segmentIndex,\n        containedSegmentIndices,\n    });\n}\nexport { createIsInSegment, createIsInSegmentMetadata, isLineInSegment };\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getToolGroup } from '../store/ToolGroupManager';\nexport function triggerAnnotationRenderForToolGroupIds(toolGroupIds) {\n    toolGroupIds.forEach((toolGroupId) => {\n        const toolGroup = getToolGroup(toolGroupId);\n        if (!toolGroup) {\n            console.warn(`ToolGroup not available for ${toolGroupId}`);\n            return;\n        }\n        const viewportsInfo = toolGroup.getViewportsInfo();\n        viewportsInfo.forEach((viewportInfo) => {\n            const { renderingEngineId, viewportId } = viewportInfo;\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            if (!renderingEngine) {\n                console.warn(`RenderingEngine not available for ${renderingEngineId}`);\n                return;\n            }\n            const viewport = renderingEngine.getViewport(viewportId);\n            triggerAnnotationRender(viewport.element);\n        });\n    });\n}\nexport default triggerAnnotationRenderForToolGroupIds;\n","import { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nexport function triggerAnnotationRenderForViewportIds(viewportIdsToRender) {\n    if (!viewportIdsToRender.length) {\n        return;\n    }\n    viewportIdsToRender.forEach((viewportId) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            console.warn(`Viewport not available for ${viewportId}`);\n            return;\n        }\n        const { viewport } = enabledElement;\n        if (!viewport) {\n            console.warn(`Viewport not available for ${viewportId}`);\n            return;\n        }\n        const element = viewport.element;\n        triggerAnnotationRender(element);\n    });\n}\nexport default triggerAnnotationRenderForViewportIds;\n","import { InstanceVolumetricCalculator } from './VolumetricCalculator';\nexport default class SegmentStatsCalculator {\n    static { this.calculators = new Map(); }\n    static { this.indices = []; }\n    static { this.mode = 'collective'; }\n    static statsInit(options) {\n        const { storePointData, indices, mode } = options;\n        this.mode = mode;\n        this.indices = indices;\n        this.calculators.clear();\n        if (this.mode === 'individual') {\n            indices.forEach((index) => {\n                this.calculators.set(index, new InstanceVolumetricCalculator({ storePointData }));\n            });\n        }\n        else {\n            this.calculators.set(indices, new InstanceVolumetricCalculator({ storePointData }));\n        }\n    }\n    static statsCallback(data) {\n        const { segmentIndex, ...statsData } = data;\n        if (!segmentIndex) {\n            throw new Error('Segment index is required for stats calculation');\n        }\n        const calculator = this.mode === 'individual'\n            ? this.calculators.get(segmentIndex)\n            : this.calculators.get(this.indices);\n        if (!calculator) {\n            throw new Error(`No calculator found for segment ${segmentIndex}`);\n        }\n        calculator.statsCallback(statsData);\n    }\n    static getStatistics(options) {\n        if (this.mode === 'individual') {\n            const result = {};\n            this.calculators.forEach((calculator, segmentIndex) => {\n                result[segmentIndex] = calculator.getStatistics(options);\n            });\n            return result;\n        }\n        const calculator = this.calculators.get(this.indices);\n        return calculator.getStatistics(options);\n    }\n}\n","import { triggerEvent, eventTarget, Enums, getRenderingEngines, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations, Events as csToolsEvents, } from '../../enums';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { getSegmentation } from './getSegmentation';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nimport surfaceDisplay from '../../tools/displayTools/Surface/surfaceDisplay';\nimport contourDisplay from '../../tools/displayTools/Contour/contourDisplay';\nimport labelmapDisplay from '../../tools/displayTools/Labelmap/labelmapDisplay';\nimport { addTool } from '../../store/addTool';\nimport { state } from '../../store/state';\nimport PlanarFreehandContourSegmentationTool from '../../tools/annotation/PlanarFreehandContourSegmentationTool';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport { addDefaultSegmentationListener } from './segmentationEventManager';\nconst renderers = {\n    [Representations.Labelmap]: labelmapDisplay,\n    [Representations.Contour]: contourDisplay,\n    [Representations.Surface]: surfaceDisplay,\n};\nconst planarContourToolName = PlanarFreehandContourSegmentationTool.toolName;\nclass SegmentationRenderingEngine {\n    constructor() {\n        this._needsRender = new Set();\n        this._pendingRenderQueue = [];\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._getAllViewports = () => {\n            const renderingEngine = getRenderingEngines();\n            return renderingEngine.flatMap((renderingEngine) => renderingEngine.getViewports());\n        };\n        this._renderFlaggedSegmentations = () => {\n            this._throwIfDestroyed();\n            const viewportIds = Array.from(this._needsRender);\n            viewportIds.forEach((viewportId) => {\n                this._triggerRender(viewportId);\n            });\n            this._needsRender.clear();\n            this._animationFrameSet = false;\n            this._animationFrameHandle = null;\n            if (this._pendingRenderQueue.length > 0) {\n                const nextViewportIds = this._pendingRenderQueue.shift();\n                if (nextViewportIds && nextViewportIds.length > 0) {\n                    this._setViewportsToBeRenderedNextFrame(nextViewportIds);\n                }\n            }\n        };\n    }\n    renderSegmentationsForViewport(viewportId) {\n        const viewportIds = viewportId\n            ? [viewportId]\n            : this._getViewportIdsForSegmentation();\n        this._setViewportsToBeRenderedNextFrame(viewportIds);\n    }\n    renderSegmentation(segmentationId) {\n        const viewportIds = this._getViewportIdsForSegmentation(segmentationId);\n        this._setViewportsToBeRenderedNextFrame(viewportIds);\n    }\n    _getViewportIdsForSegmentation(segmentationId) {\n        const viewports = this._getAllViewports();\n        const viewportIds = [];\n        for (const viewport of viewports) {\n            const viewportId = viewport.id;\n            if (segmentationId) {\n                const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n                if (segmentationRepresentations?.length > 0) {\n                    viewportIds.push(viewportId);\n                }\n            }\n            else {\n                const segmentationRepresentations = getSegmentationRepresentations(viewportId);\n                if (segmentationRepresentations?.length > 0) {\n                    viewportIds.push(viewportId);\n                }\n            }\n        }\n        return viewportIds;\n    }\n    _throwIfDestroyed() {\n        if (this.hasBeenDestroyed) {\n            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');\n        }\n    }\n    _setViewportsToBeRenderedNextFrame(viewportIds) {\n        if (this._animationFrameSet) {\n            this._pendingRenderQueue.push(viewportIds);\n            return;\n        }\n        viewportIds.forEach((viewportId) => {\n            this._needsRender.add(viewportId);\n        });\n        this._render();\n    }\n    _render() {\n        if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedSegmentations);\n            this._animationFrameSet = true;\n        }\n    }\n    _triggerRender(viewportId) {\n        const segmentationRepresentations = getSegmentationRepresentations(viewportId);\n        if (!segmentationRepresentations?.length) {\n            return;\n        }\n        const { viewport } = getEnabledElementByViewportId(viewportId) || {};\n        if (!viewport) {\n            return;\n        }\n        const segmentationRenderList = segmentationRepresentations.map((representation) => {\n            if (representation.type === SegmentationRepresentations.Contour) {\n                this._addPlanarFreeHandToolIfAbsent(viewport);\n            }\n            const display = renderers[representation.type];\n            const segmentation = getSegmentation(representation.segmentationId);\n            const existingRepresentation = segmentation.representationData[representation.type] !== undefined;\n            try {\n                display.render(viewport, representation).then(() => {\n                    if (!existingRepresentation) {\n                        addDefaultSegmentationListener(viewport, representation.segmentationId, representation.type);\n                    }\n                });\n            }\n            catch (error) {\n                console.error(error);\n            }\n            return Promise.resolve({\n                segmentationId: representation.segmentationId,\n                type: representation.type,\n            });\n        });\n        Promise.allSettled(segmentationRenderList).then((results) => {\n            const segmentationDetails = results\n                .filter((r) => r.status === 'fulfilled')\n                .map((r) => r.value);\n            function onSegmentationRender(evt) {\n                const { element, viewportId } = evt.detail;\n                element.removeEventListener(Enums.Events.IMAGE_RENDERED, onSegmentationRender);\n                segmentationDetails.forEach((detail) => {\n                    const eventDetail = {\n                        viewportId,\n                        segmentationId: detail.segmentationId,\n                        type: detail.type,\n                    };\n                    triggerEvent(eventTarget, csToolsEvents.SEGMENTATION_RENDERED, {\n                        ...eventDetail,\n                    });\n                });\n            }\n            const element = viewport.element;\n            element.addEventListener(Enums.Events.IMAGE_RENDERED, onSegmentationRender);\n            viewport.render();\n        });\n    }\n    _addPlanarFreeHandToolIfAbsent(viewport) {\n        if (!(planarContourToolName in state.tools)) {\n            addTool(PlanarFreehandContourSegmentationTool);\n        }\n        const toolGroup = getToolGroupForViewport(viewport.id);\n        if (!toolGroup.hasTool(planarContourToolName)) {\n            toolGroup.addTool(planarContourToolName);\n            toolGroup.setToolPassive(planarContourToolName);\n        }\n    }\n}\nfunction triggerSegmentationRender(viewportId) {\n    segmentationRenderingEngine.renderSegmentationsForViewport(viewportId);\n}\nfunction triggerSegmentationRenderBySegmentationId(segmentationId) {\n    segmentationRenderingEngine.renderSegmentation(segmentationId);\n}\nconst segmentationRenderingEngine = new SegmentationRenderingEngine();\nexport { triggerSegmentationRender, triggerSegmentationRenderBySegmentationId, segmentationRenderingEngine, };\n","import { quat, vec3 } from 'gl-matrix';\nimport { utilities as csUtils, cache, volumeLoader } from '@cornerstonejs/core';\nimport { run } from './runGrowCut';\nimport { getSphereBoundsInfo } from '../../getSphereBoundsInfo';\nconst { transformWorldToIndex } = csUtils;\nconst POSITIVE_SEED_VALUE = 254;\nconst NEGATIVE_SEED_VALUE = 255;\nconst POSITIVE_SEED_VARIANCE = 0.1;\nconst NEGATIVE_SEED_VARIANCE = 0.8;\nfunction _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo) {\n    const { topLeftWorld, bottomRightWorld } = sphereBoundsInfo;\n    const topLeftIJK = transformWorldToIndex(referencedVolume.imageData, topLeftWorld);\n    const bottomRightIJK = transformWorldToIndex(referencedVolume.imageData, bottomRightWorld);\n    return {\n        ...sphereBoundsInfo,\n        topLeftIJK,\n        bottomRightIJK,\n    };\n}\nfunction _getSphereBoundsInfo(referencedVolume, sphereInfo) {\n    const direction = referencedVolume.imageData.getDirection();\n    const vecColumn = vec3.fromValues(direction[3], direction[4], direction[5]);\n    const { center: sphereCenterPoint, radius: sphereRadius } = sphereInfo;\n    const refVolImageData = referencedVolume.imageData;\n    const topCirclePoint = vec3.scaleAndAdd(vec3.create(), sphereCenterPoint, vecColumn, -sphereRadius);\n    const bottomCirclePoint = vec3.scaleAndAdd(vec3.create(), sphereCenterPoint, vecColumn, sphereRadius);\n    const sphereBoundsInfo = getSphereBoundsInfo([bottomCirclePoint, topCirclePoint], refVolImageData);\n    return _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo);\n}\nfunction _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport) {\n    const refVolImageData = referencedVolume.imageData;\n    const camera = viewport.getCamera();\n    const { ijkVecRowDir, ijkVecColDir } = csUtils.getVolumeDirectionVectors(refVolImageData, camera);\n    const obliqueView = [ijkVecRowDir, ijkVecColDir].some((vec) => !csUtils.isEqual(Math.abs(vec[0]), 1) &&\n        !csUtils.isEqual(Math.abs(vec[1]), 1) &&\n        !csUtils.isEqual(Math.abs(vec[2]), 1));\n    if (obliqueView) {\n        console.warn('Oblique view is not supported!');\n        return;\n    }\n    const { boundsIJK: sphereBoundsIJK } = _getSphereBoundsInfo(referencedVolume, sphereInfo);\n    const subVolumeBoundsIJK = {\n        minX: sphereBoundsIJK[0][0],\n        maxX: sphereBoundsIJK[0][1] + 1,\n        minY: sphereBoundsIJK[1][0],\n        maxY: sphereBoundsIJK[1][1] + 1,\n        minZ: sphereBoundsIJK[2][0],\n        maxZ: sphereBoundsIJK[2][1] + 1,\n    };\n    return csUtils.createSubVolume(referencedVolume.volumeId, subVolumeBoundsIJK, {\n        targetBuffer: {\n            type: 'Float32Array',\n        },\n    });\n}\nfunction _setPositiveSeedValues(referencedVolume, labelmap, sphereInfo, options) {\n    const refVolumePixelData = referencedVolume.voxelManager.getCompleteScalarDataArray();\n    const worldStartPos = sphereInfo.center;\n    const [width, height, numSlices] = referencedVolume.dimensions;\n    const numPixelsPerSlice = width * height;\n    const ijkStartPosition = transformWorldToIndex(referencedVolume.imageData, worldStartPos);\n    const referencePixelValue = refVolumePixelData[ijkStartPosition[2] * numPixelsPerSlice +\n        ijkStartPosition[1] * width +\n        ijkStartPosition[0]];\n    const positiveSeedValue = options.positiveSeedValue ?? POSITIVE_SEED_VALUE;\n    const positiveSeedVariance = options.positiveSeedVariance ?? POSITIVE_SEED_VARIANCE;\n    const positiveSeedVarianceValue = Math.abs(referencePixelValue * positiveSeedVariance);\n    const minPositivePixelValue = referencePixelValue - positiveSeedVarianceValue;\n    const maxPositivePixelValue = referencePixelValue + positiveSeedVarianceValue;\n    const neighborsCoordDelta = [\n        [-1, 0, 0],\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n        [0, 0, 1],\n    ];\n    const startVoxelIndex = ijkStartPosition[2] * numPixelsPerSlice +\n        ijkStartPosition[1] * width +\n        ijkStartPosition[0];\n    labelmap.voxelManager.setAtIndex(startVoxelIndex, positiveSeedValue);\n    const queue = [ijkStartPosition];\n    while (queue.length) {\n        const ijkVoxel = queue.shift();\n        const [x, y, z] = ijkVoxel;\n        for (let i = 0, len = neighborsCoordDelta.length; i < len; i++) {\n            const neighborCoordDelta = neighborsCoordDelta[i];\n            const nx = x + neighborCoordDelta[0];\n            const ny = y + neighborCoordDelta[1];\n            const nz = z + neighborCoordDelta[2];\n            if (nx < 0 ||\n                nx >= width ||\n                ny < 0 ||\n                ny >= height ||\n                nz < 0 ||\n                nz >= numSlices) {\n                continue;\n            }\n            const neighborVoxelIndex = nz * numPixelsPerSlice + ny * width + nx;\n            const neighborPixelValue = refVolumePixelData[neighborVoxelIndex];\n            const neighborLabelmapValue = labelmap.voxelManager.getAtIndex(neighborVoxelIndex);\n            if (neighborLabelmapValue === positiveSeedValue ||\n                neighborPixelValue < minPositivePixelValue ||\n                neighborPixelValue > maxPositivePixelValue) {\n                continue;\n            }\n            labelmap.voxelManager.setAtIndex(neighborVoxelIndex, positiveSeedValue);\n            queue.push([nx, ny, nz]);\n        }\n    }\n}\nfunction _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options) {\n    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const [columns, rows, numSlices] = labelmap.dimensions;\n    const numPixelsPerSlice = columns * rows;\n    const { worldVecRowDir, worldVecSliceDir } = csUtils.getVolumeDirectionVectors(labelmap.imageData, viewport.getCamera());\n    const ijkSphereCenter = transformWorldToIndex(subVolume.imageData, sphereInfo.center);\n    const referencePixelValue = subVolPixelData[ijkSphereCenter[2] * columns * rows +\n        ijkSphereCenter[1] * columns +\n        ijkSphereCenter[0]];\n    const negativeSeedVariance = options.negativeSeedVariance ?? NEGATIVE_SEED_VARIANCE;\n    const negativeSeedValue = options?.negativeSeedValue ?? NEGATIVE_SEED_VALUE;\n    const negativeSeedVarianceValue = Math.abs(referencePixelValue * negativeSeedVariance);\n    const minNegativePixelValue = referencePixelValue - negativeSeedVarianceValue;\n    const maxNegativePixelValue = referencePixelValue + negativeSeedVarianceValue;\n    const numCirclePoints = 360;\n    const rotationAngle = (2 * Math.PI) / numCirclePoints;\n    const worldQuat = quat.setAxisAngle(quat.create(), worldVecSliceDir, rotationAngle);\n    const vecRotation = vec3.clone(worldVecRowDir);\n    for (let i = 0; i < numCirclePoints; i++) {\n        const worldCircleBorderPoint = vec3.scaleAndAdd(vec3.create(), sphereInfo.center, vecRotation, sphereInfo.radius);\n        const ijkCircleBorderPoint = transformWorldToIndex(labelmap.imageData, worldCircleBorderPoint);\n        const [x, y, z] = ijkCircleBorderPoint;\n        vec3.transformQuat(vecRotation, vecRotation, worldQuat);\n        if (x < 0 ||\n            x >= columns ||\n            y < 0 ||\n            y >= rows ||\n            z < 0 ||\n            z >= numSlices) {\n            continue;\n        }\n        const offset = x + y * columns + z * numPixelsPerSlice;\n        const pixelValue = subVolPixelData[offset];\n        if (pixelValue < minNegativePixelValue ||\n            pixelValue > maxNegativePixelValue) {\n            labelmap.voxelManager.setAtIndex(offset, negativeSeedValue);\n        }\n    }\n}\nasync function _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options) {\n    const labelmap = await volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);\n    _setPositiveSeedValues(subVolume, labelmap, sphereInfo, options);\n    _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options);\n    return labelmap;\n}\nasync function runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    const subVolume = _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport);\n    const labelmap = await _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options);\n    await run(subVolume.volumeId, labelmap.volumeId);\n    return labelmap;\n}\nexport { runGrowCutForSphere as default, runGrowCutForSphere };\n","export const POSITIVE_SEED_LABEL = 254;\nexport const NEGATIVE_SEED_LABEL = 255;\nexport const DEFAULT_NEIGHBORHOOD_RADIUS = 1;\nexport const DEFAULT_POSITIVE_STD_DEV_MULTIPLIER = 1.8;\nexport const DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER = 3.2;\nexport const DEFAULT_NEGATIVE_SEED_MARGIN = 30;\nexport const DEFAULT_NEGATIVE_SEEDS_COUNT = 70;\nexport const MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER = 50;\n","import { utilities as csUtils, cache, volumeLoader } from '@cornerstonejs/core';\nimport { run } from './runGrowCut';\nimport { POSITIVE_SEED_LABEL, NEGATIVE_SEED_LABEL, DEFAULT_NEIGHBORHOOD_RADIUS, DEFAULT_POSITIVE_STD_DEV_MULTIPLIER, DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER, DEFAULT_NEGATIVE_SEED_MARGIN, DEFAULT_NEGATIVE_SEEDS_COUNT, MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER, } from './constants';\nconst { transformWorldToIndex } = csUtils;\nconst MAX_POSITIVE_SEEDS = 100000;\nfunction calculateGrowCutSeeds(referencedVolume, worldPosition, options) {\n    const { dimensions, imageData: refImageData } = referencedVolume;\n    const [width, height, numSlices] = dimensions;\n    const referenceVolumeVoxelManager = referencedVolume.voxelManager;\n    const scalarData = referenceVolumeVoxelManager.getCompleteScalarDataArray();\n    const numPixelsPerSlice = width * height;\n    const neighborhoodRadius = options?.initialNeighborhoodRadius ?? DEFAULT_NEIGHBORHOOD_RADIUS;\n    const positiveK = options?.positiveStdDevMultiplier ?? DEFAULT_POSITIVE_STD_DEV_MULTIPLIER;\n    const negativeK = options?.negativeStdDevMultiplier ?? DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER;\n    const negativeSeedMargin = options?.negativeSeedMargin ?? DEFAULT_NEGATIVE_SEED_MARGIN;\n    const negativeSeedsTargetPatches = options?.negativeSeedsTargetPatches ?? DEFAULT_NEGATIVE_SEEDS_COUNT;\n    const ijkStart = transformWorldToIndex(refImageData, worldPosition).map(Math.round);\n    const startIndex = referenceVolumeVoxelManager.toIndex(ijkStart);\n    if (ijkStart[0] < 0 ||\n        ijkStart[0] >= width ||\n        ijkStart[1] < 0 ||\n        ijkStart[1] >= height ||\n        ijkStart[2] < 0 ||\n        ijkStart[2] >= numSlices) {\n        console.warn('Click position is outside volume bounds.');\n        return null;\n    }\n    const initialStats = csUtils.calculateNeighborhoodStats(scalarData, dimensions, ijkStart, neighborhoodRadius);\n    if (initialStats.count === 0) {\n        initialStats.mean = scalarData[startIndex];\n        initialStats.stdDev = 0;\n    }\n    const positiveIntensityMin = initialStats.mean - positiveK * initialStats.stdDev;\n    const positiveIntensityMax = initialStats.mean + positiveK * initialStats.stdDev;\n    const neighborsCoordDelta = [\n        [-1, 0, 0],\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n        [0, 0, 1],\n    ];\n    let minX = Infinity, minY = Infinity, minZ = Infinity;\n    let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;\n    const positiveSeedIndices = new Set();\n    const queue = [];\n    const startValue = scalarData[startIndex];\n    if (startValue >= positiveIntensityMin &&\n        startValue <= positiveIntensityMax) {\n        positiveSeedIndices.add(startIndex);\n        queue.push(ijkStart);\n        minX = maxX = ijkStart[0];\n        minY = maxY = ijkStart[1];\n        minZ = maxZ = ijkStart[2];\n    }\n    else {\n        console.warn('Clicked voxel intensity is outside the calculated positive range. No positive seeds generated.');\n        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };\n    }\n    let currentQueueIndex = 0;\n    while (currentQueueIndex < queue.length &&\n        positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {\n        const [x, y, z] = queue[currentQueueIndex++];\n        minX = Math.min(x, minX);\n        minY = Math.min(y, minY);\n        minZ = Math.min(z, minZ);\n        maxX = Math.max(x, maxX);\n        maxY = Math.max(y, maxY);\n        maxZ = Math.max(z, maxZ);\n        for (let i = 0; i < neighborsCoordDelta.length; i++) {\n            const [dx, dy, dz] = neighborsCoordDelta[i];\n            const nx = x + dx;\n            const ny = y + dy;\n            const nz = z + dz;\n            if (nx < 0 ||\n                nx >= width ||\n                ny < 0 ||\n                ny >= height ||\n                nz < 0 ||\n                nz >= numSlices) {\n                continue;\n            }\n            const neighborIndex = nz * numPixelsPerSlice + ny * width + nx;\n            if (positiveSeedIndices.has(neighborIndex)) {\n                continue;\n            }\n            const neighborValue = scalarData[neighborIndex];\n            if (neighborValue >= positiveIntensityMin &&\n                neighborValue <= positiveIntensityMax) {\n                positiveSeedIndices.add(neighborIndex);\n                if (positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {\n                    queue.push([nx, ny, nz]);\n                }\n            }\n        }\n    }\n    if (positiveSeedIndices.size >= MAX_POSITIVE_SEEDS) {\n        console.debug(`Reached maximum number of positive seeds (${MAX_POSITIVE_SEEDS}). Stopping BFS.`);\n    }\n    if (positiveSeedIndices.size === 0) {\n        console.warn('No positive seeds found after BFS.');\n        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };\n    }\n    let positiveSum = 0;\n    let positiveSumSq = 0;\n    positiveSeedIndices.forEach((index) => {\n        const value = scalarData[index];\n        positiveSum += value;\n        positiveSumSq += value * value;\n    });\n    const positiveCount = positiveSeedIndices.size;\n    const positiveMean = positiveSum / positiveCount;\n    const positiveVariance = positiveSumSq / positiveCount - positiveMean * positiveMean;\n    const positiveStdDev = Math.sqrt(Math.max(0, positiveVariance));\n    const negativeDiffThreshold = negativeK * positiveStdDev;\n    const minXm = Math.max(0, minX - negativeSeedMargin);\n    const minYm = Math.max(0, minY - negativeSeedMargin);\n    const minZm = Math.max(0, minZ - negativeSeedMargin);\n    const maxXm = Math.min(width - 1, maxX + negativeSeedMargin);\n    const maxYm = Math.min(height - 1, maxY + negativeSeedMargin);\n    const maxZm = Math.min(numSlices - 1, maxZ + negativeSeedMargin);\n    const negativeSeedIndices = new Set();\n    let attempts = 0;\n    let patchesAdded = 0;\n    const maxAttempts = negativeSeedsTargetPatches * MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER;\n    while (patchesAdded < negativeSeedsTargetPatches && attempts < maxAttempts) {\n        attempts++;\n        const rx = Math.floor(Math.random() * (maxXm - minXm + 1) + minXm);\n        const ry = Math.floor(Math.random() * (maxYm - minYm + 1) + minYm);\n        const rz = Math.floor(Math.random() * (maxZm - minZm + 1) + minZm);\n        const centerIndex = rz * numPixelsPerSlice + ry * width + rx;\n        if (positiveSeedIndices.has(centerIndex) ||\n            negativeSeedIndices.has(centerIndex)) {\n            continue;\n        }\n        const centerValue = scalarData[centerIndex];\n        if (Math.abs(centerValue - positiveMean) > negativeDiffThreshold) {\n            let patchContributed = false;\n            for (let dy = -1; dy <= 1; dy++) {\n                const ny = ry + dy;\n                if (ny < 0 || ny >= height) {\n                    continue;\n                }\n                for (let dx = -1; dx <= 1; dx++) {\n                    const nx = rx + dx;\n                    if (nx < 0 || nx >= width) {\n                        continue;\n                    }\n                    const neighborIndex = rz * numPixelsPerSlice + ny * width + nx;\n                    if (positiveSeedIndices.has(neighborIndex) ||\n                        negativeSeedIndices.has(neighborIndex)) {\n                        continue;\n                    }\n                    negativeSeedIndices.add(neighborIndex);\n                    patchContributed = true;\n                }\n            }\n            if (patchContributed) {\n                patchesAdded++;\n            }\n        }\n    }\n    if (negativeSeedIndices.size === 0) {\n        console.warn('Could not find any negative seeds. GrowCut might fail or produce poor results.');\n    }\n    console.debug('positiveSeedIndices', positiveSeedIndices.size);\n    console.debug('negativeSeedIndices', negativeSeedIndices.size);\n    return { positiveSeedIndices, negativeSeedIndices };\n}\nasync function runOneClickGrowCut({ referencedVolumeId, worldPosition, options, }) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    const labelmap = volumeLoader.createAndCacheDerivedLabelmapVolume(referencedVolumeId);\n    labelmap.voxelManager.forEach(({ index, value }) => {\n        if (value !== 0) {\n            labelmap.voxelManager.setAtIndex(index, 0);\n        }\n    });\n    const seeds = options.seeds ??\n        calculateGrowCutSeeds(referencedVolume, worldPosition, options);\n    const positiveSeedLabel = options?.positiveSeedValue ?? POSITIVE_SEED_LABEL;\n    const negativeSeedLabel = options?.negativeSeedValue ?? NEGATIVE_SEED_LABEL;\n    if (!seeds) {\n        return null;\n    }\n    const { positiveSeedIndices, negativeSeedIndices } = seeds;\n    if (positiveSeedIndices.size < 10 ||\n        positiveSeedIndices.size > MAX_POSITIVE_SEEDS ||\n        negativeSeedIndices.size < 10) {\n        console.warn('Not enough seeds found. GrowCut might fail or produce poor results.');\n        return labelmap;\n    }\n    positiveSeedIndices.forEach((index) => {\n        labelmap.voxelManager.setAtIndex(index, positiveSeedLabel);\n    });\n    negativeSeedIndices.forEach((index) => {\n        labelmap.voxelManager.setAtIndex(index, negativeSeedLabel);\n    });\n    await run(referencedVolumeId, labelmap.volumeId, options);\n    return labelmap;\n}\nexport { runOneClickGrowCut as default, runOneClickGrowCut, calculateGrowCutSeeds, };\n","class EdgeLocator {\n  constructor() {\n    let oriented = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.oriented = oriented;\n    this.edgeMap = new Map();\n  }\n  initialize() {\n    this.edgeMap.clear();\n  }\n  computeEdgeKey(pointId0, pointId1) {\n    return this.oriented || pointId0 < pointId1 ?\n    // Cantor pairing function:\n    0.5 * (pointId0 * pointId1) * (pointId0 * pointId1 + 1) + pointId1 : 0.5 * (pointId1 * pointId0) * (pointId1 * pointId0 + 1) + pointId0;\n  }\n  insertUniqueEdge(pointId0, pointId1, newEdgeValue) {\n    // Generate a unique key\n    const key = this.computeEdgeKey(pointId0, pointId1);\n    let node = this.edgeMap.get(key);\n    if (!node) {\n      // Didn't find key, so add a new edge entry\n      node = {\n        key,\n        edgeId: this.edgeMap.size,\n        value: newEdgeValue\n      };\n      this.edgeMap.set(key, node);\n    }\n    return node;\n  }\n  insertEdge(pointId0, pointId1, newEdgeValue) {\n    // Generate a unique key\n    const key = this.computeEdgeKey(pointId0, pointId1);\n    const node = {\n      key,\n      edgeId: this.edgeMap.size,\n      value: newEdgeValue\n    };\n    this.edgeMap.set(key, node);\n    return node;\n  }\n  isInsertedEdge(pointId0, pointId1) {\n    const key = this.computeEdgeKey(pointId0, pointId1);\n    return this.edgeMap.get(key);\n  }\n  static getEdgePointIds(node) {\n    const n = 0.5 * (-1 + Math.sqrt(8 * node.key + 1));\n    const pointId0 = node.key - 0.5 * (n + 1) * n;\n    const pointId1 = n - pointId0;\n    return [pointId0, pointId1];\n  }\n}\nfunction newInstance() {\n  let initialValues = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  return new EdgeLocator(initialValues.oriented);\n}\nvar vtkEdgeLocator = {\n  newInstance\n};\n\nexport { vtkEdgeLocator as default };\n","// ----------------------------------------------------------------------------\n// Marching squares case functions (using lines to generate the 2D tessellation).\n// For each case, a list of edge ids that form the triangles. A -1 marks the\n// end of the list of edges. Edges are taken three at a time to generate\n// triangle points.\n// ----------------------------------------------------------------------------\nconst MARCHING_SQUARES_CASES = [[-1, -1, -1, -1, -1] /* 0 */, [0, 3, -1, -1, -1] /* 1 */, [1, 0, -1, -1, -1] /* 2 */, [1, 3, -1, -1, -1] /* 3 */, [2, 1, -1, -1, -1] /* 4 */, [0, 3, 2, 1, -1] /* 5 */, [2, 0, -1, -1, -1] /* 6 */, [2, 3, -1, -1, -1] /* 7 */, [3, 2, -1, -1, -1] /* 8 */, [0, 2, -1, -1, -1] /* 9 */, [1, 0, 3, 2, -1] /* 10 */, [1, 2, -1, -1, -1] /* 11 */, [3, 1, -1, -1, -1] /* 12 */, [0, 1, -1, -1, -1] /* 13 */, [3, 0, -1, -1, -1] /* 14 */, [-1, -1, -1, -1, -1] /* 15 */];\n\nconst EDGES = [[0, 1], [1, 3], [2, 3], [0, 2]];\nfunction getCase(index) {\n  return MARCHING_SQUARES_CASES[index];\n}\n\n// Define the four edges of the pixel by the following pairs of vertices\nfunction getEdge(eid) {\n  return EDGES[eid];\n}\n\n// ----------------------------------------------------------------------------\n// Static API\n// ----------------------------------------------------------------------------\nvar vtkCaseTable = {\n  getCase,\n  getEdge\n};\n\nexport { vtkCaseTable as default };\n","import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\nimport vtkEdgeLocator from '../../Common/DataModel/EdgeLocator.js';\nimport vtkCaseTable from './ImageMarchingSquares/caseTable.js';\n\nconst {\n  vtkErrorMacro,\n  vtkDebugMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageMarchingSquares methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageMarchingSquares(publicAPI, model) {\n  /**\n   * Get the X,Y kernels based on the set slicing mode.\n   * @returns {[number, number]}\n   */\n  function getKernels() {\n    let kernelX = 0; // default K slicing mode\n    let kernelY = 1;\n    if (model.slicingMode === 1) {\n      kernelX = 0;\n      kernelY = 2;\n    } else if (model.slicingMode === 0) {\n      kernelX = 1;\n      kernelY = 2;\n    }\n    return [kernelX, kernelY];\n  }\n\n  // Set our className\n  model.classHierarchy.push('vtkImageMarchingSquares');\n\n  /**\n   * Get the list of contour values.\n   * @returns {number[]}\n   */\n  publicAPI.getContourValues = () => model.contourValues;\n\n  /**\n   * Set the list contour values.\n   * @param {number[]} cValues\n   */\n  publicAPI.setContourValues = cValues => {\n    model.contourValues = cValues;\n    publicAPI.modified();\n  };\n  const ids = [];\n  const pixelScalars = [];\n  const pixelPts = [];\n  const edgeLocator = vtkEdgeLocator.newInstance();\n\n  /**\n   * Retrieve scalars and pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelScalars = (ijk, dims, scalars, increments, kernelX, kernelY) => {\n    const [i, j, k] = ijk;\n\n    // First get the indices for the pixel\n    ids[0] = k * dims[1] * dims[0] + j * dims[0] + i; // i, j, k\n    ids[1] = ids[0] + increments[kernelX]; // i+1, j, k\n    ids[2] = ids[0] + increments[kernelY]; // i, j+1, k\n    ids[3] = ids[2] + increments[kernelX]; // i+1, j+1, k\n\n    // Now retrieve the scalars\n    for (let ii = 0; ii < 4; ++ii) {\n      pixelScalars[ii] = scalars[ids[ii]];\n    }\n  };\n\n  /**\n   * Retrieve pixel coordinates.\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing spacing of the image\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.getPixelPoints = (ijk, origin, spacing, kernelX, kernelY) => {\n    const i = ijk[kernelX];\n    const j = ijk[kernelY];\n\n    // (i,i+1),(j,j+1),(k,k+1) - i varies fastest; then j; then k\n    pixelPts[0] = origin[kernelX] + i * spacing[kernelX]; // 0\n    pixelPts[1] = origin[kernelY] + j * spacing[kernelY];\n    pixelPts[2] = pixelPts[0] + spacing[kernelX]; // 1\n    pixelPts[3] = pixelPts[1];\n    pixelPts[4] = pixelPts[0]; // 2\n    pixelPts[5] = pixelPts[1] + spacing[kernelY];\n    pixelPts[6] = pixelPts[2]; // 3\n    pixelPts[7] = pixelPts[5];\n  };\n\n  /**\n   * Produce points and lines for the polydata.\n   * @param {number[]} cVal list of contour values\n   * @param {Vector3} ijk origin of the pixel\n   * @param {Vector3} dims dimensions of the image\n   * @param {Vector3} origin origin of the image\n   * @param {Vector3} spacing sapcing of the image\n   * @param {TypedArray} scalars list of scalar values\n   * @param {number[]} points list of points\n   * @param {number[]} lines list of lines\n   * @param {Vector3} increments IJK slice increments\n   * @param {number} kernelX index of the X element\n   * @param {number} kernelY index of the Y element\n   */\n  publicAPI.produceLines = (cVal, ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY) => {\n    const k = ijk[model.slicingMode];\n    const CASE_MASK = [1, 2, 8, 4]; // case table is actually for quad\n    const xyz = [];\n    let pId;\n    publicAPI.getPixelScalars(ijk, dims, scalars, increments, kernelX, kernelY);\n    let index = 0;\n    for (let idx = 0; idx < 4; idx++) {\n      if (pixelScalars[idx] >= cVal) {\n        index |= CASE_MASK[idx]; // eslint-disable-line no-bitwise\n      }\n    }\n\n    const pixelLines = vtkCaseTable.getCase(index);\n    if (pixelLines[0] < 0) {\n      return; // don't get the pixel coordinates, nothing to do\n    }\n\n    publicAPI.getPixelPoints(ijk, origin, spacing, kernelX, kernelY);\n    const z = origin[model.slicingMode] + k * spacing[model.slicingMode];\n    for (let idx = 0; pixelLines[idx] >= 0; idx += 2) {\n      lines.push(2);\n      for (let eid = 0; eid < 2; eid++) {\n        const edgeVerts = vtkCaseTable.getEdge(pixelLines[idx + eid]);\n        pId = undefined;\n        if (model.mergePoints) {\n          pId = edgeLocator.isInsertedEdge(ids[edgeVerts[0]], ids[edgeVerts[1]])?.value;\n        }\n        if (pId === undefined) {\n          const t = (cVal - pixelScalars[edgeVerts[0]]) / (pixelScalars[edgeVerts[1]] - pixelScalars[edgeVerts[0]]);\n          const x0 = pixelPts.slice(edgeVerts[0] * 2, (edgeVerts[0] + 1) * 2);\n          const x1 = pixelPts.slice(edgeVerts[1] * 2, (edgeVerts[1] + 1) * 2);\n          xyz[kernelX] = x0[0] + t * (x1[0] - x0[0]);\n          xyz[kernelY] = x0[1] + t * (x1[1] - x0[1]);\n          xyz[model.slicingMode] = z;\n          pId = points.length / 3;\n          points.push(xyz[0], xyz[1], xyz[2]);\n          if (model.mergePoints) {\n            edgeLocator.insertEdge(ids[edgeVerts[0]], ids[edgeVerts[1]], pId);\n          }\n        }\n        lines.push(pId);\n      }\n    }\n  };\n  publicAPI.requestData = (inData, outData) => {\n    // implement requestData\n    const input = inData[0];\n    if (!input) {\n      vtkErrorMacro('Invalid or missing input');\n      return;\n    }\n    if (model.slicingMode == null || model.slicingMode < 0 || model.slicingMode > 2) {\n      vtkErrorMacro('Invalid or missing slicing mode');\n      return;\n    }\n    console.time('msquares');\n\n    // Retrieve output and volume data\n    const origin = input.getOrigin();\n    const spacing = input.getSpacing();\n    const dims = input.getDimensions();\n    const extent = input.getExtent();\n    const increments = input.computeIncrements(extent);\n    const scalars = input.getPointData().getScalars().getData();\n    const [kernelX, kernelY] = getKernels();\n\n    // Points - dynamic array\n    const points = [];\n\n    // Cells - dynamic array\n    const lines = [];\n\n    // Ensure slice is valid\n    let k = Math.round(model.slice);\n    if (k >= dims[model.slicingMode]) {\n      k = 0;\n    }\n\n    // Loop over all contour values, and then pixels, determine case and process\n    const ijk = [0, 0, 0];\n    ijk[model.slicingMode] = k;\n    for (let cv = 0; cv < model.contourValues.length; ++cv) {\n      for (let j = 0; j < dims[kernelY] - 1; ++j) {\n        ijk[kernelY] = j;\n        for (let i = 0; i < dims[kernelX] - 1; ++i) {\n          ijk[kernelX] = i;\n          publicAPI.produceLines(model.contourValues[cv], ijk, dims, origin, spacing, scalars, points, lines, increments, kernelX, kernelY);\n        }\n      }\n      edgeLocator.initialize();\n    }\n\n    // Update output\n    const polydata = vtkPolyData.newInstance();\n    polydata.getPoints().setData(new Float32Array(points), 3);\n    polydata.getLines().setData(new Uint32Array(lines));\n    outData[0] = polydata;\n    vtkDebugMacro('Produced output');\n    console.timeEnd('msquares');\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  contourValues: [],\n  slicingMode: 2,\n  slice: 0,\n  mergePoints: false\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Make this a VTK object\n  macro.obj(publicAPI, model);\n\n  // Also make it an algorithm with one input and one output\n  macro.algo(publicAPI, model, 1, 1);\n  macro.setGet(publicAPI, model, ['slicingMode', 'slice', 'mergePoints']);\n\n  // Object specific methods\n  macro.algo(publicAPI, model, 1, 1);\n  vtkImageMarchingSquares(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageMarchingSquares');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageMarchingSquares$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageMarchingSquares$1 as default, extend, newInstance };\n","import { expose } from 'comlink';\nimport { utilities } from '@cornerstonejs/core';\nimport SegmentStatsCalculator from '../utilities/segmentation/SegmentStatsCalculator';\nimport { getSegmentLargestBidirectional } from '../utilities/segmentation';\nimport vtkImageMarchingSquares from '@kitware/vtk.js/Filters/General/ImageMarchingSquares';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { getDeduplicatedVTKPolyDataPoints } from '../utilities/contours/getDeduplicatedVTKPolyDataPoints';\nimport { findContoursFromReducedSet } from '../utilities/contours/contourFinder';\nimport { createBidirectionalForSlice } from '../utilities/segmentation/findLargestBidirectional';\nimport { createIsInSegmentMetadata } from '../utilities/segmentation/isLineInSegment';\nconst { VoxelManager } = utilities;\nconst computeWorker = {\n    createVoxelManager: (dimensions, scalarData) => {\n        return VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData,\n        });\n    },\n    createDataStructure: (info) => {\n        const { scalarData, dimensions, spacing, origin, direction } = info;\n        const voxelManager = computeWorker.createVoxelManager(dimensions, scalarData);\n        return {\n            voxelManager,\n            dimensions,\n            spacing,\n            origin,\n            direction,\n            scalarData,\n        };\n    },\n    createVTKImageData: (dimensions, origin, direction, spacing, scalarData) => {\n        const imageData = vtkImageData.newInstance();\n        imageData.setDimensions(dimensions);\n        imageData.setOrigin(origin);\n        imageData.setDirection(direction);\n        imageData.setSpacing(spacing);\n        if (!scalarData) {\n            return imageData;\n        }\n        const scalarArray = vtkDataArray.newInstance({\n            name: 'Scalars',\n            numberOfComponents: 1,\n            values: scalarData,\n        });\n        imageData.getPointData().setScalars(scalarArray);\n        return imageData;\n    },\n    processSegmentStatistics: ({ segVoxelManager, imageVoxelManager, indices, bounds, imageData, }) => {\n        segVoxelManager.forEach(({ value, pointIJK, pointLPS, index }) => {\n            if (indices.indexOf(value) === -1) {\n                return;\n            }\n            const imageValue = imageVoxelManager.getAtIndex(index);\n            SegmentStatsCalculator.statsCallback({\n                segmentIndex: value,\n                value: imageValue,\n                pointIJK,\n                pointLPS,\n            });\n        }, {\n            boundsIJK: bounds || imageVoxelManager.getDefaultBounds(),\n            imageData,\n        });\n    },\n    performMarchingSquares: (imageData, sliceIndex = null, slicingMode = null) => {\n        const options = {};\n        if (sliceIndex !== null) {\n            options.slice = sliceIndex;\n        }\n        if (slicingMode !== null) {\n            options.slicingMode = slicingMode;\n        }\n        const mSquares = vtkImageMarchingSquares.newInstance(options);\n        mSquares.setInputData(imageData);\n        mSquares.setContourValues([1]);\n        mSquares.setMergePoints(false);\n        return mSquares.getOutputData();\n    },\n    createContoursFromPolyData: (msOutput, sliceIndex = null) => {\n        const reducedSet = getDeduplicatedVTKPolyDataPoints(msOutput);\n        if (reducedSet.points?.length) {\n            const contours = findContoursFromReducedSet(reducedSet.lines);\n            return {\n                contours,\n                polyData: reducedSet,\n            };\n        }\n        return null;\n    },\n    createSegmentsFromIndices: (indices) => {\n        return [null, ...indices.map((index) => ({ segmentIndex: index }))];\n    },\n    getArgsFromInfo: (args) => {\n        const { segmentationInfo, imageInfo } = args;\n        const getSegmentationData = () => {\n            return computeWorker.createDataStructure(segmentationInfo);\n        };\n        const getImageData = () => {\n            return computeWorker.createDataStructure(imageInfo);\n        };\n        return {\n            segmentation: segmentationInfo && getSegmentationData(),\n            image: imageInfo && getImageData(),\n        };\n    },\n    calculateSegmentsStatisticsVolume: (args) => {\n        const { mode, indices, unit } = args;\n        const { segmentation, image } = computeWorker.getArgsFromInfo(args);\n        const { voxelManager: segVoxelManager, spacing: segmentationSpacing } = segmentation;\n        const { voxelManager: imageVoxelManager } = image;\n        const imageData = computeWorker.createVTKImageData(segmentation.dimensions, segmentation.origin, segmentation.direction, segmentation.spacing);\n        SegmentStatsCalculator.statsInit({ storePointData: false, indices, mode });\n        computeWorker.processSegmentStatistics({\n            segVoxelManager,\n            imageVoxelManager,\n            indices,\n            imageData,\n        });\n        const stats = SegmentStatsCalculator.getStatistics({\n            spacing: segmentationSpacing,\n            mode,\n            unit,\n        });\n        return stats;\n    },\n    computeMetabolicStats({ segmentationInfo, imageInfo }) {\n        const { scalarData, dimensions, spacing, origin, direction } = segmentationInfo;\n        const { spacing: imageSpacing, dimensions: imageDimensions, direction: imageDirection, origin: imageOrigin, scalarData: imageScalarData, } = imageInfo;\n        const segVoxelManager = computeWorker.createVoxelManager(segmentationInfo.dimensions, segmentationInfo.scalarData);\n        const refVoxelManager = computeWorker.createVoxelManager(imageDimensions, imageScalarData);\n        let suv = 0;\n        let numVoxels = 0;\n        const scalarDataLength = segVoxelManager.getScalarDataLength();\n        for (let i = 0; i < scalarDataLength; i++) {\n            if (segVoxelManager.getAtIndex(i) !== 0) {\n                suv += refVoxelManager.getAtIndex(i);\n                numVoxels++;\n            }\n        }\n        const tmtv = 1e-3 * numVoxels * spacing[0] * spacing[1] * spacing[2];\n        const averageSuv = numVoxels > 0 ? suv / numVoxels : 0;\n        const tlg = averageSuv *\n            numVoxels *\n            imageSpacing[0] *\n            imageSpacing[1] *\n            imageSpacing[2] *\n            1e-3;\n        return {\n            tmtv,\n            tlg,\n        };\n    },\n    calculateSegmentsStatisticsStack: (args) => {\n        const { segmentationInfo, imageInfo, indices, mode } = args;\n        SegmentStatsCalculator.statsInit({ storePointData: true, indices, mode });\n        for (let i = 0; i < segmentationInfo.length; i++) {\n            const segInfo = segmentationInfo[i];\n            const imgInfo = imageInfo[i];\n            const segDimensions = [\n                segInfo.dimensions[0],\n                segInfo.dimensions[1],\n                1,\n            ];\n            const segVoxelManager = computeWorker.createVoxelManager(segDimensions, segInfo.scalarData);\n            const imageVoxelManager = computeWorker.createVoxelManager(segDimensions, imgInfo.scalarData);\n            const imageData = computeWorker.createVTKImageData(segDimensions, segInfo.origin, segInfo.direction, segInfo.spacing);\n            computeWorker.processSegmentStatistics({\n                segVoxelManager,\n                imageVoxelManager,\n                indices,\n                imageData,\n            });\n        }\n        const spacing = segmentationInfo[0].spacing;\n        const stats = SegmentStatsCalculator.getStatistics({\n            spacing,\n            mode,\n        });\n        return stats;\n    },\n    getSegmentLargestBidirectionalInternal: (args) => {\n        const { segmentationInfo, imageInfo, indices, mode, isStack } = args;\n        let segmentation;\n        if (!isStack) {\n            ({ segmentation } = computeWorker.getArgsFromInfo(args));\n        }\n        else {\n            ({ segmentation } = computeWorker.getArgsFromInfo({\n                segmentationInfo: segmentationInfo[0],\n            }));\n        }\n        return isStack\n            ? computeWorker.calculateBidirectionalStack({\n                segmentationInfo,\n                indices,\n                mode,\n            })\n            : computeWorker.calculateVolumetricBidirectional({\n                segmentation,\n                indices,\n                mode,\n            });\n    },\n    findLargestBidirectionalFromContours: (contours, isInSegment, segmentIndex) => {\n        let maxBidirectional;\n        for (const sliceContour of contours) {\n            const bidirectional = createBidirectionalForSlice(sliceContour, isInSegment, maxBidirectional);\n            if (!bidirectional) {\n                continue;\n            }\n            maxBidirectional = bidirectional;\n        }\n        if (maxBidirectional) {\n            return {\n                segmentIndex,\n                majorAxis: maxBidirectional.majorAxis,\n                minorAxis: maxBidirectional.minorAxis,\n                maxMajor: maxBidirectional.maxMajor,\n                maxMinor: maxBidirectional.maxMinor,\n            };\n        }\n        return null;\n    },\n    calculateBidirectionalStack: ({ segmentationInfo, indices, mode }) => {\n        const segments = computeWorker.createSegmentsFromIndices(indices);\n        let bidirectionalResults = [];\n        for (let i = 0; i < segmentationInfo.length; i++) {\n            const segInfo = segmentationInfo[i];\n            const dimensions = segInfo.dimensions;\n            const segScalarData = segInfo.scalarData;\n            const { spacing, direction, origin } = segInfo;\n            const voxelManager = computeWorker.createVoxelManager(dimensions, segScalarData);\n            const pixelsPerSlice = dimensions[0] * dimensions[1];\n            for (let segIndex = 1; segIndex < segments.length; segIndex++) {\n                const segment = segments[segIndex];\n                if (!segment) {\n                    continue;\n                }\n                const segmentIndex = segment.segmentIndex;\n                if (computeWorker.isSliceEmptyForSegmentVolume(0, segScalarData, pixelsPerSlice, segmentIndex)) {\n                    continue;\n                }\n                const sliceContours = [];\n                const filteredData = new Uint8Array(segScalarData.length);\n                for (let i = 0; i < segScalarData.length; i++) {\n                    filteredData[i] = segScalarData[i] === segmentIndex ? 1 : 0;\n                }\n                const scalarArray = vtkDataArray.newInstance({\n                    name: 'Pixels',\n                    numberOfComponents: 1,\n                    values: filteredData,\n                });\n                const imageData = computeWorker.createVTKImageData(dimensions, origin, direction, [spacing[0], spacing[1], 1]);\n                imageData.getPointData().setScalars(scalarArray);\n                try {\n                    const msOutput = computeWorker.performMarchingSquares(imageData, null, 2);\n                    const contourData = computeWorker.createContoursFromPolyData(msOutput);\n                    if (contourData) {\n                        sliceContours.push(contourData);\n                    }\n                }\n                catch (e) {\n                    console.warn(e);\n                }\n                const isInSegment = createIsInSegmentMetadata({\n                    dimensions,\n                    imageData,\n                    voxelManager,\n                    segmentIndex,\n                });\n                const bidirectionalResult = computeWorker.findLargestBidirectionalFromContours(sliceContours, isInSegment, segmentIndex);\n                if (bidirectionalResult) {\n                    bidirectionalResults.push(bidirectionalResult);\n                }\n            }\n        }\n        return bidirectionalResults;\n    },\n    calculateVolumetricBidirectional: ({ segmentation, indices, mode }) => {\n        const { voxelManager, dimensions, origin, direction, spacing } = segmentation;\n        const imageData = computeWorker.createVTKImageData(dimensions, origin, direction, spacing);\n        const contourSets = computeWorker.generateContourSetsFromLabelmapVolume({\n            segmentation,\n            indices,\n            imageData,\n            mode,\n        });\n        const bidirectionalResults = [];\n        for (let i = 0; i < contourSets.length; i++) {\n            const contourSet = contourSets[i];\n            const { segmentIndex } = contourSet.segment;\n            const contours = contourSet.sliceContours;\n            const isInSegment = createIsInSegmentMetadata({\n                dimensions,\n                imageData,\n                voxelManager,\n                segmentIndex,\n            });\n            const bidirectionalResult = computeWorker.findLargestBidirectionalFromContours(contours, isInSegment, segmentIndex);\n            if (bidirectionalResult) {\n                bidirectionalResults.push(bidirectionalResult);\n            }\n        }\n        return bidirectionalResults;\n    },\n    generateContourSetsFromLabelmapVolume: (args) => {\n        const { segmentation, indices } = args;\n        const { dimensions, scalarData, origin, direction, spacing } = segmentation;\n        let imageData = args.imageData;\n        if (!imageData) {\n            imageData = computeWorker.createVTKImageData(dimensions, origin, direction, spacing);\n        }\n        const numSlices = dimensions[2];\n        const pixelsPerSlice = dimensions[0] * dimensions[1];\n        const segments = computeWorker.createSegmentsFromIndices(indices);\n        for (let z = 0; z < numSlices; z++) {\n            for (let y = 0; y < dimensions[1]; y++) {\n                const index = y * dimensions[0] + z * pixelsPerSlice;\n                scalarData[index] = 0;\n                scalarData[index + dimensions[0] - 1] = 0;\n            }\n        }\n        const ContourSets = [];\n        const numSegments = segments.length;\n        for (let segIndex = 0; segIndex < numSegments; segIndex++) {\n            const segment = segments[segIndex];\n            if (!segment) {\n                continue;\n            }\n            const segmentIndex = segment.segmentIndex;\n            const sliceContours = [];\n            const scalars = vtkDataArray.newInstance({\n                name: 'Scalars',\n                numberOfComponents: 1,\n                size: pixelsPerSlice * numSlices,\n                dataType: 'Uint8Array',\n            });\n            for (let sliceIndex = 0; sliceIndex < numSlices; sliceIndex++) {\n                if (computeWorker.isSliceEmptyForSegmentVolume(sliceIndex, scalarData, pixelsPerSlice, segmentIndex)) {\n                    continue;\n                }\n                const frameStart = sliceIndex * pixelsPerSlice;\n                try {\n                    for (let i = 0; i < pixelsPerSlice; i++) {\n                        const value = scalarData[i + frameStart];\n                        if (value === segmentIndex) {\n                            scalars.setValue(i + frameStart, 1);\n                        }\n                        else {\n                            scalars.setValue(i, 0);\n                        }\n                    }\n                    const imageDataCopy = vtkImageData.newInstance();\n                    imageDataCopy.shallowCopy(imageData);\n                    imageDataCopy.getPointData().setScalars(scalars);\n                    const msOutput = computeWorker.performMarchingSquares(imageDataCopy, sliceIndex);\n                    const contourData = computeWorker.createContoursFromPolyData(msOutput, sliceIndex);\n                    if (contourData) {\n                        sliceContours.push(contourData);\n                    }\n                }\n                catch (e) {\n                    console.warn(sliceIndex);\n                    console.warn(e);\n                }\n            }\n            const ContourSet = {\n                sliceContours,\n                segment,\n            };\n            ContourSets.push(ContourSet);\n        }\n        return ContourSets;\n    },\n    isSliceEmptyForSegmentVolume: (sliceIndex, segData, pixelsPerSlice, segIndex) => {\n        const startIdx = sliceIndex * pixelsPerSlice;\n        const endIdx = startIdx + pixelsPerSlice;\n        for (let i = startIdx; i < endIdx; i++) {\n            if (segData[i] === segIndex) {\n                return false;\n            }\n        }\n        return true;\n    },\n};\nexpose(computeWorker);\n","const AttributeTypes = {\n  SCALARS: 0,\n  VECTORS: 1,\n  NORMALS: 2,\n  TCOORDS: 3,\n  TENSORS: 4,\n  GLOBALIDS: 5,\n  PEDIGREEIDS: 6,\n  EDGEFLAG: 7,\n  NUM_ATTRIBUTES: 8\n};\nconst AttributeLimitTypes = {\n  MAX: 0,\n  EXACT: 1,\n  NOLIMIT: 2\n};\nconst CellGhostTypes = {\n  DUPLICATECELL: 1,\n  // the cell is present on multiple processors\n  HIGHCONNECTIVITYCELL: 2,\n  // the cell has more neighbors than in a regular mesh\n  LOWCONNECTIVITYCELL: 4,\n  // the cell has less neighbors than in a regular mesh\n  REFINEDCELL: 8,\n  // other cells are present that refines it.\n  EXTERIORCELL: 16,\n  // the cell is on the exterior of the data set\n  HIDDENCELL: 32 // the cell is needed to maintain connectivity, but the data values should be ignored.\n};\n\nconst PointGhostTypes = {\n  DUPLICATEPOINT: 1,\n  // the cell is present on multiple processors\n  HIDDENPOINT: 2 // the point is needed to maintain connectivity, but the data values should be ignored.\n};\n\nconst AttributeCopyOperations = {\n  COPYTUPLE: 0,\n  INTERPOLATE: 1,\n  PASSDATA: 2,\n  ALLCOPY: 3 // all of the above\n};\n\nconst ghostArrayName = 'vtkGhostType';\nconst DesiredOutputPrecision = {\n  DEFAULT: 0,\n  // use the point type that does not truncate any data\n  SINGLE: 1,\n  // use Float32Array\n  DOUBLE: 2 // use Float64Array\n};\n\nvar Constants = {\n  AttributeCopyOperations,\n  AttributeLimitTypes,\n  AttributeTypes,\n  CellGhostTypes,\n  DesiredOutputPrecision,\n  PointGhostTypes,\n  ghostArrayName\n};\n\nexport { AttributeCopyOperations, AttributeLimitTypes, AttributeTypes, CellGhostTypes, DesiredOutputPrecision, PointGhostTypes, Constants as default, ghostArrayName };\n","import { m as macro } from '../../macros2.js';\nimport { b as roundVector, c as clampVector } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkStructuredData from './StructuredData.js';\nimport { StructuredType } from './StructuredData/Constants.js';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageData');\n  publicAPI.setExtent = function () {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {\n      inExtent[_key] = arguments[_key];\n    }\n    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;\n    if (extentArray.length !== 6) {\n      return false;\n    }\n    const changeDetected = model.extent.some((item, index) => item !== extentArray[index]);\n    if (changeDetected) {\n      model.extent = extentArray.slice();\n      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);\n      publicAPI.modified();\n    }\n    return changeDetected;\n  };\n  publicAPI.setDimensions = function () {\n    let i;\n    let j;\n    let k;\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    if (arguments.length === 1) {\n      const array = arguments.length <= 0 ? undefined : arguments[0];\n      i = array[0];\n      j = array[1];\n      k = array[2];\n    } else if (arguments.length === 3) {\n      i = arguments.length <= 0 ? undefined : arguments[0];\n      j = arguments.length <= 1 ? undefined : arguments[1];\n      k = arguments.length <= 2 ? undefined : arguments[2];\n    } else {\n      vtkErrorMacro('Bad dimension specification');\n      return;\n    }\n    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);\n  };\n  publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];\n  publicAPI.getNumberOfCells = () => {\n    const dims = publicAPI.getDimensions();\n    let nCells = 1;\n    for (let i = 0; i < 3; i++) {\n      if (dims[i] === 0) {\n        return 0;\n      }\n      if (dims[i] > 1) {\n        nCells *= dims[i] - 1;\n      }\n    }\n    return nCells;\n  };\n  publicAPI.getNumberOfPoints = () => {\n    const dims = publicAPI.getDimensions();\n    return dims[0] * dims[1] * dims[2];\n  };\n  publicAPI.getPoint = index => {\n    const dims = publicAPI.getDimensions();\n    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {\n      vtkErrorMacro('Requesting a point from an empty image.');\n      return null;\n    }\n    const ijk = new Float64Array(3);\n    switch (model.dataDescription) {\n      case StructuredType.EMPTY:\n        return null;\n      case StructuredType.SINGLE_POINT:\n        break;\n      case StructuredType.X_LINE:\n        ijk[0] = index;\n        break;\n      case StructuredType.Y_LINE:\n        ijk[1] = index;\n        break;\n      case StructuredType.Z_LINE:\n        ijk[2] = index;\n        break;\n      case StructuredType.XY_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0];\n        break;\n      case StructuredType.YZ_PLANE:\n        ijk[1] = index % dims[1];\n        ijk[2] = index / dims[1];\n        break;\n      case StructuredType.XZ_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[2] = index / dims[0];\n        break;\n      case StructuredType.XYZ_GRID:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0] % dims[1];\n        ijk[2] = index / (dims[0] * dims[1]);\n        break;\n      default:\n        vtkErrorMacro('Invalid dataDescription');\n        break;\n    }\n    const coords = [0, 0, 0];\n    publicAPI.indexToWorld(ijk, coords);\n    return coords;\n  };\n\n  // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;\n  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;\n  // virtual vtkIdType FindPoint(double x, double y, double z)\n  // {\n  //   return this->vtkDataSet::FindPoint(x, y, z);\n  // }\n  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,\n  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,\n  //   vtkIdType cellId, double tol2, int& subId,\n  //   double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,\n  //                                 double tol2, int& subId, double pcoords[3],\n  //                                 double *weights) VTK_OVERRIDE;\n  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,\n  //                                     this->GetDimensions());}\n  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}\n  // void ComputeBounds() VTK_OVERRIDE;\n  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest\n\n  publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());\n  publicAPI.extentToBounds = ex => vtkBoundingBox.transformBounds(ex, model.indexToWorld);\n  publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5);\n\n  // Internal, shouldn't need to call this manually.\n  publicAPI.computeTransforms = () => {\n    mat4.fromTranslation(model.indexToWorld, model.origin);\n    model.indexToWorld[0] = model.direction[0];\n    model.indexToWorld[1] = model.direction[1];\n    model.indexToWorld[2] = model.direction[2];\n    model.indexToWorld[4] = model.direction[3];\n    model.indexToWorld[5] = model.direction[4];\n    model.indexToWorld[6] = model.direction[5];\n    model.indexToWorld[8] = model.direction[6];\n    model.indexToWorld[9] = model.direction[7];\n    model.indexToWorld[10] = model.direction[8];\n    mat4.scale(model.indexToWorld, model.indexToWorld, model.spacing);\n    mat4.invert(model.worldToIndex, model.indexToWorld);\n  };\n  publicAPI.indexToWorld = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.indexToWorld);\n    return aout;\n  };\n  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;\n  publicAPI.worldToIndex = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.worldToIndex);\n    return aout;\n  };\n  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;\n  publicAPI.indexToWorldBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);\n  };\n  publicAPI.worldToIndexBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);\n  };\n\n  // Make sure the transform is correct\n  publicAPI.onModified(publicAPI.computeTransforms);\n  publicAPI.computeTransforms();\n  publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());\n  publicAPI.computeHistogram = function (worldBounds) {\n    let voxelFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const bounds = [0, 0, 0, 0, 0, 0];\n    publicAPI.worldToIndexBounds(worldBounds, bounds);\n    const point1 = [0, 0, 0];\n    const point2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);\n    roundVector(point1, point1);\n    roundVector(point2, point2);\n    const dimensions = publicAPI.getDimensions();\n    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);\n    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);\n    const yStride = dimensions[0];\n    const zStride = dimensions[0] * dimensions[1];\n    const pixels = publicAPI.getPointData().getScalars().getData();\n    let maximum = -Infinity;\n    let minimum = Infinity;\n    let sumOfSquares = 0;\n    let isum = 0;\n    let inum = 0;\n    for (let z = point1[2]; z <= point2[2]; z++) {\n      for (let y = point1[1]; y <= point2[1]; y++) {\n        let index = point1[0] + y * yStride + z * zStride;\n        for (let x = point1[0]; x <= point2[0]; x++) {\n          if (!voxelFunction || voxelFunction([x, y, z], bounds)) {\n            const pixel = pixels[index];\n            if (pixel > maximum) maximum = pixel;\n            if (pixel < minimum) minimum = pixel;\n            sumOfSquares += pixel * pixel;\n            isum += pixel;\n            inum += 1;\n          }\n          ++index;\n        }\n      }\n    }\n    const average = inum > 0 ? isum / inum : 0;\n    const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;\n    const sigma = Math.sqrt(variance);\n    return {\n      minimum,\n      maximum,\n      average,\n      variance,\n      sigma,\n      count: inum\n    };\n  };\n\n  // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).\n  // Scalar data could be tuples for color information?\n  publicAPI.computeIncrements = function (extent) {\n    let numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const increments = [];\n    let incr = numberOfComponents;\n\n    // Calculate array increment offsets\n    // similar to c++ vtkImageData::ComputeIncrements\n    for (let idx = 0; idx < 3; ++idx) {\n      increments[idx] = incr;\n      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;\n    }\n    return increments;\n  };\n\n  /**\n   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.\n   * @return {Number} the corresponding flattened index in the scalar array\n   */\n  publicAPI.computeOffsetIndex = _ref => {\n    let [i, j, k] = _ref;\n    const extent = publicAPI.getExtent();\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    const increments = publicAPI.computeIncrements(extent, numberOfComponents);\n    // Use the array increments to find the pixel index\n    // similar to c++ vtkImageData::GetArrayPointer\n    // Math.floor to catch \"practically 0\" e^-15 scenarios.\n    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);\n  };\n\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @return {Number|NaN} the corresponding pixel's index in the scalar array\n   */\n  publicAPI.getOffsetIndexFromWorld = xyz => {\n    const extent = publicAPI.getExtent();\n    const index = publicAPI.worldToIndex(xyz);\n\n    // Confirm indexed i,j,k coords are within the bounds of the volume\n    for (let idx = 0; idx < 3; ++idx) {\n      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {\n        vtkErrorMacro(`GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`);\n        return NaN;\n      }\n    }\n\n    // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream\n    return publicAPI.computeOffsetIndex(index);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @param {Number?} comp the scalar component index for multi-component scalars\n   * @return {Number|NaN} the corresponding pixel's scalar value\n   */\n  publicAPI.getScalarValueFromWorld = function (xyz) {\n    let comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    if (comp < 0 || comp >= numberOfComponents) {\n      vtkErrorMacro(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);\n      return NaN;\n    }\n    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);\n    if (Number.isNaN(offsetIndex)) {\n      // VTK Error Macro will have been tripped already, no need to do it again,\n      return offsetIndex;\n    }\n    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  direction: null,\n  // a mat3\n  indexToWorld: null,\n  // a mat4\n  worldToIndex: null,\n  // a mat4\n  spacing: [1.0, 1.0, 1.0],\n  origin: [0.0, 0.0, 0.0],\n  extent: [0, -1, 0, -1, 0, -1],\n  dataDescription: StructuredType.EMPTY\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkDataSet.extend(publicAPI, model, initialValues);\n  if (!model.direction) {\n    model.direction = mat3.identity(new Float64Array(9));\n  } else if (Array.isArray(model.direction)) {\n    model.direction = new Float64Array(model.direction.slice(0, 9));\n  }\n  model.indexToWorld = new Float64Array(16);\n  model.worldToIndex = new Float64Array(16);\n\n  // Set/Get methods\n  macro.get(publicAPI, model, ['indexToWorld', 'worldToIndex']);\n  macro.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);\n  macro.setGetArray(publicAPI, model, ['direction'], 9);\n  macro.getArray(publicAPI, model, ['extent'], 6);\n\n  // Object specific methods\n  vtkImageData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageData$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageData$1 as default, extend, newInstance };\n","import { m as macro } from '../../macros2.js';\nimport { h as hsv2rgb, i as isNan, K as floor, L as isInf, M as rgb2hsv, N as rgb2lab, O as lab2rgb } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors.js';\nimport Constants from './ColorTransferFunction/Constants.js';\n\nconst {\n  ColorSpace,\n  Scale\n} = Constants;\nconst {\n  ScalarMappingTarget\n} = vtkScalarsToColors;\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n/* eslint-disable no-continue                                                */\n\n// Convert to and from a special polar version of CIELAB (useful for creating\n// continuous diverging color maps).\nfunction vtkColorTransferFunctionLabToMsh(lab, msh) {\n  const L = lab[0];\n  const a = lab[1];\n  const b = lab[2];\n  const M = Math.sqrt(L * L + a * a + b * b);\n  const s = M > 0.001 ? Math.acos(L / M) : 0.0;\n  const h = s > 0.001 ? Math.atan2(b, a) : 0.0;\n  msh[0] = M;\n  msh[1] = s;\n  msh[2] = h;\n}\nfunction vtkColorTransferFunctionMshToLab(msh, lab) {\n  const M = msh[0];\n  const s = msh[1];\n  const h = msh[2];\n  lab[0] = M * Math.cos(s);\n  lab[1] = M * Math.sin(s) * Math.cos(h);\n  lab[2] = M * Math.sin(s) * Math.sin(h);\n}\n\n// For the case when interpolating from a saturated color to an unsaturated\n// color, find a hue for the unsaturated color that makes sense.\nfunction vtkColorTransferFunctionAdjustHue(msh, unsatM) {\n  if (msh[0] >= unsatM - 0.1) {\n    // The best we can do is hold hue constant.\n    return msh[2];\n  }\n\n  // This equation is designed to make the perceptual change of the\n  // interpolation to be close to constant.\n  const hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1]));\n  // Spin hue away from 0 except in purple hues.\n  if (msh[2] > -0.3 * Math.PI) {\n    return msh[2] + hueSpin;\n  }\n  return msh[2] - hueSpin;\n}\nfunction vtkColorTransferFunctionAngleDiff(a1, a2) {\n  let adiff = a1 - a2;\n  if (adiff < 0.0) {\n    adiff = -adiff;\n  }\n  while (adiff >= 2.0 * Math.PI) {\n    adiff -= 2.0 * Math.PI;\n  }\n  if (adiff > Math.PI) {\n    adiff = 2.0 * Math.PI - adiff;\n  }\n  return adiff;\n}\n\n// Interpolate a diverging color map.\nfunction vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {\n  const lab1 = [];\n  const lab2 = [];\n  rgb2lab(rgb1, lab1);\n  rgb2lab(rgb2, lab2);\n  const msh1 = [];\n  const msh2 = [];\n  vtkColorTransferFunctionLabToMsh(lab1, msh1);\n  vtkColorTransferFunctionLabToMsh(lab2, msh2);\n\n  // If the endpoints are distinct saturated colors, then place white in between\n  // them.\n  let localS = s;\n  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {\n    // Insert the white midpoint by setting one end to white and adjusting the\n    // scalar value.\n    let Mmid = Math.max(msh1[0], msh2[0]);\n    Mmid = Math.max(88.0, Mmid);\n    if (s < 0.5) {\n      msh2[0] = Mmid;\n      msh2[1] = 0.0;\n      msh2[2] = 0.0;\n      localS *= 2.0;\n    } else {\n      msh1[0] = Mmid;\n      msh1[1] = 0.0;\n      msh1[2] = 0.0;\n      localS = 2.0 * localS - 1.0;\n    }\n  }\n\n  // If one color has no saturation, then its hue value is invalid.  In this\n  // case, we want to set it to something logical so that the interpolation of\n  // hue makes sense.\n  if (msh1[1] < 0.05 && msh2[1] > 0.05) {\n    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);\n  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {\n    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);\n  }\n  const mshTmp = [];\n  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];\n  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];\n  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2];\n\n  // Now convert back to RGB\n  const labTmp = [];\n  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);\n  lab2rgb(labTmp, result);\n}\n\n// ----------------------------------------------------------------------------\n// vtkColorTransferFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkColorTransferFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkColorTransferFunction');\n\n  // Return the number of points which specify this function\n  publicAPI.getSize = () => model.nodes.length;\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n  publicAPI.addRGBPoint = (x, r, g, b) => publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0.0);\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n  publicAPI.addRGBPointLong = function (x, r, g, b) {\n    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    // remove any node already at this X location\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    }\n\n    // Create the new node\n    const node = {\n      x,\n      r,\n      g,\n      b,\n      midpoint,\n      sharpness\n    };\n\n    // Add it, then sort to get everything in order\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange();\n\n    // We need to find the index of the node we just added in order\n    // to return this value\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If we didn't find it, something went horribly wrong so\n    // return -1\n    if (i < model.nodes.length) {\n      return i;\n    }\n    return -1;\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n  publicAPI.addHSVPoint = (x, h, s, v) => publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0.0);\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n  publicAPI.addHSVPointLong = function (x, h, s, v) {\n    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    const rgb = [];\n    const hsv = [h, s, v];\n    hsv2rgb(hsv, rgb);\n    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);\n  };\n\n  //----------------------------------------------------------------------------\n  // Set nodes directly\n  publicAPI.setNodes = nodes => {\n    if (model.nodes !== nodes) {\n      const before = JSON.stringify(model.nodes);\n      model.nodes = nodes;\n      const after = JSON.stringify(model.nodes);\n      if (publicAPI.sortAndUpdateRange() || before !== after) {\n        publicAPI.modified();\n        return true;\n      }\n    }\n    return false;\n  };\n\n  //----------------------------------------------------------------------------\n  // Sort the vector in increasing order, then fill in\n  // the Range\n  publicAPI.sortAndUpdateRange = () => {\n    const before = JSON.stringify(model.nodes);\n    model.nodes.sort((a, b) => a.x - b.x);\n    const after = JSON.stringify(model.nodes);\n    const modifiedInvoked = publicAPI.updateRange();\n    // If range is updated, Modified() has been called, don't call it again.\n    if (!modifiedInvoked && before !== after) {\n      publicAPI.modified();\n      return true;\n    }\n    return modifiedInvoked;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateRange = () => {\n    const oldRange = [2];\n    oldRange[0] = model.mappingRange[0];\n    oldRange[1] = model.mappingRange[1];\n    const size = model.nodes.length;\n    if (size) {\n      model.mappingRange[0] = model.nodes[0].x;\n      model.mappingRange[1] = model.nodes[size - 1].x;\n    } else {\n      model.mappingRange[0] = 0;\n      model.mappingRange[1] = 0;\n    }\n\n    // If the range is the same, then no need to call Modified()\n    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {\n      return false;\n    }\n    publicAPI.modified();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  // Remove a point\n  publicAPI.removePoint = x => {\n    // First find the node since we need to know its\n    // index as our return value\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n    const retVal = i;\n\n    // If the node doesn't exist, we return -1\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n\n    // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n    let modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n    return retVal;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.movePoint = (oldX, newX) => {\n    if (oldX === newX) {\n      // Nothing to do.\n      return;\n    }\n    publicAPI.removePoint(newX);\n    for (let i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === oldX) {\n        model.nodes[i].x = newX;\n        publicAPI.sortAndUpdateRange();\n        break;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  // Remove all points\n  publicAPI.removeAllPoints = () => {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a line defined in RGB\n  publicAPI.addRGBSegment = (x1, r1, g1, b1, x2, r2, g2, b2) => {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Now add the points\n    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0.0);\n    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0.0);\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a line defined in HSV\n  publicAPI.addHSVSegment = (x1, h1, s1, v1, x2, h2, s2, v2) => {\n    const hsv1 = [h1, s1, v1];\n    const hsv2 = [h2, s2, v2];\n    const rgb1 = [];\n    const rgb2 = [];\n    hsv2rgb(hsv1, rgb1);\n    hsv2rgb(hsv2, rgb2);\n    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the RGBA color evaluated at the specified location\n  publicAPI.mapValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return [Math.floor(255.0 * rgb[0] + 0.5), Math.floor(255.0 * rgb[1] + 0.5), Math.floor(255.0 * rgb[2] + 0.5), 255];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the RGB color evaluated at the specified location\n  publicAPI.getColor = (x, rgb) => {\n    if (model.indexedLookup) {\n      const numNodes = publicAPI.getSize();\n      // todo\n      const idx = publicAPI.getAnnotatedValueIndexInternal(x);\n      if (idx < 0 || numNodes === 0) {\n        const nanColor = publicAPI.getNanColorByReference();\n        rgb[0] = nanColor[0];\n        rgb[1] = nanColor[1];\n        rgb[2] = nanColor[2];\n      } else {\n        const nodeVal = [];\n        publicAPI.getNodeValue(idx % numNodes, nodeVal);\n        // nodeVal[0] is the x value. nodeVal[1...3] is rgb.\n        rgb[0] = nodeVal[1];\n        rgb[1] = nodeVal[2];\n        rgb[2] = nodeVal[3];\n      }\n      return;\n    }\n    publicAPI.getTable(x, x, 1, rgb);\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the red color evaluated at the specified location\n  publicAPI.getRedValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[0];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the green color evaluated at the specified location\n  publicAPI.getGreenValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[1];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the blue color evaluated at the specified location\n  publicAPI.getBlueValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[2];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns a table of RGB colors at regular intervals along the function\n  publicAPI.getTable = (xStart_, xEnd_, size, table) => {\n    // To handle BigInt limitation\n    const xStart = Number(xStart_);\n    const xEnd = Number(xEnd_);\n\n    // Special case: If either the start or end is a NaN, then all any\n    // interpolation done on them is also a NaN.  Therefore, fill the table with\n    // the NaN color.\n    if (isNan(xStart) || isNan(xEnd)) {\n      for (let i = 0; i < size; i++) {\n        table[i * 3 + 0] = model.nanColor[0];\n        table[i * 3 + 1] = model.nanColor[1];\n        table[i * 3 + 2] = model.nanColor[2];\n      }\n      return;\n    }\n    let idx = 0;\n    const numNodes = model.nodes.length;\n\n    // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n    let lastR = 0.0;\n    let lastG = 0.0;\n    let lastB = 0.0;\n    if (numNodes !== 0) {\n      lastR = model.nodes[numNodes - 1].r;\n      lastG = model.nodes[numNodes - 1].g;\n      lastB = model.nodes[numNodes - 1].b;\n    }\n    let x = 0.0;\n    let x1 = 0.0;\n    let x2 = 0.0;\n    const rgb1 = [0.0, 0.0, 0.0];\n    const rgb2 = [0.0, 0.0, 0.0];\n    let midpoint = 0.0;\n    let sharpness = 0.0;\n    const tmpVec = [];\n\n    // If the scale is logarithmic, make sure the range is valid.\n    let usingLogScale = model.scale === Scale.LOG10;\n    if (usingLogScale) {\n      // Note: This requires range[0] <= range[1].\n      usingLogScale = model.mappingRange[0] > 0.0;\n    }\n    let logStart = 0.0;\n    let logEnd = 0.0;\n    let logX = 0.0;\n    if (usingLogScale) {\n      logStart = Math.log10(xStart);\n      logEnd = Math.log10(xEnd);\n    }\n\n    // For each table entry\n    for (let i = 0; i < size; i++) {\n      // Find our location in the table\n      const tidx = 3 * i;\n\n      // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n      if (size > 1) {\n        if (usingLogScale) {\n          logX = logStart + i / (size - 1.0) * (logEnd - logStart);\n          x = 10.0 ** logX;\n        } else {\n          x = xStart + i / (size - 1.0) * (xEnd - xStart);\n        }\n      } else if (usingLogScale) {\n        logX = 0.5 * (logStart + logEnd);\n        x = 10.0 ** logX;\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      }\n\n      // Linearly map x from mappingRange to [0, numberOfValues-1],\n      // discretize (round down to the closest integer),\n      // then map back to mappingRange\n      if (model.discretize) {\n        const range = model.mappingRange;\n        if (x >= range[0] && x <= range[1]) {\n          const numberOfValues = model.numberOfValues;\n          const deltaRange = range[1] - range[0];\n          if (numberOfValues <= 1) {\n            x = range[0] + deltaRange / 2.0;\n          } else {\n            // normalize x\n            const xn = (x - range[0]) / deltaRange;\n            // discretize\n            const discretizeIndex = floor(numberOfValues * xn);\n            // get discretized x\n            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;\n          }\n        }\n      }\n\n      // Do we need to move to the next node?\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++;\n        // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          if (usingLogScale) {\n            x1 = Math.log10(x1);\n            x2 = Math.log10(x2);\n          }\n          rgb1[0] = model.nodes[idx - 1].r;\n          rgb2[0] = model.nodes[idx].r;\n          rgb1[1] = model.nodes[idx - 1].g;\n          rgb2[1] = model.nodes[idx].g;\n          rgb1[2] = model.nodes[idx - 1].b;\n          rgb2[2] = model.nodes[idx].b;\n\n          // We only need the previous midpoint and sharpness\n          // since these control this region\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness;\n\n          // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      }\n\n      // Are we at or past the end? If so, just use the last value\n      if (x > model.mappingRange[1]) {\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseAboveRangeColor()) {\n            table[tidx] = model.aboveRangeColor[0];\n            table[tidx + 1] = model.aboveRangeColor[1];\n            table[tidx + 2] = model.aboveRangeColor[2];\n          } else {\n            table[tidx] = lastR;\n            table[tidx + 1] = lastG;\n            table[tidx + 2] = lastB;\n          }\n        }\n      } else if (x < model.mappingRange[0] || isInf(x) && x < 0) {\n        // we are before the first node? If so, duplicate this node's values.\n        // We have to deal with -inf here\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseBelowRangeColor()) {\n            table[tidx] = model.belowRangeColor[0];\n            table[tidx + 1] = model.belowRangeColor[1];\n            table[tidx + 2] = model.belowRangeColor[2];\n          } else if (numNodes > 0) {\n            table[tidx] = model.nodes[0].r;\n            table[tidx + 1] = model.nodes[0].g;\n            table[tidx + 2] = model.nodes[0].b;\n          }\n        }\n      } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {\n        if (numNodes > 0) {\n          table[tidx] = model.nodes[0].r;\n          table[tidx + 1] = model.nodes[0].g;\n          table[tidx + 2] = model.nodes[0].b;\n        } else {\n          table[tidx] = 0.0;\n          table[tidx + 1] = 0.0;\n          table[tidx + 2] = 0.0;\n        }\n      } else {\n        // OK, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        let s = 0.0;\n        if (usingLogScale) {\n          s = (logX - x1) / (x2 - x1);\n        } else {\n          s = (x - x1) / (x2 - x1);\n        }\n\n        // Readjust based on the midpoint - linear adjustment\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        }\n\n        // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = rgb1[0];\n            table[tidx + 1] = rgb1[1];\n            table[tidx + 2] = rgb1[2];\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = rgb2[0];\n            table[tidx + 1] = rgb2[1];\n            table[tidx + 2] = rgb2[2];\n            continue;\n          }\n        }\n\n        // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          if (model.colorSpace === ColorSpace.RGB) {\n            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];\n            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];\n            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];\n          } else if (model.colorSpace === ColorSpace.HSV) {\n            const hsv1 = [];\n            const hsv2 = [];\n            rgb2hsv(rgb1, hsv1);\n            rgb2hsv(rgb2, hsv2);\n            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n              if (hsv1[0] > hsv2[0]) {\n                hsv1[0] -= 1.0;\n              } else {\n                hsv2[0] -= 1.0;\n              }\n            }\n            const hsvTmp = [];\n            hsvTmp[0] = (1.0 - s) * hsv1[0] + s * hsv2[0];\n            if (hsvTmp[0] < 0.0) {\n              hsvTmp[0] += 1.0;\n            }\n            hsvTmp[1] = (1.0 - s) * hsv1[1] + s * hsv2[1];\n            hsvTmp[2] = (1.0 - s) * hsv1[2] + s * hsv2[2];\n\n            // Now convert this back to RGB\n            hsv2rgb(hsvTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.LAB) {\n            const lab1 = [];\n            const lab2 = [];\n            rgb2lab(rgb1, lab1);\n            rgb2lab(rgb2, lab2);\n            const labTmp = [];\n            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];\n            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];\n            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2];\n\n            // Now convert back to RGB\n            lab2rgb(labTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.DIVERGING) {\n            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else {\n            vtkErrorMacro('ColorSpace set to invalid value.', model.colorSpace);\n          }\n          continue;\n        }\n\n        // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n        if (s < 0.5) {\n          s = 0.5 * (s * 2.0) ** (1.0 + 10.0 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10.0 * sharpness);\n        }\n\n        // Compute some coefficients we will need for the hermite curve\n        const ss = s * s;\n        const sss = ss * s;\n        const h1 = 2.0 * sss - 3 * ss + 1;\n        const h2 = -2 * sss + 3 * ss;\n        const h3 = sss - 2 * ss + s;\n        const h4 = sss - ss;\n        let slope;\n        let t;\n        if (model.colorSpace === ColorSpace.RGB) {\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = rgb2[j] - rgb1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;\n          }\n        } else if (model.colorSpace === ColorSpace.HSV) {\n          const hsv1 = [];\n          const hsv2 = [];\n          rgb2hsv(rgb1, hsv1);\n          rgb2hsv(rgb2, hsv2);\n          if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n            if (hsv1[0] > hsv2[0]) {\n              hsv1[0] -= 1.0;\n            } else {\n              hsv2[0] -= 1.0;\n            }\n          }\n          const hsvTmp = [];\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = hsv2[j] - hsv1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            hsvTmp[j] = h1 * hsv1[j] + h2 * hsv2[j] + h3 * t + h4 * t;\n            if (j === 0 && hsvTmp[j] < 0.0) {\n              hsvTmp[j] += 1.0;\n            }\n          }\n          // Now convert this back to RGB\n          hsv2rgb(hsvTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.LAB) {\n          const lab1 = [];\n          const lab2 = [];\n          rgb2lab(rgb1, lab1);\n          rgb2lab(rgb2, lab2);\n          const labTmp = [];\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = lab2[j] - lab1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            labTmp[j] = h1 * lab1[j] + h2 * lab2[j] + h3 * t + h4 * t;\n          }\n          // Now convert this back to RGB\n          lab2rgb(labTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.DIVERGING) {\n          // I have not implemented proper interpolation by a hermite curve for\n          // the diverging color map, but I cannot think of a good use case for\n          // that anyway.\n          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else {\n          vtkErrorMacro('ColorSpace set to invalid value.');\n        }\n\n        // Final error check to make sure we don't go outside [0,1]\n        for (let j = 0; j < 3; j++) {\n          table[tidx + j] = table[tidx + j] < 0.0 ? 0.0 : table[tidx + j];\n          table[tidx + j] = table[tidx + j] > 1.0 ? 1.0 : table[tidx + j];\n        }\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getUint8Table = function (xStart, xEnd, size) {\n    let withAlpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {\n      return model.table;\n    }\n    if (model.nodes.length === 0) {\n      vtkErrorMacro('Attempting to lookup a value with no points in the function');\n      return model.table;\n    }\n    const nbChannels = withAlpha ? 4 : 3;\n    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {\n      model.table = new Uint8Array(size * nbChannels);\n      model.tableSize = size;\n      model.tableWithAlpha = withAlpha;\n    }\n    const tmpTable = [];\n    publicAPI.getTable(xStart, xEnd, size, tmpTable);\n    for (let i = 0; i < size; i++) {\n      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255.0 + 0.5);\n      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255.0 + 0.5);\n      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255.0 + 0.5);\n      if (withAlpha) {\n        model.table[i * nbChannels + 3] = 255;\n      }\n    }\n    model.buildTime.modified();\n    return model.table;\n  };\n  publicAPI.buildFunctionFromArray = array => {\n    publicAPI.removeAllPoints();\n    const numComponents = array.getNumberOfComponents();\n    for (let i = 0; i < array.getNumberOfTuples(); i++) {\n      switch (numComponents) {\n        case 3:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n        case 4:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n        case 5:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n        case 6:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n      }\n    }\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.buildFunctionFromTable = (xStart, xEnd, size, table) => {\n    let inc = 0.0;\n    publicAPI.removeAllPoints();\n    if (size > 1) {\n      inc = (xEnd - xStart) / (size - 1.0);\n    }\n    for (let i = 0; i < size; i++) {\n      const node = {\n        x: xStart + inc * i,\n        r: table[i * 3],\n        g: table[i * 3 + 1],\n        b: table[i * 3 + 2],\n        sharpness: 0.0,\n        midpoint: 0.5\n      };\n      model.nodes.push(node);\n    }\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n  publicAPI.getNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].r;\n    val[2] = model.nodes[index].g;\n    val[3] = model.nodes[index].b;\n    val[4] = model.nodes[index].midpoint;\n    val[5] = model.nodes[index].sharpness;\n    return 1;\n  };\n\n  //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n  publicAPI.setNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    const oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].r = val[1];\n    model.nodes[index].g = val[2];\n    model.nodes[index].b = val[3];\n    model.nodes[index].midpoint = val[4];\n    model.nodes[index].sharpness = val[5];\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange();\n      // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n    return 1;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getNumberOfAvailableColors = () => {\n    if (model.indexedLookup && publicAPI.getSize()) {\n      return publicAPI.getSize();\n    }\n    if (model.tableSize) {\n      // Not sure if this is correct since it is only set if\n      // \"const unsigned char *::GetTable(double xStart, double xEnd,int size)\"\n      // has been called.\n      return model.tableSize;\n    }\n    const nNodes = model.nodes?.length ?? 0;\n    // The minimum is 4094 colors so that it fills in the 4096 texels texture in `mapScalarsToTexture`\n    return Math.max(4094, nNodes);\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getIndexedColor = (idx, rgba) => {\n    const n = publicAPI.getSize();\n    if (n > 0 && idx >= 0) {\n      const nodeValue = [];\n      publicAPI.getNodeValue(idx % n, nodeValue);\n      for (let j = 0; j < 3; ++j) {\n        rgba[j] = nodeValue[j + 1];\n      }\n      rgba[3] = 1.0; // NodeColor is RGB-only.\n      return;\n    }\n    const nanColor = publicAPI.getNanColorByReference();\n    rgba[0] = nanColor[0];\n    rgba[1] = nanColor[1];\n    rgba[2] = nanColor[2];\n    rgba[3] = 1.0; // NanColor is RGB-only.\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.fillFromDataPointer = (nb, ptr) => {\n    if (nb <= 0 || !ptr) {\n      return;\n    }\n    publicAPI.removeAllPoints();\n    for (let i = 0; i < nb; i++) {\n      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.setMappingRange = (min, max) => {\n    const range = [min, max];\n    const originalRange = publicAPI.getRange();\n    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {\n      return;\n    }\n    if (range[1] === range[0]) {\n      vtkErrorMacro('attempt to set zero width color range');\n      return;\n    }\n    const scale = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);\n    const shift = range[0] - originalRange[0] * scale;\n    for (let i = 0; i < model.nodes.length; ++i) {\n      model.nodes[i].x = model.nodes[i].x * scale + shift;\n    }\n    model.mappingRange[0] = range[0];\n    model.mappingRange[1] = range[1];\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.adjustRange = range => {\n    const functionRange = publicAPI.getRange();\n\n    // Make sure we have points at each end of the range\n    const rgb = [];\n    if (functionRange[0] < range[0]) {\n      publicAPI.getColor(range[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    }\n    if (functionRange[1] > range[1]) {\n      publicAPI.getColor(range[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    }\n\n    // Remove all points out-of-range\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n    return 1;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {\n    const d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.findMinimumXDistance = () => {\n    if (model.nodes.length < 2) {\n      return -1.0;\n    }\n    let distance = Number.MAX_VALUE;\n    for (let i = 0; i < model.nodes.length - 1; i++) {\n      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n    return distance;\n  };\n  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {\n    if (publicAPI.getSize() === 0) {\n      vtkDebugMacro('Transfer Function Has No Points!');\n      return;\n    }\n    if (model.indexedLookup) {\n      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);\n    } else {\n      publicAPI.mapData(input, output, outFormat, inputOffset);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.mapData = (input, output, outFormat, inputOffset) => {\n    if (publicAPI.getSize() === 0) {\n      vtkWarningMacro('Transfer Function Has No Points!');\n      return;\n    }\n    const alpha = Math.floor(publicAPI.getAlpha() * 255.0 + 0.5);\n    const length = input.getNumberOfTuples();\n    const inIncr = input.getNumberOfComponents();\n    const outputV = output.getData();\n    const inputV = input.getData();\n    const rgb = [];\n    if (outFormat === ScalarMappingTarget.RGBA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 4] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n        outputV[i * 4 + 3] = alpha;\n      }\n    }\n    if (outFormat === ScalarMappingTarget.RGB) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 3] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 3 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 3 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n      }\n    }\n    if (outFormat === ScalarMappingTarget.LUMINANCE) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n      }\n    }\n    if (outFormat === ScalarMappingTarget.LUMINANCE_ALPHA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n        outputV[i * 2 + 1] = alpha;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.applyColorMap = colorMap => {\n    const oldColorSpace = JSON.stringify(model.colorSpace);\n    if (colorMap.ColorSpace) {\n      model.colorSpace = ColorSpace[colorMap.ColorSpace.toUpperCase()];\n      if (model.colorSpace === undefined) {\n        vtkErrorMacro(`ColorSpace ${colorMap.ColorSpace} not supported, using RGB instead`);\n        model.colorSpace = ColorSpace.RGB;\n      }\n    }\n    let isModified = oldColorSpace !== JSON.stringify(model.colorSpace);\n    const oldNanColor = isModified || JSON.stringify(model.nanColor);\n    if (colorMap.NanColor) {\n      model.nanColor = [].concat(colorMap.NanColor);\n      while (model.nanColor.length < 4) {\n        model.nanColor.push(1.0);\n      }\n    }\n    isModified = isModified || oldNanColor !== JSON.stringify(model.nanColor);\n    const oldNodes = isModified || JSON.stringify(model.nodes);\n    if (colorMap.RGBPoints) {\n      const size = colorMap.RGBPoints.length;\n      model.nodes = [];\n      const midpoint = 0.5;\n      const sharpness = 0.0;\n      for (let i = 0; i < size; i += 4) {\n        model.nodes.push({\n          x: colorMap.RGBPoints[i],\n          r: colorMap.RGBPoints[i + 1],\n          g: colorMap.RGBPoints[i + 2],\n          b: colorMap.RGBPoints[i + 3],\n          midpoint,\n          sharpness\n        });\n      }\n    }\n    const modifiedInvoked = publicAPI.sortAndUpdateRange();\n    const callModified = !modifiedInvoked && (isModified || oldNodes !== JSON.stringify(model.nodes));\n    if (callModified) publicAPI.modified();\n    return modifiedInvoked || callModified;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  clamping: true,\n  colorSpace: ColorSpace.RGB,\n  hSVWrap: true,\n  scale: Scale.LINEAR,\n  nanColor: null,\n  belowRangeColor: null,\n  aboveRangeColor: null,\n  useAboveRangeColor: false,\n  useBelowRangeColor: false,\n  allowDuplicateScalars: false,\n  table: null,\n  tableSize: 0,\n  buildTime: null,\n  nodes: null,\n  discretize: false,\n  numberOfValues: 256\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkScalarsToColors.extend(publicAPI, model, initialValues);\n\n  // Internal objects initialization\n  model.table = [];\n  model.nodes = [];\n  model.nanColor = [0.5, 0.0, 0.0, 1.0];\n  model.belowRangeColor = [0.0, 0.0, 0.0, 1.0];\n  model.aboveRangeColor = [1.0, 1.0, 1.0, 1.0];\n  model.buildTime = {};\n  macro.obj(model.buildTime);\n\n  // Create get-only macros\n  macro.get(publicAPI, model, ['buildTime', 'mappingRange']);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['useAboveRangeColor', 'useBelowRangeColor', 'discretize', 'numberOfValues', {\n    type: 'enum',\n    name: 'colorSpace',\n    enum: ColorSpace\n  }, {\n    type: 'enum',\n    name: 'scale',\n    enum: Scale\n  }]);\n  macro.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkColorTransferFunction(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkColorTransferFunction');\n\n// ----------------------------------------------------------------------------\n\nvar vtkColorTransferFunction$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkColorTransferFunction$1 as default, extend, newInstance };\n","import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();","import ascending from \"./ascending.js\";\nimport descending from \"./descending.js\";\n\nexport default function bisector(f) {\n  let compare1, compare2, delta;\n\n  // If an accessor is specified, promote it to a comparator. In this case we\n  // can test whether the search value is (self-) comparable. We cant do this\n  // for a comparator (except for specific, known comparators) because we cant\n  // tell if the comparator is symmetric, and an asymmetric comparator cant be\n  // used to test whether a single value is comparable.\n  if (f.length !== 2) {\n    compare1 = ascending;\n    compare2 = (d, x) => ascending(f(d), x);\n    delta = (d, x) => f(d) - x;\n  } else {\n    compare1 = f === ascending || f === descending ? f : zero;\n    compare2 = f;\n    delta = f;\n  }\n\n  function left(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function right(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) <= 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function center(a, x, lo = 0, hi = a.length) {\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction zero() {\n  return 0;\n}\n","import transpose from \"./transpose.js\";\n\nexport default function zip() {\n  return transpose(arguments);\n}\n","export default x => () => x;\n","export default function(a, b) {\n  return a = +a, b = +b, function(t) {\n    return a * (1 - t) + b * t;\n  };\n}\n","export default function(interpolator, n) {\n  var samples = new Array(n);\n  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));\n  return samples;\n}\n","export default function(a, b) {\n  return a = +a, b = +b, function(t) {\n    return Math.round(a * (1 - t) + b * t);\n  };\n}\n"],"names":["enabledElement","invalidated","image","canvas","start","stats","lastGetPixelDataTime","lastStoredPixelDataToCanvasImageDataTime","lastPutImageDataTime","lastRenderTime","lastLutGenerateTime","render","viewport","colormap","color","renderTimeInMs","invalid","needsRedraw","scale","transform","displayedArea","translate","width","height","angle","rotation","rotate","Math","PI","widthScale","heightScale","brhc","x","tlhc","y","presentationSizeMode","rowPixelSpacing","columnPixelSpacing","verticalScale","horizontalScale","min","translation","undefined","hflip","vflip","modality","Error","scaleFactor","voi","isPreScaled","windowWidth","windowCenter","Array","isArray","invert","pixelReplication","modalityLUT","voiLUT","columns","rows","GenerateImageType","DEFAULT_SETTINGS","Symbol","RUNTIME_SETTINGS","OBJECT_SETTINGS_MAP","DICTIONARY","Settings","constructor","base","dictionary","Object","create","seal","defineProperty","this","value","set","key","get","unset","name","endsWith","deleteCount","namespace","slice","deleteAll","length","prototype","hasOwnProperty","call","startsWith","forEach","callback","iterate","extend","import","root","isPlainObject","keys","dump","context","deepSet","assert","subject","getRuntimeSettings","getDefaultSettings","subfield","defaultSettings","settingObj","setting","split","runtimeSettings","getObjectSettings","from","settings","objectSettingsMap","WeakMap","extendRuntimeSettings","references","last","current","previous","indexOf","isValidKey","prefix","record","failCount","has","add","field","delete","setAll","WeakSet","getPrototypeOf","separator","subKey","subContext","subContextValue","imageLoaders","unknownImageLoader","loadImageFromImageLoader","imageId","options","cachedImageLoadObject","getImageLoadObject","handleImageLoadPromise","promise","scheme","loader","imageLoadObject","imagePromise","Promise","resolve","then","voxelManager","numberOfComponents","createImageVoxelManager","scalarData","getPixelData","getScalarData","imageFrame","pixelData","ensureVoxelManager","IMAGE_LOADED","catch","error","errorDetails","IMAGE_LOAD_FAILED","loadImage","priority","requestType","loadAndCacheImage","putImageLoadObject","createAndCacheDerivedImage","referencedImageId","skipCreateBuffer","onCacheAdd","voxelRepresentation","imagePlaneModule","TypedArrayConstructor","targetBuffer","type","imageScalarData","derivedImageId","referencedImagePlaneMetadata","metadata","referencedImageGeneralSeriesMetadata","instanceNumber","imagePixelModule","bitsAllocated","bitsStored","highBit","samplesPerPixel","pixelRepresentation","localImage","createAndCacheLocalImage","dimensions","spacing","origin","imagePositionPatient","direction","imageOrientationPatient","frameOfReferenceUID","putImageSync","createAndCacheDerivedImages","referencedImageIds","derivedImageIds","map","index","newOptions","getDerivedImageId","push","rowCosines","columnCosines","pixelSpacing","scalarDataToUse","Uint8Array","Float32Array","Uint16Array","Int16Array","photometricInterpretation","id","RLE","createRLEImageVoxelManager","minPixelValue","maxPixelValue","i","intercept","dataType","slope","getCanvas","rgba","FrameOfReferenceUID","sizeInBytes","byteLength","FrameRange","frameRangeExtractor","imageIdToFrames","match","range","it","Number","imageIdToFrameEnd","imageIdToFrameStart","framesToString","String","framesToImageId","newRangeString","replace","PointsManager","configuration","_dimensions","_length","_byteSize","growSize","initialSize","itemLength","array","ArrayBuffer","data","func","getPoint","dimensionLength","offset","subarray","getPointArray","grow","additionalSize","newSize","newArray","newData","reverse","midLength","floor","indexStart","indexEnd","dimension","valueStart","getTypedArray","point","f","mapData","points","p","toXYZ","xyz","z","fromXYZ","create3","subselect","count","selected","max","newPoints","create2","ProgressiveIterator","as","iterator","v","e","reject","reason","done","nextValue","waiting","rejectReason","getRecent","asyncIterator","errorCallback","console","warn","generate","processFunction","bind","nextPromise","donePromise","getNextPromise","getDonePromise","ADJACENT_ALL","ADJACENT_SINGLE_PLANE","ADJACENT_IN","ADJACENT_OUT","RLEVoxelMap","copyMap","destination","source","row","structuredClone","depth","Map","jMultiple","kMultiple","numComps","pixelDataConstructor","updateScalarData","fill","rle","end","j","getRLE","defaultValue","getRun","k","runIndex","rleIndex","findIndex","rle1","rle0","oldValue","rleInsert","isAfter","insertIndex","rlePrev","rleNext","splice","nextnext","ArrayType","Uint8ClampedArray","frameSize","toIJK","toIndex","newRle","iEnd","rowModified","baseIndex","rowToUse","forEachRow","clear","rowOffset","comp","floodFill","stack","replaceValue","flood","sourceValue","sum","planar","diagonals","singlePlane","childOptions","top","pop","adjacents","findAdjacents","filter","adjacent","fillFrom","getter","boundsIJK","item","adjacentsDelta","leftRle","rightRle","delta","delta1","delta2","testJ","testK","testRle","newAdjacentDelta","isImageActor","actorEntry","actorIsA","actorType","actorToCheck","actor","isA","applyPreset","preset","colorTransferArray","colorTransfer","parseFloat","shiftRange","Infinity","center","getShiftRange","cfun","normColorTransferValuePoints","r","g","b","rescaled","removeAllPoints","addRGBPoint","applyPointsToRGBFunction","getProperty","setRGBTransferFunction","scalarOpacityArray","scalarOpacity","ofun","normPoints","opacity","pwf","addPoint","applyPointsToPiecewiseFunction","property","setScalarOpacity","gradientMinValue","gradientMinOpacity","gradientMaxValue","gradientMaxOpacity","gradientOpacity","setUseGradientOpacity","setGradientOpacityMinimumValue","setGradientOpacityMinimumOpacity","setGradientOpacityMaximumValue","setGradientOpacityMaximumOpacity","interpolation","setInterpolationTypeToFastLinear","setShade","shade","ambient","diffuse","specular","specularPower","setAmbient","setDiffuse","setSpecular","setSpecularPower","volumeId","renderingEngineAndViewportIds","renderingEnginesArray","renderingEngine","viewports","viewportIds","getRenderingEngineAndViewportsContainingVolume","hasBeenDestroyed","renderViewports","getImagePlaneModule","newImagePlaneModule","MetadataModules","IMAGE_PLANE","buildMetadata","voiLUTFunction","imageIdScalingFactor","calibration","CALIBRATION","voiLUTFunctionEnum","values","VOILUTFunctionType","includes","LINEAR","getValidVOILUTFunction","scalingFactor","calculateSpacingBetweenImageIds","imageIds","referenceImagePositionPatient","rowCosineVec","colCosineVec","scanAxisNormal","refIppVec","getDistance","positionVector","ippVec","prefetchedImageIds","metadataForMiddleImage","middleIppVec","distanceBetweenFirstAndMiddleImages","abs","distanceImagePairs","distance","sort","a","numImages","sliceThickness","spacingBetweenSlices","strictZSpacingForVolumeViewport","rendering","isNaN","debug","clamp","_colormaps","registerColormap","Name","getColormap","getColormapNames","findMatchingColormap","rgbPoints","colormapsVTK","rgbPresetNames","presetName","getPresetByName","colormapsCS3D","colormapName","matchedColormap","concat","find","RGBPoints","presetRGBPoints","opacityPoints","getScalarOpacity","getDataPointer","setColorMapTransferFunctionForVolumeActor","volumeInfo","volumeActor","threshold","colorRange","getMapper","setSampleDistance","presetToUse","applyColorMap","setMappingRange","updateOpacityWithThreshold","updateOpacity","newOpacity","getThresholdValue","updateThreshold","newThreshold","getMaxOpacity","meta","getInputData","getRange","thresholdValue","opacityFunction","dataArray","y1","x2","y2","maxOpacity","createLinearRGBTransferFunction","voiRange","lower","upper","createSigmoidRGBTransferFunction","approximationNodes","table","_","flatMap","buildFunctionFromArray","decimate","list","interleave","interleaveIndices","deepClone","obj","clonedObj","fnv1aHash","str","hash","charCodeAt","toString","log","coreLog","getLogger","getClosestImageId","imageVolume","worldPos","viewPlaneNormal","ignoreSpacing","kVector","dotProduct","EPSILON","halfSpacingInNormalDirection","closestImageId","minDistance","dir","getImageDataMetadata","xSpacing","ySpacing","xVoxels","yVoxels","zSpacing","_getNumCompsFromPhotometricInterpretation","numVoxels","camera","getCamera","spacingInNormalDirection","focalPoint","getActors","referencedId","uid","sliceRange","numberOfSlices","round","imageIndex","getScalingParameters","modalityLutModule","generalSeriesModule","scalingParameters","rescaleSlope","rescaleIntercept","scalingModules","suvbw","suvbsa","suvlbm","doseGridScaling","DoseGridScaling","doseSummation","DoseSummation","doseType","DoseType","doseUnit","DoseUnit","SMALL_EPSILON","isOne","isUnit","off","isOrthonormal","getSliceRange","imageData","corners","getDirection","dx","dy","dz","getDimensions","indexToWorld","buildFromDegree","identity","rotateFromDirections","pt","apply","transformedFocalPoint","currentSlice","minX","maxX","getSpacingInNormalDirection","iVector","jVector","dotProducts","projectedSpacing","EPSILON_PART","isPrimaryVolume","volume","getVolumeLoaderSchemes","starts","substring","getTargetVolumeAndSpacingInNormalDir","targetId","useSlabThickness","volumeActors","actorUID","imageVolumes","va","getVolume","iv","targetVolumeId","imageVolumeIndex","getSpacingInNormal","smallest","hasPrimaryVolume","slabThickness","getProperties","renderingEngines","targetViewports","filteredViewports","getVolumeViewports","vp","hasVolumeId","getVoiFromSigmoidRGBTransferFunction","cfunRange","getTable","cfunDomain","logy1","x1","logy2","ww","wc","getVolumeActorCorners","bounds","extentToBounds","getExtent","getVolumeId","getActor","numScrollSteps","floatingStepNumber","currentStepIndex","sliceRangeInfo","hasFloatScalingParameters","some","isInteger","hasNaNValues","input","imageIdToURI","colonIndex","retrieveConfigurationState","IMAGE_RETRIEVE_CONFIGURATION","imageRetrieveMetadataProvider","payload","clone","restore","state","queries","query","addProvider","EventListenerPhases","TargetEventListeners","target","_eventListeners","_children","_target","isEmpty","size","addEventListener","dotIndex","namespaceToken","childElementEventListener","_addEventListener","removeEventListener","_removeEventListener","reset","entries","child","_unregisterAllEvents","listenersMap","listenerPhase","capture","Capture","Bubble","registeredPhases","None","callbackItem","newListenerPhase","_unregisterAllListeners","listener","eventPhases","currentPhase","useCapture","MultiTargetEventListenerManager","_targetsEventListeners","eventListeners","targetEventListeners","scaleRGBTransferFunction","rgbTransferFunction","getSize","nodeValue1","getNodeValue","setNodeValue","getMinMax","storedPixelData","storedPixel","numPixels","LAST_RUNTIME_ID","GLOBAL_CONTEXT","DEFAULT_MAX","DEFAULT_SEPARATOR","getRuntimeId","symbol","idComponents","carry","n","getNextRuntimeId","join","imageURI","isOpposite","v1","v2","tolerance","indexWithinDimensions","targetViewport","renderingEngineId","getRenderingEngine","sameVolumesViewports","targetActors","vpActors","every","vpActor","preScale","scaled","renderToCanvasGPU","imageOrVolume","viewportOptions","displayArea","imageArea","HTMLCanvasElement","isVolume","viewportId","element","document","createElement","devicePixelRatio","window","originalWidth","originalHeight","style","visibility","position","body","appendChild","uniqueId","setAttribute","temporaryCanvas","getOrCreateCanvas","TiledRenderingEngine","getViewport","viewportInput","ViewportType","ORTHOGRAPHIC","STACK","defaultOptions","suppressEvents","enableElement","elementRendered","viewReference","onImageRendered","eventDetail","useViewRef","setViewReference","getContext","drawImage","canvasToWorld","topRight","bottomLeft","rightVector","downVector","Events","IMAGE_RENDERED","setTimeout","disableElement","querySelectorAll","remove","thicknessMm","setVolumes","renderImageObject","resetCamera","setProperties","renderToCanvasCPU","_renderingEngineId","_viewportOptions","getDefaultViewport","renderingTools","calculateTransform","drawImageSync","loadImageToCanvas","RequestType","Thumbnail","useCPURendering","thumbnail","imageAspect","baseViewportOptions","renderFn","successCallback","metaData","useRGBA","cache","imageLoadPoolManager","addRequest","imageIdIndex","asArray","HistoryMemo","label","redoAvailable","undoAvailable","ring","isRecordingGrouped","_size","canUndo","canRedo","undo","items","subitem","restoreMemo","dispatchHistoryEvent","isUndo","undoIf","condition","eventTarget","dispatchEvent","CustomEvent","detail","operationType","memo","redo","newPosition","initializeGroupItem","startGroupRecording","rollbackUnusedGroupItem","endGroupRecording","lastItem","pushGrouped","lastMemo","createMemo","DefaultHistoryMemo","worldCoords","newOrigin","sub","imageToWorldCoords","imageCoords","imageCoordsInWorld","getViewportsWithImageURI","getViewports","hasImageURI","getClosestStackImageIndexForPoint","minimalDistance","getImageIds","currentImageIdIndex","getCurrentImageIdIndex","planeMetadata","targetImagePlane","rowVec","colVec","planeNormal","getPlaneMetadata","plane","planeEquation","planeDistanceToPoint","closestStack","higherImageIds","lowerImageIds","calculateMinimalDistanceForStackViewport","getCurrentVolumeViewportSlice","canvasWidth","canvasHeight","sliceToIndexMatrix","indexToSliceMatrix","getSliceViewInfo","ijkOriginPoint","transformCanvasToIJK","ijkRowPoint","ijkColPoint","ijkRowVec","ijkColVec","ijkSliceVec","maxIJKRowVec","maxIJKColVec","getImageData","sliceViewInfo","getSliceData","spatialRegistrationMetadataProvider","viewportId1","viewportId2","entryId","entryIdReverse","viewport1","viewport2","imageId1","getSliceIndex","imageId2","imagePlaneModule1","imagePlaneModule2","iop2","imagePositionPatient1","imagePositionPatient2","mat","getViewportImageCornersInWorld","ratio","topRightCanvas","bottomRightCanvas","bottomLeftCanvas","topLeftWorld","topRightWorld","bottomRightWorld","bottomLeftWorld","topLeftImage","worldToIndex","topRightImage","bottomRightImage","bottomLeftImage","topLeftImageWorld","_isInBounds","topRightImageWorld","bottomRightImageWorld","bottomLeftImageWorld","_getStackViewportImageCorners","imageCoord","getEnabledElement","StackViewport","getCornerstoneImage","isValidVolume","imageId0","seriesInstanceUID","usingDefaultValues","baseMetadata","validVolume","isEqual","videoUIDs","Set","isVideoTransferSyntax","uidOrUids","async","convertStackToVolumeViewport","uuidv4","getUnknownVolumeLoaderSchema","prevViewPresentation","getViewPresentation","prevViewReference","getViewReference","background","orientation","createAndCacheVolume","load","volumeViewport","volumeViewportNewVolumeHandler","VOLUME_VIEWPORT_NEW_VOLUME","setViewPresentation","convertVolumeToStackViewport","ImageVolume","prevView","stackViewport","setStack","roundToPrecision","roundNumber","precision","absValue","fixedPrecision","toFixed","convertToGrayscale","isRGBA","isRGB","newScalarData","destOffset","increment","getRandomSampleFromArray","clonedArray","shuffleArray","random","componentToHex","c","hex","rgbToHex","hexToRgb","result","exec","parseInt","deepEqual","obj1","obj2","JSON","stringify","test4DTag","IPPGroups","value_getter","frame_groups","first_frame_value_set","positions","frame_value_set","frames","frame_value","setEquals","getTagValue","tag","getPhilipsPrivateBValue","InlineBinary","value_bytes","atob","ary_buf","dv","DataView","setUint8","getSiemensPrivateBValue","getGEPrivateBValue","set_a","set_b","getPetFrameReferenceTime","moduleInfo","positionGroups","ippMetadata","reduce","rv","frame_count","getIPPGroups","imageIdGroups","splittingTag","tags","fncList2","timePoints","isDynamicVolume","scaleArray","arrayLength","clip","val","low","high","scrollSlabs","getVolumeViewportScrollInfo","newFocalPoint","snapFocalPointToSlice","setCamera","desiredStepIndex","VolumeScrollEventDetail","currentImageId","getCurrentImageId","triggerEvent","VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS","VOLUME_VIEWPORT_SCROLL","scrollVolume","eventData","STACK_SCROLL_OUT_OF_BOUNDS","scroll","debounceLoading","loop","jumpToSlice","currentImageIndex","getTargetImageIdIndex","getNumberOfSlices","_getImageSliceData","imageIndexToJump","lastSliceIndex","_getImageIndexToJump","createSubVolume","referencedVolumeId","referencedVolume","refVolumeDim","minY","maxY","minZ","maxZ","ijkTopLeft","boundingBoxOriginWorld","transformIndexToWorld","subVolumeOptions","subVolume","createLocalVolume","subVolumeData","getCompleteScalarDataArray","subVolumeSliceSize","refVolumeSliceSize","refVolumeData","rowStartWorld","refVolumeRowStartIJK","transformWorldToIndex","refVolumeRowStartOffset","rowData","subVolumeLineStartOffset","setCompleteScalarDataArray","getVolumeDirectionVectors","viewUp","ijkOrigin","worldVecColDir","worldVecSliceDir","worldVecRowDir","ijkVecColDir","ijkVecSliceDir","ijkVecRowDir","calculateNeighborhoodStats","centerIjk","radius","numSlices","numPixelsPerSlice","sumSq","cx","cy","cz","centerIndex","mean","stdDev","variance","sqrt","projectionRadiographSOPClassUIDs","alreadySeenWarn","getPixelSpacingInformation","instance","PixelSpacing","SOPClassUID","SequenceOfUltrasoundRegions","isArrayOfSequences","PhysicalDeltaX","PhysicalDeltaY","calculateUSPixelSpacing","ImagerPixelSpacing","EstimatedRadiographicMagnificationFactor","PixelSpacingCalibrationType","PixelSpacingCalibrationDescription","isProjection","CalibrationTypes","UNKNOWN","ERMF","SeriesInstanceUID","PROJECTION","CALIBRATED","calculateRadiographicPixelSpacing","NOT_APPLICABLE","getViewportModality","Modality","_getViewportModality","invertRgbTransferFunction","areNumbersEqualWithTolerance","num1","num2","isNumberType","isNumberArrayLike","arr1","arr2","areArraysEqual","negative","isEqualNegative","isEqualAbs","isNumber","isFinite","loglevel","getRootLogger","logger","names","cs3dLog","toolsLog","loaderLog","aiLog","examplesLog","dicomConsistencyLog","imageConsistencyLog","makeVolumeMetadata","voiLut","voiLutModule","BitsAllocated","BitsStored","SamplesPerPixel","HighBit","PhotometricInterpretation","PixelRepresentation","ImageOrientationPatient","Columns","Rows","VOILUTFunction","linePlaneIntersection","p0","p1","x0","y0","z0","z1","A","B","C","D","t","normal","normalized","threePlaneIntersection","firstPlane","secondPlane","thirdPlane","A1","B1","C1","D1","A2","B2","C2","D2","A3","B3","C3","D3","m0","m1","m2","m3","signed","numerator","sign","isPointOnPlane","pointInShapeCallback","pointInShapeFn","returnPoints","scalars","getPointData","getScalars","getData","defaultBoundsIJK","pointsInShape","iMin","iMax","jMin","jMax","kMin","kMax","pointIJK","xMultiple","yMultiple","zMultiple","indexK","indexJK","pointLPS","iterateOverPointsInShape","iterateOverPointsInShapeVoxelManager","getAtIndex","deltaFrames","posDiffFromFocalPoint","steps","frameIndex","newSlicePosFromMin","sortImageIdsAndGetSpacing","usingWadoUri","sortedImageIds","getTransferFunctionNodes","transferFunction","setTransferFunctionNodes","nodes","node","canvasPoint","vtkImageData","worldPoint","voxelPos","transformWorldToIndexContinuous","ORTHOGONAL_TEST_VALUE","updatePlaneRestriction","reference","planeRestriction","inPlaneVector1","inPlaneVector2","testVector","updateVTKImageDataWithCornerstoneImage","sourceImageData","newPixelData","modified","toWindowLevel","toLowHighRange","SAMPLED_SIGMOID","LINEAR_EXACT","ChangeTypes","Swipe","initialDefaultState","colorLUT","segmentations","viewportSegRepresentations","getDefaultRenderingConfig","SegmentationRepresentations","Labelmap","defaultSegmentationStateManager","_stackLabelmapImageIdReferenceMap","_labelmapImageIdReferenceMap","freeze","getState","updateState","updater","newState","getColorLUT","lutIndex","getNextColorLUTIndex","resetState","getSegmentation","segmentationId","segmentation","updateSegmentation","draftState","assign","triggerSegmentationModified","addSegmentation","newSegmentation","representationData","getLabelmapImageIds","removeSegmentation","filteredSegmentations","triggerSegmentationRemoved","addSegmentationRepresentation","renderingConfig","getEnabledElementByViewportId","getSegmentationRepresentations","setRenderInactiveSegmentations","addDefaultSegmentationRepresentation","addLabelmapRepresentation","triggerSegmentationRepresentationModified","segmentReps","segments","segmentIndex","visible","active","colorLUTIndex","config","_setActiveSegmentation","processLabelmapRepresentationAddition","BaseVolumeViewport","isBaseVolumeSegmentation","updateLabelmapSegmentationImageReferences","_updateLabelmapSegmentationReferences","labelmapImageIds","updateCallback","referenceImageId","viewableLabelmapImageIdFound","labelmapImageId","isReferenceViewable","asOverlay","_updateLabelmapImageIdReferenceMap","_updateAllLabelmapSegmentationImageReferences","sliceIndex","withNavigation","labelmapData","getLabelmapImageIdsForImageId","_generateMapKey","getCurrentLabelmapImageIdsForViewport","getCurrentLabelmapImageIdForViewport","getStackSegmentationImageIdsForViewport","associatedReferenceImageAndLabelmapImageIds","removeSegmentationRepresentationsInternal","specifier","removedRepresentations","currentRepresentations","activeRepresentationRemoved","representation","shouldRemove","removeSegmentationRepresentations","triggerSegmentationRepresentationRemoved","remainingRepresentations","removeSegmentationRepresentation","suppressEvent","currentValues","newValues","setActiveSegmentation","getActiveSegmentation","activeSegRep","segRep","viewportRepresentations","typeMatch","idMatch","getSegmentationRepresentation","getSegmentationRepresentationVisibility","viewportRepresentation","setSegmentationRepresentationVisibility","segment","addColorLUT","removeColorLUT","_getStackIdForImageIds","getAllViewportSegmentationRepresentations","representations","getSegmentationRepresentationsBySegmentationId","viewportReps","filteredReps","getSegmentIndexColor","colorValue","setSegmentIndexColor","colorReference","segmentationStateManager","getLockedSegmentIndices","locked","renderers","Contour","Surface","segmentationListeners","addDefaultSegmentationListener","representationType","updateFunction","getUpdateFunction","listenerMap","SEGMENTATION_DATA_MODIFIED","removeSegmentationListener","debouncedHandler","event","eventSegmentationId","createDebouncedSegmentationListener","addSegmentationListener","svgNodeCache","BidirectionalTool","toolName","toolProps","defaultToolProps","supportedInteractionTypes","preventHandleOutsideImage","getTextLines","defaultGetTextLines","super","isPointNearTool","annotation","canvasCoords","proximity","handles","canvasPoint1","worldToCanvas","canvasPoint2","line","distanceToPoint","toolSelectedCallback","evt","highlighted","viewportIdsToRender","getViewportIdsWithToolToRender","getToolName","editData","movingTextBox","_activateModify","hideElementCursor","preventDefault","handleSelectedCallback","handle","handleIndex","worldPosition","_endCallback","newAnnotation","hasMoved","doneEditMemo","activeHandleIndex","_deactivateModify","_deactivateDraw","resetElementCursor","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","isHandleOutsideImage","removeAnnotation","annotationUID","triggerAnnotationCompleted","isDrawing","_dragDrawCallback","currentPoints","world","canvasCoordPoints","shortAxisDistFromCenter","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","triggerAnnotationModified","HandlesUpdated","_dragModifyCallback","deltaPoints","worldPosDelta","textBox","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","cos","sin","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","cancel","_activateDraw","isInteractingWithTool","MOUSE_UP","MOUSE_DRAG","MOUSE_MOVE","MOUSE_CLICK","TOUCH_TAP","TOUCH_END","TOUCH_DRAG","renderAnnotation","svgDrawingHelper","renderStatus","annotations","getAnnotations","filterInteractableAnnotationsForElement","getTargetId","styleSpecifier","toolGroupId","canvasCoordinates","lineWidth","lineDash","shadow","getAnnotationStyle","cachedStats","unit","_throttledCalculateCachedStats","_calculateCachedStats","activeHandleCanvasCoords","isAnnotationVisible","isAnnotationLocked","showHandlesAlways","Boolean","handleGroupUID","drawHandles","dataId1","dataId2","lineUID","drawLine","secondLineUID","getLinkedTextBoxStyle","worldBoundingBox","topLeft","bottomRight","textLines","canvasTextBoxCoords","getTextBoxCoordsCanvas","textBoxPosition","textBoxUID","boundingBox","drawLinkedTextBox","left","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos1","worldPos2","worldPos3","worldPos4","targetIds","getTargetImageData","index1","index2","index3","index4","handles1","handles2","scale1","units1","scale2","units2","dist1","_calculateLength","dist2","widthUnit","_isInsideVolume","StatsUpdated","vector1","vector2","atan2","trailing","addNewAnnotation","createAnnotation","addAnnotation","hydrate","axis","hydrateBase","majorAxis","minorAxis","major0","major1","minor0","minor1","toolInstance","serializableOptions","utilities","autoGenerated","isLocked","isVisible","pos1","pos2","BrushTool","strategies","FILL_INSIDE_CIRCLE","ERASE_INSIDE_CIRCLE","FILL_INSIDE_SPHERE","ERASE_INSIDE_SPHERE","THRESHOLD_INSIDE_CIRCLE","THRESHOLD_INSIDE_SPHERE","THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL","defaultStrategy","activeStrategy","brushSize","useCenterSegmentIndex","preview","enabled","previewColors","previewTimeMs","previewMoveDistance","dragMoveDistance","dragTimeMs","actions","StrategyCallbacks","AcceptPreview","method","bindings","RejectPreview","Interpolate","useBallStructuringElement","noUseDistanceTransform","noUseExtrapolation","interpolateExtrapolation","_lastDragInfo","onSetToolPassive","disableCursor","onSetToolEnabled","onSetToolDisabled","preMouseDownCallback","_editData","createEditData","_previewData","isDrag","timerStart","Date","now","hoverData","_hoverData","createHoverData","operationData","getOperationData","applyActiveStrategyCallback","OnInteractionStart","mouseMoveCallback","mode","ToolModes","Active","updateCursor","startPoint","timer","time","clearTimeout","rejectPreview","previewCallback","strategyData","strategy","segmentationVoxelManager","Preview","_dragCallback","startCanvas","startWorld","currentCanvas","currentWorld","_calculateCursor","strokePointsWorld","applyActiveStrategy","currentCanvasClone","OnInteractionEnd","acceptPreview","centerCanvas","viewRight","centerCursorInWorld","bottomCursorInWorld","topCursorInWorld","leftCursorInWorld","rightCursorInWorld","brushCursor","computeInnerCircleRadius","getStatistics","segmentIndices","GetStatistics","interpolate","invalidateBrushCursor","segmentColor","getActiveSegmentationData","toolMetadata","brushCursorUID","bottom","drawCircle","centerSegmentIndexInfo","dynamicRadiusInCanvas","circleUID1","getEllipseCornersFromCanvasCoordinates","right","initializeCircle","Initialize","segmentationImageData","centerWorld","centerIJK","brushRadius","cornersInWorld","corner","normalizedViewUp","normalizedPlaneNormal","strokeCenters","strokeCornersWorld","centerPoint","centerVec","createCircleCornersForCenter","circleCornersIJK","getBoundingBoxAroundShapeIJK","isInObject","createPointInEllipse","isInObjectBoundsIJK","majorAxisVec","xRadius","minorAxisVec","yRadius","radiusForStroke","strokePredicate","centers","radiusSquared","centerVecs","lengthSquared","vector","dot","projX","projY","projZ","distX","distY","distZ","createStrokePredicate","sphereObj","radius2","pointVec","distToPlane","proj","fromTopLeft","centerToTopLeft","CIRCLE_STRATEGY","regionFill","setValue","determineSegmentIndex","labelmapStatistics","CIRCLE_THRESHOLD_STRATEGY","dynamicThreshold","islandRemoval","fillInsideCircle","strategyFunction","thresholdInsideCircle","initializeRectangle","rectangleCornersIJK","coord","p2","p3","axisU","axisV","uLen","vLen","getSpacing","EPS","u","vproj","d","createPointInRectangle","RECTANGLE_STRATEGY","RECTANGLE_THRESHOLD_STRATEGY","getClosestImageIdForStackViewport","ImagePositionPatient","calculateDistanceToImage","CONSTANTS","calculateBoundingBox","isWorld","xMin","xMax","yMin","yMax","zMin","zMax","is3D","findNextLink","lines","contourPoints","cell","nextLine","remainingLines","findContours","firstCell","shift","extraContours","findContoursFromReducedSet","getDeduplicatedVTKPolyDataPoints","polyData","bypass","getPoints","getLines","pointsArray","getNumberOfPoints","linesArray","getNumberOfCells","getCell","newIndex","Enums","PIXEL_UNITS","VOXEL_UNITS","SUPPORTED_REGION_DATA_TYPES","SUPPORTED_LENGTH_VARIANT","UNIT_MAPPING","SQUARE","getCalibratedLengthUnitsAndScale","hasPixelSpacing","volumeUnit","areaUnit","calibrationType","sequenceOfUltrasoundRegions","UNCALIBRATED","imageIndex1","imageIndex2","regions","region","regionLocationMinX0","regionLocationMaxX1","regionLocationMinY0","regionLocationMaxY1","regionDataType","physicalUnitsXDirection","physicalUnitsYDirection","physicalDeltaX","physicalDeltaY","USER","ERROR","_getSphereBoundsInfo","circlePoints","directionVectors","radiusWorld","rowCosine","column","columnCosine","vecNormal","topLeftIJK","bottomRightIJK","pointsIJK","_computeBoundsIJK","getSphereBoundsInfoFromViewport","getToolsWithModesForElement","modesFilter","toolGroup","getToolGroupForViewport","enabledTools","toolGroupToolNames","toolOptions","getToolInstance","Calculator","InstanceCalculator","storePointData","distanceToPointSquared","lineStart","lineEnd","distanceSquared","distanceToPointSquaredInfo","closestPoint","ORIENTATION_TOLERANCE","isPointOnLineSegment","z2","mirror","mirrorPoint","staticPoint","canvasPoints","newCanvasPoint","commonData","xDir","yDir","lastWorldPos","newWorldPos","worldPosDiff","xDist","yDist","numPointsToAdd","lastCanvasPoint","canvasDist","canvasDir","distPerPoint","areLineSegmentsIntersecting","q1","q2","line1MinX","line1MinY","line1MaxX","line1MaxY","line2MinX","line2MinY","line2MaxX","line2MaxY","orient","onSegment","q","orientationValue","PolylinePointType","PolylinePointPosition","PolylinePointDirection","ensuresNextPointers","polylinePoints","len","currentPoint","next","mergePolylines","targetPolyline","sourcePolyline","targetNormal","sourceNormal","dotNormals","targetPolylinePoints","sourcePolylinePoints","sourceIntersectionsCache","intersectionPointDirection","Exiting","Entering","pointInside","vertexPoint","Vertex","coordinates","Inside","Outside","visited","intersectionsInfo","intersectedLineSegment","sourceLineSegmentId","intersectionCoordinate","coordinate","targetStartPointDistSquared","intersectionInfo","targetEdgePoint","Intersection","Edge","sourceEdgePoint","Unknown","cloned","sourceIntersectionPoints","lineSegmentId","intersectionPoint","lineSegStartDistSquared","getSourceAndTargetPointsList","getUnvisitedOutsidePoint","mergedPolyline","iterationCount","maxIterations","containsPoint","polyline","closed","numPolylinePoints","numIntersections","holes","hole","shouldClose","maxSegmentIndex","intersects","xIntersection","convexHull","pts","cross","o","getAABB","polylineToUse","numDimensions","currentPolyline","totalPoints","getArea","area","getClosestLineSegmentIntersection","initialQ2Index","p2Index","intersections","q2Index","distances","intersection","intersectionPoints","midpoint","getFirstLineSegmentIntersectionIndexes","initialI","getLineSegmentIntersectionsCoordinates","polylineIndexes","getLineSegmentIntersectionsIndexes","numPoints","maxI","PARALLEL_LINES_TOLERANCE","getLinesIntersection","diffQ1P1","diffQ2P2","denominator","line1AABB","line2AABB","numerator2","getNormal2","getNormal3","vecArea","refPoint","aX","aY","aZ","bX","bY","bZ","_getAreaVector","subPixelResolution","volumeSpacing","absViewRightDotI","absViewRightDotJ","absViewRightDotK","absViewUpDotI","absViewUpDotJ","absViewUpDotK","getWindingDirection","intersectPolyline","sourceLen","sourceP1","sourceP2","intersectionPointIndexes","intersectPolylines","mainPolyCoords","clipPolyCoordsInput","clipPolyCoords","mainArea","clipArea","currentClipPolyForPIP","intersectPt","lenP","lenQ","seg1Idx","seg2Idx","alpha1","alpha2","buildAugmentedList","polyCoords","polyIndex","allIntersections","augmentedList","nodeIdCounter","originalPolyIndex","originalVertexIndex","prev","isIntersection","processedInPath","intersectionDir","segmentIntersections","isect","lastNode","alpha","finalList","lastNodeInFinal","firstNode","lastNodePopped","mainAugmented","clipAugmented","mainNode","mainIntersectData","partnerNode","clipNode","v_arrival_main","v_departure_clip","crossZ","midPrevMainSeg","resultPolygons","startCand","currentPathCoords","currentNode","onMainList","pathStartNode","safetyBreak","maxIter","switchedList","resultArea","isPointInsidePolyline3D","sharedDimensionIndex","projectedPolyline","projectedHoles","hole2D","point2D","p1p","p1p2","p1p2Mag","projectionVectorMag","p1p2UnitVector","projectionVector","projectionPoint","closeContourProximity","epsilon","projectTo2D","testPoints","points2D","firstDim","secondDim","vec2CrossZ","pointsAreEqual","robustSegmentIntersection","s","rxs","qmp","qmpxr","rDotR","sDotS","t0","t1","u0","u1","isInRange","PolylineNodeType","IntersectionDirection","subtractPolylines","targetPolylineCoords","sourcePolylineCoordsInput","sourcePolylineCoords","targetArea","sourceArea","targetAugmented","sourceAugmented","tnode","tData","partner","snode","p_prev","p_curr","p_next_source","midPrevTargetSeg","prevSegMidpointInsideSource","resultPolylines","startNode","onTargetList","createBidirectionalForSlice","sliceContour","isInSegment","currentMax","maxMajor","maxMinor","currentMaxMinor","currentMaxMajor","maxMajorPoints","point1","point2","distance2","testCenter","handle0","handle1","unitMajor","maxMinorPoints","isLineInSegment","ijk1","ijk2","testPoint","testIJK","testSize","unitDelta","createIsInSegmentMetadata","containedSegmentIndices","pixelsPerSlice","ijk","triggerAnnotationRenderForToolGroupIds","toolGroupIds","getToolGroup","getViewportsInfo","viewportInfo","SegmentStatsCalculator","calculators","indices","statsInit","statsCallback","statsData","calculator","labelmapDisplay","contourDisplay","surfaceDisplay","planarContourToolName","PlanarFreehandContourSegmentationTool","_needsRender","_pendingRenderQueue","_animationFrameSet","_animationFrameHandle","_getAllViewports","getRenderingEngines","_renderFlaggedSegmentations","_throwIfDestroyed","_triggerRender","nextViewportIds","_setViewportsToBeRenderedNextFrame","renderSegmentationsForViewport","_getViewportIdsForSegmentation","renderSegmentation","segmentationRepresentations","_render","requestAnimationFrame","segmentationRenderList","_addPlanarFreeHandToolIfAbsent","display","existingRepresentation","allSettled","results","segmentationDetails","status","onSegmentationRender","SEGMENTATION_RENDERED","tools","addTool","hasTool","setToolPassive","EdgeLocator","oriented","arguments","edgeMap","initialize","computeEdgeKey","pointId0","pointId1","insertUniqueEdge","newEdgeValue","edgeId","insertEdge","isInsertedEdge","getEdgePointIds","vtkEdgeLocator","newInstance","MARCHING_SQUARES_CASES","EDGES","vtkCaseTable","getCase","getEdge","eid","vtkErrorMacro","vtkDebugMacro","m","vtkImageMarchingSquares","publicAPI","model","classHierarchy","getContourValues","contourValues","setContourValues","cValues","ids","pixelScalars","pixelPts","edgeLocator","getPixelScalars","dims","increments","kernelX","kernelY","ii","getPixelPoints","produceLines","cVal","slicingMode","CASE_MASK","pId","idx","pixelLines","edgeVerts","mergePoints","requestData","inData","outData","getOrigin","extent","computeIncrements","getKernels","cv","polydata","setData","Uint32Array","timeEnd","DEFAULT_VALUES","initialValues","algo","setGet","vtkImageMarchingSquares$1","VoxelManager","computeWorker","createVoxelManager","createScalarVolumeVoxelManager","createDataStructure","info","createVTKImageData","setDimensions","setOrigin","setDirection","setSpacing","scalarArray","setScalars","processSegmentStatistics","segVoxelManager","imageVoxelManager","imageValue","getDefaultBounds","performMarchingSquares","mSquares","setInputData","setMergePoints","getOutputData","createContoursFromPolyData","msOutput","reducedSet","contours","createSegmentsFromIndices","getArgsFromInfo","args","segmentationInfo","imageInfo","calculateSegmentsStatisticsVolume","segmentationSpacing","computeMetabolicStats","imageSpacing","imageDimensions","imageDirection","imageOrigin","refVoxelManager","suv","scalarDataLength","getScalarDataLength","tmtv","tlg","calculateSegmentsStatisticsStack","segInfo","imgInfo","segDimensions","getSegmentLargestBidirectionalInternal","isStack","calculateBidirectionalStack","calculateVolumetricBidirectional","findLargestBidirectionalFromContours","maxBidirectional","bidirectional","bidirectionalResults","segScalarData","segIndex","isSliceEmptyForSegmentVolume","sliceContours","filteredData","contourData","bidirectionalResult","contourSets","generateContourSetsFromLabelmapVolume","contourSet","ContourSets","numSegments","frameStart","imageDataCopy","shallowCopy","ContourSet","segData","startIdx","endIdx","Constants","AttributeCopyOperations","COPYTUPLE","INTERPOLATE","PASSDATA","ALLCOPY","AttributeLimitTypes","MAX","EXACT","NOLIMIT","AttributeTypes","SCALARS","VECTORS","NORMALS","TCOORDS","TENSORS","GLOBALIDS","PEDIGREEIDS","EDGEFLAG","NUM_ATTRIBUTES","CellGhostTypes","DUPLICATECELL","HIGHCONNECTIVITYCELL","LOWCONNECTIVITYCELL","REFINEDCELL","EXTERIORCELL","HIDDENCELL","DesiredOutputPrecision","DEFAULT","SINGLE","DOUBLE","PointGhostTypes","DUPLICATEPOINT","HIDDENPOINT","ghostArrayName","dataDescription","EMPTY","Float64Array","setGetArray","getArray","setExtent","deleted","_len","inExtent","_key","extentArray","changeDetected","nCells","SINGLE_POINT","X_LINE","Y_LINE","Z_LINE","XY_PLANE","YZ_PLANE","XZ_PLANE","XYZ_GRID","coords","getBounds","getSpatialExtent","ex","computeTransforms","ain","aout","indexToWorldVec3","worldToIndexVec3","indexToWorldBounds","bin","bout","worldToIndexBounds","onModified","getCenter","computeHistogram","worldBounds","voxelFunction","yStride","zStride","pixels","maximum","minimum","sumOfSquares","isum","inum","pixel","average","sigma","incr","computeOffsetIndex","_ref","getNumberOfComponents","getOffsetIndexFromWorld","NaN","getScalarValueFromWorld","offsetIndex","getComponent","vtkImageData$1","ColorSpace","Scale","ScalarMappingTarget","vtkWarningMacro","vtkColorTransferFunctionLabToMsh","lab","msh","L","M","acos","h","vtkColorTransferFunctionAdjustHue","unsatM","hueSpin","vtkColorTransferFunctionInterpolateDiverging","rgb1","rgb2","lab1","lab2","msh1","msh2","localS","a1","a2","adiff","vtkColorTransferFunctionAngleDiff","Mmid","mshTmp","labTmp","vtkColorTransferFunctionMshToLab","clamping","colorSpace","RGB","hSVWrap","nanColor","belowRangeColor","aboveRangeColor","useAboveRangeColor","useBelowRangeColor","allowDuplicateScalars","tableSize","buildTime","discretize","numberOfValues","enum","setArray","addRGBPointLong","sharpness","removePoint","sortAndUpdateRange","addHSVPoint","addHSVPointLong","rgb","hsv","setNodes","before","after","modifiedInvoked","updateRange","oldRange","mappingRange","retVal","movePoint","oldX","newX","addRGBSegment","r1","g1","b1","r2","g2","b2","addHSVSegment","h1","s1","h2","s2","hsv1","hsv2","mapValue","getColor","indexedLookup","numNodes","getAnnotatedValueIndexInternal","getNanColorByReference","nodeVal","getRedValue","getGreenValue","getBlueValue","xStart_","xEnd_","xStart","xEnd","lastR","lastG","lastB","tmpVec","usingLogScale","LOG10","logStart","logEnd","logX","log10","tidx","deltaRange","xn","discretizeIndex","getUseAboveRangeColor","getUseBelowRangeColor","HSV","hsvTmp","LAB","DIVERGING","ss","sss","h3","h4","getUint8Table","withAlpha","getMTime","tableWithAlpha","nbChannels","tmpTable","numComponents","getNumberOfTuples","buildFunctionFromTable","inc","getNumberOfAvailableColors","nNodes","getIndexedColor","nodeValue","fillFromDataPointer","nb","ptr","originalRange","adjustRange","functionRange","estimateMinNumberOfSamples","findMinimumXDistance","ceil","MAX_VALUE","currentDist","mapScalarsThroughTable","output","outFormat","inputOffset","mapDataIndexed","getAlpha","inIncr","outputV","inputV","RGBA","LUMINANCE","LUMINANCE_ALPHA","colorMap","oldColorSpace","toUpperCase","isModified","oldNanColor","NanColor","oldNodes","callModified","vtkColorTransferFunction","vtkColorTransferFunction$1","out","hypot","fromValues","copy","subtract","multiply","divide","scaleAndAdd","squaredDistance","squaredLength","negate","inverse","normalize","ax","ay","az","bx","by","bz","lerp","hermite","factorTimes2","factor1","factor2","factor3","factor4","bezier","inverseFactor","inverseFactorTimesTwo","zScale","transformMat4","w","transformMat3","transformQuat","qx","qy","qz","qw","uvx","uvy","uvz","uuvx","uuvy","uuvz","w2","rotateX","rad","rotateY","rotateZ","mag","cosine","zero","exactEquals","equals","a0","b0","vec","mul","div","dist","sqrDist","sqrLen","stride","fn","arg","l","bisector","compare1","compare2","lo","hi","mid","zip","interpolator","samples"],"sourceRoot":""}