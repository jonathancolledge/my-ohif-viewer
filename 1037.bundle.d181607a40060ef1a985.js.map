{"version":3,"file":"1037.bundle.d181607a40060ef1a985.js","mappings":"sKAIe,SAAS,EAACA,EAAgBC,GACrC,MAAMC,EAAQF,EAAeE,MAC7B,IAAKF,EAAeG,SAAWH,EAAeE,MAC1C,OAEJ,MAAME,GAAQ,SAQd,GAPAF,EAAMG,MAAQ,CACVC,sBAAuB,EACvBC,0CAA2C,EAC3CC,sBAAuB,EACvBC,gBAAiB,EACjBC,qBAAsB,GAEtBR,EAAO,CACP,IAAIS,EAAST,EAAMS,OACdA,IAEGA,EADAX,EAAeY,SAASC,SACf,IAEJX,EAAMY,MACF,IAGA,KAGjBH,EAAOX,EAAgBC,EAC3B,CACA,MAAMc,GAAiB,SAAQX,EAC/BF,EAAMG,MAAMI,eAAiBM,EAC7Bf,EAAegB,SAAU,EACzBhB,EAAeiB,aAAc,CACjC,C,8DCnCe,SAAS,EAACjB,EAAgBkB,GACrC,MAAMC,EAAY,IAAI,IACtB,IAAKnB,EAAeY,SAASQ,cACzB,OAAOD,EAEXA,EAAUE,UAAUrB,EAAeG,OAAOmB,MAAQ,EAAGtB,EAAeG,OAAOoB,OAAS,GACpF,MAAMC,EAAQxB,EAAeY,SAASa,SACxB,IAAVD,GACAL,EAAUO,OAAQF,EAAQG,KAAKC,GAAM,KAEzC,IAAIC,EAAa7B,EAAeY,SAASM,MACrCY,EAAc9B,EAAeY,SAASM,MAC1C,MAAMI,EAAQtB,EAAeY,SAASQ,cAAcW,KAAKC,GACpDhC,EAAeY,SAASQ,cAAca,KAAKD,EAAI,GAC9CT,EAASvB,EAAeY,SAASQ,cAAcW,KAAKG,GACrDlC,EAAeY,SAASQ,cAAca,KAAKC,EAAI,GACpD,GAAmE,SAA/DlC,EAAeY,SAASQ,cAAce,qBAClCnC,EAAeE,MAAMkC,gBACrBpC,EAAeE,MAAMmC,mBACrBR,GACI7B,EAAeE,MAAMmC,mBACjBrC,EAAeE,MAAMkC,gBAExBpC,EAAeE,MAAMmC,mBAC1BrC,EAAeE,MAAMkC,kBACrBN,GACI9B,EAAeE,MAAMkC,gBACjBpC,EAAeE,MAAMmC,yBAMjC,GAFAR,EAAa7B,EAAeY,SAASQ,cAAciB,mBACnDP,EAAc9B,EAAeY,SAASQ,cAAcgB,gBAEhD,iBADApC,EAAeY,SAASQ,cAAce,qBACtB,CAChB,MAAMG,EAAgBtC,EAAeG,OAAOoB,QAAUA,EAASO,GACzDS,EAAkBvC,EAAeG,OAAOmB,OAASA,EAAQO,GAC/DA,EAAaC,EAAcH,KAAKa,IAAID,EAAiBD,GACjDtC,EAAeY,SAASQ,cAAcgB,gBACtCpC,EAAeY,SAASQ,cAAciB,mBACtCR,GACI7B,EAAeY,SAASQ,cAAciB,mBAClCrC,EAAeY,SAASQ,cAAcgB,gBAEzCpC,EAAeY,SAASQ,cAAciB,mBAC3CrC,EAAeY,SAASQ,cAAcgB,kBACtCN,GACI9B,EAAeY,SAASQ,cAAcgB,gBAClCpC,EAAeY,SAASQ,cAAciB,mBAEtD,CAoBJ,OAlBAlB,EAAUD,MAAMW,EAAYC,GACd,IAAVN,GACAL,EAAUO,QAASF,EAAQG,KAAKC,GAAM,KAE1CT,EAAUE,UAAUrB,EAAeY,SAAS6B,YAAYT,EAAGhC,EAAeY,SAAS6B,YAAYP,GACjF,IAAVV,GACAL,EAAUO,OAAQF,EAAQG,KAAKC,GAAM,UAE3Bc,IAAVxB,GACAC,EAAUD,MAAMA,EAAOA,GAEvBlB,EAAeY,SAAS+B,OACxBxB,EAAUD,OAAO,EAAG,GAEpBlB,EAAeY,SAASgC,OACxBzB,EAAUD,MAAM,GAAI,GAExBC,EAAUE,WAAWC,EAAQ,GAAIC,EAAS,GACnCJ,CACX,C,0ECtEe,SAAS,EAAChB,EAAQD,EAAO2C,EAAUhC,GAC9C,QAAe6B,IAAXvC,EACA,MAAM,IAAI2C,MAAM,8DAEpB,QAAcJ,IAAVxC,EACA,OAAO,SAEX,MAAMgB,GAAQ,OAAiBf,EAAQD,EAAO,GAAG6C,YACjD,IAAIC,EAkBJ,MAjBiB,OAAbH,GAAqB3C,EAAM+C,YAC3BD,EAAM,CACFE,YAAa,EACbC,aAAc,UAGST,IAAtBxC,EAAMgD,kBACYR,IAAvBxC,EAAMiD,eACNH,EAAM,CACFE,YAAaE,MAAMC,QAAQnD,EAAMgD,aAC3BhD,EAAMgD,YAAY,GAClBhD,EAAMgD,YACZC,aAAcC,MAAMC,QAAQnD,EAAMiD,cAC5BjD,EAAMiD,aAAa,GACnBjD,EAAMiD,eAGb,CACHjC,QACAuB,YAAa,CACTT,EAAG,EACHE,EAAG,GAEPc,MACAM,OAAQpD,EAAMoD,OACdC,kBAAkB,EAClB9B,SAAU,EACVkB,OAAO,EACPC,OAAO,EACPY,YAAatD,EAAMsD,YACnBX,WACAY,OAAQvD,EAAMuD,OACd5C,cAAuB6B,IAAb7B,EAAyBA,EAAWX,EAAMW,SACpDO,cAAe,CACXa,KAAM,CACFD,EAAG,EACHE,EAAG,GAEPH,KAAM,CACFC,EAAG9B,EAAMwD,QACTxB,EAAGhC,EAAMyD,MAEbvB,qBAA2CM,IAA1BxC,EAAMkC,gBAAgC,EAAIlC,EAAMkC,gBACjEC,wBAAiDK,IAA7BxC,EAAMmC,mBAAmC,EAAInC,EAAMmC,mBACvEF,qBAAsB,QAGlC,C,mgBC1DWyB,E,gLACX,SAAWA,GACPA,EAAuB,IAAI,MAC3BA,EAA4B,SAAI,WAChCA,EAA2B,QAAI,SAClC,CAJD,CAIGA,IAAsBA,EAAoB,CAAC,I,49BCL9C,MAAMC,EAAmBC,OAAO,mBAC1BC,EAAmBD,OAAO,mBAC1BE,EAAsBF,OAAO,qBAC7BG,EAAaH,OAAO,cACX,MAAMI,EACjB,WAAAC,CAAYC,GACR,MAAMC,EAAaC,OAAOC,OAAQH,aAAgBF,GAAYD,KAAcG,EACtEA,EAAKH,GACL,MACNK,OAAOE,KAAKF,OAAOG,eAAeC,KAAMT,EAAY,CAChDU,MAAON,IAEf,CACA,GAAAO,CAAIC,EAAKF,GACL,OAAOC,EAAIF,KAAKT,GAAaY,EAAKF,EAAO,KAC7C,CACA,GAAAG,CAAID,GACA,OAmIR,SAAaR,EAAYQ,GACrB,OAAOR,EAAWQ,EACtB,CArIeC,CAAIJ,KAAKT,GAAaY,EACjC,CACA,KAAAE,CAAMF,GACF,OA8ER,SAAeR,EAAYW,GACvB,GAAIA,EAAKC,SAAS,KAAM,CACpB,IAAIC,EAAc,EAClB,MAAMC,EAAYH,EACZZ,EAAOe,EAAUC,MAAM,GAAI,GAC3BC,EAA4B,IAAhBjB,EAAKkB,OACvB,IAAK,MAAMT,KAAOR,EACVC,OAAOiB,UAAUC,eAAeC,KAAKpB,EAAYQ,KAChDQ,GAAaR,EAAIa,WAAWP,IAAcN,IAAQT,YAC5CC,EAAWQ,KAChBK,GAGV,OAAOA,EAAc,CACzB,CACA,cAAcb,EAAWW,EAC7B,CA9FeD,CAAML,KAAKT,GAAaY,EAAM,GACzC,CACA,OAAAc,CAAQC,GACJC,EAAQnB,KAAKT,GAAa2B,EAC9B,CACA,MAAAE,GACI,OAAO,IAAI5B,EAASQ,KACxB,CACA,MAAAqB,CAAOC,GACCC,EAAcD,IACd1B,OAAO4B,KAAKF,GAAML,QAASd,IACvBD,EAAIF,KAAKT,GAAaY,EAAKmB,EAAKnB,GAAM,OAGlD,CACA,IAAAsB,GACI,MAAMC,EAAU,CAAC,EAMjB,OALAP,EAAQnB,KAAKT,GAAa,CAACY,EAAKF,UACP,IAAVA,GACP0B,EAAQD,EAASvB,EAAKF,KAGvByB,CACX,CACA,aAAOE,CAAOC,GACV,OAAOA,aAAmBrC,EACpBqC,EACArC,EAASsC,oBACnB,CACA,yBAAOC,CAAmBC,EAAW,MACjC,IAAIC,EAAkBzC,EAASL,GAK/B,GAJM8C,aAA2BzC,IAC7ByC,EAAkB,IAAIzC,EACtBA,EAASL,GAAoB8C,GAE7BD,EAAU,CACV,MAAME,EAAa,CAAC,EAOpB,OANAD,EAAgBhB,QAASX,IACrB,GAAIA,EAAKU,WAAWgB,GAAW,CAC3B,MAAMG,EAAU7B,EAAK8B,MAAM,GAAGJ,MAAa,GAC3CE,EAAWC,GAAWF,EAAgB7B,IAAIE,EAC9C,IAEG4B,CACX,CACA,OAAOD,CACX,CACA,yBAAOH,GACH,IAAIO,EAAkB7C,EAASH,GAK/B,OAJMgD,aAA2B7C,IAC7B6C,EAAkB,IAAI7C,EAASA,EAASuC,sBACxCvC,EAASH,GAAoBgD,GAE1BA,CACX,CACA,wBAAOC,CAAkBT,EAASU,GAC9B,IAAIC,EAAW,KACf,GAAIX,aAAmBrC,EACnBgD,EAAWX,OAEV,GAAuB,iBAAZA,GAAoC,OAAZA,EAAkB,CACtD,IAAIY,EAAoBjD,EAASF,GAC3BmD,aAA6BC,UAC/BD,EAAoB,IAAIC,QACxBlD,EAASF,GAAuBmD,GAEpCD,EAAWC,EAAkBrC,IAAIyB,GAC3BW,aAAoBhD,IACtBgD,EAAW,IAAIhD,EAASA,EAASoC,OAAOpC,EAAS8C,kBAAkBC,KACnEE,EAAkBvC,IAAI2B,EAASW,GAEvC,CACA,OAAOA,CACX,CACA,4BAAOG,GACH,OAAOnD,EAASsC,qBAAqBV,QACzC,EAmBJ,SAASD,EAAQxB,EAAYuB,GACzB,IAAK,MAAMf,KAAOR,EACduB,EAASf,EAAKR,EAAWQ,GAEjC,CAmBA,SAASD,EAAIP,EAAYQ,EAAKF,EAAO2C,GACjC,QAYJ,SAAoBzC,GAChB,IAAI0C,EAAMC,EAASC,EACnB,GAAmB,iBAAR5C,IAAqB0C,EAAO1C,EAAIS,OAAS,GAAK,EACrD,OAAO,EAEXmC,GAAY,EACZ,MAAQD,EAAU3C,EAAI6C,QAAQ,IAAKD,EAAW,KAAO,GAAG,CACpD,GAAID,EAAUC,EAAW,GAAKD,IAAYD,EACtC,OAAO,EAEXE,EAAWD,CACf,CACA,OAAO,CACX,CAzBQG,CAAW9C,KACPoB,EAActB,GApB1B,SAAgBN,EAAYuD,EAAQC,EAAQP,GACxC,IAAIQ,EACJ,GAAIR,EAAWS,IAAIF,GACf,OAAOjD,EAAIP,EAAYuD,EAAQ,KAAMN,GAEzCA,EAAWU,IAAIH,GACfC,EAAY,EACZ,IAAK,MAAMG,KAASJ,EACZvD,OAAOiB,UAAUC,eAAeC,KAAKoC,EAAQI,KAExCrD,EAAIP,EADoB,IAAjB4D,EAAM3C,OAAesC,EAAS,GAAGA,KAAUK,IAC7BJ,EAAOI,GAAQX,MACnCQ,GAKd,OADAR,EAAWY,OAAOL,GACG,IAAdC,CACX,CAImBK,CAAO9D,EAAYQ,EAAKF,EAAO2C,aAAsBc,QAAUd,EAAa,IAAIc,UAE3F/D,EAAWQ,GAAOF,GACX,GAGf,CAkBA,SAASsB,EAAcM,GACnB,GAAuB,iBAAZA,GAAoC,OAAZA,EAAkB,CACjD,MAAMhB,EAAYjB,OAAO+D,eAAe9B,GACxC,GAAIhB,IAAcjB,OAAOiB,WAA2B,OAAdA,EAClC,OAAO,CAEf,CACA,OAAO,CACX,CACA,SAASc,EAAQD,EAASvB,EAAKF,GAC3B,MAAM2D,EAAYzD,EAAI6C,QAAQ,KAC9B,GAAIY,GAAa,EAAG,CAChB,MAAMC,EAAS1D,EAAIO,MAAM,EAAGkD,GAC5B,IAAIE,EAAapC,EAAQmC,GACzB,GAA0B,iBAAfC,GAA0C,OAAfA,EAAqB,CACvD,MAAMC,EAAkBD,EACxBA,EAAa,CAAC,OACiB,IAApBC,IACPD,EAAW,IAAMC,GAErBrC,EAAQmC,GAAUC,CACtB,CACAnC,EAAQmC,EAAY3D,EAAIO,MAAMkD,EAAY,EAAGzD,EAAIS,QAASX,EAC9D,MAEIyB,EAAQvB,GAAOF,CAEvB,CACAT,EAASuC,qBAAqB7B,IAAI,cAAc,G,wqBCtLhD,MAAM8D,EAAe,CAAC,EACtB,IAAIC,EACJ,SAASC,EAAyBC,EAASC,GACvC,MAAMC,EAAwB,KAAMC,mBAAmBH,GACvD,GAAIE,EAEA,OADAE,EAAuBF,EAAsBG,QAASL,GAC/CE,EAEX,MAAMI,EAASN,EAAQ/B,MAAM,KAAK,GAC5BsC,EAASV,EAAaS,IAAWR,EACvC,IAAKS,EACD,MAAM,IAAItG,MAAM,+DAA+DqG,MAEnF,MAAME,EAAkBD,EAAOP,EAASC,GAExC,OADAG,EAAuBI,EAAgBH,QAASL,GACzCQ,CACX,CACA,SAASJ,EAAuBK,EAAcT,GAC1CU,QAAQC,QAAQF,GACXG,KAAMvJ,KAYf,SAA4BA,GACxB,IAAKA,EAAMwJ,aAAc,CACrB,MAAM,MAAEpI,EAAK,OAAEC,EAAM,mBAAEoI,GAAuBzJ,EACxCwJ,EAAe,IAAaE,wBAAwB,CACtDC,WAAY3J,EAAM4J,eAClBxI,QACAC,SACAoI,uBAEJzJ,EAAMwJ,aAAeA,EACrBxJ,EAAM4J,aAAe,IAAMJ,EAAaK,uBACjC7J,EAAM8J,WAAWC,SAC5B,CACJ,CAxBQC,CAAmBhK,IACnB,OAAa,IAAa,IAAOiK,aAAc,CAAEjK,YAEhDkK,MAAOC,IACR,MAAMC,EAAe,CACjBzB,UACAwB,UAEJ,OAAa,IAAa,IAAOE,kBAAmBD,IAE5D,CAeO,SAASE,EAAU3B,EAASC,EAAU,CAAE2B,SAAU,EAAGC,YAAa,aACrE,QAAgBhI,IAAZmG,EACA,MAAM,IAAI/F,MAAM,sDAEpB,OAAO8F,EAAyBC,EAASC,GAASI,OACtD,CACO,SAASyB,EAAkB9B,EAASC,EAAU,CAAE2B,SAAU,EAAGC,YAAa,aAC7E,QAAgBhI,IAAZmG,EACA,MAAM,IAAI/F,MAAM,8DAEpB,MAAMuG,EAAkBT,EAAyBC,EAASC,GAI1D,OAHK,KAAME,mBAAmBH,IAC1B,KAAM+B,mBAAmB/B,EAASQ,GAE/BA,EAAgBH,OAC3B,CACO,SAAS2B,EAAmBC,EAAUhC,EAAU,CAAE2B,SAAU,EAAGC,YAAa,aAC/E,IAAKI,GAAgC,IAApBA,EAASxF,OACtB,MAAM,IAAIxC,MAAM,oEAKpB,OAHoBgI,EAASC,IAAKlC,GACvB8B,EAAkB9B,EAASC,GAG1C,CACO,SAASkC,EAA2BC,EAAmBnC,EAAU,CAAC,GACrE,QAA0BpG,IAAtBuI,EACA,MAAM,IAAInI,MAAM,4EAEIJ,IAApBoG,EAAQD,UACRC,EAAQD,QAAU,YAAW,YAEjC,MAAM,QAAEA,EAAO,iBAAEqC,EAAgB,WAAEC,EAAU,oBAAEC,GAAwBtC,EACjEuC,EAAmB,MAAa,mBAAoBJ,GACpD3F,EAAS+F,EAAiB1H,KAAO0H,EAAiB3H,SAClD,sBAAE4H,IAA0B,OAAuBxC,EAAQyC,cAAcC,KAAMlG,GAC/EmG,EAAkB,IAAIH,EAAsBJ,EAAmB,EAAI5F,GACnEoG,EAAiB7C,EACjB8C,EAA+B,MAAa,mBAAoBV,GACtE,IAAwBjD,IAAI0D,EAAgB,CACxCF,KAAM,mBACNI,SAAUD,IAEd,MAAME,EAAuC,MAAa,sBAAuBZ,GACjF,IAAwBjD,IAAI0D,EAAgB,CACxCF,KAAM,sBACNI,SAAUC,IAEd,IAAwB7D,IAAI0D,EAAgB,CACxCF,KAAM,qBACNI,SAAU,CACNE,eAAgBhD,EAAQgD,kBAGhC,MAAMC,EAAmB,MAAa,mBAAoBd,GAC1D,IAAwBjD,IAAI0D,EAAgB,CACxCF,KAAM,mBACNI,SAAU,IACHG,EACHC,cAAe,EACfC,WAAY,EACZC,QAAS,EACTC,gBAAiB,EACjBC,oBAAqB,KAG7B,MAAMC,EAAaC,EAAyBzD,EAAS,CACjDgB,WAAY4B,EACZN,aACAD,mBACAK,aAAc,CACVC,KAAMC,EAAgBtH,YAAYa,MAEtCoG,sBACAmB,WAAY,CAAClB,EAAiB3H,QAAS2H,EAAiB1H,MACxD6I,QAAS,CACLnB,EAAiBhJ,mBACjBgJ,EAAiBjJ,iBAErBqK,OAAQpB,EAAiBqB,qBACzBC,UAAWtB,EAAiBuB,wBAC5BC,oBAAqBxB,EAAiBwB,oBACtC5B,kBAAmBA,IAMvB,OAJAoB,EAAWpB,kBAAoBA,EAC1B,KAAMjC,mBAAmBH,IAC1B,KAAMiE,aAAajE,EAASwD,GAEzBA,CACX,CACO,SAASU,EAA4BC,EAAoBlE,EAAU,CAAC,GACvE,GAAkC,IAA9BkE,EAAmB1H,OACnB,MAAM,IAAIxC,MAAM,6EAEpB,MAAMmK,EAAkB,GAaxB,OAZeD,EAAmBjC,IAAI,CAACE,EAAmBiC,KACtD,MAAMC,EAAa,CACftE,QAASC,GAASsE,oBAAoBnC,IAClC,YAAW,cACZnC,GAGP,OADAmE,EAAgBI,KAAKF,EAAWtE,SACzBmC,EAA2BC,EAAmB,IAC9CkC,EACHrB,eAAgBoB,EAAQ,KAIpC,CACO,SAASZ,EAAyBzD,EAASC,GAC9C,MAAM,WAAEe,EAAU,OAAE4C,EAAM,UAAEE,EAAS,aAAEpB,EAAY,iBAAEL,EAAgB,WAAEC,EAAU,oBAAE0B,EAAmB,oBAAEzB,EAAmB,kBAAEH,GAAuBnC,EAC9IyD,EAAazD,EAAQyD,WACrBC,EAAU1D,EAAQ0D,QACxB,IAAKD,IAAeC,EAChB,MAAM,IAAI1J,MAAM,iEAEpB,MAAMxB,EAAQiL,EAAW,GACnBhL,EAASgL,EAAW,GACpBlK,EAAqBmK,EAAQ,GAC7BpK,EAAkBoK,EAAQ,GAC1BnB,EAAmB,CACrBwB,sBACAlJ,KAAMpC,EACNmC,QAASpC,EACTsL,wBAAyBD,GAAa,CAAC,EAAG,EAAG,EAAG,EAAG,EAAG,GACtDW,WAAYX,EAAYA,EAAUvH,MAAM,EAAG,GAAK,CAAC,EAAG,EAAG,GACvDmI,cAAeZ,EAAYA,EAAUvH,MAAM,EAAG,GAAK,CAAC,EAAG,EAAG,GAC1DsH,qBAAsBD,GAAU,CAAC,EAAG,EAAG,GACvCe,aAAc,CAACpL,EAAiBC,GAChCD,gBAAiBA,EACjBC,mBAAoBA,GAElBiD,EAAShE,EAAQC,EACjBoI,EAAqBE,EAAWvE,OAASA,EAC/C,IAAImI,EAeAzB,EAAeC,EAAYC,EAd/B,GAAIrC,EAAY,CACZ,KAAMA,aAAsB6D,YACxB7D,aAAsB8D,cACtB9D,aAAsB+D,aACtB/D,aAAsBgE,YACtB,MAAM,IAAI/K,MAAM,4GAEpB2K,EAAkB5D,CACtB,MACK,IAAKqB,EAAkB,CACxB,MAAM,sBAAEI,IAA0B,OAAuBC,GAAcC,KAAMlG,GAE7EmI,EADwB,IAAInC,EAAsBhG,EAEtD,CAEA,GAAImI,aAA2BC,WAC3B1B,EAAgB,EAChBC,EAAa,EACbC,EAAU,OAET,GAAIuB,aAA2BG,YAChC5B,EAAgB,GAChBC,EAAa,GACbC,EAAU,QAET,GAAIuB,aAA2BI,WAChC7B,EAAgB,GAChBC,EAAa,GACbC,EAAU,OAET,MAAIuB,aAA2BE,cAMhC,MAAM,IAAI7K,MAAM,+BALhBkJ,EAAgB,GAChBC,EAAa,GACbC,EAAU,EAId,CACA,MAAMH,EAAmB,CACrBI,gBAAiB,EACjB2B,0BAA2BL,EAAgBnI,OAASiH,EAAW,GAAKA,EAAW,GACzE,MACA,cACN5I,KAAMpC,EACNmC,QAASpC,EACT0K,gBACAC,aACAC,WAEEN,EAAW,CACbP,mBACAU,oBAEJ,CAAC,mBAAoB,oBAAoBpG,QAAS6F,IAC9C,IAAwBxD,IAAIa,EAAS,CACjC2C,OACAI,SAAUA,EAASJ,IAAS,CAAC,MAGrC,MAAMuC,EAAKlF,EACLa,EAAgB0B,IAAwB,IAAiB4C,KAC3D,IAAaC,2BAA2B,CAAE1B,aAAYwB,QACtD,IAAanE,wBAAwB,CACjCrI,SACAD,QACAqI,qBACAE,WAAY4D,EACZM,OAER,IAAIG,EAAgBT,EAAgB,GAChCU,EAAgBV,EAAgB,GACpC,IAAK,IAAIW,EAAI,EAAGA,EAAIX,EAAgBnI,OAAQ8I,IACpCX,EAAgBW,GAAKF,IACrBA,EAAgBT,EAAgBW,IAEhCX,EAAgBW,GAAKD,IACrBA,EAAgBV,EAAgBW,IAGxC,MAAMlO,EAAQ,CACV2I,QAASA,EACTwF,UAAW,EACXlL,aAAc,EACdD,YAAa,EACbpC,MAAsD,QAA/CiL,EAAiB+B,0BACxBnE,mBAAoBoC,EAAiBI,gBACrCmC,SAAU/C,GAAcC,KACxB+C,MAAO,EACPL,gBACAC,gBACAxK,KAAMoI,EAAiBpI,KACvBD,QAASqI,EAAiBrI,QAC1B8K,eAAW9L,EACXnB,OAAQwK,EAAiBpI,KACzBrC,MAAOyK,EAAiBrI,QACxB+K,UAAM/L,EACNL,mBAAoBgJ,EAAiBhJ,mBACrCD,gBAAiBiJ,EAAiBjJ,gBAClCsM,oBAAqBrD,EAAiBwB,oBACtCvJ,QAAQ,EACRwG,aAAc,IAAMJ,EAAaK,gBACjCL,eACAiF,YAAa9E,EAAW+E,WACxB3D,qBAIJ,OAFAE,IAAajL,GACb,KAAM4M,aAAa5M,EAAM2I,QAAS3I,GAC3BA,CACX,CACO,SAAS2O,EAAgBhG,GAO5B,IAAqBiG,eANE,EAAGC,wBAClBA,EAAkBlG,SACXkG,EAAkBlG,UAAYA,GAK7C,MAAMQ,EAAkB,KAAML,mBAAmBH,GAC7CQ,GACAA,EAAgB2F,UAExB,CACO,SAASC,EAAiBnE,GAC7BA,EAASnF,QAASkD,IACdgG,EAAgBhG,IAExB,CACO,SAASqG,IACZ,MAAMC,EAAc,IAAqBC,iBACzC9K,OAAO4B,KAAKiJ,GAAaxJ,QAAS6F,IAC9B,MAAM6D,EAAWF,EAAY3D,GAC7BlH,OAAO4B,KAAKmJ,GAAU1J,QAAS8E,IAC3B,MAAM6E,EAAiBD,EAAS5E,GAAU8E,MAC1C,IAAKD,EACD,OAEJ,MAAMP,EAAoBO,EAAeP,mBACnC,QAAElG,EAAO,SAAE2G,GAAaT,EAC9B,IAAIU,EACA5G,EACA4G,EAAa,KAAMzG,mBAAmBH,GAEjC2G,IACLC,EAAa,KAAMC,oBAAoBF,IAEvCC,GACAA,EAAWE,WAGnB,IAAqBC,kBAAkBpE,IAE/C,CACO,SAASqE,EAAoB1G,EAAQ2G,GACxCpH,EAAaS,GAAU2G,CAC3B,CACO,SAASC,EAA2BD,GACvC,MAAME,EAAiBrH,EAEvB,OADAA,EAAqBmH,EACdE,CACX,CACO,SAASC,IACZ3L,OAAO4B,KAAKwC,GAAc/C,QAASmK,UAAuBpH,EAAaoH,IACvEnH,OAAqBjG,CACzB,CACO,SAASwN,EAAoClD,EAAoBlE,EAAU,CAAC,GAC/E,OAAOiE,EAA4BC,EAAoB,IAChDlE,EACHyC,aAAc,CAAEC,KAAM,eAE9B,CACO,SAAS2E,EAAmClF,EAAmBnC,EAAU,CAAC,GAC7E,OAAOkC,EAA2BC,EAAmB,IAC9CnC,EACHyC,aAAc,CAAEC,KAAM,eAE9B,C,gDC9We,MAAM4E,SACR1L,KAAK2L,oBAAsB,yCAA2C,CAC/E,sBAAOC,CAAgBzH,GACnB,MAAM0H,EAAQ1H,EAAQ0H,MAAM7L,KAAK2L,qBACjC,IAAKE,IAAUA,EAAM,GACjB,OAAO,KAEX,MAAMC,EAAQD,EAAM,GAAGzJ,MAAM,KAAKiE,IAAK0F,GAAOC,OAAOD,IACrD,OAAqB,IAAjBD,EAAMlL,OACCkL,EAAM,GAEVA,CACX,CACA,wBAAOG,CAAkB9H,GACrB,MAAM2H,EAAQ9L,KAAK4L,gBAAgBzH,GACnC,OAAOzF,MAAMC,QAAQmN,GAASA,EAAM,GAAKA,CAC7C,CACA,0BAAOI,CAAoB/H,GACvB,MAAM2H,EAAQ9L,KAAK4L,gBAAgBzH,GACnC,OAAOzF,MAAMC,QAAQmN,GAASA,EAAM,GAAKA,CAC7C,CACA,qBAAOK,CAAeL,GAClB,OAAIpN,MAAMC,QAAQmN,GACP,GAAGA,EAAM,MAAMA,EAAM,KAEzBM,OAAON,EAClB,CACA,sBAAOO,CAAgBlI,EAAS2H,GAC5B,MAAMD,EAAQ1H,EAAQ0H,MAAM7L,KAAK2L,qBACjC,IAAKE,IAAUA,EAAM,GACjB,OAAO,KAEX,MAAMS,EAAiBtM,KAAKmM,eAAeL,GAC3C,OAAO3H,EAAQoI,QAAQvM,KAAK2L,oBAAqB,GAAGE,EAAM,KAAKS,IACnE,E,gDClCW,MAAME,EACjB,WAAA/M,CAAYgN,EAAgB,CAAC,GACzBzM,KAAK0M,YAAc,EACnB1M,KAAK2M,QAAU,EACf3M,KAAK4M,UAAY,EACjB5M,KAAK6M,SAAW,IAChB,MAAM,YAAEC,EAAc,KAAI,WAAEjF,EAAa,EAAC,SAAEgF,EAAW,KAASJ,EAC1DM,EAAaD,EAAcjF,EACjC7H,KAAK6M,SAAWA,EAChB7M,KAAKgN,MAAQ,IAAIC,YAAYF,EAAa/M,KAAK4M,WAC/C5M,KAAKkN,KAAO,IAAIjE,aAAajJ,KAAKgN,OAClChN,KAAK0M,YAAc7E,CACvB,CACA,OAAA5G,CAAQkM,GACJ,IAAK,IAAIzD,EAAI,EAAGA,EAAI1J,KAAK2M,QAASjD,IAC9ByD,EAAKnN,KAAKoN,SAAS1D,GAAIA,EAE/B,CACA,UAAI9I,GACA,OAAOZ,KAAK2M,OAChB,CACA,cAAI9E,GACA,OAAO7H,KAAK0M,WAChB,CACA,mBAAIW,GACA,OAAOrN,KAAK2M,QAAU3M,KAAK0M,WAC/B,CACA,QAAAU,CAAS5E,GAIL,GAHIA,EAAQ,IACRA,GAASxI,KAAK2M,SAEdnE,EAAQ,GAAKA,GAASxI,KAAK2M,QAC3B,OAEJ,MAAMW,EAAStN,KAAK0M,YAAclE,EAClC,OAAOxI,KAAKkN,KAAKK,SAASD,EAAQA,EAAStN,KAAK0M,YACpD,CACA,aAAAc,CAAchF,GACV,MAAMwE,EAAQ,GAId,GAHIxE,EAAQ,IACRA,GAASxI,KAAK2M,SAEdnE,EAAQ,GAAKA,GAASxI,KAAK2M,QAC3B,OAEJ,MAAMW,EAAStN,KAAK0M,YAAclE,EAClC,IAAK,IAAIkB,EAAI,EAAGA,EAAI1J,KAAK0M,YAAahD,IAClCsD,EAAMrE,KAAK3I,KAAKkN,KAAKxD,EAAI4D,IAE7B,OAAON,CACX,CACA,IAAAS,CAAKC,EAAiB,EAAGb,EAAW7M,KAAK6M,UACrC,GAAI7M,KAAKqN,gBAAkBK,EAAiB1N,KAAK0M,aAC7C1M,KAAKkN,KAAKtM,OACV,OAEJ,MAAM+M,EAAU3N,KAAKkN,KAAKtM,OAASiM,EAC7Be,EAAW,IAAIX,YAAYU,EAAU3N,KAAK0M,YAAc1M,KAAK4M,WAC7DiB,EAAU,IAAI5E,aAAa2E,GACjCC,EAAQ3N,IAAIF,KAAKkN,MACjBlN,KAAKkN,KAAOW,EACZ7N,KAAKgN,MAAQY,CACjB,CACA,OAAAE,GACI,MAAMC,EAAY9Q,KAAK+Q,MAAMhO,KAAK2M,QAAU,GAC5C,IAAK,IAAIjD,EAAI,EAAGA,EAAIqE,EAAWrE,IAAK,CAChC,MAAMuE,EAAavE,EAAI1J,KAAK0M,YACtBwB,GAAYlO,KAAK2M,QAAU,EAAIjD,GAAK1J,KAAK0M,YAC/C,IAAK,IAAIyB,EAAY,EAAGA,EAAYnO,KAAK0M,YAAayB,IAAa,CAC/D,MAAMC,EAAapO,KAAKkN,KAAKe,EAAaE,GAC1CnO,KAAKkN,KAAKe,EAAaE,GAAanO,KAAKkN,KAAKgB,EAAWC,GACzDnO,KAAKkN,KAAKgB,EAAWC,GAAaC,CACtC,CACJ,CACJ,CACA,aAAAC,GACI,OAAOrO,KAAKkN,IAChB,CACA,IAAAvE,CAAK2F,GACDtO,KAAKyN,KAAK,GACV,MAAMH,EAAStN,KAAKY,OAASZ,KAAK0M,YAClC,IAAK,IAAIhD,EAAI,EAAGA,EAAI1J,KAAK0M,YAAahD,IAClC1J,KAAKkN,KAAKxD,EAAI4D,GAAUgB,EAAM5E,GAElC1J,KAAK2M,SACT,CACA,GAAAtG,CAAIkI,GACA,MAAMC,EAAU,GAChB,IAAK,IAAI9E,EAAI,EAAGA,EAAI1J,KAAK2M,QAASjD,IAC9B8E,EAAQ7F,KAAK4F,EAAEvO,KAAKoN,SAAS1D,GAAIA,IAErC,OAAO8E,CACX,CACA,UAAIC,GACA,OAAOzO,KAAKqG,IAAKqI,GAAMA,EAC3B,CACA,KAAAC,GACI,MAAMC,EAAM,CAAEtR,EAAG,GAAIE,EAAG,IACpBwC,KAAK0M,aAAe,IACpBkC,EAAIC,EAAI,IAEZ,MAAM,EAAEvR,EAAC,EAAEE,EAAC,EAAEqR,GAAMD,EAQpB,OAPA5O,KAAKiB,QAASyN,IACVpR,EAAEqL,KAAK+F,EAAE,IACTlR,EAAEmL,KAAK+F,EAAE,IACLG,GACAA,EAAElG,KAAK+F,EAAE,MAGVE,CACX,CACA,cAAOE,EAAQ,EAAExR,EAAC,EAAEE,EAAC,EAAEqR,IACnB,MAAM7B,EAAQR,EAAcuC,QAAQzR,EAAEsD,QACtC,IAAI0M,EAAS,EACb,IAAK,IAAI5D,EAAI,EAAGA,EAAIpM,EAAEsD,OAAQ8I,IAC1BsD,EAAME,KAAKI,KAAYhQ,EAAEoM,GACzBsD,EAAME,KAAKI,KAAY9P,EAAEkM,GACzBsD,EAAME,KAAKI,KAAYuB,EAAIA,EAAEnF,GAAK,EAGtC,OADAsD,EAAML,QAAUrP,EAAEsD,OACXoM,CACX,CACA,SAAAgC,CAAUC,EAAQ,GAAI3B,EAAS,GAC3B,MAAM4B,EAAW,IAAI1C,EAAc,CAC/BM,YAAamC,EACbpH,WAAY7H,KAAK0M,cAErB,IAAK,IAAIhD,EAAI,EAAGA,EAAIuF,EAAOvF,IAAK,CAC5B,MAAMlB,GAAS8E,EAASrQ,KAAK+Q,MAAOhO,KAAKY,OAAS8I,EAAKuF,IAAUjP,KAAKY,OACtEsO,EAASvG,KAAK3I,KAAKoN,SAAS5E,GAChC,CACA,OAAO0G,CACX,CACA,cAAOH,CAAQjC,EAAc,IAAK2B,GAC9B3B,EAAc7P,KAAKkS,IAAIrC,EAAa2B,GAAQ7N,QAAU,GACtD,MAAMwO,EAAY,IAAI5C,EAAc,CAAEM,cAAajF,WAAY,IAI/D,OAHI4G,GACAA,EAAOxN,QAASqN,GAAUc,EAAUzG,KAAK2F,IAEtCc,CACX,CACA,cAAOC,CAAQvC,EAAc,KACzB,OAAO,IAAIN,EAAc,CAAEM,cAAajF,WAAY,GACxD,E,gDC7IW,MAAMyH,EACjB,WAAA7P,CAAYa,GACRN,KAAKM,KAAOA,GAAQ,SACxB,CACA,SAAOiP,CAAG/K,GACN,GAAIA,EAAQgL,SACR,OAAOhL,EAAQgL,SAEnB,MAAMA,EAAW,IAAIF,EAAoB,eAWzC,OAVA9K,EAAQO,KAAM0K,IACV,IACID,EAASlM,IAAImM,GAAG,EACpB,CACA,MAAOC,GACHF,EAASG,OAAOD,EACpB,GACAE,IACAJ,EAASG,OAAOC,KAEbJ,CACX,CACA,GAAAlM,CAAIhG,EAAGuS,GAAO,GACV7P,KAAK8P,UAAYxS,EACjB0C,KAAK6P,OAASA,EACV7P,KAAK+P,UACL/P,KAAK+P,QAAQjL,QAAQxH,GACrB0C,KAAK+P,aAAU/R,EAEvB,CACA,OAAA8G,GACI9E,KAAK6P,MAAO,EACR7P,KAAK+P,UACL/P,KAAK+P,QAAQjL,QAAQ9E,KAAK8P,WAC1B9P,KAAK+P,aAAU/R,EAEvB,CACA,MAAA2R,CAAOC,GACH5P,KAAKgQ,aAAeJ,EACpB5P,KAAK+P,SAASJ,OAAOC,EACzB,CACA,SAAAK,GACI,GAAIjQ,KAAKgQ,aACL,MAAMhQ,KAAKgQ,aAEf,OAAOhQ,KAAK8P,SAChB,CACA,OAAQ1Q,OAAO8Q,iBACX,MAAQlQ,KAAK6P,MAAM,CACf,GAAI7P,KAAKgQ,aACL,MAAMhQ,KAAKgQ,aAEf,QAAuBhS,IAAnBgC,KAAK8P,kBACC9P,KAAK8P,UACP9P,KAAK6P,MACL,MAGH7P,KAAK+P,UACN/P,KAAK+P,QAAU,CAAC,EAChB/P,KAAK+P,QAAQvL,QAAU,IAAIK,QAAQ,CAACC,EAAS6K,KACzC3P,KAAK+P,QAAQjL,QAAUA,EACvB9E,KAAK+P,QAAQJ,OAASA,WAGxB3P,KAAK+P,QAAQvL,OACvB,OACMxE,KAAK8P,SACf,CACA,aAAM7O,CAAQC,EAAUiP,GACpB,IAAI3H,EAAQ,EACZ,IACI,UAAW,MAAMvI,KAASD,KAAM,CAC5B,MAAM,KAAE6P,GAAS7P,KACjB,UACUkB,EAASjB,EAAO4P,EAAMrH,GAC5BA,GACJ,CACA,MAAOkH,GACH,IAAKG,EAAM,CACPO,QAAQC,KAAK,yCAA0CX,GACvD,QACJ,CACA,IAAIS,EAIA,MAAMT,EAHNS,EAAcT,EAAGG,EAKzB,CACJ,CACJ,CACA,MAAOH,GACH,IAAIS,EAIA,MAAMT,EAHNS,EAAcT,GAAG,EAKzB,CACJ,CACA,QAAAY,CAASC,EAAiBJ,GACtB,OAAOI,EAAgBvQ,KAAMA,KAAK2P,OAAOa,KAAKxQ,OAAO+E,KAAK,KACjD/E,KAAK6P,MACN7P,KAAK8E,WAET8K,IACA5P,KAAK2P,OAAOC,GACRO,EACAA,EAAcP,GAGdQ,QAAQC,KAAK,2BAA4BT,IAGrD,CACA,iBAAMa,GACF,UAAW,MAAM/G,KAAK1J,KAClB,GAAI0J,EACA,OAAOA,EAGf,OAAO1J,KAAK8P,SAChB,CACA,iBAAMY,GACF,UAAW,MAAMhH,KAAK1J,MAEtB,OAAOA,KAAK8P,SAChB,CACA,cAAAa,GACI,MAAMnM,EAAUxE,KAAKyQ,cAErB,OADAjM,EAAQgL,SAAWxP,KACZwE,CACX,CACA,cAAAoM,GACI,MAAMpM,EAAUxE,KAAK0Q,cAErB,OADAlM,EAAQgL,SAAWxP,KACZwE,CACX,E,gDC3IJ,MAAMqM,EAAe,CACjB,CAAC,GAAI,EAAG,GACR,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,GAAI,GACR,CAAC,EAAG,EAAG,IAELC,EAAwB,CAC1B,CAAC,GAAI,EAAG,GACR,CAAC,EAAG,EAAG,IAELC,EAAc,CAChB,CAAC,GAAI,EAAG,GACR,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,GAAI,IAENC,EAAe,CACjB,CAAC,GAAI,EAAG,GACR,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IAEI,MAAMC,EACjB,cAAOC,CAAQC,EAAaC,GACxB,IAAK,MAAO5I,EAAO6I,KAAQD,EAAOnS,KAC9BkS,EAAYlS,KAAKiB,IAAIsI,EAAO8I,gBAAgBD,GAEpD,CACA,WAAA5R,CAAY7C,EAAOC,EAAQ0U,EAAQ,GAC/BvR,KAAKf,KAAO,IAAIuS,IAChBxR,KAAKnD,OAAS,EACdmD,KAAKpD,MAAQ,EACboD,KAAKuR,MAAQ,EACbvR,KAAKyR,UAAY,EACjBzR,KAAK0R,UAAY,EACjB1R,KAAK2R,SAAW,EAChB3R,KAAK4R,qBAAuB5I,WAC5BhJ,KAAK6R,iBAAmB,SAAU1M,GAC9BA,EAAW2M,KAAK,GAOhB9R,KAAKiB,QANY,CAACuH,EAAOuJ,EAAKV,KAC1B,MAAM,MAAE3V,EAAK,IAAEsW,EAAG,MAAE/R,GAAU8R,EAC9B,IAAK,IAAIrI,EAAIhO,EAAOgO,EAAIsI,EAAKtI,IACzBvE,EAAWqD,EAAQkB,GAAKzJ,GAIpC,EACAD,KAAKI,IAAOoI,IACR,MAAMkB,EAAIlB,EAAQxI,KAAKyR,UACjBQ,GAAKzJ,EAAQkB,GAAK1J,KAAKyR,UACvBM,EAAM/R,KAAKkS,OAAOxI,EAAGuI,GAC3B,OAAOF,GAAK9R,OAASD,KAAKmS,cAE9BnS,KAAKoS,OAAS,CAACH,EAAGI,KACd,MAAMC,EAAWL,EAAII,EAAIrS,KAAKnD,OAC9B,OAAOmD,KAAKf,KAAKmB,IAAIkS,IAEzBtS,KAAKE,IAAM,CAACsI,EAAOvI,KACf,QAAcjC,IAAViC,EACA,OAEJ,MAAMyJ,EAAIlB,EAAQxI,KAAKpD,MACjBqV,GAAKzJ,EAAQkB,GAAK1J,KAAKpD,MACvByU,EAAMrR,KAAKf,KAAKmB,IAAI6R,GAC1B,IAAKZ,EAED,YADArR,KAAKf,KAAKiB,IAAI+R,EAAG,CAAC,CAAEvW,MAAOgO,EAAGsI,IAAKtI,EAAI,EAAGzJ,WAG9C,MAAMsS,EAAWvS,KAAKwS,UAAUnB,EAAK3H,GAC/B+I,EAAOpB,EAAIkB,GACXG,EAAOrB,EAAIkB,EAAW,GAC5B,IAAKE,EACD,OAAKC,GAAQA,EAAKzS,QAAUA,GAASyS,EAAKV,MAAQtI,OAIlDgJ,EAAKV,WAHDX,EAAIkB,GAAY,CAAE7W,MAAOgO,EAAGsI,IAAKtI,EAAI,EAAGzJ,UAMhD,MAAM,MAAEvE,EAAK,IAAEsW,EAAK/R,MAAO0S,GAAaF,EACxC,GAAIxS,IAAU0S,GAAYjJ,GAAKhO,EAC3B,OAEJ,MAAMkX,EAAY,CAAElX,MAAOgO,EAAGsI,IAAKtI,EAAI,EAAGzJ,SACpC4S,EAAUnJ,EAAIhO,EACdoX,EAAcD,EAAUN,EAAW,EAAIA,EACvCQ,EAAUF,EAAUJ,EAAOC,EACjC,IAAIM,EAAUH,EAAUxB,EAAIkB,EAAW,GAAKE,EAC5C,GAAIM,GAAS9S,QAAUA,GAAS8S,GAASf,MAAQtI,EAiB7C,OAhBAqJ,EAAQf,WACJgB,GAAS/S,QAAUA,GAAS+S,EAAQtX,QAAUgO,EAAI,GAClDqJ,EAAQf,IAAMgB,EAAQhB,IACtBX,EAAI4B,OAAOV,EAAU,IAEhBS,GAAStX,QAAUgO,IACxBsJ,EAAQtX,QACJsX,EAAQtX,QAAUsX,EAAQhB,MAC1BX,EAAI4B,OAAOV,EAAU,GACrBS,EAAU3B,EAAIkB,GACVS,GAAStX,QAAUgO,EAAI,GAAKsJ,EAAQ/S,QAAUA,IAC9C8S,EAAQf,IAAMgB,EAAQhB,IACtBX,EAAI4B,OAAOV,EAAU,OAMrC,GAAIS,GAAS/S,QAAUA,GAAS+S,EAAQtX,QAAUgO,EAAI,EAQlD,OAPAsJ,EAAQtX,aACJqX,GAASf,IAAMtI,IACfqJ,EAAQf,IAAMtI,EACVqJ,EAAQf,MAAQe,EAAQrX,OACxB2V,EAAI4B,OAAOV,EAAU,KAKjC,GAAIS,GAAStX,QAAUgO,GAAKsJ,EAAQhB,MAAQtI,EAAI,EAAG,CAC/CsJ,EAAQ/S,MAAQA,EAChB,MAAMiT,EAAW7B,EAAIkB,EAAW,GAKhC,YAJIW,GAAUxX,OAASgO,EAAI,GAAKwJ,EAASjT,QAAUA,IAC/CoR,EAAI4B,OAAOV,EAAW,EAAG,GACzBS,EAAQhB,IAAMkB,EAASlB,KAG/B,CACItI,IAAMsJ,GAAStX,OACfsX,EAAQtX,QAERmX,GAAWb,EAAMtI,EAAI,EACrB2H,EAAI4B,OAAOH,EAAa,EAAGF,EAAW,CAClClX,MAAOgO,EAAI,EACXsI,IAAKe,EAAQf,IACb/R,MAAO8S,EAAQ9S,QAInBoR,EAAI4B,OAAOH,EAAa,EAAGF,GAE3BG,GAASf,IAAMtI,IACfqJ,EAAQf,IAAMtI,IAGtB1J,KAAKpD,MAAQA,EACboD,KAAKnD,OAASA,EACdmD,KAAKuR,MAAQA,EACbvR,KAAKyR,UAAY7U,EACjBoD,KAAK0R,UAAY1R,KAAKyR,UAAY5U,CACtC,QACSmD,KAAKqF,cAAgB,SAAU8N,EAAYC,mBAChD,MAAMjO,EAAa,IAAIgO,EAAUnT,KAAKqT,WAEtC,OADArT,KAAKqG,IAAIwL,iBAAiB1M,GACnBA,CACX,CAAG,CACH,KAAAmO,CAAM9K,GACF,MAAMkB,EAAIlB,EAAQxI,KAAKyR,UAGvB,MAAO,CAAC/H,GAFIlB,EAAQkB,GAAK1J,KAAKyR,UAAazR,KAAKnD,OACtCI,KAAK+Q,MAAMxF,EAAQxI,KAAK0R,WAEtC,CACA,OAAA6B,EAAS7J,EAAGuI,EAAGI,IACX,OAAO3I,EAAI2I,EAAIrS,KAAK0R,UAAYO,EAAIjS,KAAKyR,SAC7C,CACA,MAAAS,CAAOxI,EAAGuI,EAAGI,EAAI,GACb,MAAMhB,EAAMrR,KAAKf,KAAKmB,IAAI6R,EAAII,EAAIrS,KAAKnD,QACvC,IAAKwU,EACD,OAEJ,MACMU,EAAMV,EADErR,KAAKwS,UAAUnB,EAAK3H,IAElC,OAAOA,GAAKqI,GAAKrW,MAAQqW,OAAM/T,CACnC,CACA,GAAAqF,CAAImF,GACA,MAAMkB,EAAIlB,EAAQxI,KAAKyR,UACjBQ,GAAKzJ,EAAQkB,GAAK1J,KAAKyR,UACvBM,EAAM/R,KAAKkS,OAAOxI,EAAGuI,GAC3B,YAAsBjU,IAAf+T,GAAK9R,KAChB,CACA,OAAOuI,GACH,MAAMkB,EAAIlB,EAAQxI,KAAKpD,MACjBqV,GAAKzJ,EAAQkB,GAAK1J,KAAKpD,MACvByU,EAAMrR,KAAKf,KAAKmB,IAAI6R,GAC1B,IAAKZ,EACD,OAEJ,MAAMkB,EAAWvS,KAAKwS,UAAUnB,EAAK3H,GAC/BqI,EAAMV,EAAIkB,GAChB,IAAKR,GAAOA,EAAIrW,MAAQgO,EACpB,OAEJ,GAAIqI,EAAIC,MAAQtI,EAAI,EAQhB,OAPAqI,EAAIC,WACAD,EAAIrW,OAASqW,EAAIC,MACjBX,EAAI4B,OAAOV,EAAU,GAChBlB,EAAIzQ,QACLZ,KAAKf,KAAKuE,OAAOyO,KAK7B,GAAIF,EAAIrW,QAAUgO,EAEd,YADAqI,EAAIrW,QAGR,MAAM8X,EAAS,CACXvT,MAAO8R,EAAI9R,MACXvE,MAAOgO,EAAI,EACXsI,IAAKD,EAAIC,KAEbD,EAAIC,IAAMtI,EACV2H,EAAI4B,OAAOV,EAAW,EAAG,EAAGiB,EAChC,CACA,SAAAhB,CAAUnB,EAAK3H,GACX,IAAK,IAAIlB,EAAQ,EAAGA,EAAQ6I,EAAIzQ,OAAQ4H,IAAS,CAC7C,MAAQwJ,IAAKyB,GAASpC,EAAI7I,GAC1B,GAAIkB,EAAI+J,EACJ,OAAOjL,CAEf,CACA,OAAO6I,EAAIzQ,MACf,CACA,OAAAK,CAAQC,EAAUkD,GACd,MAAMsP,EAActP,GAASsP,YAC7B,IAAK,MAAOC,EAAWtC,KAAQrR,KAAKf,KAAM,CACtC,MAAM2U,EAAWF,EAAc,IAAIrC,GAAOA,EAC1C,IAAK,MAAMU,KAAO6B,EACd1S,EAASyS,EAAY3T,KAAKpD,MAAOmV,EAAKV,EAE9C,CACJ,CACA,UAAAwC,CAAW3S,GACP,IAAK,MAAOyS,EAAWtC,KAAQrR,KAAKf,KAChCiC,EAASyS,EAAY3T,KAAKpD,MAAOyU,EAEzC,CACA,KAAAyC,GACI9T,KAAKf,KAAK6U,OACd,CACA,IAAAtS,GACI,MAAO,IAAIxB,KAAKf,KAAKuC,OACzB,CACA,YAAA4D,CAAaiN,EAAI,EAAG9M,GACXA,EAIDA,EAAUuM,KAAK,GAHfvM,EAAY,IAAIvF,KAAK4R,qBAAqB5R,KAAKpD,MAAQoD,KAAKnD,OAASmD,KAAK2R,UAK9E,MAAM,MAAE/U,EAAK,OAAEC,EAAM,SAAE8U,GAAa3R,KACpC,IAAK,IAAIiS,EAAI,EAAGA,EAAIpV,EAAQoV,IAAK,CAC7B,MAAMZ,EAAMrR,KAAKoS,OAAOH,EAAGI,GAC3B,GAAKhB,EAGL,GAAiB,IAAbM,EACA,IAAK,MAAMI,KAAOV,EAAK,CACnB,MAAM0C,EAAY9B,EAAIrV,GAChB,MAAElB,EAAK,IAAEsW,EAAG,MAAE/R,GAAU8R,EAC9B,IAAK,IAAIrI,EAAIhO,EAAOgO,EAAIsI,EAAKtI,IACzBnE,EAAUwO,EAAYrK,GAAKzJ,CAEnC,MAGA,IAAK,MAAM8R,KAAOV,EAAK,CACnB,MAAM0C,EAAY9B,EAAIrV,EAAQ+U,GACxB,MAAEjW,EAAK,IAAEsW,EAAG,MAAE/R,GAAU8R,EAC9B,IAAK,IAAIrI,EAAIhO,EAAOgO,EAAIsI,EAAKtI,GAAKiI,EAC9B,IAAK,IAAIqC,EAAO,EAAGA,EAAOrC,EAAUqC,IAChCzO,EAAUwO,EAAYrK,EAAIsK,GAAQ/T,EAAM+T,EAGpD,CAER,CACA,OAAOzO,CACX,CACA,SAAA0O,CAAUvK,EAAGuI,EAAGI,EAAGpS,EAAOmE,GACtB,MAAM2N,EAAM/R,KAAKkS,OAAOxI,EAAGuI,EAAGI,GAC9B,IAAKN,EACD,MAAM,IAAI3T,MAAM,iBAAiBsL,KAAKuI,KAAKI,sBAE/C,MAAM6B,EAAQ,CAAC,CAACnC,EAAKE,EAAGI,IAClB8B,EAAepC,EAAI9R,MACzB,GAAIkU,IAAiBlU,EACjB,MAAM,IAAI7B,MAAM,WAAW+V,uBAAkClU,oBAEjE,OAAOD,KAAKoU,MAAMF,EAAOC,EAAclU,EAAOmE,EAClD,CACA,KAAAgQ,CAAMF,EAAOG,EAAapU,EAAOmE,GAC7B,IAAIkQ,EAAM,EACV,MAAM,OAAEC,GAAS,EAAI,UAAEC,GAAY,EAAI,YAAEC,GAAc,GAAWrQ,GAAW,CAAC,EACxEsQ,EAAe,CAAEH,SAAQC,YAAWC,eAC1C,KAAOP,EAAMtT,QAAQ,CACjB,MAAM+T,EAAMT,EAAMrJ,OACX/H,GAAW6R,EAClB,GAAI7R,EAAQ7C,QAAUoU,EAClB,SAEJvR,EAAQ7C,MAAQA,EAChBqU,GAAOxR,EAAQkP,IAAMlP,EAAQpH,MAC7B,MAAMkZ,EAAY5U,KAAK6U,cAAcF,EAAKD,GAAcI,OAAQC,GAAaA,GAAYA,EAAS,GAAG9U,QAAUoU,GAC/GH,EAAMvL,QAAQiM,EAClB,CACA,OAAON,CACX,CACA,QAAAU,CAASC,EAAQC,GACb,IAAK,IAAI7C,EAAI6C,EAAU,GAAG,GAAI7C,GAAK6C,EAAU,GAAG,GAAI7C,IAChD,IAAK,IAAIJ,EAAIiD,EAAU,GAAG,GAAIjD,GAAKiD,EAAU,GAAG,GAAIjD,IAAK,CACrD,IAAIF,EACAV,EACJ,IAAK,IAAI3H,EAAIwL,EAAU,GAAG,GAAIxL,GAAKwL,EAAU,GAAG,GAAIxL,IAAK,CACrD,MAAMzJ,EAAQgV,EAAOvL,EAAGuI,EAAGI,QACbrU,IAAViC,GAICoR,IACDA,EAAM,GACNrR,KAAKf,KAAKiB,IAAI+R,EAAII,EAAIrS,KAAKnD,OAAQwU,IAEnCU,GAAOA,EAAI9R,QAAUA,IACrB8R,OAAM/T,GAEL+T,IACDA,EAAM,CAAErW,MAAOgO,EAAGsI,IAAKtI,EAAGzJ,SAC1BoR,EAAI1I,KAAKoJ,IAEbA,EAAIC,OAdAD,OAAM/T,CAed,CACJ,CAER,CACA,aAAA6W,CAAcM,GAAM,UAAEX,GAAY,EAAI,OAAED,GAAS,EAAI,YAAEE,GAAc,IACjE,MAAO1C,EAAKE,EAAGI,EAAG+C,GAAkBD,GAC9B,MAAEzZ,EAAK,IAAEsW,GAAQD,EACjBsD,EAAU3Z,EAAQ,GAAKsE,KAAKkS,OAAOxW,EAAQ,EAAGuW,EAAGI,GACjDiD,EAAWtD,EAAMhS,KAAKpD,OAASoD,KAAKkS,OAAOF,EAAKC,EAAGI,GACnDvG,EAAQ0I,EACR,CAAC9Y,EAAQ,EAAIA,EAAQ,EAAIA,EAAOsW,EAAMhS,KAAKpD,MAAQoV,EAAM,EAAIA,GAC7D,CAACtW,EAAOsW,GACR4C,EAAY,GACdS,GACAT,EAAUjM,KAAK,CAAC0M,EAASpD,EAAGI,IAE5BiD,GACAV,EAAUjM,KAAK,CAAC2M,EAAUrD,EAAGI,IAEjC,IAAK,MAAMkD,KAASH,IACfX,EAAc3D,EAAwBD,GAAe,CACtD,MAAO,CAAE2E,EAAQC,GAAUF,EACrBG,EAAQF,EAASvD,EACjB0D,EAAQF,EAASpD,EACvB,GAAIqD,EAAQ,GAAKA,GAAS1V,KAAKnD,OAC3B,SAEJ,GAAI8Y,EAAQ,GAAKA,GAAS3V,KAAKuR,MAC3B,SAEJ,MAAMF,EAAMrR,KAAKoS,OAAOsD,EAAOC,GAC/B,GAAKtE,EAGL,IAAK,MAAMuE,KAAWvE,EAAK,CACvB,MAAMwE,EAAmBT,GACpBX,GAAe3D,GACfyD,GAAUkB,EAAS,GAAKzE,GACxBuD,GAAUkB,EAAS,GAAK1E,GACzBF,EACE+E,EAAQ5D,KAAOlG,EAAM,IAAM8J,EAAQla,OAASoQ,EAAM,IACpD8I,EAAUjM,KAAK,CAACiN,EAASF,EAAOC,EAAOE,GAE/C,CACJ,CACA,OAAOjB,CACX,E,+BCrXG,SAASkB,EAAaC,GACzB,OAAQC,EAASD,EAAY,cAAgBC,EAASD,EAAY,gBACtE,CACO,SAASC,EAASD,EAAYE,GACjC,MAAMC,EAAe,QAASH,EAAaA,EAAaA,EAAWI,MACnE,QAAKD,KAGIA,EAAaE,IAAIH,EAC9B,C,gGCPe,SAASI,EAAYF,EAAOG,GACvC,MAAMC,EAAqBD,EAAOE,cAC7BpU,MAAM,KACN6Q,OAAO,GACP5M,IAAIoQ,aACH,WAAEC,GAiDZ,SAAuBH,GACnB,IAAIzY,EAAM6Y,IACNxH,GAAOwH,IACX,IAAK,IAAIjN,EAAI,EAAGA,EAAI6M,EAAmB3V,OAAQ8I,GAAK,EAChD5L,EAAMb,KAAKa,IAAIA,EAAKyY,EAAmB7M,IACvCyF,EAAMlS,KAAKkS,IAAIA,EAAKoH,EAAmB7M,IAE3C,MAAMkN,GAAUzH,EAAMrR,GAAO,EAC7B,MAAO,CACH4Y,WAAY,EAAEE,EAAQA,GACtB9Y,MACAqR,MAER,CA9D2B0H,CAAcN,GAC/BzY,EAAM4Y,EAAW,GACjB9Z,EAAQ8Z,EAAW,GAAKA,EAAW,GACnCI,EAAO,mBACPC,EAA+B,GACrC,IAAK,IAAIrN,EAAI,EAAGA,EAAI6M,EAAmB3V,OAAQ8I,GAAK,EAAG,CACnD,IAAIzJ,EAAQsW,EAAmB7M,GAC/B,MAAMsN,EAAIT,EAAmB7M,EAAI,GAC3BuN,EAAIV,EAAmB7M,EAAI,GAC3BwN,EAAIX,EAAmB7M,EAAI,GACjCzJ,GAASA,EAAQnC,GAAOlB,EACxBma,EAA6BpO,KAAK,CAAC1I,EAAO+W,EAAGC,EAAGC,GACpD,EAmDJ,SAAkCzI,EAAQ3C,EAAOgL,GAC7C,MAAMla,EAAQkP,EAAM,GAAKA,EAAM,GACzBqL,EAAW1I,EAAOpI,IAAI,EAAE/I,EAAG0Z,EAAGC,EAAGC,KAAO,CAC1C5Z,EAAIV,EAAQkP,EAAM,GAClBkL,EACAC,EACAC,IAEJJ,EAAKM,kBACLD,EAASlW,QAAQ,EAAE3D,EAAG0Z,EAAGC,EAAGC,KAAOJ,EAAKO,YAAY/Z,EAAG0Z,EAAGC,EAAGC,GAEjE,CA7DII,CAAyBP,EAA8BL,EAAYI,GACnEX,EAAMoB,cAAcC,uBAAuB,EAAGV,GAC9C,MAAMW,EAAqBnB,EAAOoB,cAC7BtV,MAAM,KACN6Q,OAAO,GACP5M,IAAIoQ,YACHkB,EAAO,mBACPC,EAAa,GACnB,IAAK,IAAIlO,EAAI,EAAGA,EAAI+N,EAAmB7W,OAAQ8I,GAAK,EAAG,CACnD,IAAIzJ,EAAQwX,EAAmB/N,GAC/B,MAAMmO,EAAUJ,EAAmB/N,EAAI,GACvCzJ,GAASA,EAAQnC,GAAOlB,EACxBgb,EAAWjP,KAAK,CAAC1I,EAAO4X,GAC5B,EAiDJ,SAAwCpJ,EAAQ3C,EAAOgM,GACnD,MAAMlb,EAAQkP,EAAM,GAAKA,EAAM,GACzBqL,EAAW1I,EAAOpI,IAAI,EAAE/I,EAAGE,KAAO,CAACF,EAAIV,EAAQkP,EAAM,GAAItO,IAC/Dsa,EAAIV,kBACJD,EAASlW,QAAQ,EAAE3D,EAAGE,KAAOsa,EAAIC,SAASza,EAAGE,GAEjD,CAtDIwa,CAA+BJ,EAAYlB,EAAYiB,GACvD,MAAMM,EAAW9B,EAAMoB,cACvBU,EAASC,iBAAiB,EAAGP,GAC7B,MAAOQ,EAAkBC,EAAoBC,EAAkBC,GAAuBhC,EAAOiC,gBAAgBnW,MAAM,KAAK6Q,OAAO,GAAG5M,IAAIoQ,YACtIwB,EAASO,sBAAsB,GAAG,GAClCP,EAASQ,+BAA+B,EAAGN,GAC3CF,EAASS,iCAAiC,EAAGN,GAC7CH,EAASU,+BAA+B,EAAGN,GAC3CJ,EAASW,iCAAiC,EAAGN,GAChB,MAAzBhC,EAAOuC,eACPZ,EAASa,mCAEbb,EAASc,SAA0B,MAAjBzC,EAAO0C,OACzB,MAAMC,EAAUxC,WAAWH,EAAO2C,SAC5BC,EAAUzC,WAAWH,EAAO4C,SAC5BC,EAAW1C,WAAWH,EAAO6C,UAC7BC,EAAgB3C,WAAWH,EAAO8C,eACxCnB,EAASoB,WAAWJ,GACpBhB,EAASqB,WAAWJ,GACpBjB,EAASsB,YAAYJ,GACrBlB,EAASuB,iBAAiBJ,EAC9B,C,0EC5BA,QAzBkBtO,IACd,MAAM2O,EAUV,SAAwD3O,GACpD,MAAM4O,GAAwB,UACxBD,EAAgC,GAUtC,OATAC,EAAsBzY,QAAS0Y,IAC3B,MAAMC,GAAY,OAAyB9O,GACvC8O,EAAUhZ,QACV6Y,EAA8B9Q,KAAK,CAC/BgR,kBACAE,YAAaD,EAAUvT,IAAKnK,GAAaA,EAASmN,QAIvDoQ,CACX,CAvB0CK,CAA+ChP,GAChF2O,GAA+B7Y,QAGpC6Y,EAA8BxY,QAAQ,EAAG0Y,kBAAiBE,kBACjDF,EAAgBI,kBACjBJ,EAAgBK,gBAAgBH,K,oFCDrC,SAASI,EAAoB9V,GAChC,MACM+V,EAAsB,IADH,MAAa,EAAAC,gBAAgBC,YAAajW,IAwBnE,OApBK+V,EAAoBvc,qBACrBuc,EAAoBvc,mBAAqB,GAExCuc,EAAoBxc,kBACrBwc,EAAoBxc,gBAAkB,GAErCwc,EAAoBrR,gBACrBqR,EAAoBrR,cAAgB,CAAC,EAAG,EAAG,IAE1CqR,EAAoBtR,aACrBsR,EAAoBtR,WAAa,CAAC,EAAG,EAAG,IAEvCsR,EAAoBlS,uBACrBkS,EAAoBlS,qBAAuB,CAAC,EAAG,EAAG,IAEjDkS,EAAoBhS,0BACrBgS,EAAoBhS,wBAA0B,IAAIe,aAAa,CAC3D,EAAG,EAAG,EAAG,EAAG,EAAG,KAGhBiR,CACX,CAmBO,SAASG,EAAc7e,GAC1B,MAAM2I,EAAU3I,EAAM2I,SAChB,oBAAEuD,EAAmB,cAAEJ,EAAa,WAAEC,EAAU,QAAEC,EAAO,0BAAE4B,EAAyB,gBAAE3B,GAAqB,MAAa,mBAAoBtD,IAC5I,YAAE3F,EAAW,aAAEC,EAAY,eAAE6b,GAAmB9e,GAChD,SAAE2C,GAAa,MAAa,sBAAuBgG,GACnDoW,EAAuB,MAAa,gBAAiBpW,GACrDqW,EAAc,MAAa,EAAAL,gBAAgBM,YAAatW,GACxDuW,EA1DH,SAAgCJ,GACnC,OAAK1a,OAAO+a,OAAO,EAAAC,oBAAoBC,SAASP,GAGzCA,EAFI,EAAAM,mBAAmBE,MAGlC,CAqD+BC,CAAuBT,GAElD,MAAO,CACHE,cACAQ,cAAeT,EACfD,eAAgBI,EAChBvc,WACAwI,iBANqBsT,EAAoB9V,GAOzCkD,iBAAkB,CACdC,gBACAC,aACAE,kBACAD,UACA4B,4BACA1B,sBACAlJ,YAAaA,EACbC,aAAcA,EACdN,WACAmc,eAAgBI,GAG5B,C,oFC9Ee,SAASO,EAAgC7U,GACpD,MAAQ4B,qBAAsBkT,EAA6B,wBAAEhT,GAA6B,MAAa,mBAAoB9B,EAAS,IAC9H+U,EAAe,gBAAgBjT,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IAC/GkT,EAAe,gBAAgBlT,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IAC/GmT,EAAiB,cACvB,WAAWA,EAAgBF,EAAcC,GACzC,MAAME,EAAY,gBAAgBJ,EAA8B,GAAIA,EAA8B,GAAIA,EAA8B,IAEpI,IAAIpT,EACJ,SAASyT,EAAYpX,GACjB,MAAM,qBAAE6D,GAAyB,MAAa,mBAAoB7D,GAC5DqX,EAAiB,cACjBC,EAAS,gBAAgBzT,EAAqB,GAAIA,EAAqB,GAAIA,EAAqB,IAEtG,OADA,SAASwT,EAAgBF,EAAWG,GAC7B,SAASD,EAAgBH,EACpC,CACA,GATmD,YAA9BjV,EAAS,GAAGhE,MAAM,KAAK,GAwBvC,CACD,MAAMsZ,EAAqB,CACvBtV,EAAS,GACTA,EAASnJ,KAAK+Q,MAAM5H,EAASxF,OAAS,KAIpC+a,GAFqBJ,EAAYG,EAAmB,IAC9BH,EAAYG,EAAmB,IAC5B,MAAa,mBAAoBA,EAAmB,KACnF,IAAKC,EACD,MAAM,IAAIvd,MAAM,yDAEpB,MAAMod,EAAiB,cACjBI,EAAe,gBAAgBD,EAAuB3T,qBAAqB,GAAI2T,EAAuB3T,qBAAqB,GAAI2T,EAAuB3T,qBAAqB,IACjL,SAASwT,EAAgBF,EAAWM,GACpC,MAAMC,EAAsC,SAASL,EAAgBH,GACrEvT,EACI7K,KAAK6e,IAAID,GACL5e,KAAK+Q,MAAM5H,EAASxF,OAAS,EACzC,KAjCmB,CACf,MAAMmb,EAAqB3V,EAASC,IAAKlC,IAE9B,CACH6X,SAFaT,EAAYpX,GAGzBA,aAGR4X,EAAmBE,KAAK,CAACC,EAAGhF,IAAMA,EAAE8E,SAAWE,EAAEF,UACjD,MAAMG,EAAYJ,EAAmBnb,OACrCkH,EACI7K,KAAK6e,IAAIC,EAAmBI,EAAY,GAAGH,SACvCD,EAAmB,GAAGC,WACrBG,EAAY,EACzB,CAoBA,MAAM,eAAEC,EAAc,qBAAEC,GAAyB,MAAa,mBAAoBjW,EAAS,KACrF,gCAAEkW,IAAoC,UAAmBC,UAe/D,OAdiB,IAAZzU,IAAiB0U,MAAM1U,IAAcwU,IAClCD,GACAjM,QAAQqM,MAAM,2DACd3U,EAAUuU,GAELD,GACLhM,QAAQqM,MAAM,iFACd3U,EAAUsU,IAGVhM,QAAQqM,MAAM,gHACd3U,EAAU,IAGXA,CACX,C,+BCtEA,SAAS4U,EAAMzc,EAAOnC,EAAKqR,GACvB,OAAOlS,KAAKkS,IAAIrR,EAAKb,KAAKa,IAAIqR,EAAKlP,GACvC,C,+VCGA,MAAM0c,EAAa,IAAInL,IACvB,SAASoL,EAAiBzgB,GACtBA,EAASmE,KAAOnE,EAASmE,MAAQnE,EAAS0gB,KAC1CF,EAAWzc,IAAI/D,EAASmE,KAAMnE,EAClC,CACA,SAAS2gB,EAAYxc,GACjB,OAAOqc,EAAWvc,IAAIE,EAC1B,CACA,SAASyc,IACL,OAAOre,MAAM6D,KAAKoa,EAAWnb,OACjC,CACA,SAASwb,EAAqBC,EAAW9G,GACrC,MAAM+G,EAAe,IAAaC,eAAe9W,IAAK+W,GAAe,IAAaC,gBAAgBD,IAC5FE,EAAgBP,IAAmB1W,IAAKkX,GAAiBT,EAAYS,IAErEC,EADYN,EAAaO,OAAOH,GACJI,KAAMvhB,IACpC,MAAQwhB,UAAWC,GAAoBzhB,EACvC,GAAIyhB,EAAgBhd,SAAWqc,EAAUrc,OACrC,OAAO,EAEX,IAAK,IAAI8I,EAAI,EAAGA,EAAIkU,EAAgBhd,OAAQ8I,GAAK,EAC7C,KAAK,QAAQkU,EAAgBld,MAAMgJ,EAAI,EAAGA,EAAI,GAAIuT,EAAUvc,MAAMgJ,EAAI,EAAGA,EAAI,IACzE,OAAO,EAGf,OAAO,IAEX,IAAK8T,EACD,OAAO,KAEX,MAAM3F,EAAU,GAChB,IAAI,OAAS1B,EAAO,aAAc,CAC9B,MAAM0H,EAAgB1H,EACjBoB,cACAuG,iBAAiB,GACjBC,iBACL,IAAKF,EACD,MAAO,CACHvd,KAAMkd,EAAgBX,MAG9B,IAAK,IAAInT,EAAI,EAAGA,EAAImU,EAAcjd,OAAQ8I,GAAK,EAC3CmO,EAAQlP,KAAK,CACT1I,MAAO4d,EAAcnU,GACrBmO,QAASgG,EAAcnU,EAAI,IAGvC,CAMA,MALe,CACXpJ,KAAMkd,EAAgBX,QAClBne,MAAMC,QAAQkZ,IAAYA,EAAQjX,OAAS,GAAK,CAAEiX,cAC/B,iBAAZA,GAAwB,CAAEA,WAG7C,CACO,SAASmG,EAA0CC,GACtD,MAAM,YAAEC,EAAW,OAAE5H,EAAM,QAAEuB,EAAU,GAAG,UAAEsG,EAAY,KAAI,WAAEC,EAAa,CAAC,EAAG,IAAQH,EACxEC,EAAYG,YACpBC,kBAAkB,GACzB,MAAMxH,EAAO,mBACPyH,EAAcjI,GAAU,IAAa+G,gBAAgB,OAC3DvG,EAAK0H,cAAcD,GACnBzH,EAAK2H,gBAAgBL,EAAW,GAAIA,EAAW,IAC/CF,EAAY3G,cAAcC,uBAAuB,EAAGV,GACpD4H,EAA2BR,EAAarG,EAASsG,EACrD,CACO,SAASQ,EAAcT,EAAaU,GAEvCF,EAA2BR,EAAaU,EADfC,EAAkBX,GAE/C,CACO,SAASY,EAAgBZ,EAAaa,GAEzCL,EAA2BR,EADJc,EAAcd,GACmBa,EAC5D,CACA,SAASL,EAA2BR,EAAarG,EAASsG,GACtD,MAAMc,EAAOf,EAAYG,YAAYa,eAAe9e,IAAI,gBACxD,IAAK6e,GAAMja,aACP,MAAM,IAAI5G,MAAM,2HAEpB,MAAM0N,EAAQmT,EAAKja,aAAama,WAC1BxH,EAAO,mBACb,GAAkB,OAAdwG,EAAoB,CACpB,MAAM5I,EAAwC,KAAhCtY,KAAK6e,IAAIhQ,EAAM,GAAKA,EAAM,IAClCsT,EAAiBniB,KAAKkS,IAAIrD,EAAM,GAAI7O,KAAKa,IAAIgO,EAAM,GAAIqS,IAC7DxG,EAAKI,SAASjM,EAAM,GAAI,GACxB6L,EAAKI,SAASqH,EAAiB7J,EAAO,GACtCoC,EAAKI,SAASqH,EAAgBvH,GAC9BF,EAAKI,SAASjM,EAAM,GAAI+L,EAC5B,MAEIF,EAAKI,SAASjM,EAAM,GAAI+L,GACxBF,EAAKI,SAASjM,EAAM,GAAI+L,GAE5BqG,EAAY3G,cAAcW,iBAAiB,EAAGP,EAClD,CACA,SAASkH,EAAkBX,GACvB,MAAMmB,EAAkBnB,EAAY3G,cAAcuG,iBAAiB,GACnE,IAAKuB,EACD,OAAO,KAEX,MAAMC,EAAYD,EAAgBtB,iBAClC,IAAKuB,GAAaA,EAAU1e,QAAU,EAClC,OAAO,KAEX,IAAK,IAAI8I,EAAI,EAAGA,EAAI4V,EAAU1e,OAAS,EAAG8I,GAAK,EAAG,CACnC4V,EAAU5V,GAArB,MACM6V,EAAKD,EAAU5V,EAAI,GACnB8V,EAAKF,EAAU5V,EAAI,GACnB+V,EAAKH,EAAU5V,EAAI,GACzB,GAAW,IAAP6V,GAAYE,EAAK,EACjB,OAAOD,CAEf,CACA,OAAO,IACX,CACA,SAASR,EAAcd,GACnB,MAAMmB,EAAkBnB,EAAY3G,cAAcuG,iBAAiB,GACnE,IAAKuB,EACD,OAAO,EAEX,MAAMC,EAAYD,EAAgBtB,iBAClC,IAAKuB,GAAkC,IAArBA,EAAU1e,OACxB,OAAO,EAEX,IAAI8e,EAAa,EACjB,IAAK,IAAIhW,EAAI,EAAGA,EAAI4V,EAAU1e,OAAQ8I,GAAK,EACnC4V,EAAU5V,GAAKgW,IACfA,EAAaJ,EAAU5V,IAG/B,OAAOgW,CACX,C,6DCvIe,SAASC,EAAgCC,GACpD,MAAM9I,EAAO,mBACb,IAAI+I,EAAQ,EACRC,EAAQ,KAOZ,YANuB9hB,IAAnB4hB,EAASC,YAA0C7hB,IAAnB4hB,EAASE,QACzCD,EAAQD,EAASC,MACjBC,EAAQF,EAASE,OAErBhJ,EAAKO,YAAYwI,EAAO,EAAK,EAAK,GAClC/I,EAAKO,YAAYyI,EAAO,EAAK,EAAK,GAC3BhJ,CACX,C,8FCRe,SAASiJ,EAAiCH,EAAUI,EAAqB,MACpF,MAAM,YAAExhB,EAAW,aAAEC,GAAiB,gBAA8BmhB,EAASC,MAAOD,EAASE,OAEvFG,EADQvhB,MAAM6D,KAAK,CAAE3B,OAAQof,GAAsB,CAACE,EAAGxW,KAAOA,EAAI,IAAMsW,EAAqB,IAC/EG,QAAS3iB,GAElB,EADG,OAAMA,EAAGiB,EAAcD,GACtBhB,EAAGA,EAAGA,EAAG,GAAK,IAEvBsZ,EAAO,mBAKb,OAJAA,EAAKsJ,uBAAuB,iBAAyB,CACjDzF,OAAQsF,EACRhb,mBAAoB,KAEjB6R,CACX,C,+BCjBe,SAASuJ,EAASC,EAAMC,EAAYjT,EAAS,GACxD,MAAMkT,EAAoB,GAC1B,IAAK,IAAI9W,EAAI4D,EAAQ5D,EAAI4W,EAAK1f,OAAQ8I,GAAK6W,EACvCC,EAAkB7X,KAAKe,GAE3B,OAAO8W,CACX,C,+CCNO,SAASC,EAAUC,GACtB,GAAY,OAARA,GAA+B,iBAARA,EACvB,OAAOA,EAEX,GAAmB,mBAARA,EACP,OAAOA,EAEX,GAA+B,mBAApBpP,gBACP,OAAOoP,EAEX,GAAIhiB,MAAMC,QAAQ+hB,GACd,OAAOA,EAAIra,IAAIoa,GAEd,CACD,MAAME,EAAY,CAAC,EACnB,IAAK,MAAMxgB,KAAOugB,EACV9gB,OAAOiB,UAAUC,eAAeC,KAAK2f,EAAKvgB,KAC1CwgB,EAAUxgB,GAAOsgB,EAAUC,EAAIvgB,KAGvC,OAAOwgB,CACX,CACJ,C,+CCtBe,SAASC,EAAUC,GAC9B,IAAIC,EAAO,WACX,IAAK,IAAIpX,EAAI,EAAGA,EAAImX,EAAIjgB,OAAQ8I,IAC5BoX,GAAQD,EAAIE,WAAWrX,GACvBoX,IACKA,GAAQ,IAAMA,GAAQ,IAAMA,GAAQ,IAAMA,GAAQ,IAAMA,GAAQ,IAEzE,OAAQA,IAAS,GAAGE,SAAS,GACjC,C,yHCHA,MAAMC,EAAM,EAAAC,QAAQC,UAAU,YAAa,qBAC5B,SAASC,EAAkBC,EAAaC,EAAUC,EAAiBnd,GAC9E,MAAM,UAAE6D,EAAS,QAAEH,EAAO,SAAE1B,GAAaib,GACnC,cAAEG,GAAgB,GAAUpd,GAAW,CAAC,EAC9C,IAAKgC,GAAUxF,OACX,OAEJ,MAAM6gB,EAAUxZ,EAAUvH,MAAM,EAAG,GAC7BghB,EAAa,SAASD,EAASF,GACrC,GAAItkB,KAAK6e,IAAI4F,GAAc,EAAI,EAAAC,QAC3B,OAEJ,IAAIC,EAKAC,EAJJ,IAAKL,EAAe,CAEhBI,GADiC,OAA4B,CAAE3Z,YAAWH,WAAWyZ,GAC3B,CAC9D,CAEA,IAAIO,EAAcnL,IAClB,IAAK,IAAIjN,EAAI,EAAGA,EAAItD,EAASxF,OAAQ8I,IAAK,CACtC,MAAMvF,EAAUiC,EAASsD,GACnB/C,EAAmB,MAAa,mBAAoBxC,GAC1D,IAAKwC,GAAkBqB,qBAAsB,CACzCiZ,EAAI5Q,KAAK,6CAA6ClM,KACtD,QACJ,CACA,MAAM,qBAAE6D,GAAyBrB,EAC3Bob,EAAM,cACZ,SAASA,EAAKT,EAAUtZ,GACxB,MAAMgU,EAAW/e,KAAK6e,IAAI,SAASiG,EAAKR,IACpCC,EACIxF,EAAW8F,IACXA,EAAc9F,EACd6F,EAAiB1d,GAIjB6X,EAAW4F,GAAgC5F,EAAW8F,IACtDA,EAAc9F,EACd6F,EAAiB1d,EAG7B,CAIA,YAHuBnG,IAAnB6jB,GACAZ,EAAI5Q,KAAK,sFAENwR,CACX,C,oFCjDO,SAASG,EAAqBxmB,GACjC,MAAM,iBAAEmL,EAAgB,iBAAEU,EAAgB,eAAEiT,EAAc,SAAEnc,EAAQ,cAAE6c,EAAa,YAAER,IAAiB,QAAchf,GACpH,IAAI,WAAEoN,EAAU,cAAEC,GAAkBlC,EAClB,MAAdiC,GAAuC,MAAjBC,IACtBD,EAAa,CAAC,EAAG,EAAG,GACpBC,EAAgB,CAAC,EAAG,EAAG,IAE3B,MAAMsS,EAAe,gBAAgBvS,EAAW,GAAIA,EAAW,GAAIA,EAAW,IACxEwS,EAAe,gBAAgBvS,EAAc,GAAIA,EAAc,GAAIA,EAAc,IACjFwS,EAAiB,cACvB,WAAWA,EAAgBF,EAAcC,GACzC,IAAIrT,EAASpB,EAAiBqB,qBAChB,MAAVD,IACAA,EAAS,CAAC,EAAG,EAAG,IAEpB,MAAMka,EAAWtb,EAAiBhJ,oBAAsBnC,EAAMmC,mBACxDukB,EAAWvb,EAAiBjJ,iBAAmBlC,EAAMkC,gBACrDykB,EAAU3mB,EAAMwD,QAChBojB,EAAU5mB,EAAMyD,KAChBojB,EAAW,EAAAV,QAEZta,EAAiB+B,2BAClB5N,EAAMyO,cAAgB,EAAIzO,EAAMoB,MAAQpB,EAAMqB,SAC9CrB,EAAMyJ,mBAAqB,GAI/B,MAAO,CACHA,mBAHuBzJ,EAAMyJ,oBAmBrC,SAAmDmE,GAC/C,IAAInE,EAAqB,GACS,QAA9BmE,GACAA,GAA2ByR,SAAS,QACN,kBAA9BzR,KACAnE,EAAqB,GAEzB,OAAOA,CACX,CA1BQqd,CAA0Cjb,EAAiB+B,2BAG3DrB,SACAE,UAAW,IAAIkT,KAAiBC,KAAiBC,GACjDxT,WAAY,CAACsa,EAASC,EAXV,GAYZta,QAAS,CAACma,EAAUC,EAAUG,GAC9BE,UAAWJ,EAAUC,EAbT,EAcZzb,mBACAU,mBACAC,cAAeD,EAAiBC,cAChCgT,iBACAnc,WACA6c,gBACAR,cACAa,eAAgBA,EAExB,C,0ECbA,QA/BA,SAA4Cnf,GACxC,MAAMsmB,EAAStmB,EAASumB,aAClB,yBAAEC,EAAwB,YAAErB,IAAgB,OAAqCnlB,EAAUsmB,GACjG,IAAKnB,EACD,OAEJ,MAAM,gBAAEE,EAAe,WAAEoB,GAAeH,EAClCzM,EAAa7Z,EACd0mB,YACAlF,KAAMxB,GAAMA,EAAE2G,eAAiBxB,EAAYvW,UAC5CoR,EAAE4G,MAAQzB,EAAYvW,UACrBiL,GACD3F,QAAQC,KAAK,sCAAuCgR,EAAYvW,UAEpE,MAAMoT,EAAcnI,EAAWI,MACzB4M,GAAa,OAAc7E,EAAaqD,EAAiBoB,IACzD,IAAE7kB,EAAG,IAAEqR,EAAG,QAAErM,GAAYigB,EACxBC,EAAiB/lB,KAAKgmB,OAAO9T,EAAMrR,GAAO4kB,GAA4B,EAC5E,IAAIQ,GAAepgB,EAAUhF,IAAQqR,EAAMrR,GAAQklB,EAQnD,OAPAE,EAAajmB,KAAK+Q,MAAMkV,GACpBA,EAAaF,EAAiB,EAC9BE,EAAaF,EAAiB,EAEzBE,EAAa,IAClBA,EAAa,GAEV,CACHF,iBACAE,aAER,C,+DC/Be,SAASC,EAAqBhf,GACzC,MAAMif,EAAoB,MAAa,oBAAqBjf,IAAY,CAAC,EACnEkf,EAAsB,MAAa,sBAAuBlf,IAAY,CAAC,GACvE,SAAEhG,GAAaklB,EACfC,EAAoB,CACtBC,aAAcH,EAAkBG,cAAgB,EAChDC,iBAAkBJ,EAAkBI,kBAAoB,EACxDrlB,YAEEslB,EAAiB,MAAa,gBAAiBtf,IAAY,CAAC,EAClE,MAAO,IACAmf,KACc,OAAbnlB,GAAqB,CACrBulB,MAAOD,EAAeC,MACtBC,OAAQF,EAAeE,OACvBC,OAAQH,EAAeG,WAEV,WAAbzlB,GAAyB,CACzB0lB,gBAAiBJ,EAAeK,gBAChCC,cAAeN,EAAeO,cAC9BC,SAAUR,EAAeS,SACzBC,SAAUV,EAAeW,UAGrC,C,qFCtBA,MAAMC,EAAgB,EAAA1C,QAAU,EAAAA,QAC1B2C,EAAS7U,GAAMxS,KAAK6e,IAAI7e,KAAK6e,IAAIrM,GAAK,GAAK4U,EAC3CE,EAAS,CAAC9U,EAAG+U,IAAQF,EAAM7U,EAAE+U,KAASF,EAAM7U,EAAE+U,EAAM,KAAOF,EAAM7U,EAAE+U,EAAM,IACzEC,EAAiBhV,GAAM8U,EAAO9U,EAAG,IAAM8U,EAAO9U,EAAG,IAAM8U,EAAO9U,EAAG,GACxD,SAASiV,EAAcxG,EAAaqD,EAAiBoB,GAChE,MAAMgC,EAAYzG,EAAYG,YAAYa,eAC1C,IAAI0F,EACJ,MAAM3c,EAAY0c,EAAUE,eAC5B,GAAIJ,EAAcxc,GACd2c,GAAU,OAAsB1G,OAE/B,CACD,MAAO4G,EAAIC,EAAIC,GAAML,EAAUM,gBAW/BL,EAVmB,CACf,CAAC,EAAG,EAAG,GACP,CAACE,EAAK,EAAG,EAAG,GACZ,CAAC,EAAGC,EAAK,EAAG,GACZ,CAACD,EAAK,EAAGC,EAAK,EAAG,GACjB,CAAC,EAAG,EAAGC,EAAK,GACZ,CAACF,EAAK,EAAG,EAAGE,EAAK,GACjB,CAAC,EAAGD,EAAK,EAAGC,EAAK,GACjB,CAACF,EAAK,EAAGC,EAAK,EAAGC,EAAK,IAEL3e,IAAK0F,GAAO4Y,EAAUO,aAAanZ,GAC5D,CACA,MAAMtP,EAAY,IACb0oB,kBACAC,WACAC,qBAAqB9D,EAAiB,CAAC,EAAG,EAAG,IAClDqD,EAAQ3jB,QAASqkB,GAAO7oB,EAAU8oB,MAAMD,IACxC,MAAME,EAAwB,IAAI7C,GAClClmB,EAAU8oB,MAAMC,GAChB,MAAMC,EAAeD,EAAsB,GAC3C,IAAIE,EAAO/O,IACPgP,GAAQhP,IACZ,IAAK,IAAIjN,EAAI,EAAGA,EAAI,EAAGA,IAAK,CACxB,MAAMpM,EAAIsnB,EAAQlb,GAAG,GACjBpM,EAAIqoB,IACJA,EAAOroB,GAEPA,EAAIooB,IACJA,EAAOpoB,EAEf,CACA,MAAO,CACHQ,IAAK4nB,EACLvW,IAAKwW,EACL7iB,QAAS2iB,EACTtP,MAAO+H,EACPqD,kBACAoB,aAER,C,8DCtDe,SAASiD,EAA4BvE,EAAaE,GAC7D,MAAM,UAAEtZ,EAAS,QAAEH,GAAYuZ,EACzBwE,EAAU5d,EAAUvH,MAAM,EAAG,GAC7BolB,EAAU7d,EAAUvH,MAAM,EAAG,GAC7B+gB,EAAUxZ,EAAUvH,MAAM,EAAG,GAC7BqlB,EAAc,CAChB,SAASF,EAAStE,GAClB,SAASuE,EAASvE,GAClB,SAASE,EAASF,IAEhByE,EAAmB,cACzB,SAASA,EAAkBD,EAAY,GAAKje,EAAQ,GAAIie,EAAY,GAAKje,EAAQ,GAAIie,EAAY,GAAKje,EAAQ,IAE9G,OADiC,YAAYke,EAEjD,C,2GCVA,MAAMC,EAAe,EAAI,EAAAtE,QAEnBuE,EAAmBC,MAAa,IAAAC,0BAAyB1I,KAAMjZ,IAAWzD,OAD5D6f,EACuEsF,EAAOrb,UADzEub,EACmF5hB,KAD7Doc,EAAIyF,UAAU,EAAGrpB,KAAKa,IAAI+iB,EAAIjgB,OAAQylB,EAAOzlB,SAAzE,IAACigB,EAAKwF,IAEV,SAASE,EAAqCrqB,EAAUsmB,EAAQgE,EAAUC,GAAmB,GACxG,MAAM,gBAAElF,GAAoBiB,EACtBkE,EAAexqB,EAAS0mB,YAC9B,IAAK8D,EAAa9lB,OACd,MAAO,CACH8hB,yBAA0B,KAC1BrB,YAAa,KACbsF,SAAU,MAGlB,MAAMC,EAAeF,EAChBrgB,IAAKwgB,IACN,MAAMF,EAAWE,EAAGhE,cAAgBgE,EAAG/D,IACvC,OAAO,KAAMgE,UAAUH,KAEtB7R,OAAQiS,KAASA,GACtB,GAAIP,EAAU,CACV,MAAMQ,GAAiB,OAAYR,GAC7BS,EAAmBL,EAAapU,UAAWuU,GAAOC,EAAenM,SAASkM,EAAGjc,WAC7EuW,EAAcuF,EAAaK,IACzBnE,IAAK6D,GAAaD,EAAaO,GAEvC,MAAO,CAAE5F,cAAaqB,yBADWwE,EAAmB7F,EAAaE,EAAiBrlB,EAAUuqB,GAC5CE,WACpD,CACA,IAAKC,EAAahmB,OACd,MAAO,CACH8hB,yBAA0B,KAC1BrB,YAAa,KACbsF,SAAU,MAGlB,MAAMQ,EAAW,CACbzE,yBAA0B/L,IAC1B0K,YAAa,KACbsF,SAAU,MAERS,EAAmBR,EAAalJ,KAAKwI,GAC3C,IAAK,IAAIxc,EAAI,EAAGA,EAAIkd,EAAahmB,OAAQ8I,IAAK,CAC1C,MAAM2X,EAAcuF,EAAald,GACjC,GAAI0d,IAAqBlB,EAAgB7E,GACrC,SAEJ,MAAMqB,EAA2BwE,EAAmB7F,EAAaE,EAAiBrlB,GAC9EwmB,EAA2BuD,EAC3BkB,EAASzE,2BACTyE,EAASzE,yBAA2BA,EACpCyE,EAAS9F,YAAcA,EACvB8F,EAASR,SAAWD,EAAahd,GAAGoZ,IAE5C,CACA,OAAOqE,CACX,CACA,SAASD,EAAmB7F,EAAaE,EAAiBrlB,EAAUuqB,GAAmB,GACnF,MAAM,cAAEY,GAAkBnrB,EAASorB,gBACnC,IAAI5E,EAA2B2E,EAI/B,OAHKA,GAAkBZ,IACnB/D,GAA2B,OAA4BrB,EAAaE,IAEjEmB,CACX,C,+DCxDA,QAVA,SAAkC5X,GAC9B,MAAMyc,GAAmB,UACnBC,EAAkB,GAMxB,OALAD,EAAiBtmB,QAAS0Y,IACtB,MACM8N,EADY9N,EAAgB+N,qBACE5S,OAAQ6S,GAAOA,EAAGC,YAAY9c,IAClE0c,EAAgB7e,QAAQ8e,KAErBD,CACX,C,+BCVe,SAASK,EAAqC/Q,GACzD,IAAIgR,EAAY,GAChB,MAAOjI,EAAOC,GAAShJ,EAAKqI,WAC5BrI,EAAKiR,SAASlI,EAAOC,EAAO,KAAMgI,GAClCA,EAAYA,EAAUhT,OAAO,CAACrF,EAAG4C,IAAMA,EAAI,GAAM,GACjD,MAAM2V,EAAa,IAAItpB,MAAM,MAAM8C,QAAQ6E,IAAI,CAACoJ,EAAG4C,IACxCwN,GAAUC,EAAQD,GAAS,KAAcxN,GAE9CkN,EAAKuI,EAAU,KACfG,EAAQhrB,KAAKgkB,KAAK,EAAI1B,GAAMA,GAC5B2I,EAAKF,EAAW,KAChBvI,EAAKqI,EAAU,KACfK,EAAQlrB,KAAKgkB,KAAK,EAAIxB,GAAMA,GAC5BD,EAAKwI,EAAW,KAChBI,EAAKnrB,KAAKgmB,MAAO,GAAKzD,EAAK0I,IAAQD,EAAQE,IAC3CE,EAAKprB,KAAKgmB,MAAMiF,EAAME,EAAKH,EAAS,GAC1C,MAAO,CAAChrB,KAAKgmB,MAAMoF,EAAKD,EAAK,GAAInrB,KAAKgmB,MAAMoF,EAAKD,EAAK,GAC1D,C,+CCjBe,SAASE,EAAsBpK,GAC1C,MAAMyG,EAAYzG,EAAYG,YAAYa,eACpCqJ,EAAS5D,EAAU6D,eAAe7D,EAAU8D,aAClD,MAAO,CACH,CAACF,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAC9B,CAACA,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAEtC,C,gECbO,MAAMG,EAAelC,IACxB,MAAMtjB,EAAS,YACT2d,EAAM2F,EAAS3L,SAAS3X,GACxBsjB,EAASF,UAAUpjB,GACnBsjB,EACAhe,EAAQqY,EAAI7d,QAAQ,eAC1B,OAAkB,IAAXwF,EAAeqY,EAAMA,EAAIyF,UAAU,EAAG9d,EAAQ,G,yECgBzD,QApBA,SAAiCtM,EAAU4O,EAAU2b,GAAmB,GACpE,MAAMjE,EAAStmB,EAASumB,aAClB,WAAEE,EAAU,gBAAEpB,GAAoBiB,GAClC,yBAAEE,EAAwB,SAAEiE,IAAa,OAAqCzqB,EAAUsmB,EAAQ1X,EAAU2b,GAChH,IAAKE,EACD,MAAM,IAAIvoB,MAAM,uCAAuC0M,qBAE3D,MAAMiL,EAAa7Z,EAASysB,SAAShC,GACrC,IAAK5Q,EAED,OADA3F,QAAQC,KAAK,sCAAuCsW,GAC7C,KAEX,MAAMzI,EAAcnI,EAAWI,MAE/B,MAAO,CACH4M,YAFe,OAAc7E,EAAaqD,EAAiBoB,GAG3DD,2BACAF,SAER,C,8DCHA,QAjBA,SAAqCtmB,EAAU4O,EAAU2b,GAAmB,GACxE,MAAM,WAAE1D,EAAU,yBAAEL,EAAwB,OAAEF,IAAW,OAAwBtmB,EAAU4O,EAAU2b,IAC/F,IAAE3oB,EAAG,IAAEqR,EAAG,QAAErM,GAAYigB,EACxB6F,EAAiB3rB,KAAKgmB,OAAO9T,EAAMrR,GAAO4kB,GAE1CmG,GADY/lB,EAAUhF,IAAQqR,EAAMrR,GACJ8qB,EAEtC,MAAO,CACHA,iBACAE,iBAHqB7rB,KAAKgmB,MAAM4F,GAIhCE,eAAgB,CACZhG,aACAL,2BACAF,UAGZ,C,gDCjBO,MAAMwG,EAA6B1F,GACd1jB,OAAO+a,OAAO2I,GAAmB2F,KAAMhpB,GAA2B,iBAAVA,IAAuB+L,OAAOkd,UAAUjpB,G,+BCD7G,SAASkpB,EAAaC,GACjC,OAAI1qB,MAAMC,QAAQyqB,GACPA,EAAMH,KAAMhpB,GAAU+L,OAAOwQ,MAAMvc,IAEvC+L,OAAOwQ,MAAM4M,EACxB,C,+CCLe,SAASC,EAAallB,GACjC,MAAMmlB,EAAanlB,EAAQnB,QAAQ,KACnC,OAAOmB,EAAQmiB,UAAUgD,EAAa,EAC1C,C,+ECFA,MAAMC,EAA6B,IAAI/X,IACjCgY,EAA+B,6BAC/BC,EAAgC,CAClCD,+BACA1V,MAAO,KACHyV,EAA2BzV,SAE/BxQ,IAAK,CAACnD,EAAKupB,KACPH,EAA2BrpB,IAAIC,EAAKupB,IAExCC,MAAO,IACI,IAAInY,IAAI+X,GAEnBK,QAAUC,IACNN,EAA2BzV,QAC3B+V,EAAM5oB,QAAQ,CAAChB,EAAOE,KAClBopB,EAA2BrpB,IAAIC,EAAKF,MAG5CG,IAAK,CAAC0G,KAASgjB,KACX,GAAIhjB,IAAS0iB,EACT,OAAOM,EACFzjB,IAAK0jB,GAAUR,EAA2BnpB,IAAI2pB,IAC9CrM,KAAM3R,QAAc/N,IAAP+N,MAI9B,IAAAie,aAAYP,EAA8BrpB,IAAIoQ,KAAKiZ,IACnD,S,o/FC7BIQ,E,qDACJ,SAAWA,GACPA,EAAoBA,EAA0B,KAAI,GAAK,OACvDA,EAAoBA,EAA6B,QAAI,GAAK,UAC1DA,EAAoBA,EAA4B,OAAI,GAAK,QAC5D,CAJD,CAIGA,IAAwBA,EAAsB,CAAC,IAClD,MAAMC,EACF,WAAAzqB,CAAY0qB,GACRnqB,KAAKoqB,gBAAkB,IAAI5Y,IAC3BxR,KAAKqqB,UAAY,IAAI7Y,IACrBxR,KAAKsqB,QAAUH,CACnB,CACA,WAAII,GACA,OAAqC,IAA9BvqB,KAAKoqB,gBAAgBI,MAAsC,IAAxBxqB,KAAKqqB,UAAUG,IAC7D,CACA,gBAAAC,CAAiB3jB,EAAM5F,EAAUkD,GAC7B,MAAMsmB,EAAW5jB,EAAK9D,QAAQ,KAE9B,IADkC,IAAd0nB,EACH,CACb,MAAMC,EAAiB7jB,EAAKwf,UAAU,EAAGoE,GACzC,IAAIE,EAA4B5qB,KAAKqqB,UAAUjqB,IAAIuqB,GAC9CC,IACDA,EAA4B,IAAIV,EAAqBlqB,KAAKsqB,SAC1DtqB,KAAKqqB,UAAUnqB,IAAIyqB,EAAgBC,IAEvC9jB,EAAOA,EAAKwf,UAAUoE,EAAW,GACjCE,EAA0BH,iBAAiB3jB,EAAM5F,EAAUkD,EAC/D,MAEIpE,KAAK6qB,kBAAkB/jB,EAAM5F,EAAUkD,EAE/C,CACA,mBAAA0mB,CAAoBhkB,EAAM5F,EAAUkD,GAChC,MAAMsmB,EAAW5jB,EAAK9D,QAAQ,KAE9B,IADkC,IAAd0nB,EACH,CACb,MAAMC,EAAiB7jB,EAAKwf,UAAU,EAAGoE,GACnCE,EAA4B5qB,KAAKqqB,UAAUjqB,IAAIuqB,GACrD,IAAKC,EACD,OAEJ9jB,EAAOA,EAAKwf,UAAUoE,EAAW,GACjCE,EAA0BE,oBAAoBhkB,EAAM5F,EAAUkD,GAC1DwmB,EAA0BL,SAC1BvqB,KAAKqqB,UAAU7mB,OAAOmnB,EAE9B,MAEI3qB,KAAK+qB,qBAAqBjkB,EAAM5F,EAAUkD,EAElD,CACA,KAAA4mB,GACItsB,MAAM6D,KAAKvC,KAAKqqB,UAAUY,WAAWhqB,QAAQ,EAAER,EAAWyqB,MAEtD,GADAA,EAAMF,SACFE,EAAMX,QAIN,MAAM,IAAInsB,MAAM,4CAHhB4B,KAAKqqB,UAAU7mB,OAAO/C,KAM9BT,KAAKmrB,sBACT,CACA,iBAAAN,CAAkB/jB,EAAM5F,EAAUkD,GAC9B,IAAIgnB,EAAeprB,KAAKoqB,gBAAgBhqB,IAAI0G,GACvCskB,IACDA,EAAe,IAAI5Z,IACnBxR,KAAKoqB,gBAAgBlqB,IAAI4G,EAAMskB,IAEnC,MACMC,EADajnB,GAASknB,UAAW,EAEjCrB,EAAoBsB,QACpBtB,EAAoBuB,OACpBC,EAAmBL,EAAahrB,IAAIc,IAAa+oB,EAAoByB,KACvED,EAAmBJ,EACnBjb,QAAQC,KAAK,oDAGjB+a,EAAalrB,IAAIgB,EAAUuqB,EAAmBJ,GAC9CrrB,KAAKsqB,QAAQG,iBAAiB3jB,EAAM5F,EAAUkD,GAClD,CACA,oBAAA2mB,CAAqBjkB,EAAM5F,EAAUkD,GACjC,MACMinB,EADajnB,GAASknB,UAAW,EAEjCrB,EAAoBsB,QACpBtB,EAAoBuB,OACpBJ,EAAeprB,KAAKoqB,gBAAgBhqB,IAAI0G,GAC9C,IAAKskB,EACD,QAEclqB,EAAW,CAACA,GAAYxC,MAAM6D,KAAK6oB,EAAa5pB,SACxDP,QAAS0qB,IACf,MAAMF,EAAmBL,EAAahrB,IAAIurB,IAAiB1B,EAAoByB,KAE/E,OAD2BD,EAAmBJ,GAE1C,OAEJrrB,KAAKsqB,QAAQQ,oBAAoBhkB,EAAM6kB,EAAcvnB,GACrD,MAAMwnB,EAAmBH,EAAmBJ,EACxCO,IAAqB3B,EAAoByB,KACzCN,EAAa5nB,OAAOmoB,GAGpBP,EAAalrB,IAAIyrB,EAAcC,KAGlCR,EAAaZ,MACdxqB,KAAKoqB,gBAAgB5mB,OAAOsD,EAEpC,CACA,uBAAA+kB,CAAwB/kB,EAAMskB,GAC1B1sB,MAAM6D,KAAK6oB,EAAaH,WAAWhqB,QAAQ,EAAE6qB,EAAUC,MAEnD,IAAK,IAAIC,EADU/B,EAAoBsB,QACHQ,EAAaC,IAAiB,EAAG,CACjE,KAAMD,EAAcC,GAChB,SAEJ,MAAMC,EAAaD,IAAiB/B,EAAoBsB,QACxDvrB,KAAK8qB,oBAAoBhkB,EAAMglB,EAAU,CAAER,QAASW,IACpDF,GAAeC,CACnB,GAER,CACA,oBAAAb,GACIzsB,MAAM6D,KAAKvC,KAAKoqB,gBAAgBa,WAAWhqB,QAAQ,EAAE6F,EAAMskB,MACvDprB,KAAK6rB,wBAAwB/kB,EAAMskB,IAE3C,EC9HJ,MAAMc,EACF,WAAAzsB,GACIO,KAAKmsB,uBAAyB,IAAI3a,GACtC,CACA,gBAAAiZ,CAAiBN,EAAQrjB,EAAM5F,EAAUkD,GACrC,IAAIgoB,EAAiBpsB,KAAKmsB,uBAAuB/rB,IAAI+pB,GAChDiC,IACDA,EAAiB,IAAIlC,EAAqBC,GAC1CnqB,KAAKmsB,uBAAuBjsB,IAAIiqB,EAAQiC,IAE5CA,EAAe3B,iBAAiB3jB,EAAM5F,EAAUkD,EACpD,CACA,mBAAA0mB,CAAoBX,EAAQrjB,EAAM5F,EAAUkD,GACxC,MAAMgoB,EAAiBpsB,KAAKmsB,uBAAuB/rB,IAAI+pB,GAClDiC,IAGLA,EAAetB,oBAAoBhkB,EAAM5F,EAAUkD,GAC/CgoB,EAAe7B,SACfvqB,KAAKmsB,uBAAuB3oB,OAAO2mB,GAE3C,CACA,KAAAa,GACItsB,MAAM6D,KAAKvC,KAAKmsB,uBAAuBlB,WAAWhqB,QAAQ,EAAEkpB,EAAQkC,MAChEA,EAAqBrB,QACrBhrB,KAAKmsB,uBAAuB3oB,OAAO2mB,IAE3C,E,gDC5BW,SAASmC,EAAyBC,EAAqBvR,GAClE,MAAMwP,EAAO+B,EAAoBC,UACjC,IAAK,IAAIhkB,EAAQ,EAAGA,EAAQgiB,EAAMhiB,IAAS,CACvC,MAAMikB,EAAa,GACnBF,EAAoBG,aAAalkB,EAAOikB,GACxCA,EAAW,GAAKA,EAAW,GAAKzR,EAChCyR,EAAW,GAAKA,EAAW,GAAKzR,EAChCyR,EAAW,GAAKA,EAAW,GAAKzR,EAChCuR,EAAoBI,aAAankB,EAAOikB,EAC5C,CACJ,C,0BCVe,SAASG,EAAUC,GAC9B,IAEIC,EAFAhvB,EAAM+uB,EAAgB,GACtB1d,EAAM0d,EAAgB,GAE1B,MAAME,EAAYF,EAAgBjsB,OAClC,IAAK,IAAI4H,EAAQ,EAAGA,EAAQukB,EAAWvkB,IACnCskB,EAAcD,EAAgBrkB,GAC9B1K,EAAMb,KAAKa,IAAIA,EAAKgvB,GACpB3d,EAAMlS,KAAKkS,IAAIA,EAAK2d,GAExB,MAAO,CACHhvB,MACAqR,MAER,CCdA,MAAM6d,EAAkB5tB,OAAO,iBACzB6tB,EAAiB,CAAC,EAClBC,EAAc,WACdC,EAAoB,IACX,SAASC,EAAa1rB,EAASkC,EAAWuL,GACrD,OAEJ,SAA0BzN,EAAS2rB,EAAQle,GACvC,IAAIme,EAAe5rB,EAAQ2rB,GACrBC,aAAwB5uB,QAC1B4uB,EAAe,CAAC,GAChB1tB,OAAOG,eAAe2B,EAAS2rB,EAAQ,CAAEptB,MAAOqtB,KAEpD,IAAK,IAAIC,GAAQ,EAAM7jB,EAAI,EAAG6jB,GAAS7jB,EAAI4jB,EAAa1sB,SAAU8I,EAAG,CACjE,IAAI8jB,EAAsB,EAAlBF,EAAa5jB,GACjB8jB,EAAIre,GACJoe,GAAQ,EACRC,GAAQ,IAGRA,EAAI,EACA9jB,EAAI,IAAM4jB,EAAa1sB,QACvB0sB,EAAa3kB,KAAK,IAG1B2kB,EAAa5jB,GAAK8jB,CACtB,CACA,OAAOF,CACX,CAvBWG,CAA6B,OAAZ/rB,GAAuC,iBAAZA,EAAuBA,EAAUurB,EAAgBD,GAAiC,iBAAR7d,GAAoBA,EAAM,EAAIA,EAAM+d,KAAiB,GAAGQ,KAA0B,iBAAd9pB,EAAyBA,EAAYupB,EAC1O,C,eCLA,MAAMtD,EAAQ,CAAC,EAaf,EAZyB,CACrBvmB,IAAK,CAACa,EAASulB,KACX,MAAMiE,GAAW,EAAAtE,EAAA,GAAallB,GAC9B0lB,EAAM8D,GAAYjE,GAEtBtpB,IAAK,CAAC0G,EAAM3C,KACR,GAAa,2BAAT2C,EAAmC,CACnC,MAAM6mB,GAAW,EAAAtE,EAAA,GAAallB,GAC9B,OAAO0lB,EAAM8D,EACjB,I,eCXO,SAASC,EAAWC,EAAIC,EAAIC,EAAY,MACnD,OAAQ9wB,KAAK6e,IAAI+R,EAAG,GAAKC,EAAG,IAAMC,GAC9B9wB,KAAK6e,IAAI+R,EAAG,GAAKC,EAAG,IAAMC,GAC1B9wB,KAAK6e,IAAI+R,EAAG,GAAKC,EAAG,IAAMC,CAClC,C,gDCJe,SAASC,EAAsBxlB,EAAOX,GACjD,QAAIW,EAAM,GAAK,GACXA,EAAM,IAAMX,EAAW,IACvBW,EAAM,GAAK,GACXA,EAAM,IAAMX,EAAW,IACvBW,EAAM,GAAK,GACXA,EAAM,IAAMX,EAAW,GAI/B,C,eCgBA,QAzBA,SAAiDomB,EAAgBC,GAC7D,IAAI3G,EAEAA,EADA2G,EACmB,EAAC,EAAAC,EAAA,IAAmBD,KAGpB,EAAAC,EAAA,MAEvB,MAAMC,EAAuB,GAe7B,OAdA7G,EAAiBtmB,QAAS0Y,IACtB,MAAM0U,EAAeJ,EAAerL,YAC9BhJ,EAAYD,EAAgB+N,qBAClC,IAAK,MAAMC,KAAM/N,EAAW,CACxB,MAAM0U,EAAW3G,EAAG/E,YACpB,GAAI0L,EAAS1tB,SAAWytB,EAAaztB,OACjC,SAEgBytB,EAAaE,MAAM,EAAGzL,SAAUwL,EAAS5Q,KAAM8Q,GAAY1L,IAAQ0L,EAAQ1L,OAE3FsL,EAAqBzlB,KAAKgf,EAElC,IAEGyG,CACX,E,iHCzBA,MAGA,EAH8B5yB,GACnBA,EAAMizB,SAASC,QAAUlzB,EAAMizB,SAASnL,kBAAkBI,MCKtD,SAASiL,EAAkBlzB,EAAQmzB,EAAezwB,OAAWH,EAAWkwB,EAAoB,cAAeW,EAAkB,CACxIC,YAAa,CAAEC,UAAW,CAAC,EAAG,MAE9B,KAAKtzB,GAAYA,aAAkBuzB,mBAC/B,MAAM,IAAI5wB,MAAM,8BAEpB,MAAM6wB,GAAYL,EAAczqB,QAC1B3I,GAASyzB,GAAYL,EACrBzI,EAAS8I,GAAYL,EAErBM,EAAa,qBADI1zB,EAAM2I,SAAWgiB,EAAOrb,WAEzCqkB,EAAUC,SAASC,cAAc,OACjCC,EAAmBC,OAAOD,kBAAoB,EAC/CT,EAAgBC,cACjBD,EAAgBC,YAAc,CAAEC,UAAW,CAAC,EAAG,KAEnD,MAAMS,EAAgB/zB,EAAOmB,MACvB6yB,EAAiBh0B,EAAOoB,OAC9BsyB,EAAQO,MAAM9yB,MAAQ,GAAG4yB,EAAgBF,EAAmB,SAC5DH,EAAQO,MAAM7yB,OAAS,GAAG4yB,EAAiBH,EAAmB,SAC9DH,EAAQO,MAAMC,WAAa,SAC3BR,EAAQO,MAAME,SAAW,WACzBR,SAASS,KAAKC,YAAYX,GAC1B,MAAMY,EAAWb,EAAW9sB,MAAM,KAAKsrB,KAAK,KAC5CyB,EAAQa,aAAa,yBAA0BD,GAC/C,MAAME,GAAkB,EAAAC,EAAA,IAAkBf,GACpCxV,GAAkB,EAAAwU,EAAA,IAAmBD,IACvC,IAAIiC,EAAA,EAAqBjC,GAC7B,IAAIhyB,EAAWyd,EAAgByW,YAAYlB,GAC3C,IAAKhzB,EAAU,CACX,MAAMm0B,EAAgB,CAClBnB,aACApoB,KAAMmoB,EAAW,EAAAqB,aAAaC,aAAe,EAAAD,aAAaE,MAC1DrB,UACAsB,eAAgB,IACT5B,EACH6B,gBAAgB,IAGxB/W,EAAgBgX,cAAcN,GAC9Bn0B,EAAWyd,EAAgByW,YAAYlB,EAC3C,CACA,OAAO,IAAIrqB,QAASC,IAChB,IAAI8rB,GAAkB,GAClB,cAAEC,GAAkBhC,EACxB,MAAMiC,EAAmBC,IACrB,GAAIH,EACA,OAEJ,GAAIC,EAAe,CACf,MAAMG,EAAaH,EAInB,OAHAA,EAAgB,KAChB30B,EAAS+0B,iBAAiBD,QAC1B90B,EAASD,QAEb,CACgBR,EAAOy1B,WAAW,MAC1BC,UAAUlB,EAAiB,EAAG,EAAGA,EAAgBrzB,MAAOqzB,EAAgBpzB,OAAQ,EAAG,EAAGpB,EAAOmB,MAAOnB,EAAOoB,QACnH,MAAMkL,EAAS7L,EAASk1B,cAAc,CAAC,EAAG,IACpCC,EAAWn1B,EAASk1B,cAAc,CACpCnB,EAAgBrzB,MAAQ0yB,EACxB,IAEEgC,EAAap1B,EAASk1B,cAAc,CACtC,EACAnB,EAAgBpzB,OAASyyB,IAEvBiC,EAAc,SAAS,CAAC,EAAG,EAAG,GAAIr1B,EAASk1B,cAAc,CAAC,EAAI9B,EAAkB,IAAKvnB,GACrFypB,EAAa,SAAS,CAAC,EAAG,EAAG,GAAIt1B,EAASk1B,cAAc,CAAC,EAAG,EAAI9B,IAAoBvnB,GAE1F6oB,GAAkB,EAClBzB,EAAQrE,oBAAoB,EAAA2G,OAAOC,eAAgBZ,GACnDa,WAAW,KACPhY,EAAgBiY,eAAe1C,GACdE,SAASyC,iBAAiB,4BAA4B9B,OAC9D9uB,QAASkuB,IACdA,EAAQ2C,YAEb,GACHhtB,EAAQ,CACJiD,SACAupB,aACAD,WACAU,YAdgB,EAehBR,cACAC,gBAGRrC,EAAQ1E,iBAAiB,EAAAgH,OAAOC,eAAgBZ,GAC5C7B,EACA/yB,EAAS81B,WAAW,CAAC7L,IAAS,GAAO,GAGrCjqB,EAAS+1B,kBAAkBrD,GAE/B1yB,EAASg2B,cACQ,OAAb/zB,GAAsB,EAAqB3C,IAC3CU,EAASi2B,cAAc,CACnBvS,SAAU,CACNC,MAAOrkB,EAAMgO,cACbsW,MAAOtkB,EAAMiO,iBAIzBvN,EAASD,UAEjB,C,mCC7Ge,SAASm2B,EAAkB32B,EAAQmzB,EAAezwB,EAAUk0B,EAAoBC,GAE3F,GADe1D,EACJ9jB,SACP,MAAM,IAAI1M,MAAM,wCAEpB,MAAM5C,EAAQozB,EAERtzB,EAAiB,CACnBG,SACAS,UAHa,EAAAq2B,EAAA,GAAmB92B,EAAQD,EAAO2C,GAI/C3C,QACAg3B,eAAgB,CAAC,GAErBl3B,EAAemB,WAAY,EAAAg2B,EAAA,GAAmBn3B,GAE9C,OAAO,IAAIuJ,QAAQ,CAACC,EAAS6K,MACzB,EAAA+iB,EAAA,GAAcp3B,EAFE,MAGhBwJ,EAAQ,OAEhB,C,eCfe,SAAS6tB,EAAkBvuB,GACtC,MAAM,OAAE3I,EAAM,QAAE0I,EAAO,cAAE0sB,EAAa,YAAE7qB,EAAc,EAAA4sB,YAAYC,UAAS,SAAE9sB,GAAW,EAAE,kBAAEmoB,EAAoB,cAAa,gBAAE4E,GAAkB,EAAK,UAAEC,GAAY,EAAK,YAAEC,GAAc,EAAOnE,gBAAiBoE,GAAyB7uB,EACpO0G,EAAW+lB,GAAe/lB,SAC1BmkB,EAAWnkB,IAAa3G,EACxB0qB,EAAkBgC,GAAiBoC,EACnC,IAAKA,EAAqBpC,iBAC1BoC,EACAC,EAAWJ,EAAkBV,EAAoBzD,EACvD,OAAO,IAAI9pB,QAAQ,CAACC,EAAS6K,KACzB,SAASwjB,EAAgBvE,EAAezqB,GACpC,MAAM,SAAEhG,GAAai1B,EAAShzB,IAAI,sBAAuB+D,IAAY,CAAC,EAChE3I,GAASyzB,GAAYL,EACrBzI,EAAS8I,GAAYL,EACvBpzB,IACAA,EAAM+C,YAAc/C,EAAM+C,aAAe/C,EAAMizB,UAAUC,QAEzDqE,IACAt3B,EAAOoB,OAAS,IAChBpB,EAAOmB,MAAQ,KAEfo2B,GAAex3B,IACfC,EAAOmB,MAAQpB,GAAUC,EAAOoB,OAASrB,EAAMoB,MAASpB,EAAMqB,QAElEpB,EAAOi0B,MAAM9yB,MAAWnB,EAAOmB,MAAQ0yB,iBAAlB,KACrB7zB,EAAOi0B,MAAM7yB,OAAYpB,EAAOoB,OAASyyB,iBAAnB,KAClBnJ,GAAU2M,GACVnjB,EAAO,IAAIvR,MAAM,0CAErB80B,EAASz3B,EAAQmzB,EAAezwB,EAAU+vB,EAAmBW,GAAiB9pB,KAAKD,EACvF,CACA,SAASqL,EAAcxK,EAAOxB,GAC1BiM,QAAQzK,MAAMA,EAAOxB,GACrBwL,EAAOhK,EACX,CAQA,MAAMvB,EAAU,CACZivB,UAAWP,EACX9sB,eAEJ,GAAI8E,EAAU,CACV,MAAMqb,EAASmN,EAAA,GAAMxM,UAAUhc,GAC1Bqb,GACDxW,EAAO,IAAIvR,MAAM,aAAa0M,yBAGlCqoB,EAAgBhN,EADGA,EAAO/f,SAAS,GAEvC,MAEImtB,EAAA,EAAqBC,WApBzB,SAAqBrvB,EAASsvB,EAAcrvB,GACxC,OAAO,IAAA6B,mBAAkB9B,EAASC,GAASW,KAAMvJ,IAC7C23B,EAAgBpyB,KAAKf,KAAMxE,EAAO2I,IAClCwB,IACAwK,EAAcpP,KAAKf,KAAM2F,EAAOxB,IAExC,EAcgDqM,KAAK,KAAMrM,EAAS,KAAMC,GAAU4B,EAAa,CAAE7B,WAAW4B,IAGtH,C,eChEO,SAAS2tB,EAAQve,GACpB,OAAIzW,MAAMC,QAAQwW,GACPA,EAEJ,CAACA,EACZ,CCHA,MAAMsc,GACY,iCADZA,GAEY,iCAEX,MAAMkC,GACT,WAAAl0B,CAAYm0B,EAAQ,QAASpJ,EAAO,IAChCxqB,KAAK4vB,UAAY,EACjB5vB,KAAK6zB,cAAgB,EACrB7zB,KAAK8zB,cAAgB,EACrB9zB,KAAK+zB,KAAO,IAAIr1B,MAChBsB,KAAKg0B,oBAAqB,EAC1Bh0B,KAAK4zB,MAAQA,EACb5zB,KAAKi0B,MAAQzJ,CACjB,CACA,QAAIA,GACA,OAAOxqB,KAAKi0B,KAChB,CACA,QAAIzJ,CAAK7c,GACL3N,KAAK+zB,KAAO,IAAIr1B,MAAMiP,GACtB3N,KAAKi0B,MAAQtmB,EACb3N,KAAK4vB,UAAY,EACjB5vB,KAAK6zB,cAAgB,EACrB7zB,KAAK8zB,cAAgB,CACzB,CACA,WAAII,GACA,OAAOl0B,KAAK8zB,cAAgB,CAChC,CACA,WAAIK,GACA,OAAOn0B,KAAK6zB,cAAgB,CAChC,CACA,IAAAO,CAAKC,EAAQ,GACT,KAAOA,EAAQ,GAAKr0B,KAAK8zB,cAAgB,GAAG,CACxC,MAAM3e,EAAOnV,KAAK+zB,KAAK/zB,KAAK4vB,UAC5B,IAAK,MAAM0E,KAAWZ,EAAQve,GAAMrH,UAChCwmB,EAAQC,aAAY,GACpBv0B,KAAKw0B,qBAAqB,CAAErf,KAAMmf,EAASG,QAAQ,IAEvDJ,IACAr0B,KAAK6zB,gBACL7zB,KAAK8zB,gBACL9zB,KAAK4vB,UAAY5vB,KAAK4vB,SAAW,EAAI5vB,KAAKwqB,MAAQxqB,KAAKwqB,IAC3D,CACJ,CACA,MAAAkK,CAAOC,GACH,SAAI30B,KAAK8zB,cAAgB,GAAKa,EAAU30B,KAAK+zB,KAAK/zB,KAAK4vB,cACnD5vB,KAAKo0B,QACE,EAGf,CACA,oBAAAI,EAAqB,KAAErf,EAAI,OAAEsf,IACrBtf,EAAK9L,IACLurB,EAAA,EAAYC,cAAc,IAAIC,YAAYL,EAAShD,GAAsBA,GAAqB,CAC1FsD,OAAQ,CACJN,SACAprB,GAAI8L,EAAK9L,GACT2rB,cAAe7f,EAAK6f,eAAiB,aACrCC,KAAM9f,KAItB,CACA,IAAA+f,CAAKb,EAAQ,GACT,KAAOA,EAAQ,GAAKr0B,KAAK6zB,cAAgB,GAAG,CACxC,MAAMsB,GAAen1B,KAAK4vB,SAAW,GAAK5vB,KAAKwqB,KACzCrV,EAAOnV,KAAK+zB,KAAKoB,GACvB,IAAK,MAAMb,KAAWZ,EAAQve,GAAMrH,UAChCwmB,EAAQC,aAAY,GACpBv0B,KAAKw0B,qBAAqB,CAAErf,KAAMmf,EAASG,QAAQ,IAEvDJ,IACAr0B,KAAK4vB,SAAWuF,EAChBn1B,KAAK8zB,gBACL9zB,KAAK6zB,eACT,CACJ,CACA,mBAAAuB,GACIp1B,KAAK6zB,cAAgB,EACjB7zB,KAAK8zB,cAAgB9zB,KAAKi0B,OAC1Bj0B,KAAK8zB,gBAET9zB,KAAK4vB,UAAY5vB,KAAK4vB,SAAW,GAAK5vB,KAAKi0B,MAC3Cj0B,KAAK+zB,KAAK/zB,KAAK4vB,UAAY,EAC/B,CACA,mBAAAyF,GACIr1B,KAAKg0B,oBAAqB,EAC1Bh0B,KAAKo1B,qBACT,CACA,uBAAAE,GACIt1B,KAAK+zB,KAAK/zB,KAAK4vB,eAAY5xB,EAC3BgC,KAAK4vB,UAAY5vB,KAAK4vB,SAAW,GAAK5vB,KAAKi0B,MAC3Cj0B,KAAK8zB,eACT,CACA,iBAAAyB,GACIv1B,KAAKg0B,oBAAqB,EAC1B,MAAMwB,EAAWx1B,KAAK+zB,KAAK/zB,KAAK4vB,UACRlxB,MAAMC,QAAQ62B,IAAiC,IAApBA,EAAS50B,QAExDZ,KAAKs1B,yBAEb,CACA,WAAAG,CAAYR,GACR,MAAMS,EAAW11B,KAAK+zB,KAAK/zB,KAAK4vB,UAChC,GAAIlxB,MAAMC,QAAQ+2B,GAEd,OADAA,EAAS/sB,KAAKssB,GACPA,EAEX,MAAM,IAAI72B,MAAM,kDACpB,CACA,IAAAuK,CAAKwM,GACD,IAAKA,EACD,OAEJ,MAAM8f,EAAO9f,EAAKof,YACZpf,EACAA,EAAKwgB,eACX,OAAKV,EAGDj1B,KAAKg0B,mBACEh0B,KAAKy1B,YAAYR,IAE5Bj1B,KAAK6zB,cAAgB,EACjB7zB,KAAK8zB,cAAgB9zB,KAAKi0B,OAC1Bj0B,KAAK8zB,gBAET9zB,KAAK4vB,UAAY5vB,KAAK4vB,SAAW,GAAK5vB,KAAKi0B,MAC3Cj0B,KAAK+zB,KAAK/zB,KAAK4vB,UAAYqF,EACpBA,QAZP,CAaJ,EAEJ,MAAMW,GAAqB,IAAIjC,GC7G/B,SAtBA,SAA4BxvB,EAAS0xB,GACjC,MAAMlvB,GAAmB,IAAAvG,KAAI,mBAAoB+D,GACjD,IAAKwC,EACD,MAAM,IAAIvI,MAAM,0CAA0C+F,KAE9D,MAAM,cAAE0E,EAAa,WAAED,EAAYZ,qBAAsBD,GAAYpB,EACrE,IAAI,mBAAEhJ,EAAkB,gBAAED,GAAoBiJ,EAC9ChJ,IAAuB,EACvBD,IAAoB,EACpB,MAAMo4B,EAAY,cAClB,iBAAiBA,EAAW/tB,EAAQc,GAAgBlL,EAAqB,GACzE,iBAAiBm4B,EAAWA,EAAWltB,GAAalL,EAAkB,GACtE,MAAMq4B,EAAM,cAQZ,OAPA,SAASA,EAAKF,EAAaC,GAGP,CAFA,SAASC,EAAKntB,GAGhBlL,EAFK,SAASq4B,EAAKltB,GAGhBlL,EAGzB,ECrBe,SAASq4B,GAAmB7xB,EAAS8xB,GAChD,MAAMtvB,GAAmB,IAAAvG,KAAI,mBAAoB+D,GACjD,IAAKwC,EACD,MAAM,IAAIvI,MAAM,0CAA0C+F,KAE9D,MAAM,cAAE0E,EAAa,WAAED,EAAYZ,qBAAsBD,GAAYpB,EACrE,IAAI,mBAAEhJ,EAAkB,gBAAED,GAAoBiJ,EAC9ChJ,IAAuB,EACvBD,IAAoB,EACpB,MAAMw4B,EAAqB,cAG3B,OAFA,iBAAiBA,EAAoBnuB,EAAQa,EAAYlL,GAAmBu4B,EAAY,GAAK,KAC7F,iBAAiBC,EAAoBA,EAAoBrtB,EAAelL,GAAsBs4B,EAAY,GAAK,KACxGv3B,MAAM6D,KAAK2zB,EACtB,C,2ECde,SAASC,GAAyBxI,GAC7C,MAAMpG,GAAmB,EAAA4G,EAAA,MACnBvU,EAAY,GASlB,OARA2N,EAAiBtmB,QAAS0Y,IACcA,EAAgByc,eACxBn1B,QAAS/E,IAC7BA,EAASm6B,YAAY1I,IACrB/T,EAAUjR,KAAKzM,OAIpB0d,CACX,C,gBCVe,SAAS0c,GAAkChoB,EAAOpS,GAC7D,MAAMq6B,EAGH,SAAkDjoB,EAAOpS,GAC5D,MAAMkK,EAAWlK,EAASs6B,cACpBC,EAAsBv6B,EAASw6B,yBACrC,GAAwB,IAApBtwB,EAASxF,OACT,OAAO,KAEX,MAAM2a,EAAepX,IACjB,MAAMwyB,EA4Cd,SAA0BxyB,GACtB,MAAMyyB,EAAmBxD,EAAShzB,IAAI,mBAAoB+D,GAC1D,KAAKyyB,GACCA,EAAiBhuB,sBAAsBlK,OACE,IAAvCk4B,EAAiBhuB,WAAWhI,QAC9Bg2B,EAAiB/tB,yBAAyBnK,OACE,IAA1Ck4B,EAAiB/tB,cAAcjI,QACjCg2B,EAAiB5uB,gCAAgCtJ,OACE,IAAjDk4B,EAAiB5uB,qBAAqBpH,QAC1C,OAAO,KAEX,MAAM,WAAEgI,EAAU,cAAEC,EAAa,qBAAEb,GAA0B4uB,EACvDC,EAAS,SAAS,iBAAkBjuB,GACpCkuB,EAAS,SAAS,iBAAkBjuB,GACpCkuB,EAAc,WAAW,cAAeF,EAAQC,GACtD,MAAO,CAAEluB,aAAYC,gBAAeb,uBAAsB+uB,cAC9D,CA5D8BC,CAAiB7yB,GACvC,IAAKwyB,EACD,OAAO,KAEX,MAAMM,EAAQ1iB,GAAO2iB,cAAcP,EAAcI,YAAaJ,EAAc3uB,sBAE5E,OADiBuM,GAAO4iB,qBAAqBF,EAAO3oB,IAGlD8oB,EAAe,CACjBpb,SAAUT,EAAYnV,EAASqwB,KAAyB9f,IACxDnO,MAAOiuB,GAELY,EAAiBjxB,EAAS1F,MAAM+1B,EAAsB,GAC5D,IAAK,IAAI/sB,EAAI,EAAGA,EAAI2tB,EAAez2B,OAAQ8I,IAAK,CAC5C,MACMsS,EAAWT,EADN8b,EAAe3tB,IAE1B,GAAiB,OAAbsS,EAAJ,CAGA,KAAIA,GAAYob,EAAapb,UAKzB,MAJAob,EAAapb,SAAWA,EACxBob,EAAa5uB,MAAQkB,EAAI+sB,EAAsB,CAHnD,CAQJ,CACA,MAAMa,EAAgBlxB,EAAS1F,MAAM,EAAG+1B,GACxC,IAAK,IAAI/sB,EAAI4tB,EAAc12B,OAAS,EAAG8I,GAAK,EAAGA,IAAK,CAChD,MACMsS,EAAWT,EADN+b,EAAc5tB,IAEzB,GAAiB,OAAbsS,GAAqBA,IAAaob,EAAapb,SAAnD,CAGA,KAAIA,EAAWob,EAAapb,UAKxB,MAJAob,EAAapb,SAAWA,EACxBob,EAAa5uB,MAAQkB,CAHzB,CAQJ,CACA,OAAO0tB,EAAapb,WAAarF,IAAW,KAAOygB,CACvD,CArD4BG,CAAyCjpB,EAAOpS,GACxE,OAAOq6B,EAAkBA,EAAgB/tB,MAAQ,IACrD,C,gBCJA,SAASgvB,GAA8Bt7B,GACnC,MAAQU,MAAO66B,EAAa56B,OAAQ66B,GAAiBx7B,EAAS4N,aACxD,mBAAE6tB,EAAkB,mBAAEC,GAAuB17B,EAAS27B,mBACtDC,GAAiB,EAAAC,GAAA,GAAqB77B,EAAU,CAAC,EAAG,IACpD87B,GAAc,EAAAD,GAAA,GAAqB77B,EAAU,CAACu7B,EAAc,EAAG,IAC/DQ,GAAc,EAAAF,GAAA,GAAqB77B,EAAU,CAAC,EAAGw7B,EAAe,IAChEQ,EAAY,SAAS,cAAeF,EAAaF,GACjDK,EAAY,SAAS,cAAeF,EAAaH,GACjDM,EAAc,WAAW,cAAeF,EAAWC,GACzD,eAAeD,EAAWA,GAC1B,eAAeC,EAAWA,GAC1B,eAAeC,EAAaA,GAC5B,MAAMC,EAAep7B,KAAKkS,IAAIlS,KAAK6e,IAAIoc,EAAU,IAAKj7B,KAAK6e,IAAIoc,EAAU,IAAKj7B,KAAK6e,IAAIoc,EAAU,KAC3FI,EAAer7B,KAAKkS,IAAIlS,KAAK6e,IAAIqc,EAAU,IAAKl7B,KAAK6e,IAAIqc,EAAU,IAAKl7B,KAAK6e,IAAIqc,EAAU,KACjG,IAAK,YAAgB,EAAGE,KAAkB,YAAgB,EAAGC,GACzD,MAAM,IAAIl6B,MAAM,0DAEpB,MAAM,aAAE4G,GAAiB9I,EAASq8B,eAC5BC,EAAgBt8B,EAAS27B,mBACzB1yB,EAAaH,EAAayzB,aAAaD,GAC7C,MAAO,CACH57B,MAAO47B,EAAc57B,MACrBC,OAAQ27B,EAAc37B,OACtBsI,aACAwyB,qBACAC,qBAER,CC3BA,MAAM,GAAQ,CAAC,EACTc,GAAsC,CACxCp1B,IAAK,CAACymB,EAAOL,KACT,MAAOiP,EAAaC,GAAe7O,EAC7B8O,EAAU,GAAGF,KAAeC,IAC7B,GAAMC,KACP,GAAMA,GAAW,CAAC,GAEtB,GAAMA,GAAWnP,GAErBtpB,IAAK,CAAC0G,EAAM6xB,EAAaC,KACrB,GAAa,8BAAT9xB,EACA,OAEJ,MAAM+xB,EAAU,GAAGF,KAAeC,IAClC,GAAI,GAAMC,GACN,OAAO,GAAMA,GAEjB,MAAMC,EAAiB,GAAGF,KAAeD,IACzC,OAAI,GAAMG,GACC,YAAY,cAAe,GAAMA,SAD5C,KAKR,IAAA9O,aAAY0O,GAAoCt4B,IAAIoQ,KAAKkoB,KACzD,YCFA,SArBA,SAA+CK,EAAWC,GACtD,MAAMC,EAAWF,EAAUG,gBACrBC,EAAWH,EAAUE,gBACrBE,GAAoB,IAAAh5B,KAAI,mBAAoB64B,EAASjY,YACrDqY,GAAoB,IAAAj5B,KAAI,mBAAoB+4B,EAASnY,YAC3D,IAAKoY,IAAsBC,EAEvB,YADAjpB,QAAQ6Q,IAAI,6DAGhB,MAAQ/Y,wBAAyBoxB,GAASD,EAE1C,IADyBD,EAAkBlxB,wBAAwBqmB,MAAM,CAAC9e,EAAG/F,IAAMzM,KAAK6e,IAAIrM,EAAI6pB,EAAK5vB,IAXnF,KAcd,YADA0G,QAAQ6Q,IAAI,qGAAsGmY,GAAmBlxB,wBAAyBmxB,GAAmBnxB,yBAGrL,MAAMqxB,EAAwBH,EAAkBpxB,qBAC1CwxB,EAAwBH,EAAkBrxB,qBAC1CjK,EAAc,cAAc,cAAew7B,EAAuBC,GAClEC,EAAM,qBAAqB,cAAe17B,GAChD,GAAoCuF,IAAI,CAACy1B,EAAU1vB,GAAI2vB,EAAU3vB,IAAKowB,EAC1E,ECxBe,SAASC,GAA+Bx9B,GACnD,MAAM,UAAEyoB,EAAS,WAAE9c,GAAe3L,EAASq8B,gBAAkB,CAAC,EAC9D,IAAK5T,IAAc9c,EACf,MAAO,GAEX,MAAM,OAAEpM,GAAWS,EACby9B,EAAQpK,OAAOD,iBAEfsK,EAAiB,CAACn+B,EAAOmB,MAAQ+8B,EAAO,GACxCE,EAAoB,CACtBp+B,EAAOmB,MAAQ+8B,EACfl+B,EAAOoB,OAAS88B,GAEdG,EAAmB,CAAC,EAAGr+B,EAAOoB,OAAS88B,GACvCI,EAAe79B,EAASk1B,cAPR,CAAC,EAAG,IAQpB4I,EAAgB99B,EAASk1B,cAAcwI,GACvCK,EAAmB/9B,EAASk1B,cAAcyI,GAC1CK,EAAkBh+B,EAASk1B,cAAc0I,GACzCK,EAAexV,EAAUyV,aAAaL,GACtCM,EAAgB1V,EAAUyV,aAAaJ,GACvCM,EAAmB3V,EAAUyV,aAAaH,GAC1CM,EAAkB5V,EAAUyV,aAAaF,GAC/C,OAaJ,UAAuC,WAAEryB,EAAU,UAAE8c,EAAS,aAAEwV,EAAY,cAAEE,EAAa,iBAAEC,EAAgB,gBAAEC,EAAe,aAAER,EAAY,cAAEC,EAAa,iBAAEC,EAAgB,gBAAEC,IAC3K,MAAMM,EAAoBC,GAAYN,EAActyB,GAC9CkyB,EACApV,EAAUO,aAAa,CAAC,EAAG,EAAG,IAC9BwV,EAAqBD,GAAYJ,EAAexyB,GAChDmyB,EACArV,EAAUO,aAAa,CAACrd,EAAW,GAAK,EAAG,EAAG,IAC9C8yB,EAAwBF,GAAYH,EAAkBzyB,GACtDoyB,EACAtV,EAAUO,aAAa,CACrBrd,EAAW,GAAK,EAChBA,EAAW,GAAK,EAChB,IAEF+yB,EAAuBH,GAAYF,EAAiB1yB,GACpDqyB,EACAvV,EAAUO,aAAa,CAAC,EAAGrd,EAAW,GAAK,EAAG,IACpD,MAAO,CACH2yB,EACAE,EACAE,EACAD,EAER,CApCWE,CAA8B,CACjChzB,aACA8c,YACAwV,eACAE,gBACAC,mBACAC,kBACAR,eACAC,gBACAC,mBACAC,mBAER,CAyBA,SAASO,GAAYK,EAAYjzB,GAC7B,OAAQizB,EAAW,GAAK,GACpBA,EAAW,GAAKjzB,EAAW,GAAK,GAChCizB,EAAW,GAAK,GAChBA,EAAW,GAAKjzB,EAAW,GAAK,GAChCizB,EAAW,GAAK,GAChBA,EAAW,GAAKjzB,EAAW,GAAK,CACxC,C,wFCrDA,SAXA,SAAwBsnB,GACpB,MAAM7zB,GAAiB,EAAAy/B,GAAA,IAAkB5L,GACzC,IAAK7zB,EACD,OAEJ,MAAM,SAAEY,GAAaZ,EACrB,KAAMY,aAAoB8+B,GAAA,GACtB,MAAM,IAAI58B,MAAM,qFAAqFlC,EAAS4K,QAElH,OAAO5K,EAAS++B,qBACpB,E,mDCVA,SAASC,GAAc90B,GACnB,GAAIA,EAASxF,QAAU,EACnB,OAAO,EAEX,MAAMu6B,EAAW/0B,EAAS,IACpB,SAAEjI,EAAQ,kBAAEi9B,GAAsBhI,EAAShzB,IAAI,sBAAuB+6B,IACtE,wBAAEjzB,EAAuB,aAAEY,EAAY,oBAAEX,EAAmB,QAAEnJ,EAAO,KAAEC,EAAI,mBAAEo8B,GAAwBjI,EAAShzB,IAAI,mBAAoB+6B,GAC5I,GAAIE,EACA,OAAO,EAEX,MAAMC,EAAe,CACjBn9B,WACA+J,0BACAY,eACAX,sBACAnJ,UACAC,OACAm8B,qBAEJ,IAAIG,GAAc,EAClB,IAAK,IAAI7xB,EAAI,EAAGA,EAAItD,EAASxF,OAAQ8I,IAAK,CACtC,MAAMvF,EAAUiC,EAASsD,IACnB,SAAEvL,EAAQ,kBAAEi9B,GAAsBhI,EAAShzB,IAAI,sBAAuB+D,IACtE,wBAAE+D,EAAuB,aAAEY,EAAY,QAAE9J,EAAO,KAAEC,GAASm0B,EAAShzB,IAAI,mBAAoB+D,GAClG,GAAIi3B,IAAsBE,EAAaF,kBAAmB,CACtDG,GAAc,EACd,KACJ,CACA,GAAIp9B,IAAam9B,EAAan9B,SAAU,CACpCo9B,GAAc,EACd,KACJ,CACA,GAAIv8B,IAAYs8B,EAAat8B,QAAS,CAClCu8B,GAAc,EACd,KACJ,CACA,GAAIt8B,IAASq8B,EAAar8B,KAAM,CAC5Bs8B,GAAc,EACd,KACJ,CACA,KAAK,EAAAC,GAAA,IAAQtzB,EAAyBozB,EAAapzB,yBAA0B,CACzEqzB,GAAc,EACd,KACJ,CACA,KAAK,EAAAC,GAAA,IAAQ1yB,EAAcwyB,EAAaxyB,cAAe,CACnDyyB,GAAc,EACd,KACJ,CACJ,CACA,OAAOA,CACX,C,oDCpDO,MAAME,GAAY,IAAIC,IAAI,CAC7B,0BACA,4BACA,0BACA,4BACA,0BACA,4BACA,0BACA,4BACA,0BACA,4BACA,0BACA,4BACA,0BACA,4BACA,0BACA,4BAEW,SAASC,GAAsBC,GAC1C,IAAKA,EACD,OAAO,EAGX,OADal9B,MAAMC,QAAQi9B,GAAaA,EAAY,CAACA,IACzCle,KAAMoF,GAAQ2Y,GAAUp4B,IAAIyf,GAC5C,C,mDCpBA+Y,eAAeC,IAA6B,SAAE5/B,EAAQ,QAAEkI,EAAU,CAAC,IAC/D,MAAMuV,EAAkBzd,EAASiyB,qBACjC,IAAIrjB,EAAW1G,EAAQ0G,UAAY,IAAG,EAAAixB,EAAA,OACtC,GAAmC,IAA/BjxB,EAAS1I,MAAM,KAAKxB,OAAc,CAElCkK,EAAW,IADI,KAAAkxB,mCACSlxB,GAC5B,CACA,MAAM,GAAEzB,EAAE,QAAE8lB,GAAYjzB,EAClBgzB,EAAa9qB,EAAQ8qB,YAAc7lB,EACnCjD,EAAWlK,EAASs6B,cACpByF,EAAuB//B,EAASggC,sBAChCC,EAAoBjgC,EAASkgC,mBACnCziB,EAAgBgX,cAAc,CAC1BzB,aACApoB,KAAM,EAAAwpB,aAAaC,aACnBpB,UACAsB,eAAgB,CACZ4L,WAAYj4B,EAAQi4B,WACpBC,YAAal4B,EAAQk4B,sBAGP,KAAAC,sBAAqBzxB,EAAU,CACjD1E,cAEGo2B,OACP,MAAMC,EAAiB9iB,EAAgByW,YAAYlB,SAC7C,SAAuBvV,EAAiB,CAC1C,CACI7O,aAEL,CAACokB,IACJ,MAAMwN,EAAiC,KACnCD,EAAexgC,SACfkzB,EAAQrE,oBAAoB,EAAA2G,OAAOkL,2BAA4BD,IASnE,OANIvN,EAAQ1E,iBAAiB,EAAAgH,OAAOkL,2BAA4BD,GAGhED,EAAeG,oBAAoBX,GACnCQ,EAAexL,iBAAiBkL,GAChCM,EAAexgC,SACRwgC,CACX,C,gBC5CAZ,eAAegB,IAA6B,SAAE3gC,EAAQ,QAAEkI,IACpD,MAAMq4B,EAAiBvgC,GACjB,GAAEmN,EAAE,QAAE8lB,GAAYsN,EAClB9iB,EAAkBzd,EAASiyB,sBAC3B,WAAEkO,GAAej4B,EACjB8qB,EAAa9qB,EAAQ8qB,YAAc7lB,EACnC8c,EAASmN,EAAA,GAAMxM,UAAU2V,EAAe/T,eAC9C,KAAMvC,aAAkB2W,GAAA,GACpB,MAAM,IAAI1+B,MAAM,+KAEpB,MAAMiyB,EAAgB,CAClBnB,aACApoB,KAAM,EAAAwpB,aAAaE,MACnBrB,UACAsB,eAAgB,CACZ4L,eAGFU,EAAWN,EAAeL,mBAChCziB,EAAgBgX,cAAcN,GAC9B,MAAM2M,EAAgBrjB,EAAgByW,YAAYlB,GAIlD,aAHM8N,EAAcC,SAAS9W,EAAO/f,UACpC42B,EAAc/L,iBAAiB8L,GAC/BC,EAAc/gC,SACP+gC,CACX,C,wCCAA,SAASE,GAAiBj9B,GACtB,OAAOhD,KAAKgmB,MAAMhjB,EAAQ,GAAA0hB,SAAW,GAAAA,OACzC,CAEA,SA/BA,SAASwb,EAAYl9B,EAAOm9B,EAAY,GACpC,GAAI1+B,MAAMC,QAAQsB,GACd,OAAOA,EAAMoG,IAAKoJ,GAAM0tB,EAAY1tB,EAAG2tB,IAAY1P,KAAK,MAE5D,GAAIztB,SAAmD,KAAVA,EACzC,MAAO,MAEXA,EAAQ+L,OAAO/L,GACf,MAAMo9B,EAAWpgC,KAAK6e,IAAI7b,GAC1B,GAAIo9B,EAAW,KACX,MAAO,GAAGp9B,IAEd,MAAMq9B,EAAiBD,GAAY,IAC7BD,EAAY,EACZC,GAAY,GACRD,EAAY,EACZC,GAAY,EACRD,EACAC,GAAY,GACRD,EAAY,EACZC,GAAY,IACRD,EAAY,EACZC,GAAY,KACRD,EAAY,EACZA,EAAY,EACtC,OAAOn9B,EAAMs9B,QAAQD,EACzB,EC3Be,SAASE,GAAmBr4B,EAAYvI,EAAOC,GAC1D,MAAM4gC,EAASt4B,EAAWvE,SAAWhE,EAAQC,EAAS,EAChD6gC,EAAQv4B,EAAWvE,SAAWhE,EAAQC,EAAS,EACrD,GAAI4gC,GAAUC,EAAO,CACjB,MAAMC,EAAgB,IAAI10B,aAAarM,EAAQC,GAC/C,IAAIyQ,EAAS,EACTswB,EAAa,EACjB,MAAMC,EAAYJ,EAAS,EAAI,EAC/B,IAAK,IAAIngC,EAAI,EAAGA,EAAIV,EAAOU,IACvB,IAAK,IAAIE,EAAI,EAAGA,EAAIX,EAAQW,IAAK,CAC7B,MAAMwZ,EAAI7R,EAAWmI,GACf2J,EAAI9R,EAAWmI,EAAS,GACxB4J,EAAI/R,EAAWmI,EAAS,GAC9BqwB,EAAcC,IAAe5mB,EAAIC,EAAIC,GAAK,EAC1C5J,GAAUuwB,EACVD,GACJ,CAEJ,OAAOD,CACX,CAEI,OAAOx4B,CAEf,C,gBCZA,SATA,SAA6BjJ,GACzB,GAAIA,aAAoB,MAAgB,CAEpC,OADeo3B,EAAA,GAAMxM,UAAU5qB,EAASwsB,eAC1BtiB,QAClB,CACK,GAAIlK,EAASs6B,YACd,OAAOt6B,EAASs6B,aAExB,ECVO,SAASsH,GAAyB9wB,EAAOwd,GAC5C,MAAMuT,EAAc,IAAI/wB,GACxB,OAAIwd,GAAQuT,EAAYn9B,QACpBo9B,GAAaD,GACNA,IAEXC,GAAaD,GACNA,EAAYr9B,MAAM,EAAG8pB,GAChC,CACA,SAASwT,GAAahxB,GAClB,IAAK,IAAItD,EAAIsD,EAAMpM,OAAS,EAAG8I,EAAI,EAAGA,IAAK,CACvC,MAAMuI,EAAIhV,KAAK+Q,MAAM/Q,KAAKghC,UAAYv0B,EAAI,KACzCsD,EAAMtD,GAAIsD,EAAMiF,IAAM,CAACjF,EAAMiF,GAAIjF,EAAMtD,GAC5C,CACJ,C,2ECdA,SAASw0B,GAAeC,GACpB,MAAMC,EAAMD,EAAEnd,SAAS,IACvB,OAAqB,GAAdod,EAAIx9B,OAAc,IAAMw9B,EAAMA,CACzC,CACA,SAASC,GAASrnB,EAAGC,EAAGC,GACpB,MAAO,IAAMgnB,GAAelnB,GAAKknB,GAAejnB,GAAKinB,GAAehnB,EACxE,CACA,SAASonB,GAASF,GACd,MAAMG,EAAS,4CAA4CC,KAAKJ,GAChE,OAAOG,EACD,CACEvnB,EAAGynB,SAASF,EAAO,GAAI,IACvBtnB,EAAGwnB,SAASF,EAAO,GAAI,IACvBrnB,EAAGunB,SAASF,EAAO,GAAI,KAEzB,IACV,CChBO,SAASG,GAAUC,EAAMC,GAC5B,GAAID,IAASC,EACT,OAAO,EAEX,GAAY,MAARD,GAAwB,MAARC,EAChB,OAAO,EAEX,IACI,OAAOC,KAAKC,UAAUH,KAAUE,KAAKC,UAAUF,EACnD,CACA,MAAOj5B,GAEH,OADAyK,QAAQqM,MAAM,kDAAmD9W,GAC1Dg5B,IAASC,CACpB,CACJ,C,oDCaA,SAASG,GAAUC,EAAWC,GAC1B,MAAMC,EAAe,CAAC,EACtB,IAAIC,EAAwB,GAC5B,MAAMC,EAAYx/B,OAAO4B,KAAKw9B,GAC9B,IAAK,IAAIt1B,EAAI,EAAGA,EAAI01B,EAAUx+B,OAAQ8I,IAAK,CACvC,MAAM21B,EAAkB,IAAI3D,IACtB4D,EAASN,EAAUI,EAAU11B,IACnC,IAAK,IAAIuI,EAAI,EAAGA,EAAIqtB,EAAO1+B,OAAQqR,IAAK,CACpC,MAAMstB,EAAcN,EAAaK,EAAOrtB,GAAG9N,UAAY,EAIvD,GAHA+6B,EAAaK,GAAeL,EAAaK,IAAgB,GACzDL,EAAaK,GAAa52B,KAAK,CAAExE,QAASm7B,EAAOrtB,GAAG9N,UACpDk7B,EAAgB/7B,IAAIi8B,GAChBF,EAAgB7U,KAAO,EAAIvY,EAC3B,MAER,CACA,GAAS,GAALvI,EACAy1B,EAAwBzgC,MAAM6D,KAAK88B,QAElC,IAAKG,GAAUL,EAAuBE,GACvC,MAER,CACA,OAAOH,CACX,CACA,SAASO,GAAYt7B,EAASu7B,GAC1B,MAAMz/B,EAAQmzB,EAAShzB,IAAIs/B,EAAKv7B,GAChC,IACI,OAAOsS,WAAWxW,EACtB,CACA,MACI,MACJ,CACJ,CACA,SAAS0/B,GAAwBx7B,GAC7B,MAAMlE,EAAQmzB,EAAShzB,IAAI,WAAY+D,GACvC,IACI,MAAM,aAAEy7B,GAAiB3/B,EACzB,GAAI2/B,EAAc,CACd,MAAMC,EAAcC,KAAKF,GACnBG,EAAU,IAAI9yB,YAAY4yB,EAAYj/B,QACtCo/B,EAAK,IAAIC,SAASF,GACxB,IAAK,IAAIr2B,EAAI,EAAGA,EAAIm2B,EAAYj/B,OAAQ8I,IACpCs2B,EAAGE,SAASx2B,EAAGm2B,EAAY9e,WAAWrX,IAE1C,OAAO,IAAIT,aAAa82B,GAAS,EACrC,CACA,OAAOtpB,WAAWxW,EACtB,CACA,MACI,MACJ,CACJ,CACA,SAASkgC,GAAwBh8B,GAC7B,IAAIlE,EAAQmzB,EAAShzB,IAAI,WAAY+D,IAAYivB,EAAShzB,IAAI,WAAY+D,GAC1E,IACI,MAAM,aAAEy7B,GAAiB3/B,EAIzB,OAHI2/B,IACA3/B,EAAQ6/B,KAAKF,IAEVnpB,WAAWxW,EACtB,CACA,MACI,MACJ,CACJ,CACA,SAASmgC,GAAmBj8B,GACxB,IAAIlE,EAAQmzB,EAAShzB,IAAI,WAAY+D,GACrC,IACI,MAAM,aAAEy7B,GAAiB3/B,EAIzB,OAHI2/B,IACA3/B,EAAQ6/B,KAAKF,GAAcx9B,MAAM,OAE9BqU,WAAWxW,EAAM,IAAM,GAClC,CACA,MACI,MACJ,CACJ,CACA,SAASu/B,GAAUa,EAAOC,GACtB,GAAID,EAAMz/B,QAAU0/B,EAAM9V,KACtB,OAAO,EAEX,IAAK,IAAI9gB,EAAI,EAAGA,EAAI22B,EAAMz/B,OAAQ8I,IAC9B,IAAK42B,EAAMj9B,IAAIg9B,EAAM32B,IACjB,OAAO,EAGf,OAAO,CACX,CACA,SAAS62B,GAAyBp8B,GAC9B,MAAMq8B,EAAapN,EAAShzB,IAAI,iBAAkB+D,GAClD,OAAOq8B,EAAaA,EAA+B,mBAAI,CAC3D,CAwCA,SAvCA,SAA+Bp6B,GAC3B,MAAMq6B,EAnHV,SAAsBr6B,GAClB,MAAMs6B,EAAct6B,EAASC,IAAKlC,IAC9B,MAAM,qBAAE6D,GAAyBorB,EAAShzB,IAAI,mBAAoB+D,IAAY,CAAC,EAC/E,MAAO,CAAEA,UAAS6D,0BAEtB,IAAK04B,EAAYnS,MAAOpZ,GAASA,EAAKnN,sBAClC,OAAO,KAEX,MAAMy4B,GAdctgC,EAcwB,uBAAbugC,EAblBC,OAAO,CAACC,EAAItjC,MACpBsjC,EAAGtjC,EAAE6C,IAAQygC,EAAGtjC,EAAE6C,KAAS,IAAIwI,KAAKrL,GAC9BsjC,GACR,CAAC,IAJQ,IAAQzgC,EAepB,MAAMi/B,EAAYx/B,OAAO4B,KAAKi/B,GACxBI,EAAcJ,EAAerB,EAAU,IAAIx+B,OACjD,OAAoB,IAAhBigC,EACO,KAEezB,EAAU7Q,MAAOlc,GAAMouB,EAAepuB,GAAGzR,SAAWigC,GAIvEJ,EAFI,IAGf,CAgG2BK,CAAa16B,GACpC,IAAKq6B,EACD,MAAO,CAAEM,cAAe,CAAC36B,GAAW46B,aAAc,MAEtD,MAAMC,EAAO,CACT,6BACA,kBACA,cACA,WACA,aACA,uBACA,uBACA,kBACA,yBAEEC,EAAW,CACZ/8B,GAAYs7B,GAAYt7B,EAAS88B,EAAK,IACtC98B,GAAYs7B,GAAYt7B,EAAS88B,EAAK,IACtC98B,GAAYs7B,GAAYt7B,EAAS88B,EAAK,IACtC98B,GAAYs7B,GAAYt7B,EAAS88B,EAAK,IACtC98B,GAAYs7B,GAAYt7B,EAAS88B,EAAK,IACvCtB,GACAQ,GACAC,GACAG,IAEJ,IAAK,IAAI72B,EAAI,EAAGA,EAAIw3B,EAAStgC,OAAQ8I,IAAK,CACtC,MAAMw1B,EAAeH,GAAU0B,EAAgBS,EAASx3B,IACxD,GAAIw1B,EAAc,CAKd,MAAO,CAAE6B,cAJUnhC,OAAO4B,KAAK09B,GAC1B74B,IAAI2F,OAAOyK,YACXwF,KAAK,CAACC,EAAGhF,IAAMgF,EAAIhF,GACS7Q,IAAKlG,GAAQ++B,EAAa/+B,GAAKkG,IAAK8O,GAASA,EAAKhR,UAC3D68B,aAAcC,EAAKv3B,GAC/C,CACJ,CACA,MAAO,CAAEq3B,cAAe,CAAC36B,GAAW46B,aAAc,KACtD,ECzJA,SALA,SAA8B56B,GAC1B,MAAQ26B,cAAeI,EAAU,aAAEH,GAAiB,GAAsB56B,GAE1E,MAAO,CAAEg7B,gBADeD,EAAWvgC,OAAS,EAClBugC,aAAYH,eAC1C,E,gBCLe,SAASK,GAAWr0B,EAAOsW,GACtC,MAAMge,EAAct0B,EAAMpM,QACpB,aAAE2iB,EAAY,iBAAEC,EAAgB,MAAEE,GAAUJ,EAClD,GAAmC,OAA/BA,EAAkBnlB,UAAsC,iBAAVulB,EAC9C,IAAK,IAAIha,EAAI,EAAGA,EAAI43B,EAAa53B,IAC7BsD,EAAMtD,GAAKga,GAAS1W,EAAMtD,GAAK6Z,EAAeC,QAIlD,IAAK,IAAI9Z,EAAI,EAAGA,EAAI43B,EAAa53B,IAC7BsD,EAAMtD,GAAKsD,EAAMtD,GAAK6Z,EAAeC,EAG7C,OAAOxW,CACX,C,gBCdO,SAASu0B,GAAKC,EAAKC,EAAKC,GAC3B,OAAOzkC,KAAKa,IAAIb,KAAKkS,IAAIsyB,EAAKD,GAAME,EACxC,CAKA,YCAe,SAAS,GAAOxlC,EAAUkI,GAErC,KADuB,EAAA22B,GAAA,IAAkB7+B,EAASizB,SAE9C,MAAM,IAAI/wB,MAAM,0DAEpB,GAAIlC,aAAoB,OACc,IAAlCA,EAASs6B,cAAc51B,OACvB,MAAM,IAAIxC,MAAM,wCAEpB,MAAM,SAAE0M,EAAQ,MAAEyK,EAAK,YAAEosB,GAAgBv9B,EACzC,GAAIlI,aAAoB,OAiBrB,SAAsBA,EAAU4O,EAAUyK,EAAOosB,GAAc,GAClE,MAAMlb,EAAmBkb,GACnB,eAAE/Y,EAAc,iBAAEE,EAAgB,eAAEC,IAAmB,EAAA6Y,GAAA,GAA4B1lC,EAAU4O,EAAU2b,GAC7G,IAAKsC,EACD,OAEJ,MAAM,WAAEhG,EAAU,yBAAEL,EAAwB,OAAEF,GAAWuG,GACnD,WAAEpG,EAAU,gBAAEpB,EAAe,SAAEqO,GAAapN,GAC5C,cAAEqf,EAAa,YAAE1M,IAAgB,EAAA2M,GAAA,GAAsBnf,EAAYiN,EAAU7M,EAAYxB,EAAiBmB,EAA0BnN,GAC1IrZ,EAAS6lC,UAAU,CACfpf,WAAYkf,EACZjS,SAAUuF,IAEdj5B,EAASD,SACT,MAAM+lC,EAAmBlZ,EAAmBvT,EACtC0sB,EAA0B,CAC5Bn3B,WACA5O,WACAqZ,QACAysB,mBACAlZ,mBACAF,iBACAsZ,eAAgBhmC,EAASimC,sBAExBH,EAAmBpZ,GAAkBoZ,EAAmB,IACzD9lC,EAASimC,qBACT,EAAAC,EAAA,GAAaxN,EAAA,EAAa,EAAAnD,OAAO4Q,qCAAsCJ,IAGvE,EAAAG,EAAA,GAAaxN,EAAA,EAAa,EAAAnD,OAAO6Q,uBAAwBL,EAEjE,CA/CQM,CAAarmC,EAAU4O,EAAUyK,EAAOosB,OAEvC,CACD,MAAMlO,EAAev3B,EAASw6B,yBAC9B,GAAIjD,EAAele,EACfrZ,EAASs6B,cAAc51B,OAAS,GAChC6yB,EAAele,EAAQ,EAAG,CAC1B,MAAMitB,EAAY,CACd/O,eACAxrB,UAAWsN,IAEf,EAAA6sB,EAAA,GAAaxN,EAAA,EAAa,EAAAnD,OAAOgR,2BAA4BD,EACjE,CACAtmC,EAASwmC,OAAOntB,EAAOnR,EAAQu+B,gBAAiBv+B,EAAQw+B,KAC5D,CACJ,CC7BA/G,eAAegH,GAAY1T,EAAS/qB,EAAU,CAAC,GAC3C,MAAM,WAAE8e,EAAU,gBAAEyf,EAAe,SAAE73B,GAAa1G,EAC5C9I,GAAiB,EAAAy/B,GAAA,IAAkB5L,GACzC,IAAK7zB,EACD,MAAM,IAAI8C,MAAM,6BAEpB,MAAM,SAAElC,GAAaZ,GACb4nB,WAAY4f,EAAiB,eAAE9f,GAK3C,SAA4B9mB,EAAUymC,GAClC,GAAIzmC,aAAoB8+B,GAAA,EACpB,MAAO,CACHhY,eAAgB9mB,EAASs6B,cAAc51B,OACvCsiB,WAAYyf,EACNzmC,EAAS6mC,wBACT7mC,EAASw6B,0BAGvB,MAAO,CACH1T,eAAgB9mB,EAAS8mC,oBACzB9f,WAAYhnB,EAASg9B,gBAE7B,CAlB8D+J,CAAmB/mC,EAAUymC,GACjFO,EAkBV,SAA8BlgB,EAAgBE,GAC1C,MAAMigB,EAAiBngB,EAAiB,EACxC,OAAO,GAAKE,EAAY,EAAGigB,EAC/B,CArB6BC,CAAqBpgB,EAAgBE,GAE9D,GAAOhnB,EAAU,CAAEqZ,MADL2tB,EAAmBJ,EACPH,kBAAiB73B,YAC/C,CCVA,SAASu4B,GAAgBC,EAAoBpuB,EAAW9Q,EAAU,CAAC,GAC/D,MAAMm/B,EAAmBjQ,EAAA,GAAMxM,UAAUwc,GACzC,IAAKC,EACD,MAAM,IAAInlC,MAAM,6BAA6BklC,qBAEjD,MAAM,SAAEp8B,EAAQ,QAAEY,EAAO,UAAEG,EAAWJ,WAAY27B,GAAkBD,GAC9D,KAAE7d,EAAI,KAAEC,EAAI,KAAE8d,EAAI,KAAEC,EAAI,KAAEC,EAAI,KAAEC,GAAS1uB,EACzC2uB,EAAa,CACf5mC,KAAKa,IAAI4nB,EAAMC,GACf1oB,KAAKa,IAAI2lC,EAAMC,GACfzmC,KAAKa,IAAI6lC,EAAMC,IAEbE,GAAyB,EAAAC,EAAA,GAAsBR,EAAiB5e,UAAWkf,GAC3Eh8B,EAAa,CACf5K,KAAK6e,IAAI6J,EAAOD,GAAQ,EACxBzoB,KAAK6e,IAAI4nB,EAAOD,GAAQ,EACxBxmC,KAAK6e,IAAI8nB,EAAOD,GAAQ,IAEtB,aAAE98B,GAAiBzC,EACnB4/B,EAAmB,CACrB98B,WACAW,aACAC,UACAC,OAAQ+7B,EACR77B,YACApB,eACA1B,WAAmC,iBAAvB0B,GAAcC,KACpB,IAAImC,aAAapB,EAAW,GAAKA,EAAW,GAAKA,EAAW,SAC5D7J,GAEJimC,GAAY,KAAAC,oBAAkB,EAAAnI,EAAA,KAAUiI,GACxCG,EAAgBF,EAAUj/B,aAAao/B,6BACvCC,EAAqBx8B,EAAW,GAAKA,EAAW,GAChDy8B,EAAqBd,EAAa,GAAKA,EAAa,GACpDe,EAAgBhB,EAAiBv+B,aAAao/B,6BACpD,IAAK,IAAIv1B,EAAI,EAAGA,EAAIhH,EAAW,GAAIgH,IAC/B,IAAK,IAAIrR,EAAI,EAAGA,EAAIqK,EAAW,GAAIrK,IAAK,CACpC,MAAMgnC,GAAgB,EAAAT,EAAA,GAAsBE,EAAUtf,UAAW,CAC7D,EACAnnB,EACAqR,IAEE41B,GAAuB,EAAAC,EAAA,GAAsBnB,EAAiB5e,UAAW6f,GACzEG,EAA0BF,EAAqB,GAAKH,EACtDG,EAAqB,GAAKjB,EAAa,GACvCiB,EAAqB,GACnBG,EAAUL,EAAc7jC,MAAMikC,EAAyBA,EAA0B98B,EAAW,IAC5Fg9B,EAA2Bh2B,EAAIw1B,EAAqB7mC,EAAIqK,EAAW,GACzEs8B,EAAcjkC,IAAI0kC,EAASC,EAC/B,CAGJ,OADAZ,EAAUj/B,aAAa8/B,2BAA2BX,GAC3CF,CACX,CCxDA,SAASc,GAA0BpgB,EAAWnC,GAC1C,MAAM,OAAEwiB,EAAM,gBAAEzjB,GAAoBiB,EAC9ByiB,GAAY,EAAAP,EAAA,GAAgC/f,EAAW,CAAC,EAAG,EAAG,IAC9DugB,EAAiB,YAAY,cAAeF,GAC5CG,EAAmB,YAAY,cAAe5jB,GAC9C6jB,EAAiB,WAAW,cAAeF,EAAgBC,GAC3DE,EAAe,SAAS,eAAe,EAAAX,EAAA,GAAgC/f,EAAWugB,GAAiBD,GACnGK,EAAiB,SAAS,eAAe,EAAAZ,EAAA,GAAgC/f,EAAWwgB,GAAmBF,GAC7G,eAAeI,EAAcA,GAC7B,eAAeC,EAAgBA,GAE/B,MAAO,CACHF,iBACAF,iBACAC,mBACAI,aALiB,WAAW,cAAeF,EAAcC,GAMzDD,eACAC,iBAER,C,2BCrBO,SAASE,GAA2BrgC,EAAY0C,EAAY49B,EAAWC,GAC1E,MAAO9oC,EAAOC,EAAQ8oC,GAAa99B,EAC7B+9B,EAAoBhpC,EAAQC,EAClC,IAAIyX,EAAM,EACNuxB,EAAQ,EACR52B,EAAQ,EACZ,MAAO62B,EAAIC,EAAIC,GAAMP,EAAUp/B,IAAIpJ,KAAKgmB,OACxC,IAAK,IAAIpU,EAAIm3B,EAAKN,EAAQ72B,GAAKm3B,EAAKN,EAAQ72B,IACxC,KAAIA,EAAI,GAAKA,GAAK82B,GAGlB,IAAK,IAAInoC,EAAIuoC,EAAKL,EAAQloC,GAAKuoC,EAAKL,EAAQloC,IACxC,KAAIA,EAAI,GAAKA,GAAKX,GAGlB,IAAK,IAAIS,EAAIwoC,EAAKJ,EAAQpoC,GAAKwoC,EAAKJ,EAAQpoC,IAAK,CAC7C,GAAIA,EAAI,GAAKA,GAAKV,EACd,SAEJ,MACMqD,EAAQkF,EADA0J,EAAI+2B,EAAoBpoC,EAAIZ,EAAQU,GAElDgX,GAAOrU,EACP4lC,GAAS5lC,EAAQA,EACjBgP,GACJ,CAGR,GAAc,IAAVA,EAAa,CACb,MAAMg3B,EAAcD,EAAKJ,EAAoBG,EAAKnpC,EAAQkpC,EAC1D,GAAIG,GAAe,GAAKA,EAAc9gC,EAAWvE,OAAQ,CAErD,MAAO,CAAEslC,KADW/gC,EAAW8gC,GACHE,OAAQ,EAAGl3B,MAAO,EAClD,CAEI,MAAO,CAAEi3B,KAAM,EAAGC,OAAQ,EAAGl3B,MAAO,EAE5C,CACA,MAAMi3B,EAAO5xB,EAAMrF,EACbm3B,EAAWP,EAAQ52B,EAAQi3B,EAAOA,EAExC,MAAO,CAAEA,OAAMC,OADAlpC,KAAKopC,KAAKppC,KAAKkS,IAAI,EAAGi3B,IACdn3B,QAC3B,CCvCA,MAAMq3B,GAAmC,IAAI5K,IAAI,CAC7C,4BACA,8BACA,gCACA,8BACA,gCACA,8BACA,gCACA,+BACA,iCACA,+BACA,iCACA,iCAEE6K,GAAkB,IAAI7K,IAsEb,SAAS8K,GAA2BC,GAC/C,MAAM,aAAEC,EAAY,YAAEC,EAAW,4BAAEC,GAAgCH,EACnE,GAAIG,EACA,OArBR,SAAiCH,GAC7B,MAAM,4BAAEG,GAAgCH,EAClCI,EAAqBnoC,MAAMC,QAAQioC,GACzC,GAAIC,GAAsBD,EAA4BhmC,OAAS,EAE3D,YADAwP,QAAQC,KAAK,sHAGjB,MAAM,eAAEy2B,EAAc,eAAEC,GAAmBF,EACrCD,EAA4B,GAC5BA,EAKN,MAAO,CACHF,aALmB,CACQ,GAA3BzpC,KAAK6e,IAAIgrB,GACkB,GAA3B7pC,KAAK6e,IAAIirB,IAKjB,CAIeC,CAAwBP,GAGnC,OADqBH,GAAiCjjC,IAAIsjC,GA1E9D,SAA2CF,GACvC,MAAM,aAAEC,EAAY,mBAAEO,EAAkB,yCAAEC,EAAwC,4BAAEC,EAA2B,mCAAEC,GAAwCX,EACnJY,GAAe,EACrB,IAAKJ,EACD,MAAO,CACHP,eACA5/B,KAAM,EAAAwgC,iBAAiBC,QACvBF,gBAGR,IAAKX,EACD,OAAKQ,EAYE,CACHR,aAF0BO,EAAmB5gC,IAAKyC,GAAiBA,EAAeo+B,GAGlFpgC,KAAM,EAAAwgC,iBAAiBE,KACvBH,iBAdKd,GAAgBljC,IAAIojC,EAASgB,qBAC9Br3B,QAAQC,KAAK,qEAAsEo2B,EAASgB,kBAAmB,0CAC/GlB,GAAgBjjC,IAAImjC,EAASgB,oBAE1B,CACHf,aAAcO,EACdngC,KAAM,EAAAwgC,iBAAiBI,WACvBL,iBAUZ,OAAI,EAAA7L,GAAA,IAAQkL,EAAcO,GACf,CACHP,eACA5/B,KAAM,EAAAwgC,iBAAiBI,WACvBL,gBAGJF,GAA+BC,EACxB,CACHV,eACA5/B,KAAM,EAAAwgC,iBAAiBK,WACvBN,eACAF,8BACAC,sCAGD,CACHV,eACA5/B,KAAM,EAAAwgC,iBAAiBC,QACvBF,eAER,CA0BeO,CAAkCnB,GAEtC,CACHC,eACA5/B,KAAM,EAAAwgC,iBAAiBO,eACvBR,cAAc,EAEtB,C,gBCFA,MAAMS,GAAsB,CAAC5rC,EAAU4O,IClGvC,SAA8B5O,EAAU4O,EAAUgc,GAC9C,IAAKA,EACD,MAAM,IAAI1oB,MAAM,4DAEpB,GAAIlC,EAASiC,SACT,OAAOjC,EAASiC,SAEpB,GAAIjC,EAAS81B,WAAY,CAErB,KADAlnB,EAAWA,GAAY5O,EAASwsB,iBACd5B,EACd,OAGJ,OADeA,EAAUhc,GACX5D,SAAS6gC,QAC3B,CACA,MAAM,IAAI3pC,MAAM,wBACpB,CDkFoD4pC,CAAqB9rC,EAAU4O,EAAUwoB,EAAA,GAAMxM,U,+BElGpF,SAASmhB,EAA0B1b,GAC9C,IAAKA,EACD,OAEJ,MAAM/B,EAAO+B,EAAoBC,UACjC,IAAK,IAAIhkB,EAAQ,EAAGA,EAAQgiB,EAAMhiB,IAAS,CACvC,MAAMikB,EAAa,GACnBF,EAAoBG,aAAalkB,EAAOikB,GACxCA,EAAW,GAAK,EAAIA,EAAW,GAC/BA,EAAW,GAAK,EAAIA,EAAW,GAC/BA,EAAW,GAAK,EAAIA,EAAW,GAC/BF,EAAoBI,aAAankB,EAAOikB,EAC5C,CACJ,C,+CCbA,SAASyb,EAA6BC,EAAMC,EAAMra,GAC9C,OAAO9wB,KAAK6e,IAAIqsB,EAAOC,IAASra,CACpC,CAYA,SAASsa,EAAapoC,GAClB,MAAwB,iBAAVA,CAClB,CACA,SAASqoC,EAAkBroC,GACvB,OAAQA,GACa,iBAAVA,GACP,WAAYA,GACY,iBAAjBA,EAAMW,QACbX,EAAMW,OAAS,GACK,iBAAbX,EAAM,EACrB,CACO,SAASu7B,EAAQ3N,EAAIC,EAAIC,EAAY,MACxC,cAAWF,UAAcC,GAAa,OAAPD,GAAsB,OAAPC,IAG1Cua,EAAaxa,IAAOwa,EAAava,GAC1Boa,EAA6Bra,EAAIC,EAAIC,MAE5Cua,EAAkBza,KAAOya,EAAkBxa,KA7BnD,SAAwBya,EAAMC,EAAMza,EAAY,MAC5C,GAAIwa,EAAK3nC,SAAW4nC,EAAK5nC,OACrB,OAAO,EAEX,IAAK,IAAI8I,EAAI,EAAGA,EAAI6+B,EAAK3nC,OAAQ8I,IAC7B,IAAKw+B,EAA6BK,EAAK7+B,GAAI8+B,EAAK9+B,GAAIqkB,GAChD,OAAO,EAGf,OAAO,CACX,CAoBe0a,CAAe5a,EAAIC,EAAIC,GAGtC,C,sDACA,MAAM2a,EAAYj5B,GAAmB,iBAANA,GAAkBA,EAAIA,GAAGpJ,IAAMoJ,EAAEpJ,IAAIqiC,IAAaj5B,EAC3EqM,EAAOrM,GAAmB,iBAANA,EAAiBxS,KAAK6e,IAAIrM,GAAKA,GAAGpJ,IAAMoJ,EAAEpJ,IAAIyV,GAAOrM,EAClEk5B,EAAkB,CAAC9a,EAAIC,EAAIC,OAAY/vB,IAAcw9B,EAAQ3N,EAAI6a,EAAS5a,GAAKC,GAC/E6a,EAAa,CAAC/a,EAAIC,EAAIC,OAAY/vB,IAAcw9B,EAAQ1f,EAAI+R,GAAK/R,EAAIgS,GAAKC,GAChF,SAAS8a,EAASrb,GACrB,OAAI9uB,MAAMC,QAAQ6uB,GACPqb,EAASrb,EAAE,IAEfsb,SAAStb,KAAOhR,MAAMgR,EACjC,CACA,S,6OC9CA,MAAMub,E,MAAW,gBAIV,SAASC,EAAc1oC,GAC1B,MAAM2oC,EAASF,EAAS5nB,UAAU7gB,EAAK,IAIvC,OAHA2oC,EAAO9nB,UAAY,IAAI+nB,IACZF,EAAc,GAAG1oC,KAAQ4oC,EAAMxb,KAAK,QAExCub,CACX,CACO,SAAS9nB,KAAa7gB,GACzB,OAAO0oC,EAAc1oC,EAAKotB,KAAK,KACnC,CAZsB,oBAAX6B,SACPA,OAAOtO,IAAM8nB,GAYV,MAAMI,EAAUH,EAAc,QACxB9nB,EAAUioB,EAAQhoB,UAAU,QAC5BioB,EAAWD,EAAQhoB,UAAU,SAC7BkoB,EAAYF,EAAQhoB,UAAU,oBAC9BmoB,EAAQH,EAAQhoB,UAAU,MAC1BooB,EAAcJ,EAAQhoB,UAAU,YAChCqoB,EAAsBroB,EAAU,cAAe,SAC/CsoB,EAAsBtoB,EAAU,cAAe,Q,8DCrB7C,SAASuoB,EAAmBtjC,GACvC,MAAM+0B,EAAW/0B,EAAS,IACpB,oBAAEsB,EAAmB,cAAEJ,EAAa,WAAEC,EAAU,QAAEC,EAAO,0BAAE4B,EAAyB,gBAAE3B,IAAqB,IAAArH,KAAI,mBAAoB+6B,GACnIwO,EAAS,GACTC,GAAe,IAAAxpC,KAAI,eAAgB+6B,GACzC,IAAI7gB,EACJ,GAAIsvB,EAAc,CACd,MAAM,YAAEprC,EAAW,aAAEC,GAAiBmrC,EAEtC,GADAtvB,EAAiBsvB,GAActvB,eAC3B5b,MAAMC,QAAQH,GACd,IAAK,IAAIkL,EAAI,EAAGA,EAAIlL,EAAYoC,OAAQ8I,IACpCigC,EAAOhhC,KAAK,CACRnK,YAAaA,EAAYkL,GACzBjL,aAAcA,EAAaiL,UAKnCigC,EAAOhhC,KAAK,CACRnK,YAAaA,EACbC,aAAcA,GAG1B,MAEIkrC,EAAOhhC,KAAK,CACRnK,iBAAaR,EACbS,kBAAcT,IAGtB,MAAM,SAAEG,EAAQ,kBAAEi9B,IAAsB,IAAAh7B,KAAI,sBAAuB+6B,IAC7D,wBAAEjzB,EAAuB,aAAEY,EAAY,oBAAEX,EAAmB,QAAEnJ,EAAO,KAAEC,IAAU,IAAAmB,KAAI,mBAAoB+6B,GAC/G,MAAO,CACH0O,cAAeviC,EACfwiC,WAAYviC,EACZwiC,gBAAiBtiC,EACjBuiC,QAASxiC,EACTyiC,0BAA2B7gC,EAC3B8gC,oBAAqBxiC,EACrBqgC,SAAU5pC,EACVgsC,wBAAyBjiC,EACzBw+B,aAAc59B,EACdkB,oBAAqB7B,EACrBiiC,QAASprC,EACTqrC,KAAMprC,EACN0qC,SACAW,eAAgBhwB,EAChBmtB,kBAAmBrM,EAE3B,C,qMChDA,SAASmP,EAAsBC,EAAIC,EAAIxT,GACnC,MAAOyT,EAAIC,EAAIC,GAAMJ,GACdtiB,EAAI3I,EAAIsrB,GAAMJ,GACdK,EAAGC,EAAGC,EAAGC,GAAKhU,EACf/a,EAAIgM,EAAKwiB,EACTxzB,EAAIqI,EAAKorB,EACTxM,EAAI0M,EAAKD,EACTM,GAAM,GAAKJ,EAAIJ,EAAKK,EAAIJ,EAAKK,EAAIJ,EAAKK,IAAOH,EAAI5uB,EAAI6uB,EAAI7zB,EAAI8zB,EAAI7M,GAIvE,MAAO,CAHGjiB,EAAIgvB,EAAIR,EACRxzB,EAAIg0B,EAAIP,EACRxM,EAAI+M,EAAIN,EAEtB,CACA,SAAS1T,EAAciU,EAAQ78B,EAAO88B,GAAa,GAC/C,MAAON,EAAGC,EAAGC,GAAKG,EACZF,EAAIH,EAAIx8B,EAAM,GAAKy8B,EAAIz8B,EAAM,GAAK08B,EAAI18B,EAAM,GAClD,GAAI88B,EAAY,CACZ,MAAMxqC,EAAS3D,KAAKopC,KAAKyE,EAAIA,EAAIC,EAAIA,EAAIC,EAAIA,GAC7C,MAAO,CAACF,EAAIlqC,EAAQmqC,EAAInqC,EAAQoqC,EAAIpqC,EAAQqqC,EAAIrqC,EACpD,CACA,MAAO,CAACkqC,EAAGC,EAAGC,EAAGC,EACrB,CACA,SAASI,EAAuBC,EAAYC,EAAaC,GACrD,MAAOC,EAAIC,EAAIC,EAAIC,GAAMN,GAClBO,EAAIC,EAAIC,EAAIC,GAAMT,GAClBU,EAAIC,EAAIC,EAAIC,GAAMZ,EACnBa,EAAK,gBAAgBZ,EAAII,EAAII,EAAIP,EAAII,EAAII,EAAIP,EAAII,EAAII,GACrDG,EAAK,gBAAgBV,EAAII,EAAII,EAAIV,EAAII,EAAII,EAAIP,EAAII,EAAII,GACrDI,EAAK,gBAAgBd,EAAII,EAAII,EAAIL,EAAII,EAAII,EAAIT,EAAII,EAAII,GACrDK,EAAK,gBAAgBf,EAAII,EAAII,EAAIP,EAAII,EAAII,EAAIN,EAAII,EAAII,GAI3D,MAAO,CAHG,iBAAiBE,GAAM,iBAAiBD,GACxC,iBAAiBE,GAAM,iBAAiBF,GACxC,iBAAiBG,GAAM,iBAAiBH,GAEtD,CACA,SAASlV,EAAqBF,EAAO3oB,EAAOm+B,GAAS,GACjD,MAAO3B,EAAGC,EAAGC,EAAGC,GAAKhU,GACd35B,EAAGE,EAAGqR,GAAKP,EACZo+B,EAAY5B,EAAIxtC,EAAIytC,EAAIvtC,EAAIwtC,EAAIn8B,EAAIo8B,EACpCjvB,EAAW/e,KAAK6e,IAAI4wB,GAAazvC,KAAKopC,KAAKyE,EAAIA,EAAIC,EAAIA,EAAIC,EAAIA,GAErE,OADayB,EAASxvC,KAAK0vC,KAAKD,GAAa,GAC/B1wB,CAClB,CACA,SAAS4wB,EAAet+B,EAAO2oB,EAAOlJ,EAAY,EAAApM,SAC9C,OAAOwV,EAAqBF,EAAO3oB,GAASyf,CAChD,C,yEC9CO,SAAS8e,EAAqBloB,EAAWvgB,GAC5C,MAAM,eAAE0oC,EAAc,SAAE5rC,EAAQ,UAAEgU,EAAS,aAAE63B,GAAe,GAAU3oC,EACtE,IAAIe,EACJ,GAAIwf,EAAUtf,cACVF,EAAawf,EAAUtf,oBAEtB,CACD,MAAM2nC,EAAUroB,EAAUsoB,eAAeC,aACzC,GAAIF,EACA7nC,EAAa6nC,EAAQG,cAEpB,CACD,MAAM,aAAEnoC,GAAiB2f,EAAUvkB,IAAI,iBAAmB,CAAC,EACvD4E,IACAG,EAAaH,EAAao/B,6BAElC,CACJ,CACA,MAAMv8B,EAAa8c,EAAUM,gBACvBmoB,EAAmB,CACrB,CAAC,EAAGvlC,EAAW,IACf,CAAC,EAAGA,EAAW,IACf,CAAC,EAAGA,EAAW,KAGbwlC,EASH,UAAkC,UAAE1oB,EAAS,OAAE4D,EAAM,WAAEpjB,EAAU,eAAE2nC,EAAc,SAAE5rC,IACtF,OAAQosC,EAAMC,IAAQC,EAAMC,IAAQC,EAAMC,IAASplB,GAC7C,SAAE5W,GAAagT,EACf9c,EAAa8c,EAAUM,gBACvBC,GAAe,OAAuBP,GACtCipB,EAAW,CAAC,EAAG,EAAG,GAClBC,EAAYl8B,GACdxM,EAAWvE,OAASiH,EAAW,GAAKA,EAAW,GAAKA,EAAW,GAC7DimC,EAAYjmC,EAAW,GAAKgmC,EAC5BE,EAAYlmC,EAAW,GAAKimC,EAC5BT,EAAgB,GACtB,IAAK,IAAIh7B,EAAIq7B,EAAMr7B,GAAKs7B,EAAMt7B,IAAK,CAC/Bu7B,EAAS,GAAKv7B,EACd,MAAM27B,EAAS37B,EAAI07B,EACnB,IAAK,IAAI97B,EAAIu7B,EAAMv7B,GAAKw7B,EAAMx7B,IAAK,CAC/B27B,EAAS,GAAK37B,EACd,MAAMg8B,EAAUD,EAAS/7B,EAAI67B,EAC7B,IAAK,IAAIpkC,EAAI4jC,EAAM5jC,GAAK6jC,EAAM7jC,IAAK,CAC/BkkC,EAAS,GAAKlkC,EACd,MAAMwkC,EAAWhpB,EAAa0oB,GAC9B,GAAId,EAAeoB,EAAUN,GAAW,CACpC,MAAMplC,EAAQylC,EAAUvkC,EAAImkC,EAC5B,IAAI5tC,EAEAA,EADA4tC,EAAY,EACJ,CACJ1oC,EAAWqD,GACXrD,EAAWqD,EAAQ,GACnBrD,EAAWqD,EAAQ,IAIfrD,EAAWqD,GAEvB6kC,EAAc1kC,KAAK,CACf1I,QACAuI,QACAolC,WACAM,SAAUA,EAASxtC,UAEvBQ,EAAS,CAAEjB,QAAOuI,QAAOolC,WAAUM,YACvC,CACJ,CACJ,CACJ,CACA,OAAOb,CACX,CAtD0Bc,CAAyB,CAC3CxpB,YACA4D,OAHWrT,GAAak4B,EAIxBjoC,aACA2nC,iBACA5rC,aAEJ,OAAO6rC,EAAeM,OAAgBrvC,CAC1C,CA+CO,SAASowC,GAAqC,aAAEppC,EAAY,OAAEujB,EAAM,UAAE5D,EAAS,eAAEmoB,EAAc,SAAE5rC,EAAQ,aAAE6rC,IAC9G,OAAQO,EAAMC,IAAQC,EAAMC,IAAQC,EAAMC,IAASplB,EAC7CrD,GAAe,OAAuBP,GACtCipB,EAAW,CAAC,EAAG,EAAG,GAClBP,EAAgB,GACtB,IAAK,IAAIh7B,EAAIq7B,EAAMr7B,GAAKs7B,EAAMt7B,IAAK,CAC/Bu7B,EAAS,GAAKv7B,EACd,IAAK,IAAIJ,EAAIu7B,EAAMv7B,GAAKw7B,EAAMx7B,IAAK,CAC/B27B,EAAS,GAAK37B,EACd,IAAK,IAAIvI,EAAI4jC,EAAM5jC,GAAK6jC,EAAM7jC,IAAK,CAC/BkkC,EAAS,GAAKlkC,EACd,MAAMwkC,EAAWhpB,EAAa0oB,GAC9B,GAAId,EAAeoB,EAAUN,GAAW,CACpC,MAAMplC,EAAQxD,EAAauO,QAAQq6B,GAC7B3tC,EAAQ+E,EAAaqpC,WAAW7lC,GAClCukC,GACAM,EAAc1kC,KAAK,CACf1I,QACAuI,QACAolC,SAAU,IAAIA,GACdM,SAAUA,EAASxtC,UAG3BQ,IAAW,CAAEjB,QAAOuI,QAAOolC,WAAUM,YACzC,CACJ,CACJ,CACJ,CACA,OAAOb,CACX,C,8DC7Ge,SAASvL,EAAsBnf,EAAYiN,EAAU7M,EAAYxB,EAAiBmB,EAA0B4rB,GACvH,MAAM,IAAExwC,EAAG,IAAEqR,EAAG,QAAErM,GAAYigB,EACxBwrB,EAAwB,cAC9B,SAASA,EAAuB3e,EAAUjN,GAC1C,MAAM6rB,EAAQvxC,KAAKgmB,OAAO9T,EAAMrR,GAAO4kB,GAEjCmG,GADY/lB,EAAUhF,IAAQqR,EAAMrR,GACJ0wC,EACtC,IAAIC,EAAaxxC,KAAKgmB,MAAM4F,GACxBgZ,EAAgB,CAChBlf,EAAW,GACPpB,EAAgB,GAAKsH,EAAqBnG,EAC9CC,EAAW,GACPpB,EAAgB,GAAKsH,EAAqBnG,EAC9CC,EAAW,GACPpB,EAAgB,GAAKsH,EAAqBnG,GAElD+rB,GAAcH,EACVG,EAAaD,EACbC,EAAaD,EAERC,EAAa,IAClBA,EAAa,GAEjB,MAAMC,EAAqBD,EAAa/rB,EACxCmf,EAAgB,CACZA,EAAc,GAAKtgB,EAAgB,GAAKmtB,EACxC7M,EAAc,GAAKtgB,EAAgB,GAAKmtB,EACxC7M,EAAc,GAAKtgB,EAAgB,GAAKmtB,GAO5C,MAAO,CAAE7M,gBAAe1M,YALJ,CAChB0M,EAAc,GAAK0M,EAAsB,GACzC1M,EAAc,GAAK0M,EAAsB,GACzC1M,EAAc,GAAK0M,EAAsB,IAGjD,C,oFCjCe,SAASI,EAA0BvoC,EAAUiV,GACxD,MAAQrT,qBAAsBkT,EAA6B,wBAAEhT,GAA6B,MAAa,mBAAoB9B,EAAS,IACpI,IAAKiV,EAAgB,CACjB,MAAMF,EAAe,gBAAgBjT,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IAC/GkT,EAAe,gBAAgBlT,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IACrHmT,EAAiB,cACjB,WAAWA,EAAgBF,EAAcC,EAC7C,CACA,MAAMwzB,EAA6C,YAA9BxoC,EAAS,GAAGhE,MAAM,KAAK,GACtCigB,GAAW,OAAgCjc,GACjD,IAAIyoC,EACJ,SAAStzB,EAAYpX,GACjB,MAAM,qBAAE6D,GAAyB,MAAa,mBAAoB7D,GAC5DqX,EAAiB,cAEvB,OADA,SAASA,EAAgBN,EAA+BlT,GACjD,SAASwT,EAAgBH,EACpC,CACA,GAAKuzB,EAWA,CACD,MAAMlzB,EAAqB,CACvBtV,EAAS,GACTA,EAASnJ,KAAK+Q,MAAM5H,EAASxF,OAAS,KAE1CiuC,EAAiBzoC,EACUmV,EAAYG,EAAmB,IAC9BH,EAAYG,EAAmB,IACZ,GAC3CmzB,EAAe/gC,SAEvB,KAtBmB,CACf,MAAMiO,EAAqB3V,EAASC,IAAKlC,IAE9B,CACH6X,SAFaT,EAAYpX,GAGzBA,aAGR4X,EAAmBE,KAAK,CAACC,EAAGhF,IAAMA,EAAE8E,SAAWE,EAAEF,UACjD6yB,EAAiB9yB,EAAmB1V,IAAK6V,GAAMA,EAAE/X,QACrD,CAaA,MAAQ6D,qBAAsBD,GAAW,MAAa,mBAAoB8mC,EAAe,IAMzF,MALe,CACXxsB,WACAta,SACA8mC,iBAGR,C,8BClDA,SAASC,EAAyBC,GAC9B,MAAMvkB,EAAOukB,EAAiBviB,UACxB7R,EAAS,GACf,IAAK,IAAInS,EAAQ,EAAGA,EAAQgiB,EAAMhiB,IAAS,CACvC,MAAMikB,EAAa,GACnBsiB,EAAiBriB,aAAalkB,EAAOikB,GACrC9R,EAAOhS,KAAK8jB,EAChB,CACA,OAAO9R,CACX,CACA,SAASq0B,EAAyBD,EAAkBE,GAC3CA,GAAOruC,SAGZmuC,EAAiB33B,kBACjB63B,EAAMhuC,QAASiuC,IACXH,EAAiB13B,eAAe63B,KAExC,C,4ICjBO,SAASnX,EAAqB77B,EAAUizC,GAC3C,MAAQxqB,UAAWyqB,GAAiBlzC,EAASq8B,eACvC8W,EAAanzC,EAASk1B,cAAc+d,GAC1C,OAAO,OAAsBC,EAAcC,EAC/C,C,+BCLe,SAAStL,EAAsBpf,EAAW2qB,GACrD,OAAO3qB,EAAUO,aAAaoqB,EAClC,C,+CCFe,SAAS5K,EAAsB/f,EAAWrD,GAGrD,OAFwBqD,EAAUyV,aAAa9Y,GACjBjb,IAAIpJ,KAAKgmB,MAE3C,CACO,SAASssB,EAAgC5qB,EAAWrD,GACvD,OAAOqD,EAAUyV,aAAa9Y,EAClC,C,iGCLA,MAAMkuB,EAAwB,IACvB,SAASC,EAAuBhhC,EAAQihC,GAC3C,IAAKjhC,GAAQ7N,SAAW8uC,EAAU1lC,oBAC9B,OAEJ0lC,EAAUC,mBAAqB,CAC3B3lC,oBAAqB0lC,EAAU1lC,oBAC/BsE,MAAOG,EAAO,GACdmhC,eAAgB,KAChBC,eAAgB,MAEpB,MAAM,iBAAEF,GAAqBD,EAC7B,GAAsB,IAAlBjhC,EAAO7N,OAGP,OAFA+uC,EAAiBC,eAAiB,KAClCD,EAAiBE,eAAiB,KAC3BF,EAEX,MAAM9hB,EAAK,SAAS,cAAepf,EAAO,GAAIA,EAAOxR,KAAK+Q,MAAMS,EAAO7N,OAAS,KAChF,eAAeitB,EAAIA,GACnB8hB,EAAiBC,eAAiB/hB,EAClC8hB,EAAiBE,eAAiB,KAClC,MAAMriB,EAAI/e,EAAO7N,OACjB,GAAI4sB,EAAI,EACJ,IAAK,IAAI9jB,EAAIzM,KAAK+Q,MAAMwf,EAAI,GAAI9jB,EAAI8jB,EAAG9jB,IAAK,CACxC,MAAMomC,EAAa,SAAS,cAAerhC,EAAO/E,GAAI+E,EAAO,IACvD7N,EAAS,YAAYkvC,GAC3B,KAAI,QAAQlvC,EAAQ,IAGhB,SAASkvC,EAAYH,EAAiBC,gBACtChvC,EAAS4uC,EAGT,OAFA,eAAeM,EAAYA,GAC3BH,EAAiBE,eAAiBC,EAC3BH,CAEf,CAEJ,OAAOA,CACX,C,+BCxCA,SAASI,EAAuCC,EAAiBx0C,GAC7D,MAAM+J,EAAY/J,EAAMwJ,aAAaK,gBACrC,IAAK2qC,EAAgB/C,aACjB,OAEJ,MAAM9nC,EAAa6qC,EACd/C,eACAC,aACAC,UACL,GAAI3xC,EAAMY,OAASZ,EAAMuO,KAAM,CAC3B,MAAMkmC,EAAe,IAAIjnC,WAAWxN,EAAMwD,QAAUxD,EAAMyD,KAAO,GACjE,IAAK,IAAIyK,EAAI,EAAGA,EAAIlO,EAAMwD,QAAUxD,EAAMyD,KAAMyK,IAC5CumC,EAAiB,EAAJvmC,GAASnE,EAAc,EAAJmE,GAChCumC,EAAiB,EAAJvmC,EAAQ,GAAKnE,EAAc,EAAJmE,EAAQ,GAC5CumC,EAAiB,EAAJvmC,EAAQ,GAAKnE,EAAc,EAAJmE,EAAQ,GAEhDlO,EAAMuO,MAAO,EACbvO,EAAM4J,aAAe,IAAM6qC,EAC3B9qC,EAAWjF,IAAI+vC,EACnB,MAEI9qC,EAAWjF,IAAIqF,GAEnByqC,EAAgBE,UACpB,C,gICtBA,SAASC,EAAc1O,EAAKC,GAGxB,MAAO,CAAEljC,YAFWvB,KAAK6e,IAAI4lB,EAAOD,GAAO,EAErBhjC,cADAgjC,EAAMC,EAAO,GAAK,EAE5C,CACA,SAAS0O,EAAe5xC,EAAaC,EAAc6b,EAAiB,IAAmBQ,QACnF,GAAIR,IAAmB,IAAmBQ,QACtCR,IAAmB,IAAmB+1B,gBACtC,MAAO,CACHxwB,MAAOphB,EAAe,IAAOD,EAAc,GAAK,EAChDshB,MAAOrhB,EAAe,IAAOD,EAAc,GAAK,GAGnD,GAAI8b,IAAmB,IAAmBg2B,aAC3C,MAAO,CACHzwB,MAAOphB,EAAeD,EAAc,EACpCshB,MAAOrhB,EAAeD,EAAc,GAIxC,MAAM,IAAIJ,MAAM,2BAExB,C,meCrBA,MAAM,OAAEmyC,EAAM,QAAEC,EAAO,QAAEC,GAAY,EAAAC,WCA7BH,OAAM,UAAS,UAAS,GAAK,EAAAG,U,kBCArC,MCAQH,OAAM,UAAS,UAAS,GAAK,EAAAG,U,6HCArC,MAAM,gBAAEC,GAAoB,EAAAC,MAAA,OCA5B,MAAQD,gBAAe,GAAK,EAAAC,MAAA,OCA5B,MAAQD,gBAAe,GAAK,EAAAC,MAAA,O,cCA5B,MAAM,gBAAEC,EAAe,iBAAEC,GAAqB,EAAAF,MAAA,OCA9C,MAAQD,gBAAe,GAAK,EAAAC,MAAA,O,kDCF5B,MAAM,uCAAEG,GAA2C,EAAAC,U,yECD/C,E,sDACJ,SAAWvf,GACPA,EAAqB,aAAI,gCACzBA,EAAqB,aAAI,+BAC5B,CAHD,CAGG,IAAW,EAAS,CAAC,ICAxB,MAAM,eAAEwf,GAAmB,EAAAL,OACnBxO,aAAY,GAAK,YAEQ,IAAI5wB,I,wBCLjB,E,SCApB,MAAM,QAAEgqB,GAAY,YACN,gBAAgB,EAAG,EAAG,GACtB,gBAAgB,EAAG,EAAG,GACtB,gBAAgB,EAAG,EAAG,G,kBCDpC,MAAM,8BAAE/R,GAAkC,EAAAunB,UAkK1C,MClKQvnB,8BAA6B,GAAK,EAAAunB,U,2BCH1C,SAASE,EAAuBlsC,EAAcmsC,GAC1C,MAAM7P,EAAct8B,EAAaosC,sBAC3BC,EAAc,IAAIpoC,aAAaq4B,GACrC,IAAK,MAAMgQ,KAAwBH,EAAiB,CAChD,MAAMhsC,EAAaH,EAAausC,4BAA4BD,GAC5D,IAAK,IAAI5nC,EAAI,EAAGA,EAAI43B,EAAa53B,IAC7B2nC,EAAY3nC,IAAMvE,EAAWuE,EAErC,CACA,OAAO2nC,CACX,CAUK,EAAAT,MAAA,kBAAwBY,IAMxB,EAAAZ,MAAA,kBAAwBa,QAMxB,EAAAb,MAAA,kBAAwBc,SChCtB,SAAStkC,EAASqB,EAAQkjC,GAC7B,MAAMC,EAAa,EAAND,EACb,GAAIC,EAAOnjC,EAAO7N,OACd,OAAO,gBAAgB6N,EAAOmjC,GAAOnjC,EAAOmjC,EAAO,GAAInjC,EAAOmjC,EAAO,GAE7E,CACO,SAASC,EAAwBC,GACpC,MAAMC,EAAYD,EAASE,WAAW7E,UACtC,IAAIwE,EAAM,EACV,MAAMM,EAAe,IAAIzgC,IACzB,KAAOmgC,EAAMI,EAAUnxC,QAAQ,CAC3B,MAAMsxC,EAAcH,EAAUJ,KACxBQ,EAAU,GAChB,IAAK,IAAIzoC,EAAI,EAAGA,EAAIwoC,EAAaxoC,IAC7ByoC,EAAQxpC,KAAKopC,EAAUJ,EAAMjoC,IAEjCuoC,EAAa/xC,IAAIiyC,EAAQ,GAAIA,GAC7BR,GAAOO,CACX,CACA,MAAME,EAAW,GACXC,EAAqBhsC,IACvB,IAAK,MAAOlG,EAAKF,KAAUoG,EAAI4kB,UAC3B,QAAcjtB,IAAViC,EACA,OAAOE,EAGf,OAAQ,GAEZ,IAAImyC,EAAaD,EAAkBJ,GACnC,MAAuB,IAAhBK,GAAmB,CACtB,MAAMC,EAAU,CAACD,GACjB,KAAOL,EAAa5uC,IAAIivC,IAAa,CACjC,MAAME,EAAYP,EAAa7xC,IAAIkyC,GAAY,GAC3CL,EAAa5uC,IAAImvC,IACjBD,EAAQ5pC,KAAK6pC,GAEjBP,EAAazuC,OAAO8uC,GACpBA,EAAaE,CACjB,CACAJ,EAASzpC,KAAK4pC,GACdD,EAAaD,EAAkBJ,EACnC,CACA,OAAOG,EAASxxC,OAASwxC,OAAWp0C,CACxC,CACO,SAASy0C,EAAkBX,GAC9B,MAAMY,EAAkBb,EAAwBC,GAChD,IAAKY,EACD,OAEJ,MAAMC,EAAgBb,EAASc,YAAYzF,UAC3C,OAAOuF,EAAgBrsC,IAAKwsC,GAAmBA,EAAexsC,IAAKmC,GAAU4E,EAASulC,EAAenqC,IACzG,C,yEC1CyBsqC,EAAA,EAA0BC,MAG5BC,EAAA,E,SCVvB,MAAQvhB,OAAM,GAAK,EAAAmf,MCFnB,SAASqC,EAAiC/2C,GACtC,GAAIA,aAAoB,EAAAg3C,eACpB,OAOR,SAAgCh3C,GAC5B,MAAM,WAAEiJ,EAAU,MAAEvI,EAAK,OAAEC,GAAW,0CAAsCX,IACpE4B,IAAK0L,EAAe2F,IAAK1F,GAAkB,sBAAkBtE,GACrE,MAAO,CACHA,aACAqE,gBACAC,gBACA7M,QACAC,SACAoC,KAAMrC,EACNoC,QAASnC,EAEjB,CAnBes2C,CAAuBj3C,GAElC,GAAIA,aAAoB,EAAA8+B,cACpB,OAiBR,SAA+B9+B,GAC3B,MAAMyoB,EAAYzoB,EAASq8B,gBACrB,WAAEpzB,GAAewf,GACf7mB,IAAK0L,EAAe2F,IAAK1F,GAAkB,sBAAkBtE,GAC/DvI,EAAQ+nB,EAAU9c,WAAW,GAC7BhL,EAAS8nB,EAAU9c,WAAW,IAC9B,KAAE5I,EAAI,QAAED,EAAO,MAAE5C,GAAUF,EAAS++B,sBAC1C,MAAO,CACH91B,aACAvI,QACAC,SACA2M,gBACAC,gBACAxK,OACAD,UACA5C,QAER,CAlCeg3C,CAAsBl3C,GAEjC,MAAM,IAAIkC,MAAM,yBACpB,C,yBCLA,MAAM,sBAAEsmC,IAA0B,Y,yDCFnB,SAAS2O,GAAmBC,EAAYnkB,EAASokB,GAC5DD,EAAWpmC,KAAK0mB,MAAQ2f,GACxB,KAAAC,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAYC,YAC/D,C,iBCkIO,SAASC,GAAyBC,EAAah3C,EAAOC,EAAQg3C,EAAMC,GACvE,MAAMC,EAxIH,SAAoBF,EAAMG,EAAQ,GACrC,IAAKH,EAAKjzC,OACN,MAAM,IAAIxC,MAAM,wBAEpB,MAAMovB,EAAIqmB,EAAKjzC,OACTqzC,EAAQvqC,IAAOA,EAAI,GAAK8jB,EACxB0mB,EAAO,CAAC3xC,EAAM4xC,KAChB,MAAMxC,EAAM,GACZ,IAAK,IAAIjoC,EAAInH,EACTovC,EAAIhpC,KAAKe,GACLA,IAAMyqC,EAFMzqC,EAAIuqC,EAAKvqC,IAM7B,OAAOioC,GAEX,IAAIyC,EAAK,EAAGC,EAAK,EACjB,IAAK,IAAI3qC,EAAI,EAAGA,EAAI8jB,EAAG9jB,IACfmqC,EAAKnqC,GAAG,GAAKmqC,EAAKO,GAAI,KACtBA,EAAK1qC,GAELmqC,EAAKnqC,GAAG,GAAKmqC,EAAKQ,GAAI,KACtBA,EAAK3qC,GAGb,MAAM4qC,EAAKT,EAAKO,GACVG,EAAKV,EAAKQ,GACVG,EAAQN,EAAKE,EAAIC,GACjBI,EAAQP,EAAKG,EAAID,GACjBM,EAAaz3C,KAAKa,OAAO+1C,EAAKxtC,IAAKqI,GAAMA,EAAE,KAC3CimC,EAAYH,EAAMvrB,KAAMvf,GAAMmqC,EAAKnqC,GAAG,KAAOgrC,GAC7CF,EACAC,EACAG,EAAO33C,KAAKa,OAAO62C,EAAUtuC,IAAKqD,GAAMmqC,EAAKnqC,GAAG,KACtD,IAAImrC,EAASF,EACRtuC,IAAKqD,GAAMmqC,EAAKnqC,IAChBoL,OAAQpG,GAAMzR,KAAK6e,IAAIpN,EAAE,GAAKkmC,IAASZ,GAS5C,OARIa,EAAOj0C,OAAS,IAChBi0C,EAASF,EACJtuC,IAAKqD,GAAMmqC,EAAKnqC,IAChBuS,KAAK,CAACC,EAAGhF,IAAMgF,EAAE,GAAKhF,EAAE,IACxBxW,MAAM,EAAG,IAIX,CAAEo0C,GAFED,EAAOlU,OAAO,CAACoU,EAAMrmC,IAAOA,EAAE,GAAKqmC,EAAK,GAAKrmC,EAAIqmC,EAAOF,EAAO,IAE7DP,KAAIC,KAAIS,GADVH,EAAOlU,OAAO,CAACoU,EAAMrmC,IAAOA,EAAE,GAAKqmC,EAAK,GAAKrmC,EAAIqmC,EAAOF,EAAO,IAE9E,CA0FkBI,CAAWpB,GACnBqB,EAzCH,SAAkCC,EAASv4C,EAAOC,EAAQk3C,EAAOxB,EAAS6C,EAAO,CAAC,GACrF,MAAM,QAAEC,EAAU,GAAE,MAAErB,EAAQ,GAAMoB,EAC9BE,EACE,CAAExwB,IAAK,EAAGC,IAAK,GADjBuwB,EAEE,CAAExwB,IAAK,EAAGC,GAAI,GAFhBuwB,EAGE,CAAExwB,GAAI,EAAIC,GAAI,GAHhBuwB,EAIE,CAAExwB,GAAI,EAAIC,IAAK,GAEvB,SAASwwB,EAAajwB,GAAI,GAAER,EAAE,GAAEC,GAAM5G,EAAY,GAC9C,MAAMq3B,EAAO1wB,EAAK,EAAIQ,EAAG,GAAK+vB,EAAU/vB,EAAG,GAAK0uB,EAC1CyB,EAAO3wB,EAAK,EAAIQ,EAAG,GAAK0uB,EAAQ1uB,EAAG,GAAK+vB,EACxCK,EAAO3wB,EAAK,EAAIO,EAAG,GAAK+vB,EAAU/vB,EAAG,GAAK0uB,EAC1C2B,EAAO5wB,EAAK,EAAIO,EAAG,GAAK0uB,EAAQ1uB,EAAG,GAAK+vB,EAC9C,IAAIN,EAAOzvB,EACX,IAAK,MAAOwgB,EAAIC,KAAOwM,EAAS,CAC5B,GAAIzM,EAAK0P,GAAQ1P,EAAK2P,GAAQ1P,EAAK2P,GAAQ3P,EAAK4P,EAC5C,SAEJ,MAAMC,EAAK34C,KAAKgmB,MAAM6iB,GAChB+P,EAAK54C,KAAKgmB,MAAM8iB,GACtB,GAAI6P,EAAK,GAAKA,GAAMh5C,GAASi5C,EAAK,GAAKA,GAAMh5C,EACzC,SAEJ,MAAMi5C,GAAUF,EAAKb,EAAK,IAAMjwB,EAC1BixB,GAAUF,EAAKd,EAAK,IAAMhwB,EACtBowB,EAAQU,EAAKj5C,EAAQg5C,GACvBz3B,IAAc23B,EAAS,GAAKC,EAAS,KACzChB,EAAO,CAACjP,EAAIC,GAEpB,CACA,OAAOgP,CACX,CACA,MAAO,CACHD,GAAIS,EAAaxB,EAAMe,GAAIQ,GAC3BhB,GAAIiB,EAAaxB,EAAMO,GAAIgB,GAC3Bf,GAAIgB,EAAaxB,EAAMQ,GAAIe,GAC3BN,GAAIO,EAAaxB,EAAMiB,GAAIM,GAEnC,CAGoBU,CAAyBpC,EAAah3C,EAAOC,EAAQk3C,EAAOD,EAAc,CACtFuB,QAAS,GACTY,KAAM,KAEV,OAAOf,CACX,C,gBC7IA,SAASgB,GAASt/B,EAAQlI,GACtB,OAAOzR,KAAKk5C,MAAMznC,EAAE,GAAKkI,EAAO,GAAIlI,EAAE,GAAKkI,EAAO,GACtD,CC2CO,SAASxR,GAAajB,GACzB,MAAM3I,EAAQ,EAAA83B,MAAM8iB,SAASjyC,GAC7B,IAAK3I,EACD,OAEJ,MAAMoB,EAAQpB,EAAMoB,MACdC,EAASrB,EAAMqB,OAErB,MAAO,CACH0I,UAFc/J,EAAM4J,eAGpBxI,QACAC,SAER,CAgGO,SAASw5C,GAAqBlyC,GACjC,MAAM,UAAEoB,EAAS,MAAE3I,EAAK,OAAEC,GAAWuI,GAAajB,IAAY,CAAC,EAC/D,IAAKoB,EACD,OAEJ,MAAMgtC,EC/JH,SAA2C+D,EAAQ15C,EAAOC,GAC7D,MAAM05C,EAAc35C,EAAQC,EACtB25C,EAAeF,EAAO11C,OAAS21C,EACrC,IAAK,CAAC,EAAG,EAAG,GAAG17B,SAAS27B,GACpB,MAAM,IAAIp4C,MAAM,gDAEpB,MAAMq4C,EAAO/3C,MAAM6D,KAAK,CAAE3B,OAAQ/D,GAAU,IAAM,IAAI6B,MAAM9B,GAAOkV,MAAK,IACxE,IAAK,IAAItU,EAAI,EAAGA,EAAIX,EAAQW,IACxB,IAAK,IAAIF,EAAI,EAAGA,EAAIV,EAAOU,IAAK,CAC5B,MACMoC,GADalC,EAAIZ,EAAQU,GACLk5C,EAC1B,IAAIE,GAAe,EACnB,IAAK,IAAIvY,EAAI,EAAGA,EAAIlhC,KAAKa,IAAI,EAAG04C,GAAerY,IAC3C,GAAImY,EAAO52C,EAAOy+B,GAAK,EAAG,CACtBuY,GAAe,EACf,KACJ,CAEJD,EAAKj5C,GAAGF,GAAKo5C,CACjB,CAEJ,MAAMC,EAASj4C,MAAM6D,KAAK,CAAE3B,OAAQ/D,GAAU,IAAM,IAAI6B,MAAM9B,GAAOkV,KAAK,IAC1E,IAAI8kC,EAAe,EACnB,MAAMC,EAAc,CAAC,EACrB,IAAK,IAAIr5C,EAAI,EAAGA,EAAIX,EAAQW,IACxB,IAAK,IAAIF,EAAI,EAAGA,EAAIV,EAAOU,IACvB,GAAIm5C,EAAKj5C,GAAGF,IAAuB,IAAjBq5C,EAAOn5C,GAAGF,GAAU,CAClCs5C,IACA,MAAM3hC,EAAS,CAAC6hC,EAAIC,MACZD,EAAK,GAAKA,GAAMl6C,GAASm6C,EAAK,GAAKA,GAAMl6C,IAGtC45C,EAAKM,GAAID,IAA0B,IAAnBH,EAAOI,GAAID,GAEtC,IAAIE,EAAa,EACjB,MAAM5yC,EAAU,CACZ6yC,QAAS,CAACH,EAAIC,KACVJ,EAAOI,GAAID,GAAMF,EACjBI,KAEJxiC,WAAW,IAEf,IAAAP,WAAUgB,EAAQ,CAAC3X,EAAGE,GAAI4G,GAC1ByyC,EAAYD,GAAgBI,CAChC,CAGR,GAAqB,IAAjBJ,EACA,MAAO,GAEX,MAAMM,EAAet3C,OAAO4B,KAAKq1C,GAAalW,OAAO,CAACzkB,EAAGhF,IAAM2/B,EAAY36B,GAAK26B,EAAY3/B,GAAKgF,EAAIhF,GACrG,SAASigC,EAAS75C,EAAGE,GACjB,GAAIm5C,EAAOn5C,GAAGF,MAAQ45C,EAClB,OAAO,EAEX,IAAK,MAAOpyB,EAAIC,IAAO,CACnB,CAAC,EAAG,GACJ,EAAE,EAAG,GACL,CAAC,EAAG,GACJ,CAAC,GAAI,IACN,CACC,MAAMqyB,EAAK95C,EAAIwnB,EAAIuyB,EAAK75C,EAAIunB,EAC5B,GAAIqyB,EAAK,GACLA,GAAMx6C,GACNy6C,EAAK,GACLA,GAAMx6C,GACN85C,EAAOU,GAAID,MAASF,EACpB,OAAO,CAEf,CACA,OAAO,CACX,CACA,IAAIx7C,EAAQ,KACZ47C,EAAO,IAAK,IAAI95C,EAAI,EAAGA,EAAIX,EAAQW,IAC/B,IAAK,IAAIF,EAAI,EAAGA,EAAIV,EAAOU,IACvB,GAAI65C,EAAS75C,EAAGE,GAAI,CAChB9B,EAAQ,CAAC4B,EAAGE,GACZ,MAAM85C,CACV,CAGR,IAAK57C,EACD,MAAO,GAEX,MAAM67C,EAAO,CACT,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,CAAC,EAAG,GACJ,EAAE,EAAG,GACL,EAAE,EAAG,GACL,EAAE,GAAI,GACN,CAAC,GAAI,GACL,CAAC,GAAI,IAEHhF,EAAU,GAChB,IAAIzvC,EAAUpH,EACV87C,EAAO,CAAC97C,EAAM,GAAK,EAAGA,EAAM,IAChC,EAAG,CACC62C,EAAQ5pC,KAAK,CAAC7F,EAAQ,GAAIA,EAAQ,KAClC,MAAM20C,EAAMD,EAAK,GAAK10C,EAAQ,GAAI40C,EAAMF,EAAK,GAAK10C,EAAQ,GAC1D,IAAI60C,EAAWJ,EAAK/kC,UAAWolC,GAAMA,EAAE,KAAOH,GAAOG,EAAE,KAAOF,GAC1DC,EAAW,IACXA,EAAW,GAEf,IAAIE,EAAS,KACb,IAAK,IAAIxlC,EAAI,EAAGA,GAAK,EAAGA,IAAK,CACzB,MAAOyS,EAAIC,GAAMwyB,GAAMI,EAAWtlC,GAAK,GACjC+kC,EAAKt0C,EAAQ,GAAKgiB,EAAIuyB,EAAKv0C,EAAQ,GAAKiiB,EAC9C,GAAIqyB,GAAM,GAAKA,EAAKx6C,GAASy6C,GAAM,GAAKA,EAAKx6C,GAAUs6C,EAASC,EAAIC,GAAK,CACrEQ,EAAS,CAACT,EAAIC,GACd,MAAOS,EAAKC,GAAOR,GAAMI,EAAWtlC,EAAI,EAAI,GAAK,GACjDmlC,EAAO,CAAC10C,EAAQ,GAAKg1C,EAAKh1C,EAAQ,GAAKi1C,GACvC,KACJ,CACJ,CACA,IAAKF,EACD,MAEJ/0C,EAAU+0C,CACd,OAAS/0C,EAAQ,KAAOpH,EAAM,IAAMoH,EAAQ,KAAOpH,EAAM,IACzD,OAAO62C,CACX,CDsCoByF,CAAkCzyC,EAAW3I,EAAOC,IAC9D,WAAEo7C,EAAU,KAAEpE,GEhKjB,SAAuCtB,GAC1C,MAAM0F,EAAaC,EAAKC,SAAS93B,SAASkyB,EAAS,GAEnD,MAAO,CAAE0F,aAAYpE,KADRqE,EAAKC,SAASC,WAAWH,GAE1C,CF4JiCI,CAA8B9F,GACrD2C,EAAUvB,GAAyBpuC,EAAW3I,EAAOC,EAAQg3C,EAAMoE,GAOzE,MAAO,CAAE1F,UAAS0F,aAAYpE,OAAMqB,UAASoD,YDrK1C,SAA2BC,GAC9B,MAAM,GAAEzD,EAAE,GAAER,EAAE,GAAEC,EAAE,GAAES,GAAOuD,EACrBC,GAAe,KAAAC,eAAc3D,EAAIR,EAAIU,EAAIT,GAAI,GACnD,IAAKiE,EACD,MAAM,IAAIp6C,MAAM,6CAEpB,MAAMwY,EAAS4hC,EACf,IAAIE,EAAaxC,GAASt/B,EAAQk+B,IAAO,IAAM73C,KAAKC,IAChDy7C,EAAWzC,GAASt/B,EAAQo+B,IAAO,IAAM/3C,KAAKC,IAClD,GAAIy7C,GAAYD,EAAY,CACxB,MAAME,EAAYF,EAClBA,EAAaC,EACbA,EAAWC,CACf,CACA,MAAMC,EAAK57C,KAAK67C,MAAMhE,EAAG,GAAKl+B,EAAO,GAAIk+B,EAAG,GAAKl+B,EAAO,IAClDmiC,EAAK97C,KAAK67C,MAAM9D,EAAG,GAAKp+B,EAAO,GAAIo+B,EAAG,GAAKp+B,EAAO,IAClDoiC,EAAK/7C,KAAK67C,MAAMxE,EAAG,GAAK19B,EAAO,GAAI09B,EAAG,GAAK19B,EAAO,IAClDqiC,EAAKh8C,KAAK67C,MAAMvE,EAAG,GAAK39B,EAAO,GAAI29B,EAAG,GAAK39B,EAAO,IAGxD,MAAO,CACHA,SACA8hC,aACAC,WACAO,YANgBj8C,KAAKa,IAAI+6C,EAAIE,GAO7BI,YANgBl8C,KAAKkS,IAAI6pC,EAAIC,GAQrC,CCoIwBG,CAAkB,CAClCtE,GAAII,EAAQJ,GACZR,GAAIY,EAAQZ,GACZC,GAAIW,EAAQX,GACZS,GAAIE,EAAQF,KAGpB,CGxIoB,EAAAhE,UAAA,Y,2CCjCpB,MAAM,GACF,WAAAvxC,CAAY45C,GACRr5C,KAAKs5C,eAAiB,GACtBt5C,KAAKu5C,cAAe,EACpBv5C,KAAK2M,QAAU,EACf3M,KAAKs5C,eAAiB,GACtBt5C,KAAKw5C,YAAcH,GAAOI,YAAc,GACxCz5C,KAAK05C,iBAAmBL,GAAOM,kBAAmB,EAClD35C,KAAK45C,QAAUP,GAAOQ,SAAU,EAChC75C,KAAKu5C,cAAe,CACxB,CACA,iBAAIO,GACA,OAAO95C,KAAKs5C,cAChB,CACA,oBAAIS,GACA,OAAO/5C,KAAKs5C,eAAe14C,MAC/B,CACA,cAAI64C,GACA,OAAOz5C,KAAKw5C,WAChB,CACA,cAAIC,CAAWA,GACPz5C,KAAK05C,kBAAoB15C,KAAKw5C,cAAgBC,IAGlDz5C,KAAKw5C,YAAcC,EACnBz5C,KAAKzE,aAAc,EACvB,CACA,mBAAIo+C,GACA,OAAO35C,KAAK05C,gBAChB,CACA,UAAIG,GACA,OAAO75C,KAAK45C,OAChB,CACA,UAAIC,CAAOA,GACH75C,KAAK45C,UAAYC,IAGrB75C,KAAK45C,QAAUC,EACf75C,KAAKzE,aAAc,EACvB,CACA,QAAIy+C,GAEA,OADAh6C,KAAKi6C,UACEj6C,KAAKk6C,KAChB,CACA,UAAIt5C,GAEA,OADAZ,KAAKi6C,UACEj6C,KAAK2M,OAChB,CACA,eAAIpR,GACA,OAAOyE,KAAKu5C,YAChB,CACA,eAAIh+C,CAAYA,GACZyE,KAAKu5C,aAAeh+C,CACxB,CACA,gBAAA4+C,GACI,OAAO,CACX,CACA,eAAAC,CAAgB9rC,GACZtO,KAAKs5C,eAAe3wC,KAAK,CAAC2F,EAAM,GAAIA,EAAM,KAC1CtO,KAAKzE,aAAc,CACvB,CACA,gBAAA8+C,CAAiB5rC,GACbA,EAAOxN,QAASqN,GAAUtO,KAAKo6C,gBAAgB9rC,GACnD,CACA,kBAAAgsC,CAAmBC,GACf,MAAMC,EAAcx6C,KAAKy6C,kBAAkBF,IACnC7+C,MAAO42C,EAAYtgC,IAAK0oC,GAAaF,EAAY/rC,OACnDksC,EAAoB19C,KAAK+Q,MAAMusC,GAC/BK,EAAe56C,KAAK66C,eAAeF,GACnCzP,EAAIqP,EAAIt9C,KAAK+Q,MAAM2sC,GACnBG,EAAkB,CACpBxI,EAAW,GAAKpH,GAAKwP,EAAS,GAAKpI,EAAW,IAC9CA,EAAW,GAAKpH,GAAKwP,EAAS,GAAKpI,EAAW,KAE5Cx/B,EAAc9S,KAAKs5C,eAAet2C,QAAQ43C,EAAad,cAAcrP,IAAM,EAGjF,OAFAzqC,KAAKs5C,eAAermC,OAAOH,EAAa,EAAGgoC,GAC3C96C,KAAKzE,aAAc,EACZ,CACHiN,MAAOsK,EACPxE,MAAOwsC,EAEf,CACA,yBAAAC,CAA0BvyC,GACtB,MAAMwyC,EAAmBh7C,KAAK45C,QAAU,EAAI,EAI5C,OAHkBpxC,GAAS,GACvBA,EAAQxI,KAAKs5C,eAAe14C,QAC5BZ,KAAKs5C,eAAe14C,OAASo6C,IAIjCh7C,KAAKs5C,eAAermC,OAAOzK,EAAO,GAClCxI,KAAKzE,aAAc,GACZ,EACX,CACA,kBAAA0/C,GACIj7C,KAAKs5C,eAAiB,GACtBt5C,KAAKzE,aAAc,CACvB,CACA,gBAAA2/C,CAAiBzsC,GACbzO,KAAKi7C,qBACLj7C,KAAKq6C,iBAAiB5rC,EAC1B,CACA,kBAAA0sC,CAAmB3yC,EAAO4yC,GACtB,GAAI5yC,EAAQ,GAAKA,GAASxI,KAAKs5C,eAAe14C,OAC1C,MAAM,IAAIxC,MAAM,uBAEpB4B,KAAKs5C,eAAe9wC,GAAS,IAAI4yC,GACjCp7C,KAAKzE,aAAc,CACvB,CACA,gBAAA8/C,GACI,OAAOr7C,KAAKs5C,eAAejzC,IAAKi1C,GAAiB,CAC7CA,EAAa,GACbA,EAAa,IAErB,CACA,sBAAAC,CAAuBjtC,GACnB,MAAMwrC,EAAgB95C,KAAKs5C,eAC3B,IAAIkC,EAAiB7kC,IACjB8kC,GAAqB,EACzB,IAAK,IAAI/xC,EAAI,EAAGgyC,EAAM5B,EAAcl5C,OAAQ8I,EAAIgyC,EAAKhyC,IAAK,CACtD,MAAM4xC,EAAexB,EAAcpwC,GAC7Bob,EAAKxW,EAAM,GAAKgtC,EAAa,GAC7Bv2B,EAAKzW,EAAM,GAAKgtC,EAAa,GAC7BK,EAAc72B,EAAKA,EAAKC,EAAKA,EAC/B42B,EAAcH,IACdA,EAAiBG,EACjBF,EAAoB/xC,EAE5B,CACA,MAAO,CACHlB,MAAOizC,EACPntC,OAA8B,IAAvBmtC,OACDz9C,EACA,IAAI87C,EAAc2B,IACxBz/B,SAAU/e,KAAKopC,KAAKmV,GAE5B,CACA,oCAAAI,CAAqCttC,EAAO+mC,GACxC,MAAMwG,EAAsB77C,KAAKu7C,uBAAuBjtC,GACxD,OAAOutC,EAAoB7/B,UAAYq5B,EACjCwG,OACA79C,CACV,CACA,eAAA89C,CAAgBxtC,GACZtO,KAAKi6C,UACL,MAAM8B,EAAwB/7C,KAAKg8C,sCAAsC1tC,GACzE,IAAKytC,EAAsBn7C,OACvB,OAGJ,IAAIq7C,EADJF,EAAsB9/B,KAAK,CAACigC,EAAKC,IAAQD,EAAIE,gBAAkBD,EAAIC,iBAEnE,IAEIC,EACAC,EAHAC,GAAiC,EACjCC,EAAiB7lC,IAGrB,IAAK,IAAIjN,EAAI,EAAGA,EAAIqyC,EAAsBn7C,OAAQ8I,IAAK,CACnD,MAAM+yC,EAAuBV,EAAsBryC,GACnD,GAAI+yC,EAAqBL,gBAAkBI,EACvC,SAEJ,MAAM,kBAAE7B,EAAiB,aAAEC,GAAiB6B,GACtC,aAAExK,GAAiB2I,EACzB,IAAK,IAAI3oC,EAAI,EAAGA,EAAIggC,EAAarxC,OAAQqR,IAAK,CAC1C,MAAMuoC,EAAcvI,EAAahgC,IACzB3D,MAAOouC,EAAcN,gBAAiBO,GAAuBzE,EAAKsC,YAAYoC,2BAA2BpC,EAAY/rC,OAAO/S,MAAO8+C,EAAY/rC,OAAOuD,IAAK1D,GAC/JquC,EAAqBH,IACrBF,EAAqB9B,EACrB+B,EAAgC5B,EAChC0B,EAAsBI,EAAqB7B,aAC3CqB,EAAeS,EACfF,EAAiBG,EAEzB,CACJ,CAKA,MAAO,CACHruC,MAAO2tC,EACPY,OAHMN,GAHwBD,EAAmBQ,2BACjD5E,EAAK5pC,MAAMyuC,gBAAgBT,EAAmB7tC,OAAO/S,MAAOugD,IAC1BI,EAAoBz7C,OAKtDob,SAAU/e,KAAKopC,KAAKmW,GAE5B,CACA,kCAAAQ,CAAmC1uC,GAC/B,MAAM2uC,EAAa,IAAIj9C,KAAKs5C,gBAI5B,GAHIt5C,KAAK45C,SACLqD,EAAWt0C,KAAK3I,KAAKs5C,eAAe,KAEnC2D,EAAWr8C,OACZ,OAEJ,IAAIq7C,EACAO,EAAiB7lC,IACjB27B,EAAa2K,EAAW,GAC5B,IAAK,IAAIvzC,EAAI,EAAGgyC,EAAMuB,EAAWr8C,OAAQ8I,EAAIgyC,EAAKhyC,IAAK,CACnD,MAAMgxC,EAAWuC,EAAWvzC,IACpB4E,MAAOouC,EAAcN,gBAAiBO,GAAuBzE,EAAKsC,YAAYoC,2BAA2BtK,EAAYoI,EAAUpsC,GACnIquC,EAAqBH,IACrBP,EAAeS,EACfF,EAAiBG,GAErBrK,EAAaoI,CACjB,CACA,MAAO,CACHpsC,MAAO2tC,EACPjgC,SAAU/e,KAAKopC,KAAKmW,GAE5B,CACA,iBAAAU,GAEI,OADAl9C,KAAKi6C,UACEj6C,KAAKm9C,gCAAgCn9C,KAAK66C,eACrD,CACA,wBAAAuC,CAAyBC,EAAqBC,GAC1C,GAAIt9C,KAAK45C,QACL,MAAO,GAEX55C,KAAKi6C,UACL,MAAM4B,EAAsB77C,KAAK47C,qCAAqCyB,EAAqBC,GACrFC,EAA6C,IAA/B1B,GAAqBrzC,MACnCg1C,EAAuBx9C,KAAKy9C,wBAAwBJ,EAAqBE,GAC/E,OAAOC,GAAsB58C,OACvBZ,KAAKm9C,gCAAgCK,GACrC,EACV,CACA,gBAAAE,CAAiBpvC,EAAO+mC,GACpBr1C,KAAKi6C,UACL,MAAM0D,EAAgB39C,KAAK49C,iCAAiCtvC,EAAO+mC,GAC7DwI,EAAiBxI,EAAUA,EACjC,IAAK,IAAI3rC,EAAI,EAAGA,EAAIi0C,EAAc/8C,OAAQ8I,IAAK,CAC3C,MAAM,aAAEuoC,GAAiB0L,EAAcj0C,GACvC,IAAK,IAAIuI,EAAI,EAAGA,EAAIggC,EAAarxC,OAAQqR,IAAK,CAC1C,MAAMuoC,EAAcvI,EAAahgC,GAEjC,GADwBimC,EAAKsC,YAAYsD,uBAAuBtD,EAAY/rC,OAAO/S,MAAO8+C,EAAY/rC,OAAOuD,IAAK1D,IAC3FuvC,EACnB,OAAO,CAEf,CACJ,CACA,OAAO,CACX,CACA,aAAAE,CAAczvC,GACVtO,KAAKi6C,UAEL,GADsBj6C,KAAKs5C,eACT14C,OAAS,EACvB,OAAO,EAEX,MAAM+8C,EAAgB,IAAI39C,KAAK66C,gBACzBmD,EAAsBh+C,KAAKi+C,iDAC7BD,GACAL,EAAch1C,KAAKq1C,GAEvB,IAAIE,EAAmB,EACvB,IAAK,IAAIx0C,EAAI,EAAGA,EAAIi0C,EAAc/8C,OAAQ8I,IAAK,CAC3C,MAAMkxC,EAAe+C,EAAcj0C,IAC3BswC,KAAMmE,GAAiBvD,EAI/B,KAHiCtsC,EAAM,IAAM6vC,EAAax4B,MACtDrX,EAAM,IAAM6vC,EAAa1a,MACzBn1B,EAAM,GAAK6vC,EAAaza,MAExB,SAEJ,MAAM,aAAEuO,GAAiB2I,EACzB,IAAK,IAAIlxC,EAAI,EAAGA,EAAIuoC,EAAarxC,OAAQ8I,IAAK,CAC1C,MAAM8wC,EAAcvI,EAAavoC,IACzBswC,KAAMoE,GAAoB5D,EAIlC,GAHgClsC,EAAM,IAAM8vC,EAAgBz4B,MACxDrX,EAAM,IAAM8vC,EAAgB3a,MAC5Bn1B,EAAM,GAAK8vC,EAAgB1a,KACF,CACzB,MAAQhoC,MAAO+uC,EAAIz4B,IAAKqsC,GAAO7D,EAAY/rC,OACrC6vC,EAAiB7T,EAAG,KAAO4T,EAAG,GAC9BE,GAAkBjwC,EAAM,GAAKm8B,EAAG,KAAO4T,EAAG,GAAK5T,EAAG,KAAQ4T,EAAG,GAAK5T,EAAG,IAAMA,EAAG,GACpFyT,GACII,GAAkBhwC,EAAM,IAAMiwC,EAAgB,EAAI,CAC1D,CACJ,CACJ,CACA,OAAOL,EAAmB,GAAM,CACpC,CACA,OAAAjE,GACI,IAAKj6C,KAAKu5C,aACN,OAEJ,MAAMoE,EAAgB39C,KAAKw+C,kBAC3B,IAAI59C,EAAS,EACT8kB,EAAO/O,IACP8sB,EAAO9sB,IACPgP,GAAQhP,IACR+sB,GAAQ/sB,IACZ,IAAK,IAAIjN,EAAI,EAAGgyC,EAAMiC,EAAc/8C,OAAQ8I,EAAIgyC,EAAKhyC,IAAK,CACtD,MAAQswC,KAAMmE,EAAcv9C,OAAQ69C,GAAmBd,EAAcj0C,GACrEgc,EAAOA,GAAQy4B,EAAaz4B,KAAOA,EAAOy4B,EAAaz4B,KACvD+d,EAAOA,GAAQ0a,EAAa1a,KAAOA,EAAO0a,EAAa1a,KACvD9d,EAAOA,GAAQw4B,EAAax4B,KAAOA,EAAOw4B,EAAax4B,KACvD+d,EAAOA,GAAQya,EAAaza,KAAOA,EAAOya,EAAaza,KACvD9iC,GAAU69C,CACd,CACAz+C,KAAK66C,eAAiB8C,EACtB39C,KAAKk6C,MAAQ,CAAEx0B,OAAM+d,OAAM9d,OAAM+d,QACjC1jC,KAAK2M,QAAU/L,EACfZ,KAAKu5C,cAAe,CACxB,CACA,+BAAA4D,CAAgCQ,GAC5B39C,KAAKi6C,UACL,MAAMyE,EAAiB,GASvB,OARAf,EAAc18C,QAAQ,EAAGgxC,gBAAgB0M,KACrC1M,EAAahxC,QAAQ,CAACu5C,EAAaoE,KACT,IAAlBD,GAAwC,IAAjBC,GACvBF,EAAe/1C,KAAK,IAAI6xC,EAAY/rC,OAAO/S,QAE/CgjD,EAAe/1C,KAAK,IAAI6xC,EAAY/rC,OAAOuD,UAG5C0sC,CACX,CACA,qCAAA1C,CAAsC1tC,GAClCtO,KAAKi6C,UACL,MAAM4E,EAA+B,IAC7BhE,eAAgB8C,GAAkB39C,KAC1C,IAAK,IAAI0J,EAAI,EAAGA,EAAIi0C,EAAc/8C,OAAQ8I,IAAK,CAC3C,MAAMkxC,EAAe+C,EAAcj0C,GAC7B0yC,EAAkBlE,EAAK8B,KAAK8D,uBAAuBlD,EAAaZ,KAAM1rC,GAC5EuwC,EAA6Bl2C,KAAK,CAC9BgyC,kBAAmBjxC,EACnBkxC,eACAwB,mBAER,CACA,OAAOyC,CACX,CACA,gCAAAjB,CAAiCtvC,EAAO+mC,GACpCr1C,KAAKi6C,UACL,MAAM4D,EAAiBxI,EAAUA,EACjC,GAAI6C,EAAK8B,KAAK8D,uBAAuB99C,KAAKg6C,KAAM1rC,GAASuvC,EACrD,MAAO,GAEX,MAAMiB,EAAwB9+C,KAAKg8C,sCAAsC1tC,GACnEywC,EAA2B,GACjC,IAAK,IAAIr1C,EAAI,EAAGgyC,EAAMoD,EAAsBl+C,OAAQ8I,EAAIgyC,EAAKhyC,IAAK,CAC9D,MAAM,aAAEkxC,EAAcwB,gBAAiB4C,GAA4BF,EAAsBp1C,GACrFs1C,GAA2BnB,GAC3BkB,EAAyBp2C,KAAKiyC,EAEtC,CACA,OAAOmE,CACX,CACA,iBAAAtE,CAAkBF,GACdv6C,KAAKi6C,UACL,MAAMU,EAAoB19C,KAAK+Q,MAAMusC,GAC/BrP,EAAIqP,EAAII,EACRC,EAAe56C,KAAK66C,eAAeF,IACnC,aAAE1I,GAAiB2I,EACnBqE,EAAcrE,EAAah6C,OAASsqC,EAC1C,IAAK,IAAIxhC,EAAI,EAAGA,EAAIuoC,EAAarxC,OAAQ8I,IAAK,CAC1C,MAAM8wC,EAAcvI,EAAavoC,GAC3Bw1C,EAAY1E,EAAYsC,2BAA6BtC,EAAY55C,OACvE,GAAIq+C,GAAezE,EAAYsC,4BAC3BmC,GAAeC,EACf,OAAO1E,CAEf,CACJ,CACA,8CAAAyD,GACI,GAAIj+C,KAAK65C,OACL,OAEJ,MAAMC,EAAgB95C,KAAKs5C,eACrB6F,EAAoBrF,EAAc,GAClCsF,EAAkBtF,EAAcA,EAAcl5C,OAAS,GACvDy+C,EAAqB,CACvB5wC,OAAQ,CACJ/S,MAAO,IAAIyjD,GACXntC,IAAK,IAAIotC,IAEbpF,KAAM,CACFt0B,KAAMzoB,KAAKa,IAAIqhD,EAAkB,GAAIC,EAAgB,IACrD3b,KAAMxmC,KAAKa,IAAIqhD,EAAkB,GAAIC,EAAgB,IACrDz5B,KAAM1oB,KAAKkS,IAAIgwC,EAAkB,GAAIC,EAAgB,IACrD1b,KAAMzmC,KAAKkS,IAAIgwC,EAAkB,GAAIC,EAAgB,MAG7D,MAAO,CACHpF,KAAM,CACFt0B,KAAM25B,EAAmBrF,KAAKt0B,KAC9B+d,KAAM4b,EAAmBrF,KAAKvW,KAC9B9d,KAAM05B,EAAmBrF,KAAKr0B,KAC9B+d,KAAM2b,EAAmBrF,KAAKtW,MAElCuO,aAAc,CAACoN,GAEvB,ECpYJ,MAAMC,WAAoB,GACtB,uBAAA7B,CAAwBJ,EAAqBE,GACzC,MAAMgC,EAA0Bv/C,KAAKw/C,uBAAyB,EACxDC,EAAqBxiD,KAAKkS,IAAI,EAAGowC,EAA0B,GAC3DG,EAAmBnC,EACnBgC,EACAA,EAA0B,EAC1BI,EAAkB3/C,KAAK4/C,qBACvB9F,EAAgB,IAAI95C,KAAK85C,eACzB6D,EAAgB,GACjBJ,GACDzD,EAAcnxC,KAAK00C,GAEvB,IAAK,IAAI3zC,EAAI+1C,EAAoB/1C,GAAKg2C,EAAkBh2C,IAAK,CACzD,MAAMkxC,EAAe56C,KAAK6/C,iBAAiBn2C,EAAGi2C,EAAiB7F,EAAeyD,GAC9EI,EAAch1C,KAAKiyC,EACvB,CACA,OAAO+C,CACX,CACA,eAAAa,GACI,MAAMsB,EAAmB9/C,KAAKw/C,uBACxB7B,EAAgB,IAAIj/C,MAAMohD,GAChC,GAAIA,GAAoB,EACpB,MAAO,GAEX,MAAMH,EAAkB3/C,KAAK4/C,qBAC7B,IAAIG,EAA8B,EAClC,IAAK,IAAIr2C,EAAI,EAAGA,EAAIo2C,EAAkBp2C,IAAK,CACvC,MAAMkxC,EAAe56C,KAAK6/C,iBAAiBn2C,EAAGi2C,GAC9C/E,EAAamF,4BAA8BA,EAC3CpC,EAAcj0C,GAAKkxC,EACnBmF,GAA+BnF,EAAah6C,MAChD,CACA,OAAO+8C,CACX,CACA,oBAAA6B,CAAqB1F,EAAgB95C,KAAK85C,cAAeD,EAAS75C,KAAK65C,QACnE,OAAOA,EACDC,EAAcl5C,OACd3D,KAAKkS,IAAI,EAAG2qC,EAAcl5C,OAAS,EAC7C,CACA,SAAAo/C,CAAUzF,EAAGoF,EAAiB7F,EAAgB95C,KAAK85C,cAAeD,EAAS75C,KAAK65C,QAC5E,MAAMiG,EAAmB9/C,KAAKw/C,qBAAqB1F,EAAeD,GAC5DoG,EAAOhjD,KAAK+Q,MAAMusC,GACxB,IAAII,EAAoBsF,EAAOH,EAC/B,MAAM5U,EAAIqP,EAAI0F,EAEd,GADqCtF,EAAoB,GAAKA,GAAqBmF,EACjD,CAC9B,IAAI9/C,KAAK65C,OAKL,OAJAc,GACKmF,EAAmBnF,GAAqBmF,CAKrD,CACA,MAAM,GAAEtV,EAAE,GAAEC,EAAE,GAAE4T,EAAE,GAAE6B,GAAOlgD,KAAKmgD,uBAAuBxF,EAAmBb,EAAeD,GACnFuG,EAAKlV,EAAIA,EACTmV,EAAMD,EAAKlV,EACXoV,EAAU,gBAAgB,EAAGpV,EAAGkV,EAAIC,GACpCE,EAAU,mBAAmB,cAAeD,EAASX,GAC3D,MAAO,CACH,SAASY,EAAS,gBAAgB/V,EAAG,GAAIC,EAAG,GAAI4T,EAAG,GAAI6B,EAAG,KAC1D,SAASK,EAAS,gBAAgB/V,EAAG,GAAIC,EAAG,GAAI4T,EAAG,GAAI6B,EAAG,KAElE,CACA,sBAAAC,CAAuBxF,EAAmBb,EAAgB95C,KAAK85C,cAAeD,EAAS75C,KAAK65C,QACxF,MAAMiG,EAAmB9/C,KAAKw/C,qBAAqB1F,EAAeD,GAE5D2G,EADU7F,EACU,EACpB8F,EAAU5G,GAFAc,EAEoB,GAAKmF,EAFzBnF,EAEsD,EAChE+F,EAAUD,EAAU,EACpBhW,EAAKqP,EAJKa,GAKV0D,EAAKvE,EAAc2G,GACzB,IAAIjW,EACA0V,EAeJ,OAbI1V,EADAgW,GAAW,EACN1G,EAAc0G,GAGd3G,EACCC,EAAcA,EAAcl5C,OAAS,GACrCs3C,EAAK5pC,MAAMqyC,OAAOtC,EAAI5T,GAG5ByV,EADAQ,EAAU5G,EAAcl5C,OACnBk5C,EAAc4G,GAGd7G,EAASC,EAAc,GAAK5B,EAAK5pC,MAAMqyC,OAAOlW,EAAI4T,GAEpD,CAAE7T,KAAIC,KAAI4T,KAAI6B,KACzB,CACA,gBAAAU,CAAiBjG,EAAmBgF,EAAiB7F,EAAgB95C,KAAK85C,cAAeD,EAAS75C,KAAK65C,QACnG,MAAMiG,EAAmB9/C,KAAKw/C,qBAAqB1F,EAAeD,GAC5DgH,EAAkB7gD,KAAKy5C,WAAa,EACpCqH,EAAM,EAAID,EAEhB,IAAIE,EADSpG,EACK,EACbd,GAAUc,IAAsBmF,EAAmB,IACpDiB,GAnGQ,MAqGZ,MAAM9O,EAAe,GACrB,IAAIK,EACAoI,EACAoC,EAA6B,EACjC,IAAK,IAAIpzC,EAAI,EAAG6wC,EATHI,EASajxC,GAAKm3C,EAAiBn3C,IAAK6wC,GAAKuG,EAAK,CAC3DvG,EAAIA,EAAIwG,EAAOA,EAAOxG,EACtB,MAAMjsC,EAAQtO,KAAKggD,UAAUzF,EAAGoF,EAAiB7F,EAAeD,GAChE,IAAKnwC,EAAG,CACJ4oC,EAAahkC,EACb,QACJ,CACAosC,EAAWpsC,EACX,MAAMwW,EAAK41B,EAAS,GAAKpI,EAAW,GAC9BvtB,EAAK21B,EAAS,GAAKpI,EAAW,GAC9B1xC,EAAS3D,KAAKopC,KAAKvhB,GAAM,EAAIC,GAAM,GACnCi1B,EAAO,CACTt0B,KAAM4sB,EAAW,IAAMoI,EAAS,GAAKpI,EAAW,GAAKoI,EAAS,GAC9D/0B,KAAM2sB,EAAW,IAAMoI,EAAS,GAAKpI,EAAW,GAAKoI,EAAS,GAC9DjX,KAAM6O,EAAW,IAAMoI,EAAS,GAAKpI,EAAW,GAAKoI,EAAS,GAC9DhX,KAAM4O,EAAW,IAAMoI,EAAS,GAAKpI,EAAW,GAAKoI,EAAS,IAElEzI,EAAatpC,KAAK,CACd8F,OAAQ,CACJ/S,MAAO42C,EACPtgC,IAAK0oC,GAETV,OACAp5C,SACAk8C,+BAEJxK,EAAaoI,EACboC,GAA8Bl8C,CAClC,CACA,OAAOqxC,CACX,CACA,gBAAA4N,CAAiBlF,EAAmBgF,EAAkB3/C,KAAK4/C,qBAAsB9F,EAAgB95C,KAAK85C,cAAeD,EAAS75C,KAAK65C,QAC/H,MAAM,GAAErP,EAAE,GAAEC,EAAE,GAAE4T,EAAE,GAAE6B,GAAOlgD,KAAKmgD,uBAAuBxF,EAAmBb,EAAeD,GACnF5H,EAAejyC,KAAK4gD,iBAAiBjG,EAAmBgF,EAAiB7F,EAAeD,GAC9F,IAAImH,EAAqB,EACrBt7B,EAAO/O,IACP8sB,EAAO9sB,IACPgP,GAAQhP,IACR+sB,GAAQ/sB,IAQZ,OAPAs7B,EAAahxC,QAAQ,EAAG+4C,KAAMiH,EAAargD,OAAQsgD,MAC/Cx7B,EAAOzoB,KAAKa,IAAI4nB,EAAMu7B,EAAYv7B,MAClC+d,EAAOxmC,KAAKa,IAAI2lC,EAAMwd,EAAYxd,MAClC9d,EAAO1oB,KAAKkS,IAAIwW,EAAMs7B,EAAYt7B,MAClC+d,EAAOzmC,KAAKkS,IAAIu0B,EAAMud,EAAYvd,MAClCsd,GAAsBE,IAEnB,CACHpH,cAAe,CAAEtP,KAAIC,KAAI4T,KAAI6B,MAC7BlG,KAAM,CAAEt0B,OAAM+d,OAAM9d,OAAM+d,QAC1B9iC,OAAQogD,EACRjB,4BAA6B,EAC7B9N,eAER,EC/JJ,MAAMkP,GAAmB,oBAAoB,cAAe,gBAAgB,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,EAAG,EAAG,GAAI,EAAG,EAAG,GAAI,EAAG,GAAI,EAAG,GAAI,EAAI,GACrI,MAAMC,WAAgB9B,GAClB,kBAAAM,GACI,OAAOuB,EACX,ECLJ,MAAME,WAAuB/B,GACzB,WAAA7/C,CAAY45C,GACRiI,MAAMjI,GACNr5C,KAAKuhD,OAASlI,GAAO78C,OAAS,GAC9BwD,KAAKwhD,YAAcnI,GAAOoI,aAAc,CAC5C,CACA,SAAIjlD,GACA,OAAOwD,KAAKuhD,MAChB,CACA,SAAI/kD,CAAMA,GACFwD,KAAKwhD,aAAexhD,KAAKuhD,SAAW/kD,IAGxCwD,KAAKuhD,OAAS/kD,EACdwD,KAAKzE,aAAc,EACvB,CACA,cAAIkmD,GACA,OAAOzhD,KAAKwhD,WAChB,CACA,kBAAA5B,GACI,MAAQpjD,MAAOklD,GAAM1hD,KACf2hD,EAAK,EAAID,EACf,MAAO,CACH,EAAG,EAAG,EAAG,GACRA,EAAG,EAAGA,EAAG,EACVC,EAAID,EAAI,EAAG,EAAIC,GAAKD,GACnBA,EAAG,EAAIA,EAAGA,EAAI,EAAGA,EAE1B,EC5BJ,MAAME,WAAyBP,GAC3B,WAAA5hD,GACI6hD,MAAM,CAAE9kD,MAAO,GAAKilD,YAAY,GACpC,ECHJ,MAAMI,WAAqBR,GACvB,WAAA5hD,GACI6hD,MAAM,CAAE7H,WAAY,EAAGE,iBAAiB,EAAMn9C,MAAO,EAAGilD,YAAY,GACxE,E,gBCFJ,MAAMK,WAAgB,MAClB,WAAAriD,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXy1C,iBAAiB,KAGrBZ,MAAMS,EAAWC,EACrB,CACA,iBAAAG,CAAkBC,GACdpiD,KAAKqiD,cAAcD,EACvB,CACA,iBAAAE,CAAkBF,GACdpiD,KAAKqiD,cAAcD,EACvB,CACA,qBAAAG,CAAsBrmD,EAAUsmD,GAC5B,MAAM,OAAE/mD,GAAWS,EACby9B,EAAQpK,OAAOD,iBAEfmzB,EAAgBhnD,EAAOmB,MAAQ+8B,EAE/B+oB,EAAiBjnD,EAAOoB,OAAS88B,EACjCgpB,EAAezmD,EAAS0mD,kBACxBC,EAAW3mD,EAAS4mD,cAC1B,IAAIv6B,EACJ,GAAIo6B,GAAgB,yBAAqBA,GAAe,CAEpDp6B,EADkBo6B,EAAaxsC,MAAMkI,YAAYa,eAC9B6jC,WACvB,MAEIx6B,EAASs6B,EAASG,2BAEtB,MAAOC,EAAWC,GAAYhnD,EAASinD,cAAc,CACjD56B,EAAO,GACPA,EAAO,GACPA,EAAO,MAEJ66B,EAAYC,GAAennD,EAASinD,cAAc,CACrD56B,EAAO,GACPA,EAAO,GACPA,EAAO,KAGX,GADarsB,EAASonD,WACV,GACR,GAAKL,EAAYT,EAAkB,GA1BlB,GA2BbA,EAAkB,GAAK,GACtBY,EAAaZ,EAAkB,GAAKC,GACjCD,EAAkB,GAAK,GAC1BU,EAAWV,EAAkB,GA5BlB,GA6BRA,EAAkB,GAAK,GAC1Ba,EAAcb,EAAkB,GAAKE,GAClCF,EAAkB,GAAK,EAC3B,OAAO,OAIX,GAAKS,EAAYT,EAAkB,GAtClB,GAuCbA,EAAkB,GAAK,GACtBY,EAAaZ,EAAkB,GAAKC,GACjCD,EAAkB,GAAK,GAC1BU,EAAWV,EAAkB,GAxClB,GAyCRA,EAAkB,GAAK,GAC1Ba,EAAcb,EAAkB,GAAKE,GAClCF,EAAkB,GAAK,EAC3B,OAAO,EAGf,OAAO,CACX,CACA,aAAAH,CAAcD,GACV,MAAM,QAAEjzB,EAAO,YAAEo0B,GAAgBnB,EAAIrtB,OAC/Bz5B,GAAiB,IAAAy/B,mBAAkB5L,GACnCq0B,EAAmBD,EAAYE,MAC/BjB,EAAoBe,EAAY9nD,OACtC,GAA4B,IAAxB+nD,EAAiB,IACO,IAAxBA,EAAiB,IACO,IAAxBA,EAAiB,GACjB,OAEJ,MAAMtnD,EAAWZ,EAAeY,SAC1BsmB,EAAStmB,EAASumB,aAClB,WAAEE,EAAU,SAAEiN,GAAapN,EACjC,GAAIxiB,KAAKyM,cAAcy1C,kBAClBliD,KAAKuiD,sBAAsBrmD,EAAUsmD,GACtC,OAEJ,MAAMkB,EAAkB,CACpB9zB,EAAS,GAAK4zB,EAAiB,GAC/B5zB,EAAS,GAAK4zB,EAAiB,GAC/B5zB,EAAS,GAAK4zB,EAAiB,IAE7BG,EAAoB,CACtBhhC,EAAW,GAAK6gC,EAAiB,GACjC7gC,EAAW,GAAK6gC,EAAiB,GACjC7gC,EAAW,GAAK6gC,EAAiB,IAErCtnD,EAAS6lC,UAAU,CACfpf,WAAYghC,EACZ/zB,SAAU8zB,IAEdxnD,EAASD,QACb,EAEJ6lD,GAAQ8B,SAAW,M,gBCnGnB,MAAMC,WAA4B,MAC9B,WAAApkD,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXq3C,uBAAwB,EACxBC,2BAA4B,KAGhCzC,MAAMS,EAAWC,GACjBhiD,KAAKgkD,iBAAmB,IAAIxyC,IAC5BxR,KAAKikD,uBAAwB,EAC7BjkD,KAAKkkD,qBAAwB9B,IACzB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACdz1B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EAGf6oD,EAFajoD,EAAS0mD,kBACHzsC,MACJkI,YAErB,KAD0B,sBAAuB8lC,GAAU,6BAA8BA,GAErF,OAAO,EAEX,MAAMC,EAAyBD,EAAOE,oBACtC,IAAKrkD,KAAKikD,sBAAuB,CAC7B,MAAM,2BAAEF,GAA+B/jD,KAAKyM,cAC5C03C,EAAO7lC,kBAAkB8lC,EAAyBL,GAClD/jD,KAAKikD,uBAAwB,EACR,OAAjBjkD,KAAKskD,SACLl1B,SAAStE,oBAAoB,UAAW9qB,KAAKskD,SAEjDtkD,KAAKskD,QAAU,KACXH,EAAO7lC,kBAAkB8lC,GACzBloD,EAASD,SACT+D,KAAKikD,uBAAwB,GAEjC70B,SAAS3E,iBAAiB,UAAWzqB,KAAKskD,QAAS,CAAEC,MAAM,GAC/D,CACA,OAAO,GAEXvkD,KAAKwkD,kBAAoB,KACH,IAAAC,cAAazkD,KAAK0kD,aAAaC,cAGrD3kD,KAAK4kD,gBAAkB,KACnB,MAAMC,EAA2B,KACP7kD,KAAKwkD,oBACbvjD,QAAQ,EAAGiuB,aAAYhB,wBACjC,IAAKluB,KAAKgkD,iBAAiB3gD,IAAI6rB,GAAa,CACxC,MAAM,SAAEhzB,IAAa,IAAA4oD,wBAAuB51B,EAAYhB,IAAsB,CAAEhyB,SAAU,MAC1F,IAAKA,EACD,OAEJ,MAAM,QAAEizB,GAAYjzB,EACd6oD,EAAiB,IAAIC,eAAe,KACtC,MAAM71B,GAAU,IAAA21B,wBAAuB51B,EAAYhB,GACnD,IAAKiB,EACD,OAEJ,MAAM,SAAEjzB,GAAaizB,EACf81B,EAAmB/oD,EAASggC,sBAClChgC,EAASg2B,cACTh2B,EAAS0gC,oBAAoBqoB,GAC7B/oD,EAASD,WAEb8oD,EAAeG,QAAQ/1B,GACvBnvB,KAAKgkD,iBAAiB9jD,IAAIgvB,EAAY61B,EAC1C,KAGRF,IACA7kD,KAAKmlD,uBAA0B/C,IACvBA,EAAIrtB,OAAO2vB,cAAgB1kD,KAAK0kD,aAChCG,KAGR,EAAAjwB,YAAYnK,iBAAiB,EAAAgH,OAAO2zB,yBAA0BplD,KAAKmlD,yBAEvEnlD,KAAKqlD,kBAAoB,KACrBrlD,KAAKgkD,iBAAiB/iD,QAAQ,CAAC8jD,EAAgB71B,KAC3C61B,EAAeO,aACftlD,KAAKgkD,iBAAiBxgD,OAAO0rB,KAE7BlvB,KAAKmlD,yBACL,EAAAvwB,YAAY9J,oBAAoB,EAAA2G,OAAO2zB,yBAA0BplD,KAAKmlD,wBACtEnlD,KAAKmlD,uBAAyB,OAGtCnlD,KAAKulD,aAAe,CAACrpD,EAAUspD,EAAaC,EAAM3oD,KAC9C,MAAM4oD,EAAYxpD,EAASypD,qBACrB3gB,EAAS0gB,EAAUE,YACnBjjC,EAAa+iC,EAAUG,gBACvBj2B,EAAW81B,EAAUI,cACrB3wB,EAAc,CAAC,EAAG,EAAG,GACrB0M,EAAgB,CAAC,EAAG,EAAG,GACvBkkB,EAAY,CAAC,EAAG,EAAG,GACnBtpD,EAAY,cAAc,IAAIwM,aAAa,KACjD,eAAexM,EAAWA,EAAW+oD,GACrC,YAAY/oD,EAAWA,EAAWK,EAAO2oD,GACzC,eAAehpD,EAAWA,EAAW,EAChC+oD,EAAY,IACZA,EAAY,IACZA,EAAY,KAEjB,mBAAmBrwB,EAAavF,EAAUnzB,GAC1C,mBAAmBolC,EAAelf,EAAYlmB,GAC9C,cAAcA,GACd,YAAYA,EAAWA,EAAWK,EAAO2oD,GACzC,mBAAmBM,EAAW/gB,EAAQvoC,GACtCP,EAAS6lC,UAAU,CACfnS,SAAUuF,EACV6P,OAAQ+gB,EACRpjC,WAAYkf,KAGpB7hC,KAAKmiD,kBAAoBniD,KAAKqiD,cAAc7xC,KAAKxQ,MACjDA,KAAKsiD,kBAAoBtiD,KAAKqiD,cAAc7xC,KAAKxQ,KACrD,CACA,aAAAqiD,CAAcD,GACV,MAAM,QAAEjzB,EAAO,cAAE62B,EAAa,WAAEC,GAAe7D,EAAIrtB,OAC7CmxB,EAAsBF,EAAcvqD,OACpC0qD,EAAmBF,EAAWxqD,QAC9B,uBAAEqoD,GAA2B9jD,KAAKyM,cAClCnR,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACfknB,EAAStmB,EAASumB,YAClB7lB,EAAQuyB,EAAQi3B,YAChBvpD,EAASsyB,EAAQk3B,aACjBC,EAAqB,CACvBJ,EAAoB,GAAKtpD,EACzBspD,EAAoB,GAAKrpD,GAEvB0pD,EAA6B,CAC/BJ,EAAiB,GAAKvpD,EACtBupD,EAAiB,GAAKtpD,GAEpB+Z,EAAS,CAAS,GAARha,EAAsB,GAATC,GACvB2oD,EAActpD,EAASk1B,cAAcxa,GAErC4vC,GAAS,EAAMvpD,KAAK6e,IADA,MAC6B,EACjD2qC,EAAK,CAACF,EAA2B,GAAI,EAAG,GACxCG,EAAK,CAACJ,EAAmB,GAAI,EAAG,GAChCK,EAAOF,EAAG,IAAM,EAChBG,EAAOF,EAAG,IAAM,EAChBG,EAAMF,EAAOH,EAAQ,EAAIvpD,KAAKopC,KAAKmgB,EAAQG,GAC3CG,EAAMF,EAAOJ,EAAQ,EAAIvpD,KAAKopC,KAAKmgB,EAAQI,GAC3CG,EAAM,CAACN,EAAG,GAAI,EAAGI,GACvB,gBAAkBE,GAClB,MAAMC,EAAM,CAACN,EAAG,GAAI,EAAGI,GACvB,gBAAkBE,GAClB,MAAMC,EAAM,UAAYF,EAAKC,GAC7B,GAAI/pD,KAAK6e,IAAImrC,GAAO,KAAQ,CACxB,MAAMC,GAAU,EACZjqD,KAAKkqD,KAAK,iBAAmBF,GAAM,EAAK,IACxChqD,KAAK0vC,KAAK2Z,EAAmB,GAAKC,EAA2B,IAC7DzC,EACEsD,EAAQ5kC,EAAOwiB,OACfqiB,EAAM7kC,EAAOjB,gBACb+lC,EAAS,CAAC,EAAG,EAAG,GAChBC,EAAW,CAAC,EAAG,EAAG,GACxB,YAAcH,EAAOC,EAAKC,GAC1B,gBAAkBA,GAClB,YAAcD,EAAKC,EAAQC,GAC3B,gBAAkBA,GAClB,gBAAkBH,GAClBpnD,KAAKulD,aAAarpD,EAAUspD,EAAa+B,EAAUL,GACnD,MAAMM,GAAUjB,EAA2B,GAAKD,EAAmB,IAC/DxC,EACJ9jD,KAAKulD,aAAarpD,EAAUspD,EAAa8B,EAAQE,GACjDtrD,EAASD,QACb,CACJ,EAEJ4nD,GAAoBD,SAAW,kB,sFCtK/B,MAAM6D,GACI,EADJA,GAEI,EAFJA,GAGI,EAHJA,GAII,EAJJA,GAKI,EALJA,GAMI,EAEJC,GAAc,CAChBC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,KAAM,EACNC,eAAgB,EAChBC,eAAgB,EAChBC,eAAgB,EAChBC,eAAgB,EAChBC,eAAgB,GAChBC,eAAgB,GAChBC,eAAgB,GAChBC,eAAgB,IAEpB,MAAMC,WAA2B,MAC7B,WAAAhpD,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3Cv1C,cAAe,CACXi8C,mBAAmB,EACnBC,aAAa,EACbC,oBAAoB,EACpBC,OAAQ,CACJC,SAAS,EACTjxC,QAAS,IAEbkxC,kBAAmB,IACnBC,aAAc,CACVC,SAAU,CAAC,EAAK,EAAK,GACrBC,QAAS,CAAC,EAAK,EAAK,GACpBC,MAAO,CAAC,EAAK,EAAK,GAClBC,QAAS,CAAC,EAAK,EAAK,IAExBC,aAAc,EACdC,wBAAyB,GACzBxF,uBAAwB,EACxBC,2BAA4B,KAGhCzC,MAAMS,EAAWC,GACjBhiD,KAAKgkD,iBAAmB,IAAIxyC,IAC5BxR,KAAKikD,uBAAwB,EAC7BjkD,KAAKupD,uBAAyB,GAC9BvpD,KAAKwpD,oBAAsB,KAC3BxpD,KAAKypD,WAAa,CAAC,EAAG,EAAG,GACzBzpD,KAAK0pD,iBAAmB,KACxB1pD,KAAK2pD,eAAiB,KACtB3pD,KAAK4pD,aAAe,GACpB5pD,KAAK6pD,UAAY,CAAC,EAClB7pD,KAAK8pD,uBAAyB,KAC1B15C,QAAQqM,MAAM,uDAElBzc,KAAK+pD,iBAAmB,KACpB35C,QAAQqM,MAAM,yCAElBzc,KAAKgqD,iBAAoB5H,IACrB,MAAM,QAAEjzB,GAAYizB,EAAI6H,cAClB,CAAE96B,QAASizB,EAAI6H,eACf7H,EAAIrtB,OACJz5B,GAAiB,IAAAy/B,mBAAkB5L,GACzCnvB,KAAKkqD,sBAAsB5uD,EAAeY,UAC1CZ,EAAeY,SAASD,UAE5B+D,KAAKkkD,qBAAwB9B,IACzB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACdz1B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EAGf6oD,EAFajoD,EAAS0mD,kBACHzsC,MACJkI,YACf8rC,EAAc,CAChB/H,EAAIrtB,OAAOixB,cAAcvqD,OAAO,GAChC2mD,EAAIrtB,OAAOixB,cAAcvqD,OAAO,IAEpCuE,KAAKwpD,oBAAsB,KAC3BxpD,KAAK0pD,iBAAmB,KACxB1pD,KAAK2pD,eAAiB,KACtB,IAAK,IAAIjgD,EAAI,EAAGA,EAAI1J,KAAK4pD,aAAahpD,SAAU8I,EAAG,CAC/C,MAAM0gD,EAAeluD,EAASinD,cAAcnjD,KAAK4pD,aAAalgD,GAAG4E,OAGjE,GAFarR,KAAKopC,KAAKppC,KAAKotD,IAAIF,EAAY,GAAKC,EAAa,GAAI,GAC9DntD,KAAKotD,IAAIF,EAAY,GAAKC,EAAa,GAAI,IACpCpqD,KAAKyM,cAAc68C,wBAAyB,CACnDtpD,KAAKwpD,oBAAsB9/C,EAC3BylB,EAAQO,MAAM46B,OAAS,WACvB,MAAMC,EAAcvqD,KAAK4pD,aAAalgD,GAChC8gD,EAAatuD,EAASk1B,cAAc+4B,GAC1C,GAAII,EAAYE,SACZzqD,KAAK0pD,iBAAmB,CACpBa,EAAYj8C,MAAM,GAAKk8C,EAAW,GAClCD,EAAYj8C,MAAM,GAAKk8C,EAAW,GAClCD,EAAYj8C,MAAM,GAAKk8C,EAAW,IAEtCxqD,KAAK2pD,eAAiB,SAErB,CACD,MAAMe,EAAU,CAAEptD,EAAG,EAAGE,EAAG,EAAGqR,EAAG,GAAI07C,EAAY9E,MACjDzlD,KAAK2pD,eACDY,EAAYj8C,MAAMo8C,GAAWF,EAAWE,GAC5C1qD,KAAK0pD,iBAAmB,IAC5B,CACA,OAAO,CACX,CACJ,CAEA,KAD0B,sBAAuBvF,GAAU,6BAA8BA,GAErF,OAAO,EAEX,MAAMC,EAAyBD,EAAOE,oBACtC,IAAKrkD,KAAKikD,sBAAuB,CAC7B,MAAM,2BAAEF,GAA+B/jD,KAAKyM,cAC5C03C,EAAO7lC,kBAAkB8lC,EAAyBL,GAClD/jD,KAAKikD,uBAAwB,EACR,OAAjBjkD,KAAKskD,SACLl1B,SAAStE,oBAAoB,UAAW9qB,KAAKskD,SAEjDtkD,KAAKskD,QAAU,KAGX,GAFAH,EAAO7lC,kBAAkB8lC,GACzBhC,EAAIj4B,OAAOuF,MAAM46B,OAAS,GACO,OAA7BtqD,KAAKwpD,oBAA8B,CACnC,MAAMe,EAAcvqD,KAAK4pD,aAAa5pD,KAAKwpD,sBACpCmB,GAAc3qD,KAAKwkD,oBAEpBtoD,GADkB,IAAAiyB,oBAAmBw8B,EAAWz8B,mBACrBkC,YAAYu6B,EAAWz7B,YACpDq7B,EAAYE,WACZzqD,KAAK4qD,uBACL5qD,KAAK6qD,gCACL7qD,KAAK8qD,qCAAqC5uD,GAElD,CACA8D,KAAKwpD,oBAAsB,KAC3BxpD,KAAK0pD,iBAAmB,KACxB1pD,KAAK2pD,eAAiB,KACtBztD,EAASD,SACT+D,KAAKikD,uBAAwB,GAEjC70B,SAAS3E,iBAAiB,UAAWzqB,KAAKskD,QAAS,CAAEC,MAAM,GAC/D,CACA,OAAO,GAEXvkD,KAAK+qD,mBAAsB3I,IACvB,GAAiC,OAA7BpiD,KAAKwpD,oBACL,OAAO,EAEX,MAAMe,EAAcvqD,KAAK4pD,aAAa5pD,KAAKwpD,qBAC3C,IAAKe,EACD,OAAO,EAEX,MAAM,SAAEruD,EAAQ,MAAEunD,GAAUzjD,KAAKgrD,2BAA2B5I,GAC5D,IAAKlmD,IAAaunD,EACd,OAAO,EAEX,GAAI8G,EAAYE,SAAU,CACtB,MAAMQ,EAAYjrD,KAAKkrD,4BAA4BzH,GACnDzjD,KAAKmrD,sBAAsBZ,EAAaU,GACxC,MAAMG,EAAYprD,KAAKqrD,gBAAgBd,EAAYznC,KACnD9iB,KAAKsrD,sBAAsBf,EAAaU,EAAWG,GACnDprD,KAAK6qD,gCACL7qD,KAAK4qD,sBACT,KACK,CACD,MAAMF,EAAU,CAAEptD,EAAG,EAAGE,EAAG,EAAGqR,EAAG,GAAI07C,EAAY9E,MACjD,IAAI8F,EAAW9H,EAAMiH,GACO,OAAxB1qD,KAAK2pD,iBACL4B,GAAYvrD,KAAK2pD,gBAErBY,EAAYj8C,MAAMo8C,GAAWa,EAC7BhB,EAAYiB,aAAaC,aAAalB,EAAYj8C,OAClDi8C,EAAYiB,aAAatb,WACzBlwC,KAAK0rD,gCACL1rD,KAAK6qD,gCACL7qD,KAAK4qD,sBACT,CAIA,OAHA5qD,KAAK8qD,qCAAqC5uD,GAC1CA,EAASD,SACT+D,KAAK2rD,yBAAyBpB,IACvB,GAEXvqD,KAAK4rD,qBAAwBxJ,IACzB,MAAMlmD,EAAW8D,KAAK6rD,eACtB,GAAKzJ,EAAIrtB,OAAO00B,WAQX,CACD,GAAIrH,EAAIrtB,OAAOqG,oBAAsBp7B,KAAKo7B,kBACtC,OAEJ,MAAM0wB,EAAkC,QAA1B1J,EAAIrtB,OAAOg3B,WACnBtC,EAAaqC,EACb1J,EAAIrtB,OAAOi3B,cACX5J,EAAIrtB,OAAOk3B,cACXC,EAAUJ,EACV,CACE,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,GACP,CAAC,EAAG,EAAG,IAET,CACE,EAAE,EAAG,EAAG,GACR,CAAC,GAAI,EAAG,GACR,CAAC,EAAG,GAAI,IAEVK,EAAeL,EACf,CAACrE,GAAiBA,GAAiBA,IACnC,CAACA,GAAiBA,GAAiBA,IACnC2E,EAAgBN,EAChB,CAACpE,GAAYC,KAAMD,GAAYG,KAAMH,GAAYK,MACjD,CAACL,GAAYE,KAAMF,GAAYI,KAAMJ,GAAYM,MACjDqE,EAAO,CAAC,IAAK,IAAK,KAClBC,EAAkB,CACpB,EAAA1b,MAAA,gBAAsBqY,SACtB,EAAArY,MAAA,gBAAsBsY,QACtB,EAAAtY,MAAA,gBAAsBuY,OAE1B,IAAK,IAAIz/C,EAAI,EAAGA,EAAI,IAAKA,EAAG,CACxB,MAAM3B,EAAS,CAAC,EAAG,EAAG,GACtBA,EAAO2B,GAAK+/C,EAAW//C,GACvB,MAAMutB,EAAQ,kBAAqB,CAC/BlvB,SACAojC,OAAQ+gB,EAAQxiD,KAEpB1J,KAAKupD,uBAAuB4C,EAAaziD,IAAI3B,OAASkvB,EAAMs1B,YAC5DvsD,KAAK4pD,aAAawC,EAAc1iD,IAAI4E,MAAM5E,GAAKutB,EAAMs1B,YAAY7iD,GACjE1J,KAAK4pD,aAAawC,EAAc1iD,IAAI8hD,aAAaC,aAAazrD,KAAK4pD,aAAawC,EAAc1iD,IAAI4E,OAClGtO,KAAK4pD,aAAawC,EAAc1iD,IAAI8hD,aAAatb,WACjD,MACMsc,GADcxsD,KAAK4pD,aAAalsC,KAAK,CAACgkC,EAAG/P,IAAQ+P,EAAE+D,OAAS4G,EAAK3iD,IAAMioC,IAAQya,EAAc1iD,IACpE4E,MAAM5E,GAAKutB,EAAMs1B,YAAY7iD,IAAM,EAClE1J,KAAK4pD,aAAa3oD,QAAS4oB,IAClBA,EAAM4gC,UACP5gC,EAAM47B,OAAS4G,EAAK3iD,IACnB04C,EAAIrtB,OAAO03B,oBAAoB5xC,SAASyxC,EAAgB5iD,MACzDmgB,EAAMvb,MAAM5E,GAAK8iD,EACjB3iC,EAAM2hC,aAAaC,UAAU5hC,EAAMvb,OACnCub,EAAM6iC,YAAYn1C,cAAco1C,SAAS9iC,EAAMztB,OAC/CytB,EAAM2hC,aAAatb,cAG3B,MAAMhyB,EAAchiB,EAAS0mD,mBAAmBzsC,MAChD,GAAI+H,EAAa,CACb,MACM0uC,EADS1uC,EAAYG,YACGwuC,oBAC1BD,GACAA,EAAeT,EAAaziD,IAAIojD,UAAU71B,EAAMs1B,YAExD,CACJ,CACAvsD,KAAK4qD,uBACL1uD,EAASD,QACb,MAxEI,IAAAmmC,cAAa,EAAAxN,YAAa,EAAAnD,OAAOs7B,4BAA6B,CAC1DxD,uBAAwBvpD,KAAKupD,uBAC7Br6B,WAAYhzB,EAASmN,GACrB6kB,kBAAmBhyB,EAASgyB,kBAC5BkN,kBAAmBp7B,KAAKo7B,qBAsEpCp7B,KAAKwkD,kBAAoB,KACH,IAAAC,cAAazkD,KAAK0kD,aAAaC,cAGrD3kD,KAAKgtD,uBAA0BrI,IAC3B,IAAKA,IAAkBA,EAAc/jD,SAAW+jD,EAAc,GAE1D,YADAv0C,QAAQC,KAAK,4FAGjB,MAAMnU,EAAW8D,KAAK6rD,eAChBnlC,EAAexqB,EAAS0mB,YAC9B,IAAK8D,GAAwC,IAAxBA,EAAa9lB,OAE9B,YADAwP,QAAQC,KAAK,+DAGjB,MAAMsU,EAAY+B,EAAa,GAAGvQ,MAAMkI,YAAYa,eACpD,IAAKyF,EAED,YADAvU,QAAQC,KAAK,6DAGjBrQ,KAAKo7B,kBAAoBzW,EAAUyW,mBAAqB,UACxD,MAAM6xB,EAActoC,EAAUo+B,YACxBmK,EAAaltD,KAAKyM,cAAcs8C,mBAAqB,GACrDoE,EAASF,EAAY,GAAKA,EAAY,GACtCG,EAASH,EAAY,GAAKA,EAAY,GACtCI,EAASJ,EAAY,GAAKA,EAAY,GACtCK,EAAOL,EAAY,GAAKC,EAAaC,EACrCI,EAAON,EAAY,GAAKC,EAAaC,EACrCK,EAAOP,EAAY,GAAKC,EAAaE,EACrCK,EAAOR,EAAY,GAAKC,EAAaE,EACrCM,EAAOT,EAAY,GAAKC,EAAaG,EACrCM,EAAOV,EAAY,GAAKC,EAAaG,EACrCO,EAAS,GACTC,EAAY,kBAAqB,CACnC9lD,OAAQ,CAACulD,EAAM,EAAG,GAClBniB,OAAQ,CAAC,EAAG,EAAG,KAEb2iB,EAAY,kBAAqB,CACnC/lD,OAAQ,CAACwlD,EAAM,EAAG,GAClBpiB,OAAQ,EAAE,EAAG,EAAG,KAEd4iB,EAAY,kBAAqB,CACnChmD,OAAQ,CAAC,EAAGylD,EAAM,GAClBriB,OAAQ,CAAC,EAAG,EAAG,KAEb6iB,EAAY,kBAAqB,CACnCjmD,OAAQ,CAAC,EAAG0lD,EAAM,GAClBtiB,OAAQ,CAAC,GAAI,EAAG,KAEd8iB,EAAY,kBAAqB,CACnClmD,OAAQ,CAAC,EAAG,EAAG2lD,GACfviB,OAAQ,CAAC,EAAG,EAAG,KAEb+iB,EAAY,kBAAqB,CACnCnmD,OAAQ,CAAC,EAAG,EAAG4lD,GACfxiB,OAAQ,CAAC,EAAG,GAAI,KAEdgZ,EAASjoD,EACV0mD,kBACAzsC,MAAMkI,YACXuvC,EAAOjlD,KAAKklD,GACZD,EAAOjlD,KAAKmlD,GACZF,EAAOjlD,KAAKolD,GACZH,EAAOjlD,KAAKqlD,GACZJ,EAAOjlD,KAAKslD,GACZL,EAAOjlD,KAAKulD,GACZ,MAAMC,EAAiBP,EAAOvnD,IAAK4wB,IAAU,CACzClvB,OAAQ,IAAIkvB,EAAMs1B,aAClBphB,OAAQ,IAAIlU,EAAMm3B,gBAEtBpuD,KAAKupD,uBAAyB4E,EAC9B,MAAME,EAAkB,CAACf,GAAOG,EAAOD,GAAQ,GAAIG,EAAOD,GAAQ,GAC5DY,EAAkB,CAACf,GAAOE,EAAOD,GAAQ,GAAIG,EAAOD,GAAQ,GAC5Da,EAAkB,EAAEhB,EAAOD,GAAQ,EAAGE,GAAOG,EAAOD,GAAQ,GAC5Dc,EAAkB,EAAEjB,EAAOD,GAAQ,EAAGG,GAAOE,EAAOD,GAAQ,GAC5De,EAAkB,EAAElB,EAAOD,GAAQ,GAAIG,EAAOD,GAAQ,EAAGE,GACzDgB,EAAkB,EAAEnB,EAAOD,GAAQ,GAAIG,EAAOD,GAAQ,EAAGG,GACzDgB,EAAiB3uD,KAAK4uD,+BAA+B3xD,KAAKopC,KAAK8mB,EAASA,EAASC,EAASA,EAASC,EAASA,IAClHrtD,KAAK6uD,WAAW3yD,EAAUmyD,EAAiB,IAAK,MAAO,KAAMM,GAC7D3uD,KAAK6uD,WAAW3yD,EAAUoyD,EAAiB,IAAK,MAAO,KAAMK,GAC7D3uD,KAAK6uD,WAAW3yD,EAAUqyD,EAAiB,IAAK,MAAO,KAAMI,GAC7D3uD,KAAK6uD,WAAW3yD,EAAUsyD,EAAiB,IAAK,MAAO,KAAMG,GAC7D3uD,KAAK6uD,WAAW3yD,EAAUuyD,EAAiB,IAAK,MAAO,KAAME,GAC7D3uD,KAAK6uD,WAAW3yD,EAAUwyD,EAAiB,IAAK,MAAO,KAAMC,GAC7D,MAAM/pC,EAAU,CACZ,CAAC0oC,EAAME,EAAME,GACb,CAACJ,EAAME,EAAMG,GACb,CAACL,EAAMG,EAAMC,GACb,CAACJ,EAAMG,EAAME,GACb,CAACJ,EAAMC,EAAME,GACb,CAACH,EAAMC,EAAMG,GACb,CAACJ,EAAME,EAAMC,GACb,CAACH,EAAME,EAAME,IAEXmB,EAAa,CACf,iBACA,iBACA,iBACA,iBACA,iBACA,iBACA,iBACA,kBAEJ,IAAK,IAAIplD,EAAI,EAAGA,EAAIkb,EAAQhkB,OAAQ8I,IAChC1J,KAAK6uD,WAAW3yD,EAAU0oB,EAAQlb,GAAI,SAAU,KAAMolD,EAAWplD,GAAIilD,GAEjD,CACpB,CAAC,iBAAkB,kBACnB,CAAC,iBAAkB,kBACnB,CAAC,iBAAkB,kBACnB,CAAC,iBAAkB,kBACnB,CAAC,iBAAkB,kBACnB,CAAC,iBAAkB,kBACnB,CAAC,iBAAkB,kBACnB,CAAC,iBAAkB,kBACnB,CAAC,iBAAkB,kBACnB,CAAC,iBAAkB,kBACnB,CAAC,iBAAkB,kBACnB,CAAC,iBAAkB,mBAEP1tD,QAAQ,EAAE8tD,EAAMC,GAAOtlD,KACnC,MAAMulD,EAASjvD,KAAK4pD,aAAalsC,KAAMgkC,GAAMA,EAAE5+B,MAAQ,UAAUisC,KAC3DG,EAASlvD,KAAK4pD,aAAalsC,KAAMgkC,GAAMA,EAAE5+B,MAAQ,UAAUksC,KACjE,GAAIC,GAAUC,EAAQ,CAClB,MAAMpsC,EAAM,QAAQisC,KAAQC,KACtB,MAAE74C,EAAK,OAAE/E,GAAWpR,KAAKmvD,wBAAwBjzD,EAAU+yD,EAAO3gD,MAAO4gD,EAAO5gD,MAAO,CAAC,GAAK,GAAK,IAAMwU,GAC9G9iB,KAAK6pD,UAAU/mC,GAAO,CAAE3M,QAAO/E,SAAQ29C,OAAMC,OACjD,IAEJ7K,EAAOiL,iBAAiBvB,GACxB1J,EAAOiL,iBAAiBtB,GACxB3J,EAAOiL,iBAAiBrB,GACxB5J,EAAOiL,iBAAiBpB,GACxB7J,EAAOiL,iBAAiBnB,GACxB9J,EAAOiL,iBAAiBlB,GACxB,EAAAt5B,YAAYnK,iBAAiB,EAAAgH,OAAO49B,mCAAqCjN,IACrEpiD,KAAK4rD,qBAAqBxJ,KAE9BlmD,EAASD,UAEb+D,KAAKgrD,2BAA8B5I,IAC/B,MAAMlmD,EAAW8D,KAAK6rD,eAChBvuD,EAAI8kD,EAAIrtB,OAAOixB,cAAcvqD,OAAO,GACpC+B,EAAI4kD,EAAIrtB,OAAOixB,cAAcvqD,OAAO,GACpCgoD,EAAQvnD,EAASk1B,cAAc,CAAC9zB,EAAGE,IACzC,MAAO,CAAEtB,WAAUunD,UAEvBzjD,KAAK6rD,aAAe,KAChB,MAAOlB,GAAc3qD,KAAKwkD,oBAE1B,OADwB,IAAAr2B,oBAAmBw8B,EAAWz8B,mBAC/BkC,YAAYu6B,EAAWz7B,aAElDlvB,KAAKsvD,4BAA8B,CAAC/E,EAAa9G,EAAOvnD,KACpD,MAAM+uD,EAAYjrD,KAAKkrD,4BAA4BzH,GACnDzjD,KAAKmrD,sBAAsBZ,EAAaU,GACxC,MAAMG,EAAYprD,KAAKqrD,gBAAgBd,EAAYznC,KACnD9iB,KAAKsrD,sBAAsBf,EAAaU,EAAWG,GACnDprD,KAAKuvD,2BAA2BrzD,IAEpC8D,KAAKwvD,0BAA4B,CAACjF,EAAa9G,EAAOvnD,KAClD,MAAMwuD,EAAU,CAAEptD,EAAG,EAAGE,EAAG,EAAGqR,EAAG,GAAI07C,EAAY9E,MACjD,IAAI8F,EAAW9H,EAAMiH,GACO,OAAxB1qD,KAAK2pD,iBACL4B,GAAYvrD,KAAK2pD,gBAErBY,EAAYj8C,MAAMo8C,GAAWa,EAC7BhB,EAAYiB,aAAaC,aAAalB,EAAYj8C,OAClDi8C,EAAYiB,aAAatb,WACzBlwC,KAAKyvD,yBAAyBvzD,IAElC8D,KAAKkrD,4BAA+BzH,IAChC,IAAIwH,EAAY,CAACxH,EAAM,GAAIA,EAAM,GAAIA,EAAM,IAQ3C,OAPIzjD,KAAK0pD,mBACLuB,EAAY,CACRxH,EAAM,GAAKzjD,KAAK0pD,iBAAiB,GACjCjG,EAAM,GAAKzjD,KAAK0pD,iBAAiB,GACjCjG,EAAM,GAAKzjD,KAAK0pD,iBAAiB,KAGlCuB,GAEXjrD,KAAKqrD,gBAAmBvoC,IACpB,MAAM4sC,EAAY5sC,EAAIvW,QAAQ,UAAW,IACzC,MAAO,CACHojD,OAAQD,EAAU70C,SAAS,QAC3B+0C,OAAQF,EAAU70C,SAAS,QAC3Bg1C,OAAQH,EAAU70C,SAAS,QAC3Bi1C,OAAQJ,EAAU70C,SAAS,QAC3Bk1C,OAAQL,EAAU70C,SAAS,QAC3Bm1C,OAAQN,EAAU70C,SAAS,UAGnC7a,KAAKmrD,sBAAwB,CAACZ,EAAap1B,KACvCo1B,EAAYj8C,MAAQ6mB,EACpBo1B,EAAYiB,aAAaC,aAAat2B,GACtCo1B,EAAYiB,aAAatb,YAE7BlwC,KAAKsrD,sBAAwB,CAAC2E,EAAehF,EAAWG,KACpDprD,KAAK4pD,aAAa3oD,QAAS4oB,IACvB,IAAKA,EAAM4gC,UAAY5gC,IAAUomC,EAC7B,OAEJ,MAAM9vD,EAAM0pB,EAAM/G,IAAIvW,QAAQ,UAAW,IACpBvM,KAAKkwD,oBAAoB/vD,EAAKirD,IAE/CprD,KAAKmwD,yBAAyBtmC,EAAOohC,EAAW9qD,EAAKirD,MAIjEprD,KAAKkwD,oBAAsB,CAACR,EAAWtE,IAC1BA,EAAUuE,QAAUD,EAAU70C,SAAS,SAC3CuwC,EAAUwE,QAAUF,EAAU70C,SAAS,SACvCuwC,EAAUyE,QAAUH,EAAU70C,SAAS,SACvCuwC,EAAU0E,QAAUJ,EAAU70C,SAAS,SACvCuwC,EAAU2E,QAAUL,EAAU70C,SAAS,SACvCuwC,EAAU4E,QAAUN,EAAU70C,SAAS,QAEhD7a,KAAKmwD,yBAA2B,CAACtmC,EAAOohC,EAAWyE,EAAWtE,MACrDA,EAAUuE,QAAUD,EAAU70C,SAAS,SACvCuwC,EAAUwE,QAAUF,EAAU70C,SAAS,WACxCgP,EAAMvb,MAAM,GAAK28C,EAAU,KAE1BG,EAAUyE,QAAUH,EAAU70C,SAAS,SACvCuwC,EAAU0E,QAAUJ,EAAU70C,SAAS,WACxCgP,EAAMvb,MAAM,GAAK28C,EAAU,KAE1BG,EAAU2E,QAAUL,EAAU70C,SAAS,SACvCuwC,EAAU4E,QAAUN,EAAU70C,SAAS,WACxCgP,EAAMvb,MAAM,GAAK28C,EAAU,IAE/BphC,EAAM2hC,aAAaC,aAAa5hC,EAAMvb,OACtCub,EAAM2hC,aAAatb,YAEvBlwC,KAAKuvD,2BAA8BrzD,IAC/B8D,KAAK6qD,gCACL7qD,KAAK4qD,uBACL5qD,KAAK8qD,qCAAqC5uD,IAE9C8D,KAAKyvD,yBAA4BvzD,IAC7B8D,KAAK0rD,gCACL1rD,KAAK8qD,qCAAqC5uD,IAE9C8D,KAAK2rD,yBAA4BpB,KAC7B,IAAAnoB,cAAa,EAAAxN,YAAa,EAAAnD,OAAOs7B,4BAA6B,CAC1DtD,WAAYc,EAAYj8C,MACxBm3C,KAAM8E,EAAYE,SAAW,SAAWF,EAAY9E,KACpD+D,oBAAqBxpD,KAAKwpD,oBAC1BpuB,kBAAmBp7B,KAAKo7B,qBAGhCp7B,KAAKowD,aAAe,KAChB,MAAMzL,EAAgB3kD,KAAKwkD,oBAC3BxkD,KAAKupD,uBAAyB,GAC9BvpD,KAAK4pD,aAAe,GACpB5pD,KAAK6pD,UAAY,CAAC,EAClB7pD,KAAKgtD,uBAAuBrI,IAEhC3kD,KAAKqwD,cAAgB,CAACn0D,EAAUspD,EAAaC,EAAM3oD,KAC/C,MAAM4oD,EAAYxpD,EAASypD,qBACrB3gB,EAAS0gB,EAAUE,YACnBjjC,EAAa+iC,EAAUG,gBACvBj2B,EAAW81B,EAAUI,cACrB3wB,EAAc,CAAC,EAAG,EAAG,GACrB0M,EAAgB,CAAC,EAAG,EAAG,GACvBkkB,EAAY,CAAC,EAAG,EAAG,GACnBtpD,EAAY,cAAc,IAAIwM,aAAa,KACjD,eAAexM,EAAWA,EAAW+oD,GACrC,YAAY/oD,EAAWA,EAAWK,EAAO2oD,GACzC,eAAehpD,EAAWA,EAAW,EAChC+oD,EAAY,IACZA,EAAY,IACZA,EAAY,KAEjB,mBAAmBrwB,EAAavF,EAAUnzB,GAC1C,mBAAmBolC,EAAelf,EAAYlmB,GAC9C,cAAcA,GACd,YAAYA,EAAWA,EAAWK,EAAO2oD,GACzC,mBAAmBM,EAAW/gB,EAAQvoC,GACtCP,EAAS6lC,UAAU,CACfnS,SAAUuF,EACV6P,OAAQ+gB,EACRpjC,WAAYkf,KAGpB7hC,KAAKmiD,kBAAoBniD,KAAKqiD,cAAc7xC,KAAKxQ,MACjDA,KAAKsiD,kBAAoBtiD,KAAKqiD,cAAc7xC,KAAKxQ,KACrD,CACA,eAAA4kD,GACI,GAAI5kD,KAAK4pD,cAAgB5pD,KAAK4pD,aAAahpD,OAAS,EAC5CZ,KAAKyM,cAAck8C,aACnB3oD,KAAKswD,mBAAkB,GACvBtwD,KAAKuwD,0BAAyB,KAG9BvwD,KAAKswD,mBAAkB,GACvBtwD,KAAKuwD,0BAAyB,QAGjC,CACD,MAAM5L,EAAgB3kD,KAAKwkD,oBACrBK,EAA2B,KAC7BF,EAAc1jD,QAAQ,EAAGiuB,aAAYhB,wBACjC,IAAKluB,KAAKgkD,iBAAiB3gD,IAAI6rB,GAAa,CACxC,MAAM,SAAEhzB,IAAa,IAAA4oD,wBAAuB51B,EAAYhB,IAAsB,CAAEhyB,SAAU,MAC1F,IAAKA,EACD,OAEJ,MAAM,QAAEizB,GAAYjzB,EACd6oD,EAAiB,IAAIC,eAAe,KACtC,MAAM71B,GAAU,IAAA21B,wBAAuB51B,EAAYhB,GACnD,IAAKiB,EACD,OAEJ,MAAM,SAAEjzB,GAAaizB,EACf81B,EAAmB/oD,EAASggC,sBAClChgC,EAASg2B,cACTh2B,EAAS0gC,oBAAoBqoB,GAC7B/oD,EAASD,WAEb8oD,EAAeG,QAAQ/1B,GACvBnvB,KAAKgkD,iBAAiB9jD,IAAIgvB,EAAY61B,EAC1C,KAGRF,IACA7kD,KAAKmlD,uBAA0B/C,IACvBA,EAAIrtB,OAAO2vB,cAAgB1kD,KAAK0kD,aAChCG,KAGR,EAAAjwB,YAAYnK,iBAAiB,EAAAgH,OAAO2zB,yBAA0BplD,KAAKmlD,wBACnEnlD,KAAKwwD,mCAAmC7L,GACxC3kD,KAAKywD,iCAAiC9L,GACtC3kD,KAAKgtD,uBAAuBrI,GACxB3kD,KAAK4pD,cAAgB5pD,KAAK4pD,aAAahpD,OAAS,EAChDZ,KAAKswD,mBAAkB,IAGvBtwD,KAAKupD,uBAAyB,GAC9BvpD,KAAKgtD,uBAAuBrI,GAEpC,CACJ,CACA,iBAAAU,GACIrlD,KAAKgkD,iBAAiB/iD,QAAQ,CAAC8jD,EAAgB71B,KAC3C61B,EAAeO,aACftlD,KAAKgkD,iBAAiBxgD,OAAO0rB,KAE7BlvB,KAAKmlD,yBACL,EAAAvwB,YAAY9J,oBAAoB,EAAA2G,OAAO2zB,yBAA0BplD,KAAKmlD,wBACtEnlD,KAAKmlD,uBAAyB,MAElC,MAAMR,EAAgB3kD,KAAKwkD,oBAC3BxkD,KAAKwwD,mCAAmC7L,EAC5C,CACA,iBAAA2L,CAAkBI,GACd1wD,KAAKyM,cAAck8C,YAAc+H,EAC7BA,IACA1wD,KAAK4pD,aAAalC,GAAYC,MAAMr5C,MAAM,GACtCtO,KAAKupD,uBAAuB9B,IAAiB1/C,OAAO,GACxD/H,KAAK4pD,aAAalC,GAAYE,MAAMt5C,MAAM,GACtCtO,KAAKupD,uBAAuB9B,IAAiB1/C,OAAO,GACxD/H,KAAK4pD,aAAalC,GAAYG,MAAMv5C,MAAM,GACtCtO,KAAKupD,uBAAuB9B,IAAiB1/C,OAAO,GACxD/H,KAAK4pD,aAAalC,GAAYI,MAAMx5C,MAAM,GACtCtO,KAAKupD,uBAAuB9B,IAAiB1/C,OAAO,GACxD/H,KAAK4pD,aAAalC,GAAYK,MAAMz5C,MAAM,GACtCtO,KAAKupD,uBAAuB9B,IAAiB1/C,OAAO,GACxD/H,KAAK4pD,aAAalC,GAAYM,MAAM15C,MAAM,GACtCtO,KAAKupD,uBAAuB9B,IAAiB1/C,OAAO,GACxD,CACI2/C,GAAYC,KACZD,GAAYE,KACZF,GAAYG,KACZH,GAAYI,KACZJ,GAAYK,KACZL,GAAYM,MACd/mD,QAAS0wC,IACP,MAAM+P,EAAI1hD,KAAK4pD,aAAajY,GAC5B+P,EAAE8J,aAAaC,aAAa/J,EAAEpzC,OAC9BozC,EAAE8J,aAAatb,aAEnBlwC,KAAK4qD,wBAET5qD,KAAK2wD,2BACL,MAAMhM,EAAgB3kD,KAAKwkD,qBACpBmG,GAAchG,GACG,IAAAx2B,oBAAmBw8B,EAAWz8B,mBACrBkC,YAAYu6B,EAAWz7B,YAC/CjzB,QACb,CACA,iBAAA20D,GACI,OAAO5wD,KAAKyM,cAAck8C,WAC9B,CACA,wBAAAkI,GACI,OAAO7wD,KAAKyM,cAAcm8C,kBAC9B,CACA,wBAAA2H,CAAyBG,GACrB1wD,KAAKyM,cAAcm8C,mBAAqB8H,EACxC,MAAMx0D,EAAW8D,KAAK6rD,eACtB7rD,KAAKkqD,sBAAsBhuD,GAC3BA,EAASD,QACb,CACA,aAAAomD,CAAcD,GACV,MAAM,QAAEjzB,EAAO,cAAE62B,EAAa,WAAEC,GAAe7D,EAAIrtB,OACnD,GAAiC,OAA7B/0B,KAAKwpD,oBACLxpD,KAAK+qD,mBAAmB3I,OAEvB,CACD,MAAM8D,EAAsBF,EAAcvqD,OACpC0qD,EAAmBF,EAAWxqD,QAC9B,uBAAEqoD,GAA2B9jD,KAAKyM,cAClCnR,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACfknB,EAAStmB,EAASumB,YAClB7lB,EAAQuyB,EAAQi3B,YAChBvpD,EAASsyB,EAAQk3B,aACjBC,EAAqB,CACvBJ,EAAoB,GAAKtpD,EACzBspD,EAAoB,GAAKrpD,GAEvB0pD,EAA6B,CAC/BJ,EAAiB,GAAKvpD,EACtBupD,EAAiB,GAAKtpD,GAEpB+Z,EAAS,CAAS,GAARha,EAAsB,GAATC,GACvB2oD,EAActpD,EAASk1B,cAAcxa,GACrCk6C,EAAmB,CAAC,GAAK,IACzBtK,GAAS,EAAMvpD,KAAK6e,IAAIg1C,EAAiB,MAAQ,EACjDrK,EAAK,CAACF,EAA2B,GAAI,EAAG,GACxCG,EAAK,CAACJ,EAAmB,GAAI,EAAG,GAChCK,EAAOF,EAAG,IAAM,EAChBG,EAAOF,EAAG,IAAM,EAChBG,EAAMF,EAAOH,EAAQ,EAAIvpD,KAAKopC,KAAKmgB,EAAQG,GAC3CG,EAAMF,EAAOJ,EAAQ,EAAIvpD,KAAKopC,KAAKmgB,EAAQI,GAC3CG,EAAM,CAACN,EAAG,GAAI,EAAGI,GACvB,gBAAkBE,GAClB,MAAMC,EAAM,CAACN,EAAG,GAAI,EAAGI,GACvB,gBAAkBE,GAClB,MAAMC,EAAM,UAAYF,EAAKC,GAC7B,GAAI/pD,KAAK6e,IAAImrC,GAAO,KAAQ,CACxB,MAAMC,GAAU,EACZjqD,KAAKkqD,KAAK,iBAAmBF,GAAM,EAAK,IACxChqD,KAAK0vC,KAAK2Z,EAAmB,GAAKC,EAA2B,IAC7DzC,EACEsD,EAAQ5kC,EAAOwiB,OACfqiB,EAAM7kC,EAAOjB,gBACb+lC,EAAS,CAAC,EAAG,EAAG,GAChBC,EAAW,CAAC,EAAG,EAAG,GACxB,YAAcH,EAAOC,EAAKC,GAC1B,gBAAkBA,GAClB,YAAcD,EAAKC,EAAQC,GAC3B,gBAAkBA,GAClB,gBAAkBH,GAClBpnD,KAAKqwD,cAAcn0D,EAAUspD,EAAa+B,EAAUL,GACpD,MAAMM,GAAUjB,EAA2B,GAAKD,EAAmB,IAC/DxC,EACJ9jD,KAAKqwD,cAAcn0D,EAAUspD,EAAa8B,EAAQE,EACtD,CACAtrD,EAASD,QACb,CACJ,CACA,qBAAAiuD,CAAsBhuD,GAClB,MAAM6Z,EAAa7Z,EAAS0mD,kBAC5B,IAAK7sC,IAAeA,EAAWI,MAK3B,YAJKja,EAAS60D,sBACV3gD,QAAQC,KAAK,iFACbnU,EAAS60D,qBAAsB,IAIvC,MAAM56C,EAAQJ,EAAWI,MACnBguC,EAAShuC,EAAMkI,YACf2yC,EAAS76C,EAAM86C,YACrB,IAAKjxD,KAAKyM,cAAcm8C,mBAEpB,YADAzE,EAAO+M,0BAGX,MAAMC,EAAM,cACZ,cAAcA,EAAKH,GACnB,MAAMI,EAAe,cACrB,YAAYA,EAAcD,GAC1B,eAAeC,EAAcA,GAC7B,MAAMjD,EAAiBnuD,KAAKupD,uBAC5B,IAAK4E,IAAmBA,EAAevtD,OACnC,OAEJujD,EAAO+M,0BACP,MAAMG,EAAqB,GACrBC,EAAqB,GAC3B,IAAK,IAAI5nD,EAAI,EAAGA,EAAIykD,EAAevtD,SAAU8I,EAAG,CAC5C,MAAMutB,EAAQk3B,EAAezkD,GACvB6nD,EAAO,cACb,mBAAmBA,EAAM,IAAItoD,aAAaguB,EAAMlvB,QAASipD,GACzD,MAAMQ,EAAI,CAACD,EAAK,GAAIA,EAAK,GAAIA,EAAK,IAC5BE,EAAO,cACb,mBAAmBA,EAAM,IAAIxoD,aAAaguB,EAAMkU,QAASimB,GACzD,eAAeK,EAAMA,GACrB,MAAMjkC,EAAI,CAACikC,EAAK,GAAIA,EAAK,GAAIA,EAAK,IAClCJ,EAAmB1oD,KAAK6oD,GACxBF,EAAmB3oD,KAAK6kB,EAC5B,CACA,IAAK,IAAI9jB,EAAI,EAAGA,EAAI2nD,EAAmBzwD,SAAU8I,EAAG,CAChD,MAAMgoD,EAAgB,kBAAqB,CACvC3pD,OAAQspD,EAAmB3nD,GAC3ByhC,OAAQmmB,EAAmB5nD,KAE/By6C,EAAOiL,iBAAiBsC,EAC5B,CACJ,CACA,wBAAAf,GACI3wD,KAAK4pD,aAAa3oD,QAAS4oB,IACnBA,EAAM6iC,aACN7iC,EAAM6iC,YAAYiF,cAAc3xD,KAAKyM,cAAck8C,eAG3D/oD,OAAO+a,OAAO3a,KAAK6pD,WAAW5oD,QAAQ,EAAGkV,YACjCA,GACAA,EAAMw7C,cAAc3xD,KAAKyM,cAAck8C,cAGnD,CACA,uBAAAwG,CAAwBjzD,EAAU01D,EAAQC,EAAQz1D,EAAQ,CAAC,GAAK,GAAK,IAAM0mB,EAAM,IAC7E,GAAI8uC,EAAO,KAAOC,EAAO,IACrBD,EAAO,KAAOC,EAAO,IACrBD,EAAO,KAAOC,EAAO,GACrB,MAAO,CAAE17C,MAAO,KAAM/E,OAAQ,MAElC,MAAM3C,EAAS,oBACfA,EAAOqjD,kBAAkB,GACzBrjD,EAAOsjD,SAAS,EAAGH,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAChDnjD,EAAOsjD,SAAS,EAAGF,EAAO,GAAIA,EAAO,GAAIA,EAAO,IAChD,MAAMG,EAAQ,kBAAyB,CAAEr3C,OAAQ,CAAC,EAAG,EAAG,KAClDm3B,EAAW,oBACjBA,EAASmgB,UAAUxjD,GACnBqjC,EAASogB,SAASF,GAClB,MAAM7N,EAAS,oBACfA,EAAOgO,aAAargB,GACpB,MAAM37B,EAAQ,oBAWd,OAVAA,EAAMi8C,UAAUjO,GAChBhuC,EAAMoB,cAAco1C,YAAYvwD,GAChC+Z,EAAMoB,cAAc86C,aAAa,IACjCl8C,EAAMoB,cAAc+6C,WAAW,GAC/Bn8C,EAAMoB,cAAcg7C,yBACpBp8C,EAAMoB,cAAc8B,WAAW,GAC/BlD,EAAMoB,cAAc+B,WAAW,GAC/BnD,EAAMoB,cAAcgC,YAAY,GAChCpD,EAAMw7C,cAAc3xD,KAAKyM,cAAck8C,aACvCzsD,EAASs2D,SAAS,CAAEr8C,QAAO2M,QACpB,CAAE3M,QAAO/E,OAAQ0gC,EAC5B,CACA,UAAA+c,CAAW3yD,EAAUoS,EAAOm3C,EAAM71B,EAAU8/B,EAAY,KAAMf,GAC1D,MAAM7rC,EAAM4sC,EAAY,UAAUA,IAAc,GAAGjK,KAAQ71B,IAE3D,GADoB5vB,KAAK4pD,aAAalsC,KAAMgkC,GAAMA,EAAE5+B,MAAQA,GAExD,OAEJ,MAAM0oC,EAAe,oBACrBA,EAAaC,UAAUn9C,GACvBk9C,EAAaiH,UAAU9D,GACvB,MAAM+D,EAAe,oBACrBA,EAAaC,mBAAmBnH,EAAaoH,iBAC7C,MAAMlG,EAAc,oBACpBA,EAAY0F,UAAUM,GACtB,IAAIt2D,EAAQ,CAAC,EAAK,EAAK,GACvB,MAAM4sD,EAAehpD,KAAKyM,cAAcu8C,cAAgB,CAAC,EACrD0G,EACAtzD,EAAQ4sD,EAAaI,SAAW,CAAC,EAAK,EAAK,GAE7B,MAAT3D,EACLrpD,EAAQ4sD,EAAaG,OAAS,CAAC,EAAK,EAAK,GAE3B,MAAT1D,EACLrpD,EAAQ4sD,EAAaC,UAAY,CAAC,EAAK,EAAK,GAE9B,MAATxD,IACLrpD,EAAQ4sD,EAAaE,SAAW,CAAC,EAAK,EAAK,IAE/C,MAAMvX,EAAM3xC,KAAK4pD,aAAap3C,UAAWkvC,GAAMA,EAAE5+B,MAAQA,IAC5C,IAAT6uB,EACA3xC,KAAK4pD,aAAajhD,KAAK,CACnB2F,MAAOA,EAAM5N,QACb+kD,OACA3iC,MACA0oC,eACAkB,cACAjC,WAAYiF,EACZtzD,WAIJ4D,KAAK4pD,aAAajY,GAAKrjC,MAAQA,EAAM5N,QACrCV,KAAK4pD,aAAajY,GAAK6Z,aAAeA,GAEnBtvD,EAAS0mB,YACAlF,KAAMxB,GAAMA,EAAE4G,MAAQA,KAItD4pC,EAAYn1C,cAAco1C,SAASvwD,GACnCswD,EAAYiF,cAAc3xD,KAAKyM,cAAck8C,aAC7CzsD,EAASs2D,SAAS,CAAEr8C,MAAOu2C,EAAa5pC,IAAKA,IACjD,CACA,8BAAA8rC,CAA+BiE,QAC4B70D,IAApCgC,KAAKyM,cAAc48C,cAChCrpD,KAAKyM,cAAc48C,aADzB,MAIMsF,EAAiBkE,GADH7yD,KAAKyM,cAAcqmD,mBAAqB,KAEtDC,EAAY/yD,KAAKyM,cAAcumD,iBAAmB,EAClDC,EAAYjzD,KAAKyM,cAAcymD,iBAAmB,GACxD,OAAOj2D,KAAKkS,IAAI4jD,EAAW91D,KAAKa,IAAIm1D,EAAWtE,GACnD,CACA,oCAAA7D,CAAqC5uD,GACjC,MAAMioD,EAASjoD,EAAS0mD,kBAAkBzsC,MAAMkI,YAChDre,KAAKupD,uBAAuB,GAAGxhD,OAAS,IACjC/H,KAAK4pD,aAAalC,GAAYC,MAAMr5C,OAE3CtO,KAAKupD,uBAAuB,GAAGxhD,OAAS,IACjC/H,KAAK4pD,aAAalC,GAAYE,MAAMt5C,OAE3CtO,KAAKupD,uBAAuB,GAAGxhD,OAAS,IACjC/H,KAAK4pD,aAAalC,GAAYG,MAAMv5C,OAE3CtO,KAAKupD,uBAAuB,GAAGxhD,OAAS,IACjC/H,KAAK4pD,aAAalC,GAAYI,MAAMx5C,OAE3CtO,KAAKupD,uBAAuB,GAAGxhD,OAAS,IACjC/H,KAAK4pD,aAAalC,GAAYK,MAAMz5C,OAE3CtO,KAAKupD,uBAAuB,GAAGxhD,OAAS,IACjC/H,KAAK4pD,aAAalC,GAAYM,MAAM15C,OAE3C61C,EAAO+M,0BACP,IAAK,IAAIxnD,EAAI,EAAGA,EAAI,IAAKA,EAAG,CACxB,MAAM3B,EAAS/H,KAAKupD,uBAAuB7/C,GAAG3B,OACxCojC,EAASnrC,KAAKupD,uBAAuB7/C,GAAGyhC,OACxClU,EAAQ,kBAAqB,CAC/BlvB,SACAojC,WAEJgZ,EAAOiL,iBAAiBn4B,EAC5B,CACJ,CACA,6BAAAy0B,GACI,MAAM4B,EAAOttD,KAAK4pD,aAAalC,GAAYC,MAAMr5C,MAAM,GACjDi/C,EAAOvtD,KAAK4pD,aAAalC,GAAYE,MAAMt5C,MAAM,GACjDk/C,EAAOxtD,KAAK4pD,aAAalC,GAAYG,MAAMv5C,MAAM,GACjDm/C,EAAOztD,KAAK4pD,aAAalC,GAAYI,MAAMx5C,MAAM,GACjDo/C,EAAO1tD,KAAK4pD,aAAalC,GAAYK,MAAMz5C,MAAM,GACjDq/C,EAAO3tD,KAAK4pD,aAAalC,GAAYM,MAAM15C,MAAM,GACjDsW,EAAU,CACZ,CAAEzkB,IAAK,iBAAkBgzD,IAAK,CAAC7F,EAAME,EAAME,IAC3C,CAAEvtD,IAAK,iBAAkBgzD,IAAK,CAAC7F,EAAME,EAAMG,IAC3C,CAAExtD,IAAK,iBAAkBgzD,IAAK,CAAC7F,EAAMG,EAAMC,IAC3C,CAAEvtD,IAAK,iBAAkBgzD,IAAK,CAAC7F,EAAMG,EAAME,IAC3C,CAAExtD,IAAK,iBAAkBgzD,IAAK,CAAC5F,EAAMC,EAAME,IAC3C,CAAEvtD,IAAK,iBAAkBgzD,IAAK,CAAC5F,EAAMC,EAAMG,IAC3C,CAAExtD,IAAK,iBAAkBgzD,IAAK,CAAC5F,EAAME,EAAMC,IAC3C,CAAEvtD,IAAK,iBAAkBgzD,IAAK,CAAC5F,EAAME,EAAME,KAE/C,IAAK,MAAMyF,KAAUxuC,EAAS,CAC1B,MAAMiF,EAAQ7pB,KAAK4pD,aAAalsC,KAAMgkC,GAAMA,EAAE5+B,MAAQ,UAAUswC,EAAOjzD,OACnE0pB,IACAA,EAAMvb,MAAM,GAAK8kD,EAAOD,IAAI,GAC5BtpC,EAAMvb,MAAM,GAAK8kD,EAAOD,IAAI,GAC5BtpC,EAAMvb,MAAM,GAAK8kD,EAAOD,IAAI,GAC5BtpC,EAAM2hC,aAAaC,aAAa5hC,EAAMvb,OACtCub,EAAM2hC,aAAatb,WAE3B,CACJ,CACA,6BAAA2a,GACI,MAAMjmC,EAAU,CACZ5kB,KAAK4pD,aAAalC,GAAYO,gBAAgB35C,MAC9CtO,KAAK4pD,aAAalC,GAAYQ,gBAAgB55C,MAC9CtO,KAAK4pD,aAAalC,GAAYS,gBAAgB75C,MAC9CtO,KAAK4pD,aAAalC,GAAYU,gBAAgB95C,MAC9CtO,KAAK4pD,aAAalC,GAAYW,gBAAgB/5C,MAC9CtO,KAAK4pD,aAAalC,GAAYY,gBAAgBh6C,MAC9CtO,KAAK4pD,aAAalC,GAAYa,gBAAgBj6C,MAC9CtO,KAAK4pD,aAAalC,GAAYc,gBAAgBl6C,OAE5C+kD,EAAKzuC,EAAQve,IAAKqI,GAAMA,EAAE,IAC1B4kD,EAAK1uC,EAAQve,IAAKqI,GAAMA,EAAE,IAC1B6kD,EAAK3uC,EAAQve,IAAKqI,GAAMA,EAAE,IAC1B4+C,EAAOrwD,KAAKa,OAAOu1D,GAAK9F,EAAOtwD,KAAKkS,OAAOkkD,GAC3C7F,EAAOvwD,KAAKa,OAAOw1D,GAAK7F,EAAOxwD,KAAKkS,OAAOmkD,GAC3C5F,EAAOzwD,KAAKa,OAAOy1D,GAAK5F,EAAO1wD,KAAKkS,OAAOokD,GACjDvzD,KAAK4pD,aAAalC,GAAYC,MAAMr5C,MAAQ,CACxCg/C,GACCE,EAAOC,GAAQ,GACfC,EAAOC,GAAQ,GAEpB3tD,KAAK4pD,aAAalC,GAAYE,MAAMt5C,MAAQ,CACxCi/C,GACCC,EAAOC,GAAQ,GACfC,EAAOC,GAAQ,GAEpB3tD,KAAK4pD,aAAalC,GAAYG,MAAMv5C,MAAQ,EACvCg/C,EAAOC,GAAQ,EAChBC,GACCE,EAAOC,GAAQ,GAEpB3tD,KAAK4pD,aAAalC,GAAYI,MAAMx5C,MAAQ,EACvCg/C,EAAOC,GAAQ,EAChBE,GACCC,EAAOC,GAAQ,GAEpB3tD,KAAK4pD,aAAalC,GAAYK,MAAMz5C,MAAQ,EACvCg/C,EAAOC,GAAQ,GACfC,EAAOC,GAAQ,EAChBC,GAEJ1tD,KAAK4pD,aAAalC,GAAYM,MAAM15C,MAAQ,EACvCg/C,EAAOC,GAAQ,GACfC,EAAOC,GAAQ,EAChBE,GAEJ,CACIjG,GAAYC,KACZD,GAAYE,KACZF,GAAYG,KACZH,GAAYI,KACZJ,GAAYK,KACZL,GAAYM,MACd/mD,QAAS0wC,IACP,MAAM+P,EAAI1hD,KAAK4pD,aAAajY,GAC5B+P,EAAE8J,aAAaC,aAAa/J,EAAEpzC,OAC9BozC,EAAE8J,aAAatb,YAEvB,CACA,oBAAA0a,GACI,MAAM0C,EAAOttD,KAAK4pD,aAAalC,GAAYC,MAAMr5C,MAAM,GACjDi/C,EAAOvtD,KAAK4pD,aAAalC,GAAYE,MAAMt5C,MAAM,GACjDk/C,EAAOxtD,KAAK4pD,aAAalC,GAAYG,MAAMv5C,MAAM,GACjDm/C,EAAOztD,KAAK4pD,aAAalC,GAAYI,MAAMx5C,MAAM,GACjDo/C,EAAO1tD,KAAK4pD,aAAalC,GAAYK,MAAMz5C,MAAM,GACjDq/C,EAAO3tD,KAAK4pD,aAAalC,GAAYM,MAAM15C,MAAM,GACjDsW,EAAU,CACZ,CAAEzkB,IAAK,iBAAkBgzD,IAAK,CAAC7F,EAAME,EAAME,IAC3C,CAAEvtD,IAAK,iBAAkBgzD,IAAK,CAAC7F,EAAME,EAAMG,IAC3C,CAAExtD,IAAK,iBAAkBgzD,IAAK,CAAC7F,EAAMG,EAAMC,IAC3C,CAAEvtD,IAAK,iBAAkBgzD,IAAK,CAAC7F,EAAMG,EAAME,IAC3C,CAAExtD,IAAK,iBAAkBgzD,IAAK,CAAC5F,EAAMC,EAAME,IAC3C,CAAEvtD,IAAK,iBAAkBgzD,IAAK,CAAC5F,EAAMC,EAAMG,IAC3C,CAAExtD,IAAK,iBAAkBgzD,IAAK,CAAC5F,EAAME,EAAMC,IAC3C,CAAEvtD,IAAK,iBAAkBgzD,IAAK,CAAC5F,EAAME,EAAME,KAE/C,IAAK,MAAMyF,KAAUxuC,EAAS,CAC1B,MAAMiF,EAAQ7pB,KAAK4pD,aAAalsC,KAAMgkC,GAAMA,EAAE5+B,MAAQ,UAAUswC,EAAOjzD,OACnE0pB,IACAA,EAAMvb,MAAM,GAAK8kD,EAAOD,IAAI,GAC5BtpC,EAAMvb,MAAM,GAAK8kD,EAAOD,IAAI,GAC5BtpC,EAAMvb,MAAM,GAAK8kD,EAAOD,IAAI,GAC5BtpC,EAAM2hC,aAAaC,aAAa5hC,EAAMvb,OACtCub,EAAM2hC,aAAatb,WAE3B,CACAtwC,OAAO+a,OAAO3a,KAAK6pD,WAAW5oD,QAAQ,EAAGmQ,SAAQ29C,OAAMC,WACnD,MAAMC,EAASjvD,KAAK4pD,aAAalsC,KAAMgkC,GAAMA,EAAE5+B,MAAQ,UAAUisC,KAC3DG,EAASlvD,KAAK4pD,aAAalsC,KAAMgkC,GAAMA,EAAE5+B,MAAQ,UAAUksC,KACjE,GAAIC,GAAUC,EAAQ,CAClB,MAAMzgD,EAAS2C,EAAOwhC,YACtBnkC,EAAOsjD,SAAS,EAAG9C,EAAO3gD,MAAM,GAAI2gD,EAAO3gD,MAAM,GAAI2gD,EAAO3gD,MAAM,IAClEG,EAAOsjD,SAAS,EAAG7C,EAAO5gD,MAAM,GAAI4gD,EAAO5gD,MAAM,GAAI4gD,EAAO5gD,MAAM,IAClEG,EAAOyhC,WACP9+B,EAAO8+B,UACX,GAER,CACA,kCAAAsgB,CAAmC7L,GAC/BA,EAAc1jD,QAAQ,EAAGiuB,aAAYhB,wBACjC,MAAM,SAAEhyB,IAAa,IAAA4oD,wBAAuB51B,EAAYhB,IAClD,QAAEiB,GAAYjzB,EACpBizB,EAAQrE,oBAAoB,EAAA8lB,MAAA,OAAajU,2BAA4B38B,KAAKowD,eAElF,CACA,gCAAAK,CAAiC72C,GAC7BA,EAAU3Y,QAAQ,EAAGiuB,aAAYhB,wBAC7B,MAAM,SAAEhyB,IAAa,IAAA4oD,wBAAuB51B,EAAYhB,IAClD,QAAEiB,GAAYjzB,EACpBizB,EAAQ1E,iBAAiB,EAAAmmB,MAAA,OAAajU,2BAA4B38B,KAAKowD,eAE/E,EAEJ3H,GAAmB7E,SAAW,iB,sCCxhC9B,MAAM,mBAAE4P,IAAuB,EAAAC,UAC/B,SAASC,KACL,MAAO,gBACX,CACA,SAASC,KACL,OAAO,CACX,CACA,MAAMC,GACI,EAIV,MAAMC,WAAkC,MACpC,WAAAp0D,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,SAC5Bx1C,cAAe,CACXqnD,oBAAoB,EACpBC,yBAA0B,CACtBruB,OAAQ,EACRpoC,EAAG,KACHE,EAAG,MAEPw2D,sBAAsB,EACtBjL,kBAAmB,GACnBF,OAAQ,CACJC,SAAS,EACTjxC,QAAS,IAEbo8C,WAAY,CACR9K,MAAO,CAAC,EAAK,EAAK,GAClBD,QAAS,CAAC,EAAK,EAAK,GACpBD,SAAU,CAAC,EAAK,EAAK,GACrB1hB,QAAS,CAAC,EAAK,EAAK,IAExB2sB,UAAW,IACXC,gBAAiB,OAGrB7S,MAAMS,EAAWC,GACjBhiD,KAAKo0D,oBAAsB,GAC3Bp0D,KAAK4pD,aAAe,GACpB5pD,KAAKwpD,oBAAsB,KAC3BxpD,KAAKypD,WAAa,CAAC,EAAG,EAAG,GACzBzpD,KAAKgsD,cAAgB,CAAC,EAAG,EAAG,GAC5BhsD,KAAKisD,cAAgB,CAAC,EAAG,EAAG,GAC5BjsD,KAAKq0D,mBAAqB,EAAGnmC,oBAAmBgB,iBAC5C,IAAKhB,IAAsBgB,EAEvB,YADA9e,QAAQC,KAAK,sEAGjB,MAAM/U,GAAiB,IAAAwpD,wBAAuB51B,EAAYhB,GAC1D,IAAK5yB,EACD,OAEJ,MAAM,SAAEY,GAAaZ,EACrB0E,KAAKs0D,+BAA+Bp4D,GACpC,MAAM,QAAEizB,GAAYjzB,GACd,SAAE0zB,EAAQ,WAAEjN,EAAU,gBAAEpB,GAAoBrlB,EAASumB,YAC3D,IAAI8xC,EAAcv0D,KAAKw0D,gBAAgBl5D,GACvCi5D,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,GAChEA,GAAa3zD,SACb,IAAA8zD,kBAAiBH,EAAY,GAAGI,eAEpC,MAAMr4B,EAAct8B,KAAK40D,0BAA0B14D,EAASumB,YAAYlB,iBAClE+xB,EAAa,CACfuhB,aAAa,EACb3tD,SAAU,CACN4tD,eAAgB,IAAIllC,GACpBmlC,iBAAkB,IAAIpyC,GACtBihC,SAAU5jD,KAAKg1D,eAEnB9nD,KAAM,CACF+nD,QAAS,CACLxL,WAAYzpD,KAAKypD,WACjBuC,cAAehsD,KAAKgsD,cACpBC,cAAejsD,KAAKisD,eAExBiJ,gBAAiB,KACjBC,kBAAmB,GACnBjmC,aACAkmC,eAAgB,GAChB94B,gBAIR,OADA,IAAA+4B,eAAc/hB,EAAYnkB,GACnB,CACHgc,OAAQ5pB,EACRjT,MAAOpS,EAASk1B,cAAc,CAAC,IAAK,QAG5CpxB,KAAKwkD,kBAAoB,KACH,IAAAC,cAAazkD,KAAK0kD,aAAaC,cAGrD3kD,KAAKs1D,qBAAuB,KACxB,MAAM3Q,EAAgB3kD,KAAKwkD,oBAC3B,IAAK,MAAM+Q,KAAgB5Q,EAAe,CACtC,MAAM,WAAEz1B,EAAU,kBAAEhB,GAAsBqnC,EACpCj6D,GAAiB,IAAAwpD,wBAAuB51B,EAAYhB,GACpDhyB,EAAWZ,EAAeY,SAC1Bs5D,GAAW,EACXC,GAAY,EACZC,GAAgB,EAChBC,GAAgB,EAChBjlC,GAAiB,EACvBx0B,EAASg2B,YAAY,CACjBsjC,WACAC,YACAC,gBACAC,gBACAjlC,mBAEJx0B,EAAS05D,qBACT,MAAM,QAAEzmC,GAAYjzB,EACpB,IAAIq4D,EAAcv0D,KAAKw0D,gBAAgBl5D,GACvCi5D,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,GAChEA,EAAY3zD,SACZ,IAAA8zD,kBAAiBH,EAAY,GAAGI,eAEpCz4D,EAASD,QACb,CACA+D,KAAK61D,mBAAmBlR,IAE5B3kD,KAAK81D,kBAAoB,KACC91D,KAAKwkD,qBAE/BxkD,KAAK61D,mBAAsBlR,IACvB,IAAKA,IAAkBA,EAAc,GAEjC,YADAv0C,QAAQC,KAAK,wEAGjB,MAAM0lD,EAAiB,CAAC,QAAS,UAAW,YACtCC,EAAsBrR,EACvBt+C,IAAKshB,IACN,GAAIA,EAAGuG,kBAAmB,CACtB,MACMhyB,GADkB,IAAAiyB,oBAAmBxG,EAAGuG,mBACbkC,YAAYzI,EAAGuH,YAChD,GAAIhzB,GAAYA,EAASumB,UAAW,CAChC,MAAM6Z,EAAct8B,KAAK40D,0BAA0B14D,EAASumB,YAAYlB,iBACxE,GAAI+a,EACA,OAAOA,CAEf,CACJ,CACA,OAAO,OAENxnB,OAAOmhD,SACNC,EAAqBH,EAAer4C,KAAMrU,IAAQ2sD,EAAoBn7C,SAASxR,IAC/E8sD,EAAiB,GACjBC,EAAiB,GACjBC,EAAuB1R,EAAc7vC,OAAQ6S,IAC/C,IAAI2U,EAAc,KAClB,GAAI3U,EAAGuG,kBAAmB,CACtB,MACMhyB,GADkB,IAAAiyB,oBAAmBxG,EAAGuG,mBACbkC,YAAYzI,EAAGuH,YAC5ChzB,GAAYA,EAASumB,YACrB6Z,EAAct8B,KAAK40D,0BAA0B14D,EAASumB,YAAYlB,iBAE1E,CACA,OAAO+a,GAAey5B,EAAel7C,SAASyhB,KAOlD,GALA+5B,EAAqBp1D,QAASq1D,IAC1B,MAAM,OAAEnrB,EAAM,MAAE78B,GAAUtO,KAAKq0D,mBAAmBiC,GAClDH,EAAextD,KAAKwiC,GACpBirB,EAAeztD,KAAK2F,KAEY,IAAhC+nD,EAAqBz1D,QAAgBs1D,EAAoB,CACzD,MAAMK,EAAgB,CAAC,EAAG,EAAG,GAC7B,WAAWA,EAAeJ,EAAe,GAAIA,EAAe,IAC5D,eAAeI,EAAeA,GAC9B,MAAMC,EAAgB,EACjBJ,EAAe,GAAG,GAAKA,EAAe,GAAG,IAAM,GAC/CA,EAAe,GAAG,GAAKA,EAAe,GAAG,IAAM,GAC/CA,EAAe,GAAG,GAAKA,EAAe,GAAG,IAAM,GAE9C95B,EAAc,KACdm6B,EAAoB,CACtB5B,aAAa,EACb3tD,SAAU,CACN4tD,eAAgB,IAAI0B,GACpBzB,iBAAkB,IAAIyB,GACtB5S,SAAU5jD,KAAKg1D,eAEnB9nD,KAAM,CACF+nD,QAAS,CACLC,gBAAiB,KACjBzL,WAAYzpD,KAAKypD,WACjBuC,cAAehsD,KAAKgsD,cACpBC,cAAejsD,KAAKisD,eAExBkJ,kBAAmB,GACnBjmC,WAAYgnC,EACZd,eAAgB,GAChB94B,eAEJo6B,WAAW,EACXH,iBAEJv2D,KAAKo0D,oBAAsB,CAACqC,EAChC,MACK,GAAoC,IAAhCJ,EAAqBz1D,OAAc,CACxC,IAAI+1D,EAAqB,KACzB,MAAML,EAASD,EAAqB,GACpC,GAAIC,EAAOpoC,kBAAmB,CAC1B,MACMhyB,GADkB,IAAAiyB,oBAAmBmoC,EAAOpoC,mBACjBkC,YAAYkmC,EAAOpnC,YAChDhzB,GAAYA,EAASumB,YACrBk0C,EAAqB32D,KAAK40D,0BAA0B14D,EAASumB,YAAYlB,iBAEjF,CACA,MAAMq1C,EAAgBR,EAAe,GAC/BS,EAAmB,CACrB1N,MAAO,CAAC,EAAG,EAAG,GACdD,QAAS,CAAC,EAAG,EAAG,GAChBD,SAAU,CAAC,EAAG,EAAG,IAGf6N,EADaf,EAAejhD,OAAQzL,GAAOA,IAAOstD,GAClBtwD,IAAKi2B,IACvC,MAAM6O,EAAS0rB,EAAiBv6B,GAuBhC,MAtB0B,CACtBu4B,aAAa,EACb3tD,SAAU,CACN4tD,eAAgB,IAAI8B,GACpB7B,iBAAkB,IAAI6B,GACtBhT,SAAU5jD,KAAKg1D,eAEnB9nD,KAAM,CACF+nD,QAAS,CACLC,gBAAiB,KACjBzL,WAAYzpD,KAAKypD,WACjBuC,cAAehsD,KAAKgsD,cACpBC,cAAejsD,KAAKisD,eAExBkJ,kBAAmB,GACnBjmC,WAAYoN,EACZ84B,eAAgB,GAChB94B,eAEJo6B,WAAW,EACXH,cAAeprB,KAIvBnrC,KAAKo0D,oBAAsB0C,CAC/B,CACInS,GAAiBA,EAAc/jD,SAC/B,EAAAm2D,EAAA,GAAsCpS,EAAct+C,IAAI,EAAG6oB,gBAAiBA,KAGpFlvB,KAAKiL,OAAS,KACVmF,QAAQ6Q,IAAI,wBAEhBjhB,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,MACnDl3D,KAAKm3D,eAAehoC,EAASmkB,EAAY2jB,EAAc,GAK/Dj3D,KAAKo3D,qBAAuB,CAAChV,EAAK9O,EAAY+jB,KAC1C,MAAMtmC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB70D,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,GAClBizB,EAAIoV,kBAERx3D,KAAKy3D,cAAiBrV,IAClBpiD,KAAKs1D,wBAETt1D,KAAK03D,kBAAoB,CAACtV,EAAKuV,KAC3B,IAAKA,EACD,OAEJ,MAAM,QAAExoC,EAAO,cAAE62B,GAAkB5D,EAAIrtB,OACjCkiC,EAAejR,EAAcvqD,OACnC,IAAIm8D,GAAmB,EACvB,IAAK,IAAIluD,EAAI,EAAGA,EAAIiuD,EAAwB/2D,OAAQ8I,IAAK,CACrD,MAAM4pC,EAAaqkB,EAAwBjuD,GAC3C,IAAI,KAAAmuD,oBAAmBvkB,EAAWqhB,eAC9B,SAEJ,MAAM,KAAEznD,EAAI,YAAE2nD,GAAgBvhB,EAC9B,IAAKpmC,EAAK+nD,QACN,SAE4B/nD,EAAK+nD,QAAQC,gBACXhoD,EAAKioD,mBAAqBjoD,EAAKioD,kBAAkBv0D,OAAS,GAClFsM,EAAKioD,kBAEfjoD,EAAKioD,kBAAoB,GACzB,IAAI2C,GAAO,EACXA,EAAO93D,KAAKm3D,eAAehoC,EAASmkB,EAAY2jB,EAAc,IAC3Ba,IAASjD,IACRiD,GAAQjD,KAExCvhB,EAAWuhB,aAAeA,EAC1B+C,GAAmB,EAE3B,CACA,OAAOA,GAEX53D,KAAKy0D,wCAA0C,CAACtlC,EAASolC,KACrD,IAAKA,IAAgBA,EAAY3zD,OAC7B,MAAO,GAEX,MAAMtF,GAAiB,IAAAy/B,mBAAkB5L,GACzC,IAAImN,EAAc,KACdhhC,EAAeY,UAAYZ,EAAeY,SAASumB,YACnD6Z,EAAct8B,KAAK40D,0BAA0Bt5D,EAAeY,SAASumB,YAAYlB,kBAErF,MAAMw2C,EAAWxD,EAAYz/C,OAAQw+B,KAC7BA,EAAWojB,cAGXpjB,EAAWpmC,KAAKovB,cAChBA,GACAgX,EAAWpmC,KAAKovB,cAAgBA,IAKxC,OAAOy7B,GAEX/3D,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,SAASC,EAAmBztB,EAAI4T,EAAI8Z,EAAIC,GACpC,MAAMC,EAAOha,EAAG,GAAK5T,EAAG,GAClB6tB,EAAOja,EAAG,GAAK5T,EAAG,GAClB8tB,EAAOH,EAAG,GAAKD,EAAG,GAClBK,EAAOJ,EAAG,GAAKD,EAAG,GAClBM,GAASF,EAAOD,EAAOD,EAAOG,EACpC,GAAIv7D,KAAK6e,IAAI28C,GAAS,KAClB,OAAO,KAEX,MAAM/W,IAAM4W,GAAQ7tB,EAAG,GAAK0tB,EAAG,IAAME,GAAQ5tB,EAAG,GAAK0tB,EAAG,KAAOM,EACzDvtB,GAAKqtB,GAAQ9tB,EAAG,GAAK0tB,EAAG,IAAMK,GAAQ/tB,EAAG,GAAK0tB,EAAG,KAAOM,EAC9D,OAAI/W,GAAK,GAAKA,GAAK,GAAKxW,GAAK,GAAKA,GAAK,EAC5B,CAACT,EAAG,GAAKS,EAAImtB,EAAM5tB,EAAG,GAAKS,EAAIotB,GAEnC,IACX,CACA,MAAM3T,EAAgB3kD,KAAKwkD,oBAC3B,IAAKG,GAA0C,IAAzBA,EAAc/jD,OAChC,OAAO,EAEX,IAAI83D,GAAe,EACnB,MAAM,SAAEx8D,EAAQ,gBAAEyd,GAAoBre,GAChC,QAAE6zB,GAAYjzB,EACpB,IAAIq4D,EAAcv0D,KAAKw0D,gBAAgBl5D,GACnC0E,KAAKo0D,qBAAuBp0D,KAAKo0D,oBAAoBxzD,SACrD2zD,EAAcA,EAAY92C,OAAOzd,KAAKo0D,sBAE1C,MAAM5xC,EAAStmB,EAASumB,YAElBk2C,EAD0B34D,KAAKy0D,wCAAwCtlC,EAASolC,GACnC,GACnD,IAAKoE,IAAuBA,EAAmBzrD,KAC3C,OAAOwrD,EAEX,MAAM/D,EAAgBgE,EAAmBhE,eACnC,YAAEvO,EAAW,aAAEC,GAAiBnqD,EAAST,OACzCm9D,EAAuB37D,KAAKopC,KAAK+f,EAAcA,EAAcC,EAAeA,GAC5En5C,EAAOyrD,EAAmBzrD,KAC1B2rD,EAA2BtE,EAC3BuE,EAAgC58D,EAASinD,cAAcnjD,KAAKgsD,eAC5D+M,EAAgC78D,EAASinD,cAAcnjD,KAAKisD,eAC5DmJ,EAAiB,GACjB4D,EAAY,CAAC,EAAG,EAAG5S,EAAaC,GACtCwS,EAAyB53D,QAASqyC,IAC9B,MAAMpmC,EAAOomC,EAAWpmC,KAClBwpD,EAAY,cAAepjB,IACJ,IAAzBA,EAAWojB,UAEf,IAAIuC,EAAeC,EAAa9S,EAAaC,EAAc8S,EAA2BC,EAAmBC,EACzG,GAFAnsD,EAAK+nD,QAAQxL,WAAazpD,KAAKypD,WAE3BiN,EAAW,CACX,MAAM4C,EAAgB3U,EAAc7vC,OAAQ6S,GAAOA,EAAGuH,aAAehiB,EAAKgiB,YAC1E,GAA6B,IAAzBoqC,EAAc14D,OAAc,CAC5B,MAAM24D,EAAM5/C,EAAgByW,YAAYkpC,EAAc,GAAGpqC,YACnDsqC,EAAM7/C,EAAgByW,YAAYkpC,EAAc,GAAGpqC,YACnDuqC,EAAUF,EAAI92C,YAAYlB,gBAC1Bm4C,EAAUF,EAAI/2C,YAAYlB,gBAC1Bg1C,EAAgB,cACtB,WAAWA,EAAekD,EAASC,GACnC,eAAenD,EAAeA,GAC9B2C,EAAc,CACV33C,gBAAiBg1C,EACjB3mC,SAAU1iB,EAAK+nD,QAAQxL,WACvB9mC,WAAYzV,EAAK+nD,QAAQxL,WACzBzkB,OAAQ,CAAC,EAAG,EAAG,IAEnBohB,EAAclqD,EAAST,OAAO2qD,YAC9BC,EAAenqD,EAAST,OAAO4qD,aAC/B8S,EAA4Bl8D,KAAKopC,KAAK+f,EAAcA,EAAcC,EAAeA,GACjF+S,EAAoB,CAAe,GAAdhT,EAAkC,GAAfC,GACxCgT,EAA2BnsD,EAAK+nD,QAAQxL,WACxCwP,EAAgB,CACZ5vD,GAAI6D,EAAKgiB,WACTzzB,OAAQS,EAAST,OACjB21B,cAAe,IAAMlkB,EAAK+nD,QAAQxL,WAE1C,KACK,CAGDyP,EAAc,CACV33C,gBAHkB+xB,EACjBijB,eAAiB,CAAC,EAAG,EAAG,GAGzB3mC,SAAU1iB,EAAK+nD,QAAQxL,WACvB9mC,WAAYzV,EAAK+nD,QAAQxL,WACzBzkB,OAAQ,CAAC,EAAG,EAAG,IAEnBohB,EAAclqD,EAAST,OAAO2qD,YAC9BC,EAAenqD,EAAST,OAAO4qD,aAC/B8S,EAA4Bl8D,KAAKopC,KAAK+f,EAAcA,EAAcC,EAAeA,GACjF+S,EAAoB,CAAe,GAAdhT,EAAkC,GAAfC,GACxCgT,EAA2BnsD,EAAK+nD,QAAQxL,WACxCwP,EAAgB,CACZ5vD,GAAI6D,EAAKgiB,WACTzzB,OAAQS,EAAST,OACjB21B,cAAe,IAAMlkB,EAAK+nD,QAAQxL,WAE1C,CACJ,MAEIwP,EAAgBt/C,EAAgByW,YAAYljB,EAAKgiB,YACjDgqC,EAAcD,EAAcx2C,YAC5B2jC,EAAc6S,EAAcx9D,OAAO2qD,YACnCC,EAAe4S,EAAcx9D,OAAO4qD,aACpC8S,EAA4Bl8D,KAAKopC,KAAK+f,EAAcA,EAAcC,EAAeA,GACjF+S,EAAoB,CAAe,GAAdhT,EAAkC,GAAfC,GACxCgT,EACIJ,EAAc7nC,cAAcgoC,GAEpC,MAAMO,EAA4B35D,KAAK45D,8BAA8BX,EAAc5vD,IAC7EpB,EAAY,CAAC,EAAG,EAAG,GACzB,YAAcua,EAAOjB,gBAAiB23C,EAAY33C,gBAAiBtZ,GACnE,gBAAkBA,GAClB,qBAAuBA,EAAWkxD,GAClC,MAAMU,EAAc,CAAC,EAAG,EAAG,GAC3B,UAAYR,EAA0BpxD,EAAW4xD,GAEjD,eAAiBR,EAA0BpxD,EADvB,CAAC,EAAG,EAAG,IAE3B,MAAM6xD,EAAe59D,EAASinD,cAAc0W,GACtCE,EAA4B79D,EAASinD,cAAc,CACrDkW,EAAyB,IAAM,EAC/BA,EAAyB,IAAM,EAC/BA,EAAyB,IAAM,IAE7BW,EAA6B,cACnC,cAAcA,EAA4BF,EAAcC,GACxD,eAAeC,EAA4BA,GAC3C,MAAMC,EAA6B,cACnC,WAAWA,EAA4BD,EAAmD,IAAvBpB,GACnE,MAAMsB,EAAoBP,EACpB,WAAWb,GACX,WAAWiB,GACXI,EAAqB,cACrBC,EAAqB,cAC3B,SAASD,EAAoBD,EAAmBD,GAChD,cAAcG,EAAoBF,EAAmBD,IACrD,EAAAI,GAAA,GAAgBF,EAAoBC,EAAoBpB,GACxD5D,EAAezsD,KAAK,CAChBswD,EACAkB,EACAC,EACA,QAEJ,MAAME,EAAoBX,EACpB,WAAWZ,GACX,WAAWgB,GACXQ,EAAqB,cACrBC,EAAqB,cAC3B,SAASD,EAAoBD,EAAmBL,GAChD,cAAcO,EAAoBF,EAAmBL,IACrD,EAAAI,GAAA,GAAgBE,EAAoBC,EAAoBxB,GACxD5D,EAAezsD,KAAK,CAChBswD,EACAsB,EACAC,EACA,UAGRttD,EAAKkoD,eAAiBA,EACtB,MAAMqF,EAAgBz6D,KAAK06D,uBAAuBx+D,EAASmN,IACrDjN,OAA0B4B,IAAlBy8D,EAA8BA,EAAgB,qBA4E5D,GA3EArF,EAAen0D,QAAQ,CAAC05D,EAAMC,KAC1B,MAAMC,EAAgB,GACtB,IAAK,IAAI5oD,EAAI,EAAGA,EAAImjD,EAAex0D,SAAUqR,EAAG,CAC5C,GAAIA,IAAM2oD,EACN,SAEJ,MAAME,EAAY1F,EAAenjD,GAC3B8oD,EAAe7C,EAAmByC,EAAK,GAAIA,EAAK,GAAIG,EAAU,GAAIA,EAAU,IAC9EC,GACAF,EAAclyD,KAAK,CACfqyD,KAAMF,EAAU,GAChBxsD,MAAOysD,GAGnB,CACA,MAAM9B,EAAgB0B,EAAK,GAC3B,IAAIr+B,EAAc,KAClB,GAAI28B,GAAiBA,EAAc5vD,GAAI,CACnC,MAAM4xD,EAAwB1G,EAAY72C,KAAMxB,GAAMA,EAAEhP,KAAKgiB,aAAe+pC,EAAc5vD,IAC1F,GAAI4xD,GAAyBA,EAAsB/tD,KAAKovB,YACpDA,EAAclwB,OAAO6uD,EAAsB/tD,KAAKovB,aAAa4+B,kBAE5D,CACD,MAAMC,EAAUlC,EAAc5vD,GAAG6xD,cAC7BC,EAAQtgD,SAAS,SACjByhB,EAAc,QAET6+B,EAAQtgD,SAAS,WACtByhB,EAAc,UAET6+B,EAAQtgD,SAAS,cACtByhB,EAAc,WAEtB,CACJ,CACA,MAAM23B,EAAaj0D,KAAKyM,cAAcwnD,YAAc,CAAC,EAC/CmH,EAAWnH,EAAW33B,IACxB23B,EAAWoH,SAAW,CAAC,EAAK,EAAK,GAC/Bj/D,EAAQsC,MAAMC,QAAQy8D,GACtB,OAAOA,EAAS/0D,IAAKoJ,GAAMxS,KAAKgmB,MAAU,IAAJxT,IAAUie,KAAK,QACrD0tC,EACAE,EAAuBt7D,KAAK45D,8BAA8BX,EAAc5vD,IACxEkyD,EAAqBruD,EAAKioD,kBAAkBz3C,KAAMrU,GAAOA,IAAO4vD,EAAc5vD,IACpF,IAAI6qD,EAAYl0D,KAAKyM,cAAcynD,WAAa,IACI,OAAjChnD,EAAK+nD,QAAQC,iBAC5BhoD,EAAK+nD,QAAQC,kBAAoBtB,IACjC2H,IAEArH,EAAYl0D,KAAKyM,cAAc+uD,iBAAmB,KAEtD,MAAMC,EAAU,GAAGb,IACnB,GAAIU,IAC6B,IAAzBT,EAAcj6D,SACd,IAAA86D,UAAYzD,EAAkBtD,EAAe8G,EAASZ,EAAc,GAAGvsD,MAAOusD,EAAc,GAAGvsD,MAAO,CAClGlS,QACA83D,cAGJl0D,KAAKyM,cAAcunD,sBACM,IAAzB6G,EAAcj6D,QACVZ,KAAKyM,cAAcunD,sBACM,IAAzB6G,EAAcj6D,QAAc,CAC5B,MAAM+6D,EAAsBd,EACvBx0D,IAAK00D,IAAiB,IACpBA,EACH/+C,SAAU,cAAc2+C,EAAK,GAAII,EAAazsD,UAE7C2N,KAAK,CAACC,EAAGhF,IAAMgF,EAAEF,SAAW9E,EAAE8E,WACnC,IAAA0/C,UAAYzD,EAAkBtD,EAAe8G,EAAU,iBAAkBd,EAAK,GAAIgB,EAAoB,GAAGrtD,MAAO,CAAElS,QAAO83D,YAAW0H,SAAU,CAAC,EAAG,MAClJ,IAAAF,UAAYzD,EAAkBtD,EAAe8G,EAAU,gBAAiBE,EAAoB,GAAGrtD,MAAOqsD,EAAK,GAAI,CAAEv+D,QAAO83D,YAAW0H,SAAU,CAAC,EAAG,IACrJ,IAIZlD,GAAe,EACX14D,KAAKyM,cAAcqnD,mBAAoB,CACvC,MAAM,yBAAEC,GAA6B/zD,KAAKyM,cAGpCovD,EAA4B,CAC9BzV,GAHY2N,GAA0B+H,SAAW,KAIjDzV,GAHY0N,GAA0BgI,SAAW,MAK/CC,EAAejI,GAA0BiI,cAAuC,IAAvBpD,EACzDqD,EAAY,KAClB,IAAAC,YAAcjE,EAAkBtD,EAAesH,EAAWJ,EAA2BG,EAAc,CAAE5/D,QAAO0V,KAAM1V,GACtH,CACA,OAAOs8D,GAEX14D,KAAKw0D,gBAAmBl5D,IACpB,MAAM,SAAEY,GAAaZ,EACfi5D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe94D,EAASizB,UAAY,GACtEtV,EAAc7Z,KAAKwkD,oBAAoBn+C,IAAI,EAAG6oB,gBAAiBA,GAC/DktC,EAAuB7H,EAAYz/C,OAAQw+B,IAC7C,MAAM,KAAEpmC,GAASomC,EACjB,OAAOz5B,EAAYgB,SAAS3N,EAAKgiB,cAErC,OAAOktC,GAEXp8D,KAAKq8D,eAAkBja,IACnB,GAAIA,EAAIrtB,OAAOw0B,uBACXvpD,KAAKs8D,4BAA4Bla,EAAIrtB,OAAOw0B,4BAE3C,CACD,GAAInH,EAAIrtB,OAAOqG,oBAAsBp7B,KAAKo7B,kBACtC,OAEJ,MAAM,oBAAEouB,EAAmB,WAAEC,GAAerH,EAAIrtB,OAC1CwnC,EAAS,IAAIv8D,KAAKgsD,eAClBwQ,EAAS,IAAIx8D,KAAKisD,eACxB,GAAIzC,GAAuB,GAAKA,GAAuB,EAAG,CACtD,MAAM/D,EAAOxoD,KAAK+Q,MAAMw7C,EAAsB,GAK9C,OAJcA,EAAsB,GAAM,EACjC+S,EAASC,GAAQ/W,GAAQgE,EAAWhE,GAC7CzlD,KAAKy8D,cAAcF,EAAQ,YAC3Bv8D,KAAKy8D,cAAcD,EAAQ,MAE/B,CACA,GAAIhT,GAAuB,GAAKA,GAAuB,GAAI,CACvD,MAAM7X,EAAM6X,EACR7X,EAAM,GACN4qB,EAAO,GAAK9S,EAAW,GAGvB+S,EAAO,GAAK/S,EAAW,GAEvB,CAAC,EAAG,EAAG,GAAI,IAAI5uC,SAAS82B,GACxB4qB,EAAO,GAAK9S,EAAW,GAGvB+S,EAAO,GAAK/S,EAAW,GAEvB9X,EAAM,GAAM,EACZ4qB,EAAO,GAAK9S,EAAW,GAGvB+S,EAAO,GAAK/S,EAAW,GAE3BzpD,KAAKy8D,cAAcF,EAAQ,OAC3Bv8D,KAAKy8D,cAAcD,EAAQ,MAC/B,CACJ,GAEJx8D,KAAKowD,aAAe,KAChB,MAAMzL,EAAgB3kD,KAAKwkD,oBAC3B,GAAIG,GAAiBA,EAAc/jD,OAAS,EAAG,CAC3C,MAAM,WAAEsuB,EAAU,kBAAEhB,GAAsBy2B,EAAc,GAElDzoD,GADkB,IAAAiyB,oBAAmBD,GACVkC,YAAYlB,GACvCxI,EAAexqB,EAAS0mB,YAC9B,GAAI8D,EAAa9lB,OAAS,EAAG,CACzB,MAAM+jB,EAAY+B,EAAa,GAAGvQ,MAAMkI,YAAYa,eACpD,GAAIyF,EAAW,CACX3kB,KAAKo7B,kBAAoBzW,EAAUyW,kBACnCp7B,KAAKs0D,+BAA+Bp4D,KAChB,IAAAigE,gBAAen8D,KAAKg1D,cAAe9lC,IAAe,IAC1DjuB,QAASqyC,IACbA,EAAWpmC,MAAQomC,EAAWpmC,KAAK+nD,UACnC3hB,EAAWpmC,KAAK+nD,QAAQxL,WAAa,IAAIzpD,KAAKypD,cAG1D,CACJ,CACJ,CACAzpD,KAAK61D,mBAAmBlR,IACxB,IAAAviB,cAAa,EAAAxN,YAAa,EAAAnD,OAAO49B,mCAAoC,CACjE3K,YAAa1kD,KAAK0kD,YAClBC,cAAeA,EACfvpB,kBAAmBp7B,KAAKo7B,qBAGhCp7B,KAAK08D,gDAAkD,CAACphE,EAAgBi5D,KACpE,MAAM,WAAErlC,EAAU,gBAAEvV,EAAe,SAAEzd,GAAaZ,EAC5Cu9D,EAA2BtE,EAAYz/C,OAAQw+B,GAAeA,EAAWpmC,KAAKgiB,aAAeA,GACnG,IAAK2pC,IAA6BA,EAAyBj4D,OACvD,MAAO,GAEX,MAAM4hB,EAAStmB,EAASumB,aAClB,gBAAElB,EAAe,SAAEqO,GAAapN,EAChCm6C,EAAgC9D,EAAyB/jD,OAAQw+B,IACnE,MAAM,WAAEpkB,GAAeokB,EAAWpmC,KAE5B0vD,EADiBjjD,EAAgByW,YAAYlB,GACbzM,YACtC,QAAS,oBAAgBm6C,EAAer7C,gBAAiBA,EAAiB,MAAS,oBAAgBq7C,EAAehtC,SAAUA,EAAU,MAE1I,OAAO+sC,GAEX38D,KAAK68D,mCAAqC,CAACvhE,EAAgBwhE,EAAqBvI,KAC5E,MAAM,gBAAE56C,GAAoBre,GACtB,KAAE4R,GAAS4vD,EACX5gE,EAAWyd,EAAgByW,YAAYljB,EAAKgiB,YAC5C6tC,EAA4BxI,EAAYz/C,OAAQw+B,IAClD,MAAM,KAAEpmC,GAASomC,EACX2lB,EAAgBt/C,EAAgByW,YAAYljB,EAAKgiB,YAEvD,OAAqC,IADHlvB,KAAK45D,8BAA8BX,EAAc5vD,MAGvF,IAAK0zD,IAA8BA,EAA0Bn8D,OACzD,MAAO,GAEX,MAAM4hB,EAAStmB,EAASumB,YAClBlB,EAAkBiB,EAAOjB,gBAC/B,gBAAkBA,GAClB,MAAMy7C,EAAmDD,EAA0BjoD,OAAQw+B,IACvF,MAAM,WAAEpkB,GAAeokB,EAAWpmC,KAE5BgsD,EADgBv/C,EAAgByW,YAAYlB,GAChBzM,YAC5Bw6C,EAAuB/D,EAAY33C,gBAEzC,OADA,gBAAkB07C,GACV,oBAAgB17C,EAAiB07C,EAAsB,MAC3D,oBAAgBz6C,EAAOwiB,OAAQk0B,EAAYl0B,OAAQ,OAE3D,OAAOg4B,GAEXh9D,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAyBl9D,KAAKyM,cAAco8C,QAAQC,QAC1D35B,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpB/wB,KAAK29D,SAASrqB,WAAWpmC,KAAK+nD,QAAQC,gBAAkB,KACxDl1D,KAAK29D,SAASrqB,WAAWpmC,KAAKioD,kBAAoB,GAClDn1D,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnBnvB,KAAK29D,SAAW,KAChB,MACME,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAD1C,IAE/B,EAAA+B,EAAA,GAAsC8G,IAE1C79D,KAAKqiD,cAAiBD,IAClB,MAAMrxB,EAAcqxB,EAAIrtB,OAClBxf,EAAQwb,EAAYwyB,YAAYE,MACtC,GAAIxmD,KAAK6e,IAAIvG,EAAM,IAAM,MACrBtY,KAAK6e,IAAIvG,EAAM,IAAM,MACrBtY,KAAK6e,IAAIvG,EAAM,IAAM,KACrB,OAEJ,MAAM,QAAE4Z,GAAY4B,EACdz1B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACrB,GAAIY,EAAS4K,OAAS,EAAA8pC,MAAA,aAAmBmtB,UACrC,OAEJ,MAAMxJ,EAAcv0D,KAAKw0D,gBAAgBl5D,GAEnCq9D,EAD0B34D,KAAKy0D,wCAAwCtlC,EAASolC,GACnC,GACnD,IAAKoE,EACD,OAEJ,MAAM,QAAE1D,GAAY0D,EAAmBzrD,KACvC,GAAI+nD,EAAQC,kBAAoBtB,GAAgB,CACjB,QAAvBqB,EAAQ+I,YACRh+D,KAAKgsD,cAAc,IAAMz2C,EAAM,GAC/BvV,KAAKgsD,cAAc,IAAMz2C,EAAM,GAC/BvV,KAAKgsD,cAAc,IAAMz2C,EAAM,IAEH,QAAvB0/C,EAAQ+I,YACbh+D,KAAKisD,cAAc,IAAM12C,EAAM,GAC/BvV,KAAKisD,cAAc,IAAM12C,EAAM,GAC/BvV,KAAKisD,cAAc,IAAM12C,EAAM,KAG/BvV,KAAKypD,WAAW,IAAMl0C,EAAM,GAC5BvV,KAAKypD,WAAW,IAAMl0C,EAAM,GAC5BvV,KAAKypD,WAAW,IAAMl0C,EAAM,IAEhC,MAAMovC,EAAgB3kD,KAAKwkD,qBAC3B,EAAAuS,EAAA,GAAsCpS,EAAct+C,IAAI,EAAG6oB,gBAAiBA,KAC5E,IAAAkT,cAAa,EAAAxN,YAAa,EAAAnD,OAAO49B,mCAAoC,CACjE3K,YAAa1kD,KAAK0kD,YAClB+E,WAAYzpD,KAAKypD,WACjBuC,cAAehsD,KAAKgsD,cACpBC,cAAejsD,KAAKisD,cACpBF,WAAYkJ,EAAQ+I,WACpBvR,oBAAqB,GACrBrxB,kBAAmBp7B,KAAKo7B,mBAEhC,GAEJp7B,KAAK06D,uBACD3Y,EAAUt1C,eAAewxD,uBACrBvK,GACR1zD,KAAK45D,8BACD7X,EAAUt1C,eAAeyxD,8BACrBvK,GACR,MAAMhP,GAAgB,IAAAF,cAAazkD,KAAK0kD,cAAcC,cAEtD,GADA,EAAA/vB,YAAYnK,iBAAiB,EAAAgH,OAAOs7B,4BAA6B/sD,KAAKq8D,gBAClE1X,GAAiBA,EAAc/jD,OAAS,EAAG,CAC3C,MAAM,WAAEsuB,EAAU,kBAAEhB,GAAsBy2B,EAAc,GAIlDj+B,IAHiB,IAAAo+B,wBAAuB51B,EAAYhB,IAClC,IAAAC,oBAAmBD,GACVkC,YAAYlB,GACftM,aAC9B,IAAK8D,IAAiBA,EAAa9lB,OAE/B,YADAwP,QAAQC,KAAK,iEAAiE6e,MAGlF,MAAMvK,EAAY+B,EAAa,GAAGvQ,MAAMkI,YAAYa,eACpD,GAAIyF,EAAW,CACX,MAAM9c,EAAa8c,EAAUM,gBACvBnd,EAAU6c,EAAUw5C,aACpBp2D,EAAS4c,EAAU4nC,YACzBvsD,KAAKo7B,kBAAoBzW,EAAUyW,mBAAqB,UACxD,MAAM8xB,EAAaltD,KAAKyM,cAAcs8C,mBAAqB,GAC3D/oD,KAAKypD,WAAa,CACd1hD,EAAO,GAAKmlD,GAAcrlD,EAAW,GAAK,GAAKC,EAAQ,GACvDC,EAAO,GAAKmlD,GAAcrlD,EAAW,GAAK,GAAKC,EAAQ,GACvDC,EAAO,GAAKmlD,GAAcrlD,EAAW,GAAK,GAAKC,EAAQ,IAE3D,MAAMs2D,EAAgB,EAAIlR,EAC1BltD,KAAKgsD,cAAgB,CACjBjkD,EAAO,GAAKmlD,GAAcrlD,EAAW,GAAK,GAAKC,EAAQ,GACvDC,EAAO,GAAKmlD,GAAcrlD,EAAW,GAAK,GAAKC,EAAQ,GACvDC,EAAO,GAAKmlD,GAAcrlD,EAAW,GAAK,GAAKC,EAAQ,IAE3D9H,KAAKisD,cAAgB,CACjBlkD,EAAO,GAAKq2D,GAAiBv2D,EAAW,GAAK,GAAKC,EAAQ,GAC1DC,EAAO,GAAKq2D,GAAiBv2D,EAAW,GAAK,GAAKC,EAAQ,GAC1DC,EAAO,GAAKq2D,GAAiBv2D,EAAW,GAAK,GAAKC,EAAQ,GAElE,CACJ,CACJ,CACA,8BAAAwsD,CAA+Bp4D,GAC3B,MAAMwqB,EAAexqB,EAAS0mB,YAC9B,IAAK8D,IAAiBA,EAAa9lB,OAC/B,OAEJ,MAAM+jB,EAAY+B,EAAa,GAAGvQ,MAAMkI,YAAYa,eACpD,IAAKyF,EACD,OAEJ3kB,KAAKo7B,kBAAoBzW,EAAUyW,mBAAqB,UACxD,MAAMvzB,EAAa8c,EAAUM,gBACvBnd,EAAU6c,EAAUw5C,aACpBp2D,EAAS4c,EAAU4nC,YACnBW,EAAaltD,KAAKyM,cAAcs8C,mBAAqB,GACrDsV,EAAYnR,EAAa,EACzBoR,EAAU,EAAIpR,EAAa,EACjCltD,KAAKypD,WAAa,CACd1hD,EAAO,IACDs2D,EAAYC,GAAW,GAAMz2D,EAAW,GAAK,GAAKC,EAAQ,GAChEC,EAAO,IACDs2D,EAAYC,GAAW,GAAMz2D,EAAW,GAAK,GAAKC,EAAQ,GAChEC,EAAO,IACDs2D,EAAYC,GAAW,GAAMz2D,EAAW,GAAK,GAAKC,EAAQ,IAEpE9H,KAAKgsD,cAAgB,CACjBjkD,EAAO,GAAKs2D,GAAax2D,EAAW,GAAK,GAAKC,EAAQ,GACtDC,EAAO,GAAKs2D,GAAax2D,EAAW,GAAK,GAAKC,EAAQ,GACtDC,EAAO,GAAKs2D,GAAax2D,EAAW,GAAK,GAAKC,EAAQ,IAE1D9H,KAAKisD,cAAgB,CACjBlkD,EAAO,GAAKu2D,GAAWz2D,EAAW,GAAK,GAAKC,EAAQ,GACpDC,EAAO,GAAKu2D,GAAWz2D,EAAW,GAAK,GAAKC,EAAQ,GACpDC,EAAO,GAAKu2D,GAAWz2D,EAAW,GAAK,GAAKC,EAAQ,GAE5D,CACA,iBAAAy2D,GACInuD,QAAQqM,MAAM,gEAAgEzc,KAAKg1D,gBACvF,CACA,eAAApQ,GACI,MAAMD,EAAgB3kD,KAAKwkD,oBAC3B,IAAIga,GAAsB,EAC1B,IAAK,MAAMlI,KAAU3R,EAAe,CAChC,MAAMrpD,GAAiB,IAAAwpD,wBAAuBwR,EAAOpnC,WAAYonC,EAAOpoC,mBAClEqmC,EAAcv0D,KAAKw0D,gBAAgBl5D,GACzC,GAAIi5D,GAAeA,EAAY3zD,OAAS,EAAG,CACvC49D,GAAsB,EACtB,KACJ,CACJ,CACA,GAAKA,EAWD,IAAK,MAAMlI,KAAU3R,EAAe,CAChC,MAAMrpD,GAAiB,IAAAwpD,wBAAuBwR,EAAOpnC,WAAYonC,EAAOpoC,mBACxE,IAAK5yB,EACD,SAEJ,MAAMi5D,EAAcv0D,KAAKw0D,gBAAgBl5D,GACrCi5D,GAAeA,EAAY3zD,OAAS,GACpC2zD,EAAYtzD,QAASqyC,KACjB,IAAAohB,kBAAiBphB,EAAWqhB,iBAGpCr5D,EAAeY,SAASD,QAC5B,MAtBA+D,KAAKwwD,mCAAmC7L,GACxC3kD,KAAKywD,iCAAiC9L,GACtC3kD,KAAK61D,mBAAmBlR,IACxB,IAAAviB,cAAa,EAAAxN,YAAa,EAAAnD,OAAO49B,mCAAoC,CACjE3K,YAAa1kD,KAAK0kD,YAClBC,cAAeA,EACfvpB,kBAAmBp7B,KAAKo7B,mBAkBpC,CACA,gBAAA2uB,GACI35C,QAAQqM,MAAM,+DAA+Dzc,KAAKg1D,iBAC5Dh1D,KAAKwkD,mBAC/B,CACA,iBAAAa,GACIj1C,QAAQqM,MAAM,gEAAgEzc,KAAKg1D,iBACnF,MAAMrQ,EAAgB3kD,KAAKwkD,oBAC3BxkD,KAAKwwD,mCAAmC7L,GACxCA,EAAc1jD,QAAQ,EAAGitB,oBAAmBgB,iBACxC,MAAM5zB,GAAiB,IAAAwpD,wBAAuB51B,EAAYhB,GAC1D,IAAK5yB,EACD,OAEJ,MAAMi5D,EAAcv0D,KAAKw0D,gBAAgBl5D,GACrCi5D,GAAa3zD,QACb2zD,EAAYtzD,QAASqyC,KACjB,IAAAohB,kBAAiBphB,EAAWqhB,kBAI5C,CACA,yBAAAC,CAA0BzpB,GACtB,IAAKA,EACD,OAAO,KAEX,MAAMszB,EAAY,CACdtV,MAAO,CAAC,EAAG,EAAG,GACdD,QAAS,CAAC,EAAG,EAAG,GAChBD,SAAU,CAAC,EAAG,EAAG,IAEfyV,EAAM,IACZ,IAAK,MAAOv+D,EAAKF,KAAUL,OAAOqrB,QAAQwzC,GAAY,CAClD,GAAIxhE,KAAK6e,IAAIqvB,EAAO,GAAKlrC,EAAM,IAAMy+D,GACjCzhE,KAAK6e,IAAIqvB,EAAO,GAAKlrC,EAAM,IAAMy+D,GACjCzhE,KAAK6e,IAAIqvB,EAAO,GAAKlrC,EAAM,IAAMy+D,EACjC,OAAOv+D,EAEX,GAAIlD,KAAK6e,IAAIqvB,EAAO,GAAKlrC,EAAM,IAAMy+D,GACjCzhE,KAAK6e,IAAIqvB,EAAO,GAAKlrC,EAAM,IAAMy+D,GACjCzhE,KAAK6e,IAAIqvB,EAAO,GAAKlrC,EAAM,IAAMy+D,EACjC,OAAOv+D,CAEf,CACA,OAAO,IACX,CACA,2BAAAm8D,CAA4B/S,GACxB,MAAMqE,EAASrE,EACf,GAAIqE,EAAOhtD,QAAU,EAAG,CACpBZ,KAAKgsD,cAAgB,CACjB4B,EAAO,GAAG7lD,OAAO,GACjB6lD,EAAO,GAAG7lD,OAAO,GACjB6lD,EAAO,GAAG7lD,OAAO,IAErB/H,KAAKisD,cAAgB,CACjB2B,EAAO,GAAG7lD,OAAO,GACjB6lD,EAAO,GAAG7lD,OAAO,GACjB6lD,EAAO,GAAG7lD,OAAO,IAErB/H,KAAKypD,WAAa,EACbzpD,KAAKgsD,cAAc,GAAKhsD,KAAKisD,cAAc,IAAM,GACjDjsD,KAAKgsD,cAAc,GAAKhsD,KAAKisD,cAAc,IAAM,GACjDjsD,KAAKgsD,cAAc,GAAKhsD,KAAKisD,cAAc,IAAM,GAEtD,MAAMtH,EAAgB3kD,KAAKwkD,oBAC3BG,EAAc1jD,QAAQ,EAAGiuB,aAAYhB,wBACjC,MAAM5yB,GAAiB,IAAAwpD,wBAAuB51B,EAAYhB,GAC1D,GAAI5yB,EAAgB,CACI0E,KAAKw0D,gBAAgBl5D,GAC7B2F,QAASqyC,IACjB,GAAIA,EAAWpmC,MACXomC,EAAWpmC,KAAK+nD,SAChB3hB,EAAWpmC,KAAKovB,YAAa,CAC7B,MAAMA,EAAcgX,EAAWpmC,KAAKovB,YAChB,UAAhBA,GACAgX,EAAWpmC,KAAK+nD,QAAQjJ,cAAgB,CACpC4B,EAAO,GAAG7lD,OAAO,GACjB6lD,EAAO,GAAG7lD,OAAO,GACjBurC,EAAWpmC,KAAK+nD,QAAQjJ,cAAc,IAE1C1Y,EAAWpmC,KAAK+nD,QAAQhJ,cAAgB,CACpC2B,EAAO,GAAG7lD,OAAO,GACjB6lD,EAAO,GAAG7lD,OAAO,GACjBurC,EAAWpmC,KAAK+nD,QAAQhJ,cAAc,KAGrB,YAAhB3vB,GACLgX,EAAWpmC,KAAK+nD,QAAQjJ,cAAgB,CACpC4B,EAAO,GAAG7lD,OAAO,GACjBurC,EAAWpmC,KAAK+nD,QAAQjJ,cAAc,GACtC4B,EAAO,GAAG7lD,OAAO,IAErBurC,EAAWpmC,KAAK+nD,QAAQhJ,cAAgB,CACpC2B,EAAO,GAAG7lD,OAAO,GACjBurC,EAAWpmC,KAAK+nD,QAAQhJ,cAAc,GACtC2B,EAAO,GAAG7lD,OAAO,KAGA,aAAhBu0B,IACLgX,EAAWpmC,KAAK+nD,QAAQjJ,cAAgB,CACpC1Y,EAAWpmC,KAAK+nD,QAAQjJ,cAAc,GACtC4B,EAAO,GAAG7lD,OAAO,GACjB6lD,EAAO,GAAG7lD,OAAO,IAErBurC,EAAWpmC,KAAK+nD,QAAQhJ,cAAgB,CACpC3Y,EAAWpmC,KAAK+nD,QAAQhJ,cAAc,GACtC2B,EAAO,GAAG7lD,OAAO,GACjB6lD,EAAO,GAAG7lD,OAAO,KAGzBurC,EAAWpmC,KAAK+nD,QAAQxL,WAAa,EAChCnW,EAAWpmC,KAAK+nD,QAAQjJ,cAAc,GACnC1Y,EAAWpmC,KAAK+nD,QAAQhJ,cAAc,IACtC,GACH3Y,EAAWpmC,KAAK+nD,QAAQjJ,cAAc,GACnC1Y,EAAWpmC,KAAK+nD,QAAQhJ,cAAc,IACtC,GACH3Y,EAAWpmC,KAAK+nD,QAAQjJ,cAAc,GACnC1Y,EAAWpmC,KAAK+nD,QAAQhJ,cAAc,IACtC,EAEZ,GAER,IAEAjsD,KAAKo0D,qBAAuBp0D,KAAKo0D,oBAAoBxzD,OAAS,GAC9DZ,KAAKo0D,oBAAoBnzD,QAASqyC,IAC9B,GAAIA,EAAWpmC,MACXomC,EAAWpmC,KAAK+nD,SAChB3hB,EAAWpmC,KAAKovB,YAAa,CAC7B,MAAMA,EAAcgX,EAAWpmC,KAAKovB,YAAY4+B,cAC5B,UAAhB5+B,GACAgX,EAAWpmC,KAAK+nD,QAAQjJ,cAAgB,CACpC4B,EAAO,GAAG7lD,OAAO,GACjB6lD,EAAO,GAAG7lD,OAAO,GACjBurC,EAAWpmC,KAAK+nD,QAAQjJ,cAAc,IAE1C1Y,EAAWpmC,KAAK+nD,QAAQhJ,cAAgB,CACpC2B,EAAO,GAAG7lD,OAAO,GACjB6lD,EAAO,GAAG7lD,OAAO,GACjBurC,EAAWpmC,KAAK+nD,QAAQhJ,cAAc,KAGrB,YAAhB3vB,GACLgX,EAAWpmC,KAAK+nD,QAAQjJ,cAAgB,CACpC4B,EAAO,GAAG7lD,OAAO,GACjBurC,EAAWpmC,KAAK+nD,QAAQjJ,cAAc,GACtC4B,EAAO,GAAG7lD,OAAO,IAErBurC,EAAWpmC,KAAK+nD,QAAQhJ,cAAgB,CACpC2B,EAAO,GAAG7lD,OAAO,GACjBurC,EAAWpmC,KAAK+nD,QAAQhJ,cAAc,GACtC2B,EAAO,GAAG7lD,OAAO,KAGA,aAAhBu0B,IACLgX,EAAWpmC,KAAK+nD,QAAQjJ,cAAgB,CACpC1Y,EAAWpmC,KAAK+nD,QAAQjJ,cAAc,GACtC4B,EAAO,GAAG7lD,OAAO,GACjB6lD,EAAO,GAAG7lD,OAAO,IAErBurC,EAAWpmC,KAAK+nD,QAAQhJ,cAAgB,CACpC3Y,EAAWpmC,KAAK+nD,QAAQhJ,cAAc,GACtC2B,EAAO,GAAG7lD,OAAO,GACjB6lD,EAAO,GAAG7lD,OAAO,KAGzBurC,EAAWpmC,KAAK+nD,QAAQxL,WAAa,EAChCnW,EAAWpmC,KAAK+nD,QAAQjJ,cAAc,GACnC1Y,EAAWpmC,KAAK+nD,QAAQhJ,cAAc,IACtC,GACH3Y,EAAWpmC,KAAK+nD,QAAQjJ,cAAc,GACnC1Y,EAAWpmC,KAAK+nD,QAAQhJ,cAAc,IACtC,GACH3Y,EAAWpmC,KAAK+nD,QAAQjJ,cAAc,GACnC1Y,EAAWpmC,KAAK+nD,QAAQhJ,cAAc,IACtC,EAEZ,KAGR,EAAA8K,EAAA,GAAsCpS,EAAct+C,IAAI,EAAG6oB,gBAAiBA,GAChF,CACJ,CACA,aAAAutC,CAAchT,EAAYsC,GACH,QAAfA,EACA/rD,KAAKgsD,cAAgB,IAAIvC,GAEL,QAAfsC,IACL/rD,KAAKisD,cAAgB,IAAIxC,IAE7B,MAAM9E,EAAgB3kD,KAAKwkD,qBAC3B,EAAAuS,EAAA,GAAsCpS,EAAct+C,IAAI,EAAG6oB,gBAAiBA,GAChF,CACA,gBAAAyvC,CAAiBvc,GACb,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACdz1B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACfi5D,EAAcv0D,KAAKw0D,gBAAgBl5D,GACnCsjE,EAAsB5+D,KAAKy0D,wCAAwCv4D,EAASizB,QAASolC,GAC3F,IAAKqK,GAC8B,IAA/BA,EAAoBh+D,SACnBg+D,EAAoB,GACrB,OAAO,KAEX,MAAM,KAAE1xD,GAAS0xD,EAAoB,GAC/BC,EAAkB,GAClBzJ,EAAiBloD,EAAKkoD,gBAAkB,GAC9C,IAAK,IAAI1rD,EAAI,EAAGA,EAAI0rD,EAAex0D,SAAU8I,EAAG,CAC5C,MAAMuvD,EAAgB7D,EAAe1rD,GAAG,GACX1J,KAAK45D,8BAA8BX,EAAc5vD,MAI9Ew1D,EAAgBl2D,KAAKswD,EAAc5vD,IACnCK,IACJ,CAMA,OALAwD,EAAKioD,kBAAoB,IAAI0J,GAC7B3xD,EAAK+nD,QAAQC,gBAAkBtB,GAC/BxR,EAAIoV,kBACJ,KAAAD,mBAAkBpoC,GAClBnvB,KAAKs3D,gBAAgBnoC,GACdyvC,EAAoB,EAC/B,CACA,sBAAAE,CAAuB1c,EAAK9O,EAAYyrB,EAAQ1H,GAC5Cr3D,KAAKo3D,qBAAqBhV,EAAK9O,EAAY+jB,EAC/C,CACA,kCAAA7G,CAAmC7L,GAC/BA,EAAc1jD,QAAQ,EAAGiuB,aAAYhB,wBACjC,MAAM,SAAEhyB,IAAa,IAAA4oD,wBAAuB51B,EAAYhB,IAClD,QAAEiB,GAAYjzB,EACpBizB,EAAQrE,oBAAoB,EAAA8lB,MAAA,OAAajU,2BAA4B38B,KAAKowD,eAElF,CACA,gCAAAK,CAAiC72C,GAC7BA,EAAU3Y,QAAQ,EAAGiuB,aAAYhB,wBAC7B,MAAM,SAAEhyB,IAAa,IAAA4oD,wBAAuB51B,EAAYhB,IAClD,QAAEiB,GAAYjzB,EACpBizB,EAAQ1E,iBAAiB,EAAAmmB,MAAA,OAAajU,2BAA4B38B,KAAKowD,eAE/E,CACA,yCAAA4O,CAA0CrlD,EAAiBslD,EAA8B1pD,GACrF0pD,EAA6Bh+D,QAASqyC,IAClCtzC,KAAKk/D,iCAAiCvlD,EAAiB25B,EAAY/9B,IAE3E,CACA,gCAAA2pD,CAAiCvlD,EAAiB25B,EAAY/9B,GAC1D,MAAM,KAAErI,GAASomC,EACXp3C,EAAWyd,EAAgByW,YAAYljB,EAAKgiB,YAC5C1M,EAAStmB,EAASumB,YAClB0oB,EAAS3oB,EAAOjB,gBAChB49C,EAAU,UAAY5pD,EAAO41B,GAC7Bi0B,EAAiB,IAAIj0B,GAE3B,GADA,qBAAuBi0B,EAAgBD,GACnCliE,KAAK6e,IAAIsjD,EAAe,IAAM,MAC9BniE,KAAK6e,IAAIsjD,EAAe,IAAM,MAC9BniE,KAAK6e,IAAIsjD,EAAe,IAAM,KAAM,CACpC,MAAMv9B,EAAgB,CAAC,EAAG,EAAG,GACvB1M,EAAc,CAAC,EAAG,EAAG,GAC3B,UAAY3S,EAAOG,WAAYy8C,EAAgBv9B,GAC/C,UAAYrf,EAAOoN,SAAUwvC,EAAgBjqC,GAC7Cj5B,EAAS6lC,UAAU,CACfpf,WAAYkf,EACZjS,SAAUuF,IAEdj5B,EAASD,QACb,CACJ,CACA,cAAAk7D,CAAehoC,EAASmkB,EAAY2jB,EAAcC,GAC9C,MAAM,KAAEhqD,GAASomC,EACX8hB,EAAiBloD,EAAKkoD,eACtByJ,EAAkB,GACxB,GAAIzJ,EACA,IAAK,IAAI1rD,EAAI,EAAGA,EAAI0rD,EAAex0D,SAAU8I,EAAG,CAC5C,MAAMuvD,EAAgB7D,EAAe1rD,GAAG,GAClC21D,EAASjK,EAAe1rD,GAAG,GAC3B41D,EAAOlK,EAAe1rD,GAAG,GACzB5C,EAAOsuD,EAAe1rD,GAAG,GACb,mBAA4B21D,EAAQC,EAAM,CACxDrI,EAAa,GACbA,EAAa,MAEAC,IACb2H,EAAgBl2D,KAAKswD,EAAc5vD,IACnC6D,EAAK+nD,QAAQC,gBAAkB,EAC/BhoD,EAAK+nD,QAAQ+I,WAAal3D,EAElC,CAMJ,OAJAoG,EAAKioD,kBAAoB,IAAI0J,GAC7B7+D,KAAK29D,SAAW,CACZrqB,cAEoC,IAAjCpmC,EAAK+nD,QAAQC,eACxB,EAEJrB,GAA0BjQ,SAAW,wBCjrCrC,MAAM2b,WAAwB,MAC1B,WAAA9/D,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,WAErCX,MAAMS,EAAWC,GACjBhiD,KAAKw/D,qCAAuC,CAACr6D,EAAY0C,KACrD,MAAM43D,EAAmBxiE,KAAK+Q,MAAMnG,EAAW,GAAK,GAC9C63D,EAAc73D,EAAW,GAAKA,EAAW,GAC/C,IAAI83D,EACA/4D,EACAzB,aAAsB8D,cACtB02D,EAAgB,EAChB/4D,EAAwBqC,cAEnB9D,aAAsB6D,YAC3B22D,EAAgB,EAChB/4D,EAAwBoC,YAEnB7D,aAAsB+D,aAC3By2D,EAAgB,EAChB/4D,EAAwBsC,aAEnB/D,aAAsBgE,aAC3Bw2D,EAAgB,EAChB/4D,EAAwBuC,YAE5B,MAEMy2D,EAAQ,IAAIh5D,EAFHzB,EAAWmxC,OACPmpB,EAAmBC,EAAcC,EACQD,IACtD,IAAEvwD,EAAG,IAAErR,GAAQkC,KAAK6/D,WAAWD,EAAOF,GAC5C,OAAOvwD,EAAMrR,EAErB,CACA,iBAAAqkD,CAAkBC,GACdpiD,KAAKsiD,kBAAkBF,EAC3B,CACA,iBAAAE,CAAkBF,GACd,MAAM,QAAEjzB,EAAO,YAAEo0B,GAAgBnB,EAAIrtB,OAC/Bz5B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACrB,IAAIwP,EAAU+U,EAAOC,EAAO3hB,EAAU2hE,EAAUC,EAC5CxhE,GAAc,EAClB,MAAMyhE,EAAa9jE,EAASorB,gBAC5B,GAAIprB,aAAoB,EAAAg3C,eAAgB,CACpCpoC,EAAW5O,EAASwsB,cACpBq3C,EACI,EAAA/uB,UAAA,yBAAmClmC,KACpC+U,QAAOC,SAAUkgD,EAAWpgD,UAC/B,MAAMuG,EAAS,EAAAmN,MAAMxM,UAAUhc,GAC/B,IAAKqb,EACD,MAAM,IAAI/nB,MAAM,oBAAsB0M,GAE1C3M,EAAWgoB,EAAOjf,SAAS6gC,SAC3BxpC,EAAc4nB,EAAO85C,SAAWrgE,OAAO4B,KAAK2kB,EAAO85C,SAASr/D,OAAS,CACzE,KACK,KAAIo/D,EAAWpgD,SAQhB,MAAM,IAAIxhB,MAAM,gCARU,CAC1BD,EAAWjC,EAASiC,WACjB0hB,QAAOC,SAAUkgD,EAAWpgD,UAC/B,MAAM,SAAE6O,EAAW,CAAEC,QAAQ,IAAYxyB,EAASq8B,kBAAoB,CAAC,EACvEh6B,EACIkwB,EAASC,aAAgD1wB,IAAtCywB,EAASnL,mBAAmBI,KACvD,CAGA,CAEIo8C,EAnED,OAkEC3hE,GAAmBI,EACRyB,KAAKkgE,oBAAoB,CAChC1d,kBAAmBe,EAAY9nD,OAC/BokB,QACAC,QACAumC,aAAcl3B,EAAQk3B,aACtB9nD,cACArC,WACA4O,aAIO9K,KAAKmgE,YAAY,CACxBjkE,WACAsmD,kBAAmBe,EAAY9nD,OAC/BqP,WACA+U,QACAC,UAGJggD,EAASjgD,OAASigD,EAAShgD,QAG/B5jB,EAASi2B,cAAc,CACnBvS,SAAUkgD,IAEd5jE,EAASD,SACLC,aAAoB,EAAAg3C,gBACpB6sB,EAA6B9+D,QAAS0mB,IAC9BzrB,IAAayrB,GACbA,EAAG1rB,WAKnB,CACA,mBAAAikE,EAAoB,kBAAE1d,EAAiB,MAAE3iC,EAAK,MAAEC,EAAK,aAAEumC,EAAY,SAAEnqD,EAAQ,SAAE4O,EAAQ,YAAEvM,IACrF,IAAI6hE,EAzGe,EA2GfA,EADA7hE,EACa,EAAI8nD,EAIbrmD,KAAKqgE,+BAA+BnkE,EAAU4O,IA/GnC,EAsHnB,OAFAgV,GAFe0iC,EAAkB,GACR4d,EAGlB,CAAEvgD,QAAOC,MADhBA,EAAQvhB,EAActB,KAAKkS,IAAI2Q,EAAO,IAAOA,EAEjD,CACA,WAAAqgD,EAAY,SAAEjkE,EAAQ,kBAAEsmD,EAAiB,SAAE13C,EAAQ,MAAE+U,EAAK,MAAEC,IACxD,MAAMsgD,EAAapgE,KAAKqgE,+BAA+BnkE,EAAU4O,IAzH9C,EA2Hbw1D,EAAU9d,EAAkB,GAAK4d,EACjCG,EAAU/d,EAAkB,GAAK4d,EACvC,IAAI,YAAE5hE,EAAW,aAAEC,GAAiB,EAAAuyC,UAAA,0BAAoCnxB,EAAOC,GAC/EthB,GAAe8hE,EACf7hE,GAAgB8hE,EAChB/hE,EAAcvB,KAAKkS,IAAI3Q,EAAa,GACpC,MAAMgiE,EAAiBtkE,EAASorB,gBAAgBgjB,eAChD,OAAO,EAAA0G,UAAA,2BAAqCxyC,EAAaC,EAAc+hE,EAC3E,CACA,8BAAAH,CAA+BnkE,EAAU4O,GACrC,IAAI21D,EACJ,GAAI31D,EAAU,CACV,MAAMuW,EAAc,EAAAiS,MAAMxM,UAAUhc,IAC9B,aAAE9F,GAAiB9I,EAASq8B,eAE5BmoC,EADuB17D,EAAa27D,qBACUhgC,OAAO,CAACigC,EAAKC,IACtD,CAAC5jE,KAAKa,IAAI8iE,EAAI,GAAIC,GAAQ5jE,KAAKkS,IAAIyxD,EAAI,GAAIC,IACnD,CAAClqD,KAAWA,MACTmzB,EAAazoB,GAAana,UAAU4iC,WACpCg3B,EAAuBh3B,EAAa,GAAKA,EAAanzB,IACtDoqD,EAAkBL,EAAuB,GAAKA,EAAuB,GAC3ED,EAAqBz0D,OAAO88B,SAASi4B,GAE/B9jE,KAAKa,IAAIijE,EAAiBD,GAD1BA,CAEV,MAEIL,EAAoBzgE,KAAKghE,kCAAkC9kE,GAE/D,MAAMy9B,EAAQ8mC,EAtJc,KAuJ5B,OAAQz0D,OAAO88B,SAASnP,GAElBA,EAAQ,EACJ18B,KAAKgmB,MAAM0W,GACXA,EA3JkB,IA4JhC,CACA,iCAAAqnC,CAAkC9kE,GAC9B,MAAM,UAAEyoB,EAAS,aAAE3f,GAAiB9I,EAASq8B,eAC7C,GAAIvzB,GAAcma,SAAU,CACxB,MAAMrT,EAAQ9G,EAAama,WAC3B,OAAOrT,EAAM,GAAKA,EAAM,EAC5B,CACA,MAAMjE,EAAa8c,EAAUM,gBAC7B,GAAIN,EAAUxF,SAAU,CACpB,MAAM8hD,EAAiBt8C,EAAUxF,WACjC,OAAO8hD,EAAe,GAAKA,EAAe,EAC9C,CACA,IAAI97D,EAUA2G,EAHJ,GALI3G,EADAwf,EAAUtf,cACGsf,EAAUtf,gBAGVsf,EAAUsoB,eAAeC,aAAaC,UAEjC,IAAlBtlC,EAAW,GACX,OAAO7H,KAAKw/D,qCAAqCr6D,EAAY0C,GAGjE,GAAI1C,EAAWga,SACXrT,EAAQ3G,EAAWga,eAElB,CACD,MAAM,IAAErhB,EAAG,IAAEqR,GAAQnP,KAAK6/D,WAAW16D,EAAYA,EAAWvE,QAC5DkL,EAAQ,CAAChO,EAAKqR,EAClB,CACA,OAAOrD,EAAM,GAAKA,EAAM,EAC5B,CACA,UAAA+zD,CAAWD,EAAOF,GACd,IAAI5hE,EAAM6Y,IACNxH,GAAOwH,IACX,IAAK,IAAIjN,EAAI,EAAGA,EAAIg2D,EAAah2D,IAAK,CAClC,MAAMw3D,EAAQtB,EAAMl2D,GAChBw3D,EAAQpjE,IACRA,EAAMojE,GAENA,EAAQ/xD,IACRA,EAAM+xD,EAEd,CACA,MAAO,CAAE/xD,MAAKrR,MAClB,EAEJyhE,GAAgB3b,SAAW,cCnM3B,MAAMud,WAA8B,MAChC,WAAA1hE,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX20D,eAAgB,MAGpB9f,MAAMS,EAAWC,GACjBhiD,KAAK2+D,iBAAoBvc,IACrB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,MACzBnoD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACrB0E,KAAKqhE,WAAY,EACjB,MAAM7+C,EAAStmB,EAASumB,aAClB,gBAAElB,EAAe,OAAEyjB,GAAWxiB,EAC9Bjc,EAAoBvG,KAAKshE,qBAAqBplE,EAAUolB,EAAUC,EAAiByjB,GACnFh7B,EAAsB9N,EAASqlE,yBAC/BjuB,EAAa,CACf/3C,aAAa,EACbs5D,aAAa,EACb3tD,SAAU,CACN08C,SAAU5jD,KAAKg1D,cACfzzC,gBAAiB,IAAIA,GACrByjB,OAAQ,IAAIA,GACZh7B,sBACAzD,qBAEJ2G,KAAM,CACF+nD,QAAS,CACLxmD,OAAQ,CACJ,IAAI6S,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,KAGZkgD,YAAa,CAAC,KAGtB,QAAcluB,EAAYnkB,GAC1B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eASzE,OARAh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,uBAEJ79D,KAAKyhE,cAActyC,IACnB,KAAAooC,mBAAkBpoC,GAClBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GAC/BvqB,GAEXtzC,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,GAAwB79D,KAAK29D,SACjD39D,KAAK0hE,gBAAgBvyC,IACrB,KAAAyuC,oBAAmBzuC,GACnBnvB,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,GACjB,QAAiB/tB,EAAWqhB,gBAC5B,EAAAoC,EAAA,GAAsC8G,IACtC,KAAA8D,4BAA2BruB,GAC3BtzC,KAAK4hE,uBAAuBtuB,EAAYnkB,IAE5CnvB,KAAKqiD,cAAiBD,IAClBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,GAAwB79D,KAAK29D,UAC3C,KAAEzwD,GAASomC,GACX,cAAE0S,GAAkBj1B,EACpBz1B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,cAAEg0B,EAAa,cAAE/xB,GAAkB91B,EAAeY,SAClDolB,EAAW0kC,EAAcvC,OACzB,OAAEh1C,GAAWvB,EAAK+nD,QAExBxmD,EAD6B,GACE,IAAI6S,GACnC,MAAMwY,EAAmBqpB,EAAc10C,EAAO,IACxCmrB,EAAiBupB,EAAc10C,EAAO,IACtCorB,EAAoB,CACtBD,EAAe,GACfE,EAAiB,IAEf+nC,EAAgB,CAClB/nC,EAAiB,GACjBF,EAAe,IAEbK,EAAmB7I,EAAcyI,GACjCE,EAAe3I,EAAcywC,GACnCpzD,EAAO,GAAKwrB,EACZxrB,EAAO,GAAKsrB,EACZuZ,EAAW/3C,aAAc,GACzB,EAAAw7D,EAAA,GAAsC8G,IAE1C79D,KAAKyhE,cAAiBtyC,IAClB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK0hE,gBAAmBvyC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACpB,IAAIq4D,GAAc,QAAev0D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAGX,GADAnE,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAAO83D,EAEX,MAAMqJ,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6qD,EAAY3zD,OAAQ8I,IAAK,CACzC,MAAM4pC,EAAaihB,EAAY7qD,IACzB,cAAEirD,EAAa,KAAEznD,GAASomC,GAC1B,OAAE7kC,GAAWvB,EAAK+nD,QAClB+M,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IACnEqzD,EAAepN,cAAgBA,EAC/B,MAAM,MAAEv4D,EAAK,UAAE83D,EAAS,SAAE0H,GAAa57D,KAAKiiE,mBAAmB,CAC3D3uB,aACAyuB,mBAEJ,IAAK7lE,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,MAAMwJ,EAAS,GAAGvN,SACZwN,EAAe,KACrB,IAAAC,UAAYnK,EAAkBtD,EAAewN,EAAcH,EAAkB,GAAIA,EAAkB,GAAI,CACnG5lE,QACAw/D,WACA1H,aACDgO,GACHxJ,GAAe,CACnB,CACA,OAAOA,GAEX14D,KAAK4hE,uBAAyB,CAACtuB,EAAYnkB,KACvC,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACfqpB,EAAY,EAA6CzoB,IACzD,KAAEgR,GAASomC,GACX,OAAE7kC,GAAWvB,EAAK+nD,QAClB+M,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAC7D2zD,EAAcL,EAAkB,GAChCM,EAAYN,EAAkB,GACpC,IAAIO,EAAOtlE,KAAKa,IAAIukE,EAAY,GAAIC,EAAU,IAC1C3tD,EAAM1X,KAAKa,IAAIukE,EAAY,GAAIC,EAAU,IACzC1lE,EAAQK,KAAK6e,IAAIumD,EAAY,GAAKC,EAAU,IAC5CzlE,EAASI,KAAK6e,IAAIumD,EAAY,GAAKC,EAAU,IACjDC,EAAO,EAAAvxB,UAAA,KAAeuxB,EAAM,EAAG59C,EAAU/nB,OACzC+X,EAAM,EAAAq8B,UAAA,KAAer8B,EAAK,EAAGgQ,EAAU9nB,QACvCD,EAAQK,KAAK+Q,MAAM/Q,KAAKa,IAAIlB,EAAOK,KAAK6e,IAAI6I,EAAU/nB,MAAQ2lE,KAC9D1lE,EAASI,KAAK+Q,MAAM/Q,KAAKa,IAAIjB,EAAQI,KAAK6e,IAAI6I,EAAU9nB,OAAS8X,KACjE,MAAM6tD,EC1LlB,SAAgC79C,EAAWrnB,EAAGE,EAAGZ,EAAOC,GACpD,MAAM4lE,EAAY,GAClB,IAAIj6D,EAAQ,EACZ,MAAMjD,EAAYof,EAAUxf,WAC5B,IAAIu9D,EAASrxD,EAAKsxD,EAClB,GAAIh+C,EAAUvoB,MACV,IAAKiV,EAAM,EAAGA,EAAMxU,EAAQwU,IACxB,IAAKsxD,EAAS,EAAGA,EAAS/lE,EAAO+lE,IAAU,CACvCD,EAA2D,IAA/CrxD,EAAM7T,GAAKmnB,EAAU3lB,SAAW2jE,EAASrlE,IACrD,MAAMslE,EAAMr9D,EAAUm9D,GAChBG,EAAQt9D,EAAUm9D,EAAU,GAC5BI,EAAOv9D,EAAUm9D,EAAU,GACjCD,EAAUj6D,KAAW,MAASo6D,EAAM,MAASC,EAAQ,MAASC,CAClE,MAIJ,IAAKzxD,EAAM,EAAGA,EAAMxU,EAAQwU,IACxB,IAAKsxD,EAAS,EAAGA,EAAS/lE,EAAO+lE,IAC7BD,GAAWrxD,EAAM7T,GAAKmnB,EAAU3lB,SAAW2jE,EAASrlE,GACpDmlE,EAAUj6D,KAAWjD,EAAUm9D,GAI3C,OAAOD,CACX,CDiKuC,CAAmC99C,EAAW1nB,KAAKgmB,MAAMs/C,GAAOtlE,KAAKgmB,MAAMtO,GAAM/X,EAAOC,GAC7GkmE,EE3LlB,SAA6BC,EAAgBC,EAAWC,GACpD,MAAMn2C,EAAYi2C,EAAepiE,OACjC,IAAI9C,EAAMolE,EACN/zD,EAAM8zD,EACN3uD,EAAM,EACV,GAAIyY,EAAY,EACZ,MAAO,CACHjvB,MACAqR,MACA+2B,MAAO+8B,EAAYC,GAAa,GAGxC,IAAK,IAAI16D,EAAQ,EAAGA,EAAQukB,EAAWvkB,IAAS,CAC5C,MAAM26D,EAAMH,EAAex6D,GAC3B1K,EAAMb,KAAKa,IAAIA,EAAKqlE,GACpBh0D,EAAMlS,KAAKkS,IAAIA,EAAKg0D,GACpB7uD,GAAO6uD,CACX,CACA,MAAO,CACHrlE,MACAqR,MACA+2B,KAAM5xB,EAAMyY,EAEpB,CFoK+B,CAAgCy1C,EAAoB79C,EAAUnb,cAAemb,EAAUlb,oBAChEzL,IAAtCgC,KAAKyM,cAAc20D,iBACnBphE,KAAKyM,cAAc20D,eAAiB,IAExC,MAAM5iE,EAAcvB,KAAKkS,IAAIlS,KAAK6e,IAAIinD,EAAW5zD,IAAM4zD,EAAWjlE,KAAMkC,KAAKyM,cAAc20D,gBACrF3iE,EAAeskE,EAAW78B,KAC1Bs6B,EAAiBtkE,EAASorB,gBAAgBgjB,eAC1C1qB,EAAW,EAAAoxB,UAAA,2BAAqCxyC,EAAaC,EAAc+hE,GACjFtkE,EAASi2B,cAAc,CAAEvS,aACzB1jB,EAASD,UAEb+D,KAAKiL,OAAS,IACH,KAEXjL,KAAKg3D,gBAAkB,IACZ,KAEXh3D,KAAKo3D,qBAAuB,IACjB,KAEXp3D,KAAK8+D,uBAAyB,IACnB,KAEX9+D,KAAKs3D,gBAAkB,IACZ,KAEXt3D,KAAK09D,kBAAoB,IACd,IAEf,EAEJyD,GAAsBvd,SAAW,oBGxNjC,MAAMwf,WAAwB,MAC1B,WAAA3jE,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX7N,QAAQ,EACRykE,qBAAqB,EACrBzgC,MAAM,KAGV0e,MAAMS,EAAWC,GACjBhiD,KAAKsjE,OAAS,CAClB,CACA,kBAAAC,CAAmBnhB,GACfpiD,KAAKwjE,QAAQphB,EACjB,CACA,iBAAAE,CAAkBF,GACdpiD,KAAKqiD,cAAcD,EACvB,CACA,iBAAAD,CAAkBC,GACdpiD,KAAKqiD,cAAcD,EACvB,CACA,aAAAC,CAAcD,GACVpiD,KAAKyjE,YAAYrhB,EACrB,CACA,WAAAqhB,CAAYrhB,GACR,MAAM,YAAEmB,EAAW,WAAEr0B,EAAU,kBAAEhB,GAAsBk0B,EAAIrtB,QACrD,SAAE74B,IAAa,IAAA4oD,wBAAuB51B,EAAYhB,IAClD,oBAAEm1C,EAAmB,OAAEzkE,EAAM,KAAEgkC,GAAS5iC,KAAKyM,cAC7Ci3D,EAAcngB,EAAY9nD,OAAO,GACvC,IAAIqP,EACA5O,aAAoB,EAAAg3C,iBACpBpoC,EAAW5O,EAASwsB,eAExB,MAAMi7C,EAAiB3jE,KAAK4jE,kBAAkB1nE,GACxConE,EAASI,EAAc1jE,KAAKsjE,OAClC,GAAKK,EAGL,GAAI1mE,KAAK6e,IAAIwnD,IAAWK,EAAgB,CACpC,MAAME,EAAqB5mE,KAAKgmB,MAAMqgD,EAASK,GAC/C,EAAA3yB,UAAA,OAAiB90C,EAAU,CACvBqZ,MAAO3W,GAAUilE,EAAqBA,EACtC/4D,WACA63B,gBAAiB0gC,EACjBzgC,KAAMA,IAEV5iC,KAAKsjE,OAASA,EAASK,CAC3B,MAEI3jE,KAAKsjE,OAASA,CAEtB,CACA,OAAAE,CAAQphB,GACJ,MAAM,MAAE0hB,EAAK,QAAE30C,GAAYizB,EAAIrtB,QACzB,UAAE9sB,GAAc67D,GAChB,OAAEllE,GAAWoB,KAAKyM,eAClB,SAAEvQ,IAAa,IAAA6+B,mBAAkB5L,GACjC5Z,EAAQtN,GAAarJ,GAAU,EAAI,GACzC,EAAAoyC,UAAA,OAAiB90C,EAAU,CACvBqZ,QACAotB,gBAAiB3iC,KAAKyM,cAAc42D,oBACpCzgC,KAAM5iC,KAAKyM,cAAcm2B,KACzB93B,SAAU5O,aAAoB,EAAA6nE,mBACxB7nE,EAASwsB,mBACT1qB,EACN2jC,YAAa3hC,KAAKyM,cAAck1B,aAExC,CACA,iBAAAiiC,CAAkB1nE,GACd,MAAM,QAAEizB,GAAYjzB,EACd8mB,EAAiB9mB,EAAS8mC,oBAChC,OAAO/lC,KAAKkS,IAAI,EAAGggB,EAAQ60C,aAAe/mE,KAAKkS,IAAI6T,EAAgB,GACvE,EAEJogD,GAAgBxf,SAAW,c,gBCxE3B,MAAMqgB,WAAyB,MAC3B,WAAAxkE,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,WAErCX,MAAMS,EAAWC,GACjBhiD,KAAKujE,mBAAsBnhB,IACvB,MAAM,QAAEjzB,EAAO,MAAE20C,GAAU1hB,EAAIrtB,OACzBz5B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,OAAEsD,GAAWoB,KAAKyM,cAClB3P,EAA0B,GAAlBgnE,EAAM77D,WAAkBrJ,GAAU,EAAI,GACpDoB,KAAKkkE,SAAShoE,EAAUY,IAE5BkD,KAAKmiD,kBAAoBniD,KAAKqiD,cAAc7xC,KAAKxQ,MACjDA,KAAKsiD,kBAAoBtiD,KAAKqiD,cAAc7xC,KAAKxQ,KACrD,CACA,aAAAqiD,CAAcD,GACV,MAAM,QAAEjzB,EAAO,cAAE62B,EAAa,YAAEme,GAAgB/hB,EAAIrtB,OAC9CqvC,EAAoBpe,EAAcvC,MAClC4gB,EAAkBF,EAAY1gB,MAC9BnoD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACfknB,EAAStmB,EAASumB,YAGlB6hD,EAAe,CAAS,GAFhBn1C,EAAQi3B,YAEsB,GAD7Bj3B,EAAQk3B,cAEjBb,EAActpD,EAASk1B,cAAckzC,GAC3C,IAAIxnE,GAAQ,EAAAynE,GAAA,GAAkB,CAACF,EAAiB7e,GAAc,CAACA,EAAa4e,IAC5E,MAAM,gBAAE7iD,GAAoBiB,EACtBqL,EAAK,SAAS,cAAe23B,EAAa6e,GAC1Cv2C,EAAK,SAAS,cAAe03B,EAAa4e,GAC1CI,EAAQ,WAAW,cAAe32C,EAAIC,GACxC,SAASvM,EAAiBijD,GAAS,IACnC1nE,GAASA,GAETkP,OAAOwQ,MAAM1f,IAGjBkD,KAAKkkE,SAAShoE,EAAUY,EAC5B,CACA,QAAAonE,CAAShoE,EAAUY,GACf,MAAM,gBAAEykB,EAAe,OAAEyjB,GAAW9oC,EAASumB,YAC7C,GAAIvmB,aAAoB,EAAA6nE,mBAAoB,CACxC,MAAMU,GAAc3nE,EAAQ,KAAO,IAAOG,KAAKC,GAAM,IAC/CwnE,EAAS,cAAc,IAAIz7D,aAAa,KAC9C,YAAYy7D,EAAQA,EAAQD,EAAUljD,GACtC,MAAMojD,EAAgB,mBAAmB,cAAe3/B,EAAQ0/B,GAChExoE,EAAS6lC,UAAU,CAAEiD,OAAQ2/B,GACjC,KACK,CACD,MAAM,SAAE5nE,GAAab,EAASggC,sBAC9BhgC,EAAS0gC,oBAAoB,CACzB7/B,UAAWA,EAAWD,EAAQ,KAAO,KAE7C,CACAZ,EAASD,QACb,EAEJgoE,GAAiBrgB,SAAW,eCxD5B,MAAMghB,WAAiB,MACnB,WAAAnlE,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXo4D,cAAc,EACdC,aAAc,KACdC,aAAc,IACdC,aAAa,EACbC,KAAK,EACLrmE,QAAQ,KAGZ0iD,MAAMS,EAAWC,GACjBhiD,KAAKkkD,qBAAwB9B,IACzB,MAAM5f,EAAY4f,EAAIrtB,QAChB,QAAE5F,EAAO,cAAE62B,GAAkBxjB,EAC7BlhB,EAAW0kC,EAAcvC,MAEzBjhC,GADiB,IAAAuY,mBAAkB5L,GACXjzB,SAASumB,aACjC,WAAEE,GAAeH,EACvBxiB,KAAKklE,qBAAuB5jD,EAC5B,IAAI6jD,EAAS,gBAAgBxiD,EAAW,GAAKrB,EAAS,GAAIqB,EAAW,GAAKrB,EAAS,GAAIqB,EAAW,GAAKrB,EAAS,IAGhH,OAFA6jD,EAAS,eAAe,cAAeA,GACvCnlE,KAAKmlE,OAASA,GACP,GAEXnlE,KAAKolE,sBAAyBhjB,IAC1B,IAAKpiD,KAAKyM,cAAcu4D,YACpB,OAAOhlE,KAAKkkD,qBAAqB9B,IAGzCpiD,KAAKqlE,wBAA0B,CAACjjB,EAAKlmD,EAAUsmB,EAAQ8iD,GAAQ,KAC3D,MAAM,QAAEn2C,EAAO,YAAEo0B,GAAgBnB,EAAIrtB,OAC/BuuC,EAASgC,EACTljB,EAAIrtB,OAAOwwC,cAAc9pE,OACzB8nD,EAAY9nD,OAAO,GACnB+uB,EAAO,CAAC2E,EAAQi3B,YAAaj3B,EAAQk3B,eACrC,cAAEmf,EAAa,WAAE7iD,EAAU,SAAEiN,GAAapN,EAE1CnQ,EAAIixD,GADQ,EAAI94C,EAAK,KACKxqB,KAAKyM,cAAc7N,QAAU,EAAI,GAC3D6mE,GAAsB,EAAMpzD,GAAKmzD,EACvC,IAAIE,EAAkB/iD,EAClBgjD,EAAgB/1C,EACpB,IAAK5vB,KAAKyM,cAAco4D,aAAc,CAClC,MAAMe,EAAyB,cAAcjjD,EAAY3iB,KAAKklE,sBAC9DS,EAAgB,iBAAiB,cAAe/1C,EAAU5vB,KAAKmlE,QAASS,EAAyBvzD,GACjGqzD,EAAkB,iBAAiB,cAAe/iD,EAAY3iB,KAAKmlE,QAASS,EAAyBvzD,EACzG,CACA,MAAMsS,EAAYzoB,EAASq8B,eAC3B,IAAIzwB,EAAU,CAAC,EAAG,EAAG,GACjB+9D,EAAsBJ,EACtBK,GAAoB,EACxB,GAAInhD,EAAW,CACX7c,EAAU6c,EAAU7c,QACpB,MAAM,WAAED,GAAe8c,EACjBohD,EAAal+D,EAAW,GAAKC,EAAQ,GACrCk+D,EAAcn+D,EAAW,GAAKC,EAAQ,GACtCm+D,EAAez7C,EAAK,GAAKA,EAAK,GAC9B07C,GAAuB,IAAAC,oBAAmB5pD,WAC1C6pD,mBACA,IACA,EACAt3C,EAAc5yB,EAASkI,SAAS0qB,YAGhCu3C,EAAmBN,GAFDj3C,GAAaC,YAAY,IAAMm3C,GAGjDI,EAAoBN,GAFFl3C,GAAaC,YAAY,IAAMm3C,GAIvD,IAAIK,EAEAA,EAHsBF,EAAmBC,EAErBL,EACQI,EAAmBJ,EAAgB,GAGhB,GAApBK,EAE/B,MAAM,aAAExB,EAAY,aAAEC,GAAiB/kE,KAAKyM,cACtC+5D,EAAkBD,EAA2BxB,EAC7C0B,EAAkBF,EAA2BzB,EAC/CW,EAAqBe,GACrBX,EAAsBW,EACtBV,GAAoB,GAEfL,EAAqBgB,IAC1BZ,EAAsBY,EACtBX,GAAoB,EAE5B,CACA5pE,EAAS6lC,UAAU,CACfyjC,cAAeK,EACfljD,WAAYmjD,EAAoBnjD,EAAa+iD,EAC7C91C,SAAUk2C,EAAoBl2C,EAAW+1C,KAGjD3lE,KAAK0mE,2BAA6B,CAACtkB,EAAKlmD,EAAUsmB,EAAQ8iD,GAAQ,KAC9D,MAAM,QAAEn2C,EAAO,YAAEo0B,GAAgBnB,EAAIrtB,OAC/BuuC,EAASgC,EACTljB,EAAIrtB,OAAOwwC,cAAc9pE,OACzB8nD,EAAY9nD,OAAO,GACnB+uB,EAAO,CAAC2E,EAAQi3B,YAAaj3B,EAAQk3B,eACrC,SAAEz2B,EAAQ,WAAEjN,EAAU,gBAAEpB,GAAoBiB,EAC5CxG,EAAW,6BAA+B4T,EAAUjN,GACpDgkD,EAAY1pE,KAAKopC,KAAKrqB,GAAYwO,EAAK,GACvCo8C,EAAwB,EACzBrlD,EAAgB,IAChBA,EAAgB,IAChBA,EAAgB,IAEflP,EAAIrS,KAAKyM,cAAc7N,OACvB0kE,EAASqD,EACTrD,EAASqD,EACf,IAAIE,EAAMx0D,EAAIu0D,EAAsB,GACpCh3C,EAAS,IAAMi3C,EACflkD,EAAW,IAAMkkD,EACjBA,EAAMx0D,EAAIu0D,EAAsB,GAChCh3C,EAAS,IAAMi3C,EACflkD,EAAW,IAAMkkD,EACjBA,EAAMx0D,EAAIu0D,EAAsB,GAChCh3C,EAAS,IAAMi3C,EACflkD,EAAW,IAAMkkD,EACjB3qE,EAAS6lC,UAAU,CAAEnS,WAAUjN,gBAEnC3iB,KAAKklE,qBAAuB,CAAC,EAAG,EAAG,GACnCllE,KAAKmlE,OAAS,CAAC,EAAG,EAAG,GACjBnlE,KAAKyM,cAAcu4D,YACnBhlE,KAAKmiD,kBAAoBniD,KAAK8mE,eAAet2D,KAAKxQ,MAGlDA,KAAKmiD,kBAAoBniD,KAAKqiD,cAAc7xC,KAAKxQ,MAErDA,KAAKsiD,kBAAoBtiD,KAAKqiD,cAAc7xC,KAAKxQ,KACrD,CACA,kBAAAujE,CAAmBnhB,GACfpiD,KAAK+mE,MAAM3kB,EACf,CACA,cAAA0kB,CAAe1kB,GAGX,GAFmBA,EAAIrtB,OAClBiyC,kBACUpmE,OAAS,EAAG,CACvB,MAAM,QAAEuuB,EAAO,cAAE62B,GAAkB5D,EAAIrtB,OACjCz5B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACfknB,EAAStmB,EAASumB,YAClBnB,EAAW0kC,EAAcvC,OACzB,WAAE9gC,GAAeH,EACvBxiB,KAAKklE,qBAAuB5jD,EAC5B,IAAI6jD,EAAS,gBAAgBxiD,EAAW,GAAKrB,EAAS,GAAIqB,EAAW,GAAKrB,EAAS,GAAIqB,EAAW,GAAKrB,EAAS,IAChH6jD,EAAS,eAAe,cAAeA,GACvCnlE,KAAKmlE,OAASA,EACV3iD,EAAOykD,mBACPjnE,KAAKqlE,wBAAwBjjB,EAAKlmD,EAAUsmB,GAAQ,GAGpDxiB,KAAK0mE,2BAA2BtkB,EAAKlmD,EAAUsmB,GAAQ,GAE3DtmB,EAASD,QACb,CACI+D,KAAKyM,cAAcw4D,KACnBjlE,KAAKknE,aAAa9kB,EAE1B,CACA,aAAAC,CAAcD,GACV,MAAM,QAAEjzB,GAAYizB,EAAIrtB,OAClBz5B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACfknB,EAAStmB,EAASumB,YACpBD,EAAOykD,mBACPjnE,KAAKqlE,wBAAwBjjB,EAAKlmD,EAAUsmB,GAG5CxiB,KAAK0mE,2BAA2BtkB,EAAKlmD,EAAUsmB,GAEnDtmB,EAASD,QACb,CACA,KAAA8qE,CAAM3kB,GACF,MAAM,QAAEjzB,EAAO,OAAE1gB,GAAW2zC,EAAIrtB,OAC1Bz5B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EAGf2M,GAFS/L,EAASumB,YACN2/B,EAAIrtB,OAAO+uC,MACD77D,WACtBk/D,EAAe,CACjBpyC,OAAQ,CACJ5F,UACAi4C,UAAW,EAAA31C,OAAO41C,YAClBn5C,kBAAmB5yB,EAAe4yB,kBAClCgB,WAAYhzB,EAASmN,GACrBmZ,OAAQ,CAAC,EACT+gC,YAAa,CACT+jB,KAAM74D,EAAO64D,KACbC,OAAQ94D,EAAO84D,OACf9jB,MAAOh1C,EAAOg1C,MACdhoD,OAAQ,CAAC,EAAgB,GAAZwM,IAEjBk8D,YAAa11D,EACbw3C,WAAYx3C,EACZu3C,cAAev3C,IAGnBvS,EAAS4K,OAAS,EAAA8pC,MAAA,aAAmBpgB,OACrCxwB,KAAKkkD,qBAAqBijB,GAE9BnnE,KAAKqiD,cAAc8kB,EACvB,CACA,YAAAD,CAAa9kB,GACT,MAAM,QAAEjzB,EAAO,YAAEo0B,GAAgBnB,EAAIrtB,OAC/Bz5B,GAAiB,IAAAy/B,mBAAkB5L,GACnCq0B,EAAmBD,EAAYE,MAC/BjhC,EAASlnB,EAAeY,SAASumB,aACjC,WAAEE,EAAU,SAAEiN,GAAapN,EAC3BkhC,EAAkB,CACpB9zB,EAAS,GAAK4zB,EAAiB,GAC/B5zB,EAAS,GAAK4zB,EAAiB,GAC/B5zB,EAAS,GAAK4zB,EAAiB,IAE7BG,EAAoB,CACtBhhC,EAAW,GAAK6gC,EAAiB,GACjC7gC,EAAW,GAAK6gC,EAAiB,GACjC7gC,EAAW,GAAK6gC,EAAiB,IAErCloD,EAAeY,SAAS6lC,UAAU,CAC9Bpf,WAAYghC,EACZ/zB,SAAU8zB,IAEdpoD,EAAeY,SAASD,QAC5B,EAEJ2oE,GAAShhB,SAAW,OCnOpB,MAAM4jB,WAA2B,MAC7B,WAAA/nE,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXg7D,kBAAmB,MAGvBnmB,MAAMS,EAAWC,EACrB,CACA,kBAAA0lB,CAAmBtlB,GACf,MAAM,QAAEjzB,EAAO,cAAE62B,GAAkB5D,EAAIrtB,OACjCz5B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,EAAQ,gBAAEyd,GAAoBre,EAChCwP,EAAW5O,EAASwsB,cAC1B,IAAK5d,EACD,MAAM,IAAI1M,MAAM,0HAEpB,IAAIupE,GAAgBhxD,IACpB,MAMMixD,GAAiB,IAAAC,mCAAkC3rE,EAAU8pD,EAAcvC,MAAO34C,EAN1E,CAACg9D,EAAWx5D,KACtB,GAAIw5D,EAAYH,EAEZ,OADAA,EAAeG,EACRx5D,IAIf,IAAKs5D,IAAmBA,EAAehnE,OACnC,OAEJ,MAAM,kBAAE6mE,EAAiB,YAAE/iB,GAAgB1kD,KAAKyM,cAC9BkN,EAAgByc,eAAethB,OAAQ6S,IACrD,GAAI8/C,GAAmBzkE,QAAQ2kB,EAAGte,KAAO,EACrC,OAAO,EAEX,MAAM0+D,GAAiB,IAAAC,yBAAwBrgD,EAAGte,GAAIsQ,EAAgBtQ,IACtE,SAAIq7C,GAAeA,IAAgBqjB,GAAgB1+D,MAK7CpI,QAAS/E,IACXA,aAAoB,EAAAg3C,eACpBh3C,EAAS+rE,YAAYL,GAGrBx3D,QAAQC,KAAK,2FAGzB,EAEJm3D,GAAmB5jB,SAAW,qB,gBCrC9B,MAAQ4P,mBAAkB,IAAK,EAAAC,UAC/B,SAAS,KACL,MAAO,gBACX,CACA,SAAS,KACL,OAAO,CACX,CACA,SAASyU,KACL,OAAO,CACX,CACA,SAASC,KACL,OAAO,CACX,CACA,MAAM,GACI,EADJ,GAEM,EAFN,GAGI,EAEV,MAAMC,WAAuB,MACzB,WAAA3oE,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,SAC5Bx1C,cAAe,CACX47D,QAAQ,EACRvU,oBAAoB,EACpBC,yBAA0B,CACtBruB,OAAQ,EACRpoC,EAAG,KACHE,EAAG,MAEP8qE,QAAS,CACLxf,SAAS,EACTyf,QAAS,IAEbC,aAAc,EACdC,mBAAmB,EACnBC,8BAA+B,GAC/BC,6BAA8B,KAC9BC,kCAAmC,GACnCC,uBAAwB,EAAAj4B,MAAA,WAAiBk4B,wBACzCC,YAAa,CACTjgB,SAAS,EACT1sD,MAAO,yBACPouB,KAAM,GAEVq+B,OAAQ,CACJC,SAAS,EACTjxC,QAAS,GACT2wD,aAAc,EACdG,6BAA8B,QAItCrnB,MAAMS,EAAWC,GACjBhiD,KAAKypD,WAAa,CAAC,EAAG,EAAG,GACzBzpD,KAAKq0D,mBAAqB,EAAGnmC,oBAAmBgB,iBAC5C,MAAM5zB,GAAiB,IAAAwpD,wBAAuB51B,EAAYhB,GAC1D,IAAK5yB,EACD,OAEJ,MAAM,oBAAE0O,EAAmB,SAAE9N,GAAaZ,GACpC,QAAE6zB,GAAYjzB,GACd,SAAE0zB,EAAQ,WAAEjN,EAAU,gBAAEpB,GAAoBrlB,EAASumB,YAC3D,IAAI8xC,EAAcv0D,KAAKw0D,gBAAgBl5D,GACvCi5D,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,GAChEA,GAAa3zD,SACb,IAAA8zD,kBAAiBH,EAAY,GAAGI,eAEpC,MAAMrhB,EAAa,CACfuhB,aAAa,EACb3tD,SAAU,CACN4tD,eAAgB,IAAIllC,GACpBmlC,iBAAkB,IAAIpyC,GACtB3Y,sBACA45C,SAAU5jD,KAAKg1D,eAEnB9nD,KAAM,CACF+nD,QAAS,CACL+T,eAAgB,GAChBC,oBAAqB,GACrBxf,WAAYzpD,KAAKypD,YAErByL,gBAAiB,KACjBC,kBAAmB,GACnBjmC,eAIR,OADA,IAAAmmC,eAAc/hB,EAAYnkB,GACnB,CACHgc,OAAQ5pB,EACRjT,MAAOpS,EAASk1B,cAAc,CAC1Bl1B,EAAST,OAAO2qD,YAAc,EAC9BlqD,EAAST,OAAO4qD,aAAe,MAI3CrmD,KAAKwkD,kBAAoB,KACH,IAAAC,cAAazkD,KAAK0kD,aAAaC,cAGrD3kD,KAAKkpE,gBAAkB,KACnB,MAAMvkB,EAAgB3kD,KAAKwkD,oBAC3B,IAAK,MAAM+Q,KAAgB5Q,EAAe,CACtC,MAAM,WAAEz1B,EAAU,kBAAEhB,GAAsBqnC,EACpCj6D,GAAiB,IAAAwpD,wBAAuB51B,EAAYhB,GACpDhyB,EAAWZ,EAAeY,SAC1Bs5D,GAAW,EACXC,GAAY,EACZC,GAAgB,EAChBC,GAAgB,EAChBjlC,GAAiB,EACvBx0B,EAASg2B,YAAY,CACjBsjC,WACAC,YACAC,gBACAC,gBACAjlC,mBAEJx0B,EAAS05D,qBACT,MAAM,QAAEzmC,GAAYjzB,EACpB,IAAIq4D,EAAcv0D,KAAKw0D,gBAAgBl5D,GACvCi5D,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,GAChEA,EAAY3zD,SACZ,IAAA8zD,kBAAiBH,EAAY,GAAGI,eAEpCz4D,EAASD,QACb,CACA+D,KAAK61D,mBAAmBlR,IAE5B3kD,KAAK81D,kBAAoB,KACrB,MAAMnR,EAAgB3kD,KAAKwkD,oBAC3BxkD,KAAK61D,mBAAmBlR,IAE5B3kD,KAAK61D,mBAAsBlR,IACvB,IAAKA,EAAc/jD,QAAmC,IAAzB+jD,EAAc/jD,OAEvC,YADAwP,QAAQC,KAAK,oEAGjB,MAAO84D,EAAeC,EAAgBC,GAAiB1kB,GAC/CxZ,OAAQsuB,EAASnrD,MAAOsjD,GAAW5xD,KAAKq0D,mBAAmB8U,IAC3Dh+B,OAAQuuB,EAASprD,MAAOujD,GAAW7xD,KAAKq0D,mBAAmB+U,GACnE,IAAIE,EAAU,CAAC,EAAG,EAAG,GACjBC,EAAS,cACTF,IACGl+B,OAAQm+B,EAASh7D,MAAOi7D,GACvBvpE,KAAKq0D,mBAAmBgV,KAG5B,SAASE,EAAQ3X,EAAQC,GACzB,WAAW0X,EAAQA,EAAQ,IAC3B,WAAWD,EAAS7P,EAASC,IAEjC,MAAMpuB,EAAa,iCAA6BmuB,EAAS7H,GACnDrmB,EAAc,iCAA6BmuB,EAAS7H,GACpDrmB,EAAa,iCAA6B89B,EAASC,GACnD9f,EAAa,0CAAsCne,EAAYC,EAAaC,GAClFxrC,KAAKy8D,cAAchT,IAEvBzpD,KAAK2+D,iBAAoBvc,IACrB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,cAAEi1B,GAAkBj1B,EACpBy4C,EAAYxjB,EAAcvC,MAC1BnoD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACrB0E,KAAKypE,MAAMnuE,EAAgBkuE,GAC3B,MAAMjV,EAAcv0D,KAAKw0D,gBAAgBl5D,GACnCsjE,EAAsB5+D,KAAKy0D,wCAAwCv4D,EAASizB,QAASolC,IACrF,KAAErnD,GAAS0xD,EAAoB,IAC/B,eAAEoK,GAAmB97D,EAAK+nD,QAC1B4J,EAAkB,GACxB,IAAK,IAAIn1D,EAAI,EAAGA,EAAIs/D,EAAepoE,OAAS,IAAK8I,EAAG,CAChD,MAAMuvD,EAAgB+P,EAAet/D,GAAG,GAClC4xD,EAAuBt7D,KAAK45D,8BAA8BX,EAAc5vD,IACxEqgE,EAA6B1pE,KAAK2pE,oCAAoC1Q,EAAc5vD,IACrFiyD,GAAyBoO,IAG9B7K,EAAgBl2D,KAAKswD,EAAc5vD,IACnCK,IACJ,CAMA,OALAwD,EAAKioD,kBAAoB,IAAI0J,GAC7B3xD,EAAK+nD,QAAQC,gBAAkB,GAC/B9S,EAAIoV,kBACJ,KAAAD,mBAAkBpoC,GAClBnvB,KAAKs3D,gBAAgBnoC,GACdyvC,EAAoB,IAE/B5+D,KAAKiL,OAAS,KACVmF,QAAQ6Q,IAAI,wBAEhBjhB,KAAK8+D,uBAAyB,CAAC1c,EAAK9O,KAChC,MAAMviB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB70D,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,GAClBizB,EAAIoV,kBAERx3D,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,MACnDl3D,KAAKm3D,eAAehoC,EAASmkB,EAAY2jB,EAAc,GAK/Dj3D,KAAKo3D,qBAAuB,CAAChV,EAAK9O,EAAY+jB,KAC1C,MAAMtmC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB70D,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,GAClBizB,EAAIoV,kBAERx3D,KAAKgqD,iBAAoB5H,IACrB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACdz1B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,EACtBY,EAAWZ,EAAeY,SAC1Bq4D,EAAcv0D,KAAKw0D,gBAAgBl5D,GAEnCq9D,EAD0B34D,KAAKy0D,wCAAwCtlC,EAASolC,GACnC,GACnD,IAAKoE,EACD,OAEJ,MAAMiR,EAAgB1tE,EAASumB,YACzBonD,EAAoBlR,EAAmBzxD,SAAS4tD,eAChDgV,EAAsB,CAAC,EAAG,EAAG,GACnC,eAAiBF,EAAch6C,SAAUi6C,EAAmBC,GAC5D,MAAMC,EAAsBpR,EAAmBzxD,SAAS6tD,iBAClDiV,EAAwB,CAAC,EAAG,EAAG,GACrC,eAAiBJ,EAAcjnD,WAAYonD,EAAqBC,GAChErR,EAAmBzxD,SAAS4tD,eAAiB,IAAI8U,EAAch6C,UAC/D+oC,EAAmBzxD,SAAS6tD,iBAAmB,IACxC6U,EAAcjnD,YAErB,MAAM24C,EAAuBt7D,KAAK45D,8BAA8B19D,EAASmN,IACnEqgE,EAA6B1pE,KAAK2pE,oCAAoCztE,EAASmN,IACrF,IAAK,oBAAgBugE,EAAch6C,SAAUi6C,EAAmB,OAC5DvO,GACAoO,EAA4B,CAC5B,IAAIO,GAAa,EAC6B,oBAAgBH,EAAqBE,EAAuB,QAEtGC,GAAa,GAEjB,MAAMC,EAAwBjtE,KAAK6e,IAAI,UAAYguD,EAAqBF,EAAcroD,kBAAoB,IACrG0oD,GAAeC,IAChBlqE,KAAKypD,WAAW,IAAMqgB,EAAoB,GAC1C9pE,KAAKypD,WAAW,IAAMqgB,EAAoB,GAC1C9pE,KAAKypD,WAAW,IAAMqgB,EAAoB,IAC1C,IAAA1nC,cAAa,EAAAxN,YAAa,EAAAnD,OAAO04C,8BAA+B,CAC5DzlB,YAAa1kD,KAAK0kD,YAClB+E,WAAYzpD,KAAKypD,aAG7B,CACA,GAAIzpD,KAAKyM,cAAc67D,SAASxf,QAAS,EACnB,IAAAkf,yBAAwB9rE,EAASmN,GAAIsQ,EAAgBtQ,IAElE+gE,iBACAt1D,OAAQzL,GAAOA,IAAOnN,EAASmN,IACnBpI,QAASiuB,IACtBlvB,KAAKqqE,4BAA4Bn7C,EAAYvV,IAErD,CACA,MACMkkD,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAD1C,IAE/B,EAAA+B,EAAA,GAAsC8G,IAE1C79D,KAAKy3D,cAAiBrV,IAClBpiD,KAAKkpE,mBAETlpE,KAAK03D,kBAAoB,CAACtV,EAAKuV,KAC3B,MAAM,QAAExoC,EAAO,cAAE62B,GAAkB5D,EAAIrtB,OACjCkiC,EAAejR,EAAcvqD,OACnC,IAAIm8D,GAAmB,EACvB,IAAK,IAAIluD,EAAI,EAAGA,EAAIiuD,EAAwB/2D,OAAQ8I,IAAK,CACrD,MAAM4pC,EAAaqkB,EAAwBjuD,GAC3C,IAAI,KAAAmuD,oBAAmBvkB,EAAWqhB,eAC9B,SAEJ,MAAM,KAAEznD,EAAI,YAAE2nD,GAAgBvhB,EAC9B,IAAKpmC,EAAK+nD,QACN,SAEJ,MAAMqV,EAA0Bp9D,EAAK+nD,QAAQC,gBACvCqV,EAA4Br9D,EAAKioD,mBAAqBjoD,EAAKioD,kBAAkBv0D,OAAS,EACtF,IAAIsM,EAAKioD,mBACT,GACNjoD,EAAKioD,kBAAoB,GACzBjoD,EAAK+nD,QAAQC,gBAAkB,KAE/B,IAAI4C,GAAO,EAEPA,IAHyB93D,KAAKwqE,wBAAwBr7C,EAASmkB,EAAY2jB,EAAc,IAMlFj3D,KAAKm3D,eAAehoC,EAASmkB,EAAY2jB,EAAc,GAE/Ba,IAASjD,IACRiD,GAAQjD,GAExCvhB,EAAWuhB,aAAeA,EAC1B+C,GAAmB,GAEd1qD,EAAK+nD,QAAQC,kBAAoBoV,GACrCtqE,KAAKyqE,0BAA0Bv9D,EAAKioD,kBAAmBoV,KACxD3S,GAAmB,EAE3B,CACA,OAAOA,GAEX53D,KAAKy0D,wCAA0C,CAACtlC,EAASolC,KACrD,IAAKA,IAAgBA,EAAY3zD,OAC7B,MAAO,GAEX,MAAMtF,GAAiB,IAAAy/B,mBAAkB5L,IACnC,WAAED,GAAe5zB,EACjBovE,EAAgCnW,EAAYz/C,OAAQw+B,GAAeA,EAAWpmC,KAAKgiB,aAAeA,GACxG,OAAOw7C,GAEX1qE,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,EAAQ,gBAAEyd,GAAoBre,GAChC,QAAE6zB,GAAYjzB,EACdq4D,EAAcv0D,KAAKw0D,gBAAgBl5D,GACnCknB,EAAStmB,EAASumB,YAElBk2C,EAD0B34D,KAAKy0D,wCAAwCtlC,EAASolC,GACnC,GACnD,IAAKA,GAAa3zD,SAAW+3D,GAAoBzrD,KAC7C,OAAOwrD,EAEX,MAAM/D,EAAgBgE,EAAmBhE,eACnC,YAAEvO,EAAW,aAAEC,GAAiBnqD,EAAST,OACzCm9D,EAAuB37D,KAAKopC,KAAK+f,EAAcA,EAAcC,EAAeA,GAC5EskB,EAA2B1tE,KAAKa,IAAIsoD,EAAaC,GACjDn5C,EAAOyrD,EAAmBzrD,KAC1B09D,EAAwB1uE,EAASinD,cAAcnjD,KAAKypD,YACpDoP,EAA2B74D,KAAK6qE,+CAA+CvvE,EAAgBi5D,GAC/Fa,EAAiB,GACjB4D,EAAY,CAAC,EAAG,EAAG5S,EAAaC,GACtCwS,EAAyB53D,QAASqyC,IAC9B,MAAM,KAAEpmC,GAASomC,EACjBpmC,EAAK+nD,QAAQxL,WAAazpD,KAAKypD,WAC/B,MAAMwP,EAAgBt/C,EAAgByW,YAAYljB,EAAKgiB,YACjDgqC,EAAcD,EAAcx2C,YAC5Bk3C,EAA4B35D,KAAK45D,8BAA8BX,EAAc5vD,IAC7EyhE,EAAkC9qE,KAAK2pE,oCAAoC1Q,EAAc5vD,IACzF0hE,EAAuC/qE,KAAKgrE,yCAAyC/R,EAAc5vD,KACnG,YAAE+8C,EAAW,aAAEC,GAAiB4S,EAAcx9D,OAC9C09D,EAA4Bl8D,KAAKopC,KAAK+f,EAAcA,EAAcC,EAAeA,GACjF+S,EAAoB,CACR,GAAdhT,EACe,GAAfC,GAEEgT,EAA2BJ,EAAc7nC,cAAcgoC,GACvDnxD,EAAY,CAAC,EAAG,EAAG,GACzB,YAAcua,EAAOjB,gBAAiB23C,EAAY33C,gBAAiBtZ,GACnE,gBAAkBA,GAClB,qBAAuBA,EAAWkxD,GAClC,MAAMU,EAAc,CAAC,EAAG,EAAG,GAC3B,UAAYR,EAA0BpxD,EAAW4xD,GACjD,MAAMoR,EAAc,CAAC,EAAG,EAAG,GAC3B,eAAiB5R,EAA0BpxD,EAAWgjE,GACtD,MAAMnR,EAAe59D,EAASinD,cAAc0W,GACtCE,EAA4B79D,EAASinD,cAAckW,GACnDW,EAA6B,cACnC,cAAcA,EAA4BF,EAAcC,GACxD,eAAeC,EAA4BA,GAC3C,MAAMC,EAA6B,cACnC,WAAWA,EAA4BD,EAAmD,IAAvBpB,GACnE,MAAMsS,EAA4B,cAClC,WAAWA,EAA2BlR,EAAuD,GAA3B2Q,GAClE,MAAMQ,EAA8B,cACpC,WAAWA,EAA6BnR,EAAuD,GAA3B2Q,GACpE,MAAMS,EAA8B,cAC9BC,EAAerrE,KAAKyM,cAAco8C,QAClC,6BAAE8f,GAAiC0C,GAAcviB,QACjDuiB,EACArrE,KAAKyM,cACL6+D,EAAY3C,EAA+B,EAC3CgC,EAA2BhC,EAC3B3oE,KAAKyM,cAAci8D,8BACzB,WAAW0C,EAA6BpR,EAAgE,IAApCnB,EAAyBj4D,OAAe0qE,EAAY,GACxH,MAAMC,EAAkB,cAClBC,EAAkB,cAClBC,EAAoB,cACpBC,EAAmB,cACzB,IAAIC,EAAiB,WAAWf,GAC3BE,GAAoCnR,IACrCgS,EAAiB,WAAW5R,IAEhC,SAASwR,EAAiBI,EAAgBP,GAC1C,SAASI,EAAiBG,EAAgB1R,GAC1C,cAAcwR,EAAmBE,EAAgBP,GACjD,cAAcM,EAAkBC,EAAgB1R,IAChD,EAAAI,GAAA,GAAgBkR,EAAiBC,EAAiBxS,IAClD,EAAAqB,GAAA,GAAgBoR,EAAmBC,EAAkB1S,GACrD,MAAM4S,EAAe,cACrB,cAAcA,EAAchB,EAAuBM,GACnD,MAAMW,EAAe,cACrB,SAASA,EAAcjB,EAAuBM,GAC9C,IAAIY,EAAwB,WAAWlB,IAClCE,GACDC,IACAe,EAAwB,WAAW/R,IAEvC,IAAIgS,EAAuB,IAAI/rE,KAAKypD,aAC/BqhB,GACDC,IACAgB,EAAuB,IAAI1S,IAE/B,MAAM2S,EAA4B,CAAC,EAAG,EAAG,GACzC,eAAiBnS,EAAaoR,EAAae,GAC3C,gBAAkBA,GAClB,MAAM,gBAAEzqD,GAAoBiB,GACtB,OAAEwuC,GAAW,KACd7rC,kBACAnoB,OAAO,GAAIukB,GACV0qD,EAAiC,CAAC,EAAG,EAAG,GAC9C,mBAAmBA,EAAgCD,EAA2Bhb,GAC9E,MAAMkb,EAAqBjT,EAAckT,mBACnCC,EAA6B,IAC5BH,GAEP,qBAAuBG,EAA4BF,GACnD,MAAMG,EAAwB,CAAC,EAAG,EAAG,GACrC,UAAYN,EAAsBK,EAA4BC,GAC9D,MAAMC,EAAyBpwE,EAASinD,cAAckpB,GAChDE,EAA8B,cACpC,cAAcA,EAA6BT,EAAuBQ,GAClE,MAAME,EAAiB,cACvB,cAAcA,EAAgBV,EAAuB7R,GACrD,SAASuS,EAAgBA,EAAgBD,GACzC,MAAME,GAAiB,cACvB,SAASA,GAAgBX,EAAuB7R,GAChD,SAASwS,GAAgBA,GAAgBF,IACzC,EAAAlS,GAAA,GAAgBmS,EAAgBC,GAAgBzT,GAChD,MAAM0T,GAAmB,cACzB,SAASA,GAAkBZ,EAAuB7R,GAClD,cAAcyS,GAAkBA,GAAkBH,GAClD,MAAMI,GAAkB,cACxB,cAAcA,GAAiBb,EAAuB7R,GACtD,cAAc0S,GAAiBA,GAAiBJ,IAChD,EAAAlS,GAAA,GAAgBqS,GAAkBC,GAAiB3T,GACnD,MAAM4T,GAAc,cACdC,GAAc,cACdC,GAAgB,cAChBC,GAAe,cACrB,cAAcH,GAAad,EAAuBX,GAClD,SAASyB,GAAaA,GAAaL,GACnC,SAASM,GAAaf,EAAuBX,GAC7C,SAAS0B,GAAaA,GAAaN,GACnC,cAAcO,GAAehB,EAAuBX,GACpD,cAAc2B,GAAeA,GAAeP,GAC5C,SAASQ,GAAcjB,EAAuBX,GAC9C,cAAc4B,GAAcA,GAAcR,GAC1CnX,EAAezsD,KAAK,CAChBswD,EACAsS,EACAC,EACAC,EACAC,EACAc,EACAC,GACAC,GACAC,GACAf,EACAC,EACAe,GACAC,GACAC,GACAC,OAGR,MAAMC,EAAc,GACdC,EAAc,GACdxS,EAAgBz6D,KAAK06D,uBAAuBx+D,EAASmN,IACrDjN,OAA0B4B,IAAlBy8D,EAA8BA,EAAgB,qBAoL5D,GAnLArF,EAAen0D,QAAQ,CAAC05D,EAAMC,KAC1B,MAAM3B,EAAgB0B,EAAK,GACrBF,EAAgBz6D,KAAK06D,uBAAuBzB,EAAc5vD,IAC1DiyD,EAAuBt7D,KAAK45D,8BAA8BX,EAAc5vD,IACxEqgE,EAA6B1pE,KAAK2pE,oCAAoC1Q,EAAc5vD,KACtFrJ,KAAKyM,cAAco8C,QAAQC,QACzBokB,EAAkCltE,KAAKgrE,yCAAyC/R,EAAc5vD,KAChGrJ,KAAKyM,cAAco8C,QAAQC,QACzByS,EAAqBruD,EAAKioD,kBAAkBz3C,KAAMrU,GAAOA,IAAO4vD,EAAc5vD,IACpF,IAAIjN,OAA0B4B,IAAlBy8D,EAA8BA,EAAgB,qBACtDvG,EAAY,EAChB,MAAMiZ,EAA8C,OAAjCjgE,EAAK+nD,QAAQC,iBAC5BhoD,EAAK+nD,QAAQC,kBAAoB,IACjCqG,EACA4R,IACAjZ,EAAY,KAEhB,IAAIuH,EAAU,GAAGb,IAmBjB,GAlBIU,GAAwBoO,GACxBjO,EAAU,GAAGb,QACb,IAAAc,UAAYzD,EAAkBtD,EAAe8G,EAASd,EAAK,GAAIA,EAAK,GAAI,CACpEv+D,QACA83D,cAEJuH,EAAU,GAAGb,QACb,IAAAc,UAAYzD,EAAkBtD,EAAe8G,EAASd,EAAK,GAAIA,EAAK,GAAI,CACpEv+D,QACA83D,gBAIJ,IAAAwH,UAAYzD,EAAkBtD,EAAe8G,EAASd,EAAK,GAAIA,EAAK,GAAI,CACpEv+D,QACA83D,cAGJoH,EAAsB,CACtBl/D,OACsB4B,IAAlBy8D,EAA8BA,EAAgB,qBAClD,MAAM2S,EAAmBlgE,EAAK+nD,QAAQC,kBAAoB,GACpDmY,EAAkB,CAAC1S,EAAK,GAAIA,EAAK,KACjC2S,EAAoB,CACtBpxE,EAASk1B,cAAcupC,EAAK,IAC5B1B,EACA0B,EAAK,GACLA,EAAK,IAEH4S,EAAoB,CACtBrxE,EAASk1B,cAAcupC,EAAK,KAC5B1B,EACA0B,EAAK,GACLA,EAAK,IAETqS,EAAYrkE,KAAK2kE,EAAmBC,GACpC,MAAMC,EAA6BtgE,EAAK+nD,QAAQC,kBAAoB,GAC9DuY,EAAuB,CAAC9S,EAAK,IAAKA,EAAK,IAAKA,EAAK,IAAKA,EAAK,KAC3D+S,EAA8B,CAChCxxE,EAASk1B,cAAcupC,EAAK,KAC5B1B,EACA0B,EAAK,GACLA,EAAK,IAEHgT,EAA8B,CAChCzxE,EAASk1B,cAAcupC,EAAK,KAC5B1B,EACA0B,EAAK,GACLA,EAAK,IAEHiT,EAAgC,CAClC1xE,EAASk1B,cAAcupC,EAAK,KAC5B1B,EACA0B,EAAK,GACLA,EAAK,IAEHkT,EAA+B,CACjC3xE,EAASk1B,cAAcupC,EAAK,KAC5B1B,EACA0B,EAAK,GACLA,EAAK,IAETsS,EAAYtkE,KAAK+kE,EAA6BC,EAA6BC,EAA+BC,GAC1G,IAAIrF,EAAexoE,KAAKyM,cAAc+7D,cACjCxoE,KAAKyM,cAAcg8D,kBAAoBl5C,OAAOD,iBAAmB,GAClEzX,EAAU,EAKd,GAJI7X,KAAKyM,cAAco8C,QAAQC,UAC3B0f,EAAexoE,KAAKyM,cAAco8C,OAAO2f,aACzC3wD,EAAU7X,KAAKyM,cAAco8C,OAAOhxC,UAEnCs1D,GAAcntE,KAAKyM,cAAco8C,QAAQC,WACzCskB,IACAI,GACD9D,GACAwD,EAAiC,CACjC,IAAIY,EAAY,GAAGlT,QACnB,IAAAmT,aAAe9V,EAAkBtD,EAAemZ,EAAWT,EAAiB,CACxEjxE,QACAosE,eACA3wD,UACA/Q,KAAM,WAEVgnE,EAAY,GAAGlT,QACf,IAAAmT,aAAe9V,EAAkBtD,EAAemZ,EAAWL,EAAsB,CAC7ErxE,QACAosE,eACA3wD,UACA/Q,KAAM,QAEd,MACK,GAAIqmE,IACJC,IACAI,GACD9D,EAA4B,CAC5B,MAAMoE,EAAY,GAAGlT,KACrB,IAAAmT,aAAe9V,EAAkBtD,EAAemZ,EAAWT,EAAiB,CACxEjxE,QACAosE,eACA3wD,UACA/Q,KAAM,UAEd,MACK,GAAIy0D,IACJ6R,IACAI,GACDN,EAAiC,CACjC,MAAMY,EAAY,GAAGlT,KACrB,IAAAmT,aAAe9V,EAAkBtD,EAAemZ,EAAWL,EAAsB,CAC7ErxE,QACAosE,eACA3wD,UACA/Q,KAAM,QAEd,MACK,GAAIsmE,GAAoB1D,EAA4B,CACrD,MAAMoE,EAAY,GAAGlT,IACf4N,EAAexoE,KAAKyM,cAAc+7D,cACnCxoE,KAAKyM,cAAcg8D,kBACdl5C,OAAOD,iBACP,IACV,IAAAy+C,aAAe9V,EAAkBtD,EAAemZ,EAAWT,EAAiB,CACxEjxE,QACAosE,eACA12D,KAAM1V,EACN0K,KAAM,UAEd,MACK,GAAI0mE,GACLjS,GACA2R,EAAiC,CACjC,MAAM1E,EAAexoE,KAAKyM,cAAc+7D,cACnCxoE,KAAKyM,cAAcg8D,kBACdl5C,OAAOD,iBACP,IACV,IAAAy+C,aAAe9V,EAAkBtD,EAAe8G,EAASgS,EAAsB,CAC3ErxE,QACAosE,eACA12D,KAAM1V,EACN0K,KAAM,QAEd,CAC2BmyD,EAAckT,mBAChB,IAAOe,IAC5BzR,EAAU,GAAGb,UACb,IAAAc,UAAYzD,EAAkBtD,EAAe8G,EAASd,EAAK,GAAIA,EAAK,GAAI,CACpEv+D,QACAQ,MAAO,EACPg/D,SAAU,CAAC,EAAG,KAElBH,EAAU,GAAGb,UACb,IAAAc,UAAYzD,EAAkBtD,EAAe8G,EAASd,EAAK,GAAIA,EAAK,GAAI,CACpEv+D,QACAQ,MAAO+9D,EACPiB,SAAU,CAAC,EAAG,KAG1B,IAEJlD,GAAe,EACfxrD,EAAK+nD,QAAQ+T,eAAiBgE,EAC9B9/D,EAAK+nD,QAAQgU,oBAAsBgE,EAC/BjtE,KAAKyM,cAAcqnD,mBAAoB,CACvC,MAAM,yBAAEC,GAA6B/zD,KAAKyM,cAGpCovD,EAA4B,CAC9BzV,GAHY2N,GAA0B+H,SAAW,KAIjDzV,GAHY0N,GAA0BgI,SAAW,MAK/CC,EAAejI,GAA0BiI,cAAuC,IAAvBpD,EACzDqD,EAAY,KAClB,IAAAC,YAAcjE,EAAkBtD,EAAesH,EAAWJ,EAA2BG,EAAc,CAAE5/D,QAAO0V,KAAM1V,GACtH,CACA,GAAI4D,KAAKyM,cAAcs8D,aAAajgB,QAAS,CACzC,MAAMklB,EAAe,yBACfC,EAAc,EACdC,EAAiB,EACjBC,EAAmBnuE,KAAKyM,cAAcs8D,YAAY3sE,OAAS4xE,EAC3DI,EAAkBnxE,KAAKa,IAAIkC,KAAKyM,cAAcs8D,YAAYv+C,MAAQyjD,EAAaC,IACrF,IAAAhS,YAAcjE,EAAkBtD,EAAe,cAAeiW,EAAuBwD,EAAiB,CAClGhyE,MAAO+xE,EACPr8D,KAAMq8D,GAEd,CACA,OAAOzV,GAEX14D,KAAKw0D,gBAAmBl5D,IACpB,MAAM,SAAEY,GAAaZ,EACfi5D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe94D,EAASizB,UAAY,GACtEtV,EAAc7Z,KAAKwkD,oBAAoBn+C,IAAI,EAAG6oB,gBAAiBA,GAC/DktC,EAAuB7H,EAAYz/C,OAAQw+B,IAC7C,MAAM,KAAEpmC,GAASomC,EACjB,OAAOz5B,EAAYgB,SAAS3N,EAAKgiB,cAErC,OAAOktC,GAEXp8D,KAAKowD,aAAe,KAChB,MAAMzL,EAAgB3kD,KAAKwkD,oBAC3BxkD,KAAK61D,mBAAmBlR,IAE5B3kD,KAAKyqE,0BAA4B,CAAC4D,EAAoBC,IAC9CD,EAAmBztE,SAAW0tE,EAAmB1tE,SAGrDytE,EAAmBptE,QAASoI,IACxB,IAAIklE,GAAY,EAChB,IAAK,IAAI7kE,EAAI,EAAGA,EAAI4kE,EAAmB1tE,SAAU8I,EAC7C,GAAIL,IAAOilE,EAAmB5kE,GAAI,CAC9B6kE,GAAY,EACZ,KACJ,CAEJ,IAAkB,IAAdA,EACA,OAAO,KAGR,GAEXvuE,KAAK08D,gDAAkD,CAACphE,EAAgBi5D,KACpE,MAAM,WAAErlC,EAAU,gBAAEvV,EAAe,SAAEzd,GAAaZ,EAC5Cu9D,EAA2BtE,EAAYz/C,OAAQw+B,GAAeA,EAAWpmC,KAAKgiB,aAAeA,GACnG,IAAK2pC,IAA6BA,EAAyBj4D,OACvD,MAAO,GAEX,MAAM4hB,EAAStmB,EAASumB,aAClB,gBAAElB,EAAe,SAAEqO,GAAapN,EAChCm6C,EAAgC9D,EAAyB/jD,OAAQw+B,IACnE,MAAM,WAAEpkB,GAAeokB,EAAWpmC,KAE5B0vD,EADiBjjD,EAAgByW,YAAYlB,GACbzM,YACtC,QAAS,oBAAgBm6C,EAAer7C,gBAAiBA,EAAiB,MAAS,oBAAgBq7C,EAAehtC,SAAUA,EAAU,MAE1I,OAAO+sC,GAEX38D,KAAK68D,mCAAqC,CAACvhE,EAAgBwhE,EAAqBvI,KAC5E,MAAM,gBAAE56C,GAAoBre,GACtB,KAAE4R,GAAS4vD,EACX5gE,EAAWyd,EAAgByW,YAAYljB,EAAKgiB,YAC5C6tC,EAA4BxI,EAAYz/C,OAAQw+B,IAClD,MAAM,KAAEpmC,GAASomC,EACX2lB,EAAgBt/C,EAAgByW,YAAYljB,EAAKgiB,YAEvD,OAAqC,IADHlvB,KAAK45D,8BAA8BX,EAAc5vD,MAGvF,IAAK0zD,IAA8BA,EAA0Bn8D,OACzD,MAAO,GAEX,MAAM4hB,EAAStmB,EAASumB,YAClBlB,EAAkBiB,EAAOjB,gBAC/B,gBAAkBA,GAClB,MAAMy7C,EAAmDD,EAA0BjoD,OAAQw+B,IACvF,MAAM,WAAEpkB,GAAeokB,EAAWpmC,KAE5BgsD,EADgBv/C,EAAgByW,YAAYlB,GAChBzM,YAC5Bw6C,EAAuB/D,EAAY33C,gBAEzC,OADA,gBAAkB07C,GACV,oBAAgB17C,EAAiB07C,EAAsB,MAC3D,oBAAgBz6C,EAAOwiB,OAAQk0B,EAAYl0B,OAAQ,OAE3D,OAAOg4B,GAEXh9D,KAAK6qE,+CAAiD,CAACvvE,EAAgBi5D,KACnE,MAAM,gBAAE56C,EAAe,SAAEzd,GAAaZ,EAEhCimB,EADSrlB,EAASumB,YACOlB,gBAC/B,gBAAkBA,GAClB,MAAMitD,EAA8Cja,EAAYz/C,OAAQw+B,IACpE,MAAM,KAAEpmC,GAASomC,EACX2lB,EAAgBt/C,EAAgByW,YAAYljB,EAAKgiB,YACjDyqC,EAA4B35D,KAAK45D,8BAA8BX,EAAc5vD,IACnF,OAAQnN,IAAa+8D,IACa,IAA9BU,IAEF8U,EAA6C,GACnD,IAAK,IAAI/kE,EAAI,EAAGA,EAAI8kE,EAA4C5tE,SAAU8I,EAAG,CACzE,MAAM4pC,EAAak7B,EAA4C9kE,IACzD,WAAEwlB,GAAeokB,EAAWpmC,KAE5BgsD,EADgBv/C,EAAgByW,YAAYlB,GAChBzM,YAC5Bw6C,EAAuB/D,EAAY33C,gBAEzC,GADA,gBAAkB07C,GACd,oBAAgB17C,EAAiB07C,EAAsB,MACvD,uBAAmB17C,EAAiB07C,EAAsB,KAC1D,SAEJ,IAAIyR,GAAc,EAClB,IAAK,IAAIC,EAAK,EAAGA,EAAKF,EAA2C7tE,SAAU+tE,EAAI,CAC3E,MAAMr7B,EAAam7B,EAA2CE,IACxD,WAAEz/C,GAAeokB,EAAWpmC,KAE5B0hE,EADkBj1D,EAAgByW,YAAYlB,GACZzM,YACpC,oBAAgBmsD,EAAgBrtD,gBAAiB23C,EAAY33C,gBAAiB,MAC9E,oBAAgBqtD,EAAgBh/C,SAAUspC,EAAYtpC,SAAU,KAChE8+C,GAAc,EAEtB,CACKA,GACDD,EAA2C9lE,KAAK2qC,EAExD,CACA,MAAMu7B,EAAiDta,EAAYz/C,OAAQw+B,IACvE,MAAM,KAAEpmC,GAASomC,EACX2lB,EAAgBt/C,EAAgByW,YAAYljB,EAAKgiB,YACjDyqC,EAA4B35D,KAAK45D,8BAA8BX,EAAc5vD,IACnF,OAAQnN,IAAa+8D,IACa,IAA9BU,IAER,IAAK,IAAIjwD,EAAI,EAAGA,EAAImlE,EAA+CjuE,SAAU8I,EAAG,CAC5E,MAAM4pC,EAAau7B,EAA+CnlE,IAC5D,WAAEwlB,GAAeokB,EAAWpmC,KAE5BgsD,EADgBv/C,EAAgByW,YAAYlB,GAChBzM,YAC5Bw6C,EAAuB/D,EAAY33C,gBAEzC,GADA,gBAAkB07C,GACd,oBAAgB17C,EAAiB07C,EAAsB,MACvD,uBAAmB17C,EAAiB07C,EAAsB,KAC1D,SAEJ,IAAIyR,GAAc,EAClB,IAAK,IAAIC,EAAK,EAAGA,EAAKF,EAA2C7tE,SAAU+tE,EAAI,CAC3E,MAAMr7B,EAAam7B,EAA2CE,IACxD,WAAEz/C,GAAeokB,EAAWpmC,KAE5B0hE,EADkBj1D,EAAgByW,YAAYlB,GACZzM,YACpC,oBAAgBmsD,EAAgBrtD,gBAAiB23C,EAAY33C,gBAAiB,MAC9E,oBAAgBqtD,EAAgBh/C,SAAUspC,EAAYtpC,SAAU,KAChE8+C,GAAc,EAEtB,CACKA,GACDD,EAA2C9lE,KAAK2qC,EAExD,CACA,MAAMulB,EAA2B74D,KAAK08D,gDAAgDphE,EAAgBi5D,GACtG,IAAK,IAAI7qD,EAAI,EAAGA,EAAImvD,EAAyBj4D,SAAU8I,EAAG,CACtD,MAAM4pC,EAAaulB,EAAyBnvD,GAC5C,GAAI+kE,EAA2CxlD,KAAMkG,GAAYA,IAAYmkB,GACzE,SAEJ,MAAM,WAAEpkB,GAAeokB,EAAWpmC,KAE5BgsD,EADgBv/C,EAAgByW,YAAYlB,GAChBzM,YAC5Bw6C,EAAuB/D,EAAY33C,gBAEzC,GADA,gBAAkB07C,GACd,oBAAgB17C,EAAiB07C,EAAsB,MACvD,uBAAmB17C,EAAiB07C,EAAsB,KAC1D,SAEJ,IAAIyR,GAAc,EAClB,IAAK,IAAIC,EAAK,EAAGA,EAAKF,EAA2C7tE,SAAU+tE,EAAI,CAC3E,MAAMr7B,EAAam7B,EAA2CE,IACxD,WAAEz/C,GAAeokB,EAAWpmC,KAE5B0hE,EADkBj1D,EAAgByW,YAAYlB,GACZzM,YACpC,oBAAgBmsD,EAAgBrtD,gBAAiB23C,EAAY33C,gBAAiB,MAC9E,oBAAgBqtD,EAAgBh/C,SAAUspC,EAAYtpC,SAAU,KAChE8+C,GAAc,EAEtB,CACKA,GACDD,EAA2C9lE,KAAK2qC,EAExD,CACA,OAAOm7B,GAEXzuE,KAAK8uE,oCAAsC,CAAC5yE,EAAU+8D,KAClD,MAAM8V,EAAY7yE,EAAS8yE,kBACrBC,EAAiBhW,EAAc+V,kBACrC,OAAQD,EAAUnuE,SAAWquE,EAAeruE,QACxCmuE,EAAUxgD,MAAOllB,GAAO4lE,EAAep0D,SAASxR,KAExDrJ,KAAKypE,MAAQ,CAACnuE,EAAgBkuE,KAC1B,KAAMtM,uBAAwB,EAC9B,MAAM,SAAEhhE,EAAQ,gBAAEyd,GAAoBre,EAChCi5D,EAAcv0D,KAAKw0D,gBAAgBl5D,GACnCia,EAAQ,CAAC,EAAG,EAAG,GACrB,eAAiBi0D,EAAWxpE,KAAKypD,WAAYl0C,GAC7C,MACM0pD,EAD2Bj/D,KAAK08D,gDAAgDphE,EAAgBi5D,GACxCz/C,OAAQw+B,IAClE,MAAM,KAAEpmC,GAASomC,EACX2lB,EAAgBt/C,EAAgByW,YAAYljB,EAAKgiB,YACjDggD,EAAYlvE,KAAK8uE,oCAAoC5yE,EAAU+8D,GACrE,OAAQj5D,KAAK45D,8BAA8BX,EAAc5vD,KACrDrJ,KAAK2pE,oCAAoC1Q,EAAc5vD,KACvD6lE,IAER,OAA4C,IAAxCjQ,EAA6Br+D,QAC7B,KAAMs8D,uBAAwB,GACvB,IAEXl9D,KAAKg/D,0CAA0CrlD,EAAiBslD,EAA8B1pD,GAC9F,KAAM2nD,uBAAwB,GACvB,IAEXl9D,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAyBl9D,KAAKyM,cAAco8C,QAAQC,QAC1D35B,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpB/wB,KAAK29D,SAASrqB,WAAWpmC,KAAK+nD,QAAQC,gBAAkB,KACxDl1D,KAAK29D,SAASrqB,WAAWpmC,KAAKioD,kBAAoB,GAClDn1D,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnBnvB,KAAK29D,SAAW,KAChB,MACME,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAD1C,IAE/B,EAAA+B,EAAA,GAAsC8G,IAE1C79D,KAAKqiD,cAAiBD,IAClB,MAAMrxB,EAAcqxB,EAAIrtB,OAClBxf,EAAQwb,EAAYwyB,YAAYE,MACtC,GAAIxmD,KAAK6e,IAAIvG,EAAM,IAAM,MACrBtY,KAAK6e,IAAIvG,EAAM,IAAM,MACrBtY,KAAK6e,IAAIvG,EAAM,IAAM,KACrB,OAEJ,MAAM,QAAE4Z,GAAY4B,EACdz1B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,EAAe,SAAEzd,GAAaZ,EAChCi5D,EAAcv0D,KAAKw0D,gBAAgBl5D,GAEnCq9D,EAD0B34D,KAAKy0D,wCAAwCtlC,EAASolC,GACnC,GACnD,IAAKoE,EACD,OAEJ,MAAM,QAAE1D,GAAY0D,EAAmBzrD,MACjC,cAAE84C,GAAkB5D,EAAIrtB,OACxBkiC,EAAejR,EAAcvqD,OACnC,GAAIw5D,EAAQC,kBAAoB,GAAgB,CAC5C,MACM+J,EAD2Bj/D,KAAK08D,gDAAgDphE,EAAgBi5D,GACxCz/C,OAAQw+B,IAClE,MAAM,KAAEpmC,GAASomC,EACX2lB,EAAgBt/C,EAAgByW,YAAYljB,EAAKgiB,YACjDyqC,EAA4B35D,KAAK45D,8BAA8BX,EAAc5vD,IAC7EyhE,EAAkC9qE,KAAK2pE,oCAAoC1Q,EAAc5vD,IAC/F,OAAsC,IAA9BswD,IACgC,IAApCmR,GACAnS,EAAmBzrD,KAAKioD,kBAAkBz3C,KAAMrU,GAAOA,IAAO4vD,EAAc5vD,MAEpFrJ,KAAKg/D,0CAA0CrlD,EAAiBslD,EAA8B1pD,EAClG,MACK,GAAI0/C,EAAQC,kBAAoB,GAAkB,CACnD,MACM+J,EAD2Bj/D,KAAK08D,gDAAgDphE,EAAgBi5D,GACxCz/C,OAAQw+B,IAClE,MAAM,KAAEpmC,GAASomC,EACX2lB,EAAgBt/C,EAAgByW,YAAYljB,EAAKgiB,YACjDyqC,EAA4B35D,KAAK45D,8BAA8BX,EAAc5vD,IAC7EyhE,EAAkC9qE,KAAK2pE,oCAAoC1Q,EAAc5vD,IAC/F,OAAsC,IAA9BswD,IACgC,IAApCmR,IAEFqE,EAAO,cACPC,EAAO,cACPx4D,EAAS,CACX5W,KAAKypD,WAAW,GAChBzpD,KAAKypD,WAAW,GAChBzpD,KAAKypD,WAAW,IAEd6a,EAAepoE,EAASinD,cAAcvsC,GACtCy4D,EAAmBt+C,EAAYi1B,cAAcvqD,OAC7C6zE,EAAsB,cAC5B,SAASA,EAAqBD,EAAkBt+C,EAAYwyB,YAAY9nD,QACxE,SAAS0zE,EAAMG,EAAqBhL,GACpC,SAAS8K,EAAMC,EAAkB/K,GACjC,IAAIxnE,EAAQ,WAAWqyE,EAAMC,GACzBpvE,KAAKuvE,aAAajL,EAAcgL,EAAqBD,KACrDvyE,IAAU,GAEdA,EAAQG,KAAKgmB,MAAc,IAARnmB,GAAe,IAClC,MAAM0yE,EAAetzE,EAASumB,YAAYlB,iBACpC,OAAEyvC,GAAW,KACdye,kBACA9yE,UAAUia,EAAO,GAAIA,EAAO,GAAIA,EAAO,IACvC5Z,OAAOF,EAAO0yE,GACd7yE,WAAWia,EAAO,IAAKA,EAAO,IAAKA,EAAO,IACzC84D,EAAoB,GAC1BzQ,EAA6Bh+D,QAASqyC,IAClC,MAAM,KAAEpmC,GAASomC,EACjBpmC,EAAK+nD,QAAQxL,WAAa7yC,EAC1B,MAAMqiD,EAAgBt/C,EAAgByW,YAAYljB,EAAKgiB,YACjD1M,EAASy2C,EAAcx2C,aACvB,OAAEuiB,EAAM,SAAEpV,EAAQ,WAAEjN,GAAeH,EACzCwiB,EAAO,IAAMpV,EAAS,GACtBoV,EAAO,IAAMpV,EAAS,GACtBoV,EAAO,IAAMpV,EAAS,GACtB,mBAAmBjN,EAAYA,EAAYquC,GAC3C,mBAAmBphC,EAAUA,EAAUohC,GACvC,mBAAmBhsB,EAAQA,EAAQgsB,GACnChsB,EAAO,IAAMpV,EAAS,GACtBoV,EAAO,IAAMpV,EAAS,GACtBoV,EAAO,IAAMpV,EAAS,GACtBqpC,EAAcl3B,UAAU,CACpBnS,WACAoV,SACAriB,eAEJ+sD,EAAkB/mE,KAAKswD,EAAc5vD,MAEzCsQ,EAAgBK,gBAAgB01D,EACpC,MACK,GAAIza,EAAQC,kBAAoB,GAAgB,CACjD,MACMya,EAD2B3vE,KAAK08D,gDAAgDphE,EAAgBi5D,GAChDz/C,OAAQw+B,IAC1D,MAAM,KAAEpmC,GAASomC,EACX2lB,EAAgBt/C,EAAgByW,YAAYljB,EAAKgiB,YACjDyqC,EAA4B35D,KAAK45D,8BAA8BX,EAAc5vD,IAC7E0hE,EAAuC/qE,KAAKgrE,yCAAyC/R,EAAc5vD,IACzG,OAAsC,IAA9BswD,IACqC,IAAzCoR,GACApS,EAAmBzrD,KAAKioD,kBAAkBz3C,KAAMrU,GAAOA,IAAO4vD,EAAc5vD,MAEpF,GAAoC,IAAhCsmE,EAAqB/uE,OACrB,OAEJ,MAAMq+D,EAA+Bj/D,KAAK68D,mCAAmCvhE,EAAgBq0E,EAAqB,GAAIpb,GAChHqb,EAAe,GACrBA,EAAajnE,KAAKzM,EAASmN,IAC3B41D,EAA6Bh+D,QAASqyC,IAClC,MAAM,KAAEpmC,GAASomC,EACX2lB,EAAgBt/C,EAAgByW,YAAYljB,EAAKgiB,YAEjDic,EADS8tB,EAAcx2C,YACPlB,gBAChB49C,EAAU,UAAY5pD,EAAO41B,GAC7Bi0B,EAAiB,IAAIj0B,GAE3B,GADA,qBAAuBi0B,EAAgBD,GACnCliE,KAAK6e,IAAIsjD,EAAe,IAAM,MAC9BniE,KAAK6e,IAAIsjD,EAAe,IAAM,MAC9BniE,KAAK6e,IAAIsjD,EAAe,IAAM,KAAM,CACpC,MAAMyQ,EAAM5yE,KAAKopC,KAAK+4B,EAAe,GAAKA,EAAe,GACrDA,EAAe,GAAKA,EAAe,GACnCA,EAAe,GAAKA,EAAe,IACjC0Q,EAAe/+C,EAAYk1B,WAAWxC,MACtCx7C,EAAY,CAAC,EAAG,EAAG,GACnB8nE,EAAgB,CAClB/vE,KAAKypD,WAAW,GAChBzpD,KAAKypD,WAAW,GAChBzpD,KAAKypD,WAAW,IAGpB,IADmCzpD,KAAK2pE,oCAAoC1Q,EAAc5vD,IACzD,CAC7B,MAAM,eAAE2/D,GAAoBhpE,KAAK29D,SAASrqB,WAAe,KAAE2hB,QACrD+a,EAA8BhH,EAAel0D,OAAQxG,GAAUA,EAAM,GAAGwU,MAAQm2C,EAAc5vD,IACpG,GAA2C,IAAvC2mE,EAA4BpvE,OAAc,CAC1C,MAAMgxD,EAAS11D,EAASk1B,cAAc4+C,EAA4B,GAAG,IAC/Dne,EAAS31D,EAASk1B,cAAc4+C,EAA4B,GAAG,IACrE,UAAYpe,EAAQC,EAAQke,GAC5B,qBAAuBA,EAAe,GAC1C,CACJ,CACA,eAAiBD,EAAcC,EAAe9nE,GAC9C,MAAMgoE,EAAmB,UAAYhoE,EAAWkjC,GAC1C+kC,EAAqB,IAAI/kC,GAC/B,qBAAuB+kC,EAAoBD,GAC3C,MAAME,EAA+B,CACjCD,EAAmB,GACnBA,EAAmB,GACnBA,EAAmB,IAEvB,eAAeC,EAA8BA,GAC7C,MAAMC,EAA2B,CAC7BhR,EAAe,GACfA,EAAe,GACfA,EAAe,IAEnB,eAAegR,EAA0BA,GACzC,IAAIlE,EAAqBjT,EAAckT,mBACnC,uBAAmBgE,EAA8BC,EAA0B,MAC3ElE,GAAsB2D,EAGtB3D,GAAsB2D,EAE1B3D,EAAqBjvE,KAAK6e,IAAIowD,GAC9BA,EAAqBjvE,KAAKkS,IAAI,GAAmBkhE,uBAAwBnE,GAC5DlsE,KAAKswE,wBAAwB3X,EAAoB1B,EAAc,EAAGgC,KAE3EiT,EAAqB,GAAmBmE,yBAE1B,IAAArI,yBAAwB/O,EAAc5vD,GAAIsQ,EAAgBtQ,IACvCknE,gBAAgBvwE,KAAKg1D,eACvCwb,iBAAiBvX,EAAeiT,GACnD0D,EAAajnE,KAAKswD,EAAc5vD,GACpC,IAEJsQ,EAAgBK,gBAAgB41D,EACpC,GAEJ5vE,KAAKswE,wBAA0B,CAACh9B,EAAY2jB,EAAcC,EAAWuZ,KACjE,MAAM,KAAEvjE,GAASomC,GACX,eAAE01B,GAAmB97D,EAAK+nD,QAChC,IAAK,IAAIvrD,EAAI,EAAGA,EAAIs/D,EAAepoE,OAAS,IAAK8I,EAAG,CAChD,MAAMuvD,EAAgB+P,EAAet/D,GAAG,GACxC,GAAIuvD,EAAc5vD,KAAOonE,EAAapnE,GAClC,SAGJ,IAD6BrJ,KAAK45D,8BAA8BX,EAAc5vD,IAE1E,SAEJ,MAAMqnE,EAAe,CACjBh1E,MAAO,CACH4B,EAAG0rE,EAAet/D,GAAG,GAAG,GACxBlM,EAAGwrE,EAAet/D,GAAG,GAAG,IAE5BsI,IAAK,CACD1U,EAAG0rE,EAAet/D,GAAG,GAAG,GACxBlM,EAAGwrE,EAAet/D,GAAG,GAAG,KAG1BinE,EAAmB,mBAA4B,CAACD,EAAah1E,MAAM4B,EAAGozE,EAAah1E,MAAM8B,GAAI,CAACkzE,EAAa1+D,IAAI1U,EAAGozE,EAAa1+D,IAAIxU,GAAI,CAACy5D,EAAa,GAAIA,EAAa,KACtK2Z,EAAe,CACjBl1E,MAAO,CACH4B,EAAG0rE,EAAet/D,EAAI,GAAG,GAAG,GAC5BlM,EAAGwrE,EAAet/D,EAAI,GAAG,GAAG,IAEhCsI,IAAK,CACD1U,EAAG0rE,EAAet/D,EAAI,GAAG,GAAG,GAC5BlM,EAAGwrE,EAAet/D,EAAI,GAAG,GAAG,KAG9BmnE,EAAmB,mBAA4B,CAACD,EAAal1E,MAAM4B,EAAGszE,EAAal1E,MAAM8B,GAAI,CAACozE,EAAa5+D,IAAI1U,EAAGszE,EAAa5+D,IAAIxU,GAAI,CAACy5D,EAAa,GAAIA,EAAa,KAC5K,GAAI0Z,GAAoBzZ,GAAa2Z,GAAoB3Z,EACrD,OAAO,EAEXxtD,GACJ,CACA,OAAO,GAEX1J,KAAK06D,uBACD3Y,EAAUt1C,eAAewxD,uBACrB,GACRj+D,KAAK45D,8BACD7X,EAAUt1C,eAAeyxD,8BACrB,GACRl+D,KAAK2pE,oCACD5nB,EAAUt1C,eAAeqkE,oCACrB5I,GACRloE,KAAKgrE,yCACDjpB,EAAUt1C,eAAeskE,yCACrB5I,EACZ,CACA,eAAAvjB,GACI,MAAMD,EAAgB3kD,KAAKwkD,oBAC3BxkD,KAAKwwD,mCAAmC7L,GACxC3kD,KAAKywD,iCAAiC9L,GACtC3kD,KAAK61D,mBAAmBlR,EAC5B,CACA,gBAAAqsB,GACI,MAAMrsB,EAAgB3kD,KAAKwkD,oBAC3BxkD,KAAK61D,mBAAmBlR,EAC5B,CACA,gBAAAoF,GACI,MAAMpF,EAAgB3kD,KAAKwkD,oBAC3BxkD,KAAK61D,mBAAmBlR,EAC5B,CACA,iBAAAU,GACI,MAAMV,EAAgB3kD,KAAKwkD,oBAC3BxkD,KAAKwwD,mCAAmC7L,GACxCA,EAAc1jD,QAAQ,EAAGitB,oBAAmBgB,iBACxC,MAAM5zB,GAAiB,IAAAwpD,wBAAuB51B,EAAYhB,GAC1D,IAAK5yB,EACD,OAEJ,MAAMi5D,EAAcv0D,KAAKw0D,gBAAgBl5D,GACrCi5D,GAAa3zD,QACb2zD,EAAYtzD,QAASqyC,KACjB,IAAAohB,kBAAiBphB,EAAWqhB,kBAI5C,CACA,aAAA8H,CAAchT,EAAY/4B,GAAiB,GACjB1wB,KAAKwkD,oBACbn+C,IAAI,EAAG6nB,oBAAmBgB,iBACpC,MACMhzB,GADkB,IAAAiyB,oBAAmBD,GACVkC,YAAYlB,GACvC1M,EAAStmB,EAASumB,aAClB,WAAEE,EAAU,SAAEiN,EAAQ,gBAAErO,GAAoBiB,EAC5CjN,EAAQ,CACVk0C,EAAW,GAAK9mC,EAAW,GAC3B8mC,EAAW,GAAK9mC,EAAW,GAC3B8mC,EAAW,GAAK9mC,EAAW,IAEzB+f,EAASntB,EAAM,GAAKgM,EAAgB,GACtChM,EAAM,GAAKgM,EAAgB,GAC3BhM,EAAM,GAAKgM,EAAgB,GACzB0vD,EAAc,CAChBvuC,EAASnhB,EAAgB,GACzBmhB,EAASnhB,EAAgB,GACzBmhB,EAASnhB,EAAgB,IAEvBsgB,EAAgB,CAClBlf,EAAW,GAAKsuD,EAAY,GAC5BtuD,EAAW,GAAKsuD,EAAY,GAC5BtuD,EAAW,GAAKsuD,EAAY,IAE1B97C,EAAc,CAChBvF,EAAS,GAAKqhD,EAAY,GAC1BrhD,EAAS,GAAKqhD,EAAY,GAC1BrhD,EAAS,GAAKqhD,EAAY,IAE9B/0E,EAAS6lC,UAAU,CACfpf,WAAYkf,EACZjS,SAAUuF,IAEdj5B,EAASD,WAEb+D,KAAKypD,WAAaA,EACb/4B,IACD,IAAA0R,cAAa,EAAAxN,YAAa,EAAAnD,OAAO04C,8BAA+B,CAC5DzlB,YAAa1kD,KAAK0kD,YAClB+E,WAAYzpD,KAAKypD,YAG7B,CACA,uBAAA+gB,CAAwBr7C,EAASmkB,EAAY2jB,EAAcC,GACvD,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACrB,IAAIgT,EAAQtO,KAAKkxE,iCAAiCh1E,EAAUo3C,EAAY2jB,EAAcC,GACtF,OAAc,OAAV5oD,EACOA,GAEXA,EAAQtO,KAAKmxE,sCAAsCj1E,EAAUo3C,EAAY2jB,EAAcC,GACzE,OAAV5oD,EACOA,OADX,EAGJ,CACA,kCAAAkiD,CAAmC7L,GAC/BA,EAAc1jD,QAAQ,EAAGiuB,aAAYhB,wBACjC,MAAM,SAAEhyB,IAAa,IAAA4oD,wBAAuB51B,EAAYhB,IAClD,QAAEiB,GAAYjzB,EACpBizB,EAAQrE,oBAAoB,EAAA8lB,MAAA,OAAajU,2BAA4B38B,KAAKowD,eAElF,CACA,gCAAAK,CAAiC72C,GAC7BA,EAAU3Y,QAAQ,EAAGiuB,aAAYhB,wBAC7B,MAAM,SAAEhyB,IAAa,IAAA4oD,wBAAuB51B,EAAYhB,IAClD,QAAEiB,GAAYjzB,EACpBizB,EAAQ1E,iBAAiB,EAAAmmB,MAAA,OAAajU,2BAA4B38B,KAAKowD,eAE/E,CACA,2BAAAia,CAA4Bn7C,EAAYvV,GACpC,MAAMzd,EAAWyd,EAAgByW,YAAYlB,IACvC,YAAEk3B,EAAW,aAAEC,GAAiBnqD,EAAST,OACzC21E,EAAmBl1E,EAASinD,cAAcnjD,KAAKypD,YAC/Cwb,EAAMjlE,KAAKyM,cAAc67D,QAAQC,QACjC8I,EAAqB,CACvBD,EAAiB,GACjBA,EAAiB,IAcrB,GAZIA,EAAiB,GAAK,EACtBC,EAAmB,GAAKpM,EAEnBmM,EAAiB,GAAKhrB,IAC3BirB,EAAmB,GAAKjrB,EAAc6e,GAEtCmM,EAAiB,GAAK,EACtBC,EAAmB,GAAKpM,EAEnBmM,EAAiB,GAAK/qB,IAC3BgrB,EAAmB,GAAKhrB,EAAe4e,GAEvCoM,EAAmB,KAAOD,EAAiB,IAC3CC,EAAmB,KAAOD,EAAiB,GAC3C,OAEJ,MAAME,EAAoBp1E,EAASk1B,cAAcigD,GAC3C7tB,EAAmB,CACrB8tB,EAAkB,GAAKtxE,KAAKypD,WAAW,GACvC6nB,EAAkB,GAAKtxE,KAAKypD,WAAW,GACvC6nB,EAAkB,GAAKtxE,KAAKypD,WAAW,IAErCjnC,EAAStmB,EAASumB,aAClB,WAAEE,EAAU,SAAEiN,GAAapN,EAC3BkhC,EAAkB,CACpB9zB,EAAS,GAAK4zB,EAAiB,GAC/B5zB,EAAS,GAAK4zB,EAAiB,GAC/B5zB,EAAS,GAAK4zB,EAAiB,IAE7BG,EAAoB,CACtBhhC,EAAW,GAAK6gC,EAAiB,GACjC7gC,EAAW,GAAK6gC,EAAiB,GACjC7gC,EAAW,GAAK6gC,EAAiB,IAErCtnD,EAAS6lC,UAAU,CACfpf,WAAYghC,EACZ/zB,SAAU8zB,IAEdxnD,EAASD,QACb,CACA,gBAAAu0E,CAAiBt0E,EAAUmrB,GACvB,IAAIkqD,EACJ,MAAM,kCAAE3I,GAAsC5oE,KAAKyM,cAC/Cm8D,GACAA,EAAkChoE,OAAS,IAC3C2wE,EAAY3I,GAEhB,IAAI4I,EAAiBxxE,KAAKyM,cAAco8D,uBACpCxhD,IAAkB,GAAmBgpD,yBACrCmB,EAAiB,EAAA5gC,MAAA,WAAiB6gC,WAGtCv1E,EAASw1E,aAAaF,EAAgBD,GADpB,GAElBr1E,EAASs0E,iBAAiBnpD,EAAekqD,EAC7C,CACA,YAAAhC,CAAarzD,EAAGhF,EAAGinB,GACf,OAAQjnB,EAAE,GAAKgF,EAAE,KAAOiiB,EAAE,GAAKjiB,EAAE,KAAOhF,EAAE,GAAKgF,EAAE,KAAOiiB,EAAE,GAAKjiB,EAAE,IAAM,CAC3E,CACA,yCAAA8iD,CAA0CrlD,EAAiBslD,EAA8B1pD,GACrF0pD,EAA6Bh+D,QAASqyC,IAClCtzC,KAAKk/D,iCAAiCvlD,EAAiB25B,EAAY/9B,IAE3E,CACA,gCAAA2pD,CAAiCvlD,EAAiB25B,EAAY/9B,GAC1D,MAAM,KAAErI,GAASomC,EACXp3C,EAAWyd,EAAgByW,YAAYljB,EAAKgiB,YAC5C1M,EAAStmB,EAASumB,YAClB0oB,EAAS3oB,EAAOjB,gBAChB49C,EAAU,UAAY5pD,EAAO41B,GAC7Bi0B,EAAiB,IAAIj0B,GAE3B,GADA,qBAAuBi0B,EAAgBD,GACnCliE,KAAK6e,IAAIsjD,EAAe,IAAM,MAC9BniE,KAAK6e,IAAIsjD,EAAe,IAAM,MAC9BniE,KAAK6e,IAAIsjD,EAAe,IAAM,KAAM,CACpC,MAAMv9B,EAAgB,CAAC,EAAG,EAAG,GACvB1M,EAAc,CAAC,EAAG,EAAG,GAC3B,UAAY3S,EAAOG,WAAYy8C,EAAgBv9B,GAC/C,UAAYrf,EAAOoN,SAAUwvC,EAAgBjqC,GAC7Cj5B,EAAS6lC,UAAU,CACfpf,WAAYkf,EACZjS,SAAUuF,IAEdj5B,EAASD,QACb,CACJ,CACA,gCAAAi1E,CAAiCh1E,EAAUo3C,EAAY2jB,EAAcC,GACjE,MAAM,KAAEhqD,GAASomC,GACX,eAAE01B,GAAmB97D,EAAK+nD,QAChC,IAAK,IAAIvrD,EAAI,EAAGA,EAAIs/D,EAAepoE,OAAQ8I,IAAK,CAC5C,MAAM4E,EAAQ06D,EAAet/D,GAAG,GAC1BuvD,EAAgB+P,EAAet/D,GAAG,GAExC,IAD6B1J,KAAK45D,8BAA8BX,EAAc5vD,IAE1E,SAGJ,IADmCrJ,KAAK2pE,oCAAoC1Q,EAAc5vD,IAEtF,SAEJ,MAAMsoE,EAA6Bz1E,EAASinD,cAAc70C,GAC1D,GAAI,cAAc2oD,EAAc0a,GAA8Bza,EAK1D,OAJAhqD,EAAK+nD,QAAQC,gBAAkB,GAC/Bl1D,KAAK29D,SAAW,CACZrqB,cAEGhlC,CAEf,CACA,OAAO,IACX,CACA,qCAAA6iE,CAAsCj1E,EAAUo3C,EAAY2jB,EAAcC,GACtE,MAAM,KAAEhqD,GAASomC,GACX,oBAAE21B,GAAwB/7D,EAAK+nD,QACrC,IAAK,IAAIvrD,EAAI,EAAGA,EAAIu/D,EAAoBroE,OAAQ8I,IAAK,CACjD,MAAM4E,EAAQ26D,EAAoBv/D,GAAG,GAC/BuvD,EAAgBgQ,EAAoBv/D,GAAG,GAE7C,IAD6B1J,KAAK45D,8BAA8BX,EAAc5vD,IAE1E,SAGJ,IADwCrJ,KAAKgrE,yCAAyC/R,EAAc5vD,IAEhG,SAEJ,MAAMsoE,EAA6Bz1E,EAASinD,cAAc70C,GAC1D,GAAI,cAAc2oD,EAAc0a,GAA8Bza,EAM1D,OALAhqD,EAAK+nD,QAAQC,gBAAkB,GAC/BhoD,EAAKioD,kBAAoB,CAAC8D,EAAc5vD,IACxCrJ,KAAK29D,SAAW,CACZrqB,cAEGhlC,CAEf,CACA,OAAO,IACX,CACA,cAAA6oD,CAAehoC,EAASmkB,EAAY2jB,EAAcC,GAC9C,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,YAAE8qD,EAAW,aAAEC,GAAiBnqD,EAAST,OACzCm9D,EAAuB37D,KAAKopC,KAAK+f,EAAcA,EAAcC,EAAeA,IAC5E,KAAEn5C,GAASomC,GACX,eAAE01B,GAAmB97D,EAAK+nD,SAC1B,oBAAEgU,GAAwB/7D,EAAK+nD,QAC/B4J,EAAkB,GACxB,IAAK,IAAIn1D,EAAI,EAAGA,EAAIs/D,EAAepoE,OAAS,IAAK8I,EAAG,CAChD,MAAMuvD,EAAgB+P,EAAet/D,GAAG,GAClC4xD,EAAuBt7D,KAAK45D,8BAA8BX,EAAc5vD,IACxEqgE,EAA6B1pE,KAAK2pE,oCAAoC1Q,EAAc5vD,IAC1F,IAAKiyD,IAAyBoO,EAC1B,SAEJ,MAAMgH,EAAe,CACjBh1E,MAAO,CACH4B,EAAG0rE,EAAet/D,GAAG,GAAG,GACxBlM,EAAGwrE,EAAet/D,GAAG,GAAG,IAE5BsI,IAAK,CACD1U,EAAG0rE,EAAet/D,GAAG,GAAG,GACxBlM,EAAGwrE,EAAet/D,GAAG,GAAG,KAG1BinE,EAAmB,mBAA4B,CAACD,EAAah1E,MAAM4B,EAAGozE,EAAah1E,MAAM8B,GAAI,CAACkzE,EAAa1+D,IAAI1U,EAAGozE,EAAa1+D,IAAIxU,GAAI,CAACy5D,EAAa,GAAIA,EAAa,KACtK2Z,EAAe,CACjBl1E,MAAO,CACH4B,EAAG0rE,EAAet/D,EAAI,GAAG,GAAG,GAC5BlM,EAAGwrE,EAAet/D,EAAI,GAAG,GAAG,IAEhCsI,IAAK,CACD1U,EAAG0rE,EAAet/D,EAAI,GAAG,GAAG,GAC5BlM,EAAGwrE,EAAet/D,EAAI,GAAG,GAAG,KAG9BmnE,EAAmB,mBAA4B,CAACD,EAAal1E,MAAM4B,EAAGszE,EAAal1E,MAAM8B,GAAI,CAACozE,EAAa5+D,IAAI1U,EAAGszE,EAAa5+D,IAAIxU,GAAI,CAACy5D,EAAa,GAAIA,EAAa,MACxK0Z,GAAoBzZ,GAAa2Z,GAAoB3Z,KACrD2H,EAAgBl2D,KAAKswD,EAAc5vD,IACnC6D,EAAK+nD,QAAQC,gBAAkB,IAEnCxrD,GACJ,CACA,IAAK,IAAIA,EAAI,EAAGA,EAAIu/D,EAAoBroE,OAAS,IAAK8I,EAAG,CACrD,MAAMuvD,EAAgBgQ,EAAoBv/D,GAAG,GAC7C,GAAIm1D,EAAgBnhD,KAAMrU,GAAOA,IAAO4vD,EAAc5vD,IAClD,SAEJ,MAAMiyD,EAAuBt7D,KAAK45D,8BAA8BX,EAAc5vD,IACxE6jE,EAAkCltE,KAAKgrE,yCAAyC/R,EAAc5vD,IACpG,IAAKiyD,IAAyB4R,EAC1B,SAEJ,MAAM0E,EAAqB3I,EAAoBv/D,GAAG,GAC5CmoE,EAAqB5I,EAAoBv/D,GAAG,GAC5C46D,EAAe,cACrB,SAASA,EAAcsN,EAAoBC,GAC3C,WAAWvN,EAAcA,EAAc,IACvC,MAAMtK,EAA6B,cACnC,cAAcA,EAA4B4X,EAAoBtN,GAC9D,eAAetK,EAA4BA,GAC3C,MAAMoR,EAA8B,cACpC,WAAWA,EAA6BpR,EAAmD,IAAvBpB,GACpE,MAAMkZ,EAA0B,cAC1BC,EAA0B,cAChC,SAASD,EAAyBxN,EAAc8G,GAChD,cAAc2G,EAAyBzN,EAAc8G,GACrD,MAAMsF,EAAe,CACjBh1E,MAAO,CACH4B,EAAGw0E,EAAwB,GAC3Bt0E,EAAGs0E,EAAwB,IAE/B9/D,IAAK,CACD1U,EAAGs0E,EAAmB,GACtBp0E,EAAGo0E,EAAmB,KAGxBjB,EAAmB,mBAA4B,CAACD,EAAah1E,MAAM4B,EAAGozE,EAAah1E,MAAM8B,GAAI,CAACkzE,EAAa1+D,IAAI1U,EAAGozE,EAAa1+D,IAAIxU,GAAI,CAACy5D,EAAa,GAAIA,EAAa,KACtK2Z,EAAe,CACjBl1E,MAAO,CACH4B,EAAGy0E,EAAwB,GAC3Bv0E,EAAGu0E,EAAwB,IAE/B//D,IAAK,CACD1U,EAAGu0E,EAAmB,GACtBr0E,EAAGq0E,EAAmB,KAGxBhB,EAAmB,mBAA4B,CAACD,EAAal1E,MAAM4B,EAAGszE,EAAal1E,MAAM8B,GAAI,CAACozE,EAAa5+D,IAAI1U,EAAGszE,EAAa5+D,IAAIxU,GAAI,CAACy5D,EAAa,GAAIA,EAAa,MACxK0Z,GAAoBzZ,GAAa2Z,GAAoB3Z,KACrD2H,EAAgBl2D,KAAKswD,EAAc5vD,IACnC6D,EAAK+nD,QAAQC,gBAAkB,MAEnCxrD,GACJ,CAKA,OAJAwD,EAAKioD,kBAAoB,IAAI0J,GAC7B7+D,KAAK29D,SAAW,CACZrqB,cAEGpmC,EAAK+nD,QAAQC,kBAAoB,EAC5C,EAEJkT,GAAexkB,SAAW,aAC1B,MCz+CMouB,GAAsB,mBAC5B,MAAMC,WAAoB,MACtB,WAAAxyE,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXylE,YAAa,GACbC,aAAc,IACdC,cAAe,OAGnB9wB,MAAMS,EAAWC,GACjBhiD,KAAKqyE,iBAAkB,EACvBryE,KAAKkkD,qBAAwB9B,IACzB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,EAAO,cAAE62B,GAAkBj1B,EAC7Bz1B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,EAAQ,gBAAEyd,GAAoBre,EACtC,KAAMY,aAAoB,EAAA8+B,eACtB,MAAM,IAAI58B,MAAM,4CAEpB,MAAMmI,EAAoBvG,KAAKsyE,sBAAsBp2E,GACrD,IAAKqK,EACD,MAAM,IAAInI,MAAM,qFAEpB,MAAMy/D,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAazE,OAZAh1D,KAAK29D,SAAW,CACZp3D,oBACAs3D,sBACAviE,iBACAqe,kBACAqsC,iBAEJhmD,KAAKuyE,+BACLvyE,KAAKyhE,cAActyC,IACnB,KAAAooC,mBAAkBpoC,GAClBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,IAC/B,GAEX79D,KAAKolE,sBAAyBhjB,IAC1BpiD,KAAKkkD,qBAAqB9B,IAE9BpiD,KAAKuyE,6BAA+B,KAChC,MAAM,eAAEj3E,EAAc,kBAAEiL,EAAiB,oBAAEs3D,EAAmB,gBAAElkD,EAAe,cAAEqsC,GAAmBhmD,KAAK29D,UACnG,SAAEzhE,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACds2E,EAAqBt2E,EAASorB,iBAC5BvqB,SAAU01E,GAA6Bv2E,EAASggC,uBAChDzgC,OAAQi3E,EAAWjvB,MAAOniC,GAAa0kC,EAC/C,IAAI2sB,EAEJ,GADAA,EAAqBxjD,EAAQyjD,cAAc,gBAChB,OAAvBD,EAA6B,CAC7B,MAAME,EAAiBzjD,SAASC,cAAc,OAC9CwjD,EAAeC,UAAUxvE,IAAI,eAC7BuvE,EAAenjD,MAAMqjD,QAAU,QAC/BF,EAAenjD,MAAM9yB,MAAQ,GAAGoD,KAAKyM,cAAc0lE,iBACnDU,EAAenjD,MAAM7yB,OAAS,GAAGmD,KAAKyM,cAAc2lE,kBACpDS,EAAenjD,MAAME,SAAW,WAChC+iD,EAAqBE,EACG1jD,EAAQyjD,cAAc,qBAC9B9iD,YAAY+iD,GAC5B,MAAMxiD,EAAgB,CAClBnB,WAAY8iD,GACZlrE,KAAM,EAAA8pC,MAAA,aAAmBpgB,MACzBrB,QAASwjD,GAEbh5D,EAAgBgX,cAAcN,EAClC,CACAsiD,EAAmBjjD,MAAM/a,IAAS+9D,EAAU,GAAK1yE,KAAKyM,cAAc2lE,cAAgB,EAArD,KAC/BO,EAAmBjjD,MAAM6yC,KAAUmQ,EAAU,GAAK1yE,KAAKyM,cAAc0lE,aAAe,EAApD,KAChC,MAAMa,EAAkBr5D,EAAgByW,YAAY4hD,IACpDgB,EAAgB/1C,SAAS,CAAC12B,IAAoBxB,KAAK,KAC/C,GAAI/E,KAAKqyE,gBACL,OAEJW,EAAgB7gD,cAAcqgD,GAC9BQ,EAAgBp2C,oBAAoB,CAChC7/B,SAAU01E,IAEd,MAAM,cAAEjN,GAAkBtpE,EAASumB,aAC7B,WAAEE,EAAU,SAAEiN,EAAQ,gBAAErO,GAAoByxD,EAAgBvwD,YAC5DzG,EAAW/e,KAAKopC,KAAKppC,KAAKotD,IAAI1nC,EAAW,GAAKiN,EAAS,GAAI,GAC7D3yB,KAAKotD,IAAI1nC,EAAW,GAAKiN,EAAS,GAAI,GACtC3yB,KAAKotD,IAAI1nC,EAAW,GAAKiN,EAAS,GAAI,IACpC+zB,EAAoB,CACtBriC,EAAS,GACTA,EAAS,GACTA,EAAS,IAEPoiC,EAAkB,CACpBC,EAAkB,GAAK3nC,EAAWuF,EAAgB,GAClDoiC,EAAkB,GAAK3nC,EAAWuF,EAAgB,GAClDoiC,EAAkB,GAAK3nC,EAAWuF,EAAgB,IAEtDyxD,EAAgBjxC,UAAU,CACtByjC,cAAeA,GAAiB,EAAIxlE,KAAKyM,cAAcylE,aACvDvvD,WAAYghC,EACZ/zB,SAAU8zB,IAEdsvB,EAAgB/2E,WAEpB02E,EAAmBjjD,MAAMqjD,QAAU,SACnC,EAAAhc,EAAA,GAAsC8G,IAE1C79D,KAAKizE,gBAAmB7wB,IACpBA,EAAIoV,iBACJpV,EAAI8wB,kBACJlzE,KAAKmzE,iBAAiB/wB,IAE1BpiD,KAAKqiD,cAAiBD,IAClB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,YAAEwuB,EAAW,QAAEp0B,EAAO,cAAE62B,GAAkBj1B,EAC1CyyB,EAAmBD,EAAYE,MAC/BivB,EAAY1sB,EAAcvqD,OAC1BH,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,EACtB03E,EAAkBr5D,EAAgByW,YAAY4hD,IAC9Ca,EAAiB1jD,EAAQyjD,cAAc,gBAC7C,IAAKC,EACD,OAEJA,EAAenjD,MAAM/a,IAAS+9D,EAAU,GAAK1yE,KAAKyM,cAAc2lE,cAAgB,EAArD,KAC3BS,EAAenjD,MAAM6yC,KAAUmQ,EAAU,GAAK1yE,KAAKyM,cAAc0lE,aAAe,EAApD,KAC5B,MAAM,WAAExvD,EAAU,SAAEiN,GAAaojD,EAAgBvwD,YAC3CihC,EAAkB,CACpB9zB,EAAS,GAAK4zB,EAAiB,GAC/B5zB,EAAS,GAAK4zB,EAAiB,GAC/B5zB,EAAS,GAAK4zB,EAAiB,IAE7BG,EAAoB,CACtBhhC,EAAW,GAAK6gC,EAAiB,GACjC7gC,EAAW,GAAK6gC,EAAiB,GACjC7gC,EAAW,GAAK6gC,EAAiB,IAErCwvB,EAAgBjxC,UAAU,CACtBpf,WAAYghC,EACZ/zB,SAAU8zB,IAEdsvB,EAAgB/2E,UAEpB+D,KAAKmzE,iBAAoB/wB,IACrB,IAAI,QAAEjzB,GAAYizB,EAAIrtB,OACtB,QAAgB/2B,IAAZmxB,EAAuB,CACvB,MAAM,eAAE7zB,GAAmB0E,KAAK29D,UAC1B,SAAEzhE,GAAaZ,EACrB6zB,EAAUjzB,EAASizB,OACvB,CACA,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,EAC5Bqe,EAAgBiY,eAAeogD,IAC/B,MAAMoB,EAAkBjkD,EAAQyjD,cAAc,qBACxCD,EAAqBS,EAAgBR,cAAc,gBACzDQ,EAAgBC,YAAYV,GAC5B3yE,KAAK0hE,gBAAgBvyC,IACrB,KAAAyuC,oBAAmBzuC,GACnBnvB,KAAKqyE,iBAAkB,GAE3BryE,KAAKyhE,cAAiBtyC,IAClB,KAAM+tC,uBAAwB,EAC9Bl9D,KAAKqyE,iBAAkB,EACvBljD,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKmzE,kBAC/ChkD,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKmzE,kBAClDhkD,EAAQ1E,iBAAiB,cAAezqB,KAAKizE,iBAC7C9jD,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKmzE,kBAChDhkD,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,gBAErDriD,KAAK0hE,gBAAmBvyC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKmzE,kBAClDhkD,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKmzE,kBACrDhkD,EAAQrE,oBAAoB,cAAe9qB,KAAKizE,iBAChD9jD,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKmzE,kBACnDhkD,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eAE5D,CACA,qBAAAiwB,CAAsBp2E,GAClB,MAAMsqB,EAAWxmB,KAAKszE,YAAYp3E,GAClC,IAAIqK,EAIJ,OAHIrK,aAAoB,EAAA8+B,gBACpBz0B,EAAoBigB,EAASpkB,MAAM,YAAY,IAE5CmE,CACX,EAEJ0rE,GAAYruB,SAAW,U,wCC/KvB,MAEQnyB,OAAQ8hD,IAAa,EAAA3iC,MACvB4iC,GAAkBr9D,KAAYA,EAAMs9D,kBAC1C,IAAIC,IACJ,SAAWA,GACPA,EAAgD,oBAAI,qBACvD,CAFD,CAEGA,KAA+BA,GAA6B,CAAC,IAChE,MACMC,GAAqB,EAAI,EAAAlgB,UAAA,QAC/B,MAAMmgB,WAA4B,aACrB5zE,KAAK6zE,QAAUH,EAA4B,CACpD,WAAAj0E,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX47D,QAAQ,EACRyL,gBAAiB,CACbpuC,OAAQ,IACRquC,WAAY,EACZC,eAAgB,CAAC,IAAK,EAAG,IAAK,EAAG,IAAK,EAAG,IAAK,GAC9C1L,QAAS,CACLxf,SAAS,EACTmrB,QAAS,KAGjBC,QAAS,CACLC,oBAAqB,CACjBC,OAAQ,sBACRC,SAAU,CACN,CACIC,YAAa,EAAAC,cAAcC,UAC3BC,YAAa,EAAAC,iBAAiBC,aAOlDrzB,MAAMS,EAAWC,GACjBhiD,KAAK2+D,iBAAoBvc,IACrB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7Bz1B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,EAAQ,gBAAEyd,GAAoBre,EAChCgmB,EAAW0kC,EAAcvC,MACzBivB,EAAY1sB,EAAcvqD,QACxBq4E,gBAAiBc,GAAW50E,KAAKyM,eACnC,OAAEi5B,EAAM,WAAEquC,EAAU,QAAEzL,GAAYsM,EAClCC,EAAqB70E,KAAK80E,uBAAuBpC,EAAWhtC,GAC5DljB,EAAStmB,EAASumB,aAClB,gBAAElB,EAAe,OAAEyjB,GAAWxiB,EAC9Bjc,EAAoBvG,KAAKshE,qBAAqBplE,EAAUolB,EAAUC,EAAiByjB,GACnF2vB,EAAgB,qBAChBogB,EAAoB,qBACpB/qE,EAAsB9N,EAASqlE,yBAC/BjuB,EAAa,CACfqhB,gBACAE,aAAa,EACbt5D,aAAa,EACb2L,SAAU,CACN08C,SAAU5jD,KAAKg1D,cACfzzC,gBAAiB,IAAIA,GACrByjB,OAAQ,IAAIA,GACZh7B,sBACAzD,qBAEJ2G,KAAM,CACF8nE,iBAAkB94E,EAASmN,GAC3B0rE,oBACAhB,aACAkB,oBAAoB,EACpBhgB,QAAS,CACLxmD,OAAQomE,EACRK,kBAAmB,QAI/Bl1E,KAAKm1E,uBAAuBC,eAAe9hC,EAAY,CACnDyhC,oBACAM,qBAAsB/5E,EACtBs0B,SAAU8iD,EACVhtC,SACAquC,aACAzL,QAAS,CACLxf,QAASwf,EAAQxf,QACjBmrB,QAAS3L,EAAQ2L,QACjB/yE,SAAWgM,IACP,MAAMooE,EAAmBhiC,EAAWpmC,KAAK+nD,QAAQxmD,QACzChT,OAAQ85E,GAAgBroE,EAAKqI,MACrC,IAAK,IAAI7L,EAAI,EAAGgyC,EAAM45B,EAAiB10E,OAAQ8I,EAAIgyC,EAAKhyC,IAAK,CACzD,MAAM4E,EAAQgnE,EAAiB5rE,GAC/B4E,EAAM,IAAMinE,EAAY,GACxBjnE,EAAM,IAAMinE,EAAY,GACxBjiC,EAAW/3C,aAAc,CAC7B,OAIZ,IAAA85D,eAAc/hB,EAAYnkB,GAC1B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAGzE,OAFA5S,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GAC/BvqB,GAEXtzC,KAAKqlD,kBAAoB,KACrBrlD,KAAKm1E,uBAAuBK,WACR,IAAAC,qBACRx0E,QAASqyC,IACbA,EAAWpsC,SAAS08C,WAAa5jD,KAAKg1D,gBACtC,IAAAN,kBAAiBphB,EAAWqhB,kBAIxC30D,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,KACvD,MAAM,KAAEhqD,GAASomC,GACX,OAAE7kC,GAAWvB,EAAK+nD,QAClB+M,EAAoBvzD,EACpBinE,EAAY1T,EAAkB,GAC9B2T,EAAe3T,EAAkB,GACjC4T,EAAa5T,EAAkB,GAC/Bt8B,EAAoD,GAA3CzoC,KAAK6e,IAAI65D,EAAa,GAAKD,EAAU,IAC9C9+D,EAAS,CACXg/D,EAAW,GAAKlwC,EAChBgwC,EAAU,GAAKhwC,GAEbmwC,GAAc,KAAAC,uBAAsB,CAACl/D,EAAQqgD,IACnD,OAAIh6D,KAAK6e,IAAI+5D,EAAcnwC,GAAsB,EAAZwxB,GAKzCl3D,KAAKo3D,qBAAuB,CAAChV,EAAK9O,KAC9B,MAAMviB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB,MAAMgJ,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,wBAEJ,KAAAtG,mBAAkBpoC,GAClBnvB,KAAKs3D,gBAAgBnoC,IACrB,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAK8+D,uBAAyB,CAAC1c,EAAK9O,EAAYyrB,KAC5C,MAAMhuC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,KAAE7jB,GAASomC,EACjBA,EAAWuhB,aAAc,EACzB,MAAM,OAAEpmD,GAAWvB,EAAK+nD,QAClB8gB,EAActnE,EAAO+D,UAAW9D,GAAMA,IAAMqwD,GAC5ClB,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,eAEJ/1E,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,IAClB,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,KAAEzwD,GAASomC,EACjBpmC,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnBnvB,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,GACjB,EAAAtK,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,IAGnCtzC,KAAKi2E,kBAAqB7zB,IACtBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,YAAEwuB,GAAgBxyB,EAClBwkD,EAAchyB,GAAa9nD,QAAU,CAAC,EAAG,EAAG,IAC5C,WAAE63C,EAAU,oBAAEuqB,GAAwB79D,KAAK29D,UAC3C,OAAElvD,GAAW6kC,EAAWpmC,KAAK+nD,QACnCxmD,EAAOxN,QAASqN,IACZA,EAAM,IAAMinE,EAAY,GACxBjnE,EAAM,IAAMinE,EAAY,KAE5BjiC,EAAW/3C,aAAc,EACzByE,KAAK29D,SAASuY,UAAW,GACzB,EAAAnf,EAAA,GAAsC8G,IAE1C79D,KAAKm2E,oBAAuB/zB,IACxBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,YAAEkY,GAAgB/1E,KAAK29D,UACxD,KAAEzwD,GAASomC,EACjB,QAAoBt1C,IAAhB+3E,EAA2B,CAC3B,MAAM,YAAExyB,GAAgBxyB,EAClBwkD,EAAchyB,EAAY9nD,OACjByR,EAAK+nD,QAAQxmD,OACrBxN,QAASqN,IACZA,EAAM,IAAMinE,EAAY,GACxBjnE,EAAM,IAAMinE,EAAY,KAE5BjiC,EAAW/3C,aAAc,CAC7B,MAEIyE,KAAKo2E,YAAYh0B,GACjB9O,EAAW/3C,aAAc,GAE7B,EAAAw7D,EAAA,GAAsC8G,IAE1C79D,KAAKo2E,YAAeh0B,IAChB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,WAAEue,GAAetzC,KAAK29D,UACtB,KAAEzwD,GAASomC,GACX,OAAE7kC,GAAWvB,EAAK+nD,QAClB+M,EAAoBvzD,EACpBinE,EAAY1T,EAAkB,GAC9B2T,EAAe3T,EAAkB,GACjC4T,EAAa5T,EAAkB,GAC/Bt8B,EAAoD,GAA3CzoC,KAAK6e,IAAI65D,EAAa,GAAKD,EAAU,IAC9CW,EAAe,CACjBT,EAAW,GAAKlwC,EAChBgwC,EAAU,GAAKhwC,IAEb,cAAEsgB,GAAkBj1B,EACpBulD,EAAsBtwB,EAAcvqD,OACpC86E,GAAY,KAAAT,uBAAsB,CACpCO,EACAC,IAEEE,EAAwBx2E,KAAK80E,uBAAuBuB,EAAcE,GACxE9nE,EAAO,GAAK+nE,EAAsB,GAClC/nE,EAAO,GAAK+nE,EAAsB,GAClC/nE,EAAO,GAAK+nE,EAAsB,GAClC/nE,EAAO,GAAK+nE,EAAsB,IAEtCx2E,KAAKiL,OAAUkkB,IACX,IAAKnvB,KAAKqhE,UACN,OAEJrhE,KAAKqhE,WAAY,EACjBrhE,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,WAAEmkB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,KAAEzwD,GAASomC,EAQjB,OAPAA,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,MACjC,EAAAne,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KACTrqB,EAAWqhB,eAEtB30D,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKm2E,qBACjDhnD,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKm2E,qBACjDhnD,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKm2E,qBACpDhnD,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKm2E,qBACpDhnD,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACpB,IAAIq4D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAEXnE,EAAcA,GAAaz/C,OAAQw+B,GAAeA,EAAWpmC,KAAK8nE,mBAC9D94E,EAASmN,IACb,MAAMu1D,EAAsB5+D,KAAKy0D,wCAAwCtlC,EAASolC,GAClF,IAAKqK,GAAqBh+D,OACtB,OAAO83D,EAEX,MAAMqJ,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAIk1D,EAAoBh+D,OAAQ8I,IAAK,CACjD,MAAM4pC,EAAasrB,EAAoBl1D,IACjC,cAAEirD,EAAa,KAAEznD,GAASomC,GAC1B,kBAAEyhC,EAAiB,WAAEhB,EAAU,QAAE9e,GAAY/nD,GAC7C,OAAEuB,EAAM,kBAAEymE,GAAsBjgB,EACtC8M,EAAepN,cAAgBA,EACb30D,KAAKy2E,SAAS,YAAa1U,EAAgBzuB,GAC5CtzC,KAAKy2E,SAAS,WAAY1U,EAAgBzuB,GAD3D,MAEMl3C,EAAQ4D,KAAKy2E,SAAS,QAAS1U,EAAgBzuB,GAC/C0uB,EAAoBvzD,EACpBinE,EAAY1T,EAAkB,GAC9B2T,EAAe3T,EAAkB,GACjC4T,EAAa5T,EAAkB,GAC/Bt8B,EAAoD,GAA3CzoC,KAAK6e,IAAI65D,EAAa,GAAKD,EAAU,IAC9C9+D,EAAS,CACXg/D,EAAW,GAAKlwC,EAChBgwC,EAAU,GAAKhwC,GAEnB,IAAKxpC,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,IAAIge,EACJ,KAAK,KAAAC,qBAAoBhiB,GACrB,SAOJ,IALK,KAAAkD,oBAAmBlD,IACnB30D,KAAK29D,UACgB,OAAtBuX,IACAwB,EAA2B,CAAC1U,EAAkBkT,KAE9CwB,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAA7I,aAAe9V,EAAkBtD,EAAeiiB,EAAgBF,EAA0B,CACtFt6E,SAER,CACA,MAAM8lE,EAAS,GAAGvN,oBACZsH,EAAY,KAClB,IAAAC,YAAcjE,EAAkBtD,EAAesH,EAAWrlD,EAAQ8uB,EAAQ,CACtEtpC,QACA83D,UAAW,GACZgO,GACH,MAAM8Q,EAAkBhzE,KAAKm1E,uBAAuB/kD,YAAY2kD,GAChE/B,EAAgBpjD,SAAWhZ,EAC3Bo8D,EAAgBttC,OAASA,EACzBstC,EAAgBe,WAAaA,EAC7Bf,EAAgB6D,SAChBne,GAAe,CACnB,CACA,OAAOA,GAEX14D,KAAK80E,uBAAyB,CAACgC,EAAiBC,IACrC,CACH,CAACD,EAAgB,GAAIA,EAAgB,GAAKC,EAAc,GACxD,CAACD,EAAgB,GAAKC,EAAcD,EAAgB,GAAI,GACxD,CAACA,EAAgB,GAAIA,EAAgB,GAAKC,EAAc,GACxD,CAACD,EAAgB,GAAKC,EAAcD,EAAgB,GAAI,IAGhE92E,KAAKm1E,uBAAyB6B,GAA+BC,aACjE,CACA,mBAAA9C,CAAoB/xB,EAAK9O,GACrB,MAAM,QAAEnkB,EAAO,cAAE62B,GAAkB5D,EAAIrtB,OACjCz5B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACbG,OAAQ0zC,GAAgB6W,EAC1BotB,EAAkBjkD,EAAQyjD,cAAc,4BACxCsE,EAAoB5jC,EAAWpmC,KAAK6mE,WAEpCoD,EAAWn3E,KAAKo3E,4BAA4BF,EAAoBG,SAC5Cr5E,IAAlBq5E,IACA/jC,EAAWpmC,KAAK6mE,WAAa/nE,OAAOyK,WAAW4gE,GAC/C/jC,EAAW/3C,aAAc,GAJZ47E,EAASG,cAAcjE,YAAY8D,GAOpDj7E,EAASD,WAEb2D,OAAO23E,OAAOJ,EAASznD,MAAO,CAC1B6yC,KAAM,GAAGpzB,EAAY,OACrBx6B,IAAK,GAAGw6B,EAAY,SAExBikC,EAAgBtjD,YAAYqnD,GAC5BA,EAASK,OACb,CACA,2BAAAJ,CAA4BF,EAAmBO,GAC3C,MAAM,eAAEzD,GAAmBh0E,KAAKyM,cAAcqnE,gBACxCqD,EAAW/nD,SAASC,cAAc,UA6BxC,OA5BA8nD,EAAS3sD,KAAO,EAChB5qB,OAAO23E,OAAOJ,EAASznD,MAAO,CAC1B9yB,MAAO,OACPgzB,SAAU,aAEd,CAAC,YAAa,UAAW,YAAa,SAAS3uB,QAASmmE,IACpD+P,EAAS1sD,iBAAiB28C,EAAYhlB,GAAQA,EAAI8wB,qBAEtDiE,EAAS1sD,iBAAiB,SAAW23B,IACjCA,EAAI8wB,kBACJuE,EAAiBN,EAASl3E,SAE9Bk3E,EAAS1sD,iBAAiB,UAAY23B,MACZA,EAAIs1B,SAAyB,KAAdt1B,EAAIu1B,QACV,WAA3Bv1B,EAAIjiD,KAAKy3E,iBAETx1B,EAAI8wB,kBACJuE,OAGRzD,EAAe/yE,QAAS8yE,IACpB,MAAM8D,EAASzoD,SAASC,cAAc,UACtCwoD,EAAOjkD,MAAQmgD,EACf8D,EAAOC,MAAQ,eAAe/D,EAAWx2C,QAAQ,KACjDs6C,EAAO53E,MAAQ8zE,EACf8D,EAAOE,gBAAkBhE,IAAemD,EACxCC,EAAS7zE,IAAIu0E,KAEVV,CACX,EAEJ,MAAMH,GACF,WAAAv3E,GACIO,KAAKo1E,eAAiB,CAAC9hC,EAAYiiB,KAC/B,MAAM,kBAAEwf,EAAiB,qBAAEM,EAAoB,SAAEzlD,EAAQ,OAAE8V,EAAM,WAAEquC,EAAU,QAAEzL,GAAa/S,GACpFr5D,SAAU87E,GAAmB3C,GAC7BlmD,QAAS8oD,GAAkBD,EAC7BhF,EAAkB,IAAIkF,GAAwB,CAChDnD,oBACAM,uBACA3vC,SACA9V,WACAmkD,aACAzL,YAQJ,OANAtoE,KAAKm4E,+BAA+BF,GACpCj4E,KAAKo4E,qBAAqBl4E,IAAI8yE,EAAgB9jD,WAAY,CACtDokB,aACA0/B,kBACAqF,oBAAqB9iB,IAElByd,GAEXhzE,KAAKs4E,2BAA8Bl2B,IAC/B,MAAM,WAAE9O,GAAe8O,EAAIrtB,OA9aJ,oBA+anBue,EAAWpsC,SAAS08C,UAGxB5jD,KAAKu4E,gBAAgBjlC,EAAWpmC,KAAK6nE,oBAEzC/0E,KAAKw4E,uBAA0Bp2B,IAC3B,MAAQlzB,WAAY8lD,EAAgB,QAAE7wE,GAAYi+C,EAAIrtB,OAChD0jD,EAA6Bz4E,KAAK04E,iDAAiD1D,IACnF,SAAE94E,IAAa,IAAAy8E,+BAA8B3D,GAC/C94E,EAAS08E,yBACT54E,KAAK64E,OAAO7D,GAEhByD,EAA2Bx3E,QAAQ,EAAGqyC,iBAClCA,EAAWpsC,SAASX,kBAAoBpC,EACxCmvC,EAAW/3C,aAAc,KAGjCyE,KAAK84E,wBAA2B12B,IAC5B,MAAM,kBAAEl0B,EAAmBgB,WAAY8lD,GAAqB5yB,EAAIrtB,OAE1DijD,GADkB,IAAA7pD,oBAAmBD,GACJkC,YAAY4kD,IAC3CzzD,gBAAiBw3D,GAA2Bf,EAAev1D,YAChCziB,KAAK04E,iDAAiD1D,GAC9D/zE,QAAQ,EAAGqyC,iBAClC,MAAM,gBAAE/xB,GAAoB+xB,EAAWpsC,SAGvC,KAFmBjK,KAAK6e,IAAI,SAASyF,EAAiBw3D,IAClDpF,IAEA,OAEJ,MAAM,QAAE1e,GAAY3hB,EAAWpmC,KACzB8rE,EAAuBhB,EAAe5mD,cAAc,CAAC,EAAG,IACxD6nD,EAAwB,SAAS,cAAeD,EAAsB/jB,EAAQxmD,OAAO,IACrFyqE,EAAY,SAASD,EAAuBF,GAC5CI,EAAa,WAAW,cAAeJ,EAAwBG,GACrE,IAAK,IAAIxvE,EAAI,EAAGgyC,EAAMuZ,EAAQxmD,OAAO7N,OAAQ8I,EAAIgyC,EAAKhyC,IAAK,CACvD,MAAM4E,EAAQ2mD,EAAQxmD,OAAO/E,GAC7B4E,EAAM,IAAM6qE,EAAW,GACvB7qE,EAAM,IAAM6qE,EAAW,GACvB7qE,EAAM,IAAM6qE,EAAW,EAC3B,CACA7lC,EAAW/3C,aAAc,KAGjCyE,KAAKo4E,qBAAuB,IAAI5mE,IAChCxR,KAAKo5E,aACT,CACA,kBAAOnC,GAIH,OAHAD,GAA+BqC,WAC3BrC,GAA+BqC,YAC3B,IAAIrC,GACLA,GAA+BqC,UAC1C,CACA,WAAAjpD,CAAY2kD,GACR,OAAO/0E,KAAKo4E,qBAAqBh4E,IAAI20E,IAAoB/B,eAC7D,CACA,OAAAwC,GACIx1E,KAAKs5E,wBACLt5E,KAAKu5E,mBACT,CACA,eAAAhB,CAAgBxD,GACZ,MAAMyE,EAA0Bx5E,KAAKo4E,qBAAqBh4E,IAAI20E,GAC9D,GAAIyE,EAAyB,CACzB,MAAM,gBAAExG,GAAoBwG,GACpBt9E,SAAU87E,GAAmBhF,EAAgBqC,sBAC7ClmD,QAAS8oD,GAAkBD,EACnCh4E,KAAKy5E,kCAAkCxB,GACvCjF,EAAgBwC,UAChBx1E,KAAKo4E,qBAAqB50E,OAAOuxE,EACrC,CACJ,CACA,iBAAAwE,GAC+B76E,MAAM6D,KAAKvC,KAAKo4E,qBAAqB52E,QAC7CP,QAAS8zE,GAAsB/0E,KAAKu4E,gBAAgBxD,GAC3E,CACA,gDAAA2D,CAAiD1D,GAE7C,OADmCt2E,MAAM6D,KAAKvC,KAAKo4E,qBAAqBz9D,UACtC7F,OAAO,EAAGk+D,sBACxC,MAAM,SAAE92E,GAAa82E,EAAgBqC,qBACrC,OAAOn5E,EAASmN,KAAO2rE,GAE/B,CACA,MAAA6D,CAAO7D,GACsBh1E,KAAK04E,iDAAiD1D,GAC9D/zE,QAAQ,EAAG+xE,kBAAiB1/B,aAAY+kC,0BACrDr4E,KAAKu4E,gBAAgBvF,EAAgB9jD,YACrC,MAAMwqD,GAAoB,IAAAf,+BAA8B3D,GACxDh1E,KAAKo1E,eAAe9hC,EAAY,IACzB+kC,EACHhD,qBAAsB,IACfqE,MAInB,CACA,kBAAAC,GACI,EAAA/kD,YAAYnK,iBAAiB,SAAUmvD,mBAAoB55E,KAAKs4E,2BACpE,CACA,qBAAAgB,GACI,EAAA1kD,YAAY9J,oBAAoB,SAAU8uD,mBAAoB55E,KAAKs4E,2BACvE,CACA,8BAAAH,CAA+BhpD,GAC3BA,EAAQ1E,iBAAiB8oD,GAAS1iC,gBAAiB7wC,KAAKw4E,wBACxD,MAAMqB,EAAmBz3B,IACrB,MAAQlzB,WAAY8lD,GAAqB5yB,EAAIrtB,OAC7C/0B,KAAK64E,OAAO7D,IAEhB7lD,EAAQ1E,iBAAiB8oD,GAASuG,uBAAwBD,GAC1D,MAAME,EAAoB33B,IACtB,MAAQlzB,WAAY8lD,GAAqB5yB,EAAIrtB,OAC7C/0B,KAAK64E,OAAO7D,IAEhB7lD,EAAQ1E,iBAAiB8oD,GAAS52C,2BAA4Bo9C,GAC9D5qD,EAAQ1E,iBAAiB8oD,GAASziC,iBAAkB9wC,KAAK84E,yBACzD3pD,EAAQ0qD,gBAAkBA,EAC1B1qD,EAAQ4qD,iBAAmBA,CAC/B,CACA,iCAAAN,CAAkCtqD,GAC9BA,EAAQrE,oBAAoByoD,GAAS1iC,gBAAiB7wC,KAAKw4E,wBAC3DrpD,EAAQrE,oBAAoByoD,GAASziC,iBAAkB9wC,KAAK84E,yBAC5D3pD,EAAQrE,oBAAoByoD,GAASuG,uBAAwB3qD,EAAQ0qD,iBACrE1qD,EAAQrE,oBAAoByoD,GAAS52C,2BAA4BxN,EAAQ4qD,yBAClE5qD,EAAQ0qD,uBACR1qD,EAAQ4qD,gBACnB,CACA,WAAAX,GACIp5E,KAAK25E,oBACT,EAEJ,MAAMzB,GACF,WAAAz4E,EAAY,kBAAEs1E,EAAiB,qBAAEM,EAAoB,OAAE3vC,EAxjBnB,IAwjB2D,SAAE9V,EAAW,CAAC,EAAG,GAAE,WAAEmkD,EAAU,QAAEzL,IAC5HtoE,KAAKg6E,gBAAkB,KACvBh6E,KAAKi6E,iBAAmB,KACxBj6E,KAAKk6E,kBAAoB,KACzBl6E,KAAKm6E,kBAAmB,EACxBn6E,KAAKo6E,QAAU,EACfp6E,KAAKq6E,UAAW,EAChBr6E,KAAKs6E,aAAc,EACnBt6E,KAAKu6E,YAAcxF,GAAqB,qBACxC/0E,KAAKw6E,sBAAwBnF,EAC7Br1E,KAAKy6E,SAAWnS,EAChBtoE,KAAK0lC,OAASA,EACd1lC,KAAK4vB,SAAWA,EAChB5vB,KAAK+zE,WAAaA,EAClB/zE,KAAK0wD,SAAU,EACf1wD,KAAK06E,0BAA4B16E,KAAK06E,0BAA0BlqE,KAAKxQ,MACrEA,KAAK26E,wBAA0B36E,KAAK26E,wBAAwBnqE,KAAKxQ,MACjEA,KAAK46E,uBAAyB56E,KAAK46E,uBAAuBpqE,KAAKxQ,MAC/DA,KAAK66E,mBAAqB76E,KAAK66E,mBAAmBrqE,KAAKxQ,MACvDA,KAAK86E,sBAAwB,EAAAC,EAAA,GAAS/6E,KAAKg7E,gBAAgBxqE,KAAKxQ,MAAO,GACvEA,KAAKo5E,aACT,CACA,wBAAI/D,GACA,OAAOr1E,KAAKw6E,qBAChB,CACA,cAAItrD,GACA,OAAOlvB,KAAKu6E,WAChB,CACA,UAAI70C,GACA,OAAO1lC,KAAKo6E,OAChB,CACA,UAAI10C,CAAOA,GACHzoC,KAAK6e,IAAI9b,KAAKo6E,QAAU10C,GAAU,OAClC1lC,KAAKo6E,QAAU10C,EACf1lC,KAAKq6E,UAAW,EAExB,CACA,MAAAxD,GACI,MAAM,OAAEnxC,EAAM,SAAE9V,EAAQ,QAAE8gC,GAAY1wD,MAChC,SAAE9D,GAAa8D,KAAKg6E,iBACpB,QAAE7qD,GAAYjzB,EACdsuB,EAAO,EAAIkb,GACVpoC,EAAGE,GAAKoyB,EACX5vB,KAAKq6E,WACLr6E,KAAK86E,uBACL96E,KAAKq6E,UAAW,GAEpBz6E,OAAO23E,OAAOpoD,EAAQO,MAAO,CACzBqjD,QAASriB,EAAU,QAAU,SAC7B9zD,MAAO,GAAG4tB,MACV3tB,OAAQ,GAAG2tB,MACX+3C,MAAU78B,EAAJ,KACN/wB,KAAS+wB,EAAJ,KACLjpC,UAAW,aAAaa,QAAQE,SAEhCwC,KAAKm6E,mBACLn6E,KAAKi7E,iBACL/+E,EAASD,SAEjB,CACA,OAAAu5E,GACI,MAAM,SAAEt5E,GAAa8D,KAAKg6E,iBACpB,QAAE7qD,GAAYjzB,EACdyd,EAAkBzd,EAASiyB,qBACjCnuB,KAAKs5E,sBAAsBnqD,GAC3BxV,EAAgBiY,eAAe11B,EAASmN,IACpC8lB,EAAQ+rD,YACR/rD,EAAQ+rD,WAAW7H,YAAYlkD,EAEvC,CACA,sBAAAyrD,CAAuBx4B,GACnB,MAAQ83B,kBAAmBiB,GAAqBn7E,MAC1C,YAAE0kD,EAAW,SAAEd,EAAQ,KAAEw3B,EAAI,oBAAEC,GAAwBj5B,EAAIrtB,OACjE,GAAI/0B,KAAKi6E,kBAAkB5wE,KAAOq7C,EAGlC,OAAQ02B,GACJ,KAAK,EAAA1qC,UAAUH,OACX4qC,EAAiBG,cAAc13B,EAAUy3B,GACzC,MACJ,KAAK,EAAA3qC,UAAUF,QACX2qC,EAAiBI,eAAe33B,GAChC,MACJ,KAAK,EAAAlT,UAAUD,QACX0qC,EAAiBK,eAAe53B,GAChC,MACJ,KAAK,EAAAlT,UAAU+qC,SACXN,EAAiBO,gBAAgB93B,GACjC,MACJ,QACI,MAAM,IAAIxlD,MAAM,qBAAqBg9E,MAEjD,CACA,oBAAAO,CAAqB9I,GACjB,MAAM32E,EAAW22E,EAAeD,cAAc,qBACxCn3E,EAASo3E,EAAeD,cAAc,uBAC5C12E,EAASwzB,MAAMksD,aAAe,UAC9BngF,EAAOi0B,MAAMksD,aAAe,SAChC,CACA,mBAAAC,GACI,MAAMhJ,EAAiBzjD,SAASC,cAAc,QACxC,OAAEqW,GAAW1lC,KACbwqB,EAAgB,EAATkb,EAcb,OAbAmtC,EAAeC,UAAUxvE,IAhqBP,uBAiqBlB1D,OAAO23E,OAAO1E,EAAenjD,MAAO,CAChCqjD,QAAS,QACTn2E,MAAO,GAAG4tB,MACV3tB,OAAQ,GAAG2tB,MACXoF,SAAU,WACVksD,SAAU,SACVF,aAAc,MACdG,UAAW,aACXxZ,MAAU78B,EAAJ,KACN/wB,KAAS+wB,EAAJ,KACLjpC,UAAW,gCAERo2E,CACX,CACA,iCAAAmJ,CAAkC9/E,EAAU82E,EAAiBe,GACzD,MAAM,cAAEvO,GAAkBtpE,EAASumB,YAEnC,OAAO+iD,GAAiB,EAAIuO,IADRf,EAAgBv3E,OAAOwgF,YAAc//E,EAAST,OAAOwgF,YAE7E,CACA,gBAAAC,CAAiBhgF,GACb,MAAO,aAAcA,CACzB,CACA,iBAAAigF,CAAkBjgF,GACd,MAAO,eAAgBA,CAC3B,CACA,gBAAAkgF,CAAiBpE,EAAgBhF,GAC7B,MAAMqJ,EAAerE,EAAep1D,YAC9B05D,EAAqB,GAAGtJ,EAAgB3pE,eACxCkzE,GAAkB,IAAAvU,yBAAwBgQ,EAAe3uE,GAAI2uE,EAAe9pD,mBAC5EitD,EAAmBoB,EAAgB5yD,MAAM2yD,EAAqB14B,IAChE,MAAM44B,EAAeD,EAAgBhM,gBAAgB3sB,GAGrD,OAFyB44B,aAAwB,SAC3CA,aAAwB5I,MAYlC,OATAuH,EAAiBsB,YAAYzJ,EAAgB3pE,GAAI2pE,EAAgB9kD,mBACjEmuD,EAAavnE,OAAO0+D,IAAgBvyE,QAASkV,KACzC,KAAAumE,gCAA+B18E,KAAKkvB,WAAY,CAC5C,CACIytD,eAAgBxmE,EAAM0M,aACtB/b,KAAM,EAAA81E,4BAA4BC,cAIvC,CAAEN,kBAAiBpB,mBAC9B,CACA,WAAA2B,CAAY9E,EAAgBhF,GACxB,MAAM5sE,EAAW4xE,EAAexhD,cAChCw8C,EAAgB/1C,SAAS72B,GAAUrB,KAAK,KACpC/E,KAAKm6E,kBAAmB,EACxBn6E,KAAK62E,UAEb,CACA,aAAAkG,CAAc/E,EAAgBhF,GAC1B,MACMgK,EADShF,EAAep1D,YAEzB9N,OAAQqB,IAAWq9D,GAAer9D,IAClC9P,IAAK8P,IAAU,CAAGrL,SAAUqL,EAAM0M,gBAKvC,OAJAmwD,EAAgBhhD,WAAWgrD,GAAkBj4E,KAAK,KAC9C/E,KAAKm6E,kBAAmB,EACxBn6E,KAAK62E,WAEF7D,CACX,CACA,cAAAiK,CAAejF,EAAgBnF,GAC3B,MAAQ3jD,WAAY6lD,GAAsB/0E,KACpC2Z,EAAkBq+D,EAAe7pD,sBAC/B/pB,QAAS84E,GAA0BlF,EACrC3nD,EAAgB,CAClBlB,QAAS0jD,EACT3jD,WAAY6lD,EACZjuE,KAAMkxE,EAAelxE,KACrB2pB,eAAgB,IAAKysD,IAEzBvjE,EAAgBgX,cAAcN,GAC9B,MAAM2iD,EAAmBr5D,EAAgByW,YAAY2kD,GACjD/0E,KAAKk8E,iBAAiBlE,GACtBh4E,KAAK88E,YAAY9E,EAAgBhF,GAE5BhzE,KAAKm8E,kBAAkBnE,IAC5Bh4E,KAAK+8E,cAAc/E,EAAgBhF,GAEvChzE,KAAK27E,qBAAqB9I,GAC1B,MAAMsK,EAAan9E,KAAKo8E,iBAAiBpE,EAAgBhF,GACzDhzE,KAAKi6E,iBAAmBkD,EAAWZ,gBACnCv8E,KAAKk6E,kBAAoBiD,EAAWhC,gBACxC,CACA,yBAAAiC,CAA0Bh7B,GACtBA,EAAI8wB,kBACJ9wB,EAAIoV,gBACR,CACA,uBAAAmjB,CAAwBv4B,GACpB,MAAM,QAAEjzB,GAAYnvB,KAAKg6E,gBAAgB99E,SACzCkzB,SAAStE,oBAAoB,UAAW9qB,KAAK26E,yBAC7CxrD,EAAQ1E,iBAAiB,UAAWzqB,KAAKo9E,2BACzCjuD,EAAQ1E,iBAAiB,YAAazqB,KAAKo9E,0BAC/C,CACA,yBAAA1C,CAA0Bt4B,GACtB,MAAM,QAAEjzB,GAAYnvB,KAAKg6E,gBAAgB99E,SACzC8D,KAAKs6E,cAAgBl4B,EAAIj4B,QAAQkzD,QAAQ,wBACzCjuD,SAAS3E,iBAAiB,UAAWzqB,KAAK26E,yBAC1CxrD,EAAQrE,oBAAoB,UAAW9qB,KAAKo9E,2BAC5CjuD,EAAQrE,oBAAoB,YAAa9qB,KAAKo9E,0BAClD,CACA,kBAAAvC,CAAmBz4B,GACf,IAAK,KAAM8a,sBACP,OAEJ,MAAQud,SAAUnS,GAAYtoE,KAC9B,IAAKsoE,EAAQxf,UAAY9oD,KAAKs6E,YAC1B,OAEJ,MAAM,cAAEt0B,GAAkB5D,EAAIrtB,QACxB,SAAE74B,GAAa8D,KAAKg6E,iBACpB,cAAE5oD,GAAkBl1B,GAClBT,OAAQ6hF,GAAkBt3B,GAC1BtgB,OAAQ63C,GAAkBv9E,KAC5Bq2E,EAAe,CAACkH,EAAeA,GAC/BC,GAAO,KAAAzgC,iBAAgBs5B,EAAciH,GACrCjoC,EAAUkoC,EAAgBjV,EAAQ2L,QACxC,GAAIuJ,GAAQnoC,EACR,OAEJ,MAAMooC,EAAUD,EAAOnoC,EACjBqoC,EAAiB,SAAS,cAAeJ,EAAejH,GAC9D,eAAeqH,EAAgBA,GAC/B,WAAWA,EAAgBA,EAAgBD,GAC3C,MAAME,EAAoB,SAAS,cAAe39E,KAAK4vB,SAAU8tD,GAC3DE,EAAkBxsD,EAAcpxB,KAAK4vB,UACrCiuD,EAAczsD,EAAcusD,GAC5BG,EAAgB,SAAS,cAAeD,EAAaD,GACrDG,EAAsB,CACxBtvE,OAAQ,CACJuvE,gBAAiB,CACbviF,OAAQuE,KAAK4vB,SACb6zB,MAAOm6B,GAEXzoD,YAAa,CACT15B,OAAQkiF,EACRl6B,MAAOo6B,IAGftoE,MAAO,CACH9Z,OAAQiiF,EACRj6B,MAAOq6B,IAGfxV,EAAQpnE,SAAS68E,EACrB,CACA,yBAAAE,CAA0B9uD,GACtBC,SAAS3E,iBAAiB,YAAazqB,KAAK06E,2BAA2B,GACvEvrD,EAAQ1E,iBAAiB,YAAazqB,KAAKo9E,2BAC3CjuD,EAAQ1E,iBAAiB,UAAWzqB,KAAKo9E,2BACzCjuD,EAAQ1E,iBAAiB,YAAazqB,KAAKo9E,2BAC3CjuD,EAAQ1E,iBAAiB,WAAYzqB,KAAKo9E,0BAC9C,CACA,4BAAAc,CAA6B/uD,GACzBC,SAAStE,oBAAoB,YAAa9qB,KAAK06E,2BAA2B,GAC1EtrD,SAAStE,oBAAoB,UAAW9qB,KAAK26E,yBAC7CxrD,EAAQrE,oBAAoB,YAAa9qB,KAAKo9E,2BAC9CjuD,EAAQrE,oBAAoB,UAAW9qB,KAAKo9E,2BAC5CjuD,EAAQrE,oBAAoB,YAAa9qB,KAAKo9E,2BAC9CjuD,EAAQrE,oBAAoB,WAAY9qB,KAAKo9E,0BACjD,CACA,kBAAAzD,CAAmBxqD,GACf,EAAAyF,YAAYnK,iBAAiB,SAAU0zD,kBAAmBn+E,KAAK46E,wBAC/DzrD,EAAQ1E,iBAAiB,SAAUq3C,WAAY9hE,KAAK66E,oBACpD1rD,EAAQ1E,iBAAiB,SAAU4yC,WAAYr9D,KAAK66E,oBACpD76E,KAAKi+E,0BAA0B9uD,EACnC,CACA,qBAAAmqD,CAAsBnqD,GAClB,EAAAyF,YAAY9J,oBAAoB,SAAUqzD,kBAAmBn+E,KAAK46E,wBAClEzrD,EAAQ1E,iBAAiB,SAAUq3C,WAAY9hE,KAAK66E,oBACpD1rD,EAAQ1E,iBAAiB,SAAU4yC,WAAYr9D,KAAK66E,oBACpD76E,KAAKk+E,6BAA6B/uD,EACtC,CACA,WAAAiqD,GACI,MAAQoB,sBAAuBnF,GAAyBr1E,MAChD9D,SAAU87E,GAAmB3C,GAC7B55E,OAAQ2iF,GAAiBpG,EAC3BnF,EAAiB7yE,KAAK67E,sBAC5BuC,EAAalD,WAAWprD,YAAY+iD,GACpC7yE,KAAK25E,mBAAmB9G,GACxB7yE,KAAKi9E,eAAejF,EAAgBnF,GACpC7yE,KAAKg6E,iBAAkB,IAAAj/C,mBAAkB83C,EAC7C,CACA,qBAAAwL,CAAsBrG,EAAgBhF,GAClC,MAAM1xD,EAAW02D,EAAe5mD,cAAcpxB,KAAK4vB,UAC7C41C,EAAgBxlE,KAAKg8E,kCAAkChE,EAAgBhF,EAAiBhzE,KAAK+zE,aAC7F,WAAEpxD,EAAU,SAAEiN,EAAQ,gBAAErO,GAAoByxD,EAAgBvwD,YAC5DzG,EAAW/e,KAAKopC,KAAKppC,KAAKotD,IAAI1nC,EAAW,GAAKiN,EAAS,GAAI,GAC7D3yB,KAAKotD,IAAI1nC,EAAW,GAAKiN,EAAS,GAAI,GACtC3yB,KAAKotD,IAAI1nC,EAAW,GAAKiN,EAAS,GAAI,IACpC+zB,EAAoB,CACtBriC,EAAS,GACTA,EAAS,GACTA,EAAS,IAEPoiC,EAAkB,CACpBC,EAAkB,GAAK3nC,EAAWuF,EAAgB,GAClDoiC,EAAkB,GAAK3nC,EAAWuF,EAAgB,GAClDoiC,EAAkB,GAAK3nC,EAAWuF,EAAgB,IAEtDyxD,EAAgBjxC,UAAU,CACtByjC,gBACA7iD,WAAYghC,EACZ/zB,SAAU8zB,GAElB,CACA,mBAAA46B,CAAoBtG,EAAgBhF,GAChCA,EAAgBuL,gBAAgBvG,EAAethD,yBACnD,CACA,cAAAukD,GACI,MAAQ/+E,SAAU87E,GAAmBh4E,KAAKw6E,uBAClCt+E,SAAU82E,GAAoBhzE,KAAKg6E,gBACrCwE,EAAmBxG,EAAe1wD,gBACtB0rD,EAAgBz6C,iBAIlCy6C,EAAgB7gD,cAAcqsD,GAC9Bx+E,KAAKq+E,sBAAsBrG,EAAgBhF,GACvChzE,KAAKk8E,iBAAiBlE,IACtBh4E,KAAKs+E,oBAAoBtG,EAAgBhF,GAE7ChzE,KAAKq+E,sBAAsBrG,EAAgBhF,GAC3CA,EAAgB/2E,SACpB,CACA,eAAA++E,GACI,MAAM,SAAE9+E,GAAa8D,KAAKg6E,gBACF99E,EAASiyB,qBACjBswD,QACpB,EAEJ7K,GAAoBhwB,SAAW,kB,eCr5B/B,MAAM,QAAEjiC,IAAY,EAAA8xC,UACpB,MAAMirB,WAAuBC,GAAA7zC,EACzB,WAAArrC,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXuoE,iBAAkB,GAClB4J,6BAA6B,EAC7BC,mBAAmB,KAGvBv9B,MAAMS,EAAWC,GACjBhiD,KAAK29D,SAAW,KAChB39D,KAAK8+E,MAAQ,KACT,MACMnlE,GADmB,IAAAolE,uBACgB,GACzC,IAAKplE,EACD,OAEJ,IAAIC,EAAYD,EAAgByc,eAChCxc,GAAY,IAAAolE,gCAA+BplE,EAAW5Z,KAAKg1D,eAC3D,MAAMgjB,EAAiBr+D,EAAgByW,YAAYpwB,KAAKyM,cAAcuoE,kBACtE,IAAKgD,GAAgBz/C,eACjB,OAEJ,MAAM,QAAEpJ,GAAY6oD,GACd,OAAEhzC,EAAM,gBAAEzjB,GAAoBy2D,EAAev1D,YAC7Cw8D,EAAqC,2CAAuCjH,GAClF,IAAI1kC,EAAatzC,KAAK29D,UAAUrqB,WAChC,MAAMtpC,EAAsBguE,EAAezW,yBAC3C,GAAKjuB,EAqBDtzC,KAAK29D,SAASrqB,WAAWpmC,KAAK+nD,QAAQxmD,OAClCwwE,MAtBS,CACb,MAAMjJ,EAAgB,CAClBnhB,aAAa,EACbt5D,aAAa,EACb2L,SAAU,CACN08C,SAAU5jD,KAAKg1D,cACfzzC,gBAAiB,IAAIA,GACrByjB,OAAQ,IAAIA,GACZh7B,sBACAzD,kBAAmB,MAEvB2G,KAAM,CACF+nD,QAAS,CACLxmD,OAAQwwE,MAIpB,IAAA5pB,eAAc2gB,EAAe7mD,GAC7BmkB,EAAa0iC,CACjB,CAKAh2E,KAAK29D,SAAW,CACZqX,iBAAkBgD,EAAe3uE,GACjCsQ,kBACA25B,eAEJ,EAAAyjB,EAAA,GAAsCn9C,EACjC9E,OAAQ5Y,GAAaA,EAASmN,KAAO2uE,EAAe3uE,IACpDhD,IAAKnK,GAAaA,EAASmN,MAEpCrJ,KAAK+pD,iBAAmB,KACpB/pD,KAAK8+E,SAET9+E,KAAK8pD,uBAAyB,KAC1B9pD,KAAK8+E,SAET9+E,KAAKgqD,iBAAoB5H,IACrBpiD,KAAK8+E,SAET9+E,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,MAAQ/7D,SAAU+xB,GAAmB3yB,EACrC,IAAK0E,KAAK29D,SACN,OAAO,EAEX,MAAM,WAAErqB,EAAU,iBAAE0hC,GAAqBh1E,KAAK29D,SAC9C,IAAIjF,GAAe,EACnB,MAAQx8D,SAAU87E,IAAmB,IAAAW,+BAA8B3D,IAAqB,CAAC,EACzF,IAAKgD,EACD,OAAOtf,EAEX,GAAIsf,EAAe3uE,KAAO4kB,EAAe5kB,GACrC,OAAOqvD,EAEX,IAAKplB,IAAeA,GAAYpmC,MAAM+nD,SAASxmD,OAC3C,OAAOiqD,EAEX,GAAI14D,KAAKyM,cAAcmyE,6BACnB5G,EAAezW,2BACXtzC,EAAeszC,yBACnB,OAAO7I,EAEX,MAAMqJ,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAElC61E,EAAU5rC,EAAWpmC,KAAK+nD,QAAQxmD,OAAO,GACzC4iB,EAAWiiB,EAAWpmC,KAAK+nD,QAAQxmD,OAAO,GAC1C6iB,EAAagiB,EAAWpmC,KAAK+nD,QAAQxmD,OAAO,GAC5C0wE,EAAc7rC,EAAWpmC,KAAK+nD,QAAQxmD,OAAO,IAC7C,WAAEkU,EAAU,gBAAEpB,EAAe,OAAEyjB,GAAW/W,EAAexL,aACvDlB,gBAAiB69D,GAA0BpH,EAAev1D,YAClE,GAAIziB,KAAKq/E,WAAW99D,EAAiB69D,GACjC,OAAO1mB,EAEX,MAAM4mB,EAAsB,iCAA6B/9D,EAAiBoB,GACpE48D,EAAY,CAACL,EAAS5tD,EAAYD,EAAU8tD,GAC5CK,EAAY,CAACN,EAAS7tD,EAAUC,EAAY6tD,GAClD,IAAIM,EAAgBF,EAChBG,EAAe,cAAc,cAAeH,EAAU,GAAIA,EAAU,IACxEG,EAAe,eAAe,cAAeA,GAC7C,IAAIC,EAAc,cAAc,cAAeJ,EAAU,GAAIA,EAAU,IACvEI,EAAc,eAAe,cAAeA,GAC5C,MAAMC,EAAY,WAAW,cAAeF,EAAcC,GAC1D,GAAI3/E,KAAKq/E,WAAWO,EAAWr+D,GAC3B,OAAOm3C,EAEP14D,KAAK6/E,gBAAgBH,EAAcn+D,KACnCk+D,EAAgBD,GAEpB,MAAMM,EAAiB,yCAAqCL,EAAc,GAAIA,EAAc,GAAIH,GAC1FS,EAAe,yCAAqCN,EAAc,GAAIA,EAAc,GAAIH,IACxF,cAAE3qB,GAAkBrhB,EAC1ByuB,EAAepN,cAAgBA,EAC/B,MAAMT,EAAYl0D,KAAKy2E,SAAS,YAAa1U,EAAgBzuB,GACvDsoB,EAAW57D,KAAKy2E,SAAS,WAAY1U,EAAgBzuB,GACrDl3C,EAAQ4D,KAAKy2E,SAAS,QAAS1U,EAAgBzuB,GAC/C+0B,EAASroE,KAAKy2E,SAAS,SAAU1U,EAAgBzuB,GACvD,IAAI0uB,EAAoB,CAAC8d,EAAgBC,GAAc15E,IAAKo9C,GAAUx1B,EAAek1B,cAAcM,IAInG,GAHIzjD,KAAKyM,cAAcoyE,oBACnB7c,EAAoBhiE,KAAKggF,oBAAoB/xD,EAAgB6xD,EAAgBv+D,EAAiByjB,EAAQ+6C,EAAc/d,IAEpHA,EAAkBphE,OAAS,EAC3B,OAAO83D,EAEX,MAAMwJ,EAAS,GAAGvN,SASlB,OAPA,IAAA+G,UAAYzD,EAAkBtD,EADd,IACsCqN,EAAkB,GAAIA,EAAkB,GAAI,CAC9F5lE,QACAQ,MAAOs3D,EACP0H,WACAyM,UACDnG,GACHxJ,GAAe,EACRA,GAEX14D,KAAK6/E,gBAAkB,CAACI,EAAMC,KAC1B,MAAMj5B,EAAM,SAASg5B,EAAMC,GAC3B,OAAOjjF,KAAK6e,IAAImrC,GAAOtlC,GAE/B,CACA,mBAAAq+D,CAAoB/xD,EAAgB6xD,EAAgBv+D,EAAiByjB,EAAQ+6C,EAAc/d,GAC/D/zC,EAAeE,qBAAvC,MACM3H,EAAWxmB,KAAKszE,YAAYrlD,GAC5BkyD,EAAcngF,KAAKogF,mBAAmB55D,GACtCjgB,EAAoBvG,KAAKshE,qBAAqBrzC,EAAgB6xD,EAAgBv+D,EAAiByjB,GACrG,GAAIz+B,GAAqB45E,EACrB,IACI,MAAM,UAAEx7D,EAAS,WAAE9c,GAAes4E,GAC3BE,EAAmBC,EAAoBC,EAAuBC,GAAyB,CAC1F77D,EAAUO,aAAa,CAAC,EAAG,EAAG,IAC9BP,EAAUO,aAAa,CAACrd,EAAW,GAAK,EAAG,EAAG,IAC9C8c,EAAUO,aAAa,CACnBrd,EAAW,GAAK,EAChBA,EAAW,GAAK,EAChB,IAEJ8c,EAAUO,aAAa,CAAC,EAAGrd,EAAW,GAAK,EAAG,KAChDxB,IAAKo9C,GAAU,+BAA2Bl9C,EAAmBk9C,KACxDg9B,EAAqBC,GAAqB,CAC7CZ,EACAC,GACF15E,IAAKo9C,GAAU,+BAA2Bl9C,EAAmBk9C,IAC/Due,EAAoB,CAChB,CAACqe,EAAmBC,GACpB,CAACA,EAAoBC,GACrB,CAACC,EAAsBD,GACvB,CAACF,EAAmBG,IAEnBn6E,IAAI,EAAE3K,EAAOsW,KAAShS,KAAK2gF,uBAAuBjlF,EAAOsW,EAAKyuE,EAAqBC,IACnF5rE,OAAQxG,GAAUA,GAAStO,KAAK4gF,UAAUtyE,EAAOzG,IACjDxB,IAAKiI,IACN,MAAMm1C,EAAQ,+BAA2Bl9C,EAAmB+H,GAC5D,OAAO2f,EAAek1B,cAAcM,IAE5C,CACA,MAAOo9B,GACHzwE,QAAQ6Q,IAAI4/D,EAChB,CAEJ,OAAO7e,CACX,CACA,sBAAA2e,CAAuBG,EAAYC,EAAUC,EAAYC,GACrD,MAAO/4D,EAAI3I,GAAMuhE,GACVthE,EAAIC,GAAMshE,GACVG,EAAIC,GAAMH,GACVI,EAAIC,GAAMJ,EACXK,EAAK7hE,EAAKF,EACVgiE,EAAKr5D,EAAK1I,EACVgiE,EAAKhiE,EAAKD,EAAK2I,EAAKzI,EACpBgiE,EAAKJ,EAAKF,EACVO,EAAKR,EAAKE,EACVO,EAAKP,EAAKD,EAAKD,EAAKG,EAC1B,GAAIpkF,KAAK6e,IAAIwlE,EAAKI,EAAKD,EAAKF,GAAM5/D,GAC9B,OAIJ,MAAO,EAFI4/D,EAAKI,EAAKD,EAAKF,IAAOF,EAAKI,EAAKD,EAAKF,IACrCE,EAAKD,EAAKF,EAAKK,IAAOL,EAAKI,EAAKD,EAAKF,GAEpD,CACA,UAAAlC,CAAWY,EAAMC,GACb,OAAOjjF,KAAK6e,IAAI,SAASmkE,EAAMC,IAAS,EAAIv+D,EAChD,CACA,SAAAi/D,CAAUtyE,EAAOzG,GACb,OAAQyG,EAAM,IAAM,GAChBA,EAAM,IAAMzG,EAAW,IACvByG,EAAM,IAAM,GACZA,EAAM,IAAMzG,EAAW,EAC/B,EAEJ62E,GAAe96B,SAAW,iBAC1B,MChOQjiC,QAAO,IAAK,EAAA8xC,UACpB,MAAMmuB,WAAwBjD,GAAA7zC,EAC1B,WAAArrC,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXo1E,eAAgB,MAGpBvgC,MAAMS,EAAWC,GACjBhiD,KAAK+pD,iBAAmB,KACpB/pD,KAAK8+E,SAET9+E,KAAK4kD,gBAAkB,KACnB5kD,KAAK8+E,SAET9+E,KAAK8+E,MAAQ,KACT,MAAM+C,EAAiB7hF,KAAKyM,cAAco1E,eAC1C,IAAKA,GAAgBjhF,OAEjB,YADAwP,QAAQC,KAAK,gEAGjB,MAAM1J,EAAmB,EAAAysB,SAAA,IAAa,mBAAoByuD,EAAe,IACzE,IAAKl7E,EAED,YADAyJ,QAAQC,KAAK,iEAGjB,MAAM,oBAAElI,GAAwBxB,EAC1Bg+C,GAAgB,IAAAF,cAAazkD,KAAK0kD,aAAaC,cACrD,IAAKA,GAAe/jD,OAEhB,YADAwP,QAAQC,KAAK,uCAGjB,MAAMkkD,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7sD,GACvD,IAAKosD,GAAa3zD,OAAQ,CACtB,MAAMkhF,EAAYD,EAAex7E,IAAKgD,GAC3BrJ,KAAK+hF,0BAA0B14E,IAEpC2sE,EAAgB,CAClBnhB,aAAa,EACbt5D,aAAa,EACb2L,SAAU,CACN08C,SAAU5jD,KAAKg1D,cACfhrD,oBAAqB7B,EACrB5B,kBAAmB,MAEvB2G,KAAM,CACF80E,aAAc,IAAIxwE,IAClBswE,eAGR,IAAAzsB,eAAc2gB,EAAe7tE,EACjC,EACA,EAAA4uD,EAAA,GAAsCpS,EAAct+C,IAAI,EAAG6oB,gBAAiBA,KAEhFlvB,KAAK+hF,0BAA6B59E,IAC9B,MAAM,qBAAE6D,EAAoB,KAAE/I,EAAI,QAAED,EAAO,WAAE4J,EAAU,cAAEC,EAAa,gBAAEnL,EAAe,mBAAEC,GAAwB,EAAAy1B,SAAA,IAAa,mBAAoBjvB,GAC5I+6E,EAAU,IAAIl3E,GACdqpB,EAAW,IAAIrpB,GACfspB,EAAa,IAAItpB,GACjBm3E,EAAc,IAAIn3E,GACxB,iBAAiBqpB,EAAUrpB,EAAsBa,EAAe7J,EAAUrB,GAC1E,iBAAiB2zB,EAAYtpB,EAAsBY,EAAY3J,EAAOvB,GACtE,iBAAiByhF,EAAa7tD,EAAYzoB,EAAe7J,EAAUrB,GAGnE,MAAO,CAAE4hF,UAFS,CAACL,EAAS5tD,EAAYD,EAAU8tD,GAE9BK,UADF,CAACN,EAAS7tD,EAAUC,EAAY6tD,KAGtDn/E,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,MAAM4pB,EAAiB7hF,KAAKyM,cAAco1E,eAC1C,IAAInpB,GAAe,EACnB,IAAKmpB,GAAgBjhF,OACjB,OAAO83D,EAEX,MAAQx8D,SAAU+xB,EAAc,oBAAEjkB,GAAwB1O,EAE1D,GADuB2yB,EAAeuI,cACnB51B,OAAS,EACxB,OAAO83D,EAEX,MAAMnE,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAehrD,GACvD,IAAKuqD,GAAa3zD,OACd,OAAO83D,EAEX,MAAMplB,EAAaihB,EAAY,IACzB,cAAEI,GAAkBrhB,GACpB,WAAE3wB,EAAU,gBAAEpB,GAAoB0M,EAAexL,YACjDs/C,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAElC44E,EAAiBjiF,KAAKkiF,iBAAiBL,EAAe,IAC5D,GAAI7hF,KAAKq/E,WAAW99D,EAAiB0gE,GACjC,OAAOvpB,EAEX,MAAM4mB,EAAsB,iCAA6B/9D,EAAiBoB,GACpEm/D,EAAYxuC,EAAWpmC,KAAK40E,UAC5BE,EAAe1uC,EAAWpmC,KAAK80E,aACrC,IAAK,IAAIt4E,EAAI,EAAGA,EAAIm4E,EAAejhF,OAAQ8I,IAAK,CAC5C,MAAM,UAAE61E,EAAS,UAAEC,GAAcsC,EAAUp4E,GACrCy4E,EAAaH,EAAa5hF,IAAI6tB,EAAe5kB,KAC/CrJ,KAAKoiF,uBAAuBJ,EAAc/zD,EAAe5kB,IAC7D,IAAK84E,EAAWE,eAAe34E,GAAI,CAC/B,IAAI+1E,EAAgBF,EAChBG,EAAe,cAAc,cAAeH,EAAU,GAAIA,EAAU,IACxEG,EAAe,eAAe,cAAeA,GACzC1/E,KAAK6/E,gBAAgBH,EAAcn+D,KACnCk+D,EAAgBD,GAEpB2C,EAAWE,eAAe34E,GAAK+1E,EAC/B0C,EAAWG,gBAAgB54E,GAAK,yCAAqC+1E,EAAc,GAAIA,EAAc,GAAIH,GACzG6C,EAAWI,cAAc74E,GAAK,yCAAqC+1E,EAAc,GAAIA,EAAc,GAAIH,EAC3G,CACA,MAAMQ,EAAiBqC,EAAWG,gBAAgB54E,GAC5Cq2E,EAAeoC,EAAWI,cAAc74E,GAC9Cq4D,EAAepN,cAAgBA,EAC/B,MAAMT,EAAYl0D,KAAKy2E,SAAS,YAAa1U,EAAgBzuB,GACvDsoB,EAAW57D,KAAKy2E,SAAS,WAAY1U,EAAgBzuB,GACrDl3C,EAAQ4D,KAAKy2E,SAAS,QAAS1U,EAAgBzuB,GAC/C+0B,EAASroE,KAAKy2E,SAAS,SAAU1U,EAAgBzuB,GACjD0uB,EAAoB,CAAC8d,EAAgBC,GAAc15E,IAAKo9C,GAAUx1B,EAAek1B,cAAcM,IAC/Fye,EAAS,GAAGvN,SACZ8G,EAAU,GAAG/xD,KACnB,IAAAgyD,UAAYzD,EAAkBtD,EAAe8G,EAASuG,EAAkB,GAAIA,EAAkB,GAAI,CAC9F5lE,QACAQ,MAAOs3D,EACP0H,WACAyM,UACDnG,EACP,CAEA,OADAxJ,GAAe,EACRA,GAEX14D,KAAKoiF,uBAAyB,CAACJ,EAAc34E,KACzC24E,EAAa9hF,IAAImJ,EAAI,CACjBg5E,eAAgB,GAChBC,gBAAiB,GACjBC,cAAe,KAEZP,EAAa5hF,IAAIiJ,IAE5BrJ,KAAK6/E,gBAAkB,CAACI,EAAMC,KAC1B,MAAMj5B,EAAM,SAASg5B,EAAMC,GAC3B,OAAOjjF,KAAK6e,IAAImrC,GAAO,GAE/B,CACA,UAAAo4B,CAAWY,EAAMC,GACb,OAAOjjF,KAAK6e,IAAI,SAASmkE,EAAMC,IAAS,EAAI,EAChD,CACA,gBAAAgC,CAAiB/9E,GACb,MAAM,wBAAE+D,GAA4B,EAAAkrB,SAAA,IAAa,mBAAoBjvB,GAC/DgX,EAAe,gBAAgBjT,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IAC/GkT,EAAe,gBAAgBlT,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IACrH,OAAO,WAAW,cAAeiT,EAAcC,EACnD,EAEJwmE,GAAgBh+B,SAAW,cCzJ3B,MAAM4+B,WAAqC7D,GAAA7zC,EACvC,WAAArrC,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3Cv1C,cAAe,CACXoL,QAAS,MAGbypC,MAAMS,EAAWC,GACjBhiD,KAAK8+E,MAAQ,KACT,MAAMn6B,GAAgB,IAAAF,cAAazkD,KAAK0kD,aAAaC,cACrD,IAAKA,GAAe/jD,OAEhB,YADAwP,QAAQC,KAAKrQ,KAAKg1D,cAAgB,4BAGtC,MAAMmU,GAAgB,IAAAh7C,oBAAmBw2B,EAAc,GAAGz2B,oBAAoBkC,YAAYu0B,EAAc,GAAGz1B,YAC3G,IAAKi6C,EACD,OAEJ,MAAMhhE,EAAsBghE,EAAc5H,yBACpChN,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7sD,GACvD,IAAKosD,GAAa3zD,OAAQ,CACtB,MAAM6hF,EAAuB,IAAIjxE,KAsEjD,SAAmDixE,EAAsB99B,GACrEA,EAAc1jD,QAAQ,EAAGiuB,aAAYhB,wBACjC,MAAMhyB,GAAW,IAAAiyB,oBAAmBD,IAAoBkC,YAAYlB,GACpEwzD,GAAqDD,EAAsBvmF,IAEnF,CA1EgBymF,CAA0CF,EAAsB99B,GAChE,MAAMqxB,EAAgB,CAClBnhB,aAAa,EACbt5D,aAAa,EACb2L,SAAU,CACN08C,SAAU5jD,KAAKg1D,cACfhrD,oBAAqB7B,EACrB5B,kBAAmB,MAEvB2G,KAAM,CACFu1E,0BAGR,IAAAptB,eAAc2gB,EAAe7tE,EACjC,EACA,EAAA4uD,EAAA,GAAsCpS,EAAct+C,IAAI,EAAG6oB,gBAAiBA,KAEhFlvB,KAAK+pD,iBAAmB,KACpB/pD,KAAK8+E,SAET9+E,KAAKgqD,iBAAoB5H,IACrBpiD,KAAK8+E,SAET9+E,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,MAAM,SAAE/7D,EAAQ,oBAAE8N,GAAwB1O,EAC1C,IAAIo9D,GAAe,EACnB,MAAMnE,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAehrD,GACvD,IAAKuqD,GAAa3zD,OACd,OAAO83D,EAEX,MAAMplB,EAAaihB,EAAY,IACzB,cAAEI,GAAkBrhB,EACpBmvC,EAAuB,EAAav1E,KAAKu1E,qBAC/CC,GAAqDD,EAAsBvmF,GAC3E,MAAM0mF,EAAe1mF,EAAS0mB,YACxBigE,EAAUC,GAAW5mF,GA8B3B,OA7BA0mF,EAAa3hF,QAAS8U,IAClB,IAAKA,GAAYgtE,eACb,OAEJ,MAAMC,EAAqBP,EAAqBriF,IAAI2V,EAAW+M,KAC/D,IAAKkgE,EACD,OAEJ,IAAKA,EAAmB5iF,IAAIyiF,GACxB,OAEJ,IAAII,EAAc,EAClB,MAAM,eAAEC,EAAc,MAAE9mF,GAAU4mF,EAAmB5iF,IAAIyiF,GACzD,IAAK,IAAIn5E,EAAI,EAAGA,EAAIw5E,EAAetiF,OAAQ8I,IAAK,CAC5C,MACMy5E,EADcD,EAAex5E,GACFrD,IAAKiI,GAAUpS,EAASinD,cAAc70C,IACjElK,EAAU,CACZhI,MAAOA,EACPgnF,UAAWhnF,EACXinF,YAAarjF,KAAKyM,cAAcoL,QAChCyrE,WAAW,EACXpvB,UAAW,GAETqvB,EAAcxtE,EAAW+M,IAAM,IAAMmgE,GAC3C,IAAAO,UAASvrB,EAAkBtD,EAAe4uB,EAAaJ,EAAc/+E,GACrE6+E,GACJ,IAEJvqB,GAAe,EACRA,EAEf,EAQJ,SAASgqB,GAAqDD,EAAsBvmF,GAChF,MAAM0mF,EAAe1mF,EAAS0mB,YACxBigE,EAAUC,GAAW5mF,GAC3B0mF,EAAa3hF,QAAS8U,IAClB,IAAKA,GAAYgtE,eACb,OAEJ,IAAIU,EAAsBhB,EAAqBriF,IAAI2V,EAAW+M,KAK9D,GAJK2gE,IACDA,EAAsB,IAAIjyE,IAC1BixE,EAAqBviF,IAAI6V,EAAW+M,IAAK2gE,KAExCA,EAAoBrjF,IAAIyiF,GAAU,CACnC,MACMK,EAAiB,EADNntE,EAAWgtE,eAAeW,iBAE3C,IAAKR,EACD,OAEJ,MACM9mF,EAUlB,SAAuBunF,GACnB,SAASC,EAAuBC,GAC5B,IAAIC,EAAkB7mF,KAAK+Q,MAAkB,IAAZ61E,GAAiB7iE,SAAS,IAI3D,OAH+B,IAA3B8iE,EAAgBljF,SAChBkjF,EAAkB,IAAMA,GAErBA,CACX,CACA,MAAQ,IACJF,EAAuBD,EAAW,IAClCC,EAAuBD,EAAW,IAClCC,EAAuBD,EAAW,GAC1C,CAtB0BI,CADKhuE,EAAWI,MAAMoB,cAAcysE,YAElDP,EAAoBvjF,IAAI2iF,EAAS,CAAEK,iBAAgB9mF,SACvD,GAER,CACA,SAAS0mF,GAAW5mF,GAChB,MAAM,gBAAEqlB,GAAoBrlB,EAASumB,YAC/BS,EAAahnB,EAASw6B,yBAC5B,MAAO,GAAGx6B,EAASmN,MCpIhB,SAAuBiF,EAAO21E,EAAW,GAC5C,OAAQxtE,WAAWnI,EAAM,IAAIivB,QAAQ0mD,GACjC,IACAxtE,WAAWnI,EAAM,IAAIivB,QAAQ0mD,GAC7B,IACAxtE,WAAWnI,EAAM,IAAIivB,QAAQ0mD,GAC7B,GACR,CD6H6BC,CAAc3iE,MAAoB2B,GAC/D,CA0CAs/D,GAA6B5+B,SAAW,2BEpKxC,MAAMugC,WAAyBxF,GAAA7zC,EAC3B,WAAArrC,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX47D,QAAQ,EACR+b,2BAA2B,EAC3BC,iBAAkB,EAClBC,cAAc,EACdC,eAAe,KAGnBjjC,MAAMS,EAAWC,GACjBhiD,KAAKqhE,WAAY,EACjBrhE,KAAKwkF,sBAAuB,EAC5BxkF,KAAKykF,mBAAqB,KAC1BzkF,KAAK0kF,4BAA8B,KACnC1kF,KAAK2kF,uBAAyB,KAC9B3kF,KAAK4kF,uBAAwB,EAC7B5kF,KAAK03D,kBAAqBtV,IACtB,MAAM,OAAErtB,GAAWqtB,GACb,QAAEjzB,EAAO,cAAE62B,GAAkBjxB,EACnC/0B,KAAK0kF,4BAA8B1+B,EAAcvC,MACjDzjD,KAAK2kF,uBAAyB3+B,EAAcvqD,OAC5CuE,KAAKykF,mBAAqBt1D,EAC1B,MAAMmkB,EAAatzC,KAAK6kF,oBAAoB11D,GAC5C,OAAmB,OAAfmkB,GACAtzC,KAAK8kF,wBAAwB9+B,EAAcvC,MAAOt0B,IAC3C,IAEXnvB,KAAK+kF,yBAAyB51D,EAASmkB,IAChC,IAEXtzC,KAAK8kF,wBAA0B,CAACxjE,EAAU6N,KACtC,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,GACzC,IAAK7zB,EACD,MAAM,IAAI8C,MAAM,4BAEpB,MAAM,SAAElC,EAAQ,gBAAEyd,GAAoBre,EACtC0E,KAAKqhE,WAAY,EACjB,MAAM7+C,EAAStmB,EAASumB,aAClB,gBAAElB,EAAe,OAAEyjB,GAAWxiB,EACpC,IAAKjB,IAAoByjB,EACrB,MAAM,IAAI5mC,MAAM,oBAEpB,MAAMmI,EAAoBvG,KAAKshE,qBAAqBplE,EAAUolB,EAAUC,EAAiByjB,GACnFh7B,EAAsB9N,EAASqlE,yBAC/BjuB,EAAa,CACfuhB,aAAa,EACbt5D,aAAa,EACb2L,SAAU,CACN08C,SAAU5jD,KAAKg1D,cACfzzC,gBAAiB,IAAIA,GACrByjB,OAAQ,IAAIA,GACZh7B,sBACAzD,qBAEJ2G,KAAM,CACF0mB,MAAO,GACPqhC,QAAS,CACLxmD,OAAQ,CAAC,IAAI6S,IACb4zD,kBAAmB,KACnB8P,QAAS,CACL9O,UAAU,EACV+O,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChB7tD,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB6tD,YAAa,CAAC,EAAG,EAAG,QAOxC,IADoB,IAAAhjB,gBAAen8D,KAAKg1D,cAAe7lC,GACvCvuB,OAAS,EACrB,OAAO,KAGX,GAAqB,QADA,IAAAy0D,eAAc/hB,EAAYnkB,GAE3C,OAEJ,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAAe,IACxF,EAAA+B,EAAA,GAAsC8G,IAE1C79D,KAAKgqD,iBAAoB5H,IACrB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,EAAO,eAAEg2D,EAAc,OAAE3iE,GAAWuO,EAEtC70B,GADiB,IAAA6+B,mBAAkB5L,GACTjzB,SAChC,GAAIizB,IAAYnvB,KAAKykF,mBACjB,OAEJ,MAAMW,EAAgBD,EAAexiE,WAC/B0iE,EAAe7iE,EAAOjB,gBACtBsgB,EAAgBrf,EAAOG,WACvBqnD,EAAwB,CAAC,EAAG,EAAG,GAErC,GADA,eAAiBnoC,EAAeujD,EAAepb,GACU,IAArDA,EAAsBrpC,OAAO,CAACzkB,EAAGhF,IAAMgF,EAAIhF,EAAG,GAC9C,OAEJ,MAAMwK,EAAa,UAAYsoD,EAAuBqb,GACtD,GAAIpoF,KAAK6e,IAAI4F,GAAc,IACvB,OAEJ,IAAK1hB,KAAK2kF,uBACN,OAEJ,MAAM9G,EAAc3hF,EAASk1B,cAAcpxB,KAAK2kF,wBAChD3kF,KAAK0kF,4BAA8B7G,EACnC79E,KAAK+kF,yBAAyB51D,EAASnvB,KAAK6kF,oBAAoB11D,KAEpEnvB,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,EAAQ,oBAAE8N,GAAwB1O,EACpCgqF,EAAsBtlF,KAAKykF,qBAAuBvoF,EAASizB,QAC7DnvB,KAAKyM,cAAc63E,eAAiBgB,GACpCtlF,KAAKulF,oBAAoBrpF,GAE7B,MAAM,QAAEizB,GAAYjzB,EACpB,IAAIq4D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAGX,GADAnE,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAAO83D,EAEX,MAAMqJ,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6qD,EAAY3zD,OAAQ8I,IAAK,CACzC,MAAM4pC,EAAaihB,EAAY7qD,IACzB,cAAEirD,EAAa,KAAEznD,GAASomC,GAC1B,QAAE2hB,GAAY/nD,GACd,OAAEuB,GAAWwmD,EACnB,IAAKN,EACD,OAAO+D,EAEXqJ,EAAepN,cAAgBA,EAC/B,MAAM6wB,EAAgB/uE,WAAWzW,KAAKy2E,SAAS,YAAa1U,EAAgBzuB,IACtE4gB,EACAsxB,EAEA5pB,EAAW57D,KAAKy2E,SAAS,WAAY1U,EAAgBzuB,GACrDl3C,EAAQ4D,KAAKy2E,SAAS,QAAS1U,EAAgBzuB,GACrD,GAAI7kC,EAAO,GAAGwa,KAAMvZ,GAAM8M,MAAM9M,IAC5B,OAAOgpD,EAEX,MAAMsJ,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IACnE,IAAKxS,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,KAAK,KAAAie,qBAAoBhiB,GACrB,SAEJ,MAAM8wB,EAAgB,CAClB3lE,MAAO,QACP4lE,MAAO,QACP7lE,MAAO,QACP0iD,KAAM,SAEHjlE,EAAGE,GAAKwkE,EAAkB,GAC3B2jB,EAAcL,EAAsB,GAAK,EACzCM,EAAaN,EAAsB,EAAI,GAC7C,IAAA5pB,UAASzD,EAAkBtD,EAAe8wB,EAAc3lE,MAAO,CAACxiB,EAAGE,GAAKmoF,EAAc,EAAIC,IAAc,CAACtoF,EAAGE,EAAImoF,EAAc,GAAI,CAAEvpF,QAAOw/D,WAAU1H,eACrJ,IAAAwH,UAASzD,EAAkBtD,EAAe8wB,EAAc5lE,MAAO,CAACviB,EAAGE,GAAKmoF,EAAc,EAAIC,IAAc,CAACtoF,EAAGE,EAAImoF,EAAc,GAAI,CAAEvpF,QAAOw/D,WAAU1H,eACrJ,IAAAwH,UAASzD,EAAkBtD,EAAe8wB,EAAcC,MAAO,CAACpoF,GAAKqoF,EAAc,EAAIC,GAAapoF,GAAI,CAACF,EAAIqoF,EAAc,EAAGnoF,GAAI,CAAEpB,QAAOw/D,WAAU1H,eACrJ,IAAAwH,UAASzD,EAAkBtD,EAAe8wB,EAAcljB,KAAM,CAACjlE,GAAKqoF,EAAc,EAAIC,GAAapoF,GAAI,CAACF,EAAIqoF,EAAc,EAAGnoF,GAAI,CAAEpB,QAAOw/D,WAAU1H,cACpJwE,GAAe,CACnB,CACA,OAAOA,GAEX14D,KAAK4kF,sBAAwB5kF,KAAKyM,cAAc83E,aACpD,CACA,eAAA3/B,GAEI,GADA5kD,KAAK4kF,sBAAwB5kF,KAAKyM,cAAc83E,eAC3CvkF,KAAK4kF,sBACN,OAEJ,MAAM/qE,GAAc,IAAA4qC,cAAazkD,KAAK0kD,aAAaC,cACnD,IAAK9qC,EACD,OAEoBA,EAAYxT,IAAKqJ,IAAM,IAAAo1C,wBAAuBp1C,EAAEwf,WAAYxf,EAAEwe,oBACtEjtB,QAASkuB,IACjBA,IACA,KAAAooC,mBAAkBpoC,EAAQjzB,SAASizB,UAG/C,CACA,iBAAAk2B,GACI,IAAKrlD,KAAK4kF,sBACN,OAEJ,MAAM/qE,GAAc,IAAA4qC,cAAazkD,KAAK0kD,aAAaC,cACnD,IAAK9qC,EACD,OAEoBA,EAAYxT,IAAKqJ,IAAM,IAAAo1C,wBAAuBp1C,EAAEwf,WAAYxf,EAAEwe,oBACtEjtB,QAASkuB,IACjBA,IACA,KAAAyuC,oBAAmBzuC,EAAQjzB,SAASizB,UAGhD,CACA,mBAAA01D,CAAoB11D,GAChB,MAAMolC,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GACvD,IAAKolC,EAAY3zD,OACb,OAAO,KAGX,OADyB2zD,EAAY,EAEzC,CACA,wBAAAwwB,CAAyB51D,EAASmkB,GAC9B,MAAMhyB,EAAWthB,KAAK0kF,4BACtB,IAAKpjE,EACD,OAEJ,IAAKgyB,EAAWpmC,MAAM+nD,SAASxmD,OAC3B,OAEJ6kC,EAAWpmC,KAAK+nD,QAAQxmD,OAAS,CAAC,IAAI6S,IACtCgyB,EAAW/3C,aAAc,EACzB,MAAMsiE,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAAe,IACjE,IAAAj6B,mBAAkB5L,KAIzC,EAAA4nC,EAAA,GAAsC8G,EAC1C,CACA,uCAAApJ,CAAwCtlC,EAASolC,GAC7C,KAAMA,aAAuB71D,QAAiC,IAAvB61D,EAAY3zD,OAC/C,MAAO,GAEX,MAAM0yC,EAAaihB,EAAY,GACzBr4D,GAAW,IAAA6+B,mBAAkB5L,IAAUjzB,SAC7C,IAAKA,EACD,MAAO,GAEX,MAAMsmB,EAAStmB,EAASumB,aAClB,gBAAElB,EAAe,WAAEoB,GAAeH,EACxC,IAAKjB,IAAoBoB,EACrB,MAAO,GAEX,MAAMlU,EAAS6kC,EAAWpmC,MAAM+nD,SAASxmD,OACzC,KAAMA,aAAkB/P,QAA4B,IAAlB+P,EAAO7N,OACrC,MAAO,GAEX,MAAM0gB,EAAW7S,EAAO,GAClBwoB,EAAQ,EAAA+Z,UAAA,qBAA+BzvB,EAAiBoB,GAE9D,OADiB,EAAAquB,UAAA,4BAAsC/Z,EAAO3V,GAC5CthB,KAAKyM,cAAc43E,iBAAmB,CAAC/wC,GAAc,EAC3E,CACA,mBAAAiyC,CAAoBrpF,GAChB,MAAM2pF,EAAuB7lF,KAAK0kF,4BAClC,GAAKmB,IAAwBA,EAAqB58D,KAAMvZ,GAAM8M,MAAM9M,IAGpE,GAAIxT,aAAoB,EAAA8+B,cAAe,CACnC,MAAM8qD,EAAe,EAAA90C,UAAA,kCAA4C60C,EAAsB3pF,GACvF,GAAqB,OAAjB4pF,EACA,OAEAA,IAAiB5pF,EAASw6B,0BAC1Bx6B,EAASqiF,gBAAgBuH,EAEjC,MACK,GAAI5pF,aAAoB,EAAAg3C,eAAgB,CACzC,MAAM,WAAEvwB,EAAU,gBAAEpB,GAAoBrlB,EAASumB,YACjD,IAAKE,IAAepB,EAChB,OAEJ,MAAM0V,EAAQ,EAAA+Z,UAAA,qBAA+BzvB,EAAiBoB,GACxDojE,EAAkB,EAAA/0C,UAAA,4BAAsC/Z,EAAO4uD,GAAsB,GAC3F,GAAI5oF,KAAK6e,IAAIiqE,GAAmB,GAC5B,OAEJ,MAAMC,EAAsB,eAAe,cAAe,mBAAmBzkE,IACvE0kE,EAAoB,WAAW,cAAeD,EAAqBD,GACnElkD,EAAgB,SAAS,cAAe,mBAAmBlf,GAAasjE,GAE9E,IADmB,EACH,CACZ/pF,EAAS6lC,UAAU,CAAEpf,WAAYkf,IACjC,MAAMloB,EAAkBzd,EAASiyB,qBAC7BxU,GACAA,EAAgBusE,eAAehqF,EAASmN,GAEhD,CACJ,CACJ,EAEJ86E,GAAiBvgC,SAAW,mBAC5B,MC7SMuiC,GAA2B,GACjC,MAAMC,WAAyBzH,GAAA7zC,EAC3B,WAAArrC,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3Cv1C,cAAe,CACXyiB,WAAY,GACZm3D,cAAe,YAGnB/kC,MAAMS,EAAWC,GACjBhiD,KAAK29D,SAAW,KAChB39D,KAAK8+E,MAAQ,KACT,MACMnlE,GADmB,IAAAolE,uBACgB,GACzC,IAAKplE,EACD,OAEJ,MAAME,GAAc,IAAA4qC,cAAazkD,KAAK0kD,aAAaC,cACnD,IAAK9qC,EACD,OAEJ,MAAMysE,EAAkBzsE,EAAYxT,IAAKqJ,IAAM,IAAAo1C,wBAAuBp1C,EAAEwf,WAAYxf,EAAEwe,oBACtF,IAAI,SAAEhyB,GAAaoqF,EAAgB,GACnC,MAAM,oBAAEt8E,GAAwBs8E,EAAgB,GAQhD,GAPItmF,KAAKyM,cAAcyiB,YACnBo3D,EAAgBrlF,QAASkuB,IACjBA,EAAQjzB,SAASmN,IAAMrJ,KAAKyM,cAAcyiB,aAC1ChzB,EAAWizB,EAAQjzB,aAI1BA,EACD,OAEJ,MAAM,OAAE8oC,EAAM,gBAAEzjB,GAAoBrlB,EAASumB,YACvC8jE,EAA+B,2CAAuCrqF,GAC5E,IAAIo3C,EAAatzC,KAAK29D,UAAUrqB,WAChC,MAAMihB,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe94D,EAASizB,SAC5DolC,EAAY3zD,SACZ0yC,EAAaihB,EAAYz/C,OAAQ0xE,GAAmBA,EAAet5E,KAAKgiB,YAAchzB,EAASmN,IAAI,IAEvGi9E,EAAgBrlF,QAASkuB,IACrB,MAAM,SAAEjzB,GAAaizB,EACrB,IAAKg3D,GAAyBtrE,SAAS3e,EAASmN,IAAK,CACjD,MAAM2sE,EAAgB,CAClB9uE,SAAU,CACN08C,SAAU5jD,KAAKg1D,cACfzzC,gBAAiB,IAAIA,GACrByjB,OAAQ,IAAIA,GACZh7B,sBACAzD,kBAAmB,MAEvB2G,KAAM,CACF+nD,QAAS,CACLxmD,OAAQ,2CAAuCvS,IAEnDgzB,WAAYhzB,EAASmN,KAG7B88E,GAAyBx9E,KAAKzM,EAASmN,KACvC,IAAAgsD,eAAc2gB,EAAe95E,EAASizB,SACtCmkB,EAAa0iC,CACjB,IAEAh2E,KAAK29D,UAAUrqB,YACftzC,KAAK29D,SAASrqB,WAAWpmC,KAAKgiB,YAAchzB,EAASmN,KACrDrJ,KAAK29D,SAASrqB,WAAWpmC,KAAK+nD,QAAQxmD,OAClC83E,EACJvmF,KAAK29D,SAASrqB,WAAWpmC,KAAKgiB,WAAahzB,EAASmN,IAExDrJ,KAAK29D,SAAW,CACZzhE,WACAyd,kBACA25B,eAGRtzC,KAAK+pD,iBAAmB,KACpB/pD,KAAK8+E,SAET9+E,KAAKgqD,iBAAoB5H,IACrBpiD,KAAKyM,cAAcyiB,WAAakzB,EAAIrtB,OAAO7F,WAC3ClvB,KAAK8+E,SAET9+E,KAAKymF,iBAAmB,CAACC,EAAoBC,EAAqBC,KAC9D,MAAMC,EAAa,CACf,KAAO,IAAM,IAAM,IAAM,IAAM,IAAK,IAAK,IAAK,GAAI,GAAI,GAAI,EAAG,GAEjE,IAAIC,EASJ,OAPIA,EADY,OAAZF,GAAiC,UAAZA,EACFC,EAAW/xE,OAAQiyE,GAAcA,EAAiC,GAArBL,GAC5DK,EAAiC,GAArBL,GAGGG,EAAW/xE,OAAQiyE,GAAcA,EAAkC,GAAtBJ,GAC5DI,EAAkC,GAAtBJ,GAEbG,EAAiB,IAE5B9mF,KAAKgnF,qBAAuB,CAAChlB,EAAmB4kB,KAC5C,MAAMK,EAAqB,CACvBC,OAAQ,CACJ,CAAC,GAAI,IACL,CAAC,GAAI,KAETvyE,IAAK,CACD,CAAC,EAAG,IACJ,CAAC,EAAG,KAER4tD,KAAM,CACF,CAAC,EAAG,GACJ,CAAC,GAAI,IAETmjB,MAAO,CACH,CAAC,EAAG,GACJ,EAAE,GAAI,KAuBd,MAAO,CACHyB,SArBa,CACb,CACInlB,EAAkB,GAAG,GAAKilB,EAAmBL,GAAU,GAAG,GAC1D5kB,EAAkB,GAAG,GAAKilB,EAAmBL,GAAU,GAAG,IAE9D,CACI5kB,EAAkB,GAAG,GAAKilB,EAAmBL,GAAU,GAAG,GAC1D5kB,EAAkB,GAAG,GAAKilB,EAAmBL,GAAU,GAAG,KAe9DQ,SAZa,CACb,CACIplB,EAAkB,GAAG,GAAKilB,EAAmBL,GAAU,GAAG,GAC1D5kB,EAAkB,GAAG,GAAKilB,EAAmBL,GAAU,GAAG,IAE9D,CACI5kB,EAAkB,GAAG,GAAKilB,EAAmBL,GAAU,GAAG,GAC1D5kB,EAAkB,GAAG,GAAKilB,EAAmBL,GAAU,GAAG,OAQtE5mF,KAAKqnF,uBAAyB,CAACN,EAAWH,EAAUjyB,EAAe2yB,EAAUC,KACzE,IAAIC,EACY,UAAZZ,GAAoC,OAAZA,EACxBY,EAAkBD,EAAU,GAAG,GAAKD,EAAS,GAAG,GAE/B,QAAZV,GAAkC,SAAZA,IAC3BY,EAAkBD,EAAU,GAAG,GAAKD,EAAS,GAAG,IAEpD,MAAMG,EAAU,GACVC,EAAW,GACXC,EAAkB,GACxB,IAAIC,EAAmBb,EACnBA,GAAa,KACba,EAAmBb,EAAY,IAEnC,MAAMc,EAAcL,EAAkBI,EACtC,IAAK,IAAIl+E,EAAI,EAAGA,EAAIk+E,EAAmB,EAAGl+E,IAAK,CAC3C,MAAMo+E,EAAiB,CACnBZ,OAAQ,CACJ,CAACW,GAAen+E,EAAI,GAAI,GACxB,CAACm+E,GAAen+E,EAAI,GAAI,IAE5BiL,IAAK,CACD,CAACkzE,GAAen+E,EAAI,GAAI,GACxB,CAACm+E,GAAen+E,EAAI,IAAK,IAE7B64D,KAAM,CACF,CAAC,EAAGslB,GAAen+E,EAAI,IACvB,EAAE,EAAGm+E,GAAen+E,EAAI,KAE5Bg8E,MAAO,CACH,CAAC,EAAGmC,GAAen+E,EAAI,IACvB,CAAC,EAAGm+E,GAAen+E,EAAI,MAG/B+9E,EAAQ9+E,KAAK,GAAGgsD,SAAqBjrD,KACrCg+E,EAAS/+E,KAAK,OAAOe,MAChBA,EAAI,GAAK,GAAK,EACfi+E,EAAgBh/E,KAAK,CACjB,CACI2+E,EAAS,GAAG,GAAKQ,EAAelB,GAAU,GAAG,GAC7CU,EAAS,GAAG,GAAKQ,EAAelB,GAAU,GAAG,IAEjD,CACIU,EAAS,GAAG,GAAKQ,EAAelB,GAAU,GAAG,GAC7CU,EAAS,GAAG,GAAKQ,EAAelB,GAAU,GAAG,MAKrDe,EAAgBh/E,KAAK,CACjB,CACI2+E,EAAS,GAAG,GAAKQ,EAAelB,GAAU,GAAG,GAC7CU,EAAS,GAAG,GAAKQ,EAAelB,GAAU,GAAG,IAEjD,CACIU,EAAS,GAAG,GAAKQ,EAAelB,GAAU,GAAG,GAC7CU,EAAS,GAAG,GAAKQ,EAAelB,GAAU,GAAG,KAI7D,CACA,MAAO,CAAEa,UAASC,WAAUC,oBAEhC3nF,KAAK+nF,6BAA+B,CAAChB,EAAWH,EAAUoB,KACtD,IAAIC,EACAvI,EAAe,cAAc,cAAesI,EAAS,GAAIA,EAAS,IACtEtI,EAAe,eAAe,cAAeA,GAC7C,IAAIC,EAAc,cAAc,cAAeqI,EAAS,GAAIA,EAAS,IACrErI,EAAc,eAAe,cAAeA,GAC5C,MAAMuI,EAAmB,CACrBhB,OAAQ,CAACc,EAAS,GAAIA,EAAS,IAC/BrzE,IAAK,CAACqzE,EAAS,GAAIA,EAAS,IAC5BtC,MAAO,CAACsC,EAAS,GAAIA,EAAS,IAC9BzlB,KAAM,CAACylB,EAAS,GAAIA,EAAS,KAE3BG,EAAW,SACR,cAAeD,EAAiBtB,GAAU,GAAIsB,EAAiBtB,GAAU,IAC7EvgF,IAAKqD,GAAMA,EAAI,GACd4D,EAASy5E,EACX,EACA9pF,KAAKopC,KAAKppC,KAAKotD,IAAIq1B,EAAa,GAAI,GAChCziF,KAAKotD,IAAIq1B,EAAa,GAAI,GAC1BziF,KAAKotD,IAAIq1B,EAAa,GAAI,IAalC,MAZgB,OAAZkH,GAAiC,UAAZA,EACrBqB,EAAmB,CACf,cAAc,cAAeE,EAAUxI,EAAYt5E,IAAKqD,GAAMA,EAAI4D,IAClE,SAAS,cAAe66E,EAAUxI,EAAYt5E,IAAKqD,GAAMA,EAAI4D,KAGhD,QAAZs5E,GAAkC,SAAZA,IAC3BqB,EAAmB,CACf,SAAS,cAAeE,EAAUzI,EAAar5E,IAAKqD,GAAMA,EAAI4D,IAC9D,cAAc,cAAe66E,EAAUzI,EAAar5E,IAAKqD,GAAMA,EAAI4D,MAGpE26E,GAEXjoF,KAAKooF,8BAAgC,CAACC,EAAYrmB,EAAmBsmB,EAAcC,EAAc3B,KAC7F,IAAI4B,EACJ,GAAgB,OAAZ5B,GAAiC,UAAZA,EAAsB,CAC3C,MAAM6B,EAAwBzmB,EAAkB,GAAG,GAAKA,EAAkB,GAAG,GAC7EwmB,EAAyB,CACrB,CAACH,EAAWzrF,MAAQ,EAAI6rF,EAAwB,EAAGH,EAAazrF,QAChE,CAACwrF,EAAWzrF,MAAQ,EAAI6rF,EAAwB,EAAGH,EAAazrF,QAExE,MACK,GAAgB,QAAZ+pF,GAAkC,SAAZA,EAAqB,CAChD,MAAM6B,EAAwBzmB,EAAkB,GAAG,GAAKA,EAAkB,GAAG,GAC7EwmB,EAAyB,CACrB,CAACD,EAAa3rF,MAAOyrF,EAAWxrF,OAAS,EAAI4rF,EAAwB,GACrE,CAACF,EAAa3rF,MAAOyrF,EAAWxrF,OAAS,EAAI4rF,EAAwB,GAE7E,CACA,OAAOD,GAEXxoF,KAAK0oF,mBAAqB,CAACL,EAAYM,EAAqBC,EAAmBhC,KAC3E,MAAMiC,EAAaF,EAAsB1rF,KAAKa,IAAI,IAAMuqF,EAAWzrF,OAC7DksF,EAAaF,EAAoB3rF,KAAKa,IAAI,IAAMuqF,EAAWxrF,QAC3DksF,EAAiB,CACnB7B,OAAQ,EAAE4B,GAAaD,GACvBl0E,IAAK,CAACm0E,EAAYD,GAClBtmB,KAAM,CAACumB,EAAYD,GACnBnD,MAAO,EAAEoD,GAAaD,IAEpBG,EAAe,CACjB9B,OAAQ,CAACmB,EAAWxrF,OAAQwrF,EAAWzrF,OACvC+X,IAAK,CAAC,EAAG0zE,EAAWzrF,OACpB2lE,KAAM,CAAC8lB,EAAWxrF,OAAQ,GAC1B6oF,MAAO,CAAC2C,EAAWxrF,OAAQwrF,EAAWzrF,QAE1C,MAAO,CACHC,OAAQmsF,EAAapC,GAAU,GAAKmC,EAAenC,GAAU,GAC7DhqF,MAAOosF,EAAapC,GAAU,GAAKmC,EAAenC,GAAU,IAGxE,CACA,gBAAA5uB,CAAiB18D,EAAgB28D,GAC7B,IAAKj4D,KAAK29D,WAAa39D,KAAK29D,SAASzhE,SACjC,OAEJ,MAAM0qF,EAAW5mF,KAAKyM,cAAc45E,eAC9B,SAAEnqF,GAAaZ,EAEfg4C,GADc,IAAA6oB,gBAAen8D,KAAKg1D,cAAe94D,EAASizB,SACjCra,OAAQ0xE,GAAmBA,EAAet5E,KAAKgiB,YAAchzB,EAASmN,IAAI,GACnG5N,EAASH,EAAeY,SAAST,OACjCi9D,GAAe,EACrB,IAAKx8D,EACD,OAAOw8D,EAEX,MAAMqJ,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAElCg/E,EAAa,CACfzrF,MAAOnB,EAAOmB,MAAQ2yB,OAAOD,kBAAoB,EACjDzyB,OAAQpB,EAAOoB,OAAS0yB,OAAOD,kBAAoB,GAEjD4vD,EAAU5rC,EAAWpmC,KAAK+nD,QAAQxmD,OAAO,GACzC4iB,EAAWiiB,EAAWpmC,KAAK+nD,QAAQxmD,OAAO,GAC1C6iB,EAAagiB,EAAWpmC,KAAK+nD,QAAQxmD,OAAO,GAC5C0wE,EAAc7rC,EAAWpmC,KAAK+nD,QAAQxmD,OAAO,GAC7C8wE,EAAY,CAACL,EAAS5tD,EAAYD,EAAU8tD,GAC5CuH,EAAqB,cAAcp1D,EAAY6tD,GAC/CwH,EAAsB,cAAczH,EAAS5tD,GAC7Ci3D,EAAevoF,KAAK0oF,mBAAmBL,EAAY,IAAM,IAAMzB,GAC/D0B,EAAetoF,KAAK0oF,mBAAmBL,EAAY,IAAM,IAAMzB,GAC/DG,EAAY/mF,KAAKymF,iBAAiBC,EAAoBC,EAAqBC,GAC3E5kB,EAAoBhiE,KAAK+nF,6BAA6BhB,EAAWH,EAAUrH,GAAWl5E,IAAKo9C,GAAUvnD,EAASinD,cAAcM,IAC5H+kC,EAAyBxoF,KAAKooF,8BAA8BC,EAAYrmB,EAAmBsmB,EAAcC,EAAc3B,GACvHqC,EAAajpF,KAAKgnF,qBAAqBwB,EAAwB5B,IAC/D,cAAEjyB,GAAkBrhB,EAC1ByuB,EAAepN,cAAgBA,EAC/B,MAAMT,EAAYl0D,KAAKy2E,SAAS,YAAa1U,EAAgBzuB,GACvDsoB,EAAW57D,KAAKy2E,SAAS,WAAY1U,EAAgBzuB,GACrDl3C,EAAQ4D,KAAKy2E,SAAS,QAAS1U,EAAgBzuB,GAC/C+0B,EAASroE,KAAKy2E,SAAS,SAAU1U,EAAgBzuB,GACjD41C,EAAU,GAAGv0B,eAEnB,IAAA+G,UAAYzD,EAAkBtD,EADT,IACsC6zB,EAAuB,GAAIA,EAAuB,GAAI,CAC7GpsF,QACAQ,MAAOs3D,EACP0H,WACAyM,UACD6gB,GACH,MAAMC,EAAa,GAAGx0B,UAEtB,IAAA+G,UAAYzD,EAAkBtD,EADV,IACsCs0B,EAAW9B,SAAS,GAAI8B,EAAW9B,SAAS,GAAI,CACtG/qF,QACAQ,MAAOs3D,EACP0H,WACAyM,UACD8gB,GACH,MAAMC,EAAc,GAAGz0B,WAEvB,IAAA+G,UAAYzD,EAAkBtD,EADT,IACsCs0B,EAAW7B,SAAS,GAAI6B,EAAW7B,SAAS,GAAI,CACvGhrF,QACAQ,MAAOs3D,EACP0H,WACAyM,UACD+gB,GACH,MAAMC,EAAqB,CACvBnC,OAAQ,EAAE,IAAK,IACfvyE,IAAK,EAAE,IAAK,IACZ4tD,KAAM,EAAE,IAAK,IACbmjB,MAAO,EAAE,IAAK,KAEZ4D,EAAwB,CAC1Bd,EAAuB,GAAG,GAAKa,EAAmBzC,GAAU,GAC5D4B,EAAuB,GAAG,GAAKa,EAAmBzC,GAAU,IAE1D2C,EAAevpF,KAAKwpF,cAAczC,IAClC,QAAEU,EAAO,SAAEC,EAAQ,gBAAEC,GAAoB3nF,KAAKqnF,uBAAuBN,EAAWH,EAAUjyB,EAAes0B,EAAW9B,SAAU8B,EAAW7B,UAC/I,IAAK,IAAI19E,EAAI,EAAGA,EAAIg+E,EAAS9mF,OAAQ8I,KACjC,IAAAgyD,UAAYzD,EAAkBtD,EAAe+yB,EAASh+E,GAAIi+E,EAAgBj+E,GAAG,GAAIi+E,EAAgBj+E,GAAG,GAAI,CACpGtN,QACAQ,MAAOs3D,EACP0H,WACAyM,UACDof,EAAQ/9E,IAWf,OARA,IAAA+/E,aAAexxB,EAAkBtD,EADjB,QACyC40B,EAAc,CAACD,EAAsB,GAAIA,EAAsB,IAAK,CACzHI,WAAY,+CACZC,SAAU,OACV/tB,SAAU,MACV1H,UAAW,IACXmU,QAAQ,EACRjsE,MAAOA,IAEJs8D,CACX,CACA,aAAA8wB,CAAczC,GACV,IAAI6C,EACAC,EACA9C,GAAa,IACb6C,EAAwB7C,EAAY,GACpC8C,EAAiB,QAGjBD,EAAwB7C,EACxB8C,EAAiB,OAGrB,MADkB,CAACD,EAAsB5oE,WAAWvD,OAAOosE,GAE/D,EAEJzD,GAAiBxiC,SAAW,e,wCC/X5B,MAAMkmC,WAAqB,MACvB,WAAArqF,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXs9E,WAAY,EACZC,oBAAqB,CACjB,oBACA,yCAEJC,UAAW,SACXC,mBAAoB,oBACpBC,iBAAkB,aAGtB7oC,MAAMS,EAAWC,GACjBhiD,KAAKoqF,iBAAmB,IAAI54E,IAC5BxR,KAAKqqF,UAAW,EAChBrqF,KAAKsqF,WAAa,CACdC,oBAAqB,KACrB1sB,oBAAqB,GACrB2sB,sBAAsB,EACtBC,oBAAgBzsF,GAEpBgC,KAAKkkD,qBAAwB9B,IACzB,MAAM5f,EAAY4f,EAAIrtB,OAChB5F,EAAUqT,EAAUrT,QAG1B,GAFAnvB,KAAK0qF,kBAAkBtoC,GACvBpiD,KAAK2qF,mBAAmBnoD,GACoB,OAAxCxiC,KAAKsqF,WAAWC,oBAMpB,OAHAvqF,KAAKqqF,UAAW,GAChB,KAAA9yB,mBAAkBpoC,GAClBnvB,KAAK4qF,eAAez7D,IACb,GAEXnvB,KAAK03D,kBAAqBtV,IAClBpiD,KAAKo7E,OAAS,EAAA1qC,UAAUH,QACxBvwC,KAAK0qF,kBAAkBtoC,GACvBpiD,KAAK6qF,aAAazoC,IAGlBpiD,KAAKsqF,WAAWG,oBAAiBzsF,GAGzCgC,KAAK8qF,YAAe1oC,IAChB,MAAM5f,EAAY4f,EAAIrtB,QAChB,QAAE5F,GAAYqT,EACdoyC,EAAS50E,KAAKyM,cACdnR,GAAiB,IAAAy/B,mBAAkB5L,GACzCnvB,KAAKqqF,UAAW,EAChBrqF,KAAK+qF,iBAAiB57D,IACtB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,kBAAEjB,EAAiB,WAAEgB,GAAe5zB,EAEpCkhF,GADY,IAAAxU,yBAAwB94C,EAAYhB,GACvBqiD,gBAAgBqE,EAAOsV,oBAEhDc,EADchrF,KAAKirF,sCAAsC97D,GAC1BzR,KAAM41B,GAAeA,EAAWqhB,gBAAkB30D,KAAKsqF,WAAWC,qBACnG/N,EAAa/vE,cAAcy+E,iBAC3BF,EAAiBzvF,aAAc,IAEnC,KAAAi4C,2BAA0Bw3C,EAAkB77D,EAAS,EAAAskB,YAAY03C,iBAErEnrF,KAAKorF,aAAgBhpC,IACjB,MAAM5f,EAAY4f,EAAIrtB,OAChB5F,EAAUqT,EAAUrT,QAC1BnvB,KAAK6qF,aAAazoC,GAClB,MAAMmS,EAAcv0D,KAAKirF,sCAAsC97D,GACzD67D,EAAmBz2B,EAAY72C,KAAM41B,GAAeA,EAAWqhB,gBAAkB30D,KAAKsqF,WAAWC,qBACvG,IAAKh2B,GAAa3zD,SAAWZ,KAAKqqF,SAC9B,OAEJ,MAAM57E,EAASu8E,EAAiB99E,KAAKqlC,QAAQ4F,SAC7Cn4C,KAAKqrF,OAAO7oD,EAAW/zB,IAE3BzO,KAAKsrF,eAAeC,GAAA,EAAmBC,UAAWD,GAAA,GAClDvrF,KAAKyrF,aAAazrF,KAAKyM,cAAcw9E,UACzC,CACA,cAAAqB,CAAeE,EAAWE,GACtB,MAAMC,EAAQ,IAAID,EAClB1rF,KAAKoqF,iBAAiBlqF,IAAIsrF,EAAWG,EACzC,CACA,MAAAN,CAAO7oD,EAAW/zB,GACd,MAAMmmE,EAAS50E,KAAKyM,cACd0iB,EAAUqT,EAAUrT,QACpB7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACfswF,EAAc5rF,KAAKoqF,iBAAiBhqF,IAAIJ,KAAK6rF,eACnD7rF,KAAK8rF,WAAa,CACdC,WAAYvpD,EAAUwjB,cAAcvC,MACpCuoC,iBAAkBxpD,EAAUwjB,cAAcvqD,OAC1CwwF,WAAYzpD,EAAU+gB,YAAYE,MAClCh1C,SACAy9E,WAAYN,EAAYO,cAAcvX,EAAOmV,YAC7C56D,QAASA,GAEb,MAAMi9D,EAAgBR,EAAYS,YAAYnwF,EAAU8D,KAAK8rF,iBACjC9tF,IAAxBouF,EAAcE,OACdtsF,KAAKusF,iBAAiBH,EAE9B,CACA,iCAAAI,CAAkC9iF,EAAG+E,EAAQg+E,EAAsBP,GAC/D,MAAM,QAAE/8D,GAAYnvB,KAAK8rF,WACnBxwF,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACfoxF,EAAkBC,GAAajjF,EAAI,EAAG+E,EAAO7N,QAC7CgsF,EAAqB1wF,EAASinD,cAAc10C,EAAO/E,IACnDmjF,EAAkB3wF,EAASinD,cAAc10C,EAAOi+E,IACzB,EAAAp+E,MAAA,gBAAsBs+E,EAAoBC,GAC5CX,GACvBO,EAAqB9jF,KAAKe,EAElC,CACA,YAAAmhF,CAAazoC,GACT,MAAM5f,EAAY4f,EAAIrtB,OAChB5F,EAAUqT,EAAUrT,QACpB7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,EAAe,SAAEzd,GAAaZ,EACtC0E,KAAKsqF,WAAWzsB,oBAAsB,CAAC3hE,EAASmN,IAChD,MAAMkrD,EAAcv0D,KAAKirF,sCAAsC97D,GAC/D,IAAKolC,GAAa3zD,OACd,OAEJ,MAAMoqF,EAAmBz2B,EAAY72C,KAAM41B,GAAeA,EAAWqhB,gBAAkB30D,KAAKsqF,WAAWC,qBAEvG,GADAvqF,KAAKsqF,WAAWG,eAAiBjoD,EAAUwjB,cAAcvqD,OACrDuE,KAAKqqF,SACLW,EAAiBn2B,aAAc,MAE9B,CACD,MAAM+2B,EAAc5rF,KAAKoqF,iBAAiBhqF,IAAIJ,KAAK6rF,eAC7C50B,EAAez0B,EAAUwjB,cAAcvqD,OACD,YAAxCuE,KAAKyM,cAAc09E,kBACnByB,EAAYkB,eAAe71B,EAAc/6D,EAAU8uF,EAE3D,EACA,EAAAj0B,EAAA7rB,GAAsClrC,KAAKsqF,WAAWzsB,oBAC1D,CACA,qCAAAotB,CAAsC97D,GAClC,MAAMylD,EAAS50E,KAAKyM,cACdnR,GAAiB,IAAAy/B,mBAAkB5L,IACnC,kBAAEjB,EAAiB,WAAEgB,GAAe5zB,EACpCyxF,EAAwB,GAExBvQ,GADY,IAAAxU,yBAAwB94C,EAAYhB,GACvBqiD,gBAAgBqE,EAAOsV,oBAOtD,OANAtV,EAAOoV,oBAAoB/oF,QAASipF,IAChC,MAAM31B,GAAc,QAAe21B,EAAoB/6D,GACnDolC,GACAw4B,EAAsBpkF,QAAQ4rD,KAG/BioB,EAAa/nB,wCAAwCtlC,EAAS49D,EACzE,CACA,iBAAArC,CAAkBtoC,GACMpiD,KAAKoqF,iBAAiBhqF,IAAIJ,KAAK6rF,eACvCnB,kBAAkBtoC,EAClC,CACA,gBAAAmqC,CAAiBH,GACb,MAAMK,EAAuBzsF,KAAKgtF,qBAAqBZ,GACvD,IAAIa,EAAmB,EACvB,IAAK,IAAIvjF,EAAI,EAAGA,EAAI+iF,GAAsB7rF,OAAQ8I,IAAK,CACnD,MAAMoJ,EAAc25E,EAAqB/iF,GAAK,EAAIujF,EAClDjtF,KAAKktF,qBAAqBp6E,GAC1Bm6E,GACJ,CACJ,CACA,oBAAAD,CAAqBZ,GACjB,MAAM,OAAE39E,EAAM,WAAEy9E,GAAelsF,KAAK8rF,WAC9BW,EAAuB,GAC7B,IAAK,IAAI/iF,EAAI0iF,EAAcE,MAAO5iF,GAAK0iF,EAAcvpF,KAAM6G,IACvD1J,KAAKwsF,kCAAkC9iF,EAAG+E,EAAQg+E,EAAsBP,GAE5E,OAAOO,CACX,CACA,oBAAAS,CAAqBp6E,GACjB,MAAM,OAAErE,GAAWzO,KAAK8rF,WACxB,GAAIh5E,EAAcrE,EAAO7N,OAAS,GAC9BZ,KAAKsqF,WAAWE,qBAChB,OAEJ,MAAMoB,EAAc5rF,KAAKoqF,iBAAiBhqF,IAAIJ,KAAK6rF,eAC7CsB,EAAgBr6E,EAAc,EAC9Bs6E,EAAYT,GAAa75E,EAAarE,EAAO7N,QAE7CysF,EADiBzB,EAAY0B,kBAAkBH,EAAeC,EAAWptF,KAAK8rF,YAEpFr9E,EAAOwE,OAAOH,EAAa,EAAGu6E,EAClC,CACA,kBAAA1C,CAAmBnoD,GACf,MAAM+qD,EAAuBvtF,KAAKwtF,gCAAgChrD,QACrCxkC,IAAzBuvF,IAGJvtF,KAAKsqF,WAAWC,oBAAsBgD,EAC1C,CACA,+BAAAC,CAAgChrD,GAC5B,MAAM,QAAErT,GAAYqT,EACdlnC,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACfs5E,EAAS50E,KAAKyM,cACd8nD,EAAcv0D,KAAKirF,sCAAsC97D,GAC/D,IAAKolC,GAAa3zD,OACd,OAEJ,MAAMuiF,EAAe3gD,EAAUwjB,cAAcvqD,OACvC4hF,EAAU,CACZrhE,SAAUrF,IACV82E,eAAWzvF,EACX22D,mBAAe32D,GAEnB,IAAK,IAAI0L,EAAI,EAAGA,EAAI6qD,GAAa3zD,OAAQ8I,IAAK,CAC1C,GAAI6qD,EAAY7qD,GAAGgkF,WAAan5B,EAAY7qD,GAAGikF,UAC3C,SAEJ,MAAMC,GAAmB,EAAAC,GAAA,GAAuB3xF,EAAUq4D,EAAY7qD,GAAIy5E,IAChD,IAAtByK,IAGAA,EAAmBvQ,EAAQrhE,WAC3BqhE,EAAQrhE,SAAW4xE,EACnBvQ,EAAQoQ,UAAY/jF,EACpB2zE,EAAQ1oB,cAAgBJ,EAAY7qD,GAAGirD,eAE/C,CAKA,OAJA30D,KAAKsqF,WAAWE,sBACXj2B,EAAY8oB,EAAQoQ,WAAWvgF,KAAKqlC,QAAQsH,OACjD+6B,EAAOsV,mBACH31B,EAAY8oB,EAAQoQ,WAAWvmF,SAAS08C,SACrCy5B,EAAQ1oB,aACnB,CACA,cAAAi2B,CAAez7D,GACXA,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAK8qF,aAC/C37D,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAK8qF,aAClD37D,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKorF,cACjDj8D,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAK8qF,aAChD37D,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAK8qF,aAChD37D,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKorF,aACrD,CACA,gBAAAL,CAAiB57D,GACbA,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAK8qF,aAClD37D,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAK8qF,aACrD37D,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKorF,cACpDj8D,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAK8qF,aACnD37D,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAK8qF,aACnD37D,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKorF,aACxD,CACA,YAAAK,CAAaxB,GACTjqF,KAAK6rF,cACD7rF,KAAKoqF,iBAAiBhqF,IAAI6pF,IAAcsB,GAAA,EAAmBC,SACnE,CACA,gBAAAxzB,CAAiB18D,EAAgB28D,GAC7B,MAAM,SAAE/7D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACd2hE,EAAsB79D,KAAKsqF,WAAWzsB,oBAC5C,IAAK79D,KAAKsqF,WAAWG,gBACjBzqF,KAAKo7E,OAAS,EAAA1qC,UAAUH,SACvBstB,EAAoBhjD,SAAS3e,EAASmN,IACvC,OAEJ,MAAMkrD,EAAcv0D,KAAKirF,sCAAsC97D,GAC/D,IAAKolC,GAAa3zD,OACd,OAEJ,MAAMmhE,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAIjN,GAAQ,QAAiB,QAAS2lE,EAAgB,EAAA+rB,sBAAsBC,QAAS/tF,KAAKo7E,MACtFp7E,KAAKqqF,WACLjuF,GAAQ,QAAiB,QAAS2lE,EAAgB,EAAA+rB,sBAAsBE,YAAahuF,KAAKo7E,OAE1Ep7E,KAAKoqF,iBAAiBhqF,IAAIJ,KAAK6rF,eACvCoC,YAAYh2B,EAAkBj4D,KAAKsqF,WAAWG,eAAgB,CACtEruF,SAER,EAEG,MAAMuwF,GAAe,CAACjjF,EAAG9I,KACpB8I,EAAI9I,GAAUA,EAE1BkpF,GAAalmC,SAAW,eACxB,MCjSMsqC,GAGC,CAAC,EAAG,EAAG,GAGd,MAAMC,WAAyB,MAC3B,WAAA1uF,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXxE,UAAWimF,GACXpqC,uBAAwB,MAG5BxC,MAAMS,EAAWC,EACrB,CACA,kBAAAuhB,CAAmBnhB,GACf,MAAM,QAAEjzB,EAAO,MAAE20C,GAAU1hB,EAAIrtB,OACzBz5B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,UAAE2M,EAAS,uBAAE67C,GAA2B9jD,KAAKyM,cAC7C+V,EAAStmB,EAASumB,aAClB,OAAEuiB,EAAM,SAAEpV,EAAQ,WAAEjN,GAAeH,GACjCva,UAAWq7D,GAAWQ,GACvBh+B,EAAIC,EAAIC,GAAMrjB,GACdyrE,EAAIC,EAAIC,GAAMrmF,EACfnL,EAASwmE,GAAUxf,EAAyB7mD,KAAKC,IAAO,IACxDi4B,EAAc,CAAC,EAAG,EAAG,GACrB0M,EAAgB,CAAC,EAAG,EAAG,GACvBkkB,EAAY,CAAC,EAAG,EAAG,GACnBtpD,EAAY,cAAc,IAAIwM,aAAa,KACjD,eAAexM,EAAWA,EAAW,CAACqpC,EAAIC,EAAIC,IAC9C,YAAYvpC,EAAWA,EAAWK,EAAO,CAACsxF,EAAIC,EAAIC,IAClD,eAAe7xF,EAAWA,EAAW,EAAEqpC,GAAKC,GAAKC,IACjD,mBAAmB7Q,EAAavF,EAAUnzB,GAC1C,mBAAmBolC,EAAelf,EAAYlmB,GAC9C,cAAcA,GACd,YAAYA,EAAWA,EAAWK,EAAO,CAACsxF,EAAIC,EAAIC,IAClD,mBAAmBvoC,EAAW/gB,EAAQvoC,GACtCP,EAAS6lC,UAAU,CACfnS,SAAUuF,EACV6P,OAAQ+gB,EACRpjC,WAAYkf,IAEhB3lC,EAASD,QACb,EAEJkyF,GAAiBvqC,SAAW,yB,gBCtC5B,MAAM2qC,WAAkB,aACXvuF,KAAK4jD,SAAW,OAAS,CAClC,WAAAnkD,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX47D,QAAQ,EACRmmB,mBACAC,sBACArK,2BAA2B,KAG/B9iC,MAAMS,EAAWC,GACjBhiD,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,KACvD,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,cAAEq5D,GAAkBrhB,EACpBhlC,EAAQglC,EAAWpmC,KAAK+nD,QAAQxmD,OAAO,GACvCkjE,EAA6Bz1E,EAASinD,cAAc70C,GAE1D,GADa,cAAc2oD,EAAc0a,GAC9Bza,EACP,OAAO,EAEX,MAAMw3B,EAAWv/D,EAAQyjD,cAAc,OACvC,IAAK8b,EACD,OAAO,EAEX,MAAMC,EAAYD,EAAS9b,cAAc,0BAA0Bje,OACnE,IAAKg6B,EACD,OAAO,EAEX,MAAMC,EAAmBD,EACnBE,EAAOD,EAAiBE,UACxBryF,EAAYmyF,EAAiBG,aAAa,aAChD,IAAIC,EAAa,EACbC,EAAa,EACjB,GAAIxyF,EAAW,CACX,MAAMyyF,EAAUzyF,EAAUoP,MAAM,sCAC5BqjF,IACAF,EAAav4E,WAAWy4E,EAAQ,IAChCD,EAAax4E,WAAWy4E,EAAQ,IAExC,CACA,MAAM5xF,EAAIuxF,EAAKvxF,EAAI0xF,EACbxxF,EAAIqxF,EAAKrxF,EAAIyxF,EAKnB,OAJeh4B,EAAa,IAAM35D,GAC9B25D,EAAa,IAAM35D,EAAIuxF,EAAKjyF,OAC5Bq6D,EAAa,IAAMz5D,GACnBy5D,EAAa,IAAMz5D,EAAIqxF,EAAKhyF,QAGpCmD,KAAK2+D,iBAAoBvc,IACrB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,OAC/B,KAAA8T,mBAAkBpoC,GAClBnvB,KAAKqhE,WAAY,EACjB,MAAM/tB,EAActzC,KAAKmvF,iBAAiB/sC,EAAK,CAC3C,IAAI9gC,GACJ,IAAIA,MAER,IAAA+zC,eAAc/hB,EAAYnkB,GAC1B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAsBzE,OArBAh1D,KAAK29D,SAAW,CACZrqB,aACA0iC,eAAe,EACfnY,sBACAvwD,OAAQ,CAAC,EAAG,EAAG,IAEnB80C,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GACtC79D,KAAKyM,cAAc+hF,gBAAiB56D,IAChC,IAAKA,EAID,OAHA,IAAA8gC,kBAAiBphB,EAAWqhB,gBAC5B,EAAAoC,EAAA,GAAsC8G,QACtC79D,KAAKqhE,WAAY,IAGrB,KAAAzD,oBAAmBzuC,GACnBmkB,EAAWpmC,KAAK0mB,MAAQA,GACxB,KAAA+tC,4BAA2BruB,IAC3B,EAAAyjB,EAAA,GAAsC8G,KAE1C79D,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,eAAe,IAC/C1iC,GAEXtzC,KAAKo3D,qBAAuB,CAAChV,EAAK9O,KAC9B,MAAMviB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,EAAO,cAAE62B,GAAkBj1B,EACnCuiB,EAAWuhB,aAAc,EACzB,MAAMgJ,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzE,IAAI1nD,EAAS,CAAC,EAAG,EAAG,GACpB,GAAI04C,GAAiBA,EAAcvC,MAAO,CACtC,MAAM2rC,EAAkBppC,EAAcvC,MAChC4rC,EAAiB/7C,EAAWpmC,KAAK+nD,QAAQxmD,OAAO,GACtDnB,EAAS,CACL+hF,EAAe,GAAKD,EAAgB,GACpCC,EAAe,GAAKD,EAAgB,GACpCC,EAAe,GAAKD,EAAgB,GAE5C,CACApvF,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAvwD,UAEJtN,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,IAClB,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,SAChE39D,KAAK0hE,gBAAgBvyC,GACrBnvB,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACf6mD,GACAh2E,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBAE3Ch2E,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,EACjBrhE,KAAKsvF,eACDtvF,KAAKwkF,sBACLxkF,KAAKyM,cAAc23E,4BACnB,IAAA1vB,kBAAiBphB,EAAWqhB,gBAEhC,EAAAoC,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,IAGnCtzC,KAAKqiD,cAAiBD,IAClB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,OACzB,WAAEnQ,EAAU,oBAAEuqB,EAAmB,OAAEvwD,GAAWtN,KAAK29D,SAErDrqB,EAAWpmC,KAAK+nD,QAAQxmD,OAAO,GAD/BnB,EACoC,CAChCgU,EAAS,GAAKhU,EAAO,GACrBgU,EAAS,GAAKhU,EAAO,GACrBgU,EAAS,GAAKhU,EAAO,IAIW,IAAIgU,GAE5CgyB,EAAW/3C,aAAc,GACzB,EAAAw7D,EAAA,GAAsC8G,IACtC,KAAArqB,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAYC,cAE/D1zC,KAAKiL,OAAUkkB,IACX,GAAInvB,KAAKqhE,UAAW,CAChBrhE,KAAKqhE,WAAY,EACjBrhE,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,WAAEmkB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,KAAEzwD,GAASomC,EAQjB,OAPAA,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,MACjC,EAAAne,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KACTrqB,EAAWqhB,aACtB,GAEJ30D,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,gBAErDriD,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,eAEvDp9D,KAAKyhE,cAAiBtyC,IAClB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,gBAErDriD,KAAK0hE,gBAAmBvyC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,gBAExDriD,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACpB,IAAIq4D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAEXnE,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,GACpE,MAAMwN,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6qD,EAAY3zD,OAAQ8I,IAAK,CACzC,MAAM4pC,EAAaihB,EAAY7qD,IACzB,cAAEirD,EAAa,KAAEznD,GAASomC,EAC1BhlC,EAAQpB,EAAK+nD,QAAQxmD,OAAO,GAClCszD,EAAepN,cAAgBA,EAC/B,MAAMqN,EAAoB9lE,EAASinD,cAAc70C,GAEjD,GADAoqD,GAAe,GACVx8D,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,KAAK,KAAAie,qBAAoBhiB,GACrB,SAEJ,IAAKznD,EAAK0mB,MACN,SAEJ,MAAMxvB,EAAUpE,KAAKuvF,sBAAsBxtB,EAAgBzuB,GACrDk8C,EAAa,KACnB,IAAA/F,aAAexxB,EAAkBtD,EAAe66B,EAAY,CAACtiF,EAAK0mB,OAAQouC,EAAmB,IACtF59D,EACH6vE,QAAS,GAEjB,CACA,OAAOvb,EAEf,QACS14D,KAAKyvF,QAAU,CAACvgE,EAAYU,EAAUgE,EAAOxvB,KAClD,MAAM9I,GAAiB,IAAAq9E,+BAA8BzpD,GACrD,IAAK5zB,EACD,OAEJ,MAAM,SAAEY,GAAaZ,EACf0O,EAAsB9N,EAASqlE,0BAC/B,gBAAEhgD,EAAe,OAAEyjB,GAAW9oC,EAASumB,YACvCgkB,EAAW,IAAIzmC,KACfuG,EAAoBkgC,EAAS66B,qBAAqBplE,EAAU0zB,EAAUrO,EAAiByjB,GACvFsO,EAAa,CACfqhB,cAAevwD,GAASuwD,eAAiB,qBACzCznD,KAAM,CACF0mB,QACAqhC,QAAS,CACLxmD,OAAQ,CAACmhB,KAGjBilC,aAAa,EACb66B,eAAe,EACfn0F,aAAa,EACbmyF,UAAU,EACVC,WAAW,EACXzmF,SAAU,CACN08C,SAAUnd,EAASuuB,cACnBzzC,kBACAvX,sBACAzD,uBACGnC,KAGX,IAAAixD,eAAc/hB,EAAYp3C,EAASizB,UACnC,EAAA4nC,EAAA,GAAsC,CAAC76D,EAASmN,KACjD,CACH,sBAAAy1D,CAAuB6wB,EAAMC,EAAaC,EAASC,GAAoB,CACvE,yBAAAC,CAA0B5gE,EAASmkB,EAAYC,GAC3CD,EAAWpmC,KAAK0mB,MAAQ2f,EACxB,MAAMsqB,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,gBACzE,EAAA+B,EAAA,GAAsC8G,IACtC,KAAArqB,2BAA0BF,EAAYnkB,EAC1C,CACA,eAAA6gE,CAAgBC,EAAQC,EAAQroF,GAC5B,OAAQ,kCAA8BooF,EAAQpoF,IAC1C,kCAA8BqoF,EAAQroF,EAC9C,EAEJ,SAAS2mF,GAAgB2B,GACrB,OAAOA,EAAyBC,OAAO,0BAC3C,CACA,SAAS3B,GAAmBvhF,EAAMs1B,EAAW2tD,GACzC,OAAOA,EAAyBC,OAAO,0BAC3C,CACA7B,GAAU3qC,SAAW,QACrB,MCvSQlf,sBAAqB,IAAK,YAClC,MAAM2rD,WAAmB,aACZrwF,KAAK4jD,SAAW,QAAU,CACnC,WAAAnkD,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX23E,2BAA2B,EAC3BkM,aAAcC,GACdrc,QAAS,CACL9/C,KAAM,CACFggD,OAAQ,OACRC,SAAU,CAAC,CAAEl0E,IAAK,OAEtB+0B,KAAM,CACFk/C,OAAQ,OACRC,SAAU,CAAC,CAAEl0E,IAAK,WAK9BmhD,MAAMS,EAAWC,GACjBhiD,KAAK2+D,iBAAoBvc,IACrB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,OAC/B,KAAA8T,mBAAkBpoC,GAClBnvB,KAAKqhE,WAAY,EACjB,MAAM/tB,EAActzC,KAAKmvF,iBAAiB/sC,EAAK,CAC3C,IAAI9gC,GACJ,IAAIA,MAER,IAAA+zC,eAAc/hB,EAAYnkB,GAC1B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAYzE,OAXAh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,YAAa,EACbya,eAAe,EACfxa,eAAe,EACfE,UAAU,GAEdl2E,KAAKyhE,cAActyC,GACnBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GAC/BvqB,GAEXtzC,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,KACvD,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,KAAE4R,GAASomC,GACVse,EAAQC,GAAU3kD,EAAK+nD,QAAQxmD,OAChCgiF,EAAev0F,EAASinD,cAAcyO,GACtC8+B,EAAex0F,EAASinD,cAAc0O,GACtC8I,EAAO,CACTj/D,MAAO,CACH4B,EAAGmzF,EAAa,GAChBjzF,EAAGizF,EAAa,IAEpBz+E,IAAK,CACD1U,EAAGozF,EAAa,GAChBlzF,EAAGkzF,EAAa,KAIxB,OADwB,mBAA4B,CAAC/1B,EAAKj/D,MAAM4B,EAAGq9D,EAAKj/D,MAAM8B,GAAI,CAACm9D,EAAK3oD,IAAI1U,EAAGq9D,EAAK3oD,IAAIxU,GAAI,CAACy5D,EAAa,GAAIA,EAAa,MACpHC,GAK3Bl3D,KAAKo3D,qBAAuB,CAAChV,EAAK9O,KAC9B,MAAMviB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB,MAAMgJ,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACA2yB,eAAe,GAEnBxwF,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,IAClB,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAEmY,EAAa,SAAEE,GAAal2E,KAAK29D,UACpE,KAAEzwD,GAASomC,EACb0iC,IAAkBE,IAGtBhpE,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK09D,kBAAkBvuC,GACvBnvB,KAAK0hE,gBAAgBvyC,IACrB,KAAAyuC,oBAAmBzuC,GACfnvB,KAAKwkF,sBACLxkF,KAAKyM,cAAc23E,4BACnB,IAAA1vB,kBAAiBphB,EAAWqhB,gBAEhC,EAAAoC,EAAA,GAAsC8G,GACtC79D,KAAKsvF,eACDtZ,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,IAErBrhE,KAAKqiD,cAAiBD,IAClBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,YAAEkY,EAAW,cAAEya,EAAa,cAAExa,GAAmBh2E,KAAK29D,UACvF,KAAEzwD,GAASomC,EAEjB,GADAtzC,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBACnCwa,EAAe,CACf,MAAM,YAAEjtC,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,OAC5B,QAAEuhC,GAAY93E,EAAK+nD,SACnB,cAAEgwB,GAAkBD,EAC1BC,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC3L,EAAQ9O,UAAW,CACvB,MACK,QAAoBl4E,IAAhB+3E,EAA2B,CAChC,MAAM,YAAExyB,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,MACnBv2C,EAAK+nD,QAAQxmD,OACrBxN,QAASqN,IACZA,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,KAE9Br9C,EAAW/3C,aAAc,CAC7B,KACK,CACD,MAAM,cAAEyqD,GAAkBj1B,EACpBzP,EAAW0kC,EAAcvC,MAC/Bv2C,EAAK+nD,QAAQxmD,OAAOsnE,GAAe,IAAIz0D,GACvCgyB,EAAW/3C,aAAc,CAC7B,CACAyE,KAAK29D,SAASuY,UAAW,GACzB,EAAAnf,EAAA,GAAsC8G,GAClCvqB,EAAW/3C,cACX,KAAAi4C,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAY03C,iBAGnEnrF,KAAKiL,OAAUkkB,IACX,GAAInvB,KAAKqhE,UAAW,CAChBrhE,KAAKqhE,WAAY,EACjBrhE,KAAK0hE,gBAAgBvyC,GACrBnvB,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,WAAEmkB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,KAAEzwD,GAASomC,EAQjB,OAPAA,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,MACjC,EAAAne,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KACTrqB,EAAWqhB,aACtB,GAEJ30D,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKyhE,cAAiBtyC,IAClB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK0hE,gBAAmBvyC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACpB,IAAIq4D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAGX,GADAnE,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAAO83D,EAEX,MAAMlyC,EAAWxmB,KAAKszE,YAAYp3E,GAC5Byd,EAAkBzd,EAASiyB,qBAC3B4zC,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6qD,EAAY3zD,OAAQ8I,IAAK,CACzC,MAAM4pC,EAAaihB,EAAY7qD,IACzB,cAAEirD,EAAa,KAAEznD,GAASomC,GAC1B,OAAE7kC,EAAM,kBAAEymE,GAAsBhoE,EAAK+nD,QAC3C8M,EAAepN,cAAgBA,EAC/B,MAAM,MAAEv4D,EAAK,UAAE83D,EAAS,SAAE0H,EAAQ,OAAEyM,GAAWroE,KAAKiiE,mBAAmB,CACnE3uB,aACAyuB,mBAEEC,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAYnE,GAXKxB,EAAKs0D,YAAYh7C,IACiB,MAAnCtZ,EAAKs0D,YAAYh7C,GAAUoqE,KAOtBt9C,EAAW/3C,aAChByE,KAAK6wF,+BAA+Bv9C,EAAY35B,EAAiBre,IAPjE4R,EAAKs0D,YAAYh7C,GAAY,CACzB5lB,OAAQ,KACRgwF,KAAM,MAEV5wF,KAAK8wF,sBAAsBx9C,EAAY35B,EAAiBre,KAKvDY,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,IAAIge,EACJ,KAAK,KAAAC,qBAAoBhiB,GACrB,UAEC,KAAAkD,oBAAmBlD,IACnB30D,KAAK29D,UACgB,OAAtBuX,IACAwB,EAA2B,CAAC1U,EAAkBkT,KAElD,MAAM6b,EAAoB96B,SAAQ,QAAiB,oBAAqB,CAAC,IACzE,GAAIygB,GAA4Bqa,EAAmB,CAC/C,MAAMna,EAAiB,KACvB,IAAA7I,aAAe9V,EAAkBtD,EAAeiiB,EAAgB5U,EAAmB,CAC/E5lE,QACAw/D,WACA1H,aAER,CACA,MAAMgO,EAAS,GAAGvN,SACZ8G,EAAU,IAQhB,IAPA,IAAAC,UAAYzD,EAAkBtD,EAAe8G,EAASuG,EAAkB,GAAIA,EAAkB,GAAI,CAC9F5lE,QACAQ,MAAOs3D,EACP0H,WACAyM,UACDnG,GACHxJ,GAAe,GACVx8D,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,MAAMt0D,EAAUpE,KAAKuvF,sBAAsBxtB,EAAgBzuB,GAC3D,IAAKlvC,EAAQurB,WAAY,CACrBziB,EAAK+nD,QAAQ+vB,QAAU,CACnB9O,UAAU,EACV+O,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChB7tD,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB6tD,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM6R,EAAYhxF,KAAKyM,cAAc6jF,aAAapjF,EAAMsZ,GACxD,IAAKtZ,EAAK+nD,QAAQ+vB,QAAQ9O,SAAU,CAChC,MAAM+a,GAAsB,IAAAC,wBAAuBlvB,GACnD90D,EAAK+nD,QAAQ+vB,QAAQC,cACjB/oF,EAASk1B,cAAc6/D,EAC/B,CACA,MAAME,EAAkBj1F,EAASinD,cAAcj2C,EAAK+nD,QAAQ+vB,QAAQC,eAC9DuK,EAAa,IACb4B,GAAc,IAAAC,mBAAqBp5B,EAAkBtD,EAAe66B,EAAYwB,EAAWG,EAAiBnvB,EAAmB,CAAC,EAAG59D,IACjI9G,EAAGilE,EAAM/kE,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWu0F,EAC3ClkF,EAAK+nD,QAAQ+vB,QAAQE,iBAAmB,CACpChG,QAAShjF,EAASk1B,cAAc,CAACmxC,EAAM5tD,IACvC0c,SAAUn1B,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,IAChD2c,WAAYp1B,EAASk1B,cAAc,CAACmxC,EAAM5tD,EAAM9X,IAChDsiF,YAAajjF,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,EAAM9X,IAEjE,CACA,OAAO67D,GAEX14D,KAAK6wF,gCAAiC,EAAAS,EAAA,GAAStxF,KAAK8wF,sBAAuB,IAAK,CAAES,UAAU,GAChG,QACSvxF,KAAKyvF,QAAU,CAACvgE,EAAYzgB,EAAQrK,KACzC,MAAM9I,GAAiB,IAAAq9E,+BAA8BzpD,GACrD,IAAK5zB,EACD,OAEJ,MAAM,oBAAE0O,EAAmB,kBAAEzD,EAAiB,gBAAEgb,EAAe,SAAEklB,EAAQ,SAAEvqC,GAAc8D,KAAKwxF,YAAYnB,GAAY/0F,EAAgBmT,EAAQrK,IACxI,aAAEo4E,KAAiBiV,GAAwBrtF,GAAW,CAAC,EACvDkvC,EAAa,CACfqhB,cAAevwD,GAASuwD,eAAiB,EAAA3jB,UAAA,SACzC9jC,KAAM,CACF+nD,QAAS,CACLxmD,WAGRomD,aAAa,EACb66B,eAAe,EACfn0F,aAAa,EACbmyF,UAAU,EACVC,WAAW,EACXzmF,SAAU,CACN08C,SAAUnd,EAASuuB,cACnBzzC,kBACAvX,sBACAzD,uBACGkrF,KAGX,IAAAp8B,eAAc/hB,EAAYp3C,EAASizB,UACnC,EAAA4nC,EAAA,GAAsC,CAAC76D,EAASmN,KACjD,CACH,sBAAAy1D,CAAuB1c,EAAK9O,EAAYyrB,GACpC,MAAMhuC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,KAAE7jB,GAASomC,EACjBA,EAAWuhB,aAAc,EACzB,IACIkhB,EADAya,GAAgB,EAEhBzxB,EAAOkmB,cACPuL,GAAgB,EAGhBza,EAAc7oE,EAAK+nD,QAAQxmD,OAAO+D,UAAW9D,GAAMA,IAAMqwD,GAE7D,MAAMlB,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,cACAya,iBAEJxwF,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,IAClB,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,gBACR,CACA,gBAAAk6B,CAAiBC,EAAMC,GACnB,MAAM9sE,EAAK6sE,EAAK,GAAKC,EAAK,GACpB7sE,EAAK4sE,EAAK,GAAKC,EAAK,GACpB5sE,EAAK2sE,EAAK,GAAKC,EAAK,GAC1B,OAAO30F,KAAKopC,KAAKvhB,EAAKA,EAAKC,EAAKA,EAAKC,EAAKA,EAC9C,CACA,qBAAA8rE,CAAsBx9C,EAAY35B,EAAiBre,GAC/C,MAAM4R,EAAOomC,EAAWpmC,MAClB,QAAEiiB,GAAY7zB,EAAeY,SAC7B21F,EAAY3kF,EAAK+nD,QAAQxmD,OAAO,GAChCqjF,EAAY5kF,EAAK+nD,QAAQxmD,OAAO,IAChC,YAAE+yD,GAAgBt0D,EAClB6kF,EAAYnyF,OAAO4B,KAAKggE,GAC9B,IAAK,IAAI93D,EAAI,EAAGA,EAAIqoF,EAAUnxF,OAAQ8I,IAAK,CACvC,MAAM8c,EAAWurE,EAAUroF,GACrBlO,EAAQwE,KAAKogF,mBAAmB55D,GACtC,IAAKhrB,EACD,SAEJ,MAAM,UAAEmpB,EAAS,WAAE9c,GAAerM,EAC5By0F,EAAS,GAAsBtrE,EAAWktE,GAC1C3B,EAAS,GAAsBvrE,EAAWmtE,GAC1C78B,EAAU,CAACg7B,EAAQC,IACnB,MAAE1zF,EAAK,KAAEo0F,IAAS,QAAiCp1F,EAAOy5D,GAC1Dr0D,EAASZ,KAAK0xF,iBAAiBG,EAAWC,GAAat1F,EACzDwD,KAAKgwF,gBAAgBC,EAAQC,EAAQroF,GACrC7H,KAAKwkF,sBAAuB,EAG5BxkF,KAAKwkF,sBAAuB,EAEhChjB,EAAYh7C,GAAY,CACpB5lB,SACAgwF,OAER,CACA,MAAMr1F,EAAc+3C,EAAW/3C,YAK/B,OAJA+3C,EAAW/3C,aAAc,EACrBA,IACA,KAAAi4C,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAYu+C,cAExDxwB,CACX,CACA,eAAAwuB,CAAgBC,EAAQC,EAAQroF,GAC5B,OAAQ,kCAA8BooF,EAAQpoF,IAC1C,kCAA8BqoF,EAAQroF,EAC9C,EAEJ,SAAS0oF,GAAoBrjF,EAAMsZ,GAC/B,MAAMyrE,EAAoB/kF,EAAKs0D,YAAYh7C,IACrC,OAAE5lB,EAAM,KAAEgwF,GAASqB,EACzB,GAAIrxF,SAA2C4b,MAAM5b,GACjD,OAGJ,MADkB,CAAC,GAAG,wBAAoBA,MAAWgwF,IAEzD,CACA,MC1aQlsD,sBAAqB,IAAK,YAClC,MAAMwtD,WAAmB,aACZlyF,KAAK4jD,SAAW,QAAU,CACnC,WAAAnkD,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX23E,2BAA2B,EAC3BkM,aAAc,MAGlBhvC,MAAMS,EAAWC,GACjBhiD,KAAK2+D,iBAAoBvc,IACrB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,OAC/B,KAAA8T,mBAAkBpoC,GAClBnvB,KAAKqhE,WAAY,EACjB,MAAM/tB,EAActzC,KAAKmvF,iBAAiB/sC,EAAK,CAC3C,IAAI9gC,GACJ,IAAIA,MAER,IAAA+zC,eAAc/hB,EAAYnkB,GAC1B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAYzE,OAXAh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,YAAa,EACbya,eAAe,EACfxa,eAAe,EACfE,UAAU,GAEdl2E,KAAKyhE,cAActyC,GACnBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GAC/BvqB,GAEXtzC,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,KACvD,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,KAAE4R,GAASomC,GACVse,EAAQC,GAAU3kD,EAAK+nD,QAAQxmD,OAChCgiF,EAAev0F,EAASinD,cAAcyO,GACtC8+B,EAAex0F,EAASinD,cAAc0O,GACtC8I,EAAO,CACTj/D,MAAO,CACH4B,EAAGmzF,EAAa,GAChBjzF,EAAGizF,EAAa,IAEpBz+E,IAAK,CACD1U,EAAGozF,EAAa,GAChBlzF,EAAGkzF,EAAa,KAIxB,OADwB,mBAA4B,CAAC/1B,EAAKj/D,MAAM4B,EAAGq9D,EAAKj/D,MAAM8B,GAAI,CAACm9D,EAAK3oD,IAAI1U,EAAGq9D,EAAK3oD,IAAIxU,GAAI,CAACy5D,EAAa,GAAIA,EAAa,MACpHC,GAK3Bl3D,KAAKo3D,qBAAuB,CAAChV,EAAK9O,KAC9B,MAAMviB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB,MAAMgJ,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACA2yB,eAAe,GAEnBxwF,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,IACK,IAAA4L,mBAAkB5L,IACzC,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAEmY,EAAa,SAAEE,GAAal2E,KAAK29D,UACpE,KAAEzwD,GAASomC,EACjB,GAAI0iC,IAAkBE,EAClB,OAEJhpE,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK09D,kBAAkBvuC,GACvBnvB,KAAK0hE,gBAAgBvyC,IACrB,KAAAyuC,oBAAmBzuC,GACnB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,EACxB0E,KAAKwkF,sBACLxkF,KAAKyM,cAAc23E,4BACnB,IAAA1vB,kBAAiBphB,EAAWqhB,gBAEhC,EAAAoC,EAAA,GAAsC8G,GACtC79D,KAAKsvF,eACDtZ,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,GAErBrhE,KAAKqiD,cAAiBD,IAClBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,YAAEkY,EAAW,cAAEya,EAAa,cAAExa,GAAkBh2E,KAAK29D,UACtF,KAAEzwD,GAASomC,EAEjB,GADAtzC,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBACnCwa,EAAe,CACf,MAAM,YAAEjtC,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,OAC5B,QAAEuhC,GAAY93E,EAAK+nD,SACnB,cAAEgwB,GAAkBD,EAC1BC,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC3L,EAAQ9O,UAAW,CACvB,MACK,QAAoBl4E,IAAhB+3E,EAA2B,CAChC,MAAM,YAAExyB,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,MACnBv2C,EAAK+nD,QAAQxmD,OACrBxN,QAASqN,IACZA,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,KAE9Br9C,EAAW/3C,aAAc,CAC7B,KACK,CACD,MAAM,cAAEyqD,GAAkBj1B,EACpBzP,EAAW0kC,EAAcvC,MAC/Bv2C,EAAK+nD,QAAQxmD,OAAOsnE,GAAe,IAAIz0D,GACvCgyB,EAAW/3C,aAAc,CAC7B,CACAyE,KAAK29D,SAASuY,UAAW,EACzB,MAAM56E,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,IAE1C79D,KAAKiL,OAAUkkB,IACX,GAAInvB,KAAKqhE,UAAW,CAChBrhE,KAAKqhE,WAAY,EACjBrhE,KAAK0hE,gBAAgBvyC,GACrBnvB,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,WAAEmkB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,KAAEzwD,GAASomC,EACjBA,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,MACV,IAAAn6C,mBAAkB5L,GAMzC,OALA,EAAA4nC,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KACTrqB,EAAWqhB,aACtB,GAEJ30D,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKyhE,cAAiBtyC,IAClB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK0hE,gBAAmBvyC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACpB,IAAIq4D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAGX,GADAnE,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAAO83D,EAEX,MAAMlyC,EAAWxmB,KAAKszE,YAAYp3E,GAC5Byd,EAAkBzd,EAASiyB,qBAC3B4zC,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6qD,EAAY3zD,OAAQ8I,IAAK,CACzC,MAAM4pC,EAAaihB,EAAY7qD,IACzB,cAAEirD,EAAa,KAAEznD,GAASomC,GAC1B,OAAE7kC,EAAM,kBAAEymE,GAAsBhoE,EAAK+nD,QAC3C8M,EAAepN,cAAgBA,EAC/B,MAAM,MAAEv4D,EAAK,UAAE83D,EAAS,SAAE0H,EAAQ,OAAEyM,GAAWroE,KAAKiiE,mBAAmB,CACnE3uB,aACAyuB,mBAEEC,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IACnE,IAAIgoE,EAYJ,GAXKxpE,EAAKs0D,YAAYh7C,IACiB,MAAnCtZ,EAAKs0D,YAAYh7C,GAAUoqE,KAOtBt9C,EAAW/3C,aAChByE,KAAK6wF,+BAA+Bv9C,EAAY35B,EAAiBre,IAPjE4R,EAAKs0D,YAAYh7C,GAAY,CACzB5lB,OAAQ,KACRgwF,KAAM,MAEV5wF,KAAK8wF,sBAAsBx9C,EAAY35B,EAAiBre,MAKvD,KAAAq7E,qBAAoBhiB,GACrB,UAEC,KAAAkD,oBAAmBlD,IACnB30D,KAAK29D,UACgB,OAAtBuX,IACAwB,EAA2B,CAAC1U,EAAkBkT,KAElD,MAAM6b,EAAoB96B,SAAQ,QAAiB,oBAAqB,CAAC,IACzE,GAAIygB,GAA4Bqa,EAAmB,CAC/C,MAAMna,EAAiB,KACvB,IAAA7I,aAAe9V,EAAkBtD,EAAeiiB,EAAgB5U,EAAmB,CAC/E5lE,QACAw/D,WACA1H,aAER,CACA,MAAMi+B,EAAY,IAOlB,IANA,IAAAC,YAAcn6B,EAAkBtD,EAAew9B,EAAWnwB,EAAkB,GAAIA,EAAkB,GAAI,CAClG5lE,QACAQ,MAAOs3D,EACP0H,SAAUA,IAEdlD,GAAe,GACVx8D,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,MAAMt0D,EAAUpE,KAAKuvF,sBAAsBxtB,EAAgBzuB,GAC3D,IAAKlvC,EAAQurB,WAAY,CACrBziB,EAAK+nD,QAAQ+vB,QAAU,CACnB9O,UAAU,EACV+O,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChB7tD,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB6tD,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM6R,EAAYhxF,KAAKyM,cAAc6jF,aAAapjF,EAAMsZ,GACxD,IAAKtZ,EAAK+nD,QAAQ+vB,QAAQ9O,SAAU,CAChC,MAAM+a,GAAsB,IAAAC,wBAAuBlvB,GACnD90D,EAAK+nD,QAAQ+vB,QAAQC,cACjB/oF,EAASk1B,cAAc6/D,EAC/B,CACA,MAAME,EAAkBj1F,EAASinD,cAAcj2C,EAAK+nD,QAAQ+vB,QAAQC,eAC9DuK,EAAa,IACb4B,GAAc,IAAAC,mBAAqBp5B,EAAkBtD,EAAe66B,EAAYwB,EAAWG,EAAiBnvB,EAAmB,CAAC,EAAG59D,IACjI9G,EAAGilE,EAAM/kE,EAAM,MAAEZ,EAAK,OAAEC,GAAWu0F,EAC3ClkF,EAAK+nD,QAAQ+vB,QAAQE,iBAAmB,CACpChG,QAAShjF,EAASk1B,cAAc,CAACmxC,EAAM5tD,IACvC0c,SAAUn1B,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,IAChD2c,WAAYp1B,EAASk1B,cAAc,CAACmxC,EAAM5tD,EAAM9X,IAChDsiF,YAAajjF,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,EAAM9X,IAEjE,CACA,OAAO67D,GAEX14D,KAAK6wF,gCAAiC,EAAAS,EAAA,GAAStxF,KAAK8wF,sBAAuB,IAAK,CAAES,UAAU,GAChG,CACA,sBAAAzyB,CAAuB1c,EAAK9O,EAAYyrB,GACpC,MAAMhuC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,KAAE7jB,GAASomC,EACjBA,EAAWuhB,aAAc,EACzB,IACIkhB,EADAya,GAAgB,EAEhBzxB,EAAOkmB,cACPuL,GAAgB,EAGhBza,EAAc7oE,EAAK+nD,QAAQxmD,OAAO+D,UAAW9D,GAAMA,IAAMqwD,GAE7D,MAAMlB,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,cACAya,iBAEJxwF,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,GAClB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,GACtCzb,EAAIoV,gBACR,CACA,gBAAA66B,CAAiBV,EAAMC,GACnB,MAAM9sE,EAAK8sE,EAAK,GAAKD,EAAK,GACpB5sE,EAAK6sE,EAAK,GAAKD,EAAK,GACpB3sE,EAAK4sE,EAAK,GAAKD,EAAK,GAC1B,OAAU,GAAN7sE,EACU,GAANC,EACO9nB,KAAK6e,IAAIkJ,GAGT,EAGA,GAAND,EACE9nB,KAAK6e,IAAIkJ,GAEL,GAANA,EACE/nB,KAAK6e,IAAIiJ,QADf,CAGT,CACA,qBAAA+rE,CAAsBx9C,EAAY35B,EAAiBre,GAC/C,MAAM4R,EAAOomC,EAAWpmC,MAClB,QAAEiiB,GAAY7zB,EAAeY,SAC7B21F,EAAY3kF,EAAK+nD,QAAQxmD,OAAO,GAChCqjF,EAAY5kF,EAAK+nD,QAAQxmD,OAAO,IAChC,YAAE+yD,GAAgBt0D,EAClB6kF,EAAYnyF,OAAO4B,KAAKggE,GAC9B,IAAK,IAAI93D,EAAI,EAAGA,EAAIqoF,EAAUnxF,OAAQ8I,IAAK,CACvC,MAAM8c,EAAWurE,EAAUroF,GACrBlO,EAAQwE,KAAKogF,mBAAmB55D,GACtC,IAAKhrB,EACD,SAEJ,MAAM,UAAEmpB,EAAS,WAAE9c,GAAerM,EAC5By0F,EAAS,GAAsBtrE,EAAWktE,GAC1C3B,EAAS,GAAsBvrE,EAAWmtE,GAC1C78B,EAAU,CAACg7B,EAAQC,IACnB,MAAE1zF,EAAK,KAAEo0F,IAAS,QAAiCp1F,EAAOy5D,GAC1Dp4D,EAASmD,KAAKqyF,iBAAiBR,EAAWC,GAAat1F,EACvD81F,EAAUtyF,KAAKgwF,gBAAgBC,EAAQC,EAAQroF,GACrD7H,KAAKwkF,qBAAuB8N,EAC5B9wB,EAAYh7C,GAAY,CACpB3pB,SACA+zF,OAER,CACA,MAAMr1F,EAAc+3C,EAAW/3C,YAK/B,OAJA+3C,EAAW/3C,aAAc,EACrBA,IACA,KAAAi4C,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAYu+C,cAExDxwB,CACX,CACA,eAAAwuB,CAAgBC,EAAQC,EAAQroF,GAC5B,OAAQ,kCAA8BooF,EAAQpoF,IAC1C,kCAA8BqoF,EAAQroF,EAC9C,EAEJ,SAAS,GAAoBqF,EAAMsZ,GAC/B,MAAMyrE,EAAoB/kF,EAAKs0D,YAAYh7C,IACrC,OAAE3pB,EAAM,KAAE+zF,GAASqB,EACzB,GAAIp1F,SAA2C2f,MAAM3f,GACjD,OAGJ,MADkB,CAAC,GAAG,wBAAoBA,MAAW+zF,IAEzD,C,gBC3YA,MAAQlsD,sBAAqB,IAAK,YAClC,MAAM6tD,WAAkB,aACXvyF,KAAK4jD,SAAW,OAAS,QACzB5jD,KAAKwyF,cAAgB,CAC1BvwC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX47D,QAAQ,EACR+b,2BAA2B,EAC3BkM,aAAc,GACd9nB,aAAc,IACdiqB,iBAAkB,CACdn1F,EAAG,EACHE,GAAI,IAGb,CACH,WAAAiC,CAAYsiD,EAAY,CAAC,EAAGC,GACxBV,MAAMS,EAAW,MAAe2wC,kBAAkBH,GAAUC,cAAexwC,IAC3EhiD,KAAK2+D,iBAAoBvc,IACrB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,MACzBnoD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACrB0E,KAAKqhE,WAAY,EACjB,MAAM/tB,EAActzC,KAAgB,YAAE2yF,4BAA4Bz2F,EAAU,CACxEgR,KAAM,CACF+nD,QAAS,CAAExmD,OAAQ,CAAC,IAAI6S,SAGhC,IAAA+zC,eAAc/hB,EAAYnkB,GAC1B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAUzE,OATAh1D,KAAK29D,SAAW,CACZrqB,aACA0iC,eAAe,EACfnY,uBAEJ79D,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,GAClBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GAC/BvqB,GAEXtzC,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,WAAEzuC,EAAU,gBAAEvV,IAAoB,IAAAohB,mBAAkB5L,GAC1DnvB,KAAK4yF,oBAAsB,CACvB1jE,aACAhB,kBAAmBvU,EAAgBtQ,IAEvCrJ,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACf6mD,GACAh2E,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBAE3Ch2E,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,EACjBrhE,KAAKsvF,eACDtvF,KAAKwkF,sBACLxkF,KAAKyM,cAAc23E,4BACnB,IAAA1vB,kBAAiBphB,EAAWqhB,gBAEhC,EAAAoC,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,IAGnCtzC,KAAKqiD,cAAiBD,IAClBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,OACzB,WAAEnQ,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,KAAEzwD,GAASomC,EACjBtzC,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBACvC9oE,EAAK+nD,QAAQxmD,OAAO,GAAK,IAAI6S,GAC7BgyB,EAAW/3C,aAAc,GACzB,EAAAw7D,EAAA,GAAsC8G,IAE1C79D,KAAKiL,OAAUkkB,IACX,GAAInvB,KAAKqhE,UAAW,CAChBrhE,KAAKqhE,WAAY,EACjBrhE,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,WAAEmkB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,KAAEzwD,GAASomC,EAQjB,OAPAA,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,MACjC,EAAAne,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KACTrqB,EAAWqhB,aACtB,GAEJ30D,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACpB,IAAIq4D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAGX,GADAnE,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAAO83D,EAEX,MAAMlyC,EAAWxmB,KAAKszE,YAAYp3E,GAC5Byd,EAAkBzd,EAASiyB,qBAC3B4zC,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6qD,EAAY3zD,OAAQ8I,IAAK,CACzC,MAAM4pC,EAAaihB,EAAY7qD,GACzBirD,EAAgBrhB,EAAWqhB,cAC3BznD,EAAOomC,EAAWpmC,KAClBoB,EAAQpB,EAAK+nD,QAAQxmD,OAAO,GAC5BuzD,EAAoB9lE,EAASinD,cAAc70C,GACjDyzD,EAAepN,cAAgBA,EAC/B,MAAM,MAAEv4D,EAAK,UAAE83D,GAAcl0D,KAAKiiE,mBAAmB,CACjD3uB,aACAyuB,mBAKJ,GAHK70D,EAAKs0D,cACNt0D,EAAKs0D,YAAc,CAAC,GAEnBt0D,EAAKs0D,YAAYh7C,IACmB,OAArCtZ,EAAKs0D,YAAYh7C,GAAUvmB,OAQ1B,GAAIqzC,EAAW/3C,cAChByE,KAAK8wF,sBAAsBx9C,EAAY35B,EAAiBre,GACpDY,aAAoB,EAAAg3C,gBAAgB,CACpC,MAAM,kBAAE3sC,GAAsB+sC,EAAWpsC,SACzC,IAAK,MAAMsf,KAAYtZ,EAAKs0D,YACxB,GAAIh7C,EAASxlB,WAAW,WAAY,CACd2Y,EAAgBk5E,oBACCn1E,KAAMiK,IACrC,MAAMmrE,EAAqB,yBAAqBvsF,GAC1C8vB,EAAc1O,EAAG0O,YAAYy8D,GAC7BC,EAAkB,yBAAqBprE,EAAGwa,qBAChD,OAAO9L,GAAe08D,IAAoBD,YAGnC5lF,EAAKs0D,YAAYh7C,EAEhC,CAER,OAzBAtZ,EAAKs0D,YAAYh7C,GAAY,CACzBuhB,SAAU,KACVv/B,MAAO,KACPvI,MAAO,MAEXD,KAAK8wF,sBAAsBx9C,EAAY35B,EAAiBre,EAAgB,EAAAm4C,YAAYu+C,cAsBxF,IAAK91F,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,KAAK,KAAAie,qBAAoBhiB,GACrB,SAEJ,MAAMiiB,EAAiB,KACvB,IAAA7I,aAAe9V,EAAkBtD,EAAeiiB,EAAgB,CAAC5U,GAAoB,CAAE5lE,QAAO83D,YAAWsU,aAAcxoE,KAAKyM,cAAc+7D,eAC1I9P,GAAe,EACf,MAAMt0D,EAAUpE,KAAKuvF,sBAAsBxtB,EAAgBzuB,GAC3D,IAAKlvC,EAAQurB,WACT,SAEJ,MAAMqhE,EAAYhxF,KAAKyM,cAAc6jF,aAAapjF,EAAMsZ,GACxD,GAAIwqE,EAAW,CACX,MAAM1H,EAAwB,CAC1BtnB,EAAkB,GAAKhiE,KAAKyM,cAAcgmF,iBAAiBn1F,EAC3D0kE,EAAkB,GAAKhiE,KAAKyM,cAAcgmF,iBAAiBj1F,GAEzDw1F,EAAU,KAChB,IAAAvJ,aAAexxB,EAAkBtD,EAAeq+B,EAAShC,EAAW,CAAC1H,EAAsB,GAAIA,EAAsB,IAAKllF,EAC9H,CACJ,CACA,OAAOs0D,EAEf,CACA,eAAA1B,CAAgB7nC,EAASmkB,EAAY2jB,EAAcC,GAC/C,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,KAAE4R,GAASomC,EACXhlC,EAAQpB,EAAK+nD,QAAQxmD,OAAO,GAC5BkjE,EAA6Bz1E,EAASinD,cAAc70C,GAC1D,OAAO,cAAc2oD,EAAc0a,GAA8Bza,CACrE,CACA,oBAAAE,GAAyB,QAChBp3D,KAAKyvF,QAAU,CAACvgE,EAAYzgB,EAAQrK,KACzC,MAAM9I,GAAiB,IAAAq9E,+BAA8BzpD,GACrD,IAAK5zB,EACD,OAEJ,MAAM,oBAAE0O,EAAmB,kBAAEzD,EAAiB,gBAAEgb,EAAe,OAAEyjB,EAAM,SAAEyB,EAAQ,SAAEvqC,GAAc8D,KAAKwxF,YAAYe,GAAWj3F,EAAgBmT,EAAQrK,IAC/I,aAAEo4E,KAAiBiV,GAAwBrtF,GAAW,CAAC,EACvDkvC,EAAa,CACfqhB,cAAevwD,GAASuwD,eAAiB,qBACzCznD,KAAM,CACF+nD,QAAS,CACLxmD,WAGRomD,aAAa,EACb66B,eAAe,EACfn0F,aAAa,EACbmyF,UAAU,EACVC,WAAW,EACXzmF,SAAU,CACN08C,SAAUnd,EAASuuB,cACnBzzC,kBACAvX,sBACAzD,uBACGkrF,KAGX,IAAAp8B,eAAc/hB,EAAYp3C,EAASizB,UACnC,EAAA4nC,EAAA,GAAsC,CAAC76D,EAASmN,KACjD,CACH,uBAAAmhE,CAAwBr7C,EAASmkB,EAAY2jB,EAAcC,GACvD,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,KAAE4R,GAASomC,EACXhlC,EAAQpB,EAAK+nD,QAAQxmD,OAAO,GAC5BkjE,EAA6Bz1E,EAASinD,cAAc70C,GAE1D,IAAa,IADA,cAAc2oD,EAAc0a,GAA8Bza,EAEnE,OAAO5oD,CAEf,CACA,sBAAAwwD,CAAuB1c,EAAK9O,GACxB,MAAMviB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB,MAAMgJ,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,uBAEJ79D,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,IAClB,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,gBACR,CACA,qBAAAs5B,CAAsBx9C,EAAY35B,EAAiBre,EAAgB23F,EAAa,EAAAx/C,YAAYu+C,cACxF,MAAM9kF,EAAOomC,EAAWpmC,MAClB,kBAAEghB,EAAiB,SAAEhyB,GAAaZ,GAClC,QAAE6zB,GAAYjzB,EACdolB,EAAWpU,EAAK+nD,QAAQxmD,OAAO,IAC/B,YAAE+yD,GAAgBt0D,EAClB6kF,EAAYnyF,OAAO4B,KAAKggE,GAC9B,IAAK,IAAI93D,EAAI,EAAGA,EAAIqoF,EAAUnxF,OAAQ8I,IAAK,CACvC,MAAM8c,EAAWurE,EAAUroF,GACrBwpF,EAAoB,CACtB30F,aAAa,EAAA40F,GAAA,GAAoBj3F,EAAUsqB,GAC3C4sE,YAAapzF,KAAKozF,YAAYl3F,EAAUsqB,EAAU8sB,EAAWpsC,SAASX,oBAEpE/K,EAAQwE,KAAKogF,mBAAmB55D,GACtC,IAAKhrB,EACD,SAEJ,MAAM,WAAEqM,EAAU,UAAE8c,EAAS,SAAEzd,EAAQ,aAAElC,GAAiBxJ,EACpD2C,EAAW+I,EAAS6gC,SAC1B,IAAIsrD,EAAM,GAAsB1uE,EAAWrD,GAE3C,GADA+xE,EAAM,WAAWA,EAAKA,GAClB,kCAA8BA,EAAKxrF,GAAa,CAChD7H,KAAKwkF,sBAAuB,EAC5B,IAQI8O,EARArzF,EAAQ+E,EAAauuF,cAAcF,GACvC,GAAI7sE,EAASxlB,WAAW,YAAa,CACjC,MAAMmD,EAAUqiB,EAASpkB,MAAM,YAAY,GACrCurB,EAAW,yBAAqBxpB,GAEhCjI,EADY,qCAAiCyxB,GACxB,GAC3B0lE,EAAI,GAAKn3F,EAASw6B,wBACtB,CAEA,GAAiB,OAAbv4B,EAAmB,CACnB,MAAMq1F,GAAoB,QAAgCh4F,EAAO,CAC7D63F,IAEEI,EAA0BD,EAAkB74E,OAAO4T,MAAOtuB,GAAoB,OAAVA,GAC1EA,EAASwzF,EAA0BD,EAAkB74E,OAAS1a,EAC9DqzF,EAAeG,EACTD,EAAkBE,MAClB,KACV,MAEIJ,GAAe,EAAAK,GAAA,GAAmBx1F,EAAUm1C,EAAWpsC,SAASX,kBAAmB2sF,GAEvF1xB,EAAYh7C,GAAY,CACpBhe,MAAO6qF,EACPpzF,QACA8nC,SAAU5pC,EACVm1F,gBAEJhgD,EAAW/3C,aAAc,CAC7B,MAEIyE,KAAKwkF,sBAAuB,EAC5BhjB,EAAYh7C,GAAY,CACpBhe,MAAO6qF,EACPtrD,SAAU5pC,EAGtB,CACA,MAAM5C,EAAc+3C,EAAW/3C,YAK/B,OAJA+3C,EAAW/3C,aAAc,EACrBA,IACA,KAAAi4C,2BAA0BF,EAAYnkB,EAAS8jE,GAE5CzxB,CACX,EAEJ,SAAS,GAAoBt0D,EAAMsZ,GAC/B,MAAMyrE,EAAoB/kF,EAAKs0D,YAAYh7C,IACrC,MAAEhe,EAAK,MAAEvI,EAAK,aAAEqzF,GAAiBrB,EACvC,QAAcj0F,IAAViC,IAAwBuI,EACxB,OAEJ,MAAMwoF,EAAY,GAElB,GADAA,EAAUroF,KAAK,IAAIH,EAAM,OAAOA,EAAM,OAAOA,EAAM,OAC/CvI,aAAiBvB,OAAS40F,aAAwB50F,MAClD,IAAK,IAAIgL,EAAI,EAAGA,EAAIzJ,EAAMW,OAAQ8I,IAC9BsnF,EAAUroF,KAAK,GAAG,wBAAoB1I,EAAMyJ,OAAO4pF,EAAa5pF,WAIpEsnF,EAAUroF,KAAK,GAAG,wBAAoB1I,MAAUqzF,KAEpD,OAAOtC,CACX,CACA,YC7WA,MAAM4C,WAAsB,UACf5zF,KAAK4jD,SAAW,WAAa,CACtC,WAAAnkD,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX47D,QAAQ,EACR+b,2BAA2B,EAC3BkM,aAAc,MAGlBhvC,MAAMS,EAAWC,GACjBhiD,KAAK6zF,sBAAyBzxC,IAC1B,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,MACzBnoD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,EAAQ,gBAAEyd,GAAoBre,EACtC0E,KAAKqhE,WAAY,EACjB,MAAM7+C,EAAStmB,EAASumB,aAClB,gBAAElB,EAAe,OAAEyjB,GAAWxiB,EAC9Bjc,EAAoBvG,KAAKshE,qBAAqBplE,EAAUolB,EAAUC,EAAiByjB,GACnFsO,EAAa,CACf/3C,aAAa,EACbs5D,aAAa,EACb84B,WAAW,EACXzmF,SAAU,CACN08C,SAAU5jD,KAAKg1D,cACfzzC,gBAAiB,IAAIA,GACrByjB,OAAQ,IAAIA,GACZh7B,oBAAqB9N,EAASqlE,yBAC9Bh7D,qBAEJ2G,KAAM,CACF0mB,MAAO,GACPqhC,QAAS,CAAExmD,OAAQ,CAAC,IAAI6S,KACxBkgD,YAAa,CAAC,IAGhB3D,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAUzE,OATAh1D,KAAK29D,SAAW,CACZrqB,aACA0iC,eAAe,EACfnY,uBAEJ79D,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,GAClBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GAC/BvqB,GAEXtzC,KAAK8zF,uBAA0B1xC,GACpBpiD,KAAK6zF,sBAAsBzxC,GAEtCpiD,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,EACrB,IAAK0E,KAAK29D,SACN,OAAOjF,EAEX,MAAMnE,EAAcv0D,KAAKy0D,wCAAwCv4D,EAASizB,QAAS,CAACnvB,KAAK29D,SAASrqB,aAClG,IAAKihB,GAAa3zD,OACd,OAAO83D,EAEX,MAAMlyC,EAAWxmB,KAAKszE,YAAYp3E,GAC5Byd,EAAkBzd,EAASiyB,qBAC3B4zC,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAElCiqC,EAAatzC,KAAK29D,SAASrqB,WAC3BqhB,EAAgBrhB,EAAWqhB,cAC3BznD,EAAOomC,EAAWpmC,KAClBoB,EAAQpB,EAAK+nD,QAAQxmD,OAAO,GAC5BuzD,EAAoB9lE,EAASinD,cAAc70C,GACjDyzD,EAAepN,cAAgBA,EAC/B,MAAM,MAAEv4D,GAAU4D,KAAKiiE,mBAAmB,CACtC3uB,aACAyuB,mBAcJ,GAZK70D,EAAKs0D,YAAYh7C,IACmB,OAArCtZ,EAAKs0D,YAAYh7C,GAAUvmB,MAQtBqzC,EAAW/3C,aAChByE,KAAK8wF,sBAAsBx9C,EAAY35B,EAAiBre,IARxD4R,EAAKs0D,YAAYh7C,GAAY,CACzBuhB,SAAU,KACVv/B,MAAO,KACPvI,MAAO,MAEXD,KAAK8wF,sBAAsBx9C,EAAY35B,EAAiBre,KAKvDY,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,GAGX,IAAAqV,aAAe9V,EAAkBtD,EADV,IACyC,CAACqN,GAAoB,CAAE5lE,UACvFs8D,GAAe,EACf,MAAMs4B,EAAYhxF,KAAKyM,cAAc6jF,aAAapjF,EAAMsZ,GACxD,GAAIwqE,EAAW,CACX,MAAM1H,EAAwB,CAC1BtnB,EAAkB,GAAK,EACvBA,EAAkB,GAAK,GAErBgxB,EAAU,KAChB,IAAAvJ,aAAexxB,EAAkBtD,EAAeq+B,EAAShC,EAAW,CAAC1H,EAAsB,GAAIA,EAAsB,IAAKtpF,KAAKuvF,sBAAsBxtB,EAAgBzuB,GACzK,CACA,OAAOolB,EAEf,EAEJ,SAAS,GAAoBxrD,EAAMsZ,GAC/B,MAAMyrE,EAAoB/kF,EAAKs0D,YAAYh7C,IACrC,MAAEhe,EAAK,MAAEvI,EAAK,aAAEqzF,GAAiBrB,EACvC,QAAcj0F,IAAViC,EACA,OAEJ,MAAM+wF,EAAY,GAGlB,OAFAA,EAAUroF,KAAK,IAAIH,EAAM,OAAOA,EAAM,OAAOA,EAAM,OACnDwoF,EAAUroF,KAAK,GAAG1I,EAAMs9B,QAAQ,MAAM+1D,KAC/BtC,CACX,C,gDC1GA,MAAQtsD,sBAAqB,IAAK,YAClC,MAAMqvD,WAA0B,aACnB/zF,KAAK4jD,SAAW,eAAiB,CAC1C,WAAAnkD,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX47D,QAAQ,EACR+b,2BAA2B,EAC3B4P,gBAAgB,EAChBC,kBAAmB,EACnB/I,gBAAgB,EAChBoF,aAAc,GACd4D,gBAAiB,GAAAC,wBAGrB7yC,MAAMS,EAAWC,GACjBhiD,KAAKwkF,sBAAuB,EAC5BxkF,KAAK2+D,iBAAoBvc,IACrB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,MAC/BzjD,KAAKqhE,WAAY,EACjB,MAAM/tB,EAActzC,KAAKmvF,iBAAiB/sC,EAAK,CAC3C,IAAI9gC,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,MAER,IAAA+zC,eAAc/hB,EAAYnkB,GAC1B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAYzE,OAXAh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACArY,YAAalkC,EACb00D,eAAe,EACfE,UAAU,GAEdl2E,KAAKyhE,cAActyC,IACnB,KAAAooC,mBAAkBpoC,GAClBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GAC/BvqB,GAEXtzC,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,KACvD,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,KAAE4R,GAASomC,GACX,OAAE7kC,GAAWvB,EAAK+nD,QAClB+M,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,KAC5Dw4E,EAAQvyE,EAAK4tD,EAAMmjB,GAAS1jB,EAC7BoyB,EAAIn3F,KAAK67C,MAAMypB,EAAK,GAAKmjB,EAAM,GAAInjB,EAAK,GAAKmjB,EAAM,IACnD2O,EAAIp3F,KAAK67C,MAAMnkC,EAAI,GAAKuyE,EAAO,GAAIvyE,EAAI,GAAKuyE,EAAO,IACnDpqF,EAAQG,KAAKk5C,MAAMosB,EAAK,GAAKmjB,EAAM,GAAInjB,EAAK,GAAKmjB,EAAM,IACvD9uE,EAAS,EAAE2rD,EAAK,GAAKmjB,EAAM,IAAM,GAAI/wE,EAAI,GAAKuyE,EAAO,IAAM,GAC3DoN,EAAe,CACjB19E,SACA29E,SAAUH,EAAIl9B,GAAa,EAC3Bs9B,SAAUH,EAAIn9B,GAAa,EAC3Bp6D,SAEE23F,EAAe,CACjB79E,SACA29E,SAAUH,EAAIl9B,GAAa,EAC3Bs9B,SAAUH,EAAIn9B,GAAa,EAC3Bp6D,SAEE43F,EAAsB10F,KAAK20F,sBAAsBL,EAAcr9B,GAErE,SAD4Bj3D,KAAK20F,sBAAsBF,EAAcx9B,IACzCy9B,IAKhC10F,KAAKo3D,qBAAuB,CAAChV,EAAK9O,KAC9B,MAAMviB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB,MAAMgJ,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACA2yB,eAAe,IAEnB,KAAAj5B,mBAAkBpoC,GAClBnvB,KAAKs3D,gBAAgBnoC,GACrB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAK8+D,uBAAyB,CAAC1c,EAAK9O,EAAYyrB,KAC5C,MAAMhuC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,KAAE7jB,GAASomC,EACjBA,EAAWuhB,aAAc,EACzB,IACIkhB,EACAzR,EACA9e,EACA/tB,EACAC,EACAk9D,EANApE,GAAgB,EAOpB,GAAIzxB,EAAOkmB,cACPuL,GAAgB,MAEf,CACD,MAAM,OAAE/hF,GAAWvB,EAAK+nD,SAClB,SAAE/4D,IAAa,IAAA6+B,mBAAkB5L,IACjC,cAAEg0B,EAAa,cAAE/xB,GAAkBl1B,EACzC65E,EAActnE,EAAO+D,UAAW9D,GAAMA,IAAMqwD,GAC5C,MAAM81B,EAAepmF,EAAOpI,IAAI88C,GAChCyxC,EAAuBC,EAAa9e,GACpCt+C,EAAcx6B,KAAK6e,IAAI+4E,EAAa,GAAG,GAAKA,EAAa,GAAG,IAC5Dn9D,EAAez6B,KAAK6e,IAAI+4E,EAAa,GAAG,GAAKA,EAAa,GAAG,IAC7DvwB,EAAe,EACVuwB,EAAa,GAAG,GAAKA,EAAa,GAAG,IAAM,GAC3CA,EAAa,GAAG,GAAKA,EAAa,GAAG,IAAM,GAEhDrvC,EAAcp0B,EAAckzC,EAChC,CACA,MAAMzG,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,cACAt+C,cACAC,eACA8tB,cACAovC,uBACApE,iBAEJxwF,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,IAClB,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAEmY,EAAa,SAAEE,GAAal2E,KAAK29D,UACpE,KAAEzwD,GAASomC,EACb0iC,IAAkBE,IAGtBl2E,KAAKsvF,eACLh8C,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK09D,kBAAkBvuC,GACvBnvB,KAAK0hE,gBAAgBvyC,IACrB,KAAAyuC,oBAAmBzuC,GACnBnvB,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,EACbrhE,KAAKwkF,sBACLxkF,KAAKyM,cAAc23E,4BACnB,IAAA1vB,kBAAiBphB,EAAWqhB,gBAEhC,EAAAoC,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,KAGnCtzC,KAAKi2E,kBAAqB7zB,IACtBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,cAAEi1B,GAAkBj1B,EACpBulD,EAAsBtwB,EAAcvqD,OACpCH,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,cAAE81B,GAAkBl1B,GACpB,WAAEo3C,EAAU,oBAAEuqB,EAAmB,YAAErY,EAAW,cAAEwwB,GAAkBh2E,KAAK29D,SAC7E39D,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBACvC,MAAM1R,EAAepoE,EAASinD,cAAcqC,IACtC,KAAEt4C,GAASomC,EACXwhD,EAAK73F,KAAK6e,IAAIw6D,EAAoB,GAAKhS,EAAa,IACpDywB,EAAK93F,KAAK6e,IAAIw6D,EAAoB,GAAKhS,EAAa,IACpD0wB,EAAe,CAAC1wB,EAAa,GAAIA,EAAa,GAAKywB,GACnDE,EAAY,CAAC3wB,EAAa,GAAIA,EAAa,GAAKywB,GAChDG,EAAa,CAAC5wB,EAAa,GAAKwwB,EAAIxwB,EAAa,IACjD6wB,EAAc,CAAC7wB,EAAa,GAAKwwB,EAAIxwB,EAAa,IACxDp3D,EAAK+nD,QAAQxmD,OAAS,CAClB2iB,EAAc4jE,GACd5jE,EAAc6jE,GACd7jE,EAAc8jE,GACd9jE,EAAc+jE,IAElB7hD,EAAW/3C,aAAc,EACzByE,KAAK29D,SAASuY,UAAW,GACzB,EAAAnf,EAAA,GAAsC8G,IACtC,KAAArqB,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAY03C,iBAE/DnrF,KAAKm2E,oBAAuB/zB,IACxBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,YAAEkY,EAAW,cAAEya,EAAa,cAAExa,GAAmBh2E,KAAK29D,SAC7F39D,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBACvC,MAAM,KAAE9oE,GAASomC,EACjB,GAAIk9C,EAAe,CACf,MAAM,YAAEjtC,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,OAC5B,QAAEuhC,GAAY93E,EAAK+nD,SACnB,cAAEgwB,GAAkBD,EAC1BC,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC3L,EAAQ9O,UAAW,CACvB,MACK,QAAoBl4E,IAAhB+3E,EAA2B,CAChC,MAAM,YAAExyB,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,MACnBv2C,EAAK+nD,QAAQxmD,OACrBxN,QAASqN,IACZA,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,KAE9Br9C,EAAW/3C,aAAc,CAC7B,MAEIyE,KAAKo2E,YAAYh0B,GACjB9O,EAAW/3C,aAAc,EAE7B,MAAMD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,GAClCvqB,EAAW/3C,cACX,KAAAi4C,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAY03C,iBAGnEnrF,KAAKo2E,YAAeh0B,IAChB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,SAAE70B,IAAa,IAAA6+B,mBAAkB5L,IACjC,cAAEiC,EAAa,cAAE+xB,GAAkBjnD,GACnC,WAAEo3C,EAAU,YAAE7b,EAAW,aAAEC,EAAY,YAAEq+C,EAAW,YAAEvwB,EAAW,qBAAEovC,GAA0B50F,KAAK29D,SAClG2G,EAAepoE,EAASinD,cAAcqC,IACtC,KAAEt4C,GAASomC,GACX,OAAE7kC,GAAWvB,EAAK+nD,SAClB,cAAEjP,GAAkBj1B,EACpBulD,EAAsBtwB,EAAcvqD,OAC1C,GAAoB,IAAhBs6E,GAAqC,IAAhBA,EAAmB,CACxC,MAAMqf,EAAWn4F,KAAK6e,IAAIw6D,EAAoB,GAAKhS,EAAa,IAC1DqR,EAAe,CACjBrR,EAAa,GACbA,EAAa,GAAK8wB,GAEhB1f,EAAY,CACdpR,EAAa,GACbA,EAAa,GAAK8wB,GAEtB3mF,EAAO,GAAK2iB,EAAcukD,GAC1BlnE,EAAO,GAAK2iB,EAAcskD,GAC1B,MACM2f,EAAqB59D,EAAc,GADxB6+C,EAAoB,GAAKse,EAAqB,IAEzDhf,EAAa,CACftR,EAAa,GAAK+wB,EAClB/wB,EAAa,IAEXgxB,EAAc,CAChBhxB,EAAa,GAAK+wB,EAClB/wB,EAAa,IAEjB71D,EAAO,GAAK2iB,EAAcwkD,GAC1BnnE,EAAO,GAAK2iB,EAAckkE,EAC9B,KACK,CACD,MAAMC,EAAWt4F,KAAK6e,IAAIw6D,EAAoB,GAAKhS,EAAa,IAC1DsR,EAAa,CACftR,EAAa,GAAKixB,EAClBjxB,EAAa,IAEXgxB,EAAc,CAChBhxB,EAAa,GAAKixB,EAClBjxB,EAAa,IAEjB71D,EAAO,GAAK2iB,EAAcwkD,GAC1BnnE,EAAO,GAAK2iB,EAAckkE,GAC1B,MACME,EAAsB99D,EAAe,GAD1B4+C,EAAoB,GAAKse,EAAqB,IAEzDjf,EAAe,CACjBrR,EAAa,GACbA,EAAa,GAAKkxB,GAEhB9f,EAAY,CACdpR,EAAa,GACbA,EAAa,GAAKkxB,GAEtB/mF,EAAO,GAAK2iB,EAAcukD,GAC1BlnE,EAAO,GAAK2iB,EAAcskD,EAC9B,GAEJ11E,KAAKiL,OAAUkkB,IACX,GAAInvB,KAAKqhE,UAAW,CAChBrhE,KAAKqhE,WAAY,EACjBrhE,KAAK0hE,gBAAgBvyC,GACrBnvB,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,WAAEmkB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,KAAEzwD,GAASomC,EAQjB,OAPAA,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,MACjC,EAAAne,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KACTrqB,EAAWqhB,aACtB,GAEJ30D,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKm2E,qBACjDhnD,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKm2E,qBACjDhnD,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKm2E,qBACpDhnD,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKm2E,qBACpDhnD,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKyhE,cAAiBtyC,IAClB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKi2E,mBACjD9mD,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAKi2E,mBACjD9mD,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKi2E,mBACjD9mD,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK0hE,gBAAmBvyC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKi2E,mBACpD9mD,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAKi2E,mBACpD9mD,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKi2E,mBACpD9mD,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACpB,IAAIq4D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAGX,GADAnE,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAAO83D,EAEX,MAAMlyC,EAAWxmB,KAAKszE,YAAYp3E,GAC5Byd,EAAkBzd,EAASiyB,qBAC3B4zC,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6qD,EAAY3zD,OAAQ8I,IAAK,CACzC,MAAM4pC,EAAaihB,EAAY7qD,IACzB,cAAEirD,EAAa,KAAEznD,GAASomC,GAC1B,QAAE2hB,GAAY/nD,GACd,OAAEuB,EAAM,kBAAEymE,GAAsBjgB,EACtC8M,EAAepN,cAAgBA,EAC/B,MAAM,MAAEv4D,EAAK,UAAE83D,EAAS,SAAE0H,GAAa57D,KAAKiiE,mBAAmB,CAC3D3uB,aACAyuB,mBAEEC,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAC7D+mF,GAAiB,KAAAC,yBAAwB1zB,IACzC,kBAAEiyB,GAAsBj0F,KAAKyM,cACnC,GAAKS,EAAKs0D,YAAYh7C,IACqB,MAAvCtZ,EAAKs0D,YAAYh7C,GAAUmvE,UAW1B,GAAIriD,EAAW/3C,cAChByE,KAAK6wF,+BAA+Bv9C,EAAYp3C,EAAUyd,EAAiBre,GACvEY,aAAoB,EAAAg3C,gBAAgB,CACpC,MAAM,kBAAE3sC,GAAsB+sC,EAAWpsC,SACzC,IAAK,MAAMsf,KAAYtZ,EAAKs0D,YACxB,GAAIh7C,EAASxlB,WAAW,WAAY,CACd2Y,EAAgBk5E,oBACCn1E,KAAMiK,IACrC,MAAMmrE,EAAqB,yBAAqBvsF,GAC1C8vB,EAAc1O,EAAG0O,YAAYy8D,GAC7BC,EAAkB,yBAAqBprE,EAAGwa,qBAChD,OAAO9L,GAAe08D,IAAoBD,YAGnC5lF,EAAKs0D,YAAYh7C,EAEhC,CAER,OA5BAtZ,EAAKs0D,YAAYh7C,GAAY,CACzBuhB,SAAU,KACV6tD,KAAM,KACNzmF,IAAK,KACL+2B,KAAM,KACNC,OAAQ,KACRwvD,SAAU,MAEd31F,KAAK8wF,sBAAsBx9C,EAAYp3C,EAAUyd,GAsBrD,IAAKzd,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,IAAIge,EACJ,KAAK,KAAAC,qBAAoBhiB,GACrB,UAEC,KAAAkD,oBAAmBlD,IACnB30D,KAAK29D,UACgB,OAAtBuX,IACAwB,EAA2B,CAAC1U,EAAkBkT,KAElD,MAAM6b,EAAoB96B,SAAQ,QAAiB,oBAAqB,CAAC,IACzE,GAAIygB,GAA4Bqa,EAAmB,CAC/C,MAAMna,EAAiB,KACvB,IAAA7I,aAAe9V,EAAkBtD,EAAeiiB,EAAgBma,EAAoB/uB,EAAoB0U,EAA0B,CAC9Ht6E,SAER,CACA,MAAM8lE,EAAS,GAAGvN,YACZkhC,EAAa,IAMnB,IALA,8BAAe59B,EAAkBtD,EAAekhC,EAAY7zB,EAAmB,CAC3E5lE,QACAw/D,WACA1H,aACDgO,GACC+xB,EAAoB,EAAG,CAEvB,GADkBh3F,KAAKa,IAAIb,KAAK6e,IAAI25E,EAAc,GAAG,GAAKA,EAAc,GAAG,IAAM,EAAGx4F,KAAK6e,IAAI25E,EAAc,GAAG,GAAKA,EAAc,GAAG,IAAM,GAC1H,EAAIxB,EAAmB,CACnC,MAAMlrB,EAAc/oE,KAAK81F,wBAAwB9zB,IACjD,IAAA9F,YAAcjE,EAAkBtD,EAAe,GAAGkhC,WAAqB9sB,EAAakrB,EAAmB,CACnG73F,QACAw/D,WACA1H,aAER,CACJ,CACAwE,GAAe,EACf,MAAMt0D,EAAUpE,KAAKuvF,sBAAsBxtB,EAAgBzuB,GAC3D,IAAKlvC,EAAQurB,WAAY,CACrBziB,EAAK+nD,QAAQ+vB,QAAU,CACnB9O,UAAU,EACV+O,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChB7tD,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB6tD,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM6R,EAAYhxF,KAAKyM,cAAc6jF,aAAapjF,EAAMsZ,GACxD,IAAKwqE,GAAkC,IAArBA,EAAUpwF,OACxB,SAEJ,IAAIqwF,EACC/jF,EAAK+nD,QAAQ+vB,QAAQ9O,WACtB+a,GAAsB,IAAAC,wBAAuBuE,GAC7CvoF,EAAK+nD,QAAQ+vB,QAAQC,cACjB/oF,EAASk1B,cAAc6/D,IAE/B,MAAME,EAAkBj1F,EAASinD,cAAcj2C,EAAK+nD,QAAQ+vB,QAAQC,eAC9DuK,EAAa,IACb4B,GAAc,IAAAC,mBAAqBp5B,EAAkBtD,EAAe66B,EAAYwB,EAAWG,EAAiBnvB,EAAmB,CAAC,EAAG59D,IACjI9G,EAAGilE,EAAM/kE,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWu0F,EAC3ClkF,EAAK+nD,QAAQ+vB,QAAQE,iBAAmB,CACpChG,QAAShjF,EAASk1B,cAAc,CAACmxC,EAAM5tD,IACvC0c,SAAUn1B,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,IAChD2c,WAAYp1B,EAASk1B,cAAc,CAACmxC,EAAM5tD,EAAM9X,IAChDsiF,YAAajjF,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,EAAM9X,IAEjE,CACA,OAAO67D,GAEX14D,KAAK8wF,sBAAwB,CAACx9C,EAAYp3C,EAAUyd,KAChD,IAAK3Z,KAAKyM,cAAcy+E,eACpB,OAEJ,MAAMh+E,EAAOomC,EAAWpmC,MAClB,QAAEiiB,GAAYjzB,GACd,OAAEuS,GAAWvB,EAAK+nD,QAClB+M,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,KAC7D,gBAAE6S,EAAe,OAAEyjB,GAAW9oC,EAASumB,aACtCo/C,EAAehoC,IAAsB,KAAA67D,yBAAwB1zB,GAC9DjoC,EAAe79B,EAASk1B,cAAcywC,GACtC5nC,EAAmB/9B,EAASk1B,cAAcyI,IAC1C,YAAE2nC,GAAgBt0D,EAClB6kF,EAAYnyF,OAAO4B,KAAKggE,GACxBqwB,EAAY93D,EACZ+3D,EAAY73D,EAClB,IAAK,IAAIvwB,EAAI,EAAGA,EAAIqoF,EAAUnxF,OAAQ8I,IAAK,CACvC,MAAM8c,EAAWurE,EAAUroF,GACrBlO,EAAQwE,KAAKogF,mBAAmB55D,GACtC,IAAKhrB,EACD,SAEJ,MAAM,WAAEqM,EAAU,UAAE8c,EAAS,SAAEzd,EAAQ,aAAElC,GAAiBxJ,EACpDu6F,EAAY,GAAsBpxE,EAAWktE,GACnDkE,EAAU,GAAK94F,KAAK+Q,MAAM+nF,EAAU,IACpCA,EAAU,GAAK94F,KAAK+Q,MAAM+nF,EAAU,IACpCA,EAAU,GAAK94F,KAAK+Q,MAAM+nF,EAAU,IACpC,MAAMC,EAAY,GAAsBrxE,EAAWmtE,GAInD,GAHAkE,EAAU,GAAK/4F,KAAK+Q,MAAMgoF,EAAU,IACpCA,EAAU,GAAK/4F,KAAK+Q,MAAMgoF,EAAU,IACpCA,EAAU,GAAK/4F,KAAK+Q,MAAMgoF,EAAU,IAChCh2F,KAAKgwF,gBAAgB+F,EAAWC,EAAWnuF,GAAa,CACxD,MAMMqN,EAAY,CACd,CAPSjY,KAAKa,IAAIi4F,EAAU,GAAIC,EAAU,IACjC/4F,KAAKkS,IAAI4mF,EAAU,GAAIC,EAAU,KAO1C,CANS/4F,KAAKa,IAAIi4F,EAAU,GAAIC,EAAU,IACjC/4F,KAAKkS,IAAI4mF,EAAU,GAAIC,EAAU,KAM1C,CALS/4F,KAAKa,IAAIi4F,EAAU,GAAIC,EAAU,IACjC/4F,KAAKkS,IAAI4mF,EAAU,GAAIC,EAAU,MAMxCp/E,EAAS,EACVmjB,EAAa,GAAKE,EAAiB,IAAM,GACzCF,EAAa,GAAKE,EAAiB,IAAM,GACzCF,EAAa,GAAKE,EAAiB,IAAM,GAExCs6D,EAAUt3F,KAAK6e,IAAIie,EAAa,GAAKE,EAAiB,IAAM,EAC5Du6D,EAAUv3F,KAAK6e,IAAIie,EAAa,GAAKE,EAAiB,IAAM,EAC5Dg8D,EAAUh5F,KAAK6e,IAAIie,EAAa,GAAKE,EAAiB,IAAM,EAC5Di8D,EAAa,CACft/E,SACA29E,QAASA,EAAU,EAAA5yE,QAAU,EAAI,EAAI4yE,EACrCC,QAASA,EAAU,EAAA7yE,QAAU,EAAI,EAAI6yE,EACrCyB,QAASA,EAAU,EAAAt0E,QAAU,EAAI,EAAIs0E,IAEnC,WAAEE,EAAU,YAAEC,IAAgB,EAAAC,GAAA,GAAoC90E,EAAiByjB,EAAQ6sD,EAAWC,GACtGwE,EAA6B,IAAfH,GAAoC,IAAhBC,EAClCnhC,EAAU,CAAC8gC,EAAWC,IACtB,MAAEx5F,EAAK,KAAEo0F,EAAI,SAAE+E,IAAa,QAAiCn6F,EAAOy5D,GACpEshC,GAAS,QAAoB/6F,GAC7Bo6F,EAAO34F,KAAK6e,IAAI7e,KAAKC,IACtBi5F,EAAa35F,EAAQ,IACrB45F,EAAcG,EAAS/5F,EAAQ,IAC9B02F,EAAoB,CACtB30F,aAAa,EAAA40F,GAAA,GAAoBj3F,EAAUsqB,GAC3C4sE,YAAapzF,KAAKozF,YAAYl3F,EAAUsqB,EAAU8sB,EAAWpsC,SAASX,oBAEpE+sF,GAAe,EAAAK,GAAA,GAAmBzsF,EAAS6gC,SAAUuL,EAAWpsC,SAASX,kBAAmB2sF,GAClG,IAAI7lD,EACAroC,IACAqoC,EAAgBroC,EAAa/D,QAAQjB,KAAKyM,cAAcynF,gBAAgBsC,cAAe,CACnFC,WAAavoD,IAAa,KAAAwoD,gBAAeR,EAAYhoD,EAAU,CAAEyoD,MAAM,IACvEzhF,YACAyP,YACAooB,aAAc/sC,KAAKyM,cAAcunF,kBAGzC,MAAMr4F,EAAQqE,KAAKyM,cAAcynF,gBAAgB0C,gBACjDp1B,EAAYh7C,GAAY,CACpBuhB,SAAU7gC,EAAS6gC,SACnB6tD,OACA1vD,KAAMvqC,EAAMuqC,MAAMjmC,MAClBkP,IAAKxT,EAAMwT,KAAKlP,MAChBnC,IAAKnC,EAAMmC,KAAKmC,MAChBkmC,OAAQxqC,EAAMwqC,QAAQlmC,MACtB42F,WAAYl7F,EAAMqR,MAClBqgC,gBACAipD,cACAX,WACArC,eAER,MAEItzF,KAAKwkF,sBAAuB,EAC5BhjB,EAAYh7C,GAAY,CACpBuhB,SAAU7gC,EAAS6gC,SAG/B,CACA,MAAMxsC,EAAc+3C,EAAW/3C,YAK/B,OAJA+3C,EAAW/3C,aAAc,EACrBA,IACA,KAAAi4C,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAYu+C,cAExDxwB,GAEXxhE,KAAKgwF,gBAAkB,CAACC,EAAQC,EAAQroF,IAC5B,kCAA8BooF,EAAQpoF,IAC1C,kCAA8BqoF,EAAQroF,GAE9C7H,KAAK6wF,gCAAiC,EAAAS,EAAA,GAAStxF,KAAK8wF,sBAAuB,IAAK,CAAES,UAAU,GAChG,QACSvxF,KAAKyvF,QAAU,CAACvgE,EAAYzgB,EAAQrK,KACzC,MAAM9I,GAAiB,IAAAq9E,+BAA8BzpD,GACrD,IAAK5zB,EACD,OAEJ,MAAM,oBAAE0O,EAAmB,kBAAEzD,EAAiB,gBAAEgb,EAAe,SAAEklB,EAAQ,SAAEvqC,GAAc8D,KAAKwxF,YAAYuC,GAAmBz4F,EAAgBmT,EAAQrK,IAC/I,aAAEo4E,KAAiBiV,GAAwBrtF,GAAW,CAAC,EACvDkvC,EAAa,CACfqhB,cAAevwD,GAASuwD,eAAiB,qBACzCznD,KAAM,CACF+nD,QAAS,CACLxmD,SACAymE,kBAAmB,MAEvBthD,MAAO,GACP4tC,YAAa,CAAC,GAElB3M,aAAa,EACb66B,eAAe,EACfn0F,aAAa,EACbmyF,UAAU,EACVC,WAAW,EACXzmF,SAAU,CACN08C,SAAUnd,EAASuuB,cACnBzzC,kBACAvX,sBACAzD,uBACGkrF,KAGX,IAAAp8B,eAAc/hB,EAAYp3C,EAASizB,UACnC,EAAA4nC,EAAA,GAAsC,CAAC76D,EAASmN,KACjD,CACH,qBAAAsrF,CAAsBmC,EAASlQ,GAC3B,MAAM,QAAE2N,EAAO,QAAEC,EAAO,OAAE59E,EAAM,MAAE9Z,GAAUg6F,EACtCC,EAAc,YAAY,cAAenQ,EAAUhwE,GAAS9Z,GAClE,GAAIy3F,GAAW,GAAOC,GAAW,EAC7B,OAAO,EAEX,MAAMppD,EAAa,CAAC2rD,EAAY,GAAKngF,EAAO,GAAImgF,EAAY,GAAKngF,EAAO,IAIxE,OAHmBw0B,EAAW,GAAKA,EAAW,IAAOmpD,EAAUA,GAC1DnpD,EAAW,GAAKA,EAAW,IAAOopD,EAAUA,IAC7C,CAER,CACA,uBAAAsB,CAAwBkB,GACpB,MAAO9P,EAAQvyE,EAAK4tD,EAAMmjB,GAASsR,EAC7B9X,EAAU,CAAC3c,EAAK,GAAI5tD,EAAI,IACxBwqE,EAAc,CAACuG,EAAM,GAAIwB,EAAO,IACtC,MAAO,EACFhI,EAAQ,GAAKC,EAAY,IAAM,GAC/BD,EAAQ,GAAKC,EAAY,IAAM,EAExC,EAEJ,SAAS,GAAoBjyE,EAAMsZ,GAC/B,MAAMyrE,EAAoB/kF,EAAKs0D,YAAYh7C,IACrC,KAAEovE,EAAI,KAAE1vD,EAAI,OAAEC,EAAM,IAAEh3B,EAAG,YAAEmnF,EAAW,SAAEX,EAAQ,aAAErC,EAAY,IAAEx1F,GAAQm0F,EACxEjB,EAAY,GAClB,GAAI,qBAAiB4E,GAAO,CACxB,MAAMqB,EAAWX,EACX,8BACA,SAAS,wBAAoBV,MAASD,IAC5C3E,EAAUroF,KAAKsuF,EACnB,CAaA,OAZI,qBAAiB/wD,IACjB8qD,EAAUroF,KAAK,SAAS,wBAAoBu9B,MAASotD,KAErD,qBAAiBnkF,IACjB6hF,EAAUroF,KAAK,QAAQ,wBAAoBwG,MAAQmkF,KAEnD,qBAAiBx1F,IACjBkzF,EAAUroF,KAAK,QAAQ,wBAAoB7K,MAAQw1F,KAEnD,qBAAiBntD,IACjB6qD,EAAUroF,KAAK,YAAY,wBAAoBw9B,MAAWmtD,KAEvDtC,CACX,CACA,MCxqBQtsD,sBAAqB,IAAK,YAClC,MAAMwyD,WAAsB,aACfl3F,KAAK4jD,SAAW,WAAa,CACtC,WAAAnkD,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX47D,QAAQ,EACR+b,2BAA2B,EAC3B4P,gBAAgB,EAChBC,kBAAmB,EACnB/I,gBAAgB,EAChBoF,aAAc,GACd4D,gBAAiB,GAAAC,qBACjBl8C,YAAY,KAGhBqJ,MAAMS,EAAWC,GACjBhiD,KAAKwkF,sBAAuB,EAC5BxkF,KAAK2+D,iBAAoBvc,IACrB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,MAE/B,IAAIh1C,EADJzO,KAAKqhE,WAAY,EAGb5yD,EADAzO,KAAKyM,cAAcwrC,WACV,CAAC,IAAI32B,GAAW,IAAIA,IAGpB,CACL,IAAIA,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAGZ,MAAMgyB,EAAatzC,KAAKmvF,iBAAiB/sC,EAAK3zC,IAC9C,IAAA4mD,eAAc/hB,EAAYnkB,GAC1B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAWzE,OAVAh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAmY,eAAe,EACfE,UAAU,GAEdl2E,KAAKyhE,cAActyC,IACnB,KAAAooC,mBAAkBpoC,GAClBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GAC/BvqB,GAEXtzC,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,KACvD,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,OAAEmT,GAAW6kC,EAAWpmC,KAAK+nD,QAC7BkiC,EAAgB1oF,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IACzD2nE,EAAe8gB,EAAc,GAC7BzxD,GAAS,KAAAowC,uBAAsB,CAACO,EAAc8gB,EAAc,KAC5DthB,GAAc,KAAAC,uBAAsB,CAACO,EAAcpf,IACzD,OAAOh6D,KAAK6e,IAAI+5D,EAAcnwC,GAAUwxB,EAAY,GAExDl3D,KAAKo3D,qBAAuB,CAAChV,EAAK9O,KAC9B,MAAMviB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB,MAAMgJ,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACA2yB,eAAe,IAEnB,KAAAj5B,mBAAkBpoC,GAClBnvB,KAAKs3D,gBAAgBnoC,IACrB,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAK8+D,uBAAyB,CAAC1c,EAAK9O,EAAYyrB,KAC5C,MAAMhuC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,KAAE7jB,GAASomC,EACjBA,EAAWuhB,aAAc,EACzB,IACIkhB,EADAya,GAAgB,EAEpB,GAAIzxB,EAAOkmB,cACPuL,GAAgB,MAEf,CACD,MAAM,OAAE/hF,GAAWvB,EAAK+nD,QACxB8gB,EAActnE,EAAO+D,UAAW9D,GAAMA,IAAMqwD,EAChD,CACA,MAAMlB,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,cACAya,iBAEJxwF,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,IAClB,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAEmY,EAAa,SAAEE,GAAal2E,KAAK29D,UACpE,KAAEzwD,GAASomC,EACb0iC,IAAkBE,IAGtBl2E,KAAKsvF,eACLh8C,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK09D,kBAAkBvuC,GACvBnvB,KAAK0hE,gBAAgBvyC,IACrB,KAAAyuC,oBAAmBzuC,GACnBnvB,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,EACbrhE,KAAKwkF,sBACLxkF,KAAKyM,cAAc23E,4BACnB,IAAA1vB,kBAAiBphB,EAAWqhB,gBAEhC,EAAAoC,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,KAGnCtzC,KAAKi2E,kBAAqB7zB,IACtBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,EAAO,cAAE62B,GAAkBj1B,GAC3B0yB,MAAOniC,EAAU7lB,OAAQ66E,GAAwBtwB,EACnD1qD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,cAAE81B,GAAkBl1B,GACpB,WAAEo3C,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,SAChE39D,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBACvC,MAAM,KAAE9oE,GAASomC,EACXkS,EAAct4C,EAAK+nD,QAAQxmD,OAAO,GAClC61D,EAAepoE,EAASinD,cAAcqC,GAC5C,GAAIxlD,KAAKyM,cAAcwrC,WACnB/qC,EAAK+nD,QAAQxmD,OAAO,GAAK6S,MAExB,CACD,MAAM81E,EAAe,cAAc9yB,EAAcgS,GACjDppE,EAAK+nD,QAAQxmD,OAAO,GAAK,IAAI+2C,GAC7Bt4C,EAAK+nD,QAAQxmD,OAAO,GAAK2iB,EAAc,CACnCkzC,EAAa,GACbA,EAAa,GAAK8yB,IAEtBlqF,EAAK+nD,QAAQxmD,OAAO,GAAK2iB,EAAc,CACnCkzC,EAAa,GACbA,EAAa,GAAK8yB,IAEtBlqF,EAAK+nD,QAAQxmD,OAAO,GAAK2iB,EAAc,CACnCkzC,EAAa,GAAK8yB,EAClB9yB,EAAa,KAEjBp3D,EAAK+nD,QAAQxmD,OAAO,GAAK2iB,EAAc,CACnCkzC,EAAa,GAAK8yB,EAClB9yB,EAAa,IAErB,CACAhxB,EAAW/3C,aAAc,EACzByE,KAAK29D,SAASuY,UAAW,GACzB,EAAAnf,EAAA,GAAsC8G,IACtC,KAAArqB,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAY03C,iBAE/DnrF,KAAKm2E,oBAAuB/zB,IACxBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,YAAEkY,EAAW,cAAEya,EAAa,cAAExa,GAAmBh2E,KAAK29D,SAC7F39D,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBACvC,MAAM,KAAE9oE,GAASomC,EACjB,GAAIk9C,EAAe,CACf,MAAM,YAAEjtC,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,OAC5B,QAAEuhC,GAAY93E,EAAK+nD,SACnB,cAAEgwB,GAAkBD,EAC1BC,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC3L,EAAQ9O,UAAW,CACvB,MACK,QAAoBl4E,IAAhB+3E,EAA2B,CAChC,MAAM,YAAExyB,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,MACnBv2C,EAAK+nD,QAAQxmD,OACrBxN,QAASqN,IACZA,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,KAE9Br9C,EAAW/3C,aAAc,CAC7B,MAEIyE,KAAKo2E,YAAYh0B,GACjB9O,EAAW/3C,aAAc,GAE7B,EAAAw7D,EAAA,GAAsC8G,GAClCvqB,EAAW/3C,cACX,KAAAi4C,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAY03C,iBAGnEnrF,KAAKo2E,YAAeh0B,IAChB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACdz1B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,cAAEiC,EAAa,cAAE+xB,GAAkB7nD,EAAeY,UAClD,WAAEo3C,EAAU,YAAEyiC,GAAgB/1E,KAAK29D,UACnC,KAAEzwD,GAASomC,GACX,OAAE7kC,GAAWvB,EAAK+nD,SAClB,cAAEjP,EAAa,YAAEzC,GAAgBxyB,EACvC,GAAoB,IAAhBglD,EAAmB,CACnB,MAAM4a,EAAgBptC,EAAYE,MAClCh1C,EAAOxN,QAASqN,IACZ,SAASA,EAAOA,EAAOqiF,IAE/B,KACK,CACD,MACMrsB,EAAenhB,EADD10C,EAAO,IAErBm+E,EAAqB5mC,EAAcvqD,OACnC47F,EAAkB,cAAc/yB,EAAcsoB,GACpDn+E,EAAO,GAAK2iB,EAAc,CACtBkzC,EAAa,GACbA,EAAa,GAAK+yB,IAEtB5oF,EAAO,GAAK2iB,EAAc,CACtBkzC,EAAa,GACbA,EAAa,GAAK+yB,IAEtB5oF,EAAO,GAAK2iB,EAAc,CACtBkzC,EAAa,GAAK+yB,EAClB/yB,EAAa,KAEjB71D,EAAO,GAAK2iB,EAAc,CACtBkzC,EAAa,GAAK+yB,EAClB/yB,EAAa,IAErB,CACAhxB,EAAW/3C,aAAc,GAE7ByE,KAAKiL,OAAUkkB,IACX,GAAInvB,KAAKqhE,UAAW,CAChBrhE,KAAKqhE,WAAY,EACjBrhE,KAAK0hE,gBAAgBvyC,GACrBnvB,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,WAAEmkB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,SAQhE,OAPArqB,EAAWuhB,aAAc,EACzBvhB,EAAWpmC,KAAK+nD,QAAQigB,kBAAoB,MAC5C,EAAAne,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KACTrqB,EAAWqhB,aACtB,GAEJ30D,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKm2E,qBACjDhnD,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKm2E,qBACjDhnD,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKm2E,qBACpDhnD,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKm2E,qBACpDhnD,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKyhE,cAAiBtyC,IAClB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKi2E,mBACjD9mD,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAKi2E,mBACjD9mD,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKi2E,mBACjD9mD,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK0hE,gBAAmBvyC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKi2E,mBACpD9mD,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAKi2E,mBACpD9mD,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKi2E,mBACpD9mD,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACpB,IAAIq4D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAGX,GADAnE,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAAO83D,EAEX,MAAMlyC,EAAWxmB,KAAKszE,YAAYp3E,GAC5Byd,EAAkBzd,EAASiyB,qBAC3B4zC,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6qD,EAAY3zD,OAAQ8I,IAAK,CACzC,MAAM4pC,EAAaihB,EAAY7qD,IACzB,cAAEirD,EAAa,KAAEznD,GAASomC,GAC1B,QAAE2hB,GAAY/nD,GACd,OAAEuB,EAAM,kBAAEymE,GAAsBjgB,EACtC8M,EAAepN,cAAgBA,EAC/B,MAAM,MAAEv4D,EAAK,UAAE83D,EAAS,SAAE0H,GAAa57D,KAAKiiE,mBAAmB,CAC3D3uB,aACAyuB,mBAEEC,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAC7DkI,EAASorD,EAAkB,GAC3Bt8B,GAAS,KAAAowC,uBAAsB,CAACl/D,EAAQorD,EAAkB,KAC1DyzB,GAAgB,KAAA6B,wBAAuB,CACzC1gF,EACAorD,EAAkB,MAEhB,kBAAEiyB,GAAsBj0F,KAAKyM,cACnC,GAAKS,EAAKs0D,YAAYh7C,IACqB,MAAvCtZ,EAAKs0D,YAAYh7C,GAAUmvE,UAc1B,GAAIriD,EAAW/3C,cAChByE,KAAK6wF,+BAA+Bv9C,EAAYp3C,EAAUyd,EAAiBre,GACvEY,aAAoB,EAAAg3C,gBAAgB,CACpC,MAAM,kBAAE3sC,GAAsB+sC,EAAWpsC,SACzC,IAAK,MAAMsf,KAAYtZ,EAAKs0D,YACxB,GAAIh7C,EAASxlB,WAAW,WAAY,CACd2Y,EAAgBk5E,oBACCn1E,KAAMiK,IACrC,MAAMmrE,EAAqB,yBAAqBvsF,GAC1C8vB,EAAc1O,EAAG0O,YAAYy8D,GAC7BC,EAAkB,yBAAqBprE,EAAGwa,qBAChD,OAAO9L,GAAe08D,IAAoBD,YAGnC5lF,EAAKs0D,YAAYh7C,EAEhC,CAER,OA/BAtZ,EAAKs0D,YAAYh7C,GAAY,CACzBuhB,SAAU,KACV6tD,KAAM,KACNzmF,IAAK,KACL+2B,KAAM,KACNC,OAAQ,KACRwvD,SAAU,KACVjwD,OAAQ,KACR6xD,WAAY,KACZC,UAAW,MAEfx3F,KAAK8wF,sBAAsBx9C,EAAYp3C,EAAUyd,EAAiBre,GAsBtE,IAAKY,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,IAAIge,EACJ,KAAK,KAAAC,qBAAoBhiB,GACrB,UAEC,KAAAkD,oBAAmBlD,IACnB30D,KAAK29D,UACgB,OAAtBuX,IAEIwB,EADA12E,KAAKyM,cAAcwrC,WACQ,CAAC+pB,EAAkBkT,IAGnBlT,GAGnC,MAAM+uB,EAAoB96B,SAAQ,QAAiB,oBAAqB,CAAC,IACzE,GAAIygB,GAA4Bqa,EAAmB,CAC/C,MAAMna,EAAiB,KACvB,IAAA7I,aAAe9V,EAAkBtD,EAAeiiB,EAAgBma,EAAoB/uB,EAAoB0U,EAA0B,CAC9Ht6E,SAER,CACA,MAAM8lE,EAAS,GAAGvN,WACZsH,EAAY,IAgBlB,IAfA,IAAAC,YAAcjE,EAAkBtD,EAAesH,EAAWrlD,EAAQ8uB,EAAQ,CACtEtpC,QACAw/D,WACA1H,aACDgO,GACC+xB,EAAoB,GAChBvuD,EAAS,EAAIuuD,IACb,IAAA/3B,YAAcjE,EAAkBtD,EAAe,GAAGsH,WAAoBrlD,EAAQq9E,EAAmB,CAC7F73F,QACAw/D,WACA1H,cAIZwE,GAAe,EACX14D,KAAKyM,cAAcy+E,eAAgB,CACnC,MAAM9mF,EAAUpE,KAAKuvF,sBAAsBxtB,EAAgBzuB,GAC3D,IAAKlvC,EAAQurB,WAAY,CACrBziB,EAAK+nD,QAAQ+vB,QAAU,CACnB9O,UAAU,EACV+O,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChB7tD,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB6tD,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM6R,EAAYhxF,KAAKyM,cAAc6jF,aAAapjF,EAAMsZ,GACxD,IAAKwqE,GAAkC,IAArBA,EAAUpwF,OACxB,SAEJ,IAAIqwF,EACC/jF,EAAK+nD,QAAQ+vB,QAAQ9O,WACtB+a,GAAsB,IAAAC,wBAAuBuE,GAC7CvoF,EAAK+nD,QAAQ+vB,QAAQC,cACjB/oF,EAASk1B,cAAc6/D,IAE/B,MAAME,EAAkBj1F,EAASinD,cAAcj2C,EAAK+nD,QAAQ+vB,QAAQC,eAC9DuK,EAAa,IACb4B,GAAc,IAAAC,mBAAqBp5B,EAAkBtD,EAAe66B,EAAYwB,EAAWG,EAAiB,CAACv6E,EAAQorD,EAAkB,IAAK,CAAC,EAAG59D,IAC9I9G,EAAGilE,EAAM/kE,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWu0F,EAC3ClkF,EAAK+nD,QAAQ+vB,QAAQE,iBAAmB,CACpChG,QAAShjF,EAASk1B,cAAc,CAACmxC,EAAM5tD,IACvC0c,SAAUn1B,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,IAChD2c,WAAYp1B,EAASk1B,cAAc,CAACmxC,EAAM5tD,EAAM9X,IAChDsiF,YAAajjF,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,EAAM9X,IAEjE,CACJ,CACA,OAAO67D,GAEX14D,KAAK8wF,sBAAwB,CAACx9C,EAAYp3C,EAAUyd,EAAiBre,KACjE,IAAK0E,KAAKyM,cAAcy+E,eACpB,OAEJ,MAAMh+E,EAAOomC,EAAWpmC,MAClB,QAAEiiB,GAAYjzB,EACdu7F,EAAiBnkD,EAAW/3C,aAC5B,OAAEkT,GAAWvB,EAAK+nD,QAClB+M,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAC7D2nE,EAAerU,EAAkB,GACjC0T,EAAY1T,EAAkB,IAC9B,gBAAEzgD,EAAe,OAAEyjB,GAAW9oC,EAASumB,aACtCo/C,EAAehoC,IAAsB,KAAAy9D,wBAAuB,CAACjhB,EAAcX,IAC5E37C,EAAe79B,EAASk1B,cAAcywC,GACtC5nC,EAAmB/9B,EAASk1B,cAAcyI,IAC1C,YAAE2nC,GAAgBt0D,EAClB6kF,EAAYnyF,OAAO4B,KAAKggE,GACxBqwB,EAAY93D,EACZ+3D,EAAY73D,EAClB,IAAK,IAAIvwB,EAAI,EAAGA,EAAIqoF,EAAUnxF,OAAQ8I,IAAK,CACvC,MAAM8c,EAAWurE,EAAUroF,GACrBlO,EAAQwE,KAAKogF,mBAAmB55D,GACtC,IAAKhrB,EACD,SAEJ,MAAM,WAAEqM,EAAU,UAAE8c,EAAS,SAAEzd,EAAQ,aAAElC,GAAiBxJ,EACpDu6F,EAAY,GAAsBpxE,EAAWktE,GACnDkE,EAAU,GAAK94F,KAAK+Q,MAAM+nF,EAAU,IACpCA,EAAU,GAAK94F,KAAK+Q,MAAM+nF,EAAU,IACpCA,EAAU,GAAK94F,KAAK+Q,MAAM+nF,EAAU,IACpC,MAAMC,EAAY,GAAsBrxE,EAAWmtE,GAInD,GAHAkE,EAAU,GAAK/4F,KAAK+Q,MAAMgoF,EAAU,IACpCA,EAAU,GAAK/4F,KAAK+Q,MAAMgoF,EAAU,IACpCA,EAAU,GAAK/4F,KAAK+Q,MAAMgoF,EAAU,IAChCh2F,KAAKgwF,gBAAgB+F,EAAWC,EAAWnuF,GAAa,CACxD,MAMMqN,EAAY,CACd,CAPSjY,KAAKa,IAAIi4F,EAAU,GAAIC,EAAU,IACjC/4F,KAAKkS,IAAI4mF,EAAU,GAAIC,EAAU,KAO1C,CANS/4F,KAAKa,IAAIi4F,EAAU,GAAIC,EAAU,IACjC/4F,KAAKkS,IAAI4mF,EAAU,GAAIC,EAAU,KAM1C,CALS/4F,KAAKa,IAAIi4F,EAAU,GAAIC,EAAU,IACjC/4F,KAAKkS,IAAI4mF,EAAU,GAAIC,EAAU,MAMxCp/E,EAASnI,EAAO,GAChB8lF,EAAUt3F,KAAK6e,IAAIie,EAAa,GAAKE,EAAiB,IAAM,EAC5Du6D,EAAUv3F,KAAK6e,IAAIie,EAAa,GAAKE,EAAiB,IAAM,EAC5Dg8D,EAAUh5F,KAAK6e,IAAIie,EAAa,GAAKE,EAAiB,IAAM,EAC5Di8D,EAAa,CACft/E,SACA29E,QAASA,EAAU,EAAA5yE,QAAU,EAAI,EAAI4yE,EACrCC,QAASA,EAAU,EAAA7yE,QAAU,EAAI,EAAI6yE,EACrCyB,QAASA,EAAU,EAAAt0E,QAAU,EAAI,EAAIs0E,IAEnC,WAAEE,EAAU,YAAEC,IAAgB,EAAAC,GAAA,GAAoC90E,EAAiByjB,EAAQ6sD,EAAWC,GACtGwE,EAA6B,IAAfH,GAAoC,IAAhBC,EAClCnhC,EAAU,CAAC8gC,EAAWC,IACtB,MAAEx5F,EAAK,KAAEo0F,EAAI,SAAE+E,IAAa,QAAiCn6F,EAAOy5D,GACpEshC,GAAS,QAAoB/6F,GAC7Bo6F,EAAO34F,KAAK6e,IAAI7e,KAAKC,IACtBi5F,EAAa35F,EAAQ,IACrB45F,EAAcG,EAAS/5F,EAAQ,IAC9B02F,EAAoB,CACtB30F,aAAa,EAAA40F,GAAA,GAAoBj3F,EAAUsqB,GAC3C4sE,YAAapzF,KAAKozF,YAAYl3F,EAAUsqB,EAAU8sB,EAAWpsC,SAASX,oBAEpE+sF,GAAe,EAAAK,GAAA,GAAmBzsF,EAAS6gC,SAAUuL,EAAWpsC,SAASX,kBAAmB2sF,GAClG,IAAI7lD,EACAroC,IACAqoC,EAAgBroC,EAAa/D,QAAQjB,KAAKyM,cAAcynF,gBAAgBsC,cAAe,CACnFC,WAAavoD,IAAa,KAAAwoD,gBAAeR,EAAYhoD,EAAU,CAAEyoD,MAAM,IACvEzhF,YACAyP,YACAooB,aAAc/sC,KAAKyM,cAAcunF,kBAGzC,MAAMr4F,EAAQqE,KAAKyM,cAAcynF,gBAAgB0C,gBACjDp1B,EAAYh7C,GAAY,CACpBuhB,SAAU7gC,EAAS6gC,SACnB6tD,OACA1vD,KAAMvqC,EAAMuqC,MAAMjmC,MAClBkP,IAAKxT,EAAMwT,KAAKlP,MAChBnC,IAAKnC,EAAMmC,KAAKmC,MAChBotC,gBACAlH,OAAQxqC,EAAMwqC,QAAQlmC,MACtB42F,WAAYl7F,EAAMqR,MAClBspF,cACAX,WACAjwD,OAAQywD,EAAa,EAAI35F,EACzB+6F,WAAY3G,EACZ4G,UAAY,EAAIv6F,KAAKC,IAAMi5F,EAAa,GAAM35F,EAC9C82F,eAER,MAEItzF,KAAKwkF,sBAAuB,EAC5BhjB,EAAYh7C,GAAY,CACpBuhB,SAAU7gC,EAAS6gC,SAG/B,CAKA,OAJAuL,EAAW/3C,aAAc,EACrBk8F,IACA,KAAAjkD,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAYu+C,cAExDxwB,GAEXxhE,KAAKgwF,gBAAkB,CAACC,EAAQC,EAAQroF,IAC5B,kCAA8BooF,EAAQpoF,IAC1C,kCAA8BqoF,EAAQroF,GAE9C7H,KAAK6wF,gCAAiC,EAAAS,EAAA,GAAStxF,KAAK8wF,sBAAuB,IAAK,CAAES,UAAU,GAChG,QACSvxF,KAAKyvF,QAAU,CAACvgE,EAAYzgB,EAAQrK,KACzC,MAAM9I,GAAiB,IAAAq9E,+BAA8BzpD,GACrD,IAAK5zB,EACD,OAEJ,MAAM,oBAAE0O,EAAmB,kBAAEzD,EAAiB,gBAAEgb,EAAe,SAAEklB,EAAQ,SAAEvqC,GAAc8D,KAAKwxF,YAAY0F,GAAe57F,EAAgBmT,EAAQrK,IAC3I,aAAEo4E,KAAiBiV,GAAwBrtF,GAAW,CAAC,EACvDkvC,EAAa,CACfqhB,cAAevwD,GAASuwD,eAAiB,qBACzCznD,KAAM,CACF+nD,QAAS,CACLxmD,SACAu2E,QAAS,CACL9O,UAAU,EACV+O,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChB7tD,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB6tD,YAAa,CAAC,EAAG,EAAG,KAG5BjK,kBAAmB,MAEvBthD,MAAO,GACP4tC,YAAa,CAAC,GAElB3M,aAAa,EACb66B,eAAe,EACfn0F,aAAa,EACbmyF,UAAU,EACVC,WAAW,EACXzmF,SAAU,CACN08C,SAAUnd,EAASuuB,cACnBzzC,kBACAvX,sBACAzD,uBACGkrF,KAGX,IAAAp8B,eAAc/hB,EAAYp3C,EAASizB,UACnC,EAAA4nC,EAAA,GAAsC,CAAC76D,EAASmN,KACjD,EAEP,SAAS,GAAoB6D,EAAMsZ,GAC/B,MAAMyrE,EAAoB/kF,EAAKs0D,YAAYh7C,IACrC,OAAEkf,EAAM,WAAE6xD,EAAU,KAAE3B,EAAI,KAAE1vD,EAAI,OAAEC,EAAM,IAAEh3B,EAAG,IAAErR,EAAG,YAAEw4F,EAAW,SAAEX,EAAQ,aAAErC,GAAkBrB,EAC7FjB,EAAY,GAClB,GAAI,qBAAiBtrD,GAAS,CAC1B,MAAMgyD,EAAapB,EACb,gCACA,WAAW,wBAAoB5wD,MAAW6xD,IAChDvG,EAAUroF,KAAK+uF,EACnB,CACA,GAAI,qBAAiB9B,GAAO,CACxB,MAAMqB,EAAWX,EACX,8BACA,SAAS,wBAAoBV,MAASD,IAC5C3E,EAAUroF,KAAKsuF,EACnB,CAaA,OAZI,qBAAiB/wD,IACjB8qD,EAAUroF,KAAK,SAAS,wBAAoBu9B,MAASotD,KAErD,qBAAiBnkF,IACjB6hF,EAAUroF,KAAK,QAAQ,wBAAoBwG,MAAQmkF,KAEnD,qBAAiBx1F,IACjBkzF,EAAUroF,KAAK,QAAQ,wBAAoB7K,MAAQw1F,KAEnD,qBAAiBntD,IACjB6qD,EAAUroF,KAAK,YAAY,wBAAoBw9B,MAAWmtD,KAEvDtC,CACX,CACA,YC1oBA,MAAM2G,WAAsB,aACf33F,KAAK4jD,SAAW,WAAa,CACtC,WAAAnkD,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX47D,QAAQ,EACR+b,2BAA2B,EAC3BwT,QAAS,CAAC,GAAI,IAAK,IAAK,KACxBC,UAAW,CAAC,GAAI,GAAI,OAGxBv2C,MAAMS,EAAWC,GACjBhiD,KAAKwkF,sBAAuB,EAC5BxkF,KAAK2+D,iBAAoBvc,IACrB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,MACzBnoD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,EAAQ,gBAAEyd,GAAoBre,EACtC0E,KAAKqhE,WAAY,EACjB,MAAM7+C,EAAStmB,EAASumB,aAClB,gBAAElB,EAAe,OAAEyjB,GAAWxiB,EAC9Bjc,EAAoBvG,KAAKshE,qBAAqBplE,EAAUolB,EAAUC,EAAiByjB,GACnFh7B,EAAsB9N,EAASqlE,yBAC/BjuB,EAAa,CACfuhB,aAAa,EACbt5D,aAAa,EACb2L,SAAU,CACN08C,SAAU5jD,KAAKg1D,cACfzzC,gBAAiB,IAAIA,GACrByjB,OAAQ,IAAIA,GACZh7B,sBACAzD,uBACGrK,EAASkgC,iBAAiB,CAAE3tB,OAAQ,CAAC6S,MAE5CpU,KAAM,CACF0mB,MAAO,GACPqhC,QAAS,CACLxmD,OAAQ,CAAC,IAAI6S,QAIzB,IAAA+zC,eAAc/hB,EAAYnkB,GAC1B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAUzE,OATAh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAmY,eAAe,GAEnBh2E,KAAKyhE,cAActyC,IACnB,KAAAooC,mBAAkBpoC,GAClBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GAC/BvqB,GAEXtzC,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,KACvD,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,KAAE4R,GAASomC,GACX,OAAE7kC,GAAWvB,EAAK+nD,QAClBr+C,EAAS1a,EAASinD,cAAc10C,EAAO,IACvCi3B,GAAS,KAAAowC,uBAAsB,CAACl/D,EAAQqgD,IAC9C,OAAIh6D,KAAK6e,IAAI4pB,GAAUwxB,GAK3Bl3D,KAAKo3D,qBAAuB,CAAChV,EAAK9O,KAC9B,MAAMviB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB,MAAMgJ,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,wBAEJ,KAAAtG,mBAAkBpoC,GAClBnvB,KAAKs3D,gBAAgBnoC,GACrB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAK8+D,uBAAyB,CAAC1c,EAAK9O,KAChC,MAAMviB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB,MAAMgJ,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,uBAEJ79D,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,GAClB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAEmY,EAAa,SAAEE,GAAal2E,KAAK29D,UACpE,KAAEzwD,GAASomC,EACjB,GAAI0iC,IAAkBE,EAClB,OAEJ5iC,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK09D,kBAAkBvuC,GACvBnvB,KAAK0hE,gBAAgBvyC,IACrB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,gBAAExV,IAAoB,IAAAohB,mBAAkB5L,GAC9CnvB,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,EACbrhE,KAAKwkF,sBACLxkF,KAAKyM,cAAc23E,4BACnB,IAAA1vB,kBAAiBphB,EAAWqhB,gBAEhC,EAAAoC,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,IAGnCtzC,KAAKi2E,kBAAqB7zB,IACtBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,cAAEi1B,GAAkBj1B,EACpBulD,EAAsBtwB,EAAcvqD,OACpCH,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,EAAe,SAAEzd,GAAaZ,GAChC,cAAE81B,GAAkBl1B,GACpB,WAAEo3C,EAAU,oBAAEuqB,GAAwB79D,KAAK29D,UAC3C,KAAEzwD,GAASomC,EACjBpmC,EAAK+nD,QAAQxmD,OAAS,CAClB2iB,EAAcklD,GACdllD,EAAcklD,IAElBhjC,EAAW/3C,aAAc,EACzByE,KAAK29D,SAASuY,UAAW,GACzB,EAAAnf,EAAA,GAAsC8G,IAE1C79D,KAAKm2E,oBAAuB/zB,IACxBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,GAAwB79D,KAAK29D,UAC3C,KAAEzwD,GAASomC,GACX,YAAEiQ,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,MACnBv2C,EAAK+nD,QAAQxmD,OACrBxN,QAASqN,IACZA,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,KAE9Br9C,EAAW/3C,aAAc,EACzB,MAAMD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,IAE1C79D,KAAKo2E,YAAeh0B,IAChB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACdz1B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,cAAEiC,EAAa,cAAE+xB,GAAkB7nD,EAAeY,UAClD,WAAEo3C,GAAetzC,KAAK29D,UACtB,KAAEzwD,GAASomC,GACX,OAAE7kC,GAAWvB,EAAK+nD,QAClB+M,EAAoBvzD,EAAOpI,IAAKqI,GAAMy0C,EAAcz0C,KACpD,cAAEs3C,GAAkBj1B,EACpBulD,EAAsBtwB,EAAcvqD,OACpC85F,EAAWjf,EAAoB,GAAKtU,EAAkB,GAAG,GACzDozB,EAAW9e,EAAoB,GAAKtU,EAAkB,GAAG,GACzDqU,EAAeC,EACfwhB,EAAY,CACd91B,EAAkB,GAAG,GAAKuzB,EAC1BvzB,EAAkB,GAAG,GAAKozB,GAE9B3mF,EAAO,GAAK2iB,EAAcilD,GAC1B5nE,EAAO,GAAK2iB,EAAc0mE,IAE9B93F,KAAKiL,OAAUkkB,IACX,GAAInvB,KAAKqhE,UAAW,CAChBrhE,KAAKqhE,WAAY,EACjBrhE,KAAK0hE,gBAAgBvyC,GACrBnvB,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,WAAEmkB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,KAAEzwD,GAASomC,EACjBA,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,KACjC,MAAM,gBAAEv7D,IAAoB,IAAAohB,mBAAkB5L,GAM9C,OALA,EAAA4nC,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KACTrqB,EAAWqhB,aACtB,GAEJ30D,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKm2E,qBACjDhnD,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKm2E,qBACjDhnD,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKm2E,qBACpDhnD,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKm2E,qBACpDhnD,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKyhE,cAAiBtyC,IAClB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKi2E,mBACjD9mD,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAKi2E,mBACjD9mD,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKi2E,mBACjD9mD,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK0hE,gBAAmBvyC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKi2E,mBACpD9mD,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAKi2E,mBACpD9mD,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKi2E,mBACpD9mD,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACpB,IAAIq4D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAGX,GADAnE,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAAO83D,EAEX,MAAMqJ,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6qD,EAAY3zD,OAAQ8I,IAAK,CACzC,MAAM4pC,EAAaihB,EAAY7qD,IACzB,cAAEirD,EAAa,KAAEznD,GAASomC,GAC1B,QAAE2hB,GAAY/nD,GACd,OAAEuB,GAAWwmD,EACnB8M,EAAepN,cAAgBA,EAC/B,MAAM,MAAEv4D,EAAK,UAAE83D,EAAS,SAAE0H,GAAa57D,KAAKiiE,mBAAmB,CAC3D3uB,aACAyuB,mBAGEnrD,EADoBnI,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAClC,GACjC,IAAKxS,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,KAAK,KAAAie,qBAAoBhiB,GACrB,SAEJ,IAAI8G,EAAU,GAAG9G,uBACbj5D,EAAQ,CAACkb,EAAO,GAAIA,EAAO,GAtRxB,GAuRH5E,EAAM,CAAC4E,EAAO,GAAIA,EAAO,GAvRtB,IAwRP,IAAA8kD,UAASzD,EAAkBtD,EAAe8G,EAAS//D,EAAOsW,EAAK,CAC3D5V,QACAw/D,WACA1H,cAEJuH,EAAU,GAAG9G,yBACbj5D,EAAQ,CAACkb,EAAO,GA9RT,EA8R8BA,EAAO,IAC5C5E,EAAM,CAAC4E,EAAO,GA/RP,EA+R4BA,EAAO,KAC1C,IAAA8kD,UAASzD,EAAkBtD,EAAe8G,EAAS//D,EAAOsW,EAAK,CAC3D5V,QACAw/D,WACA1H,cAEJ,MAAM6jC,EAAkB/3F,KAAKyM,cAAcorF,UAAUxxF,IAAK2xF,GAAah4F,KAAKi4F,qBAAqBD,EAAU97F,IAC3G,IAAK,IAAIwN,EAAI,EAAGA,EAAIquF,EAAgBn3F,OAAQ8I,IAAK,CAC7C,MAAMw4D,EAAS,GAAGvN,YAAwBjrD,IACpCuyD,EAAY,GAAGtH,YAAwBjrD,KAC7C,IAAAwyD,YAAcjE,EAAkBtD,EAAesH,EAAWrlD,EAAQmhF,EAAgBruF,GAAK,EAAG,CACtFtN,QACAw/D,WACA1H,aACDgO,EACP,CACA,MAAMg2B,EAAc56F,GAAOA,EAAIL,KAAKC,GAAM,IACpCi7F,EAAen4F,KAAKyM,cAAcmrF,QAAQvxF,IAAK+xF,GAAWF,EAAWE,IAC3E,IAAK,IAAI1uF,EAAI,EAAGA,EAAIyuF,EAAav3F,OAAQ8I,IAAK,CAC1C,MAAM+xD,EAAU,GAAG9G,UAAsBjrD,IACnChO,EAAQ,CACTuB,KAAKo7F,IAAIF,EAAazuF,IAAMquF,EAAgB,GAAM,EAAInhF,EAAO,GAC7D3Z,KAAKq7F,IAAIH,EAAazuF,IAAMquF,EAAgB,GAAM,EAAInhF,EAAO,IAE5D5E,EAAM,CACP/U,KAAKo7F,IAAIF,EAAazuF,IAAMquF,EAAgB,GAAM,EAAInhF,EAAO,GAC7D3Z,KAAKq7F,IAAIH,EAAazuF,IAAMquF,EAAgB,GAAM,EAAInhF,EAAO,KAElE,IAAA8kD,UAASzD,EAAkBtD,EAAe8G,EAAS//D,EAAOsW,EAAK,CAC3D5V,QACAw/D,WACA1H,aAER,CACAwE,GAAe,CACnB,CACA,OAAOA,EAEf,CACA,oBAAAu/B,CAAqBM,EAAar8F,GAC9B,MAAMuuC,EAAKvuC,EAASk1B,cAAc,CAC9Bl1B,EAAST,OAAOmB,MAAQ,EACxBV,EAAST,OAAOoB,OAAS,KAEvB,OAAEmoC,GAAW9oC,EAASumB,YACtB47B,EAAK,iBAAiB,cAAe5T,EAAIzF,EAAQuzD,GACjDC,EAAWt8F,EAASinD,cAAc1Y,GAClCguD,EAAWv8F,EAASinD,cAAc9E,GAGxC,OAFiBphD,KAAKopC,KAAKppC,KAAKotD,IAAIouC,EAAS,GAAKD,EAAS,GAAI,GAC3Dv7F,KAAKotD,IAAIouC,EAAS,GAAKD,EAAS,GAAI,GAE5C,E,wCC3UJ,MAEME,GAAwB,CAC1Bj/C,WAAY,GACZk/C,6BAA8B,EAC9BC,6BAA8B,EAC9BC,6BAA6B,EAC7BC,6BAA6B,EAC7BC,6BAA6B,GAEjC,IAAIC,GAOAC,IANJ,SAAWD,GACPA,EAA0B,SAAI,WAC9BA,EAAwB,OAAI,SAC5BA,EAA4B,WAAI,aAChCA,EAAyB,QAAI,SAChC,CALD,CAKGA,KAAoBA,GAAkB,CAAC,IAE1C,SAAWC,GACPA,EAAmC,gBAAI,kBACvCA,EAAsC,mBAAI,oBAC7C,CAHD,CAGGA,KAAsBA,GAAoB,CAAC,IAC9C,MAAMC,GAAkB,CACpB,sBACA,kBACA,aACA,qBAEJ,MAAMC,WAAsBC,GAAA,SACfp5F,KAAK4jD,SAAW,WAAa,QAC7B5jD,KAAKq5F,YAAcL,EAAiB,QACpCh5F,KAAK6zE,QAAUolB,EAAmB,CAC3C,WAAAx5F,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX23E,2BAA2B,EAC3B8G,gBAAgB,EAChBoO,kBAAkB,EAClBhJ,aAAc,GACdiJ,+BAAgC,EAAA7kB,iBAAiBC,MACjDt0D,SAAU,CACNyoC,SAAS,EACT0wC,QAAS,IAEbC,OAAQ,CACJhtF,cAAe,CACX,CAACusF,GAAgBU,UAAW,CACxBC,MAAOt4C,GACP7kD,MAAO,IAEX,CAACw8F,GAAgBY,YAAa,CAC1BD,MAAO/3C,IAEX,CAACo3C,GAAgBa,QAAS,CACtBF,MAAO93C,IAEX,CAACm3C,GAAgB53C,SAAU,CACvBu4C,MAAOv4C,GACP03C,6BAA6B,EAC7BC,6BAA6B,EAC7BF,6BAA6B,IAGrC/xF,KAAMkyF,GAAgBY,WACtBE,oBAAoB,EACpBC,uBAAuB,EACvBC,6BAA8B,CAAC,YAAa,WAEhD9lB,QAAS,CACL,CAAC+kB,GAAkBgB,iBAAkB,CACjC7lB,OAAQ,0BACRC,SAAU,CACN,CACIC,YAAa,EAAAC,cAAc2lB,QAC3BzlB,YAAa,EAAAC,iBAAiBC,SAI1C,CAACskB,GAAkBkB,oBAAqB,CACpC/lB,OAAQ,6BACRC,SAAU,CACN,CACIC,YAAa,EAAAC,cAAc2lB,QAC3BzlB,YAAa,EAAAC,iBAAiB0lB,YAOlD94C,MAAMS,EAAWC,GACjBhiD,KAAKk5F,gBAAkB,CACnB,sBACA,kBACA,aACA,qBAEJl5F,KAAKwkF,sBAAuB,EAC5BxkF,KAAKq6F,mBAAqB,KAC1Br6F,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,KACvD,MAAQzwB,SAAUgzD,GAAWnmD,EAAWpmC,KAAKusF,OAC7C,OAAOA,EAAO/7C,iBAAiBuZ,EAAcC,IAEjDl3D,KAAKo3D,qBAAuB,CAAChV,EAAK9O,KAC9B,MAAMviB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB,MAAMgJ,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACA2yB,eAAe,GAEnBxwF,KAAKs3D,gBAAgBnoC,IACrB,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAK8+D,uBAAyB,CAAC1c,EAAK9O,EAAYyrB,KAC5C,MAAMhuC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,KAAE7jB,GAASomC,EACjBA,EAAWuhB,aAAc,EACzB,IACIkhB,EADAya,GAAgB,EAEpB,GAAIzxB,EAAOkmB,cACPuL,GAAgB,MAEf,CACD,MAAM,OAAE/hF,GAAWvB,EAAK+nD,QACxB8gB,EAActnE,EAAO+D,UAAW9D,GAAMA,IAAMqwD,EAChD,CACA,MAAMlB,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,cACAya,iBAEJxwF,KAAKs3D,gBAAgBnoC,IACrB,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAEmY,EAAa,6BAAEskB,GAAkCt6F,KAAK29D,UACzF,KAAEzwD,GAASomC,EACjBA,EAAWo8C,eAAgB,EAC3BxiF,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK09D,kBAAkBvuC,GACvBnvB,KAAK0hE,gBAAgBvyC,GACrB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,GACnC3zB,EAAQwE,KAAKogF,mBAAmBpgF,KAAKszE,YAAYh4E,EAAeY,YAChE,UAAEyoB,EAAS,WAAE9c,GAAerM,EAClCwE,KAAKwkF,qBAAuBt3E,EAAK+nD,QAAQxmD,OACpCpI,IAAKqI,GAAM,EAAAsiC,UAAA,sBAAgCrsB,EAAWjW,IACtDua,KAAMzgB,IAAW,EAAAwoC,UAAA,sBAAgCxoC,EAAOX,IACzD7H,KAAKwkF,sBACLxkF,KAAKyM,cAAc23E,4BACnB,IAAA1vB,kBAAiBphB,EAAWqhB,eAEhC,MAAMs+B,EAAajd,EACb,EAAAviC,YAAY8mD,UACZ,EAAA9mD,YAAY03C,eACbnrF,KAAKq6F,oBAQNr6F,KAAKq6F,mBAAmB1lC,cAAgBrhB,EAAWqhB,cACnD30D,KAAKq6F,mBAAmBpH,WAAaA,GARrCjzF,KAAKq6F,mBAAqB,CACtB1lC,cAAerhB,EAAWqhB,cAC1Bs+B,aACAqH,iCAOR,EAAAvjC,EAAA,GAAsC8G,GACtC79D,KAAKsvF,eACLtvF,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,GAErBrhE,KAAKw6F,iBAAoBp4C,IACrB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACd5wB,EAAM4wB,EAAY5wB,KAAO,IACzB,6BAAE65F,GAAiCh6F,KAAKyM,cAAcgtF,OAE5D,IADwBO,EAA6Bn/E,SAAS1a,GAE1D,OAEJ,MAAM,WAAEmzC,GAAetzC,KAAK29D,UACtB,KAAEzwD,GAASomC,EACjB,GA/Lc,IA+LVpmC,EAAK+nD,QAAQxmD,OAAO7N,OAAxB,CAIK,CACD,MAAM65F,EAAoBvtF,EAAK+nD,QAAQxmD,OAAO7N,OAAS,EACvDZ,KAAK06F,2BAA2BvrE,EAASmkB,EAAYmnD,EACzD,CACAr4C,EAAIoV,gBADJ,MANIx3D,KAAKiL,OAAOkkB,IASpBnvB,KAAK26F,mBAAsBv4C,IACvB,MAAM,mBAAE03C,GAAuB95F,KAAKyM,cAAcgtF,OAClD,IAAKK,EACD,OAEJ,MAAM,QAAE3qE,GAAYizB,EAAIrtB,QAClB,gBAAEpb,IAAoB,IAAAohB,mBAAkB5L,GACxC0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAASi9B,gBAAkBx4C,EAAIrtB,OAAOixB,cAAcvqD,QACzD,EAAAs7D,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAK66F,mBAAsBz4C,IACvB,MAAM04C,EAAc14C,EAAIt7C,OAAS,EAAA2qB,OAAOspE,oBAClC,WAAEznD,EAAU,oBAAEuqB,GAAwB79D,KAAK29D,UAC3C,KAAEzwD,GAASomC,EACjB,GAAIpmC,EAAKqlC,QAAQsH,OACb,OAEJ75C,KAAKsvF,eACL,MAAMv+D,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,GAC3Bt1B,OAAQ0zC,EAAasU,MAAOpU,GAAe2W,EACnD,IAAIg1C,EAAe9tF,EAAK+nD,QAAQxmD,OAAO7N,QAAU,GAAKk6F,EAClDG,GAAc,EAMlB,GALI/tF,EAAK+nD,QAAQxmD,OAAO7N,QACpBZ,KAAK21B,WAAWxG,EAASmkB,EAAY,CACjC0iC,cAA8C,IAA/B9oE,EAAK+nD,QAAQxmD,OAAO7N,SAGvCsM,EAAK+nD,QAAQxmD,OAAO7N,QAAU,EAAG,CACjCZ,KAAK21B,WAAWxG,EAASmkB,GACzB,MAAQ7M,SAAUgzD,GAAWvsF,EAAKusF,OAC5B59C,EAAsB49C,EAAO79C,qCAAqCzM,EAzOlD,IA0Oa,IAA/B0M,GAAqBrzC,QACrByyF,GAAc,EACdD,GAAe,EAEvB,CACIC,GACA/tF,EAAK+nD,QAAQxmD,OAAO9F,KAAK0mC,GAE7BniC,EAAKqlC,QAAQsH,OAAS3sC,EAAKqlC,QAAQsH,QAAUmhD,EAC7C1nD,EAAW/3C,aAAc,GACzB,EAAAw7D,EAAA,GAAsC8G,GAClC3wD,EAAKqlC,QAAQsH,QACb75C,KAAKo9D,aAAahb,GAEtBA,EAAIoV,kBAERx3D,KAAKqiD,cAAiBD,IAClBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,YAAEkY,EAAW,cAAEya,EAAa,cAAExa,GAAmBh2E,KAAK29D,UACvF,KAAEzwD,GAASomC,EAEjB,GADAtzC,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBACnCwa,EAAe,CACf,MAAM,YAAEjtC,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,OAC5B,QAAEuhC,GAAY93E,EAAK+nD,SACnB,cAAEgwB,GAAkBD,EAC1BC,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC3L,EAAQ9O,UAAW,CACvB,MACK,QAAoBl4E,IAAhB+3E,EAA2B,CAChC,MAAM,YAAExyB,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,MAClCzjD,KAAKk7F,eAAe5nD,EAAYq9C,EACpC,KACK,CACD,MAAM,cAAE3qC,GAAkBj1B,EACpBzP,EAAW0kC,EAAcvC,MAC/Bv2C,EAAK+nD,QAAQxmD,OAAOsnE,GAAe,IAAIz0D,GACvCgyB,EAAW/3C,aAAc,CAC7B,CACAyE,KAAK29D,SAASuY,UAAW,EACzB,MAAM56E,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,IAE1C79D,KAAK2hE,2BAA6B,CAACruB,EAAYgnD,KAC3C,MAAMa,EAAY,EAAA1pE,OAAO2pE,qBACnBrqE,EAAc,CAChBuiB,aACA2/C,WAAY,EAAAx/C,YAAY8mD,UACxBD,iCAEJ,IAAAl4D,cAAa,EAAAxN,YAAaumE,EAAWpqE,IAEzC/wB,KAAKwzC,0BAA4B,CAACF,EAAYh4C,EAAgB23F,EAAa,EAAAx/C,YAAYu+C,gBACnF,MAAM,WAAE9iE,EAAU,kBAAEhB,GAAsB5yB,EACpC6/F,EAAY,EAAA1pE,OAAO4pE,oBACnBtqE,EAAc,CAChBuiB,aACApkB,aACAhB,oBACA+kE,eAEJ,IAAA7wD,cAAa,EAAAxN,YAAaumE,EAAWpqE,IAEzC/wB,KAAKs7F,mBAAqB,CAAChoD,EAAYh4C,EAAgB23F,EAAa,EAAAx/C,YAAYu+C,aAAcsI,KACtFrH,IAAe,EAAAx/C,YAAY8mD,UAC3Bv6F,KAAK2hE,2BAA2BruB,EAAYgnD,GAG5Ct6F,KAAKwzC,0BAA0BF,EAAYh4C,EAAgB23F,IAGnEjzF,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKyhE,cAAiBtyC,IAClB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO8pE,SAAUv7F,KAAKw6F,kBAC/CrrE,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAK26F,oBACjDxrE,EAAQ1E,iBAAiB,EAAAgH,OAAO+pE,WAAYx7F,KAAK66F,oBACjD1rE,EAAQ1E,iBAAiB,EAAAgH,OAAOspE,mBAAoB/6F,KAAK66F,oBACzD1rE,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAK66F,qBAEpD76F,KAAK0hE,gBAAmBvyC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO8pE,SAAUv7F,KAAKw6F,kBAClDrrE,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAK26F,oBACpDxrE,EAAQrE,oBAAoB,EAAA2G,OAAO+pE,WAAYx7F,KAAK66F,oBACpD1rE,EAAQrE,oBAAoB,EAAA2G,OAAOspE,mBAAoB/6F,KAAK66F,oBAC5D1rE,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAK66F,qBAEvD76F,KAAKy7F,aAAe,CAACnoD,EAAYp3C,EAAU+7D,EAAkByjC,KACzD,MAAMxuF,EAAOomC,EAAWpmC,KAClBsZ,EAAWxmB,KAAKszE,YAAYp3E,GAClC,IAAKgR,EAAKusF,OAAOhzD,SAASoT,SAAW6hD,EAAa/rE,WAC9C,OAEJ,MAAMqhE,EAAYhxF,KAAKyM,cAAc6jF,aAAapjF,EAAMsZ,GACxD,IAAKwqE,GAAkC,IAArBA,EAAUpwF,OACxB,OAEJ,MAAMohE,EAAoB90D,EAAK+nD,QAAQxmD,OAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAChF,IAAKxB,EAAK+nD,QAAQ+vB,QAAQ9O,SAAU,CAChC,MAAM+a,GAAsB,IAAAC,wBAAuBlvB,GACnD90D,EAAK+nD,QAAQ+vB,QAAQC,cACjB/oF,EAASk1B,cAAc6/D,EAC/B,CACA,MAAME,EAAkBj1F,EAASinD,cAAcj2C,EAAK+nD,QAAQ+vB,QAAQC,eAE9DmM,GAAc,IAAAC,mBAAqBp5B,EAAkB3kB,EAAWqhB,eAAiB,GADpE,UACoFq8B,EAAWG,EAAiBnvB,EAAmB,CAAC,EAAG05B,IAClJp+F,EAAGilE,EAAM/kE,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWu0F,EAC3ClkF,EAAK+nD,QAAQ+vB,QAAQE,iBAAmB,CACpChG,QAAShjF,EAASk1B,cAAc,CAACmxC,EAAM5tD,IACvC0c,SAAUn1B,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,IAChD2c,WAAYp1B,EAASk1B,cAAc,CAACmxC,EAAM5tD,EAAM9X,IAChDsiF,YAAajjF,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,EAAM9X,MAGjEmD,KAAK27F,wBAA0B,CAACv5C,EAAK9O,KACjC,MAAM,KAAEpmC,GAASomC,EACXsoD,EAAa1uF,EAAKusF,OAAO3yF,KACzB+0F,EAAe77F,KAAK87F,iBAAiBF,GACrCvmD,EAAUwmD,EAAalD,6BAC7B,IAAiD,IAA7CkD,EAAa/C,4BACb,OAEJ,MAAM/nE,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACdz1B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,EAAe,SAAEzd,GAAaZ,GAChC,cAAE81B,GAAkBl1B,GAClBuqC,SAAUgzD,GAAWvsF,EAAKusF,OAC5B/mB,EAAYtwB,EAAIrtB,OAAOixB,cAAcvqD,OACrCsgG,EAAmBtC,EAAO39C,gBAAgB42B,GAChD,GAAIqpB,EAAiB//E,SAAWq5B,EAC5B,OAEJ,MAAM,MAAE7sC,EAAO8F,MAAO6gC,GAAgBsqD,EAAOn/C,mBAAmByhD,EAAiBl/C,QACjF3vC,EAAK+nD,QAAQxmD,OAAOwE,OAAOzK,EAAO,EAAG4oB,EAAc+d,IACnDmE,EAAW/3C,aAAc,EACzB,MAAMsiE,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,gBACzE,EAAA+B,EAAA,GAAsC8G,IAE1C79D,KAAKg8F,2BAA6B,CAAC55C,EAAK9O,KACpC,MAAMsoD,EAAatoD,EAAWpmC,KAAKusF,OAAO3yF,KACpC+0F,EAAe77F,KAAK87F,iBAAiBF,GACrCvmD,EAAUwmD,EAAajD,6BAC7B,IAAiD,IAA7CiD,EAAa9C,4BACb,OAEJ,MAAMhoE,EAAcqxB,EAAIrtB,QAClB,QAAE5F,EAAO,cAAE62B,GAAkBj1B,GAC3Bt1B,OAAQi3E,GAAc1sB,GACtBvf,SAAUgzD,GAAWnmD,EAAWpmC,KAAKusF,OACvC59C,EAAsB49C,EAAO79C,qCAAqC82B,EAAWr9B,GAC9EwG,GAGL77C,KAAK06F,2BAA2BvrE,EAASmkB,EAAYuI,EAAoBrzC,QAE7ExI,KAAK8wF,sBAAwB,CAACx9C,EAAYnkB,KACtC,IAAKnvB,KAAKyM,cAAcy+E,eACpB,OAEJ,MAAMh+E,EAAOomC,EAAWpmC,KACxB,IAAKA,EAAKqlC,QAAQsH,OACd,OAEJ,MAAMv+C,GAAiB,IAAAy/B,mBAAkB5L,GACzC,IAAK7zB,EACD,OAEJ,MAAM,SAAEY,GAAaZ,GACf,YAAEkmE,GAAgBt0D,GAChBirC,SAAU1pC,GAAWvB,EAAKqlC,QAC5Bw/C,EAAYnyF,OAAO4B,KAAKggE,GAC9B,IAAK,IAAI93D,EAAI,EAAGA,EAAIqoF,EAAUnxF,OAAQ8I,IAAK,CACvC,MAAM8c,EAAWurE,EAAUroF,GACrBlO,EAAQwE,KAAKogF,mBAAmB55D,GACtC,IAAKhrB,EACD,SAEJ,MAAM,SAAE0L,GAAa1L,EACfwmE,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAC7DygC,EAAc6yB,EAAkB,GAChCi6B,EAAqB//F,EAASk1B,cAAc+d,GAC5C+sD,EAAchgG,EAASk1B,cAAc,CACvC+d,EAAY,GAAK,EACjBA,EAAY,KAEVgtD,EAAcjgG,EAASk1B,cAAc,CACvC+d,EAAY,GACZA,EAAY,GAAK,IAEfitD,EAAW,cAAcH,EAAoBC,GAC7CG,EAAW,cAAcJ,EAAoBE,IAC7C,UAAEx3E,GAAcnpB,GAChB,MAAEgB,EAAK,SAAEm5F,IAAa,QAAiCn6F,EAAO,KAChE,MAAQmqB,KAAM22E,EAAY54D,KAAM64D,EAAY72E,KAAM82E,EAAY/4D,KAAMg5D,GAAgBvkD,EAAKC,SAASukD,QAAQ16B,GACpG26B,EAAiBzgG,EAASk1B,cAAc,CAC1CorE,EACAC,IAEEG,EAAiB,EAAA5rD,UAAA,sBAAgCrsB,EAAWg4E,GAC5DE,EAAqB3gG,EAASk1B,cAAc,CAC9CkrE,EACAC,IAGJ,MAAO,CAACK,EADmB,EAAA5rD,UAAA,sBAAgCrsB,EAAWk4E,MAG1E,IAAIjH,EAAO19C,EAAKC,SAAS2kD,QAAQ96B,GAAqBxlE,EAAQA,EAC9Do5F,GAAQwG,EAAWC,EACnB76B,EAAYh7C,GAAY,CACpBuhB,SAAU7gC,EAAS6gC,SACnB6tD,OACAD,WAER,CACA,MAAMp6F,EAAc+3C,EAAW/3C,YAK/B,OAJA+3C,EAAW/3C,aAAc,EACrBA,GACAyE,KAAKwzC,0BAA0BF,EAAYh4C,EAAgB,EAAAm4C,YAAYu+C,cAEpExwB,GAEXxhE,KAAK6wF,gCAAiC,EAAAS,EAAA,GAAStxF,KAAK8wF,sBAAuB,IAAK,CAAES,UAAU,IAC5FvxF,KAAK+8F,0BAA4B/8F,KAAKg9F,oBAAoBxsF,KAAKxQ,KACnE,CACA,mBAAAg9F,CAAoB56C,GAChB,MAAQ66C,iBAAkB3pD,GAAe8O,EAAIrtB,OACxC/0B,KAAKk5F,gBAAgBr+E,SAASy4B,GAAYpsC,UAAU08C,WACpD5jD,KAAKyM,cAAc6sF,kBACnBt5F,KAAKk9F,8BAGV,KAAAC,sCAAqC7pD,EACzC,CACA,mBAAA8pD,GACI,EAAAxoE,YAAYnK,iBAAiB,EAAAgH,OAAO2pE,qBAAsBp7F,KAAK+8F,0BACnE,CACA,eAAAM,GACI,EAAAzoE,YAAY9J,oBAAoB,EAAA2G,OAAO2pE,qBAAsBp7F,KAAK+8F,0BACtE,CACA,gBAAAhzC,GACI/pD,KAAKo9F,qBACT,CACA,eAAAx4C,GACI5kD,KAAKo9F,qBACT,CACA,iBAAA/3C,GACIrlD,KAAKq9F,iBACT,CACA,gBAAA1+B,CAAiBvc,GACb,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,GAC3Bt1B,OAAQi3E,GAAc1sB,EACxBs0C,GAA+B,EAAAgD,GAAA,GAAoBl7C,EAAIrtB,OAAOwoE,SAChEv9F,KAAKyM,cAAc8sF,+BACjBjmD,EAAatzC,KAAKmvF,iBAAiB/sC,GACzCpiD,KAAKqhE,WAAY,EACjBrhE,KAAKq1D,cAAc/hB,EAAYnkB,GAC/B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAazE,OAZAh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACA2yB,eAAe,EACfxa,eAAe,EACfE,UAAU,EACV0kB,gBAAiBloB,EACjB4nB,gCAEJt6F,KAAKyhE,cAActyC,GACnBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GAC/BvqB,CACX,CACA,MAAAroC,CAAOkkB,GACH,IAAKnvB,KAAKqhE,UACN,OAEJrhE,KAAKqhE,WAAY,EACjBrhE,KAAK0hE,gBAAgBvyC,GACrBnvB,KAAK09D,kBAAkBvuC,GACvB,MAAM,WAAEmkB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,SAC5DqY,IACA,IAAAthB,kBAAiBphB,EAAWqhB,eAEhCrT,MAAMk8C,iBAAiBlqD,GACvB,MAAMh4C,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,EAG5B,OAFA,EAAAy7D,EAAA,GAAsC8G,GACtC79D,KAAK29D,SAAW,KACTrqB,EAAWqhB,aACtB,CACA,yBAAAuoC,GACI,OAAO,CACX,CACA,wBAAAO,CAAyBC,GACrB,MAAM,eAAEpiG,EAAc,SAAEkrB,EAAQ,iBAAEyxC,EAAgB,gBAAE0lC,GAAoBD,GAClE,SAAExhG,GAAaZ,GACf,cAAE6nD,GAAkBjnD,GACpB,QAAEizB,GAAYjzB,EACdo3C,EAAaoqD,EAAcpqD,YAC3B,cAAEqhB,EAAa,KAAEznD,EAAI,YAAE2nD,GAAgBvhB,GACvC,QAAE2hB,GAAY/nD,GACZuB,OAAQqrC,EAAa,kBAAEo7B,GAAsBjgB,EAC/C+gB,EAAgBh2E,KAAK29D,UAAUqY,eAC/B,UAAE9hB,EAAS,SAAE0H,EAAQ,MAAEx/D,EAAOwhG,OAAQC,GAAsBF,EAC5D37B,EAAoBloB,EAAczzC,IAAKqI,GAAMy0C,EAAcz0C,KAC3D,mBAAEorF,GAAuB95F,KAAKyM,cAAcgtF,OAC5CmC,EAAatoD,EAAWpmC,KAAKusF,OAAO3yF,KACpC+0F,EAAe77F,KAAK87F,iBAAiBF,GACrCnC,EAASnmD,EAAWpmC,KAAKusF,OAAOhzD,SAChCq3D,GAAmB,IAAAC,qBAAoBzqD,GAE7C,IAA2B,IADDwqD,EAAiBtrF,UAAWzG,IAAQA,GAE1D,MAAM,IAAI3N,MAAM,mCAAmCk1C,EAAW0qD,oBAAoBtwE,UAyBtF,IAAIgpD,EAIJ,GA3B+B,CAACpjC,KAAewqD,GAAkBhpF,OAAQw+B,GAAetzC,KAAKi+F,uBAAuB3qD,IAC7FryC,QAASqyC,IAC5B,MACM4qD,EADSl+F,KAAKm+F,sBAAsBhvE,EAASmkB,GACf4J,oBACpCl9C,KAAKo+F,sBAAsB9qD,EAAY,CACnC7kC,OAAQyvF,EACRrkD,OAAQ3sC,EAAKqlC,QAAQsH,OACrBwkD,uBAAwB,KAAwBC,WACjDpiG,EAAU,CAAEqiG,uBAAwBrxF,EAAKqlC,QAAQsH,WAExDyH,MAAMm8C,yBAAyBC,GAC1BxwF,EAAKs0D,YAAYh7C,IACqB,MAAvCtZ,EAAKs0D,YAAYh7C,GAAUmvE,SAQtBriD,EAAW/3C,aAChByE,KAAK6wF,+BAA+Bv9C,EAAYnkB,IARhDjiB,EAAKs0D,YAAYh7C,GAAY,CACzBuhB,SAAU,KACV6tD,KAAM,KACND,SAAU,MAEd31F,KAAK8wF,sBAAsBx9C,EAAYnkB,IAMtC0uE,GAAqB79F,KAAK29D,UAAkC,OAAtBuX,IACvCwB,EAA2B,CAAC1U,EAAkBkT,KAE9CwB,GAA4BV,GAAiBnhB,EAAa,CAC1D,MAAM+hB,EAAiB,KACvB,IAAA7I,aAAe9V,EAAkBtD,EAAeiiB,EAAgB5U,EAAmB,CAC/E5lE,QACA83D,YACAsU,aAAc,KAEtB,CACA,GAAIsxB,GACAL,EAAO1/C,kBAAoB,GAC3B/5C,KAAK29D,UAAUi9B,kBACdnB,EAAO5/C,OAAQ,CAChB,MAAM,gBAAE+gD,GAAoB56F,KAAK29D,UAC3B,sBAAEo8B,GAA0B/5F,KAAKyM,cAAcgtF,OACrD,GAAgC,IAA5BA,EAAO1/C,kBAA0BggD,EAAuB,CACxD,MACMyE,EAAwB,CADXx8B,EAAkB,GACM44B,IAC3C,IAAA6D,cAAgBxmC,EAAkBtD,EAAe,sBAAuB6pC,EAAuB,CAC3FpiG,MAAO,UACPw/D,SAAUA,EACV1H,UAAW,GAEnB,MACK,GAAIulC,EAAO1/C,iBAAmB,EAAG,CAClC,MAAMykD,EAAwB/E,EAAOr8C,yBAAyBw9C,EAhnBxC,KAinBtB,IAAA6D,cAAgBxmC,EAAkBtD,EAAe,sBAAuB6pC,EAAuB,CAC3FpiG,MAAO,UACPw/D,SAAUA,EACV1H,UAAW,GAEnB,CACJ,CACA,GAAI2nC,EAAahD,4BAA6B,CAC1C,MAAM6F,EAA0B,IAAI18B,GAChCy3B,EAAO5/C,QACP6kD,EAAwB/1F,KAAKq5D,EAAkB,KAEnD,IAAAy8B,cAAgBxmC,EAAkBtD,EAAe,0BAA2B+pC,EAAyB,CACjGtiG,MAAO,2BACP83D,UAAW,GAEnB,CAOA,OANAl0D,KAAKy7F,aAAanoD,EAAYp3C,EAAU+7D,EAAkB0lC,EAAgBgB,SACtE3+F,KAAKq6F,oBAAoB1lC,gBAAkBA,IAC3C30D,KAAKs7F,mBAAmBhoD,EAAYh4C,EAAgB0E,KAAKq6F,mBAAmBpH,WAAYjzF,KAAKq6F,mBAAmBC,8BAChHt6F,KAAKq6F,mBAAqB,MAE9B/mD,EAAW/3C,aAAc,GAClB,CACX,CACA,+BAAAqjG,CAAgCtrD,GAC5B,GAAIA,EAAWpmC,KAAK+nD,QAAQxmD,QAAQ7N,OAChC,OAEJ,MAAM,SAAEu3C,GAAa7E,EAAWpmC,KAAKqlC,QACrC,IAAK4F,IAAaA,EAASv3C,OACvB,OAEJ0yC,EAAWpmC,KAAK+nD,QAAQxmD,OAAS,GACjC,MAAM,OAAEA,GAAW6kC,EAAWpmC,KAAK+nD,QAC7Bp3B,EAAY5gC,KAAKkS,IAAI,GAAIlS,KAAK+Q,MAAMmqC,EAASv3C,OAAS,KAC5D,IAAK,IAAI8I,EAAI,EAAGA,EAAIyuC,EAASv3C,OAASi9B,EAAWn0B,GAAKm0B,EAClDpvB,EAAO9F,KAAKwvC,EAASzuC,IAEzB+E,EAAO9F,KAAKwvC,EAASA,EAASv3C,OAAS,GAC3C,CACA,kBAAAi+F,CAAmBvrD,GACf,OAAO4lD,GAAgBr+E,SAASy4B,GAAYpsC,UAAU08C,SAC1D,CACA,0BAAAk7C,CAA2BxrD,EAAYsoD,GACnC,MAAMC,EAAe77F,KAAK87F,iBAAiBF,GACrCnC,EAAS,IAAIoC,EAAalC,MAChCrmD,EAAWpmC,KAAKusF,OAAS,CACrB3yF,KAAM+0F,EAAa/0F,KACnB2/B,SAAUgzD,EACVhgD,WAAYoiD,EAAapiD,WAEjC,CACA,gBAAA01C,CAAiB/sC,GACb,MAAM28C,EAAoBz9C,MAAM6tC,iBAAiB/sC,IACzCqB,MAAOniC,GAAa8gC,EAAIrtB,OAAOixB,eAC/Bl/C,KAAM80F,GAAe57F,KAAKyM,cAAcgtF,OAC1CoC,EAAe77F,KAAK87F,iBAAiBF,GACrCnC,EAAS,IAAIoC,EAAalC,MAC1BqF,EAAe,KAAM,CACvBl4F,KAAM+0F,EAAa/0F,KACnB2/B,SAAUgzD,EACVhgD,WAAYoiD,EAAapiD,aAE7B,IAAIwlD,EAOJ,OANIj/F,KAAKyM,cAAcoM,eAAeiwC,UAClCm2C,EAA2B3rD,IACvBA,EAAWpmC,KAAKusF,SAAWuF,IAC3Bh/F,KAAK4+F,gCAAgCtrD,KAGtC,EAAAtC,UAAA,UAAoB+tD,EAAmB,CAC1C7xF,KAAM,CACF+nD,QAAS,CACLxmD,OAAQ,CAAC,IAAI6S,KAEjBm4E,OAAQuF,IACRx9B,YAAa,CAAC,GAElBy9B,2BAER,CACA,0BAAAvE,CAA2BvrE,EAASmkB,EAAYmnD,GAC5C,MAAMn/F,GAAiB,IAAAy/B,mBAAkB5L,IACjC1gB,OAAQqrC,GAAkBxG,EAAWpmC,KAAK+nD,QACrB,IAAzBnb,EAAcl5C,QACd,IAAA8zD,kBAAiBphB,EAAWqhB,eAG5B7a,EAAc7mC,OAAOwnF,EAAmB,GAE5C,MAAM,gBAAE9gF,GAAoBre,EACtBuiE,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzE1hB,EAAW/3C,aAAc,GACzB,EAAAw7D,EAAA,GAAsC8G,EAC1C,CACA,sBAAAogC,CAAuB3qD,GACnB,QAASA,EAAWpmC,MAAMusF,MAC9B,CACA,gBAAAqC,CAAiBh1F,GACb,MAAQ2F,cAAemoE,GAAW50E,KAC5Bk/F,EAAgBtqB,EAAO6kB,OAAOhtF,cACpC,OAAO7M,OAAO23E,OAAO,CAAEzwE,QAAQ4xF,GAAuBwG,EAAcp4F,GACxE,CACA,qBAAAq3F,CAAsBhvE,EAASmkB,GAC3B,MAAMh4C,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,cAAE6nD,GAAkBjnD,GACpB,KAAEgR,GAASomC,GACTxsC,KAAM80F,EAAYn1D,SAAUgzD,GAAWnmD,EAAWpmC,KAAKusF,OACzDoC,EAAe77F,KAAK87F,iBAAiBF,GAErCzY,EADcj2E,EAAK+nD,QAAQxmD,OACApI,IAAI88C,GAC/B1J,OAAyCz7C,IAA5B69F,EAAapiD,WAC1Bhb,SAASo9D,EAAapiD,iBACtBz7C,EACAxB,OAA+BwB,IAAvB69F,EAAar/F,MACrBia,WAAWolF,EAAar/F,YACxBwB,EAgBN,OAfAy7F,EAAOv+C,iBAAiBioC,GACxBsW,EAAO5/C,SAAW3sC,EAAKqlC,QAAQsH,OAC1B4/C,EAAO9/C,sBACO37C,IAAfy7C,GACAggD,EAAOhgD,aAAeA,IACtBggD,EAAOhgD,WAAaA,EACpBnG,EAAW/3C,aAAc,GAEzBk+F,aAAkBp4C,KACjBo4C,EAAOh4C,iBACEzjD,IAAVxB,GACAi9F,EAAOj9F,QAAUA,IACjBi9F,EAAOj9F,MAAQA,EACf82C,EAAW/3C,aAAc,GAEtBk+F,CACX,QACSz5F,KAAKyvF,QAAU,CAACvgE,EAAYzgB,EAAQrK,KACzC,MAAM9I,GAAiB,IAAAq9E,+BAA8BzpD,GACrD,IAAK5zB,EACD,OAEJ,GAAImT,EAAO7N,OA/vBO,EAiwBd,YADAwP,QAAQC,KAAK,6CAGjB,MAAM,oBAAErG,EAAmB,kBAAEzD,EAAiB,gBAAEgb,EAAe,OAAEyjB,EAAM,SAAEyB,EAAQ,SAAEvqC,GAAc8D,KAAKwxF,YAAY2H,GAAe79F,EAAgBmT,EAAQrK,GACnJw3F,EAAax3F,GAASw3F,YAAc5C,GAAgBY,WAGpDuF,EAAiB,IAAIC,EAFN34D,EAASq1D,iBAAiBF,GACdjC,QAE3B,aAAEnd,KAAiBiV,GAAwBrtF,GAAW,CAAC,EACvDkvC,EAAa,CACfqhB,cAAevwD,GAASuwD,eAAiB,EAAA3jB,UAAA,SACzC9jC,KAAM,CACF+nD,QAAS,CACLxmD,UAEJmlB,MAAO,GACP4tC,YAAa,CAAC,EACdi4B,OAAQ,CACJ3yF,KAAM80F,EACNn1D,SAAU04D,GAEd5sD,QAAS,CACLsH,QAAQ,IAGhBgb,aAAa,EACb66B,eAAe,EACfn0F,aAAa,EACbmyF,UAAU,EACVC,WAAW,EACXzmF,SAAU,CACN08C,SAAUnd,EAASuuB,cACnBzzC,kBACAvX,sBACAzD,uBACGkrF,KAGX,IAAAp8B,eAAc/hB,EAAYp3C,EAASizB,UACnC,EAAA4nC,EAAA,GAAsC,CAAC76D,EAASmN,KACjD,EAEP,SAAS,GAAoB6D,EAAMsZ,GAC/B,MAAMyrE,EAAoB/kF,EAAKs0D,YAAYh7C,IACrC,KAAEovE,EAAI,YAAEU,EAAW,SAAEX,GAAa1D,EAClCjB,EAAY,GAClB,GAAI4E,EAAM,CACN,MAAMqB,EAAWX,EACX,8BACA,SAAS,EAAAtlD,UAAA,YAAsB4kD,MAASD,IAC9C3E,EAAUroF,KAAKsuF,EACnB,CACA,OAAOjG,CACX,CACA,YCt0BA,MAAMqO,WAAsC,UAC/Br/F,KAAK4jD,SAAW,+BAAiC,CAC1D,WAAAnkD,CAAYsiD,GAMRT,MALqB,EAAAtQ,UAAA,UAAoB,CACrCvkC,cAAe,CACXy+E,gBAAgB,IAErBnpC,IAEH/hD,KAAKs/F,kCACDt/F,KAAKu/F,4BAA4B/uF,KAAKxQ,KAC9C,CACA,yBAAAk9F,GACI,OAAO,CACX,CACA,mBAAAE,GACI,EAAAxoE,YAAYnK,iBAAiB,EAAAgH,OAAO+tE,uCAAwCx/F,KAAKs/F,kCACrF,CACA,eAAAjC,GACI,EAAAzoE,YAAY9J,oBAAoB,EAAA2G,OAAO+tE,uCAAwCx/F,KAAKs/F,kCACxF,CACA,2BAAAC,CAA4Bn9C,GACxB,MAAQ66C,iBAAkB3pD,GAAe8O,EAAIrtB,OACzC/0B,KAAK4jD,WAAatQ,GAAYpsC,UAAU08C,UACvC5jD,KAAKk5F,gBAAgBr+E,SAASy4B,GAAYpsC,UAAU08C,WACpD5jD,KAAKyM,cAAc6sF,mBAGxB,KAAA6D,sCAAqC7pD,EACzC,E,6DCdJ,MAAMmsD,WAA4BrG,GAAA,SACrBp5F,KAAK4jD,SAAW,iBAAmB,CAC5C,WAAAnkD,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX6jF,aAAc,GACdpF,gBAAgB,EAChB9G,2BAA2B,EAC3BmV,+BAAgC,EAAA7kB,iBAAiBC,MACjD+qB,iBAAkB,EAClB7mF,cAAe,CACXiwC,SAAS,EACT62C,YAAa,EACbC,2BAA2B,GAE/Bv/E,SAAU,CACNyoC,SAAS,EACT0wC,QAAS,IAEbtlB,QAAS,CACL2rB,iBAAkB,CACdzrB,OAAQ,mBACRC,SAAU,CACN,CACIl0E,IAAK,gBAOzBmhD,MAAMS,EAAWC,GACjBhiD,KAAKwkF,sBAAuB,EAC5BxkF,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,KACvD,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACfwkG,EAAmB5oC,EAAYA,EAC/BisB,EAAe7vC,EAAWpmC,KAAKqlC,QAAQ4F,SAAS9xC,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IACxF,IAAI4jC,EAAa6wC,EAAaA,EAAaviF,OAAS,GACpD,IAAK,IAAI8I,EAAI,EAAGA,EAAIy5E,EAAaviF,OAAQ8I,IAAK,CAC1C,MAAMgxC,EAAWyoC,EAAaz5E,GAE9B,GAD+BwuC,EAAKsC,YAAYsD,uBAAuBxL,EAAYoI,EAAUuc,IAC/D6oC,EAC1B,OAAO,EAEXxtD,EAAaoI,CACjB,CACA,OAAO,GAEX16C,KAAKo3D,qBAAuB,CAAChV,EAAK9O,KAC9B,MAAMviB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB,MAAMgJ,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACA2yB,eAAe,GAEnB,MAAMl1F,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,EAC5B0E,KAAKs3D,gBAAgBnoC,IACrB,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAK8+D,uBAAyB,CAAC1c,EAAK9O,EAAYyrB,KAC5C,MAAMhuC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,KAAE7jB,GAASomC,EACjBA,EAAWuhB,aAAc,EACzB,IACIkhB,EADAya,GAAgB,EAEpB,GAAIzxB,EAAOkmB,cACPuL,GAAgB,MAEf,CACD,MAAM,OAAE/hF,GAAWvB,EAAK+nD,QACxB8gB,EAActnE,EAAO+D,UAAW9D,GAAMA,IAAMqwD,EAChD,CACA,MAAMlB,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,cACAya,iBAEJxwF,KAAKs3D,gBAAgBnoC,GACrB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAKo9D,aAAe,CAAChb,EAAK29C,GAAkB,KACxC,MAAMhvE,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAEmY,EAAa,6BAAEskB,GAAkCt6F,KAAK29D,UACzF,KAAEzwD,GAASomC,EACjBtzC,KAAKsvF,eACLpiF,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK09D,kBAAkBvuC,GACvBnvB,KAAK0hE,gBAAgBvyC,GACrB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,GACzC,GAAKnvB,KAAKwkF,sBACNxkF,KAAKyM,cAAc23E,2BACnB2b,EAIA,OAHA,IAAArrC,kBAAiBphB,EAAWqhB,eAC5B30D,KAAKggG,qBACL,EAAAjpC,EAAA,GAAsC8G,IAG1C,EAAA9G,EAAA,GAAsC8G,GACtC,MAAMo1B,EAAajd,EACb,EAAAviC,YAAY8mD,UACZ,EAAA9mD,YAAY03C,eAClBnrF,KAAKs7F,mBAAmBhoD,EAAYh4C,EAAgB23F,EAAYqH,GAChEt6F,KAAKggG,iBAEThgG,KAAKs7F,mBAAqB,CAAChoD,EAAYh4C,EAAgB23F,EAAa,EAAAx/C,YAAYu+C,aAAcsI,GAA+B,KACrHrH,IAAe,EAAAx/C,YAAY8mD,WAC3B,KAAA0F,mCAAkC3sD,EAAYgnD,IAG9C,KAAA9mD,2BAA0BF,EAAYh4C,EAAeY,SAASizB,QAAS8jE,IAG/EjzF,KAAK66F,mBAAsBz4C,IACvB,MAAM04C,EAAc14C,EAAIt7C,OAAS,EAAA2qB,OAAOspE,oBAClC,WAAEznD,EAAU,oBAAEuqB,EAAmB,aAAEqiC,EAAY,aAAEC,EAAY,cAAEnqB,GAAmBh2E,KAAK29D,SAC7F,GAAI39D,KAAK29D,SAAS9jB,OACd,OAEJ,MAAM9oB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,cAAEi1B,GAAkBj1B,GAClBt1B,OAAQi3E,EAAWjvB,MAAO28C,GAAqBp6C,EACvD,IAAI1kC,EAAW8+E,EACf,MAAM9kG,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,EAAQ,gBAAEyd,GAAoBre,EAChCw+C,EAAgB95C,KAAK29D,SAAS0iC,YAAYhlD,mBAChD,IAAIioC,EAAYxpC,EAAcl5C,QAAU,GAAKk6F,EAK7C,GAJA96F,KAAKsvF,eACLtvF,KAAK21B,WAAWxG,EAASmkB,EAAY,CACjC0iC,cAAeA,GAA0C,IAAzBl8B,EAAcl5C,SAE9Ck5C,EAAcl5C,QAAU,EAAG,CAC3B,MAAM0/F,EAAqB,CACvB93F,OAAQ,EACR+3F,YAAa5pF,KAEjB,IAAK,IAAIjN,EAAI,EAAGgyC,EAAM5B,EAAcl5C,OAAQ8I,EAAIgyC,EAAKhyC,IAAK,CACtD,MACM82F,EAAoBL,EADLrmD,EAAcpwC,IAE7B+2F,EAAqBvkG,EAASinD,cAAcq9C,GAC5CD,EAAcroD,EAAK5pC,MAAMwvC,uBAAuB40B,EAAW+tB,GAC7DF,GA3JW,KA4JXA,EAAcD,EAAmBC,cACjCD,EAAmBC,YAAcA,EACjCD,EAAmB93F,MAAQkB,EAEnC,CACiC,IAA7B42F,EAAmB93F,QACnB86E,GAAY,EAEpB,CACA,MAAM,iBAAEoc,GAAqB1/F,KAAKyM,cAClC,GAAIizF,IAAqB1/F,KAAK29D,SAAS9jB,OAAQ,CAC3C,MAAMwmD,EAAc,IAAI,KAClBK,EAAY1gG,KAAK2gG,SAASC,cAAcV,EAAaE,GAAmB,GACxES,EAAa7gG,KAAK2gG,SAASG,gBAAgBJ,GACjDL,EAAYU,UAAUF,GACtBR,EAAYW,YAAYhhG,KAAK29D,SAASsjC,eACtC3/E,EAAW6+E,EAAaO,GACxB1gG,KAAK29D,SAAS0iC,YAAcA,CAChC,CACArgG,KAAK29D,SAAS9jB,OAAS75C,KAAK29D,SAAS9jB,QAAUypC,EAC/CtjF,KAAK29D,SAASsjC,cAAgBjhG,KAAK29D,SAAS0iC,YAC5C,MAAMa,EAAYlhG,KAAK29D,SAAS0iC,YAAYc,eAC5CnhG,KAAK29D,SAASsjC,cAAc7mD,gBAAgB8mD,GAC5C5tD,EAAWpmC,KAAK+nD,QAAQxmD,OAAO9F,KAAKw3F,EAAae,IACjDlhG,KAAK2gG,SAASS,YAAYlB,EAAa5+E,IACvCgyB,EAAW/3C,aAAc,GACzB,EAAAw7D,EAAA,GAAsC8G,GAClC79D,KAAK29D,SAAS9jB,SACd75C,KAAKqhG,iBAAiBrhG,KAAK29D,SAASsjC,eACpCjhG,KAAKo9D,aAAahb,IAEtBA,EAAIoV,kBAERx3D,KAAK26F,mBAAsBv4C,IACvB,MAAM,QAAEjzB,EAAO,cAAE62B,GAAkB5D,EAAIrtB,QAC/B0uB,MAAOniC,EAAU7lB,OAAQi3E,GAAc1sB,GACzC,gBAAErsC,IAAoB,IAAAohB,mBAAkB5L,GACxC0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAASi9B,gBAAkBloB,EAChC,MAAQ91E,MAAO0kG,EAAUzkG,OAAQ0kG,GAAcvhG,KAAK2gG,UAC9C,aAAET,GAAiBlgG,KAAK29D,SACxB6jC,EAAatB,EAAa5+E,GAChC,GAAIkgF,EAAW,GAAK,GAChBA,EAAW,GAAK,GAChBA,EAAW,IAAMF,GACjBE,EAAW,IAAMD,EACjB,OAEJ,MAAMV,EAAa7gG,KAAK2gG,SAASG,gBAAgBU,GAC3CnB,EAAc,IAAI,KACxBA,EAAYU,UAAUF,GACtBR,EAAYW,YAAYhhG,KAAK29D,SAASsjC,eACtCjhG,KAAK29D,SAAS0iC,YAAcA,GAC5B,EAAAtpC,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAKqiD,cAAiBD,IAClBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAE2yB,EAAa,YAAEza,EAAW,cAAEC,GAAmBh2E,KAAK29D,SAC7F39D,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBACvC,MAAM,KAAE9oE,GAASomC,EACjB,GAAIk9C,EAAe,CACf,MAAM,YAAEjtC,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,OAC5B,QAAEuhC,GAAY93E,EAAK+nD,SACnB,cAAEgwB,GAAkBD,EAC1BC,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC3L,EAAQ9O,UAAW,CACvB,MACK,QAAoBl4E,IAAhB+3E,EACL3lE,QAAQC,KAAK,uCAEZ,CACD,MAAM,cAAE21C,GAAkBj1B,EACpBzP,EAAW0kC,EAAcvC,MAC/BzjD,KAAKyhG,WAAWngF,EAAU6N,EAASmkB,EAAYyiC,EACnD,CACA/1E,KAAK29D,SAASuY,UAAW,EACzB,MAAM56E,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,IAE1C79D,KAAKiL,OAAUkkB,IACX,IAAKnvB,KAAKqhE,UACN,OAEJrhE,KAAKqhE,WAAY,EACjBrhE,KAAK0hE,gBAAgBvyC,GACrBnvB,KAAK09D,kBAAkBvuC,GACvB,MAAM,WAAEmkB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,SAOhE,OANIqY,IACA,IAAAthB,kBAAiBphB,EAAWqhB,gBAEhC,EAAAoC,EAAA,GAAsC8G,GACtC79D,KAAKsvF,eACLtvF,KAAK2gG,SAAW,KACTrtD,EAAWqhB,eAEtB30D,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKyhE,cAAiBtyC,IAClB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAK26F,oBACjDxrE,EAAQ1E,iBAAiB,EAAAgH,OAAO+pE,WAAYx7F,KAAK66F,oBACjD1rE,EAAQ1E,iBAAiB,EAAAgH,OAAOspE,mBAAoB/6F,KAAK66F,oBACzD1rE,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAK66F,qBAEpD76F,KAAK0hE,gBAAmBvyC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAK26F,oBACpDxrE,EAAQrE,oBAAoB,EAAA2G,OAAO+pE,WAAYx7F,KAAK66F,oBACpD1rE,EAAQrE,oBAAoB,EAAA2G,OAAOspE,mBAAoB/6F,KAAK66F,oBAC5D1rE,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAK66F,qBAEvD76F,KAAK8wF,sBAAwB,CAACx9C,EAAYnkB,KACtC,IAAKnvB,KAAKyM,cAAcy+E,eACpB,OAEJ,MAAMh+E,EAAOomC,EAAWpmC,KACxB,IAAKA,EAAKqlC,QAAQsH,OACd,OAEJ,MAAMv+C,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,EAAQ,gBAAEyd,GAAoBre,GAChC,YAAEkmE,GAAgBt0D,GAChBirC,SAAU1pC,GAAWvB,EAAKqlC,QAC5Bw/C,EAAYnyF,OAAO4B,KAAKggE,GAC9B,IAAK,IAAI93D,EAAI,EAAGA,EAAIqoF,EAAUnxF,OAAQ8I,IAAK,CACvC,MAAM8c,EAAWurE,EAAUroF,GACrBlO,EAAQwE,KAAKogF,mBAAmB55D,GACtC,IAAKhrB,EACD,SAEJ,MAAM,SAAE0L,GAAa1L,EACfwmE,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAC7DygC,EAAc6yB,EAAkB,GAChCi6B,EAAqB//F,EAASk1B,cAAc+d,GAC5C+sD,EAAchgG,EAASk1B,cAAc,CACvC+d,EAAY,GAAK,EACjBA,EAAY,KAEVgtD,EAAcjgG,EAASk1B,cAAc,CACvC+d,EAAY,GACZA,EAAY,GAAK,IAEfitD,EAAW,cAAcH,EAAoBC,GAC7CG,EAAW,cAAcJ,EAAoBE,IAC7C,UAAEx3E,GAAcnpB,GAChB,MAAEgB,EAAK,SAAEm5F,IAAa,QAAiCn6F,EAAO,KAChE,MAAQmqB,KAAM22E,EAAY54D,KAAM64D,EAAY72E,KAAM82E,EAAY/4D,KAAMg5D,GAAgBvkD,EAAKC,SAASukD,QAAQ16B,GACpG26B,EAAiBzgG,EAASk1B,cAAc,CAC1CorE,EACAC,IAEEG,EAAiB,EAAA5rD,UAAA,sBAAgCrsB,EAAWg4E,GAC5DE,EAAqB3gG,EAASk1B,cAAc,CAC9CkrE,EACAC,IAGJ,MAAO,CAACK,EADmB,EAAA5rD,UAAA,sBAAgCrsB,EAAWk4E,MAG1E,IAAIjH,EAAO19C,EAAKC,SAAS2kD,QAAQ96B,GAAqBxlE,EAAQA,EAC9Do5F,GAAQwG,EAAWC,EACnB76B,EAAYh7C,GAAY,CACpBuhB,SAAU7gC,EAAS6gC,SACnB6tD,OACAD,SAAUA,EAElB,CACA,MAAMp6F,EAAc+3C,EAAW/3C,YAK/B,OAJA+3C,EAAW/3C,aAAc,EACrBA,GACAyE,KAAKwzC,0BAA0BF,EAAYh4C,EAAgB,EAAAm4C,YAAYu+C,cAEpExwB,GAEXxhE,KAAKy7F,aAAe,CAACnoD,EAAYp3C,EAAU+7D,EAAkByjC,KACzD,MAAMxuF,EAAOomC,EAAWpmC,KAClBsZ,EAAWxmB,KAAKszE,YAAYp3E,GAClC,IAAKgR,EAAKqlC,QAAQsH,SAAW6hD,EAAa/rE,WACtC,OAEJ,MAAMqhE,EAAYhxF,KAAKyM,cAAc6jF,aAAapjF,EAAMsZ,GACxD,IAAKwqE,GAAkC,IAArBA,EAAUpwF,OACxB,OAEJ,MAAMohE,EAAoB90D,EAAK+nD,QAAQxmD,OAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAChF,IAAKxB,EAAK+nD,QAAQ+vB,QAAQ9O,SAAU,CAChC,MAAM+a,GAAsB,IAAAC,wBAAuBlvB,GACnD90D,EAAK+nD,QAAQ+vB,QAAQC,cACjB/oF,EAASk1B,cAAc6/D,EAC/B,CACA,MAAME,EAAkBj1F,EAASinD,cAAcj2C,EAAK+nD,QAAQ+vB,QAAQC,eAE9DmM,GAAc,IAAAC,mBAAqBp5B,EAAkB3kB,EAAWqhB,eAAiB,GADpE,UACoFq8B,EAAWG,EAAiBnvB,EAAmB,CAAC,EAAG05B,IAClJp+F,EAAGilE,EAAM/kE,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWu0F,EAC3ClkF,EAAK+nD,QAAQ+vB,QAAQE,iBAAmB,CACpChG,QAAShjF,EAASk1B,cAAc,CAACmxC,EAAM5tD,IACvC0c,SAAUn1B,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,IAChD2c,WAAYp1B,EAASk1B,cAAc,CAACmxC,EAAM5tD,EAAM9X,IAChDsiF,YAAajjF,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,EAAM9X,MAGjEmD,KAAKwzC,0BAA4B,CAACF,EAAYh4C,EAAgB23F,EAAa,EAAAx/C,YAAYu+C,gBACnF,MAAM,WAAE9iE,EAAU,kBAAEhB,GAAsB5yB,EACpC6/F,EAAY,EAAA1pE,OAAO4pE,oBACnBtqE,EAAc,CAChBuiB,aACApkB,aACAhB,oBACA+kE,eAEJ,IAAA7wD,cAAa,EAAAxN,YAAaumE,EAAWpqE,IAEzC/wB,KAAK6wF,gCAAiC,EAAAS,EAAA,GAAStxF,KAAK8wF,sBAAuB,IAAK,CAAES,UAAU,GAChG,CACA,iBAAAmQ,CAAkBpgF,EAAU6N,EAASmkB,EAAYquD,EAASrH,GACtD,MAAMh/F,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACrB0E,KAAKqhE,WAAY,EACjB,MAAMugC,EAAoB1lG,EAASq8B,gBAC3B5T,UAAWyqB,GAAiBwyD,EACpC,IAAI1B,EACAC,EACAvjG,EACAC,EACAsI,EACJ,GAAMjJ,aAAoB,EAAAg3C,eAUrB,MAAIh3C,aAAoB,EAAAg3C,gBAiBzB,MAAM,IAAI90C,MAAM,0BAjByB,CACzC,MAAMyjG,EAAiB,0CAAsC3lG,IACvD,mBAAEy7B,EAAkB,mBAAEC,GAAuBiqE,EACnD3B,EAAgB5xF,IACZ,MAAMwzF,EAAW,kCAA8B1yD,EAAc9gC,GACvDkzF,EAAa,mBAAmB,CAAC,EAAG,EAAG,GAAIM,EAAUlqE,GAC3D,MAAO,CAAC4pE,EAAW,GAAIA,EAAW,KAEtCrB,EAAgB7xF,IACZ,MAAMwzF,EAAW,mBAAmB,CAAC,EAAG,EAAG,GAAI,CAACxzF,EAAM,GAAIA,EAAM,GAAI,GAAIqpB,GACxE,OAAO,kCAA8ByX,EAAc0yD,IAEvD38F,EAAa08F,EAAe18F,WAC5BvI,EAAQilG,EAAejlG,MACvBC,EAASglG,EAAehlG,MAC5B,CAGA,MA3BID,EAAQglG,EAAkB/5F,WAAW,GACrChL,EAAS+kG,EAAkB/5F,WAAW,GACtCq4F,EAAgB5xF,IACZ,MAAMwzF,EAAW,kCAA8B1yD,EAAc9gC,GAC7D,MAAO,CAACwzF,EAAS,GAAIA,EAAS,KAElC3B,EAAgB7xF,GAAU,kCAA8B8gC,EAAc,CAAC9gC,EAAM,GAAIA,EAAM,GAAI,IAC3FnJ,EAAay8F,EAAkBz8F,WAqBnCA,EAAa,+BAA2BA,EAAYvI,EAAOC,GAC3D,MAAM,SAAE+iB,GAAa1jB,EAASorB,gBACxBy6E,EAAW7B,EAAa5+E,GAC9BthB,KAAK2gG,SAAWqB,GAAA,EAAiBC,+BAA+B98F,EAAYvI,EAAOC,EAAQ+iB,GACvF+hF,IACA3hG,KAAKkiG,aAAeF,GAAA,EAAiBC,+BAA+B98F,EAAYvI,EAAOC,EAAQ+iB,GAC/F5f,KAAKkiG,aAAad,YAAYlB,EAAayB,KAE/C3hG,KAAK2gG,SAASS,YAAYW,GAC1B,MAAM/rB,GAAiB2rB,EACjBV,EAAgB,IAAI,KACpBZ,EAAc,IAAI,KAClB8B,EAAkBnsB,OAAgBh4E,EAAY,IAAI,KACxDijG,EAAclpF,SAASgqF,GACvBd,EAAc7mD,gBAAgB2nD,GAC9B,MAAMlkC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACnE4lC,EAAkB1+F,EAASinD,cAAc7hC,GAC/CthB,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAmY,gBACAE,UAAU,EACV0kB,kBACAqG,gBACAZ,cACA+B,kBAAmBD,EACnBtoD,QAAQ,EACRk8B,YAAa/1E,KAAK29D,UAAUoY,aAAeziC,EAAW2hB,SAASigB,kBAC/DgrB,eACAC,eACA7F,+BAER,CACA,gBAAA37B,CAAiBvc,GACb,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,GAC3B0yB,MAAOniC,GAAa0kC,EACtB1S,EAAatzC,KAAKmvF,iBAAiB/sC,GACnCk4C,GAA+B,EAAAgD,GAAA,GAAoBl7C,EAAIrtB,OAAOwoE,SAChEv9F,KAAKyM,cAAc8sF,+BAMvB,OALAv5F,KAAK0hG,kBAAkBpgF,EAAU6N,EAASmkB,OAAYt1C,EAAWs8F,GACjEt6F,KAAKq1D,cAAc/hB,EAAYnkB,GAC/BnvB,KAAKyhE,cAActyC,GACnBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC/2D,KAAK29D,SAASE,qBAC7CvqB,CACX,CACA,aAAA0sD,GACIhgG,KAAK29D,SAAW,KAChB39D,KAAK2gG,SAAW,KAChB3gG,KAAKkiG,aAAe,KACpBliG,KAAKqhE,WAAY,CACrB,CACA,UAAAogC,CAAWngF,EAAU6N,EAASmkB,EAAYyiC,GACtC,MAAM,KAAE7oE,GAASomC,GACT7kC,OAAQ4zF,GAAiBn1F,EAAK+nD,SAC9Br0D,OAAQ0hG,GAAeD,EACzBE,EAAiBF,GAActsB,EAAc,EAAIusB,GAAcA,GAC/DE,EAAaH,GAActsB,EAAc,GAAKusB,GACpD,IAAKtiG,KAAK29D,UAAUykC,kBAAmB,CACnCpiG,KAAK0hG,kBAAkBa,EAAgBpzE,EAASmkB,EAAYkvD,GAC5D,MAAM,SAAErqD,GAAajrC,EAAKqlC,QACpB0uD,EAAgB,IAAI,KACpBmB,EAAoB,IAAI,MACxB,aAAElC,GAAiBlgG,KAAK29D,SACxBwvB,GAAgB,EAAAsV,GAAA,GAAwBnvD,EAAYyiC,EAAc,GAClEqX,GAAY,EAAAqV,GAAA,GAAwBnvD,EAAYyiC,EAAc,GACpE,IAAmB,IAAfqX,IAAuC,IAAnBD,EACpB,MAAM,IAAI/uF,MAAM,4BAA0C,IAAfgvF,GAAoBoV,MAAiC,IAAnBrV,GAAwBoV,KAErF,IAAhBxsB,EACAqsB,EAAkBrB,UAAU5oD,EAASz3C,MAAM0sF,EAAY,EAAGD,GAAe9mF,IAAI65F,KAG7Ee,EAAcF,UAAU5oD,EAASz3C,MAAM,EAAGysF,EAAgB,GAAG9mF,IAAI65F,IACjEkC,EAAkBrB,UAAU5oD,EAASz3C,MAAM0sF,EAAWj1C,EAASv3C,QAAQyF,IAAI65F,KAE/ElgG,KAAK29D,SAASsjC,cAAgBA,EAC9BjhG,KAAK29D,SAASykC,kBAAoBA,CACtC,CACA,MAAM,SAAEzkC,EAAQ,SAAEgjC,GAAa3gG,MACzB,aAAEkgG,EAAY,aAAEC,GAAiBxiC,GACjC,kBAAEuX,GAAsBhoE,EAAK+nD,QACnC,GAAIigB,QACAhoE,EAAK+nD,QAAQigB,kBAAoBa,OAEhC,GAAIb,IAAsBa,EAC3B,MAAM,IAAI33E,MAAM,yEAAyE23E,OAAiB7oE,EAAK+nD,QAAQigB,qBAE3H,MAAMwtB,EAAWxC,EAAa5+E,GAC9B,GAAIohF,EAAS,GAAK,GACdA,EAAS,IAAM/B,EAAS/jG,OACxB8lG,EAAS,GAAK,GACdA,EAAS,IAAM/B,EAAS9jG,OACxB,OAEJwlG,EAAatsB,GAAeoqB,EAAauC,GACzC,MAAMC,EAAiBhC,EAASG,gBAAgB4B,GAC1CE,EAAkB5iG,KAAKkiG,aAAapB,gBAAgB4B,GACpDrC,EAAc,IAAI,KACxBA,EAAYW,YAAYrjC,EAASsjC,eACb,IAAhBlrB,GACAsqB,EAAYU,UAAU4B,GAE1BtC,EAAYU,UAAU6B,EAAgB90F,WACtCuyF,EAAYwC,WAAWllC,EAASykC,mBACZ,IAAhBrsB,GACAsqB,EAAYU,UAAU4B,GAE1BhlC,EAAS0iC,YAAcA,EACvB/sD,EAAW/3C,aAAc,EACzBoiE,EAASuY,UAAW,EACpBvY,EAAS9jB,QAAS,CACtB,CACA,gBAAAme,CAAiB18D,EAAgB28D,GAE7B,OADAj4D,KAAKqhG,iBAAiBrhG,KAAK29D,UAAU0iC,aAC9B/+C,MAAM0W,iBAAiB18D,EAAgB28D,EAClD,CACA,yBAAAilC,GACI,OAAO,CACX,CACA,gBAAA/N,CAAiB/sC,GACb,MAAM0gD,EAAgCxhD,MAAM6tC,iBAAiB/sC,IACrDqB,MAAOniC,GAAa8gC,EAAIrtB,OAAOixB,cAQvC,OAPmB,sBAAkB88C,EAA+B,CAChE51F,KAAM,CACF+nD,QAAS,CACLxmD,OAAQ,CAAC,IAAI6S,OAK7B,CACA,gBAAAu+E,CAAiB1wE,EAASylD,EAAQxyB,GACzBpiD,KAAK29D,SAIV39D,KAAKo9D,aAAahb,GAAK,GAHnBpiD,KAAKo0B,MAIb,CACA,wBAAAqpE,CAAyBC,GACrB,MAAM,WAAEpqD,EAAU,eAAEh4C,EAAc,iBAAE28D,EAAgB,gBAAE0lC,EAAe,SAAEn3E,GAAck3E,GAC/E,SAAExhG,GAAaZ,GACf,QAAE6zB,GAAYjzB,GACd,cAAEinD,GAAkBjnD,GACpB,cAAEy4D,EAAa,KAAEznD,EAAI,YAAE2nD,GAAgBvhB,GACvC,QAAE2hB,GAAY/nD,EACd8oE,EAAgBh2E,KAAK29D,UAAUqY,eAC/B,UAAE9hB,EAAS,SAAE0H,EAAQ,MAAEx/D,GAAUuhG,EACvC,GAAI9oC,GACCmhB,GACG1iC,EAAWqhB,gBAAkB30D,KAAK29D,UAAUrqB,YAAYqhB,cAAgB,CAC5E,MAAMiiB,EAAiB,IACjBugB,EAAgBliC,EAAQxmD,OAAOpI,IAAI88C,IACzC,IAAA4qB,aAAe9V,EAAkBtD,EAAeiiB,EAAgBugB,EAAe,CAC3E/6F,QACAw/D,WACA1H,aAER,CAeA,OAdA5S,MAAMm8C,yBAAyBC,GAC1BxwF,EAAKs0D,YAAYh7C,IACuB,OAAzCtZ,EAAKs0D,YAAYh7C,IAAWmvE,SAQvBriD,EAAW/3C,aAChByE,KAAK6wF,+BAA+Bv9C,EAAYnkB,IARhDjiB,EAAKs0D,YAAYh7C,GAAY,CACzBuhB,SAAU,KACV6tD,KAAM,KACND,SAAU,MAEd31F,KAAK8wF,sBAAsBx9C,EAAYnkB,IAK3CnvB,KAAKy7F,aAAanoD,EAAYp3C,EAAU+7D,EAAkB0lC,EAAgBgB,UACnE,CACX,CACA,gBAAA0C,CAAiB0B,GACb,IAAK/iG,KAAK29D,WAAaolC,EACnB,OAEJ,MAAM,WAAEzvD,EAAU,aAAE6sD,EAAY,aAAED,EAAY,OAAErmD,EAAM,cAAEm8B,GAAkBh2E,KAAK29D,SAC/E,IAAMqlC,WAAYC,GAAgBF,EAC9BE,EAAYriG,OAAS,IACrBqiG,EAAc,IAAIA,EAAaA,EAAY,KAE/C,MAAM5E,EAAyBroB,GAAiBn8B,EAAS,KAAwBykD,eAAYtgG,EAC7FgC,KAAKo+F,sBAAsB9qD,EAAY,CACnC7kC,OAAQw0F,EACRppD,SACAwkD,0BACD,CACCjtE,cAAe+uE,EACfh9C,cAAe+8C,GAEvB,EAEJ,YACA,SAAS,GAAoBhzF,EAAMsZ,GAC/B,MAAMyrE,EAAoB/kF,EAAKs0D,YAAYh7C,IACrC,KAAEovE,EAAI,SAAED,GAAa1D,EACrBjB,EAAY,GAClB,GAAI4E,EAAM,CACN,MAAMqB,EAAW,SAAS,wBAAoBrB,MAASD,IACvD3E,EAAUroF,KAAKsuF,EACnB,CACA,OAAOjG,CACX,C,gBC1oBA,MAAMkS,WAAwC,UACjCljG,KAAK4jD,SAAW,iCAAmC,CAC5D,4BAAAu/C,CAA6B7vD,EAAYh4C,IACjC0E,KAAK29D,UACJrqB,EAAW/3C,aACX+3C,EAAWpmC,KAAK+nD,QAAQmuC,uBAG7B9vD,EAAWpmC,KAAKqlC,QAAQ8wD,iBAAmB/vD,EAAWpmC,KAAKqlC,QAAQ4F,SACnEmrD,eAAe,KACX,IAAKhwD,EAAWpmC,KAAK+nD,QAAQmuC,qBACzB,OAEJ,MAAM,OAAE30F,GAAW6kC,EAAWpmC,KAAK+nD,SAC7B,QAAE9lC,GAAY7zB,EAAeY,SACnC8D,KAAK0hG,kBAAkBjzF,EAAO,GAAI0gB,EAASmkB,GAC3C,MAAQ1yC,OAAQqO,GAAUR,GACpB,SAAEkyF,GAAa3gG,MACf,YAAE2/F,EAAW,oBAAE4D,GAAwBvjG,KAAKyM,cAAcoM,cAChEy6B,EAAWpmC,KAAK+nD,QAAQuuC,eAAiB/0F,EACzC,MAAM,aAAEyxF,EAAY,aAAEC,GAAiBngG,KAAK29D,SACtC8lC,EAAkB,GACxB,GAAI9D,EAAa,CACb,IAAIuB,EAAYhB,EAAazxF,EAAOA,EAAO7N,OAAS,IACpD6N,EAAOxN,QAAQ,CAACqN,EAAOo1F,KACnB,MAAMC,EAAYzD,EAAa5xF,GAC/B4yF,EAAYyC,EACZF,EAAgB96F,KAAKg7F,GACrBhD,EAASS,YAAYF,GACrBP,EAASG,gBAAgB6C,GACzBhD,EAASG,gBAAgBZ,EAAazxF,GAAQi1F,EAAS,GAAKj1F,EAAO7N,UACnE,MAAMgjG,EAAWjD,EAASC,cAAc+C,EAAWhE,GAC9C,oBAAgBgE,EAAWC,KAC5BH,EAAgBC,GAAUE,EAC1B1C,EAAY0C,EACZn1F,EAAOi1F,GAAUvD,EAAayD,KAG1C,CACA,MAAMC,EAAe,IAAI,KACzB,IAAK,IAAIn6F,EAAI,EAAGA,EAAIuF,EAAOvF,IAAK,CAC5Bi3F,EAASS,YAAYlB,EAAazxF,EAAO/E,KACzC,MAAMo6F,EAAOnD,EAASG,gBAAgBZ,EAAazxF,GAAQ/E,EAAI,GAAKuF,KACpE40F,EAAa9C,UAAU+C,EAC3B,CACA9jG,KAAKqhG,iBAAiBwC,GACtB7jG,KAAK2gG,SAAW,KAChB3gG,KAAKkiG,aAAe,KACpBliG,KAAK29D,SAAW,KAChBrqB,EAAWpmC,KAAK+nD,QAAQmuC,qBAAuB,KAC3CG,IACA,KAAA/vD,2BAA0BF,EAAYh4C,EAAeY,SAASizB,QAAS,EAAAskB,YAAYswD,wBAG/F,CACA,wBAAAtG,CAAyBC,GACrB,MAAM,eAAEpiG,EAAc,iBAAE28D,GAAqBylC,EACvCpqD,EAAaoqD,EAAcpqD,YAC3B,cAAEqhB,GAAkBrhB,GACpB,SAAEp3C,GAAaZ,GACf,cAAE6nD,GAAkBjnD,GACpB,0BAAE0jG,GAA8B5/F,KAAKyM,cAAcoM,eAAiB,CAAC,EAC3E7Y,KAAKmjG,+BAA+B7vD,EAAYh4C,GAChD,MAAM,iBAAE+nG,GAAqB/vD,EAAWpmC,KAAKqlC,QACvCyxD,EAAW1iD,MAAMm8C,yBAAyBC,GAChD,GAAIkC,GACAyD,GACA/vD,EAAWo8C,cAAe,CAC1B,MAAMuU,EAAuBZ,EAAiBh9F,IAAI88C,GAClD8gD,EAAqBt7F,KAAKs7F,EAAqB,KAC/C,IAAAxF,cAAgBxmC,EAAkBtD,EAAe,yBAA0BsvC,EAAsB,CAC7F7nG,MAAO,UACP83D,UAAW,EACXmvB,YAAa,GAErB,CACA,OAAO2gB,CACX,CACA,yBAAA9G,GACI,OAAO,CACX,QAEIgH,GAAAp5D,EAAsBq5D,SAASnkG,KACnC,EC3EJ,MAAMokG,WAA0B,aACnBpkG,KAAK4jD,SAAW,eAAiB,CAC1C,WAAAnkD,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX47D,QAAQ,EACRmmB,gBAAe,GACfC,mBAAkB,GAClBrK,2BAA2B,EAC3BigB,YAAY,EACZC,eAAgB,YAGpBhjD,MAAMS,EAAWC,GACjBhiD,KAAK2+D,iBAAoBvc,IACrBpiD,KAAKq1B,sBACL,MAAMtE,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,OAC/B,KAAA8T,mBAAkBpoC,GAClBnvB,KAAKqhE,WAAY,EACjB,MAAM,WAAEgjC,GAAerkG,KAAKyM,cACtB6mC,EAAatzC,KAAKmvF,iBAAiB/sC,EAAK,CAAC,IAAI9gC,GAAW,IAAIA,IAAY,CAC1EpU,KAAM,CACF+nD,QAAS,CACLovC,kBAIZ,IAAAhvC,eAAc/hB,EAAYnkB,GAC1B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAYzE,OAXAh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,YAAa,EACbya,eAAe,EACfxa,eAAe,EACfE,UAAU,GAEdl2E,KAAKyhE,cAActyC,GACnBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GAC/BvqB,GAEXtzC,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,KACvD,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,KAAE4R,GAASomC,GACVse,EAAQC,GAAU3kD,EAAK+nD,QAAQxmD,OAChCgiF,EAAev0F,EAASinD,cAAcyO,GACtC8+B,EAAex0F,EAASinD,cAAc0O,GACtC8I,EAAO,CACTj/D,MAAO,CACH4B,EAAGmzF,EAAa,GAChBjzF,EAAGizF,EAAa,IAEpBz+E,IAAK,CACD1U,EAAGozF,EAAa,GAChBlzF,EAAGkzF,EAAa,KAIxB,OADwB,mBAA4B,CAAC/1B,EAAKj/D,MAAM4B,EAAGq9D,EAAKj/D,MAAM8B,GAAI,CAACm9D,EAAK3oD,IAAI1U,EAAGq9D,EAAK3oD,IAAIxU,GAAI,CAACy5D,EAAa,GAAIA,EAAa,MACpHC,GAK3Bl3D,KAAKo3D,qBAAuB,CAAChV,EAAK9O,KAC9B,MAAMviB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB,MAAMgJ,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACA2yB,eAAe,GAEnBxwF,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,GAClB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAEmY,EAAa,SAAEE,EAAQ,cAAEsa,GAAmBxwF,KAAK29D,UACpF,KAAEzwD,GAASomC,EACb0iC,IAAkBE,IAGtBhpE,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK09D,kBAAkBvuC,GACvBnvB,KAAK0hE,gBAAgBvyC,IACrB,KAAAyuC,oBAAmBzuC,GACfnvB,KAAKwkF,sBACLxkF,KAAKyM,cAAc23E,4BACnB,IAAA1vB,kBAAiBphB,EAAWqhB,eAE5BqhB,EACAh2E,KAAKyM,cAAc+hF,gBAAiB56D,IAChC,IAAKA,EAKD,OAJA,IAAA8gC,kBAAiBphB,EAAWqhB,gBAC5B,EAAAoC,EAAA,GAAsC8G,GACtC79D,KAAK29D,SAAW,UAChB39D,KAAKqhE,WAAY,GAGrB/tB,EAAWpmC,KAAK0mB,MAAQA,GACxB,KAAA4f,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAY03C,iBAC3D,KAAAxpB,4BAA2BruB,GAC3BtzC,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,gBAAiBh2E,KAAKi1B,OAC7Doe,GAAmBC,EAAYnkB,EAASyE,GACxC5zB,KAAKu1B,oBACLv1B,KAAKsvF,gBACL,EAAAv4B,EAAA,GAAsC8G,KAGpC2yB,IACN,KAAAh9C,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAY03C,gBAE/DnrF,KAAKsvF,eACLtvF,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,IAErBrhE,KAAKqiD,cAAiBD,IAClBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,YAAEkY,EAAW,cAAEya,EAAa,cAAExa,GAAmBh2E,KAAK29D,SAC7F39D,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBACvC,MAAM,KAAE9oE,GAASomC,EACjB,GAAIk9C,EAAe,CACf,MAAM,YAAEjtC,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,OAC5B,QAAEuhC,GAAY93E,EAAK+nD,SACnB,cAAEgwB,GAAkBD,EAC1BC,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC3L,EAAQ9O,UAAW,CACvB,MACK,QAAoBl4E,IAAhB+3E,EAA2B,CAChC,MAAM,YAAExyB,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,MACnBv2C,EAAK+nD,QAAQxmD,OACrBxN,QAASqN,IACZA,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,KAE9Br9C,EAAW/3C,aAAc,CAC7B,KACK,CACD,MAAM,cAAEyqD,GAAkBj1B,EACpBzP,EAAW0kC,EAAcvC,MAC/Bv2C,EAAK+nD,QAAQxmD,OAAOsnE,GAAe,IAAIz0D,GACvCgyB,EAAW/3C,aAAc,CAC7B,CACAyE,KAAK29D,SAASuY,UAAW,GACzB,EAAAnf,EAAA,GAAsC8G,GAClCvqB,EAAW/3C,cACX,KAAAi4C,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAY03C,iBAGnEnrF,KAAKukG,iBAAoBniD,IACE,GAAnBA,EAAIrtB,OAAOyvE,MACXxkG,KAAKykG,oBAAoBriD,IAGjCpiD,KAAKykG,oBAAuBriD,IACxB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpB,IAAIwjC,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GAErD,GADAolC,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAEJ,MAAM8jG,EAAoBnwC,EAAY72C,KAAM41B,GAAetzC,KAAKg3D,gBAAgB7nC,EAASmkB,EAAYviB,EAAYi1B,cAAcvqD,OAAQ,IACvI,IAAKipG,EACD,OAEJ,MAAMpxD,EAAaoxD,EACnB1kG,KAAKyM,cAAcgiF,mBAAmBiW,EAAmBtiD,EAAIrtB,OAAQ/0B,KAAK+vF,0BAA0Bv/E,KAAKxQ,KAAMmvB,EAASmkB,IACxHtzC,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,EACjBjf,EAAIuiD,2BACJviD,EAAIoV,kBAERx3D,KAAKiL,OAAUkkB,IACX,GAAInvB,KAAKqhE,UAAW,CAChBrhE,KAAKqhE,WAAY,EACjBrhE,KAAK0hE,gBAAgBvyC,GACrBnvB,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,WAAEmkB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,KAAEzwD,GAASomC,EAQjB,OAPAA,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,MACjC,EAAAne,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KACTrqB,EAAWqhB,aACtB,GAEJ30D,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,gBAErDriD,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,eAEvDp9D,KAAKyhE,cAAiBtyC,IAClB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,gBAErDriD,KAAK0hE,gBAAmBvyC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,gBAExDriD,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACpB,IAAIq4D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAGX,GADAnE,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAAO83D,EAEX,MAAMqJ,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6qD,EAAY3zD,OAAQ8I,IAAK,CACzC,MAAM4pC,EAAaihB,EAAY7qD,IACzB,cAAEirD,EAAa,KAAEznD,GAASomC,GAC1B,QAAE2hB,EAAO,MAAErhC,GAAU1mB,GACrB,OAAEuB,EAAM,kBAAEymE,GAAsBjgB,EACtC8M,EAAepN,cAAgBA,EAC/B,MAAM,MAAEv4D,EAAK,UAAE83D,EAAS,SAAE0H,EAAQ,WAAEgpC,GAAe5kG,KAAKiiE,mBAAmB,CACvE3uB,aACAyuB,mBAEEC,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IACnE,IAAIgoE,EAMJ,IALK,KAAA7e,oBAAmBlD,IACnB30D,KAAK29D,UACgB,OAAtBuX,IACAwB,EAA2B,CAAC1U,EAAkBkT,MAE7Ch5E,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,KAAK,KAAAie,qBAAoBhiB,GACrB,SAEJ,MAAMo8B,EAAoB96B,SAAQ,QAAiB,oBAAqB,CAAC,IACzE,GAAIygB,GAA4Bqa,EAAmB,CAC/C,MAAMna,EAAiB,KACvB,IAAA7I,aAAe9V,EAAkBtD,EAAeiiB,EAAgB5U,EAAmB,CAC/E5lE,QACA83D,aAER,CACA,MAAM2wC,EAAW,IAoBjB,GAnBI7kG,KAAKyM,cAAc43F,YACnB,IAAAS,WAAa7sC,EAAkBtD,EAAekwC,EAAU7iC,EAAkB,GAAIA,EAAkB,GAAI,CAChG5lE,QACAQ,MAAOs3D,EACP0H,SAAUA,EACVmpC,UAAiD,WAAtC/kG,KAAKyM,cAAc63F,eAC9BM,gBAIJ,IAAAE,WAAa7sC,EAAkBtD,EAAekwC,EAAU7iC,EAAkB,GAAIA,EAAkB,GAAI,CAChG5lE,QACAQ,MAAOs3D,EACP0H,SAAUA,EACVmpC,UAAiD,WAAtC/kG,KAAKyM,cAAc63F,eAC9BM,eAGRlsC,GAAe,GACV9kC,EACD,SAEJ,MAAMxvB,EAAUpE,KAAKuvF,sBAAsBxtB,EAAgBzuB,GAC3D,IAAKlvC,EAAQurB,WAAY,CACrBziB,EAAK+nD,QAAQ+vB,QAAU,CACnB9O,UAAU,EACV+O,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChB7tD,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB6tD,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,IAAKjyE,EAAK+nD,QAAQ+vB,QAAQ9O,SAAU,CAChC,MAAM+a,EAAsBjvB,EAAkB,GAC9C90D,EAAK+nD,QAAQ+vB,QAAQC,cACjB/oF,EAASk1B,cAAc6/D,EAC/B,CACA,MAAME,EAAkBj1F,EAASinD,cAAcj2C,EAAK+nD,QAAQ+vB,QAAQC,eAC9DuK,EAAa,IACb4B,GAAc,IAAAC,mBAAqBp5B,EAAkBtD,EAAe66B,EAAY,CAAC57D,GAAQu9D,EAAiBnvB,EAAmB,CAAC,EAAG59D,IAC/H9G,EAAGilE,EAAM/kE,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWu0F,EAC3ClkF,EAAK+nD,QAAQ+vB,QAAQE,iBAAmB,CACpChG,QAAShjF,EAASk1B,cAAc,CAACmxC,EAAM5tD,IACvC0c,SAAUn1B,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,IAChD2c,WAAYp1B,EAASk1B,cAAc,CAACmxC,EAAM5tD,EAAM9X,IAChDsiF,YAAajjF,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,EAAM9X,IAEjE,CACA,OAAO67D,EAEf,QACS14D,KAAKyvF,QAAU,CAACvgE,EAAYzgB,EAAQmlB,EAAOxvB,KAChD,MAAM9I,GAAiB,IAAAq9E,+BAA8BzpD,GACrD,IAAK5zB,EACD,OAEJ,MAAM,oBAAE0O,EAAmB,kBAAEzD,EAAiB,gBAAEgb,EAAe,SAAEklB,EAAQ,SAAEvqC,GAAc8D,KAAKwxF,YAAY4S,GAAmB9oG,EAAgBmT,EAAQrK,IAC/I,aAAEo4E,KAAiBiV,GAAwBrtF,GAAW,CAAC,EACvDkvC,EAAatzC,KAAKmvF,iBAAiB,CACrCx6B,cAAevwD,GAASuwD,eAAiB,qBACzCznD,KAAM,CACF0mB,MAAOA,GAAS,GAChBqhC,QAAS,CACLxmD,WAGRihF,eAAe,EACfxoF,SAAU,CACN08C,SAAUnd,EAASuuB,cACnBzzC,kBACAvX,sBACAzD,uBACGkrF,MAGX,IAAAp8B,eAAc/hB,EAAYp3C,EAASizB,UACnC,EAAA4nC,EAAA,GAAsC,CAAC76D,EAASmN,KACjD,CACH,sBAAAy1D,CAAuB1c,EAAK9O,EAAYyrB,GACpC,MAAMhuC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,KAAE7jB,GAASomC,EACjBA,EAAWuhB,aAAc,EACzB,IACIkhB,EADAya,GAAgB,EAEhBzxB,EAAOkmB,cACPuL,GAAgB,EAGhBza,EAAc7oE,EAAK+nD,QAAQxmD,OAAO+D,UAAW9D,GAAMA,IAAMqwD,GAE7D,MAAMlB,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,cACAya,iBAEJxwF,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,GAClB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,GACtCzb,EAAIoV,gBACR,CACA,yBAAAu4B,CAA0B5gE,EAASmkB,EAAYC,GAC3CD,EAAWpmC,KAAK0mB,MAAQ2f,EACxB,MAAMsqB,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,gBACzE,EAAA+B,EAAA,GAAsC8G,IACtC,KAAArqB,2BAA0BF,EAAYnkB,EAC1C,CACA,eAAA6gE,CAAgBC,EAAQC,EAAQroF,GAC5B,OAAQ,kCAA8BooF,EAAQpoF,IAC1C,kCAA8BqoF,EAAQroF,EAC9C,EAEJ,SAAS,GAAgBsoF,GACrB,OAAOA,EAAyBC,OAAO,0BAC3C,CACA,SAAS,GAAmBljF,EAAMs1B,EAAW2tD,GACzC,OAAOA,EAAyBC,OAAO,0BAC3C,CCpaA,MAAM4U,WAAkB,aACXhlG,KAAK4jD,SAAW,OAAS,CAClC,WAAAnkD,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX47D,QAAQ,EACR48B,cAAc,EACdC,UAAW,EACX9gB,2BAA2B,EAC3BkM,aAAc,MAGlBhvC,MAAMS,EAAWC,GACjBhiD,KAAK2+D,iBAAoBvc,IACrB,GAAIpiD,KAAKmlG,4BACL,OAEJnlG,KAAKmlG,6BAA8B,EACnC,MAAMp0E,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,OAC/B,KAAA8T,mBAAkBpoC,GAClBnvB,KAAKqhE,WAAY,EACjB,MAAM/tB,EAActzC,KAAKmvF,iBAAiB/sC,EAAK,CAC3C,IAAI9gC,GACJ,IAAIA,MAER,IAAA+zC,eAAc/hB,EAAYnkB,GAC1B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAYzE,OAXAh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,YAAa,EACbya,eAAe,EACfxa,eAAe,EACfE,UAAU,GAEdl2E,KAAKyhE,cAActyC,GACnBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GAC/BvqB,GAEXtzC,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,KACvD,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,KAAE4R,GAASomC,GACVse,EAAQC,EAAQ0X,GAAUr8D,EAAK+nD,QAAQxmD,OACxCgiF,EAAev0F,EAASinD,cAAcyO,GACtC8+B,EAAex0F,EAASinD,cAAc0O,GACtCuzC,EAAQ,CACV1pG,MAAO,CACH4B,EAAGmzF,EAAa,GAChBjzF,EAAGizF,EAAa,IAEpBz+E,IAAK,CACD1U,EAAGozF,EAAa,GAChBlzF,EAAGkzF,EAAa,KAIxB,GADwB,mBAA4B,CAAC0U,EAAM1pG,MAAM4B,EAAG8nG,EAAM1pG,MAAM8B,GAAI,CAAC4nG,EAAMpzF,IAAI1U,EAAG8nG,EAAMpzF,IAAIxU,GAAI,CAACy5D,EAAa,GAAIA,EAAa,MACxHC,EACnB,OAAO,EAEX,IAAKqS,EACD,OAAO,EAEX,MAAM87B,EAAenpG,EAASinD,cAAcomB,GACtC+7B,EAAQ,CACV5pG,MAAO,CACH4B,EAAGozF,EAAa,GAChBlzF,EAAGkzF,EAAa,IAEpB1+E,IAAK,CACD1U,EAAG+nG,EAAa,GAChB7nG,EAAG6nG,EAAa,KAIxB,OADyB,mBAA4B,CAACC,EAAM5pG,MAAM4B,EAAGgoG,EAAM5pG,MAAM8B,GAAI,CAAC8nG,EAAMtzF,IAAI1U,EAAGgoG,EAAMtzF,IAAIxU,GAAI,CAACy5D,EAAa,GAAIA,EAAa,MACxHC,GAK5Bl3D,KAAKo3D,qBAAuB,CAAChV,EAAK9O,KAC9B,MAAMviB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB,MAAMgJ,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACA2yB,eAAe,GAEnBxwF,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,GAClB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAEmY,EAAa,SAAEE,GAAal2E,KAAK29D,UACpE,KAAEzwD,GAASomC,EACjB,GAAI0iC,IAAkBE,EAClB,OAEJ,GAAIl2E,KAAKmlG,6BAA8D,IAA/Bj4F,EAAK+nD,QAAQxmD,OAAO7N,OAExD,YADAZ,KAAK29D,SAASoY,YAAc,GAGhC/1E,KAAKmlG,6BAA8B,EACnCj4F,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK09D,kBAAkBvuC,GACvBnvB,KAAK0hE,gBAAgBvyC,IACrB,KAAAyuC,oBAAmBzuC,GACnB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,EACxB0E,KAAKwkF,sBACLxkF,KAAKyM,cAAc23E,4BACnB,IAAA1vB,kBAAiBphB,EAAWqhB,gBAEhC,EAAAoC,EAAA,GAAsC8G,GACtC79D,KAAKsvF,eACDtZ,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,GAErBrhE,KAAKqiD,cAAiBD,IAClBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,YAAEkY,EAAW,cAAEya,EAAa,cAAExa,GAAmBh2E,KAAK29D,UACvF,KAAEzwD,GAASomC,EAEjB,GADAtzC,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBACnCwa,EAAe,CACf,MAAM,YAAEjtC,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,OAC5B,QAAEuhC,GAAY93E,EAAK+nD,SACnB,cAAEgwB,GAAkBD,EAC1BC,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC3L,EAAQ9O,UAAW,CACvB,MACK,QAAoBl4E,IAAhB+3E,EAA2B,CAChC,MAAM,YAAExyB,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,MACnBv2C,EAAK+nD,QAAQxmD,OACrBxN,QAASqN,IACZA,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,KAE9Br9C,EAAW/3C,aAAc,CAC7B,KACK,CACD,MAAM,cAAEyqD,GAAkBj1B,EACpBzP,EAAW0kC,EAAcvC,MAC/Bv2C,EAAK+nD,QAAQxmD,OAAOsnE,GAAe,IAAIz0D,GACvCgyB,EAAW/3C,aAAc,CAC7B,CACAyE,KAAK29D,SAASuY,UAAW,EACzB,MAAM56E,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,GAClCvqB,EAAW/3C,cACX,KAAAi4C,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAY03C,iBAGnEnrF,KAAKiL,OAAUkkB,IACX,GAAInvB,KAAKqhE,UAAW,CAChBrhE,KAAKqhE,WAAY,EACjBrhE,KAAK0hE,gBAAgBvyC,GACrBnvB,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,WAAEmkB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,KAAEzwD,GAASomC,EASjB,OARAA,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,MACjC,EAAAne,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KAChB39D,KAAKmlG,6BAA8B,EAC5B7xD,EAAWqhB,aACtB,GAEJ30D,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,gBAErDriD,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,gBAExDriD,KAAKyhE,cAAiBtyC,IAClB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,gBAErDriD,KAAK0hE,gBAAmBvyC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,gBAExDriD,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACpB,IAAIq4D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAGX,GADAnE,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAAO83D,EAEX,MAAMlyC,EAAWxmB,KAAKszE,YAAYp3E,GAC5Byd,EAAkBzd,EAASiyB,qBAC3B4zC,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6qD,EAAY3zD,OAAQ8I,IAAK,CACzC,MAAM4pC,EAAaihB,EAAY7qD,IACzB,cAAEirD,EAAa,KAAEznD,GAASomC,GAC1B,OAAE7kC,EAAM,kBAAEymE,GAAsBhoE,EAAK+nD,QAC3C8M,EAAepN,cAAgBA,EAC/B,MAAM,MAAEv4D,EAAK,UAAE83D,EAAS,SAAE0H,EAAQ,iBAAE2pC,GAAqBvlG,KAAKiiE,mBAAmB,CAC7E3uB,aACAyuB,mBAEEC,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAWnE,IAAIgoE,EAMJ,GAhBKxpE,EAAKs0D,YAAYh7C,IACkB,MAApCtZ,EAAKs0D,YAAYh7C,GAAU1pB,MAMtBw2C,EAAW/3C,aAChByE,KAAK6wF,+BAA+Bv9C,EAAY35B,EAAiBre,IANjE4R,EAAKs0D,YAAYh7C,GAAY,CACzB1pB,MAAO,MAEXkD,KAAK8wF,sBAAsBx9C,EAAY35B,EAAiBre,KAMvD,KAAAu8D,oBAAmBvkB,EAAWqhB,gBAC9B30D,KAAK29D,UACgB,OAAtBuX,IACAwB,EAA2B,CAAC1U,EAAkBkT,MAE7Ch5E,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,KAAK,KAAAie,qBAAoBhiB,GACrB,SAEJ,MAAMo8B,EAAoB96B,SAAQ,QAAiB,oBAAqB,CAAC,IACzE,GAAIygB,GAA4Bqa,EAAmB,CAC/C,MAAMna,EAAiB,KACvB,IAAA7I,aAAe9V,EAAkBtD,EAAeiiB,EAAgB5U,EAAmB,CAC/E5lE,QACAw/D,WACA1H,aAER,CACA,IAAIuH,EAAU,IAOd,IANA,IAAAC,UAAYzD,EAAkBtD,EAAe8G,EAASuG,EAAkB,GAAIA,EAAkB,GAAI,CAC9F5lE,QACAQ,MAAOs3D,EACP0H,aAEJlD,GAAe,EACkB,IAA7BsJ,EAAkBphE,OAClB,OAAO83D,EAQX,GANA+C,EAAU,KACV,IAAAC,UAAYzD,EAAkBtD,EAAe8G,EAASuG,EAAkB,GAAIA,EAAkB,GAAI,CAC9F5lE,QACAQ,MAAOs3D,EACP0H,aAEA57D,KAAKyM,cAAcw4F,aAAc,CACjC,MAAMruF,EAASorD,EAAkB,GAC3B10D,EAAStN,KAAKyM,cAAcy4F,UAC5Bx/D,EAASzoC,KAAKa,IAAI,mBAA4B,CAAC8Y,EAAO,GAAIA,EAAO,IAAK,CAACorD,EAAkB,GAAG,GAAIA,EAAkB,GAAG,IAAK,CAACA,EAAkB,GAAG,GAAIA,EAAkB,GAAG,KAAM,mBAA4B,CAACprD,EAAO,GAAIA,EAAO,IAAK,CAACorD,EAAkB,GAAG,GAAIA,EAAkB,GAAG,IAAK,CAACA,EAAkB,GAAG,GAAIA,EAAkB,GAAG,MAAQ10D,EAC9Uk4F,EAAc,GACpB,IAAI9sD,EAAaz7C,KAAKk5C,MAAM6rB,EAAkB,GAAG,GAAKprD,EAAO,GAAIorD,EAAkB,GAAG,GAAKprD,EAAO,IAC9F+hC,EAAW17C,KAAKk5C,MAAM6rB,EAAkB,GAAG,GAAKprD,EAAO,GAAIorD,EAAkB,GAAG,GAAKprD,EAAO,IAC5F+hC,EAAWD,IACXC,GAAY,EAAI17C,KAAKC,IAGzB,GADwBy7C,EAAWD,EACbz7C,KAAKC,GAAI,CAC3B,MAAMuoG,EAAO/sD,EACbA,EAAaC,EACbA,EAAW8sD,EAAO,EAAIxoG,KAAKC,EAC/B,CACA,MAAMwoG,EAAW,GACjB,IAAK,IAAIh8F,EAAI,EAAGA,GAAKg8F,EAAUh8F,IAAK,CAChC,MAAM5M,EAAQ47C,EAAchvC,EAAIg8F,GAAa/sD,EAAWD,GACxD8sD,EAAY78F,KAAK,CACbiO,EAAO,GAAK8uB,EAASzoC,KAAKo7F,IAAIv7F,GAC9B8Z,EAAO,GAAK8uB,EAASzoC,KAAKq7F,IAAIx7F,IAEtC,EACA,IAAA0mF,UAAYvrB,EAAkBtD,EAAe,IAAK6wC,EAAa,CAC3DppG,MAAOA,EACPQ,MAAOs3D,EACP0H,SAAU2pC,GAElB,CACA,IAAKr4F,EAAKs0D,YAAYh7C,IAAW1pB,MAC7B,SAEJ,MAAMsH,EAAUpE,KAAKuvF,sBAAsBxtB,EAAgBzuB,GAC3D,IAAKlvC,EAAQurB,WAAY,CACrBziB,EAAK+nD,QAAQ+vB,QAAU,CACnB9O,UAAU,EACV+O,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChB7tD,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB6tD,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM6R,EAAYhxF,KAAKyM,cAAc6jF,aAAapjF,EAAMsZ,GACxD,IAAKtZ,EAAK+nD,QAAQ+vB,QAAQ9O,SAAU,CAChC,MAAM+a,EAAsBjvB,EAAkB,GAC9C90D,EAAK+nD,QAAQ+vB,QAAQC,cACjB/oF,EAASk1B,cAAc6/D,EAC/B,CACA,MAAME,EAAkBj1F,EAASinD,cAAcj2C,EAAK+nD,QAAQ+vB,QAAQC,eAC9DuK,EAAa,IACb4B,GAAc,IAAAC,mBAAqBp5B,EAAkBtD,EAAe66B,EAAYwB,EAAWG,EAAiBnvB,EAAmB,CAAC,EAAG59D,IACjI9G,EAAGilE,EAAM/kE,EAAM,MAAEZ,EAAK,OAAEC,GAAWu0F,EAC3ClkF,EAAK+nD,QAAQ+vB,QAAQE,iBAAmB,CACpChG,QAAShjF,EAASk1B,cAAc,CAACmxC,EAAM5tD,IACvC0c,SAAUn1B,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,IAChD2c,WAAYp1B,EAASk1B,cAAc,CAACmxC,EAAM5tD,EAAM9X,IAChDsiF,YAAajjF,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,EAAM9X,IAEjE,CACA,OAAO67D,GAEX14D,KAAK6wF,gCAAiC,EAAAS,EAAA,GAAStxF,KAAK8wF,sBAAuB,IAAK,CAAES,UAAU,GAChG,QACSvxF,KAAKyvF,QAAU,CAACvgE,EAAYzgB,EAAQrK,KACzC,MAAM9I,GAAiB,IAAAq9E,+BAA8BzpD,GACrD,IAAK5zB,EACD,OAEJ,MAAM,oBAAE0O,EAAmB,kBAAEzD,EAAiB,gBAAEgb,EAAe,SAAEklB,EAAQ,SAAEvqC,GAAc8D,KAAKwxF,YAAYwT,GAAW1pG,EAAgBmT,EAAQrK,IACvI,aAAEo4E,KAAiBiV,GAAwBrtF,GAAW,CAAC,EACvDkvC,EAAa,CACfqhB,cAAevwD,GAASuwD,eAAiB,qBACzCznD,KAAM,CACF+nD,QAAS,CACLxmD,WAGRomD,aAAa,EACb66B,eAAe,EACfn0F,aAAa,EACbmyF,UAAU,EACVC,WAAW,EACXzmF,SAAU,CACN08C,SAAUnd,EAASuuB,cACnBzzC,kBACAvX,sBACAzD,uBACGkrF,KAGX,IAAAp8B,eAAc/hB,EAAYp3C,EAASizB,UACnC,EAAA4nC,EAAA,GAAsC,CAAC76D,EAASmN,KACjD,CACH,sBAAAy1D,CAAuB1c,EAAK9O,EAAYyrB,GACpC,MAAMhuC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,KAAE7jB,GAASomC,EACjBA,EAAWuhB,aAAc,EACzB,IACIkhB,EADAya,GAAgB,EAEhBzxB,EAAOkmB,cACPuL,GAAgB,EAGhBza,EAAc7oE,EAAK+nD,QAAQxmD,OAAO+D,UAAW9D,GAAMA,IAAMqwD,GAE7D,MAAMlB,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,cACAya,iBAEJxwF,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,GAClB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,GACtCzb,EAAIoV,gBACR,CACA,qBAAAs5B,CAAsBx9C,EAAY35B,EAAiBre,GAC/C,MAAM4R,EAAOomC,EAAWpmC,MAClB,QAAEiiB,GAAY7zB,EAAeY,SACnC,GAAmC,IAA/BgR,EAAK+nD,QAAQxmD,OAAO7N,OACpB,OAEJ,MAAMixF,EAAY3kF,EAAK+nD,QAAQxmD,OAAO,GAChCqjF,EAAY5kF,EAAK+nD,QAAQxmD,OAAO,GAChCk3F,EAAYz4F,EAAK+nD,QAAQxmD,OAAO,IAChC,YAAE+yD,GAAgBt0D,EAClB6kF,EAAYnyF,OAAO4B,KAAKggE,GAC9B,IAAK,IAAI93D,EAAI,EAAGA,EAAIqoF,EAAUnxF,OAAQ8I,IAAK,CACvC,MAAM8c,EAAWurE,EAAUroF,GACrB5M,GAAQ,EAAAynE,GAAA,GAAkB,CAACstB,EAAWC,GAAY,CAACA,EAAW6T,KAC9D,WAAE99F,EAAU,UAAE8c,GAAc3kB,KAAKogF,mBAAmB55D,GAC1DxmB,KAAKwkF,qBAAuB,CAACqN,EAAWC,EAAW6T,GAC9Ct/F,IAAKib,GAAa,kCAA8BqD,EAAWrD,IAC3D2H,KAAMzgB,IAAW,kCAA8BA,EAAOX,IAC3D25D,EAAYh7C,GAAY,CACpB1pB,MAAO0f,MAAM1f,GAAS,mBAAqBA,EAEnD,CACA,MAAMvB,EAAc+3C,EAAW/3C,YAK/B,OAJA+3C,EAAW/3C,aAAc,EACrBA,IACA,KAAAi4C,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAYu+C,cAExDxwB,CACX,EAEJ,SAAS,GAAoBt0D,EAAMsZ,GAC/B,MAAMyrE,EAAoB/kF,EAAKs0D,YAAYh7C,IACrC,MAAE1pB,GAAUm1F,EAClB,QAAcj0F,IAAVlB,EACA,OAEJ,GAAI0f,MAAM1f,GACN,MAAO,CAAC,GAAGA,KAKf,MAHkB,CACd,GAAG,wBAAoBA,MAAUsP,OAAOw5F,aAAa,OAG7D,C,gBCxdA,MAAMC,WAAsB,aACf7lG,KAAK4jD,SAAW,WAAa,CACtC,WAAAnkD,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX47D,QAAQ,EACR+b,2BAA2B,EAC3BkM,aAAc,GACdwV,cAAc,KAGlBxkD,MAAMS,EAAWC,GACjBhiD,KAAK2+D,iBAAoBvc,IACrB,GAAIpiD,KAAKmlG,4BACL,OAEJnlG,KAAKmlG,6BAA8B,EACnC,MAAMp0E,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,OAC/B,KAAA8T,mBAAkBpoC,GAClBnvB,KAAKqhE,WAAY,EACjB,MAAM/tB,EAActzC,KAAKmvF,iBAAiB/sC,EAAK,CAC3C,IAAI9gC,GACJ,IAAIA,MAER,IAAA+zC,eAAc/hB,EAAYnkB,GAC1B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAYzE,OAXAh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,YAAa,EACbya,eAAe,EACfxa,eAAe,EACfE,UAAU,GAEdl2E,KAAKyhE,cAActyC,GACnBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GAC/BvqB,GAEXtzC,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,KACvD,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,KAAE4R,GAASomC,GACX,gBAAEyJ,EAAe,iBAAE8zB,GAAqB7wE,KAAK+lG,gBAAgB,CAC/D7pG,WACAuS,OAAQvB,EAAK+nD,QAAQxmD,OACrBwoD,eACAC,cAEJ,OAAIna,GAAmBma,GAAa2Z,GAAoB3Z,GAK5Dl3D,KAAKo3D,qBAAuB,CAAChV,EAAK9O,EAAY+jB,EAAiBJ,EAAcC,EAAY,KACrF,MAAMnmC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB,MAAMgJ,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACnE15D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,EAAe,SAAEzd,GAAaZ,GAChC,gBAAE0qG,EAAe,iBAAEC,GAAqBjmG,KAAK+lG,gBAAgB,CAC/D7pG,WACAuS,OAAQ6kC,EAAWpmC,KAAK+nD,QAAQxmD,OAChCwoD,eACAC,cAEJl3D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACA2yB,eAAe,EACfwV,kBACAC,oBAEJjmG,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,IAClB,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAEmY,EAAa,SAAEE,GAAal2E,KAAK29D,UACpE,KAAEzwD,GAASomC,EACjB,GAAI0iC,IAAkBE,EAClB,OAGJ,GADAl2E,KAAKsvF,eACDtvF,KAAKmlG,6BAA+Bj4F,EAAK+nD,QAAQxmD,OAAO7N,OAAS,EAGjE,OAFA,KAAAg9D,oBAAmBzuC,QACnBnvB,KAAK29D,SAASoY,YAAc7oE,EAAK+nD,QAAQxmD,OAAO7N,QAGpDZ,KAAKmlG,6BAA8B,EACnCj4F,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK09D,kBAAkBvuC,GACvBnvB,KAAK0hE,gBAAgBvyC,IACrB,KAAAyuC,oBAAmBzuC,GACnB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,EACxB0E,KAAKwkF,sBACLxkF,KAAKyM,cAAc23E,4BACnB,IAAA1vB,kBAAiBphB,EAAWqhB,gBAEhC,EAAAoC,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,GAErBrhE,KAAK66F,mBAAsBz4C,IACvB,MAAM,WAAE9O,EAAU,YAAEyiC,GAAgB/1E,KAAK29D,SACnC5sC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,EAAO,cAAE62B,GAAkBj1B,EAC7BzP,EAAW0kC,EAAcvC,OACzB,KAAEv2C,GAASomC,EACjB,OAAoB,IAAhByiC,GACA7oE,EAAK+nD,QAAQxmD,OAAO,GAAK6S,OACzBthB,KAAK29D,SAASuY,SACVhpE,EAAK+nD,QAAQxmD,OAAO,GAAG,KAAOvB,EAAK+nD,QAAQxmD,OAAO,GAAG,IACjDvB,EAAK+nD,QAAQxmD,OAAO,GAAG,KAAOvB,EAAK+nD,QAAQxmD,OAAO,GAAG,KAG7C,IAAhBsnE,GACA7oE,EAAK+nD,QAAQxmD,OAAO,GAAK6S,EACzBthB,KAAK29D,SAASuY,SACVhpE,EAAK+nD,QAAQxmD,OAAO,GAAG,KAAOvB,EAAK+nD,QAAQxmD,OAAO,GAAG,IACjDvB,EAAK+nD,QAAQxmD,OAAO,GAAG,KAAOvB,EAAK+nD,QAAQxmD,OAAO,GAAG,QAC7DzO,KAAKmlG,6BAA8B,KAGvCnlG,KAAK29D,SAASuY,UAAW,GACzB,KAAA3e,mBAAkBpoC,GAClBjiB,EAAK+nD,QAAQxmD,OAAO,GAAKvB,EAAK+nD,QAAQxmD,OAAO,GAAK6S,OAClDthB,KAAK29D,SAASoY,YAAc7oE,EAAK+nD,QAAQxmD,OAAO7N,OAAS,KAE7DZ,KAAKqiD,cAAiBD,IAClBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,YAAEkY,EAAW,cAAEya,EAAa,gBAAEwV,EAAe,iBAAEC,EAAgB,cAAEjwB,GAAmBh2E,KAAK29D,SAChI39D,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBACvC,MAAM,KAAE9oE,GAASomC,EACjB,GAAIk9C,EAAe,CACf,MAAM,YAAEjtC,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,OAC5B,QAAEuhC,GAAY93E,EAAK+nD,SACnB,cAAEgwB,GAAkBD,EAC1BC,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC3L,EAAQ9O,UAAW,CACvB,MACK,QAAoBl4E,IAAhB+3E,IACJiwB,GAAmBC,GAAmB,CACvC,MAAM,YAAE1iD,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,MAC5Bh1C,EAASvB,EAAK+nD,QAAQxmD,OAC5B,GAAIu3F,EAAiB,CACO,CAACv3F,EAAO,GAAIA,EAAO,IAC3BxN,QAASqN,IACrBA,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,IAElC,MACK,GAAIsV,EAAkB,CACE,CAACx3F,EAAO,GAAIA,EAAO,IAC3BxN,QAASqN,IACtBA,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,IAElC,CACAr9C,EAAW/3C,aAAc,CAC7B,KACK,CACD,MAAM,cAAEyqD,GAAkBj1B,EACpBzP,EAAW0kC,EAAcvC,MAC/Bv2C,EAAK+nD,QAAQxmD,OAAOsnE,GAAe,IAAIz0D,GACvCgyB,EAAW/3C,aAAc,CAC7B,CACAyE,KAAK29D,SAASuY,UAAW,EACzB,MAAM56E,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,GAClCvqB,EAAW/3C,cACX,KAAAi4C,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAY03C,iBAGnEnrF,KAAKiL,OAAUkkB,IACX,IAAKnvB,KAAKqhE,UACN,OAEJrhE,KAAKqhE,WAAY,EACjBrhE,KAAK0hE,gBAAgBvyC,GACrBnvB,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,WAAEmkB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,KAAEzwD,GAASomC,EACbpmC,EAAK+nD,QAAQxmD,OAAO7N,OAAS,IAC7B,IAAA8zD,kBAAiBphB,EAAWqhB,eAEhCrhB,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,KACjC,MAAM55E,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,EAO5B,OANA,EAAAy7D,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KAChB39D,KAAKmlG,6BAA8B,EAC5B7xD,EAAWqhB,eAEtB30D,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOy0E,YAAalmG,KAAK66F,oBAClD1rE,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOy0E,YAAalmG,KAAK66F,oBACrD1rE,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKyhE,cAAiBtyC,IAClB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+pE,WAAYx7F,KAAK66F,oBACjD1rE,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOy0E,YAAalmG,KAAK66F,oBAClD1rE,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK0hE,gBAAmBvyC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+pE,WAAYx7F,KAAK66F,oBACpD1rE,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOy0E,YAAalmG,KAAK66F,oBACrD1rE,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACpB,IAAIq4D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAGX,GADAnE,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAAO83D,EAEX,MAAMlyC,EAAWxmB,KAAKszE,YAAYp3E,GAC5Byd,EAAkBzd,EAASiyB,qBAC3B4zC,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6qD,EAAY3zD,OAAQ8I,IAAK,CACzC,MAAM4pC,EAAaihB,EAAY7qD,IACzB,cAAEirD,EAAa,KAAEznD,GAASomC,GAC1B,OAAE7kC,EAAM,kBAAEymE,GAAsBhoE,EAAK+nD,QAC3C8M,EAAepN,cAAgBA,EAC/B,MAAM,MAAEv4D,EAAK,UAAE83D,EAAS,SAAE0H,GAAa57D,KAAKiiE,mBAAmB,CAC3D3uB,aACAyuB,mBAEEC,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IA+BnE,IAAIgoE,EAMJ,GApCKxpE,EAAKs0D,YAAYh7C,IACkB,MAApCtZ,EAAKs0D,YAAYh7C,GAAU1pB,MA0BtBw2C,EAAW/3C,aAChByE,KAAK6wF,+BAA+Bv9C,EAAY35B,EAAiBre,IA1BjE4R,EAAKs0D,YAAYh7C,GAAY,CACzB1pB,MAAO,KACPqpG,UAAW,KACXC,UAAW,KACX33F,OAAQ,CACJg1C,MAAO,CACH4iD,UAAW,KACXC,QAAS,KACTC,UAAW,KACXC,QAAS,KACTL,UAAW,KACXC,UAAW,MAEf3qG,OAAQ,CACJ4qG,UAAW,KACXC,QAAS,KACTC,UAAW,KACXC,QAAS,KACTL,UAAW,KACXC,UAAW,QAIvBpmG,KAAK8wF,sBAAsBx9C,EAAY35B,EAAiBre,KAMvD,KAAAu8D,oBAAmBlD,IACnB30D,KAAK29D,UACgB,OAAtBuX,IACAwB,EAA2B,CAAC1U,EAAkBkT,MAE7Ch5E,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,KAAK,KAAAie,qBAAoBhiB,GACrB,SAEJ,MAAMo8B,EAAoB96B,SAAQ,QAAiB,oBAAqB,CAAC,IACzE,GAAIygB,GAA4Bqa,EAAmB,CAC/C,MAAMna,EAAiB,KACvB,IAAA7I,aAAe9V,EAAkBtD,EAAeiiB,EAAgB5U,EAAmB,CAC/E5lE,QACAw/D,WACA1H,aAER,CACA,MAAMuyC,EAAY,CAACzkC,EAAkB,GAAIA,EAAkB,IACrD0kC,EAAa,CAAC1kC,EAAkB,GAAIA,EAAkB,IAC5D,IAAIvG,EAAU,QAOd,IANA,IAAAC,UAAYzD,EAAkBtD,EAAe8G,EAASgrC,EAAU,GAAIA,EAAU,GAAI,CAC9ErqG,QACAQ,MAAOs3D,EACP0H,aAEJlD,GAAe,EACXsJ,EAAkBphE,OAAS,EAC3B,OAAO83D,EAEX+C,EAAU,SACV,IAAAC,UAAYzD,EAAkBtD,EAAe8G,EAASirC,EAAW,GAAIA,EAAW,GAAI,CAChFtqG,QACAQ,MAAOs3D,EACP0H,aAEJH,EAAU,WACV,MAAMkrC,GAAO,EAAAC,GAAA,GAAUH,EAAU,GAAIA,EAAU,IACzCI,GAAO,EAAAD,GAAA,GAAUF,EAAW,GAAIA,EAAW,KACjD,IAAAhrC,UAAYzD,EAAkBtD,EAAe8G,EAASkrC,EAAME,EAAM,CAC9DzqG,QACA83D,UAAW,IACX0H,SAAU,QAEd,MAAM,UAAEyqC,EAAS,QAAEC,EAAO,QAAEE,EAAO,UAAED,GAAcr5F,EAAKs0D,YAAYh7C,GAAU/X,OAAOhT,QAC/E,UAAE0qG,EAAS,UAAEC,GAAcl5F,EAAKs0D,YAAYh7C,GAalD,GAZIxmB,KAAKyM,cAAcq5F,eACnBrqC,EAAU,QACV,IAAAC,UAAYzD,EAAkBtD,EAAe8G,EAAS4qC,EAAWC,EAAS,CACtElqG,QACA83D,UAAW,MAEfuH,EAAU,QACV,IAAAC,UAAYzD,EAAkBtD,EAAe8G,EAAS8qC,EAAWC,EAAS,CACtEpqG,QACA83D,UAAW,QAGdhnD,EAAKs0D,YAAYh7C,IAAW1pB,MAC7B,SAEJ,MAAMsH,EAAUpE,KAAKuvF,sBAAsBxtB,EAAgBzuB,GAC3D,IAAKlvC,EAAQurB,WAAY,CACrBziB,EAAK+nD,QAAQ+vB,QAAU,CACnB9O,UAAU,EACV+O,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChB7tD,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB6tD,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM6R,EAAYhxF,KAAKyM,cAAc6jF,aAAapjF,EAAMsZ,GACxD,IAAKtZ,EAAK+nD,QAAQ+vB,QAAQ9O,SAAU,CAChC,MAAM+a,GAAsB,IAAAC,wBAAuBlvB,GACnD90D,EAAK+nD,QAAQ+vB,QAAQC,cACjB/oF,EAASk1B,cAAc6/D,EAC/B,CACA,MAAME,EAAkBj1F,EAASinD,cAAcj2C,EAAK+nD,QAAQ+vB,QAAQC,eAC9DuK,EAAa,gBACb4B,GAAc,IAAAC,mBAAqBp5B,EAAkBtD,EAAe66B,EAAYwB,EAAWG,EAAiBnvB,EAAmB,CAAC,EAAG59D,IACjI9G,EAAGilE,EAAM/kE,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWu0F,EAO3C,GANAlkF,EAAK+nD,QAAQ+vB,QAAQE,iBAAmB,CACpChG,QAAShjF,EAASk1B,cAAc,CAACmxC,EAAM5tD,IACvC0c,SAAUn1B,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,IAChD2c,WAAYp1B,EAASk1B,cAAc,CAACmxC,EAAM5tD,EAAM9X,IAChDsiF,YAAajjF,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,EAAM9X,KAEzDmD,KAAKyM,cAAcq5F,aAAc,CACjC,MAAMgB,EAAiB,YACjBC,EAAe,CACjB,GAAGZ,EAAU5oE,QAAQ,MAAMnxB,OAAOw5F,aAAa,QAE7CoB,GAAqB,EAAAJ,GAAA,GAAUP,EAAWC,IAChD,IAAA7c,aAAexxB,EAAkBtD,EAAemyC,EAAgBC,EAAcC,EAAoB,IAC3F5iG,EACH6vE,QAAS,IAEb,MAAMgzB,EAAiB,YACjBC,EAAe,CACjB,GAAGd,EAAU7oE,QAAQ,MAAMnxB,OAAOw5F,aAAa,QAE7CuB,GAAqB,EAAAP,GAAA,GAAUL,EAAWC,IAChD,IAAA/c,aAAexxB,EAAkBtD,EAAesyC,EAAgBC,EAAcC,EAAoB,IAC3F/iG,EACH6vE,QAAS,GAEjB,CACJ,CACA,OAAOvb,GAEX14D,KAAK+lG,gBAAkB,EAAG7pG,WAAUuS,SAAQwoD,eAAcC,gBACtD,MAAOtF,EAAQC,EAAQ0X,EAAQ69B,GAAU34F,EACnCgiF,EAAev0F,EAASinD,cAAcyO,GACtC8+B,EAAex0F,EAASinD,cAAc0O,GACtCwzC,EAAenpG,EAASinD,cAAcomB,GACtC89B,EAAenrG,EAASinD,cAAcikD,GACtChC,EAAQ,CACV1pG,MAAO,CACH4B,EAAGmzF,EAAa,GAChBjzF,EAAGizF,EAAa,IAEpBz+E,IAAK,CACD1U,EAAGozF,EAAa,GAChBlzF,EAAGkzF,EAAa,KAGlB4U,EAAQ,CACV5pG,MAAO,CACH4B,EAAG+nG,EAAa,GAChB7nG,EAAG6nG,EAAa,IAEpBrzF,IAAK,CACD1U,EAAG+pG,EAAa,GAChB7pG,EAAG6pG,EAAa,KAGlBtqD,EAAkB,mBAA4B,CAACqoD,EAAM1pG,MAAM4B,EAAG8nG,EAAM1pG,MAAM8B,GAAI,CAAC4nG,EAAMpzF,IAAI1U,EAAG8nG,EAAMpzF,IAAIxU,GAAI,CAACy5D,EAAa,GAAIA,EAAa,KACzI4Z,EAAmB,mBAA4B,CAACy0B,EAAM5pG,MAAM4B,EAAGgoG,EAAM5pG,MAAM8B,GAAI,CAAC8nG,EAAMtzF,IAAI1U,EAAGgoG,EAAMtzF,IAAIxU,GAAI,CAACy5D,EAAa,GAAIA,EAAa,KAChJ,IAAI+uC,GAAkB,EAClBC,GAAmB,EAOvB,OANIlpD,GAAmBma,EACnB8uC,GAAkB,EAEbn1B,GAAoB3Z,IACzB+uC,GAAmB,GAEhB,CACHlpD,kBACA8zB,mBACAm1B,kBACAC,qBAGRjmG,KAAKsnG,sBAAwB,EAAGb,YAAWC,aAAYC,OAAME,WACzD,MAAMU,EAAW,CAACZ,EAAME,GAClBV,GAAY,EAAA5hC,GAAA,GAAkBkiC,EAAWc,GACzCnB,GAAY,EAAA7hC,GAAA,GAAkBmiC,EAAYa,GAC1CC,EAAWrB,EAAY,GAAK,EAAI,EAChCsB,EAAWrB,EAAY,GAAK,EAAI,EAChCsB,GAAc,EAAAd,GAAA,GAAUW,EAAS,GAAIA,EAAS,IAC9CI,EAAiB1qG,KAAKopC,MAAMkhE,EAAS,GAAG,GAAKA,EAAS,GAAG,KAAO,GACjEA,EAAS,GAAG,GAAKA,EAAS,GAAG,KAAO,GACnC5tE,EAAQ,GACRiuE,GAAe,EAAAhB,GAAA,GAAUH,EAAU,GAAIA,EAAU,IACjDoB,GAAgB,EAAAjB,GAAA,GAAUF,EAAW,GAAIA,EAAW,IACpDoB,EAA2B,CAC7BrB,EAAUe,GAAU,GAAKI,EAAa,GACtCnB,EAAUe,GAAU,GAAKI,EAAa,IAEpCG,EAAqB9qG,KAAKopC,KAAKyhE,EAAyB,IAAM,EAAIA,EAAyB,IAAM,GACjGE,EAA+B,CACjCF,EAAyB,GAAKC,EAC9BD,EAAyB,GAAKC,GAE5B1B,EAAY,CACduB,EAAa,GACTI,EAA6B,GAAKL,EAAiBhuE,EACvDiuE,EAAa,GACTI,EAA6B,GAAKL,EAAiBhuE,GAErDsuE,EAAyB,CAC3BP,EAAY,GAAKf,EAAK,GACtBe,EAAY,GAAKf,EAAK,IAEpBuB,EAAmBjrG,KAAKopC,KAAK4hE,EAAuB,IAAM,EAAIA,EAAuB,IAAM,GAC3FE,EAA6B,CAC/BF,EAAuB,GAAKC,EAC5BD,EAAuB,GAAKC,GAE1B5B,EAAU,CACZK,EAAK,GAAKwB,EAA2B,GAAKR,EAAiBhuE,EAC3DgtE,EAAK,GAAKwB,EAA2B,GAAKR,EAAiBhuE,GAEzDyuE,EAA2B,CAC7B1B,EAAWe,GAAU,GAAKI,EAAc,GACxCnB,EAAWe,GAAU,GAAKI,EAAc,IAEtCQ,EAAqBprG,KAAKopC,KAAK+hE,EAAyB,IAAM,EAAIA,EAAyB,IAAM,GACjGE,EAA+B,CACjCF,EAAyB,GAAKC,EAC9BD,EAAyB,GAAKC,GAE5B9B,EAAY,CACdsB,EAAc,GACVS,EAA6B,GAAKX,EAAiBhuE,EACvDkuE,EAAc,GACVS,EAA6B,GAAKX,EAAiBhuE,GAErD4uE,EAAyB,CAC3Bb,EAAY,GAAKb,EAAK,GACtBa,EAAY,GAAKb,EAAK,IAEpB2B,EAAmBvrG,KAAKopC,KAAKkiE,EAAuB,IAAM,EAAIA,EAAuB,IAAM,GAC3FE,EAA6B,CAC/BF,EAAuB,GAAKC,EAC5BD,EAAuB,GAAKC,GAMhC,MAAO,CACHnC,YACAC,UACAC,YACAC,QARY,CACZK,EAAK,GAAK4B,EAA2B,GAAKd,EAAiBhuE,EAC3DktE,EAAK,GAAK4B,EAA2B,GAAKd,EAAiBhuE,GAO3DwsE,UAAWA,EAAY,GAAK,IAAMA,EAAYA,EAC9CC,UAAWA,EAAY,GAAK,IAAMA,EAAYA,IAGtDpmG,KAAK6wF,gCAAiC,EAAAS,EAAA,GAAStxF,KAAK8wF,sBAAuB,GAAI,CAAES,UAAU,GAC/F,CACA,sBAAAzyB,CAAuB1c,EAAK9O,EAAYyrB,EAAQ1H,EAAkB,SAC9D,MAAMtmC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,KAAE7jB,GAASomC,EACjBA,EAAWuhB,aAAc,EACzB,IACIkhB,EADAya,GAAgB,EAEhBzxB,EAAOkmB,cACPuL,GAAgB,EAGhBza,EAAc7oE,EAAK+nD,QAAQxmD,OAAO+D,UAAW9D,GAAMA,IAAMqwD,GAE7D,MAAMlB,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,cACAya,iBAEJxwF,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,IAClB,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,gBACR,CACA,qBAAAs5B,CAAsBx9C,EAAY35B,EAAiBre,GAC/C,MAAM4R,EAAOomC,EAAWpmC,KACxB,GAAmC,IAA/BA,EAAK+nD,QAAQxmD,OAAO7N,OACpB,OAEJ,MAAM8nG,EAAO,CAAC,KAAM,MACdC,EAAO,CAAC,KAAM,MACpB,IAAIC,EAAU58F,OAAO68F,UACrB,IAAK,IAAIn/F,EAAI,EAAGA,EAAI,EAAGA,GAAK,EACxB,IAAK,IAAIuI,EAAI,EAAGA,EAAI,EAAGA,GAAK,EAAG,CAC3B,MAAMurE,EAAO,cAActwE,EAAK+nD,QAAQxmD,OAAO/E,GAAIwD,EAAK+nD,QAAQxmD,OAAOwD,IACnEurE,EAAOorB,IACPA,EAAUprB,EACVkrB,EAAK,GAAKx7F,EAAK+nD,QAAQxmD,OAAO/E,GAC9Bg/F,EAAK,GAAKx7F,EAAK+nD,QAAQxmD,QAAQ/E,EAAI,GAAK,GACxCi/F,EAAK,GAAKz7F,EAAK+nD,QAAQxmD,OAAOwD,GAC9B02F,EAAK,GAAKz7F,EAAK+nD,QAAQxmD,OAAO,GAAMwD,EAAI,GAAK,GAErD,CAEJ,MAAM,SAAE/V,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACdinF,EAAej2E,EAAK+nD,QAAQxmD,OAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IACrE+3F,EAAY,CAACtjB,EAAa,GAAIA,EAAa,IAC3CujB,EAAa,CAACvjB,EAAa,GAAIA,EAAa,IAC5CwjB,GAAO,EAAAC,GAAA,GAAUH,EAAU,GAAIA,EAAU,IACzCI,GAAO,EAAAD,GAAA,GAAUF,EAAW,GAAIA,EAAW,KAC3C,UAAEL,EAAS,QAAEC,EAAO,QAAEE,EAAO,UAAED,EAAS,UAAEJ,EAAS,UAAEC,GAAcpmG,KAAKsnG,sBAAsB,CAChGb,YACAC,aACAC,OACAE,UAEE,YAAErlC,GAAgBt0D,EAClB6kF,EAAYnyF,OAAO4B,KAAKggE,GAC9B,IAAK,IAAI93D,EAAI,EAAGA,EAAIqoF,EAAUnxF,OAAQ8I,IAAK,CAEvC83D,EADiBuwB,EAAUroF,IACH,CACpB5M,OAAO,EAAAynE,GAAA,GAAkBmkC,EAAMC,GAC/BxC,YACAC,YACA33F,OAAQ,CACJhT,OAAQ,CACJ4qG,YACAC,UACAE,UACAD,aAEJ9iD,MAAO,CACH4iD,UAAWnqG,EAASk1B,cAAci1E,GAClCC,QAASpqG,EAASk1B,cAAck1E,GAChCE,QAAStqG,EAASk1B,cAAco1E,GAChCD,UAAWrqG,EAASk1B,cAAcm1E,KAIlD,CACA,MAAMhrG,EAAc+3C,EAAW/3C,YAK/B,OAJA+3C,EAAW/3C,aAAc,EACrBA,IACA,KAAAi4C,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAYu+C,cAExDxwB,CACX,EAEJ,SAAS,GAAoBt0D,EAAMsZ,GAC/B,MAAMyrE,EAAoB/kF,EAAKs0D,YAAYh7C,IACrC,MAAE1pB,GAAUm1F,EAClB,QAAcj0F,IAAVlB,EACA,OAGJ,MADkB,CAAC,GAAGA,EAAMygC,QAAQ,MAAMnxB,OAAOw5F,aAAa,OAElE,CACA,MCzpBQlhE,sBAAqB,IAAK,YAClC,MAAMokE,WAAkC,aAC3B9oG,KAAK4jD,SAAW,2BAA6B,CACtD,WAAAnkD,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX47D,QAAQ,EACR+b,2BAA2B,EAC3BkM,aAAc,GACdyY,0BAA0B,KAG9BznD,MAAMS,EAAWC,GACjBhiD,KAAK2+D,iBAAoBvc,IACrB,GAAIpiD,KAAKgpG,eACL,OAEJhpG,KAAKgpG,gBAAiB,EACtB,MAAMj4E,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,MACzBnoD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACrB,KAAMY,aAAoB,EAAA8+B,eACtB,MAAM,IAAI58B,MAAM,kEAEpB,KAAAm5D,mBAAkBpoC,GAClBnvB,KAAKqhE,WAAY,EACjB,MAAM/tB,EAActzC,KAAKmvF,iBAAiB/sC,EAAK,CAC3C,IAAI9gC,GACJ,IAAIA,MAER,IAAA+zC,eAAc/hB,EAAYnkB,GAC1B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAYzE,OAXAh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,YAAa,EACbya,eAAe,EACfxa,eAAe,EACfE,UAAU,GAEdl2E,KAAKyhE,cAActyC,GACnBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GAC/BvqB,GAEXtzC,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,KACvD,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,KAAE4R,GAASomC,GACVse,EAAQC,GAAU3kD,EAAK+nD,QAAQxmD,OAChCgiF,EAAev0F,EAASinD,cAAcyO,GACtC8+B,EAAex0F,EAASinD,cAAc0O,GACtC8I,EAAO,CACTj/D,MAAO,CACH4B,EAAGmzF,EAAa,GAChBjzF,EAAGizF,EAAa,IAEpBz+E,IAAK,CACD1U,EAAGozF,EAAa,GAChBlzF,EAAGkzF,EAAa,KAIxB,OADwB,EAAAl2C,YAAA,gBAA4B,CAACmgB,EAAKj/D,MAAM4B,EAAGq9D,EAAKj/D,MAAM8B,GAAI,CAACm9D,EAAK3oD,IAAI1U,EAAGq9D,EAAK3oD,IAAIxU,GAAI,CAACy5D,EAAa,GAAIA,EAAa,MACpHC,GAK3Bl3D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAEmY,EAAa,SAAEE,GAAal2E,KAAK29D,UACpE,KAAEzwD,GAASomC,EACjB,GAAI0iC,IAAkBE,EAClB,OAEJ,GAAIl2E,KAAKgpG,gBAAiD,IAA/B97F,EAAK+nD,QAAQxmD,OAAO7N,OAE3C,YADAZ,KAAK29D,SAASoY,YAAc,GAGhC/1E,KAAKgpG,gBAAiB,EACtB97F,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK09D,kBAAkBvuC,GACvBnvB,KAAK0hE,gBAAgBvyC,IACrB,KAAAyuC,oBAAmBzuC,GACnB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,EACxB0E,KAAKwkF,sBACLxkF,KAAKyM,cAAc23E,4BACnB,IAAA1vB,kBAAiBphB,EAAWqhB,gBAEhC,EAAAoC,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,GAErBrhE,KAAKqiD,cAAiBD,IAClBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,YAAEkY,EAAW,cAAEya,GAAkBxwF,KAAK29D,UACvE,KAAEzwD,GAASomC,EACjB,GAAIk9C,EAAe,CACf,MAAM,YAAEjtC,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,OAC5B,QAAEuhC,GAAY93E,EAAK+nD,SACnB,cAAEgwB,GAAkBD,EAC1BC,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC3L,EAAQ9O,UAAW,CACvB,MACK,QAAoBl4E,IAAhB+3E,EAA2B,CAChC,MAAM,YAAExyB,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,MACnBv2C,EAAK+nD,QAAQxmD,OACrBxN,QAASqN,IACZA,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,KAE9Br9C,EAAW/3C,aAAc,CAC7B,KACK,CACD,MAAM,cAAEyqD,GAAkBj1B,EACpBzP,EAAW0kC,EAAcvC,MAC/Bv2C,EAAK+nD,QAAQxmD,OAAOsnE,GAAe,IAAIz0D,GACvCgyB,EAAW/3C,aAAc,CAC7B,CACAyE,KAAK29D,SAASuY,UAAW,EACzB,MAAM56E,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,IAE1C79D,KAAKiL,OAAUkkB,IACX,GAAInvB,KAAKqhE,UAAW,CAChBrhE,KAAKqhE,WAAY,EACjBrhE,KAAK0hE,gBAAgBvyC,GACrBnvB,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,WAAEmkB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,KAAEzwD,GAASomC,EASjB,OARAA,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,MACjC,EAAAne,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KAChB39D,KAAKgpG,gBAAiB,EACf11D,EAAWqhB,aACtB,GAEJ30D,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,gBAErDriD,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,gBAExDriD,KAAKyhE,cAAiBtyC,IAClB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,gBAErDriD,KAAK0hE,gBAAmBvyC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,gBAExDriD,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACpB,IAAIq4D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAGX,GADAnE,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAAO83D,EAEX,MAAMlyC,EAAWxmB,KAAKszE,YAAYp3E,GAC5Byd,EAAkBzd,EAASiyB,qBAC3B4zC,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6qD,EAAY3zD,OAAQ8I,IAAK,CACzC,MAAM4pC,EAAaihB,EAAY7qD,IACzB,cAAEirD,EAAa,KAAEznD,GAASomC,GAC1B,OAAE7kC,GAAWvB,EAAK+nD,QACxB8M,EAAepN,cAAgBA,EAC/B,MAAMv4D,EAAQ4D,KAAKy2E,SAAS,QAAS1U,EAAgBzuB,GAC/C0uB,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAenE,GAdKxB,EAAKs0D,YAAYh7C,IACoB,MAAtCtZ,EAAKs0D,YAAYh7C,GAAUyiF,QAUtB31D,EAAW/3C,aAChByE,KAAK6wF,+BAA+Bv9C,EAAY35B,EAAiBre,IAVjE4R,EAAKs0D,YAAYh7C,GAAY,CACzByiF,QAAS,CAAC,EAAG,GACbC,QAAS,CAAC,EAAG,GACbC,cAAc,EACdzV,MAAO,CAAC,IACR0V,YAAY,GAEhBppG,KAAK8wF,sBAAsBx9C,EAAY35B,EAAiBre,KAKvDY,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,IAAIke,EAAiB,IAKrB,IAJA,IAAAyyB,YAAcpxC,EAAkBtD,EAAeiiB,EAAgB5U,EAAkB,GAAI,CACjF5lE,SACD,GACHs8D,GAAe,EACkB,IAA7BsJ,EAAkBphE,OAClB,OAAO83D,EAEXke,EAAiB,KACjB,IAAAyyB,YAAcpxC,EAAkBtD,EAAeiiB,EAAgB5U,EAAkB,GAAI,CACjF5lE,SACD,GAEH,GADmB8Q,EAAKs0D,YAAYh7C,GAAU4iF,WAoCzC,CACD,MAAMlnC,EAAS,GAAGvN,WACZ8G,EAAU,KAChB,IAAAC,UAAYzD,EAAkBtD,EAAe8G,EAASuG,EAAkB,GAAIA,EAAkB,GAAI,CAC9F5lE,QACAQ,MAAO,EACPyrE,OAAQroE,KAAKyM,cAAc47D,QAC5BnG,EACP,KA3CiB,CACb,MAAMuuB,EAAezuB,EAAkB,GACjC0uB,EAAe1uB,EAAkB,GACjCsnC,EAAe5Y,EAAa,GAAKD,EAAa,GAC9C8Y,EAAe7Y,EAAa,GAAKD,EAAa,GAEpD,IAAI+Y,EAAuB,CAAC,EAAG,GAE3BA,EAHiBt8F,EAAKs0D,YAAYh7C,GAAU2iF,aAGrB,CACnB1Y,EAAa,GAAK8Y,EAClB9Y,EAAa,IAIM,CACnBA,EAAa,GACbA,EAAa,GAAK6Y,GAG1B,IAAIpnC,EAAS,GAAGvN,WACZ8G,EAAU,KACd,IAAAC,UAAYzD,EAAkBtD,EAAe8G,EAASuG,EAAkB,GAAIwnC,EAAsB,CAC9FptG,QACAQ,MAAO,EACPyrE,OAAQroE,KAAKyM,cAAc47D,QAC5BnG,GACHA,EAAS,GAAGvN,WACZ8G,EAAU,KACV,IAAAC,UAAYzD,EAAkBtD,EAAe8G,EAASuG,EAAkB,GAAIwnC,EAAsB,CAC9FptG,QACAQ,MAAO,EACPg/D,SAAU,CAAC,EAAG,GACdyM,OAAQroE,KAAKyM,cAAc47D,QAC5BnG,EACP,CAUA,MAAM99D,EAAUpE,KAAKuvF,sBAAsBxtB,EAAgBzuB,GAC3D,IAAKlvC,EAAQurB,WAAY,CACrBziB,EAAK+nD,QAAQ+vB,QAAU,CACnB9O,UAAU,EACV+O,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChB7tD,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB6tD,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM6R,EAAYhxF,KAAKyM,cAAc6jF,aAAapjF,EAAMsZ,EAAUxmB,KAAKyM,eACvE,IAAKS,EAAK+nD,QAAQ+vB,QAAQ9O,SAAU,CAChC,MAAM+a,EAAsBjvB,EAAkB,GAC9C90D,EAAK+nD,QAAQ+vB,QAAQC,cACjB/oF,EAASk1B,cAAc6/D,EAC/B,CACA,MAAME,EAAkBj1F,EAASinD,cAAcj2C,EAAK+nD,QAAQ+vB,QAAQC,eAC9DuK,EAAa,IACb4B,GAAc,IAAAC,mBAAqBp5B,EAAkBtD,EAAe66B,EAAYwB,EAAWG,EAAiBnvB,EAAmB,CAAC,EAAG59D,IACjI9G,EAAGilE,EAAM/kE,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWu0F,EAC3ClkF,EAAK+nD,QAAQ+vB,QAAQE,iBAAmB,CACpChG,QAAShjF,EAASk1B,cAAc,CAACmxC,EAAM5tD,IACvC0c,SAAUn1B,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,IAChD2c,WAAYp1B,EAASk1B,cAAc,CAACmxC,EAAM5tD,EAAM9X,IAChDsiF,YAAajjF,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,EAAM9X,IAEjE,CACA,OAAO67D,GAEX14D,KAAK6wF,gCAAiC,EAAAS,EAAA,GAAStxF,KAAK8wF,sBAAuB,IAAK,CAAES,UAAU,GAChG,CACA,oBAAAn6B,CAAqBhV,EAAK9O,EAAY+jB,EAAiBJ,GAEvD,CACA,sBAAA6H,CAAuB1c,EAAK9O,EAAYyrB,GACpC,MAAMhuC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,KAAE7jB,GAASomC,EACjBA,EAAWuhB,aAAc,EACzB,MAAMgJ,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzE,IACI+gB,EADAya,GAAgB,EAEhBzxB,EAAOkmB,cACPuL,GAAgB,EAGhBza,EAAc7oE,EAAK+nD,QAAQxmD,OAAO+D,UAAW9D,GAAMA,IAAMqwD,GAE7D/+D,KAAK29D,SAAW,CACZoY,cACAziC,aACAuqB,uBAEJ79D,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,GAClB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,GAAoBre,GAC5B,EAAAy7D,EAAA,GAAsC8G,GACtCzb,EAAIoV,gBACR,CACA,qBAAAs5B,CAAsBx9C,EAAY35B,EAAiBre,GAC/C,MAAM4R,EAAOomC,EAAWpmC,MAClB,QAAEiiB,GAAY7zB,EAAeY,SACnC,GAAmC,IAA/BgR,EAAK+nD,QAAQxmD,OAAO7N,OACpB,OAEJ,MAAM,YAAE4gE,GAAgBt0D,EAClB6kF,EAAYnyF,OAAO4B,KAAKggE,GAC9B,IAAK,IAAI93D,EAAI,EAAGA,EAAIqoF,EAAUnxF,OAAQ8I,IAAK,CACvC,MAAM8c,EAAWurE,EAAUroF,GACrBlO,EAAQwE,KAAKogF,mBAAmB55D,GACtC,IAAKhrB,EACD,SAEJ,MAAM,UAAEmpB,GAAcnpB,EAChBq2F,EAAY3kF,EAAK+nD,QAAQxmD,OAAO,GAChCqjF,EAAY5kF,EAAK+nD,QAAQxmD,OAAO,GAChCg7F,EAAc,GAAsB9kF,EAAWktE,GAC/C6X,EAAc,GAAsB/kF,EAAWmtE,IAC7Cn3E,OAAQgvF,EAASjW,MAAOkW,IAAW,QAAgCpuG,EAAO,CAACiuG,KAC3E9uF,OAAQkvF,EAASnW,MAAOoW,IAAW,QAAgCtuG,EAAO,CAACkuG,IACnF,IAAIT,EAASC,EAASxV,EAAOyV,EACzBC,GAAa,EACjB,GAAIQ,EAAO,KAAOE,EAAO,IACrBF,EAAO,KAAOE,EAAO,IACN,QAAdF,EAAO,IAA8B,QAAdE,EAAO,GAAe,CAC9C,MAAM7pG,GAAQ,KAAA88C,iBAAgB80C,EAAWC,GACzCmX,EAAU,CAAChpG,EAAO,GAClBipG,EAAU,CAACjpG,EAAO,GAClByzF,EAAQ,CAAC,MACT0V,GAAa,CACjB,KACK,CACD,MAAM3Y,EAAen1F,EAAeY,SAASinD,cAAc0uC,GACrDnB,EAAep1F,EAAeY,SAASinD,cAAc2uC,GACrDwX,EAAe5Y,EAAa,GAAKD,EAAa,GAC9C8Y,EAAe7Y,EAAa,GAAKD,EAAa,GACpD0Y,EAAelsG,KAAK6e,IAAIytF,GAAgBtsG,KAAK6e,IAAIwtF,GACjDL,EAAU,CAACU,EAAQ,GAAIE,EAAQ,IAC/BX,EAAU,CAACS,EAAQ,GAAIE,EAAQ,IAC/BnW,EAAQ,CAACkW,EAAO,GAAIA,EAAO,GAC/B,CACApoC,EAAYh7C,GAAY,CACpByiF,UACAC,UACAC,eACAzV,QACA0V,aAER,CACA,MAAM7tG,EAAc+3C,EAAW/3C,YAK/B,OAJA+3C,EAAW/3C,aAAc,EACrBA,IACA,KAAAi4C,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAYu+C,cAExDxwB,CACX,EAEJ,SAAS,GAAoBt0D,EAAMsZ,EAAU/Z,GACzC,MAAM+0D,EAAct0D,EAAKs0D,YAAYh7C,IAC/B,QAAEyiF,EAAO,QAAEC,EAAO,MAAExV,EAAK,WAAE0V,EAAU,aAAED,GAAiB3nC,EAC9D,GAAI4nC,EACA,MAAO,CAAC,GAAG,wBAAoBH,EAAQ,UAE3C,GAAIx8F,EAAcs8F,yBAA0B,CACxC,MAAMgB,EAAQ9sG,KAAK6e,IAAImtF,EAAQ,GAAKA,EAAQ,IACtCe,EAAQ/sG,KAAK6e,IAAIotF,EAAQ,GAAKA,EAAQ,IAC5C,MAAO,CACH,GAAG,wBAAoBa,MAAUrW,EAAM,KACvC,GAAG,wBAAoBsW,MAAUtW,EAAM,KAE/C,CACA,GAAIyV,EAAc,CACd,MAAM3rB,EAAOvgF,KAAK6e,IAAImtF,EAAQ,GAAKA,EAAQ,IAC3C,MAAO,CAAC,GAAG,wBAAoBzrB,MAASkW,EAAM,KAClD,CACK,CACD,MAAMlW,EAAOvgF,KAAK6e,IAAIotF,EAAQ,GAAKA,EAAQ,IAC3C,MAAO,CAAC,GAAG,wBAAoB1rB,MAASkW,EAAM,KAClD,CACJ,C,gBCvbA,MAAM,sBAAE3vD,IAA0B,EAAAiN,UAClC,MAAMi5D,WAAkC,aAC3BjqG,KAAK4jD,SAAW,2BAA6B,QAC7C5jD,KAAKkqG,4BAA8B,CACxCC,MAAO,QACPC,OAAQ,SACT,CACH,WAAA3qG,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX23E,2BAA2B,EAC3BkM,aAAc,GACd15E,OAAQ,KACRsiC,YAAa,KACbC,YAAa,KACbT,WAAY,KACZC,SAAU,KACV0xD,WAAY,mBACZC,YAAa,iBACbC,gBAAgB,EAChBC,YAAa,GACbC,gBAAiB,mBACjBC,oBAAqB,EACrBC,qBAAsB,GACtBC,kBAAmB,GACnBC,kBAAmB,GACnBC,WAAY,GACZC,oBAAoB,EACpBC,yBAA0B,KAC1B92B,QAAS,CACL9/C,KAAM,CACFggD,OAAQ,OACRC,SAAU,CAAC,CAAEl0E,IAAK,OAEtB+0B,KAAM,CACFk/C,OAAQ,OACRC,SAAU,CAAC,CAAEl0E,IAAK,WAK9BmhD,MAAMS,EAAWC,GACjBhiD,KAAKirG,kBAAoB,GACzBjrG,KAAKkrG,iBAAmB,GACxBlrG,KAAK2+D,iBAAoBvc,IACrB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,MACzBnoD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACrB,KAAAi8D,mBAAkBpoC,GAClBnvB,KAAKqhE,WAAY,EACjB,MAAM,gBAAE9/C,EAAe,OAAEyjB,EAAQpV,SAAUklC,GAAoB54D,EAASumB,YAClElc,EAAoBvG,KAAKshE,qBAAqBplE,EAAUolB,EAAUC,EAAiByjB,GACnFsO,EAAa,CACfuhB,aAAa,EACbt5D,aAAa,EACb2L,SAAU,IACHhL,EAASkgC,iBAAiB,CAAE3tB,OAAQ,CAAC6S,KACxCsiC,SAAU5jD,KAAKg1D,cACfzuD,oBACAy+B,SACA8vB,kBAEJ5nD,KAAM,CACF+nD,QAAS,CACLxmD,OAAQ,CAAC,IAAI6S,GAAW,IAAIA,IAC5B4zD,kBAAmB,MAEvBi2B,eAAgBnrG,KAAKorG,0BACrBx3E,MAAO,MAGf,IAAAyhC,eAAc/hB,EAAYnkB,GAC1B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAYzE,OAXAh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,YAAa,EACbya,eAAe,EACfxa,eAAe,EACfE,UAAU,GAEdl2E,KAAKyhE,cAActyC,GACnBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GAC/BvqB,GAEXtzC,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,KACvD,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,KAAE4R,GAASomC,GACVse,EAAQC,GAAU3kD,EAAK+nD,QAAQxmD,OAChCgiF,EAAev0F,EAASinD,cAAcyO,GACtC8+B,EAAex0F,EAASinD,cAAc0O,GACtC8I,EAAO,CACTj/D,MAAO,CACH4B,EAAGmzF,EAAa,GAChBjzF,EAAGizF,EAAa,IAEpBz+E,IAAK,CACD1U,EAAGozF,EAAa,GAChBlzF,EAAGkzF,EAAa,KAIxB,OADwB,mBAA4B,CAAC/1B,EAAKj/D,MAAM4B,EAAGq9D,EAAKj/D,MAAM8B,GAAI,CAACm9D,EAAK3oD,IAAI1U,EAAGq9D,EAAK3oD,IAAIxU,GAAI,CAACy5D,EAAa,GAAIA,EAAa,MACpHC,GAK3Bl3D,KAAKo3D,qBAAuB,CAAChV,EAAK9O,KAC9B,MAAMviB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB,MAAMgJ,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACA2yB,eAAe,GAEnBxwF,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,IAClB,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,kBAERx3D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAEmY,EAAa,SAAEE,GAAal2E,KAAK29D,UACpE,KAAEzwD,GAASomC,EACb0iC,IAAkBE,IAGtBhpE,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK09D,kBAAkBvuC,GACvBnvB,KAAK0hE,gBAAgBvyC,IACrB,KAAAyuC,oBAAmBzuC,GACfnvB,KAAKwkF,sBACLxkF,KAAKyM,cAAc23E,4BACnB,IAAA1vB,kBAAiBphB,EAAWqhB,gBAEhC,EAAAoC,EAAA,GAAsC8G,GACtC79D,KAAKsvF,eACDtZ,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,IAErBrhE,KAAKqiD,cAAiBD,IAClBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,SAAE70B,IAAa,IAAA6+B,mBAAkB5L,IAAY,CAAC,EACpD,IAAKjzB,EACD,OAEJ,MAAM,WAAEo3C,EAAU,oBAAEuqB,EAAmB,YAAEkY,EAAW,cAAEya,EAAa,cAAExa,GAAmBh2E,KAAK29D,UACvF,KAAEzwD,GAASomC,EAEjB,GADAtzC,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBACnCwa,EAAe,CACf,MAAM,YAAEjtC,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,OAC5B,QAAEuhC,GAAY93E,EAAK+nD,SACnB,cAAEgwB,GAAkBD,EAC1BC,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC1L,EAAc,IAAM0L,EAAc,GAClC3L,EAAQ9O,UAAW,CACvB,MACK,QAAoBl4E,IAAhB+3E,EAA2B,CAChC,MAAM,YAAExyB,GAAgBxyB,EAClB4/D,EAAgBptC,EAAYE,MAC5Bh1C,EAASvB,EAAK+nD,QAAQxmD,OACtB48F,EAAuB58F,EAAO8f,MAAOjgB,IACvC,MAAMg9F,EAAW,CACbh9F,EAAM,GAAKqiF,EAAc,GACzBriF,EAAM,GAAKqiF,EAAc,GACzBriF,EAAM,GAAKqiF,EAAc,IAE7B,OAAO3wF,KAAKurG,iBAAiBrvG,EAAUovG,KAEvCD,IACA58F,EAAOxN,QAASqN,IACZA,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,KAE9Br9C,EAAW/3C,aAAc,EAEjC,KACK,CACD,MAAM,cAAEyqD,GAAkBj1B,EACpBzP,EAAW0kC,EAAcvC,MAC3BzjD,KAAKurG,iBAAiBrvG,EAAUolB,KAChCpU,EAAK+nD,QAAQxmD,OAAOsnE,GAAe,IAAIz0D,GACvCgyB,EAAW/3C,aAAc,EAEjC,CACAyE,KAAK29D,SAASuY,UAAW,GACzB,EAAAnf,EAAA,GAAsC8G,GAClCvqB,EAAW/3C,cACX,KAAAi4C,2BAA0BF,EAAYnkB,EAAS,EAAAskB,YAAY03C,iBAGnEnrF,KAAKiL,OAAUkkB,IACX,GAAInvB,KAAKqhE,UAAW,CAChBrhE,KAAKqhE,WAAY,EACjBrhE,KAAK0hE,gBAAgBvyC,GACrBnvB,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,WAAEmkB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,KAAEzwD,GAASomC,EAQjB,OAPAA,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,MACjC,EAAAne,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KACTrqB,EAAWqhB,aACtB,GAEJ30D,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKyhE,cAAiBtyC,IAClB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK0hE,gBAAmBvyC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACpB,IAAK8D,KAAKwrG,8BAA8BtvG,GACpC,OAEJ,MAAM,UAAEyoB,GAAczoB,EAASq8B,gBAAkB,CAAC,EAClD,IAAK5T,EACD,OAAO+zC,EAEP14D,KAAKyM,cAAc89F,gBACnBvqG,KAAKuqG,eAAetyC,EAAkB/7D,GAE1C,IAAIq4D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAGX,GADAnE,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAAO83D,EAEM14D,KAAKszE,YAAYp3E,GACVA,EAASiyB,qBADjC,MAEM4zC,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAElCoiG,EAAYvvG,EAASinD,cAAcpf,GAAsBpf,EAAW3kB,KAAKyM,cAAcmK,SACvF80F,EAAqB1rG,KAAK2rG,sBAAsBzvG,GAChDg9C,EAAcl5C,KAAKyM,cAAcysC,YAAcwyD,EAC/CvyD,EAAcn5C,KAAKyM,cAAc0sC,YAAcuyD,EAC/CxpE,EAAiBhmC,EAASimC,oBAC1BypE,EAA0Br3C,EAC3Bz/C,OAAQw+B,GAAeA,EAAWpmC,KAAKi+F,iBACxClB,GAA0BC,4BAA4BE,QACtD92D,EAAWpsC,SAASX,oBAAsB27B,GACzC77B,IAAKitC,IACN,MAAM0uB,EAAoB1uB,EAAWpmC,KAAK+nD,QAAQxmD,OAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAE3F,OADiB,SAAmB+8F,EAAWzpC,KAG7C6pC,GAAwB,SAAeD,GACvCE,EAA2B,GAC3BC,EAA0B,GAC1BC,EAAkB14D,IACpB,MAAM,cAAEqhB,EAAa,KAAEznD,GAASomC,GAC1B,OAAE7kC,EAAM,kBAAEymE,GAAsBhoE,EAAK+nD,QAC3C8M,EAAepN,cAAgBA,EAC/B,MAAM,MAAEv4D,EAAK,UAAE83D,EAAS,SAAE0H,EAAQ,OAAEyM,GAAWroE,KAAKiiE,mBAAmB,CACnE3uB,aACAyuB,mBAEEC,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IACnE,IAAKxS,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,IAAIge,EACJ,KAAK,KAAAC,qBAAoBhiB,GACrB,OAOJ,IALK,KAAAkD,oBAAmBlD,IACnB30D,KAAK29D,UACgB,OAAtBuX,IACAwB,EAA2B,CAAC1U,EAAkBkT,KAE9CwB,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAA7I,aAAe9V,EAAkBtD,EAAeiiB,EAAgB5U,EAAmB,CAC/E5lE,MAAO4D,KAAKisG,oBAAoB34D,GAChCxhC,KAAM9R,KAAKisG,oBAAoB34D,GAC/BsoB,WACA1H,aAER,CACA,MAAMgO,EAAS,GAAGvN,SAQlB,IANA,IAAA+G,UAAYzD,EAAkBtD,EADd,IACsCqN,EAAkB,GAAIA,EAAkB,GAAI,CAC9F5lE,MAAO4D,KAAKisG,oBAAoB34D,GAChC12C,MAAOs3D,EACP0H,WACAyM,UACDnG,GACCliE,KAAKyM,cAAcs+F,mBAAoB,CACvC,MAAMmB,GAAe,SAAmBT,EAAWzpC,GACnD,IAAImqC,EAAY,EAChB,GAAI74D,EAAWpmC,KAAKi+F,iBAChBlB,GAA0BC,4BAA4BC,MAAO,EAClC,SAAkB4B,EAAyBG,GACnDjrG,QAASmrG,KACC,SAAaA,EAAUP,GAC/B5qG,QAASorG,IACtBF,IACA,MACMG,EAAY,GAAG33C,SADJw3C,IAEXI,EAAS,KAFEJ,KAGjB,IAAAK,SAAWv0C,EAAkBtD,EAAe43C,EAAQd,EAAWvyD,EAAaC,EAAakzD,EAAgB,GAAIA,EAAgB,GAAI,CAC7HjwG,MAAO,cACP0V,KAAM9R,KAAKisG,oBAAoB34D,GAC/B+vC,YAAarjF,KAAKyM,cAAcq+F,WAChCluG,MAAOs3D,EACP0H,WACAyM,UACDikC,EAAW,IACdP,EAAwBpjG,KAAK0jG,MAGzC,MACK,GAAI/4D,EAAWpmC,KAAKi+F,iBACrBlB,GAA0BC,4BAA4BE,OAAQ,EACnC,SAAkB0B,EAA0BI,GACpDjrG,QAAQ,CAACmrG,EAAU5jG,KAClC2jG,IACA,MACMG,EAAY,GAAG33C,SADJw3C,IAEXI,EAAS,KAFEJ,KAGjB,IAAAK,SAAWv0C,EAAkBtD,EAAe43C,EAAQd,EAAWvyD,EAAaC,EAAaizD,EAAS,GAAIA,EAAS,GAAI,CAC/GhwG,MAAO,cACP0V,KAAM9R,KAAKisG,oBAAoB34D,GAC/B+vC,YAAarjF,KAAKyM,cAAcq+F,WAChCluG,MAAOs3D,EACP0H,WACAyM,UACDikC,EAAW,GACdR,EAAyBnjG,KAAKyjG,IAEtC,CACJ,GAEEK,EAA0Bl4C,EAAYz/C,OAAQw+B,GAAeA,EAAWpmC,KAAKi+F,iBAC/ElB,GAA0BC,4BAA4BE,QACtD92D,EAAWpsC,SAASX,oBAAsB27B,GAC9CuqE,EAAwBxrG,QAASqyC,IAC7B,IAAKp3C,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEXszC,EAAe14D,KAEnB,MAAMo5D,EAAyBn4C,EAAYz/C,OAAQw+B,GAAeA,EAAWpmC,KAAKi+F,iBAC9ElB,GAA0BC,4BAA4BC,OACtD72D,EAAWpsC,SAASX,oBAAsB27B,GAY9C,OAXAwqE,EAAuBzrG,QAASqyC,IAC5B,IAAKp3C,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEXszC,EAAe14D,KAEnBolB,GAAe,EACX14D,KAAKyM,cAAcu+F,0BAA4B9uG,GAC/C8D,KAAKyM,cAAcu+F,yBAAyBhrG,KAAK2sG,+BAA+BzwG,IAE7Ew8D,GAEX14D,KAAK4sG,qBACD3C,GAA0BC,4BAA4BC,KAC9D,CACA,wBAAO0C,CAAkB19E,EAAS29E,EAAiB,KAAM,GACrD,MAAMv4C,GAAc,IAAA4H,gBAAe8tC,GAA0BrmD,SAAUz0B,GACvE,IAAKolC,GAAa3zD,OACd,MAAO,GAEX,MAAMg+D,EAAsBrK,EAAYz/C,OAAQw+B,IAC5C,MAAMpR,EAAiBoR,EAAWpsC,SAASX,kBAC3C,OAAOumG,EAAe5qE,KAE1B,OAAO08B,CACX,CACA,uBAAOmuC,CAAiB59E,EAAS29E,EAAiB,KAAM,GACpD,MAAMv4C,GAAc,IAAA4H,gBAAe8tC,GAA0BrmD,SAAUz0B,IACjE,SAAEjzB,IAAa,IAAA6+B,mBAAkB5L,GACjC/oB,EAAWlK,EAASs6B,cACpBw2E,EAAmB7oG,IACrB,MAAMqE,EAAQpC,EAASoM,UAAWnJ,GAAOA,IAAOlF,GAChD,OAAe,IAAXqE,EACO,EAEJA,GAEX,IAAK+rD,GAAa3zD,OACd,OAEJ,MAAMqsG,EAAoB,IAAIz7F,IA4B9B,OA3BA+iD,EAAYtzD,QAASqyC,IACjB,MAAMpR,EAAiBoR,EAAWpsC,SAASX,kBAC3C,IAAKumG,EAAe5qE,GAChB,OAEJ,MAAM,eAAEipE,GAAmB73D,EAAWpmC,KACtC,IAAIggG,EAEAA,EADAD,EAAkB5pG,IAAI6+B,GACb+qE,EAAkB7sG,IAAI8hC,GAGtB,CACL09B,MAAOotC,EAAgB9qE,GACvBirE,MAAO,EACPC,OAAQ,GAGZjC,IACAlB,GAA0BC,4BAA4BE,OACtD8C,EAAOE,SAEFjC,IACLlB,GAA0BC,4BAA4BC,OACtD+C,EAAOC,QAEXF,EAAkB/sG,IAAIgiC,EAAgBgrE,KAEnCD,CACX,CACA,wBAAOI,CAAkBl+E,EAAS29E,EAAiB,KAAM,GACrD,MAAMv4C,GAAc,IAAA4H,gBAAe8tC,GAA0BrmD,SAAUz0B,GAClEolC,GAAa3zD,QAGlB2zD,EAAYtzD,QAASqyC,IACZw5D,EAAex5D,EAAWpsC,SAASX,qBAGxC,IAAAmuD,kBAAiBphB,EAAWqhB,gBAEpC,CACA,uBAAA24C,CAAwBxmG,GACpB9G,KAAK4sG,qBAAuB9lG,CAChC,CACA,uBAAAskG,GACI,OAAOprG,KAAK4sG,oBAChB,CACA,wBAAAW,CAAyBp+E,EAASroB,GAC9B,IAAI0mG,EACJ,MAAMj5C,GAAc,IAAA4H,gBAAe8tC,GAA0BrmD,SAAUz0B,GASvE,GARIroB,IAASmjG,GAA0BC,4BAA4BE,OAC/DoD,EAAiBj5C,EAAYz/C,OAAQw+B,GAAeA,EAAWpmC,KAAKi+F,iBAChElB,GAA0BC,4BAA4BE,QAErDtjG,IAASmjG,GAA0BC,4BAA4BC,QACpEqD,EAAiBj5C,EAAYz/C,OAAQw+B,GAAeA,EAAWpmC,KAAKi+F,iBAChElB,GAA0BC,4BAA4BC,QAE1DqD,GAAgB5sG,OAAS,EAAG,CAC5B,MAAM0yC,EAAak6D,EAAe3iG,OAClC,IAAA6pD,kBAAiBphB,EAAWqhB,cAChC,CACJ,QACS30D,KAAKyvF,QAAU,CAACvgE,EAAYzgB,EAAQrK,KACzC,MAAM9I,GAAiB,IAAAq9E,+BAA8BzpD,GACrD,IAAK5zB,EACD,OAEJ,MAAM,oBAAE0O,EAAmB,kBAAEzD,EAAiB,gBAAEgb,EAAe,SAAEklB,EAAQ,SAAEvqC,GAAc8D,KAAKwxF,YAAYyY,GAA2B3uG,EAAgBmT,EAAQrK,IACvJ,aAAEo4E,KAAiBiV,GAAwBrtF,GAAW,CAAC,EACvDkvC,EAAa,CACfqhB,cAAevwD,GAASuwD,eAAiB,EAAA3jB,UAAA,SACzC9jC,KAAM,CACF+nD,QAAS,CACLxmD,WAGRomD,aAAa,EACb66B,eAAe,EACfn0F,aAAa,EACbmyF,UAAU,EACVC,WAAW,EACXzmF,SAAU,CACN08C,SAAUnd,EAASuuB,cACnBzzC,kBACAvX,sBACAzD,uBACGkrF,KAGX,IAAAp8B,eAAc/hB,EAAYp3C,EAASizB,UACnC,EAAA4nC,EAAA,GAAsC,CAAC76D,EAASmN,KACjD,CACH,sBAAAy1D,CAAuB1c,EAAK9O,EAAYyrB,GACpC,MAAMhuC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,KAAE7jB,GAASomC,EACjBA,EAAWuhB,aAAc,EACzB,IACIkhB,EADAya,GAAgB,EAEhBzxB,EAAOkmB,cACPuL,GAAgB,EAGhBza,EAAc7oE,EAAK+nD,QAAQxmD,OAAO+D,UAAW9D,GAAMA,IAAMqwD,GAE7D,MAAMlB,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,cACAya,iBAEJxwF,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,IAClB,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,gBACR,CACA,gBAAA+zC,CAAiBrvG,EAAUoS,GACvB,IAAKtO,KAAKwrG,8BAA8BtvG,GACpC,OAAO,EAEX,MAAM,UAAEyoB,GAAczoB,EAASq8B,gBAAkB,CAAC,EAClD,GAAI5T,EAAW,CACX,MAAM8mF,EAAYvvG,EAASinD,cAAcx+B,EAAUO,aAAallB,KAAKyM,cAAcmK,SAC7EorD,EAAoB9lE,EAASinD,cAAc70C,GAC3CxR,GAAQ,SAAgB2uG,EAAWzpC,GACzC,OAAQllE,GAASkD,KAAKyM,cAAcisC,YAChC57C,GAASkD,KAAKyM,cAAcksC,QACpC,CACJ,CACA,8BAAA80D,CAA+Bn1D,GACtBA,IAGDt4C,KAAK0tG,kCAAkCp1D,KACvCt4C,KAAKyM,cAAcmK,OAAS,CACxB0hC,EAAY1hC,OAAO,GACnB0hC,EAAY1hC,OAAO,GACnB,IAGR5W,KAAKyM,cAAcysC,YAAcZ,EAAYY,YAC7Cl5C,KAAKyM,cAAc0sC,YAAcb,EAAYa,YAC7Cn5C,KAAKyM,cAAcisC,WAAaJ,EAAYI,WAC5C14C,KAAKyM,cAAcksC,SAAWL,EAAYK,SAC9C,CACA,6BAAAg1D,CAA8BzxG,GAC1B,MAAMiI,EAAUjI,EAASimC,qBACnB,YAAEmW,GAAgBjC,GAAqBlyC,IAAY,CAAC,EACtDm0C,GACAt4C,KAAKytG,+BAA+Bn1D,EAE5C,CACA,iCAAAo1D,CAAkCp1D,GAI9B,OAHKA,IACDA,EAAct4C,KAAKyM,eAEf6rC,GAAa1hC,QACjB0hC,GAAaY,YAAc,GAC3BZ,GAAaa,aACbb,GAAaI,WAAa,GAC1BJ,GAAaI,WAAa,KAC1BJ,GAAaK,SAAW,GACxBL,GAAaK,SAAW,GAChC,CACA,6BAAA6yD,CAA8BtvG,GAC1B,GAAI8D,KAAK0tG,oCACL,OAAO,EAEX,IAAK1tG,KAAK0tG,oCAAqC,CAC3C,MAAMvpG,EAAUjI,EAASimC,oBACnBmW,EAAc,EAAAllB,SAAA,IAAa,6BAA8BjvB,GAC/DnE,KAAKytG,+BAA+Bn1D,EACxC,CAIA,OAHKt4C,KAAK0tG,qCACN1tG,KAAK2tG,8BAA8BzxG,GAEhC8D,KAAK0tG,mCAChB,CACA,8BAAAf,CAA+BzwG,GAC3B,IAAK8D,KAAKwrG,8BAA8BtvG,GACpC,OAEJ,MAAM,UAAEyoB,GAAczoB,EAASq8B,gBAAkB,CAAC,EAClD,IAAK5T,EACD,OAEJ,MAAM,QAAEwK,GAAYjzB,EACduvG,EAAYvvG,EAASinD,cAAcx+B,EAAUO,aAAallB,KAAKyM,cAAcmK,SAC7EsrB,EAAiBhmC,EAASimC,oBAC1BoyB,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,IAAY,GAC7Dy+E,EAAkBr5C,EACnBz/C,OAAQw+B,GAAeA,EAAWpmC,KAAKi+F,iBACxClB,GAA0BC,4BAA4BE,QACtD92D,EAAWpsC,SAASX,oBAAsB27B,GACzC77B,IAAKitC,GACoBA,EAAWpmC,KAAK+nD,QAAQxmD,OAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,KAGzFm/F,EAAiBt5C,EAClBz/C,OAAQw+B,GAAeA,EAAWpmC,KAAKi+F,iBACxClB,GAA0BC,4BAA4BC,OACtD72D,EAAWpsC,SAASX,oBAAsB27B,GACzC77B,IAAKitC,GACoBA,EAAWpmC,KAAK+nD,QAAQxmD,OAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,KAG/F,OAAO,SAA4B+8F,EAAWmC,EAAiBC,EACnE,CACA,mBAAA5B,CAAoB34D,GAChB,MAAM,eAAE63D,GAAmB73D,EAAWpmC,MAChC,WAAEm9F,EAAU,YAAEC,GAAgBtqG,KAAKyM,cACzC,OAAI0+F,IACAlB,GAA0BC,4BAA4BC,MAC/CE,EAEPc,IACAlB,GAA0BC,4BAA4BE,OAC/CE,EAEJD,CACX,CACA,qBAAAsB,CAAsBzvG,GAClB,MAAM,UAAEyoB,GAAczoB,EAASq8B,gBAAkB,CAAC,EAC5C1K,EAAK3xB,EAASinD,cAAcx+B,EAAUO,aAAa,CAAC,EAAG,EAAG,KAC1D4I,EAAK5xB,EAASinD,cAAcx+B,EAAUO,aAAa,CAAC,EAAG,EAAG,KAC1D4oF,EAAa,CAAChgF,EAAG,GAAKD,EAAG,GAAIC,EAAG,GAAKD,EAAG,IAE9C,OADmB5wB,KAAKopC,KAAKynE,EAAW,GAAKA,EAAW,GAAKA,EAAW,GAAKA,EAAW,GAE5F,CACA,cAAAvD,CAAetyC,EAAkB/7D,GAC7B,IAAK8D,KAAKwrG,8BAA8BtvG,GACpC,OAEJ,MAAM,UAAEyoB,GAAczoB,EAASq8B,gBAAkB,CAAC,EAClD,IAAK5T,EACD,OAEJ,MAAMopF,EAAeC,GAAe,IAANA,EAAa/wG,KAAKC,GAC1C+wG,EAAe7V,GAAYA,EAASn7F,KAAKC,GAAM,IAC/CgxG,EAAiB5/F,GACZpS,EAASinD,cAAcpf,GAAsBpf,EAAWrW,IAE7D6/F,EAAenuG,KAAKyM,cAAcysC,YACpCl5C,KAAKyM,cAAc+9F,aACdxqG,KAAKyM,cAAc0sC,YAAcn5C,KAAKyM,cAAcysC,aACvDk1D,EAAcpuG,KAAKyM,cAAcisC,WAEjC21D,EADYruG,KAAKyM,cAAcksC,SACLy1D,EAC1BE,EAAaL,EAAYI,GAAeF,EAC9C,IAAII,EAAatxG,KAAKgmB,MAAMqrF,GACvBtuG,KAAKyM,cAAck+F,qBAChB3qG,KAAKyM,cAAcm+F,oBACvB2D,GAAc,IACdA,EAAatxG,KAAKkS,IAAI,GAAIlS,KAAKgmB,MAAMorF,EAAc,KAEvD,MAAMG,EAAaH,EAAcE,EACjC,IAAK,IAAI7kG,EAAI,EAAGA,EAAI6kG,EAAY7kG,IAAK,CACjC,MAAM+kG,EAASR,EAAYG,EAAc1kG,EAAI8kG,GACvCE,EAAST,EAAYG,EACvB1kG,EAAI8kG,EACJT,EAAY/tG,KAAKyM,cAAck+F,sBAAwBwD,GACrDQ,EAAc,CAChB3uG,KAAKyM,cAAcmK,OAAO,GAAKu3F,EAAelxG,KAAKo7F,IAAIoW,GACvDzuG,KAAKyM,cAAcmK,OAAO,GAAKu3F,EAAelxG,KAAKq7F,IAAImW,GACvD,GAEEG,EAAY,CACd5uG,KAAKyM,cAAcmK,OAAO,GAAKu3F,EAAelxG,KAAKo7F,IAAIqW,GACvD1uG,KAAKyM,cAAcmK,OAAO,GAAKu3F,EAAelxG,KAAKq7F,IAAIoW,GACvD,IAEJ,IAAAhzC,UAAYzD,EAAkB/7D,EAASmN,GAAI,cAAcK,IAAKwkG,EAAcS,GAAcT,EAAcU,GAAY,CAChHxyG,MAAO4D,KAAKyM,cAAcg+F,gBAC1Bv2C,UAAWl0D,KAAKyM,cAAci+F,oBAC9BmE,cAAe7uG,KAAKyM,cAAco+F,mBAE1C,CACJ,CACA,eAAA7a,CAAgBC,EAAQC,EAAQroF,GAC5B,OAAQ,EAAAmpC,UAAA,sBAAgCi/C,EAAQpoF,IAC5C,EAAAmpC,UAAA,sBAAgCk/C,EAAQroF,EAChD,EAEJ,SAAS,GAAoBqF,EAAMsZ,GAC/B,MAAO,CAAC,GACZ,CCpuBA,MAAMsoF,WAAqB,aACd9uG,KAAK4jD,SAAW,UAAY,QAC5B5jD,KAAK+uG,WAAa,CACvB7hG,KAAM,CACF8hG,aAAa,GAElB,QACMhvG,KAAKivG,UAAY,CACtB/hG,KAAM,CACFgiG,SAAS,GAEd,CACH,WAAAzvG,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACX+hF,gBAAe,GACfC,mBAAkB,GAClB0gB,eAAgB,CAAC,GAAI,IACrB9mB,WAAY,GACZ7f,aAAc,IACdwmC,aAAa,EACbE,SAAS,KAGb5tD,MAAMS,EAAWC,GACjBhiD,KAAK2+D,iBAAoBvc,IACrB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,EAAO,cAAE62B,GAAkBj1B,EAC7Bz1B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACfgmB,EAAW0kC,EAAcvC,MACzBnQ,EAActzC,KAAgB,YAAE2yF,4BAA4Bz2F,EAAU,CACxEgR,KAAM,CACF+nD,QAAS,CAAExmD,OAAQ,CAAC,IAAI6S,KACxB0tF,YAAahvG,KAAKyM,cAAcuiG,YAChCE,QAASlvG,KAAKyM,cAAcyiG,YAGpC,IAAA75C,eAAc/hB,EAAYnkB,GAC1B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAezE,OAdA5S,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GACtC79D,KAAKyM,cAAc+hF,gBAAiB56D,IAChC,IAAKA,EAID,OAHA,IAAA8gC,kBAAiBphB,EAAWqhB,gBAC5B,EAAAoC,EAAA,GAAsC8G,QACtC79D,KAAKqhE,WAAY,GAGrB/tB,EAAWpmC,KAAK0mB,MAAQA,GACxB,KAAA+tC,4BAA2BruB,IAC3B,EAAAyjB,EAAA,GAAsC8G,KAE1C79D,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,eAAe,IAC/C1iC,GAEXtzC,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,KACvD,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,KAAE4R,GAASomC,EACjB,IAAKpmC,GAAMgiG,QACP,OAAO,EAEX,MAAM,eAAEC,EAAc,WAAE9mB,GAAeroF,KAAKyM,cAC5C,QAAK0iG,GAAgBvuG,SAGjB3D,KAAK6e,IAAIm7C,EAAa,GAAKk4C,EAAe,GAAK9mB,EAAa,IAC5DA,EAAa,GACbprF,KAAK6e,IAAIm7C,EAAa,GAAKk4C,EAAe,GAAK9mB,EAAa,IACxDA,EAAa,IAKzBroF,KAAKo3D,qBAAuB,CAAChV,EAAK9O,KAC9BA,EAAWuhB,aAAc,EACzBzS,EAAIoV,kBAERx3D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,WAAEzuC,EAAU,gBAAEvV,IAAoB,IAAAohB,mBAAkB5L,GAC1DnvB,KAAK4yF,oBAAsB,CACvB1jE,aACAhB,kBAAmBvU,EAAgBtQ,IAEvCrJ,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACf6mD,GACAh2E,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBAE3Ch2E,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,EACjBrhE,KAAKsvF,eACDtvF,KAAKwkF,sBACLxkF,KAAKyM,cAAc23E,4BACnB,IAAA1vB,kBAAiBphB,EAAWqhB,gBAEhC,EAAAoC,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,IAGnCtzC,KAAKykG,oBAAuBriD,IACxB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpB,IAAIwjC,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GAErD,GADAolC,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAEJ,MAAM8jG,EAAoBnwC,EAAY72C,KAAM41B,GAAetzC,KAAKg3D,gBAAgB7nC,EAASmkB,EAAYviB,EAAYi1B,cAAcvqD,OAAQ,IACvI,IAAKipG,EACD,OAEJ,MAAMpxD,EAAaoxD,EACnB1kG,KAAK21B,WAAWxG,EAASmkB,GACzBtzC,KAAKyM,cAAcgiF,mBAAmBiW,EAAmBtiD,EAAIrtB,OAAQ/0B,KAAK+vF,0BAA0Bv/E,KAAKxQ,KAAMmvB,EAASmkB,IACxHtzC,KAAKqhE,WAAY,EACjBrhE,KAAKsvF,eACLltC,EAAIuiD,2BACJviD,EAAIoV,kBAERx3D,KAAKqiD,cAAiBD,IAClBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,OACzB,WAAEnQ,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,KAAEzwD,GAASomC,EACjBtzC,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBACvC9oE,EAAK+nD,QAAQxmD,OAAO,GAAK,IAAI6S,GAC7BgyB,EAAW/3C,aAAc,GACzB,EAAAw7D,EAAA,GAAsC8G,IAE1C79D,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACpB,IAAIq4D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAGX,GADAnE,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAAO83D,EAEX,MAAMqJ,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6qD,EAAY3zD,OAAQ8I,IAAK,CACzC,MAAM4pC,EAAaihB,EAAY7qD,IACzB,cAAEirD,EAAa,KAAEznD,GAASomC,EAChCyuB,EAAepN,cAAgBA,EAC/B,MAAM,MAAEv4D,EAAK,UAAE83D,GAAcl0D,KAAKiiE,mBAAmB,CACjD3uB,aACAyuB,oBAEE,eAAEotC,EAAc,WAAE9mB,GAAeroF,KAAKyM,cACtCo4F,EAAW,IACjB,GAAI33F,GAAMgiG,QAAS,CACf,MAAM5gG,EAAQpB,EAAK+nD,QAAQxmD,OAAO,GAC5BuzD,EAAoB9lE,EAASinD,cAAc70C,IACjD,IAAAy/D,aAAe9V,EAAkBtD,EAAekwC,EAAU,CAAC7iC,GAAoB,CAC3E5lE,QACA83D,YACAsU,aAAcxoE,KAAKyM,cAAc+7D,cAEzC,MACS2mC,GAAgBvuG,SACrB,IAAAkkG,WAAa7sC,EAAkBtD,EAAekwC,EAAUsK,EAAe9oG,IAAK0F,GAAOA,EAAKs8E,GAAa8mB,EAAgB,CACjH/yG,QACAQ,MAAO,IAIf,GADA87D,GAAe,GACVx8D,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,CAEf,CACA,OAAOA,EAEf,CACA,sBAAAoG,CAAuB1c,EAAK9O,GACxB,MAAMviB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,EACpBuiB,EAAWuhB,aAAc,EACzB,MAAMgJ,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eACzEh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,uBAEJ79D,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,IAClB,EAAA4nC,EAAA,GAAsC8G,GACtCzb,EAAIoV,gBACR,CACA,eAAOzF,CAASze,EAAY47D,GAAW57D,EAAWpmC,KAAKgiG,QAAS//E,GAC5DmkB,EAAWpmC,KAAKgiG,QAAUA,GAC1B,KAAA17D,2BAA0BF,EAAYnkB,EAC1C,CACA,yBAAA4gE,CAA0B5gE,EAASmkB,EAAY87D,GAC3C97D,EAAWpmC,KAAK0mB,MAAQw7E,EACxB,MAAMvxC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,gBACzE,EAAA+B,EAAA,GAAsC8G,IACtC,KAAArqB,2BAA0BF,EAAYnkB,EAC1C,CACA,MAAAlkB,CAAOkkB,GACH,GAAInvB,KAAKqhE,UAAW,CAChBrhE,KAAKqhE,WAAY,EACjBrhE,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,WAAEmkB,EAAU,oBAAEuqB,EAAmB,cAAEmY,GAAkBh2E,KAAK29D,UAC1D,KAAEzwD,GAASomC,EAQjB,OAPAA,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,MACjC,EAAAne,EAAA,GAAsC8G,GAClCmY,IACA,KAAArU,4BAA2BruB,GAE/BtzC,KAAK29D,SAAW,KACTrqB,EAAWqhB,aACtB,CACJ,CACA,eAAAq7B,CAAgBC,EAAQC,EAAQroF,GAC5B,OAAQ,kCAA8BooF,EAAQpoF,IAC1C,kCAA8BqoF,EAAQroF,EAC9C,EAEJ,SAAS,GAAgBsoF,GACrB,OAAOA,EAAyBC,OAAO,0BAC3C,CACA,SAAS,GAAmBljF,EAAMs1B,EAAW2tD,GACzC,OAAOA,EAAyBC,OAAO,0BAC3C,C,gBCvQA,MAAMif,WAA6B,MAC/B,WAAA5vG,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,WAErCX,MAAMS,EAAWC,GACjBhiD,KAAKkkD,qBAAwB9B,GAClBpiD,KAAKsvG,yBAAyBltD,EAAK,SAE9CpiD,KAAKolE,sBAAyBhjB,GACnBpiD,KAAKsvG,yBAAyBltD,EAAK,QAElD,CACA,wBAAAktD,CAAyBltD,EAAKiV,GAC1B,MAAM,kBAAEnpC,EAAiB,WAAEgB,EAAU,QAAEC,EAAO,cAAE62B,GAAkB5D,EAAIrtB,OAChEw6E,GAAY,IAAAvnC,yBAAwB94C,EAAYhB,GACtD,IAAKqhF,EACD,OAAO,EAEX,MAAMC,EAAQD,EAAUE,eAClBC,EAAsB,GAC5B,IAAK,MAAM9rD,KAAY4rD,EAAO,CAC1B,MAAMhzB,EAAegzB,EAAM5rD,GAC3B,GAA4C,mBAAjC44B,EAAaxlB,iBAEhB,mBADGwlB,EAAa/nB,wCAEpB,SAEJ,MAAMF,GAAc,IAAA4H,gBAAevY,EAAUz0B,GACvCwgF,EAA0BnzB,EAAa/nB,wCAAwCtlC,EAASolC,GAC9F,GAAKo7C,EAGL,IAAK,MAAMr8D,KAAcq8D,EACjBnzB,EAAaxlB,gBAAgB7nC,EAASmkB,EAAY0S,EAAcvqD,OAAQ,GAAI47D,IAC5Eq4C,EAAoB/mG,KAAK2qC,EAAWqhB,cAGhD,CACA,IAAK,MAAMA,KAAiB+6C,EAAqB,EAC7C,KAAAE,uBAAsBj7C,GACtB,MAAMrhB,GAAa,IAAAu8D,eAAcl7C,GACjC,MAAem7C,qBAAqB3gF,EAASmkB,EAAY,CACrDy8D,UAAU,KAEd,IAAAr7C,kBAAiBC,EACrB,CAEA,OADAvS,EAAIoV,kBACG,CACX,EAEJ63C,GAAqBzrD,SAAW,S,gBC9ChC,MAAMosD,WAA0BC,GAAA,SACnBjwG,KAAK4jD,SAAW,eAAiB,CAC1C,WAAAnkD,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXyjG,iBAAiB,EACjBC,qBAAsB,GACtBC,qBAAsB,MAG1B9uD,MAAMS,EAAWC,GACjBhiD,KAAKqiD,cAAiBD,IAClB,MAAM5f,EAAY4f,EAAIrtB,QAChB,QAAE5F,EAAO,cAAE62B,GAAkBxjB,GAC3BihB,MAAO4sD,GAAsBrqD,EAC/B1qD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACrB0E,KAAKswG,YAAYC,kBAAoBF,GACrC,OAAuC,CAACn0G,EAASmN,MAErDrJ,KAAKo9D,aAAevhC,MAAOumB,IACvB,MAAM5f,EAAY4f,EAAIrtB,QAChB,QAAE5F,GAAYqT,EACdlnC,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACrB0E,KAAKwwG,aACLxwG,KAAK0hE,gBAAgBvyC,GACrBnvB,KAAKswG,YAAc,MACnB,KAAA1yC,oBAAmBzuC,IACnB,OAAuC,CAACjzB,EAASmN,MAErDrJ,KAAK0hE,gBAAmBvyC,IACpBA,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cAE7D,CACA,0BAAMlZ,CAAqB9B,GACvB,MAAM5f,EAAY4f,EAAIrtB,QAChB,QAAE5F,EAAO,cAAE62B,GAAkBxjB,GAC3BihB,MAAOpU,GAAe2W,EACxB1qD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,EAAQ,gBAAEyd,GAAoBre,EAStC,aARMgmD,MAAM4C,qBAAqB9B,GACjCxiD,OAAO23E,OAAOv3E,KAAKswG,YAAa,CAC5BG,kBAAmBphE,EACnBkhE,kBAAmBlhE,IAEvBrvC,KAAKyhE,cAActyC,IACnB,KAAAooC,mBAAkBpoC,IAClB,OAAuC,CAACjzB,EAASmN,MAC1C,CACX,CACA,wBAAMqnG,CAAmBJ,GACrB,MAAQK,cAAc,mBAAErtE,GAAoB,kBAAEpV,EAAiB,WAAEgB,EAAU,kBAAEuhF,EAAiB,kBAAEF,EAAiB,QAAEnsG,GAAaksG,EAE1Hp0G,GADkB,IAAAiyB,oBAAmBD,GACVkC,YAAYlB,GAEvC0hF,EAAa,CACfh6F,OAAQ65F,EACR/qE,OAHsB,SAAS,SAAS,cAAe+qE,EAAmBF,KAK9E,OAAO,EAAAM,QAAA,oBAA4BvtE,EAAoBstE,EAAY10G,EAAUkI,EACjF,CACA,aAAAq9D,CAActyC,GACVA,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,aACtD,CACA,gBAAApF,CAAiB18D,EAAgB28D,GAC7B,IAAKj4D,KAAKswG,YACN,OAEJ,MAAM,SAAEp0G,GAAaZ,GACbq1G,aAAcG,EAAgB,kBAAEL,EAAiB,kBAAEF,GAAuBvwG,KAAKswG,YACjFS,EAAoB70G,EAASinD,cAAcstD,GAC3CO,EAAoB90G,EAASinD,cAAcotD,GAC3CU,EAAoB,SAAS,cAAeD,EAAmBD,GAC/D/0C,EAAe,SAASi1C,GAC9B,GAAI,oBAAgBj1C,EAAc,GAC9B,OAEJ,MAEM,MAAE5/D,GAAU4D,KAAKkxG,gBAAgB,CACnCv0B,eAAgBm0B,EAAiBn0B,eACjCw0B,aAAcL,EAAiBK,aAC/BjiF,WAAYhzB,EAASmN,MAEzB,IAAA6yD,YAAcjE,EAPQ,UACJ,IAMwC84C,EAAmB/0C,EAAc,CACvF5/D,SAER,E,gBC/FJ,MAAMg1G,WAA8BnB,GAAA,SACvBjwG,KAAK4jD,SAAW,mBAAqB,CAC9C,WAAAnkD,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXyjG,iBAAiB,EACjBC,qBAAsB,GACtBC,qBAAsB,GACtBiB,2BAA4B,GAC5BC,cAAe,CACXxoD,SAAS,MAIjBxH,MAAMS,EAAWC,GACjBhiD,KAAKuxG,WAAa,KAClBvxG,KAAKwxG,kBAAmB,CAC5B,CACA,iBAAA95C,CAAkBtV,GACd,GAAIpiD,KAAKo7E,OAAS,EAAA1qC,UAAUH,OACxB,OAEJ,MAAM/N,EAAY4f,EAAIrtB,QAChB,cAAEixB,EAAa,QAAE72B,GAAYqT,GAC3BihB,MAAOpU,GAAe2W,EAC9B72B,EAAQO,MAAM46B,OAAS,UACC,OAApBtqD,KAAKuxG,aACLhiF,OAAOkiF,aAAazxG,KAAKuxG,YACzBvxG,KAAKuxG,WAAa,MAEtBvxG,KAAKuxG,WAAahiF,OAAOoC,WAAW,KAChC3xB,KAAK0xG,cAActvD,EAAK/S,EAAYlgB,IACrCnvB,KAAKyM,cAAcklG,qBAAuB,IACjD,CACA,mBAAMD,CAActvD,EAAK/S,EAAYlgB,SAC3BmyB,MAAM4C,qBAAqB9B,GACjC,MAAMwvD,EAAY,EAAAt+E,MAAMxM,UAAU9mB,KAAKswG,YAAYK,aAAartE,oBAC1DuuE,GAAQ,SAAsBD,EAAWviE,EAAY,CAAC,IAAM,CAC9DyiE,oBAAqB,IAAIp2E,IACzBq2E,oBAAqB,IAAIr2E,MAEvB,oBAAEo2E,EAAmB,oBAAEC,GAAwBF,EACrD,IAAIvnD,EACAwnD,EAAoBtnF,KAAOunF,EAAoBvnF,KAAO,IACtDunF,EAAoBvnF,KAAO,IAC3B8/B,EAAS,cACTtqD,KAAKwxG,kBAAmB,IAGxBlnD,EAAS,OACTtqD,KAAKwxG,kBAAmB,GAE5B,MAAMl2G,GAAiB,IAAAy/B,mBAAkB5L,GACrCA,IACAA,EAAQO,MAAM46B,OAASA,EACvB0nD,sBAAsB,KACd7iF,EAAQO,MAAM46B,SAAWA,IACzBn7B,EAAQO,MAAM46B,OAASA,MAI/BtqD,KAAKwxG,mBACLxxG,KAAK6xG,MAAQA,GAEbv2G,GAAkBA,EAAeY,UACjCZ,EAAeY,SAASD,QAEhC,CACA,0BAAMioD,CAAqB9B,GACvB,IAAKpiD,KAAKwxG,iBACN,OAAO,EAEX,MAAMhvE,EAAY4f,EAAIrtB,QAChB,cAAEixB,EAAa,QAAE72B,GAAYqT,GACZ,IAAAzH,mBAAkB5L,KAErCA,EAAQO,MAAM46B,OAAS,OACvB0nD,sBAAsB,KACW,SAAzB7iF,EAAQO,MAAM46B,SACdn7B,EAAQO,MAAM46B,OAAS,WAInC,MAAQ7G,MAAOpU,GAAe2W,EAgB9B,aAfM1E,MAAM4C,qBAAqB9B,GACjCpiD,KAAKswG,YAAc,sBAAkBtwG,KAAKswG,YAAa,CACnDjhE,aACAiiE,cAAe,CACXW,kBAAmB,CAAC5iE,MAG5BrvC,KAAKswG,YAAYjhE,WAAaA,EAC9BrvC,KAAKswG,YAAYgB,cAAgB,CAC7BW,kBAAmB,CAAC5iE,UAElBrvC,KAAKwwG,aACPrhF,IACAA,EAAQO,MAAM46B,OAAS,YAEpB,CACX,CACA,mBAAA4nD,CAAoB5B,GAChB,MAAM,WAAEjhE,GAAeihE,EACvB,MAAO,CACH2B,kBAAmB,CAAC5iE,GAE5B,CACA,wBAAMqhE,CAAmBJ,GACrB,MAAQK,cAAc,mBAAErtE,GAAoB,WAAE+L,EAAU,QAAEjrC,GAAaksG,GACjE,2BAAEe,GAA+BrxG,KAAKyM,cACtC0lG,EAAgB,IACf/tG,EACHitG,6BACAQ,MAAO7xG,KAAK6xG,OAEhB,OAAO,EAAAhB,QAAA,mBAA2B,CAC9BvtE,qBACA2hD,cAAe51C,EACfjrC,QAAS+tG,GAEjB,EAEJ,MCvHMC,GAAuB,EAAEz7F,KAAW,KACpC07F,GAAuB,CAAC,EAAG,MAC3BC,GAAqB,CAAC,IAAM,OAC1B5tE,sBAAqB,yBAAuB,IAAK,YACzD,MAAM6tE,WAA6BtC,GAAA,EAC/B,WAAAxwG,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXyjG,iBAAiB,EACjBsC,mBAAoBH,GACpBI,mBAAoBL,GACpBd,cAAe,CACXxoD,SAAS,EACT4pD,iBAAkBJ,OAI1BhxD,MAAMS,EAAWC,GACjBhiD,KAAKqiD,cAAiBD,IAClB,MAAM5f,EAAY4f,EAAIrtB,QAChB,QAAE5F,EAAO,cAAE62B,GAAkBxjB,GAC3BihB,MAAO4sD,GAAsBrqD,EAC/B1qD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACf2hD,EAAaj9C,KAAK2yG,8BAA8Br3G,EAAgB+0G,GACtErwG,KAAKswG,YAAYsC,gBAAgB,GAAK31D,GACtC,OAAuC,CAAC/gD,EAASmN,MAErDrJ,KAAKo9D,aAAevhC,MAAOumB,IACvB,MAAM5f,EAAY4f,EAAIrtB,QAChB,QAAE5F,GAAYqT,EACdlnC,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,QACf0E,KAAKwwG,aACXxwG,KAAK0hE,gBAAgBvyC,GACrBnvB,KAAKswG,YAAc,MACnB,KAAA1yC,oBAAmBzuC,IACnB,OAAuC,CAACjzB,EAASmN,MAErDrJ,KAAK0hE,gBAAmBvyC,IACpBA,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cAE7D,CACA,0BAAMlZ,CAAqB9B,GACvB,MAAM5f,EAAY4f,EAAIrtB,QAChB,QAAE5F,EAAO,cAAE62B,GAAkBxjB,GAC3BihB,MAAOpU,GAAe2W,EACxB1qD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,EAAQ,gBAAEyd,GAAoBre,EAChC2hD,EAAaj9C,KAAK2yG,8BAA8Br3G,EAAgB+zC,GAMtE,aALMiS,MAAM4C,qBAAqB9B,GACjCpiD,KAAKswG,YAAYsC,gBAAkB,CAAC31D,EAAYA,GAChDj9C,KAAKyhE,cAActyC,IACnB,KAAAooC,mBAAkBpoC,IAClB,OAAuC,CAACjzB,EAASmN,MAC1C,CACX,CACA,gBAAA2uD,CAAiB18D,EAAgB28D,GAC7B,IAAKj4D,KAAKswG,YACN,OAEJ,MAAQK,aAAcG,EAAgB,gBAAE8B,GAAoB5yG,KAAKswG,YACjE,GAA+B,IAA3BsC,EAAgBhyG,OAChB,OAEJ,MAAM,SAAE1E,GAAaZ,GACf,eAAEqhF,EAAc,aAAEw0B,GAAiBL,GAClC1L,EAAOE,GAASsN,GAChBC,EAAcC,GAAgB1N,GAC9B2N,EAAcC,GAAgB1N,EAC/BniB,EAAe,CACjB0vB,EACAC,EACAE,EACAD,GACF1sG,IAAKgpC,GAAenzC,EAASinD,cAAc9T,KAGvC,MAAEjzC,EAAK,UAAEgnF,EAAS,UAAElvB,EAAS,YAAEmvB,EAAW,SAAEznB,GAAa57D,KAAKkxG,gBAAgB,CAChFv0B,iBACAw0B,eACAjiF,WAAYhzB,EAASmN,MAEzB,IAAAo1F,cAAgBxmC,EAPM,cACC,IAM0CkrB,EAAc,CAC3E/mF,QACAgnF,YACAC,cACAnvB,YACA0H,WACA0nB,WAAW,GAEnB,CACA,wBAAMotB,CAAmBJ,GACrB,MAAQK,cAAc,aAAEQ,EAAY,mBAAE7tE,GAAoB,kBAAEpV,EAAiB,WAAEgB,EAAU,gBAAE0jF,GAAqBtC,EAE1Gp0G,GADkB,IAAAiyB,oBAAmBD,GACVkC,YAAYlB,IACtCk2E,EAAOE,GAASsN,EACjBK,EAAoB,CAAC7N,EAAM,GAAIA,EAAM,GAAIE,EAAM,GAAIA,EAAM,IACzD/hE,EAAmB,EAAAjQ,MAAMxM,UAAUwc,IACjC47C,QAASg0B,EAAc/zB,YAAag0B,GAAqBnzG,KAAKozG,wCAAwCl3G,EAAU+2G,GAGlHI,EAAkB,CACpBjiB,YAAa,CACTvtD,WAJW,GAAsBN,EAAiB5e,UAAWuuF,GAK7DI,eAJe,GAAsB/vE,EAAiB5e,UAAWwuF,KAOnEv+B,EAAS50E,KAAKyM,cACdrI,EAAU,CACZmvG,kBAAmBpC,EACnBqC,kBAAmB,IACnBf,mBAAoB79B,EAAO69B,mBAC3BD,mBAAoB59B,EAAO49B,oBAE/B,OAAO,EAAA3B,QAAA,yBAAiCvtE,EAAoB+vE,EAAiBjvG,EACjF,CACA,mBAAA8tG,GACI,MAAQvB,cAAc,aAAEQ,EAAY,mBAAE7tE,EAAkB,iBAAEmwE,IAAwBzzG,KAAKswG,YACjF/sE,EAAmB,EAAAjQ,MAAMxM,UAAUwc,GACnCowE,EAAiB,EAAApgF,MAAMxM,UAAU2sF,GACjCE,EAAuBpwE,EAAiBv+B,aAAao/B,6BACrDwvE,EAAeF,EAAe1uG,aAAao/B,8BAC3C,iBAAEsuE,GAAqB1yG,KAAKyM,cAAc6kG,cAC1CuC,EAAqB,GAC3B,IAAK,IAAInqG,EAAI,EAAGgyC,EAAMk4D,EAAahzG,OAAQ8I,EAAIgyC,EAAKhyC,IAAK,CACrD,GAAIkqG,EAAalqG,KAAOynG,EACpB,SAEJ,MAAM2C,EAAaH,EAAqBjqG,GACpCoqG,GAAcpB,EAAiB,IAC/BoB,GAAcpB,EAAiB,IAC/BmB,EAAmBlrG,KAAKe,EAEhC,CACA,MAAO,CACHmqG,qBAER,CACA,aAAApyC,CAActyC,GACVA,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,aACtD,CACA,8BAAA22C,CAA+B73G,EAAU83G,EAAgBC,GACrD,MAAM9tF,EAASnmB,KAAKk0G,mBAAmBh4G,IACjC,WAAE2L,GAAese,EACjB27E,EAAW,GAAsB37E,EAAOxB,UAAWqvF,GACnDvuD,EAAOwuD,EAAazhG,UAAWgb,GAAM,oBAAgBvwB,KAAK6e,IAAI0R,GAAI,IACxE,IAAc,IAAVi4B,EACA,MAAM,IAAIrnD,MAAM,mCAEpB,MAAM+1G,EAAY,IAAIrS,GAChBsS,EAAY,IAAItS,GAGtB,OAFAqS,EAAU1uD,GAAQ,EAClB2uD,EAAU3uD,GAAQ59C,EAAW49C,GAAQ,EAC9B,CAAC0uD,EAAWC,EACvB,CACA,8CAAAC,CAA+Cn4G,EAAU83G,GACrD,MAAM,gBAAEzyF,GAAoBrlB,EAASumB,YACrC,OAAOziB,KAAK+zG,+BAA+B73G,EAAU83G,EAAgBzyF,EACzE,CACA,2BAAA+yF,CAA4Bp4G,EAAU+2G,GAClC,MAAMsB,EAAe,GACfpuF,EAASnmB,KAAKk0G,mBAAmBh4G,GAMvC,OALA+2G,EAAkBhyG,QAASuzG,IACvB,MACMC,EADgBz0G,KAAKq0G,+CAA+Cn4G,EAAUs4G,GAC9CnuG,IAAKy7F,GAAa,GAAsB37E,EAAOxB,UAAWm9E,IAChGyS,EAAa5rG,QAAQ8rG,KAElBF,CACX,CACA,uCAAAnB,CAAwCl3G,EAAU+2G,GAC9C,MAAMyB,EAAoB10G,KAAKs0G,4BAA4Bp4G,EAAU+2G,GAC/D/zB,EAAU,IAAIw1B,EAAkB,IAChCv1B,EAAc,IAAIu1B,EAAkB,IAK1C,OAJAA,EAAkBzzG,QAASouC,IACvB,SAAS6vC,EAASA,EAAS7vC,GAC3B,SAAS8vC,EAAaA,EAAa9vC,KAEhC,CAAE6vC,UAASC,cACtB,CACA,kBAAA+0B,CAAmBh4G,GACf,KAAMA,aAAoB,EAAA6nE,oBACtB,MAAM,IAAI3lE,MAAM,wCAEpB,MAAM0M,EAAW5O,EAAS8yE,kBAAkB,GAC5C,OAAO,EAAA17C,MAAMxM,UAAUhc,EAC3B,CACA,2BAAA6pG,CAA4Br5G,EAAgB+zC,GACxC,MAAM,SAAEnzC,GAAaZ,EACf6qB,EAASnmB,KAAKk0G,mBAAmBh4G,IACjC,WAAE2L,GAAese,EACjB27E,EAAW,GAAsB37E,EAAOxB,UAAW0qB,IACnD,OAAErK,EAAM,gBAAEzjB,GAAoBrlB,EAASumB,YAEvCgjC,EADS,WAAW,cAAezgB,EAAQzjB,GAC7B/O,UAAWgb,GAAM,oBAAgBvwB,KAAK6e,IAAI0R,GAAI,IAC5D2mF,EAAY,IAAIrS,GAChBsS,EAAY,IAAItS,GAGtB,OAFAqS,EAAU1uD,GAAQ,EAClB2uD,EAAU3uD,GAAQ59C,EAAW49C,GAAQ,EAC9B,CAAC0uD,EAAWC,EACvB,CACA,6BAAAzB,CAA8Br3G,EAAgB+zC,GAC1C,MAAM,SAAEnzC,GAAaZ,EACf6qB,EAASnmB,KAAKk0G,mBAAmBh4G,IAChC04G,EAAWC,GAAa70G,KAAK20G,4BAA4Br5G,EAAgB+zC,GAGhF,MAAO,CAFa,GAAsBlpB,EAAOxB,UAAWiwF,GACxC,GAAsBzuF,EAAOxB,UAAWkwF,GAEhE,EAEJtC,GAAqB3uD,SAAW,mB,oDClNhC,MAAMkxD,WAA8BC,GAAA,EAChC,WAAAt1G,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXuoG,WAAY,CACRC,YAAa,MACbC,aAAc,MAElBC,gBAAiB,cACjBC,eAAgB,iBAGpB9zD,MAAMS,EAAWC,GACjBhiD,KAAKkkD,qBAAwB9B,IACzB,IAAuB,IAAnBpiD,KAAKqhE,UACL,OAEJ,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,MACzBnoD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACrB0E,KAAKqhE,WAAY,EACjB,MAAM7+C,EAAStmB,EAASumB,aAClB,gBAAElB,EAAe,OAAEyjB,GAAWxiB,EAC9B6yF,EAA6B,GAAAC,mBAAA,sBAAyCp5G,EAASmN,IACrF,IAAKgsG,EACD,MAAM,IAAIj3G,MAAM,0EAEpB,MAAM,eAAEu+E,GAAmB04B,EACrBlE,EAAe,GAAAA,aAAA,sBAA6Cx0B,GAC5D44B,EAAiB,GAAAC,eAAA,wBAAuC74B,GACxD84B,EAAe,qCAA8Cv5G,EAASmN,GAAIszE,EAAgBw0B,IAC1F,mBAAEuE,IAAuB,KAAAC,iBAAgBh5B,GACzCi3B,EAAe8B,EAAmB,EAAA94B,4BAA4BC,UAC9DvpC,EAAa,CACfuhB,aAAa,EACbt5D,aAAa,EACb2L,SAAU,CACNqa,gBAAiB,IAAIA,GACrByjB,OAAQ,IAAIA,GACZh7B,oBAAqB9N,EAASqlE,yBAC9Bh7D,kBAAmB,GACnBq9C,SAAU5jD,KAAKg1D,cACfygD,gBAEJvoG,KAAM,CACF+nD,QAAS,CACLxmD,OAAQ,CACJ,IAAI6S,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAER4zD,kBAAmB,QAIzBrX,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAgBzE,GAfAh1D,KAAK29D,SAAW,CACZrqB,aACA69D,eACAx0B,iBACA44B,iBACAE,eACA53C,sBACAkY,YAAa,EACbya,eAAe,EACfxa,eAAe,EACfE,UAAU,EACVprE,SAAU,KACVw4B,mBAAoB,KACpBn/B,QAAS,MAETjI,aAAoB,EAAA6nE,mBAAoB,CACxC,MAAM,SAAEj5D,GAAa8oG,EACfjD,EAAe,EAAAr9E,MAAMxM,UAAUhc,GACrC9K,KAAK29D,SAAW,IACT39D,KAAK29D,SACR7yD,WACAw4B,mBAAoBqtE,EAAartE,mBAEzC,KACK,CACD,MAAMsyE,GAAsB,KAAAC,sCAAqC35G,EAASmN,GAAIszE,GAC9E38E,KAAK29D,SAAW,IACT39D,KAAK29D,SACRx5D,QAASyxG,EAEjB,CAKA,OAJA51G,KAAKyhE,cAActyC,IACnB,KAAAooC,mBAAkBpoC,GAClBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,IAC/B,GAEX79D,KAAKqiD,cAAiBD,IAClBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,YAAEkY,GAAgB/1E,KAAK29D,UACxD,KAAEzwD,GAASomC,GACX,cAAE0S,GAAkBj1B,EACpBz1B,GAAiB,IAAAy/B,mBAAkB5L,IACnC,cAAEg0B,EAAa,cAAE/xB,GAAkB91B,EAAeY,SAClDolB,EAAW0kC,EAAcvC,OACzB,OAAEh1C,GAAWvB,EAAK+nD,QAExB,IAAIn7B,EACAD,EACAgoC,EACAjoC,EACAM,EACAD,EACAF,EACAC,EACJ,OATAvrB,EAAOsnE,GAAe,IAAIz0D,GASlBy0D,GACJ,KAAK,EACL,KAAK,EACDj8C,EAAmBqpB,EAAc10C,EAAO,IACxCmrB,EAAiBupB,EAAc10C,EAAO,IACtCorB,EAAoB,CAACD,EAAe,GAAIE,EAAiB,IACzD+nC,EAAgB,CAAC/nC,EAAiB,GAAIF,EAAe,IACrDK,EAAmB7I,EAAcyI,GACjCE,EAAe3I,EAAcywC,GAC7BpzD,EAAO,GAAKwrB,EACZxrB,EAAO,GAAKsrB,EACZ,MACJ,KAAK,EACL,KAAK,EACDF,EAAoBspB,EAAc10C,EAAO,IACzCozD,EAAgB1e,EAAc10C,EAAO,IACrCqrB,EAAmB,CACf+nC,EAAc,GACdhoC,EAAkB,IAEtBD,EAAiB,CAACC,EAAkB,GAAIgoC,EAAc,IACtD3nC,EAAkB9I,EAAc0I,GAChCE,EAAgB5I,EAAcwI,GAC9BnrB,EAAO,GAAKyrB,EACZzrB,EAAO,GAAKurB,EAGpBsZ,EAAW/3C,aAAc,EACzByE,KAAK29D,SAASuY,UAAW,GACzB,EAAAnf,EAAA,GAAsC8G,IAE1C79D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,cAAE0iC,EAAa,SAAEE,GAAal2E,KAAK29D,UAC/C,KAAEzwD,GAASomC,EACjB,GAAI0iC,IAAkBE,EAClB,OAEJhpE,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK0hE,gBAAgBvyC,IACrB,KAAAyuC,oBAAmBzuC,GACnB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,GACnC2mF,EAAgB,IACf91G,KAAK29D,SACRlvD,OAAQvB,EAAK+nD,QAAQxmD,OACrBknB,WAAY31B,KAAK21B,WAAWnlB,KAAKxQ,OAErCA,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,EACjBrhE,KAAK+1G,oBAAoBz6G,EAAgBw6G,GACzC91G,KAAKsvF,gBAETtvF,KAAKyhE,cAAiBtyC,IAClBA,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,eAEpDp9D,KAAK0hE,gBAAmBvyC,IACpBA,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,gBAExDriD,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,IAAK14D,KAAK29D,SACN,OAAOjF,EAEX,MAAM,SAAEx8D,GAAaZ,GACf,WAAEg4C,GAAetzC,KAAK29D,SACtBq4C,EAAe1iE,EAAWpsC,SAC1BytD,EAAgBrhB,EAAWqhB,cAC3BznD,EAAOomC,EAAWpmC,MAClB,OAAEuB,GAAWvB,EAAK+nD,QAClB+M,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAC7DtS,EAAQ,OAAO45G,EAAaP,aAAa/0G,MAAM,EAAG,MACxD,IAAKxE,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAOX,OAJA,IAAA0J,UAAYnK,EAAkBtD,EADT,IACsCqN,EAAkB,GAAIA,EAAkB,GAAI,CACnG5lE,UAEJs8D,GAAe,EACRA,EAEf,EAEJo8C,GAAsBlxD,SAAW,mB,4BCtNjC,MAAMqyD,WAA2BlB,GAAA,EAC7B,WAAAt1G,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXuoG,WAAY,CACRC,YAAa,MACbC,aAAc,MAElBC,gBAAiB,cACjBC,eAAgB,iBAGpB9zD,MAAMS,EAAWC,GACjBhiD,KAAKkkD,qBAAwB9B,IACzB,IAAuB,IAAnBpiD,KAAKqhE,UACL,OAEJ,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,MACzBivB,EAAY1sB,EAAcvqD,OAC1BH,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACrB0E,KAAKqhE,WAAY,EACjB,MAAM7+C,EAAStmB,EAASumB,aAClB,gBAAElB,EAAe,OAAEyjB,GAAWxiB,EAC9B6yF,EAA6B,GAAAC,mBAAA,sBAAyCp5G,EAASmN,IACrF,IAAKgsG,EACD,MAAM,IAAIj3G,MAAM,0EAEpB,MAAM,eAAEu+E,GAAmB04B,EACrBlE,EAAe,GAAAA,aAAA,sBAA6Cx0B,GAC5D44B,EAAiB,GAAAC,eAAA,wBAAuC74B,GACxD84B,EAAe,qCAA8Cv5G,EAASmN,GAAIszE,EAAgBw0B,IAC1F,mBAAEuE,IAAuB,KAAAC,iBAAgBh5B,GACzCi3B,EAAe8B,EAAmB74B,SACxC,IAAK+2B,EACD,MAAM,IAAIx1G,MAAM,6FAEpB,MAAMk1C,EAAa,CACf/3C,aAAa,EACbs5D,aAAa,EACb3tD,SAAU,CACNqa,gBAAiB,IAAIA,GACrByjB,OAAQ,IAAIA,GACZh7B,oBAAqB9N,EAASqlE,yBAC9Bh7D,kBAAmB,GACnBq9C,SAAU5jD,KAAKg1D,cACfygD,gBAEJvoG,KAAM,CACF+nD,QAAS,CACLxmD,OAAQ,CACJ,IAAI6S,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAER4zD,kBAAmB,MAEvB7T,WAAW,EACXG,YAAa,CAAC,IAGhB3D,EAAsB,CAAC3hE,EAASmN,IAiBtC,GAhBArJ,KAAK29D,SAAW,CACZrqB,aACAgxB,aAAcoO,EACdy+B,eACAx0B,iBACA44B,iBACAE,eACA53C,sBACAkY,YAAa,EACbya,eAAe,EACfxa,eAAe,EACfE,UAAU,EACVprE,SAAU,KACVw4B,mBAAoB,KACpBn/B,QAAS,MAETjI,aAAoB,EAAA6nE,mBAAoB,CACxC,MAAM,SAAEj5D,GAAa8oG,EACfjD,EAAe,EAAAr9E,MAAMxM,UAAUhc,GACrC9K,KAAK29D,SAAW,IACT39D,KAAK29D,SACR7yD,WACAw4B,mBAAoBqtE,EAAartE,mBAEzC,KACK,CACD,MAAMsyE,GAAsB,KAAAC,sCAAqC35G,EAASmN,GAAIszE,GAC9E38E,KAAK29D,SAAW,IACT39D,KAAK29D,SACRx5D,QAASyxG,EAEjB,CAKA,OAJA51G,KAAKyhE,cAActyC,IACnB,KAAAooC,mBAAkBpoC,GAClBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,IAC/B,GAEX79D,KAAKqiD,cAAiBD,IAClBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,cAAEi1B,GAAkBj1B,EACpBulD,EAAsBtwB,EAAcvqD,OACpCH,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,EAAe,SAAEzd,GAAaZ,GAChC,cAAE81B,GAAkBl1B,GACpB,WAAEo3C,EAAU,oBAAEuqB,EAAmB,aAAEyG,GAAiBtkE,KAAK29D,UACzD,KAAEzwD,GAASomC,EACXwhD,EAAK73F,KAAK6e,IAAIw6D,EAAoB,GAAKhS,EAAa,IACpDywB,EAAK93F,KAAK6e,IAAIw6D,EAAoB,GAAKhS,EAAa,IACpD5+B,EAASzoC,KAAKopC,KAAKyuD,EAAKA,EAAKC,EAAKA,GAClCC,EAAe,CACjB1wB,EAAa,GACbA,EAAa,GAAK5+B,GAEhBuvD,EAAY,CAAC3wB,EAAa,GAAIA,EAAa,GAAK5+B,GAChDwvD,EAAa,CACf5wB,EAAa,GAAK5+B,EAClB4+B,EAAa,IAEX6wB,EAAc,CAChB7wB,EAAa,GAAK5+B,EAClB4+B,EAAa,IAEjBp3D,EAAK+nD,QAAQxmD,OAAS,CAClB2iB,EAAc4jE,GACd5jE,EAAc6jE,GACd7jE,EAAc8jE,GACd9jE,EAAc+jE,IAElB7hD,EAAW/3C,aAAc,EACzByE,KAAK29D,SAASuY,UAAW,GACzB,EAAAnf,EAAA,GAAsC8G,IAE1C79D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,cAAE0iC,EAAa,SAAEE,GAAal2E,KAAK29D,UAC/C,KAAEzwD,GAASomC,GACX,gBAAE/xB,EAAe,OAAEyjB,GAAWsO,EAAWpsC,SAC/C,GAAI8uE,IAAkBE,EAClB,OAEJhpE,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK0hE,gBAAgBvyC,IACrB,KAAAyuC,oBAAmBzuC,GACnB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,GACnC2mF,EAAgB,IACf91G,KAAK29D,SACRlvD,OAAQvB,EAAK+nD,QAAQxmD,OACrB8S,kBACAyjB,SACArP,WAAY31B,KAAK21B,WAAWnlB,KAAKxQ,OAErCA,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,EACjBrhE,KAAK+1G,oBAAoBz6G,EAAgBw6G,GACzC91G,KAAKsvF,gBAETtvF,KAAKyhE,cAAiBtyC,IAClBA,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,eAEpDp9D,KAAK0hE,gBAAmBvyC,IACpBA,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,IAAK14D,KAAK29D,SACN,OAAOjF,EAEX,MAAM,SAAEx8D,GAAaZ,GACf,oBAAEuiE,GAAwB79D,KAAK29D,SACrC,IAAKE,EAAoBhjD,SAAS3e,EAASmN,IACvC,OAAOqvD,EAEX,MAAM,WAAEplB,GAAetzC,KAAK29D,SACtBq4C,EAAe1iE,EAAWpsC,SAC1BytD,EAAgBrhB,EAAWqhB,cAC3BznD,EAAOomC,EAAWpmC,MAClB,OAAEuB,GAAWvB,EAAK+nD,QAClB+M,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAC7Dw4E,EAASllB,EAAkB,GAC3BrtD,EAAMqtD,EAAkB,GACxBprD,EAAS,CACX3Z,KAAK+Q,OAAOk5E,EAAO,GAAKvyE,EAAI,IAAM,GAClC1X,KAAK+Q,OAAOk5E,EAAO,GAAKvyE,EAAI,IAAM,IAEhC+wB,EAASzoC,KAAK6e,IAAIorE,EAAO,GAAKjqF,KAAK+Q,OAAOk5E,EAAO,GAAKvyE,EAAI,IAAM,IAChEvY,EAAQ,OAAO45G,EAAaP,aAAa/0G,MAAM,EAAG,MACxD,IAAKxE,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAOX,OAJA,IAAAwD,YAAcjE,EAAkBtD,EADd,IACwC/9C,EAAQ8uB,EAAQ,CACtEtpC,UAEJs8D,GAAe,EACRA,EAEf,EAEJu9C,GAAmBryD,SAAW,gB,2BC7N9B,MAAMsyD,WAA2BnB,GAAA,EAC7B,WAAAt1G,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXuoG,WAAY,CACRC,YAAa,MACbC,aAAc,MAElBC,gBAAiB,cACjBC,eAAgB,iBAGpB9zD,MAAMS,EAAWC,GACjBhiD,KAAKkkD,qBAAwB9B,IACzB,IAAuB,IAAnBpiD,KAAKqhE,UACL,OAEJrhE,KAAKsvF,eACL,MAAMv+D,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,MACzBivB,EAAY1sB,EAAcvqD,OAC1BH,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACrB0E,KAAKqhE,WAAY,EACjB,MAAM7+C,EAAStmB,EAASumB,aAClB,gBAAElB,EAAe,OAAEyjB,GAAWxiB,EAC9B2zF,EAAmC,GAAAb,mBAAA,sBAAyCp5G,EAASmN,IAC3F,IAAK8sG,EACD,MAAM,IAAI/3G,MAAM,0EAEpB,MAAM,eAAEu+E,GAAmBw5B,EACrBhF,EAAe,GAAAA,aAAA,sBAA6Cx0B,GAC5D44B,EAAiB,GAAAC,eAAA,wBAAuC74B,GACxD84B,EAAe,qCAA8Cv5G,EAASmN,GAAIszE,EAAgBw0B,GAChGnxG,KAAKqhE,WAAY,EACjB,MAAM/tB,EAAa,CACfpsC,SAAU,CACNqa,gBAAiB,IAAIA,GACrByjB,OAAQ,IAAIA,GACZh7B,oBAAqB9N,EAASqlE,yBAC9Bh7D,kBAAmB,GACnBq9C,SAAU5jD,KAAKg1D,cACfygD,gBAEJvoG,KAAM,CACF3R,aAAa,EACb05D,QAAS,CACLxmD,OAAQ,CACJ,IAAI6S,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAER4zD,kBAAmB,MAEvB1T,YAAa,CAAC,EACd3M,aAAa,IAGfgJ,EAAsB,CAAC3hE,EAASmN,IACtCrJ,KAAK29D,SAAW,CACZrqB,aACAgxB,aAAcoO,EACdy+B,eACAx0B,iBACA44B,iBACAE,eACA/wD,YAAa1kD,KAAK0kD,YAClBmZ,sBACAkY,YAAa,EACbya,eAAe,EACfxa,eAAe,EACfE,UAAU,EACVprE,SAAU,KACVw4B,mBAAoB,KACpBn/B,QAAS,MAEb,MAAM,mBAAEuxG,IAAuB,KAAAC,iBAAgBh5B,GACzChf,EAAW39D,KAAKo2G,YAAY,CAC9Bl6G,WACAw5G,qBACAH,iBACA54B,mBAUJ,OARA38E,KAAK29D,SAAW,IACT39D,KAAK29D,YACLA,GAEP39D,KAAKyhE,cAActyC,IACnB,KAAAooC,mBAAkBpoC,GAClBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,IAC/B,GAEX79D,KAAKqiD,cAAiBD,IAClBpiD,KAAKqhE,WAAY,EACjB,MAAMtwC,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,cAAEi1B,GAAkBj1B,EACpBulD,EAAsBtwB,EAAcvqD,OACpCH,GAAiB,IAAAy/B,mBAAkB5L,IACnC,gBAAExV,EAAe,SAAEzd,GAAaZ,GAChC,cAAE81B,GAAkBl1B,GACpB,WAAEo3C,EAAU,oBAAEuqB,EAAmB,aAAEyG,GAAiBtkE,KAAK29D,UACzD,KAAEzwD,GAASomC,EACXwhD,EAAK73F,KAAK6e,IAAIw6D,EAAoB,GAAKhS,EAAa,IACpDywB,EAAK93F,KAAK6e,IAAIw6D,EAAoB,GAAKhS,EAAa,IACpD5+B,EAASzoC,KAAKopC,KAAKyuD,EAAKA,EAAKC,EAAKA,GAClCC,EAAe,CACjB1wB,EAAa,GACbA,EAAa,GAAK5+B,GAEhBuvD,EAAY,CAAC3wB,EAAa,GAAIA,EAAa,GAAK5+B,GAChDwvD,EAAa,CACf5wB,EAAa,GAAK5+B,EAClB4+B,EAAa,IAEX6wB,EAAc,CAChB7wB,EAAa,GAAK5+B,EAClB4+B,EAAa,IAEjBp3D,EAAK+nD,QAAQxmD,OAAS,CAClB2iB,EAAc4jE,GACd5jE,EAAc6jE,GACd7jE,EAAc8jE,GACd9jE,EAAc+jE,IAElB7hD,EAAW/3C,aAAc,EACzByE,KAAK29D,SAASuY,UAAW,GACzB,EAAAnf,EAAA,GAAsC8G,IAE1C79D,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,cAAE0iC,EAAa,SAAEE,EAAQ,aAAEi7B,EAAY,eAAEoE,GAAoBv1G,KAAK29D,UAC9E,KAAEzwD,GAASomC,GACX,gBAAE/xB,EAAe,OAAEyjB,GAAWsO,EAAWpsC,SAC/C,GAAI8uE,IAAkBE,EAClB,OAEJ5iC,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK0hE,gBAAgBvyC,IACrB,KAAAyuC,oBAAmBzuC,GACnB,MAAM7zB,GAAiB,IAAAy/B,mBAAkB5L,GACnC2mF,EAAgB,IACf91G,KAAK29D,SACRlvD,OAAQvB,EAAK+nD,QAAQxmD,OACrB0iG,eACAoE,iBACAh0F,kBACAyjB,SACArP,WAAY31B,KAAK21B,WAAWnlB,KAAKxQ,OAErCA,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,EACjBrhE,KAAK+1G,oBAAoBz6G,EAAgBw6G,GACzC91G,KAAKsvF,gBAETtvF,KAAKyhE,cAAiBtyC,IAClBA,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAOgsC,UAAWz9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,gBAErDriD,KAAK0hE,gBAAmBvyC,IACpBA,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOgsC,UAAWz9D,KAAKo9D,eAEvDp9D,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,IAAK14D,KAAK29D,SACN,OAAOjF,EAEX,MAAM,SAAEx8D,GAAaZ,GACf,oBAAEuiE,GAAwB79D,KAAK29D,SACrC,IAAKE,EAAoBhjD,SAAS3e,EAASmN,IACvC,OAAOqvD,EAEX,MAAM,WAAEplB,GAAetzC,KAAK29D,SACtBq4C,EAAe1iE,EAAWpsC,SAC1BytD,EAAgBrhB,EAAWqhB,cAC3BznD,EAAOomC,EAAWpmC,MAClB,OAAEuB,GAAWvB,EAAK+nD,QAClB+M,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAC7Dw4E,EAASllB,EAAkB,GAC3BrtD,EAAMqtD,EAAkB,GACxBprD,EAAS,CACX3Z,KAAK+Q,OAAOk5E,EAAO,GAAKvyE,EAAI,IAAM,GAClC1X,KAAK+Q,OAAOk5E,EAAO,GAAKvyE,EAAI,IAAM,IAEhC+wB,EAASzoC,KAAK6e,IAAIorE,EAAO,GAAKjqF,KAAK+Q,OAAOk5E,EAAO,GAAKvyE,EAAI,IAAM,IAChEvY,EAAQ,OAAO45G,EAAaP,aAAa/0G,MAAM,EAAG,MACxD,IAAKxE,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAOX,OAJA,IAAAwD,YAAcjE,EAAkBtD,EADd,IACwC/9C,EAAQ8uB,EAAQ,CACtEtpC,UAEJs8D,GAAe,EACRA,EAEf,EAEJw9C,GAAmBtyD,SAAW,gB,kBC3M9B,MAAQlf,sBAAqB,IAAK,YAClC,MAAM2xE,WAAuC,GACzC,WAAA52G,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXwrC,YAAY,EACZ+7C,gBAAgB,EAChBsiB,qBAAsB,GACtBC,6BAA6B,EAC7BjmB,aAAc,GACd4D,gBAAiB,GAAAC,qBACjBqiB,aAAa,EACbC,gBAAiB,OAGrBn1D,MAAMS,EAAWC,GACjBhiD,KAAKwkF,sBAAuB,EAC5BxkF,KAAK2+D,iBAAoBvc,IACrB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,MACzBnoD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,EAAQ,gBAAEyd,GAAoBre,EACtC0E,KAAKqhE,WAAY,EACjB,MAAM7+C,EAAStmB,EAASumB,aAClB,gBAAElB,EAAe,OAAEyjB,GAAWxiB,EACpC,IAAIjc,EAAmB8a,EAAavW,EACpC,GAAI5O,aAAoB,EAAA8+B,cACpB,MAAM,IAAI58B,MAAM,kCAEf,CACD,MAAMooB,EAAWxmB,KAAKszE,YAAYp3E,GAClC4O,EAAW,wBAAoB0b,GAC/BnF,EAAc,EAAAiS,MAAMxM,UAAUhc,GAC9BvE,EAAoB,8BAA0B8a,EAAaC,EAAUC,EACzE,CACA,MAAMm1F,EAAkB,wCAAoCr1F,EAAaE,GACnEo1F,EAAa32G,KAAK42G,oBAAoBt1F,EAAUo1F,EAAiBn1F,GACjEs1F,EAAW72G,KAAK82G,kBAAkBx1F,EAAUo1F,EAAiBn1F,GAC7DvX,EAAsB9N,EAASqlE,yBACrC,IAAI9yD,EAEAA,EADAzO,KAAKyM,cAAcwrC,WACV,CAAC,IAAI32B,GAAW,IAAIA,IAGpB,CACL,IAAIA,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAGZ,MAAMgyB,EAAa,CACfuhB,aAAa,EACbt5D,aAAa,EACb2L,SAAU,CACN08C,SAAU5jD,KAAKg1D,cACfzzC,gBAAiB,IAAIA,GACrByjB,OAAQ,IAAIA,GACZh7B,sBACAzD,oBACAuE,WACA4rG,kBACAp7G,kBAEJ4R,KAAM,CACF0mB,MAAO,GACPmjF,gBAAiBJ,EACjBK,cAAeH,EACf5hD,QAAS,CACL+vB,QAAS,CACL9O,UAAU,EACV+O,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChB7tD,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB6tD,YAAa,CAAC,EAAG,EAAG,KAG5B1wE,SACAymE,kBAAmB,MAEvB1T,YAAa,CACTy1C,eAAgB,GAChBC,iBAAkB,GAClBC,WAAY,IAEhBC,YAAa,OAGrBp3G,KAAKq3G,yBAAyB/jE,EAAYjyB,IAC1C,IAAAg0C,eAAc/hB,EAAYnkB,GAC1B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAWzE,OAVAh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAmY,eAAe,EACfE,UAAU,GAEdl2E,KAAKyhE,cAActyC,IACnB,KAAAooC,mBAAkBpoC,GAClBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GAC/BvqB,GAEXtzC,KAAKo9D,aAAgBhb,IACjB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,QAAE5F,GAAY4B,GACd,WAAEuiB,EAAU,oBAAEuqB,EAAmB,cAAEmY,EAAa,SAAEE,GAAal2E,KAAK29D,UACpE,KAAEzwD,GAASomC,EACjB,GAAI0iC,IAAkBE,EAClB,OAEJ5iC,EAAWuhB,aAAc,EACzB3nD,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK09D,kBAAkBvuC,GACvBnvB,KAAK0hE,gBAAgBvyC,IACrB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,SAAEjoB,GAAaosC,GACf,eAAEh4C,GAAmB4L,EAC3BlH,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,EACbrhE,KAAKwkF,sBACLxkF,KAAKyM,cAAc23E,4BACnB,IAAA1vB,kBAAiBphB,EAAWqhB,eAEhC,MAAMnuC,EAAWxmB,KAAKszE,YAAYh4E,EAAeY,UAC3CmlB,EAAc,EAAAiS,MAAMxM,UAAUN,EAASpkB,MAAM,gBAAgB,IACnEpC,KAAKs3G,2BAA2BhkE,EAAYjyB,EAAamF,EAAUlrB,IACnE,EAAAy7D,EAAA,GAAsC8G,GAClCmY,GACA,KAAArU,4BAA2BruB,IAG3B,KAAAE,2BAA0BF,EAAYnkB,IAG9CnvB,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,EACrB,IAAIi5D,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe94D,EAASizB,SAC9D,IAAKolC,GAAa3zD,OACd,OAAO83D,EAEXnE,GAAc,IAAAgjD,kCAAiChjD,EAAar4D,EAASumB,aACrE,MAAMs/C,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6qD,EAAY3zD,OAAQ8I,IAAK,CACzC,MAAM4pC,EAAaihB,EAAY7qD,IACzB,cAAEirD,EAAa,KAAEznD,EAAI,SAAEhG,GAAaosC,GACpC,gBAAEyjE,EAAe,cAAEC,GAAkB9pG,GACrC,OAAEuB,EAAM,kBAAEymE,GAAsBhoE,EAAK+nD,SACnC35D,eAAgBk8G,GAA6BtwG,EACrD66D,EAAepN,cAAgBA,EAC/B,MAAMT,EAAYl0D,KAAKy2E,SAAS,YAAa1U,EAAgBzuB,GACvDsoB,EAAW57D,KAAKy2E,SAAS,WAAY1U,EAAgBzuB,GACrDl3C,EAAQ4D,KAAKy2E,SAAS,QAAS1U,EAAgBzuB,GAC/C0uB,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAC7DkI,EAASorD,EAAkB,GAC3Bt8B,GAAS,KAAAowC,uBAAsB,CACjC9T,EAAkB,GAClBA,EAAkB,MAEhB,kBAAEiyB,GAAsBj0F,KAAKyM,cAC7BgpF,GAAgB,KAAA6B,wBAAuB,CACzCt1B,EAAkB,GAClBA,EAAkB,KAEhBr/C,EAAazmB,EAASumB,YAAYE,WAClC80F,EAAkBv7G,EAASumB,YAAYlB,gBAC7C,IAAIm2F,EAAsBX,EACtBY,EAAoBX,EACpBt4G,MAAMC,QAAQo4G,KACdW,EAAsB13G,KAAK43G,iCAAiCF,EAAqBD,GACjFvqG,EAAK6pG,gBAAkBW,GAEvBh5G,MAAMC,QAAQq4G,KACdW,EAAoB33G,KAAK43G,iCAAiCD,EAAmBF,GAC7EvqG,EAAK8pG,cAAgBW,GAEzB,MAAME,EAAyB,6BAA2B3qG,EAAK6pG,iBACzDe,EAAuB,6BAA2B5qG,EAAK8pG,eACvDe,EAAmB/3G,KAAK43G,iCAAiCj1F,EAAY80F,GACrEO,EAA0B,6BAA2BD,GAC3D,GAAIC,EACA/6G,KAAKa,IAAI+5G,EAAwBC,IACjCE,EACI/6G,KAAKkS,IAAI0oG,EAAwBC,GACrC,SAEJ,MAAMG,EAAmB,8BAA4B/qG,EAAK6pG,gBAAkB7pG,EAAK8pG,eAAiB,GAClG,IAAIkB,GAAgB,EAChBF,IAA4BC,IAC5BC,GAAgB,GAEpBhrG,EAAK+nD,QAAQxmD,OAAO,GAAGzO,KAAKm4G,yCAAyCV,IAAoBQ,EACzF,MAAMG,EAAoBZ,EAAyBt7G,UAAU6yE,UAAUp0D,SACvE,IAAK,MAAM7P,KAAYstG,EACf9kE,EAAW/3C,aACX+3C,EAAWpsC,SAAS4D,WAAaA,GACjC9K,KAAK6wF,+BAA+Bv9C,EAAYkkE,GAGxD,IAAKt7G,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,IAAIge,EACJ,KAAK,KAAAC,qBAAoBhiB,GACrB,SAaJ,IAXK,KAAAkD,oBAAmBlD,IACnB30D,KAAK29D,UACgB,OAAtBuX,IACAgjC,IAEIxhC,EADA12E,KAAKyM,cAAcwrC,WACQ,CAAC+pB,EAAkBkT,IAGnBlT,GAG/B0U,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAA7I,aAAe9V,EAAkBtD,EAAeiiB,EAAgBF,EAA0B,CACtFt6E,SAER,CACA,IAAIi8G,EAAiBnkD,EACjBokD,EAAgB18C,EAChBs8C,GACAG,EAAiBnkD,EACjBokD,EAAgB,IAGhBA,EAAgB,CAAC,EAAG,GAExB,MAAMr8C,EAAY,IAgBlB,IAfA,IAAAC,YAAcjE,EAAkBtD,EAAesH,EAAWrlD,EAAQ8uB,EAAQ,CACtEtpC,QACAw/D,SAAU08C,EACVpkD,UAAWmkD,IAEXpkB,EAAoB,GAChBvuD,EAAS,EAAIuuD,IACb,IAAA/3B,YAAcjE,EAAkBtD,EAAe,GAAGsH,WAAoBrlD,EAAQq9E,EAAmB,CAC7F73F,QACAw/D,WACA1H,cAIZwE,GAAe,EACX14D,KAAKyM,cAAc+pG,YAAa,CAChC,MAAMpyG,EAAUpE,KAAKuvF,sBAAsBxtB,EAAgBzuB,GAC3D,IAAKlvC,EAAQurB,WAAY,CACrBziB,EAAK+nD,QAAQ+vB,QAAU,CACnB9O,UAAU,EACV+O,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChB7tD,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB6tD,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA,MAAM6R,EAAYhxF,KAAKyM,cAAc6jF,aAAapjF,EAAM,CAAEhG,aAC1D,IAAK8pF,GAAkC,IAArBA,EAAUpwF,OACxB,SAEJ,IAAIqwF,EACC/jF,EAAK+nD,QAAQ+vB,QAAQ9O,WACtB+a,GAAsB,IAAAC,wBAAuBuE,GAC7CvoF,EAAK+nD,QAAQ+vB,QAAQC,cACjB/oF,EAASk1B,cAAc6/D,IAE/B,MAAME,EAAkBj1F,EAASinD,cAAcj2C,EAAK+nD,QAAQ+vB,QAAQC,eAC9DuK,EAAa,IACb4B,GAAc,IAAAC,mBAAqBp5B,EAAkBtD,EAAe66B,EAAYwB,EAAWG,EAAiB,CAACnvB,EAAkB,GAAIA,EAAkB,IAAK,CAAC,EAAG59D,IAC5J9G,EAAGilE,EAAM/kE,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWu0F,EAC3ClkF,EAAK+nD,QAAQ+vB,QAAQE,iBAAmB,CACpChG,QAAShjF,EAASk1B,cAAc,CAACmxC,EAAM5tD,IACvC0c,SAAUn1B,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,IAChD2c,WAAYp1B,EAASk1B,cAAc,CAACmxC,EAAM5tD,EAAM9X,IAChDsiF,YAAajjF,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,EAAM9X,IAEjE,CACJ,CACA,OAAO67D,GAEP14D,KAAKyM,cAAc8pG,4BACnBv2G,KAAK6wF,gCAAiC,EAAAS,EAAA,GAAStxF,KAAKu4G,0BAA2Bv4G,KAAKyM,cAAcgqG,gBAAiB,CAAEllB,UAAU,IAG/HvxF,KAAK6wF,gCAAiC,EAAA9V,EAAA,GAAS/6E,KAAKu4G,0BAA2Bv4G,KAAKyM,cAAcgqG,gBAE1G,CACA,wBAAAY,CAAyB/jE,EAAYjyB,GACjC,MAAM,KAAEnU,EAAI,SAAEhG,GAAaosC,GACrB,gBAAE/xB,EAAe,gBAAEm1F,GAAoBxvG,GACvC,gBAAE6vG,EAAe,cAAEC,GAAkB9pG,GACrC,OAAEuB,GAAWvB,EAAK+nD,QAClBujD,EAAsBx4G,KAAKm4G,yCAAyC52F,GACpEk3F,EAAa,WAAWhqG,EAAO,IACrCgqG,EAAWD,GAAuBzB,EAClC,MAAM2B,EAAW,WAAWjqG,EAAO,IACnCiqG,EAASF,GAAuBxB,EAChC,MAAM/uG,EAAY,cAClB,cAAcA,EAAWywG,EAAUD,GACnC,MAAMz8F,EAAW,YAAY/T,GAC7B,GAAiB,IAAb+T,EAAgB,CAChB,MAAM28F,EAAsBlqG,EAAOpI,IAAKqI,IACpC,MAAM48F,EAAW,WAAW58F,GAE5B,OADA48F,EAASkN,GAAuBzB,EACzBr4G,MAAM6D,KAAK+oG,KAGtB,YADAp+F,EAAKs0D,YAAY01C,iBAAmB,CAACyB,GAEzC,CACA,eAAe1wG,EAAWA,GAC1B,MAAM2wG,EAAiB,sBAAkBnqG,GACzCmqG,EAAe,GAAGJ,GAAuBzB,EACzC6B,EAAe,GAAGJ,GAAuBzB,EACzC,MAAM8B,EAAsB,GAC5B,IAAK,IAAIr7B,EAAO,EAAGA,GAAQxhE,EAAW,KAAMwhE,GAAQk5B,EAChDmC,EAAoBlwG,KAAKiwG,EAAevyG,IAAKiI,IACzC,MAAMg9F,EAAW,cAEjB,OADA,iBAAiBA,EAAUh9F,EAAOrG,EAAWu1E,GACtC9+E,MAAM6D,KAAK+oG,MAG1Bp+F,EAAKs0D,YAAY01C,iBAAmB2B,CACxC,CACA,0BAAAvB,CAA2BhkE,EAAYjyB,EAAamF,EAAUlrB,GAC1D,MAAM,KAAE4R,EAAI,SAAEhG,GAAaosC,GACrB,gBAAE/xB,EAAe,OAAEyjB,GAAW99B,GAC9B,SAAEhL,GAAaZ,EACf47G,EAAmBhqG,EAAKs0D,YAAY01C,iBACpC4B,EAAqB,CAAC,IACtBt9G,EAAQwE,KAAKogF,mBAAmB55D,GAChCw7C,EAAoB90D,EAAK+nD,QAAQxmD,OAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAC1EqqG,GAAoB,KAAAzhB,wBAAuB,CAC7Ct1B,EAAkB,GAClBA,EAAkB,KACnB,GACGg3C,GAAwB,KAAA1hB,wBAAuB,CACjDt1B,EAAkB,GAClBA,EAAkB,KACnB,GACGi3C,EAAW/8G,EAASk1B,cAAc2nF,GAClCG,EAAWh9G,EAASk1B,cAAc4nF,IAClC,WAAE7iB,EAAU,YAAEC,IAAgB,EAAAC,GAAA,GAAoC90E,EAAiByjB,EAAQi0E,EAAUC,GACrGC,GAAc,QAAiC39G,EAAO0R,EAAK+nD,QAAQxmD,QACnE8nF,GAAS,QAAoB/6F,GAC7Bo6F,EAAO34F,KAAK6e,IAAI7e,KAAKC,IACtBi5F,EAAagjB,EAAY38G,MAAQ,IACjC45F,EAAcG,EAAS4iB,EAAY38G,MAAQ,IAC1C48G,EAAsB,CACxB76G,aAAa,EAAA40F,GAAA,GAAoBj3F,EAAUsqB,GAC3C4sE,YAAapzF,KAAKozF,YAAYl3F,EAAUsqB,EAAU8sB,EAAWpsC,SAASX,oBAEpE+sF,GAAe,EAAAK,GAAA,GAAmBzsF,EAAS6gC,SAAUuL,EAAWpsC,SAASX,kBAAmB6yG,GAClG,IAAK,IAAI1vG,EAAI,EAAGA,EAAIwtG,EAAiBt2G,OAAQ8I,IAAK,CAC9C,IAAK2X,EACD,SAEJ,MAAMmkC,EAAc0xD,EAAiBxtG,GAAG,GAClC2vG,EAA2BnC,EAAiBxtG,GAAGrD,IAAKqI,GAAMxS,EAASinD,cAAcz0C,KAChFmzD,EAAehoC,IAAsB,KAAAy9D,wBAAuB,CAC/D+hB,EAAyB,GACzBA,EAAyB,KAEvBt/E,EAAe79B,EAASk1B,cAAcywC,GACtC5nC,EAAmB/9B,EAASk1B,cAAcyI,GAC1Cg4D,EAAY93D,EACZ+3D,EAAY73D,GACZ,WAAEpyB,EAAU,UAAE8c,EAAS,aAAE3f,GAAiBqc,EAC1Ci4F,EAAiB,GAAsB30F,EAAWktE,GAClD0nB,EAA4B,GAAsB50F,EAAW6gC,GAC7Dg0D,EAAoBx5G,KAAKm4G,yCAAyC52F,GACxE+3F,EAAe,GAAKr8G,KAAK+Q,MAAMsrG,EAAe,IAC9CA,EAAe,GAAKr8G,KAAK+Q,MAAMsrG,EAAe,IAC9CA,EAAe,GAAKr8G,KAAK+Q,MAAMsrG,EAAe,IAC9CA,EAAeE,GACXD,EAA0BC,GAC9B,MAAMC,EAAiB,GAAsB90F,EAAWmtE,GAMxD,GALA2nB,EAAe,GAAKx8G,KAAK+Q,MAAMyrG,EAAe,IAC9CA,EAAe,GAAKx8G,KAAK+Q,MAAMyrG,EAAe,IAC9CA,EAAe,GAAKx8G,KAAK+Q,MAAMyrG,EAAe,IAC9CA,EAAeD,GACXD,EAA0BC,GAC1Bx5G,KAAKgwF,gBAAgBspB,EAAgBG,EAAgB5xG,GAAa,CAClE,MAMMqN,EAAY,CACd,CAPSjY,KAAKa,IAAIw7G,EAAe,GAAIG,EAAe,IAC3Cx8G,KAAKkS,IAAImqG,EAAe,GAAIG,EAAe,KAOpD,CANSx8G,KAAKa,IAAIw7G,EAAe,GAAIG,EAAe,IAC3Cx8G,KAAKkS,IAAImqG,EAAe,GAAIG,EAAe,KAMpD,CALSx8G,KAAKa,IAAIw7G,EAAe,GAAIG,EAAe,IAC3Cx8G,KAAKkS,IAAImqG,EAAe,GAAIG,EAAe,MAOlDvjB,EAAa,CACft/E,OAFW4uC,EAGX+uC,QAASt3F,KAAK6e,IAAIie,EAAa,GAAKE,EAAiB,IAAM,EAC3Du6D,QAASv3F,KAAK6e,IAAIie,EAAa,GAAKE,EAAiB,IAAM,EAC3Dg8D,QAASh5F,KAAK6e,IAAIie,EAAa,GAAKE,EAAiB,IAAM,GAEzDoT,EAAgBroC,EAAa/D,QAAQjB,KAAKyM,cAAcynF,gBAAgBsC,cAAe,CACzFC,WAAavoD,IAAa,KAAAwoD,gBAAeR,EAAYhoD,GACrDh5B,YACAyP,YACAooB,aAAc/sC,KAAKyM,cAAcunF,iBAErC8kB,EAAmBnwG,KAAK0kC,EAC5B,CACJ,CACA,MAAM1xC,EAAQqE,KAAKyM,cAAcynF,gBAAgB0C,gBACjD1pF,EAAKs0D,YAAYy1C,eAAiB6B,EAClC5rG,EAAKs0D,YAAY21C,WAAa,CAC1BpvE,SAAU7gC,EAAS6gC,SACnB6tD,OACA1vD,KAAMvqC,EAAMuqC,MAAMjmC,MAClBkmC,OAAQxqC,EAAMwqC,QAAQlmC,MACtBkP,IAAKxT,EAAMwT,KAAKlP,MAChB42F,WAAYl7F,EAAMqR,MAClB2oF,SAAUwjB,EAAYxjB,SACtBrC,eAER,CACA,yBAAAilB,CAA0BjlE,EAAYh4C,GAClC,MAAM4R,EAAOomC,EAAWpmC,MAClB,SAAEhR,GAAaZ,GACf,YAAEkmE,GAAgBt0D,EAClBsZ,EAAWxmB,KAAKszE,YAAYp3E,GAC5BmlB,EAAc,EAAAiS,MAAMxM,UAAUN,EAASpkB,MAAM,gBAAgB,IAKnE,OAJApC,KAAKq3G,yBAAyB/jE,EAAYjyB,GAC1CrhB,KAAKs3G,2BAA2BhkE,EAAYjyB,EAAamF,EAAUlrB,GACnEg4C,EAAW/3C,aAAc,GACzB,KAAAi4C,2BAA0BF,EAAYp3C,EAASizB,SACxCqyC,CACX,CACA,mBAAAo1C,CAAoBt1F,EAAUo1F,EAAiBn1F,GAC3C,MAAM+0F,EAAuBt2G,KAAKyM,cAAc6pG,qBAC1CoD,EAAgCz8G,KAAKgmB,MAAMqzF,EAAuB,GAClEvU,EAAW,cACjB,iBAAiBA,EAAUzgF,EAAUC,EAAiBm4F,GAAiChD,GAEvF,OADmB12G,KAAK43G,iCAAiC7V,EAAUxgF,EAEvE,CACA,iBAAAu1F,CAAkBx1F,EAAUo1F,EAAiBn1F,GACzC,MAAM+0F,EAAuBt2G,KAAKyM,cAAc6pG,qBAC1CqD,EAA4BrD,EAAuBr5G,KAAKgmB,MAAMqzF,EAAuB,GACrFsD,EAAS,cACf,iBAAiBA,EAAQt4F,EAAUC,EAAiBo4F,EAA4BjD,GAEhF,OADiB12G,KAAK43G,iCAAiCgC,EAAQr4F,EAEnE,CACA,wCAAA42F,CAAyC52F,GACrC,MAAMs4F,EAAqB,CACvB58G,KAAK6e,IAAIyF,EAAgB,IACzBtkB,KAAK6e,IAAIyF,EAAgB,IACzBtkB,KAAK6e,IAAIyF,EAAgB,KAG7B,OADyBs4F,EAAmB72G,QAAQ/F,KAAKkS,OAAO0qG,GAEpE,CACA,gCAAAjC,CAAiCzkD,EAAK5xC,GAElC,OAAO4xC,EADkBnzD,KAAKm4G,yCAAyC52F,GAE3E,EAEJ,SAAS,GAAoBrU,EAAM4sG,EAAW,CAAC,GAC3C,MAAM7nB,EAAoB/kF,EAAKs0D,YAAY21C,YACrC,KAAEvhB,EAAI,KAAE1vD,EAAI,IAAE/2B,EAAG,OAAEg3B,EAAM,SAAEwvD,EAAQ,aAAErC,GAAiBrB,EAC5D,QAAaj0F,IAATkoC,EACA,OAEJ,MAAM8qD,EAAY,GAKlB,OAJAA,EAAUroF,KAAK,SAAS,wBAAoBitF,MAASD,KACrD3E,EAAUroF,KAAK,SAAS,wBAAoBu9B,MAASotD,KACrDtC,EAAUroF,KAAK,QAAQ,wBAAoBwG,MAAQmkF,KACnDtC,EAAUroF,KAAK,YAAY,wBAAoBw9B,MAAWmtD,KACnDtC,CACX,CACAqlB,GAA+BzyD,SAAW,6B,wCC7f1C,MAAQlf,sBAAqB,WAAS,IAAK,YAC3C,MAAMq1E,WAAsB,MACxB,WAAAt6G,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,WAErCX,MAAMS,EAAWC,GACjBhiD,KAAKkkD,qBAAwB9B,IACzB,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,MACzBnoD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACfknB,EAAStmB,EAASumB,aAClB,gBAAElB,GAAoBiB,EACtB2zF,EAAmC,GAAAb,mBAAA,sBAAyCp5G,EAASmN,IAC3F,IAAK8sG,EACD,MAAM,IAAI/3G,MAAM,0EAEpB,MAAM,eAAEu+E,GAAmBw5B,EACrBhF,EAAe,GAAAA,aAAA,sBAA6Cx0B,GAC5D44B,EAAiB,GAAAC,eAAA,wBAAuC74B,IACxD,mBAAE+4B,IAAuB,KAAAC,iBAAgBh5B,GAC/C,IAAI90E,EACAI,EACAO,EACAxD,EAEJ,GADAhF,KAAKsvF,eACDpzF,aAAoB,EAAA6nE,mBAAoB,CACxC,MAAM,SAAEj5D,GAAa4qG,EAAmB,EAAA94B,4BAA4BC,UAC9D8zB,EAAe,EAAAr9E,MAAMxM,UAAUhc,KAClCjD,aAAYI,aAAc0oG,GAC7B3rG,EAAe2rG,EAAa3rG,aAC5BwD,EAAQ,GAAsBmoG,EAAahsF,UAAWrD,EAC1D,KACK,CACD,MAAM04F,GAA6B,KAAAnE,sCAAqC35G,EAASmN,GAAIszE,GACrF,IAAKq9B,EACD,MAAM,IAAI57G,MAAM,kFAEpB,MAAM,UAAEumB,GAAczoB,EAASq8B,eAC/B1wB,EAAa8c,EAAUM,gBACvBhd,EAAY0c,EAAUE,eACtB,MAAMrpB,EAAQ,EAAA83B,MAAM8iB,SAAS4jE,GAC7Bh1G,EAAexJ,EAAMwJ,aACrBwD,EAAQ,GAAsBmc,EAAWrD,EAC7C,CACA,MAAM24F,EAAiBj6G,KAAKk6G,kBAAkB34F,EAAiBtZ,GAC/D,QAAuBjK,IAAnBi8G,EAEA,YADA7pG,QAAQC,KAAK,wCAGjB,MAAM,gBAAE8pG,EAAe,cAAEC,EAAa,+BAAEC,EAA8B,iBAAEC,EAAgB,oBAAEC,GAAyBv6G,KAAKw6G,gBAAgBx1G,EAAc6C,EAAYW,EAAOyxG,GACzK,GAAIzxG,EAAM,GAAK,GACXA,EAAM,IAAMX,EAAW,IACvBW,EAAM,GAAK,GACXA,EAAM,IAAMX,EAAW,IACvBW,EAAM,GAAK,GACXA,EAAM,IAAMX,EAAW,GACvB,OAEJ,MAAM4yG,EAAoBL,EAAc5xG,EAAM,GAAIA,EAAM,GAAIA,EAAM,IAClE,GAAI+sG,EAAe16F,SAAS4/F,GACxB,OAEJ,MAAMC,GAAkB,EAAAzmG,GAAA,GAAUkmG,EAAiBG,IAC7C,QAAEK,GAAYD,EACpBC,EAAQ15G,QAASuH,IACb,MAAMoyG,EAAkBP,EAA+B7xG,EAAM,GAAIA,EAAM,IACvExD,EAAa61G,WAAWD,EAAiBzJ,KAE7C,MAAM2J,EAAiB96G,KAAK+6G,kBAAkBd,EAAgBM,EAAqBG,GAEnF,OADA,KAAAM,iCAAgCr+B,EAAgBm+B,IACzC,GAEX96G,KAAK+6G,kBAAoB,CAACd,EAAgBM,EAAqBG,KAC3D,MAAQC,QAASM,GAAeP,EAChC,GAAuB,IAAnBT,EACA,MAAO,CAACM,GAEZ,IAAIW,EAAOvkG,IACPwkG,GAAQxkG,IACZ,IAAK,IAAIO,EAAI,EAAGA,EAAI+jG,EAAWr6G,OAAQsW,IAAK,CACxC,MAAMjF,EAAIgpG,EAAW/jG,GAAG,GACpBjF,EAAIipG,IACJA,EAAOjpG,GAEPA,EAAIkpG,IACJA,EAAOlpG,EAEf,CACA,MAAM6oG,EAAiB,GACvB,IAAK,IAAIl7C,EAAQs7C,EAAMt7C,GAASu7C,EAAMv7C,IAClCk7C,EAAenyG,KAAKi3D,GAExB,OAAOk7C,GAEX96G,KAAKw6G,gBAAkB,CAACx1G,EAAc6C,EAAYuzG,EAAanB,EAAiB,KAC5E,IAAIM,EACAD,EACJ,OAAQL,GACJ,KAAK,EACDM,EAAsBa,EAAY,GAClCd,EAAmB,CAACc,EAAY,GAAIA,EAAY,IAChD,MACJ,KAAK,EACDb,EAAsBa,EAAY,GAClCd,EAAmB,CAACc,EAAY,GAAIA,EAAY,IAChD,MACJ,KAAK,EACDb,EAAsBa,EAAY,GAClCd,EAAmB,CAACc,EAAY,GAAIA,EAAY,IAChD,MACJ,QACI,MAAM,IAAIh9G,MAAM,2BAA2B67G,KAEnD,MAGMG,EAAgB,CAAC98G,EAAGE,EAAGqR,IAClB7J,EAAaq2G,SAAS/9G,EAAGE,EAAGqR,GAEjCsrG,EAAkBn6G,KAAKs7G,wBAAwBzzG,EAAYoyG,EAAgBM,EAAqBH,GAEtG,MAAO,CACHC,+BAFmCr6G,KAAKu7G,uCAPd,CAACj+G,EAAGE,EAAGqR,IAC1B7J,EAAauO,QAAQ,CAACjW,EAAGE,EAAGqR,IAMmEorG,EAAgBM,GAGtHH,gBACAD,kBACAG,mBACAC,wBAGRv6G,KAAKs7G,wBAA0B,CAACzzG,EAAYoyG,EAAgBM,EAAqBH,KAC7E,IAAID,EACJ,OAAQF,GACJ,KAAK,EACDE,EAAkB,CAAC38G,EAAGqR,KAClB,KAAIrR,GAAKqK,EAAW,IAAMrK,EAAI,GAAKqR,GAAKhH,EAAW,IAAMgH,EAAI,GAG7D,OAAOurG,EAAcG,EAAqB/8G,EAAGqR,IAEjD,MACJ,KAAK,EACDsrG,EAAkB,CAAC78G,EAAGuR,KAClB,KAAIvR,GAAKuK,EAAW,IAAMvK,EAAI,GAAKuR,GAAKhH,EAAW,IAAMgH,EAAI,GAG7D,OAAOurG,EAAc98G,EAAGi9G,EAAqB1rG,IAEjD,MACJ,KAAK,EACDsrG,EAAkB,CAAC78G,EAAGE,KAClB,KAAIF,GAAKuK,EAAW,IAAMvK,EAAI,GAAKE,GAAKqK,EAAW,IAAMrK,EAAI,GAG7D,OAAO48G,EAAc98G,EAAGE,EAAG+8G,IAE/B,MACJ,QACI,MAAM,IAAIn8G,MAAM,2BAA2B67G,KAEnD,OAAOE,GAEXn6G,KAAKu7G,uCAAyC,CAACC,EAAuBvB,EAAgBM,KAClF,IAAIF,EACJ,OAAQJ,GACJ,KAAK,EACDI,EAAiC,CAAC78G,EAAGqR,IAC1B2sG,EAAsBjB,EAAqB/8G,EAAGqR,GAEzD,MACJ,KAAK,EACDwrG,EAAiC,CAAC/8G,EAAGuR,IAC1B2sG,EAAsBl+G,EAAGi9G,EAAqB1rG,GAEzD,MACJ,KAAK,EACDwrG,EAAiC,CAAC/8G,EAAGE,IAC1Bg+G,EAAsBl+G,EAAGE,EAAG+8G,GAEvC,MACJ,QACI,MAAM,IAAIn8G,MAAM,2BAA2B67G,KAEnD,OAAOI,EAEf,CACA,iBAAAH,CAAkB34F,EAAiBtZ,GAC/B,MAAMwzG,EAAaxzG,EAAUvH,MAAM,EAAG,GAChCg7G,EAAazzG,EAAUvH,MAAM,EAAG,GAChCi7G,EAAa1zG,EAAUvH,MAAM,EAAG,GAChCk7G,EAA4B,CAC9B3+G,KAAK6e,IAAIyF,EAAgB,IACzBtkB,KAAK6e,IAAIyF,EAAgB,IACzBtkB,KAAK6e,IAAIyF,EAAgB,KAEvBs6F,EAAuB,CACzB5+G,KAAK6e,IAAI2/F,EAAW,IACpBx+G,KAAK6e,IAAI2/F,EAAW,IACpBx+G,KAAK6e,IAAI2/F,EAAW,KAExB,GAAI,GAAQG,EAA2BC,GACnC,OAAO,EAEX,MAAMC,EAAuB,CACzB7+G,KAAK6e,IAAI4/F,EAAW,IACpBz+G,KAAK6e,IAAI4/F,EAAW,IACpBz+G,KAAK6e,IAAI4/F,EAAW,KAExB,GAAI,GAAQE,EAA2BE,GACnC,OAAO,EAEX,MAAMC,EAAuB,CACzB9+G,KAAK6e,IAAI6/F,EAAW,IACpB1+G,KAAK6e,IAAI6/F,EAAW,IACpB1+G,KAAK6e,IAAI6/F,EAAW,KAExB,OAAI,GAAQC,EAA2BG,GAC5B,OADX,CAGJ,EAEJhC,GAAcn2D,SAAW,Y,ICzNrBo4D,G,iDACJ,SAAWA,GACPA,EAAkBA,EAAkC,eAAI,GAAK,iBAC7DA,EAAkBA,EAAwB,KAAI,GAAK,OACnDA,EAAkBA,EAA0B,OAAI,GAAK,QACxD,CAJD,CAIGA,KAAsBA,GAAoB,CAAC,IAC9C,MAAMC,WAA8B,aACvBj8G,KAAKk8G,KAAO,CAAG,QACfl8G,KAAKm8G,KAAO,CAAG,QACfn8G,KAAKo8G,QAAU,CAAG,QAClBp8G,KAAKq8G,qBAAuBL,EAAmB,CACxD,WAAAv8G,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3Cv1C,cAAe,CACX6vG,kBAAmB,CACfxzD,SAAS,EACTyzD,eAAgB,MAA2BC,QAAQC,aACnDC,aAAc,IACdC,aAAc,IACdC,aAAc,KAElBC,kBAAmBZ,GAAsBI,qBAAqBS,eAC9DC,qBAAsB,CAClB,CAACd,GAAsBI,qBAAqBS,gBAAiB,CACzDE,eAAgB,CACZC,MAAO,CAAEC,KAAM,IAAKC,UAAW,UAAWC,aAAc,IACxDC,OAAQ,CAAEH,KAAM,IAAKC,UAAW,UAAWC,aAAc,KACzDE,MAAO,CACHJ,KAAM,IACNC,UAAW,UACXI,UAAW,QACXH,aAAc,KAElBI,OAAQ,CAAEN,KAAM,IAAKC,UAAW,UAAWI,UAAW,SACtDE,MAAO,CAAEP,KAAM,KACfQ,OAAQ,CAAER,KAAM,MAEpBS,aAAc,CACVC,UAAW,OACXl0B,WAAY,QACZ6zB,UAAW,QACXM,cAAgBC,GAAQA,EAAM,EAC9BX,UAAW,UACXY,cAAe,GACfC,UAAW,QACXvkE,WAAY,MAGpB,CAACwiE,GAAsBI,qBAAqB4B,MAAO,CAAC,EACpD,CAAChC,GAAsBI,qBAAqB6B,QAAS,CACjDC,YAAa,kJAKzB78D,MAAMS,EAAWC,GACjBhiD,KAAKgkD,iBAAmB,IAAIxyC,IAC5BxR,KAAK+pD,iBAAmB,KACpB/pD,KAAKo+G,gBACLp+G,KAAKq+G,8BAETr+G,KAAK4kD,gBAAkB,KACnB5kD,KAAKo+G,gBACLp+G,KAAKq+G,8BAETr+G,KAAKqlD,kBAAoB,KACrBrlD,KAAKs+G,cACLt+G,KAAKwwD,sCAETxwD,KAAKwkD,kBAAoB,KACH,IAAAC,cAAazkD,KAAK0kD,aAAaC,cAGrD3kD,KAAKy+E,OAAUvvD,IACX,MAAMqvF,EAAoBv+G,KAAKw+G,mBAAmBtvF,GAClD,IAAKqvF,EACD,OAEJ,MAAM,kBAAEjC,GAAsBiC,EAC9BjC,EAAkBmC,kBAEtBz+G,KAAKw+G,mBAAqB,CAAC,EAC3Bx+G,KAAK0+G,0BAA4B,CAAC,CACtC,CACA,kCAAAluD,GACI,MAAMmuD,EAAc,KACM3+G,KAAKwkD,oBACbvjD,QAAQ,EAAGiuB,aAAYhB,wBACjC,MAAM,SAAEhyB,IAAa,IAAA4oD,wBAAuB51B,EAAYhB,IAClD,QAAEiB,GAAYjzB,EACpBizB,EAAQrE,oBAAoB,EAAA8lB,MAAA,OAAajU,2BAA4B38B,KAAKo+G,cAAc5tG,KAAKxQ,OACtEA,KAAKgkD,iBAAiB5jD,IAAI8uB,GAClC0vF,UAAUzvF,MAGjC,EAAAyF,YAAY9J,oBAAoB,EAAA2G,OAAO2zB,yBAA2BhD,IAC1DA,EAAIrtB,OAAO2vB,cAAgB1kD,KAAK0kD,cAGpCi6D,IACA3+G,KAAKo+G,kBAEb,CACA,0BAAAC,GACI,MAAMx5D,EAA2B,KACP7kD,KAAKwkD,oBACbvjD,QAAQ,EAAGiuB,aAAYhB,wBACjC,MAAM,SAAEhyB,IAAa,IAAA4oD,wBAAuB51B,EAAYhB,IAClD,QAAEiB,GAAYjzB,EACpB8D,KAAKo+G,gBACLjvF,EAAQ1E,iBAAiB,EAAAmmB,MAAA,OAAajU,2BAA4B38B,KAAKo+G,cAAc5tG,KAAKxQ,OAC1F,MAAM+kD,EAAiB,IAAIC,eAAe,KACtCrzB,WAAW,KACP,MAAMxC,GAAU,IAAA21B,wBAAuB51B,EAAYhB,GACnD,IAAKiB,EACD,OAEJ,MAAM,SAAEjzB,GAAaizB,EACrBnvB,KAAKy+E,OAAOvvD,GACZhzB,EAASD,UACV,OAEP8oD,EAAeG,QAAQ/1B,GACvBnvB,KAAKgkD,iBAAiB9jD,IAAIgvB,EAAY61B,MAG9CF,IACA,EAAAjwB,YAAYnK,iBAAiB,EAAAgH,OAAO2zB,yBAA2BhD,IACvDA,EAAIrtB,OAAO2vB,cAAgB1kD,KAAK0kD,cAGpCG,IACA7kD,KAAKo+G,kBAEb,CACA,WAAAE,IAC6B,IAAAv/B,uBACgB,GACP3oD,eACxBn1B,QAAS/E,IACf,MAAMqiH,EAAoBv+G,KAAKw+G,mBAAmBtiH,EAASmN,IAC3D,IAAKk1G,EACD,OAEJ,MAAM,MAAEpoG,EAAK,kBAAEmmG,GAAsBiC,EACrCjC,GAAmBuC,YAAW,GAC9BvC,GAAmB94G,SACnB2S,GAAO3S,SACctH,EAChBiyB,qBACA2wF,8BAA8B5iH,EAASmN,IACvC01G,kBACQ9iH,SACbC,EAASiyB,qBAAqBlyB,gBACvB+D,KAAKw+G,mBAAmBtiH,EAASmN,KAEhD,CACA,aAAA+0G,GACI,MACMzkG,GADmB,IAAAolE,uBACgB,GACzC,IAAKplE,EACD,OAEJ,IAAIC,EAAYD,EAAgByc,eAChCxc,GAAY,IAAAolE,gCAA+BplE,EAAW5Z,KAAKg1D,eAC3Dp7C,EAAU3Y,QAAS/E,IACf,MAAM8iH,EAAS9iH,EAAS+iH,UAAUj/G,KAAKg1D,eAClCgqD,IAAUA,EAAOE,aAClBl/G,KAAKm/G,uBAAuBjjH,IAGxC,CACA,4BAAMijH,CAAuBjjH,GACzB,MAAMgzB,EAAahzB,EAASmN,GAC5B,IAAKrJ,KAAK0+G,0BAA0BxvF,GAAa,CAC7ClvB,KAAK0+G,0BAA0BxvF,IAAc,EAC7C,MAAMpoB,EAAO9G,KAAKyM,cAAcowG,kBAC1BE,EAAuB/8G,KAAKyM,cAAcswG,qBAAqBj2G,GACrE,GAAI9G,KAAKw+G,mBAAmBtvF,GAAa,CACrC,MAAM,MAAE/Y,EAAK,kBAAEmmG,GAAsBt8G,KAAKw+G,mBAAmBtvF,GAC7DhzB,EAAS4mD,cAAcs8D,YAAYjpG,GACnCmmG,EAAkBuC,YAAW,EACjC,CACA,IAAI1oG,EACS,IAATrP,EACAqP,EAAQnW,KAAKq/G,qBAAqBtC,GAEpB,IAATj2G,EACLqP,EAAQ,oBAEM,IAATrP,IACLqP,QAAcnW,KAAKs/G,qBAEvB,MAAMz8D,EAAW3mD,EAAS4mD,cACpBy8D,EAAerjH,EAChBiyB,qBACA2wF,8BAA8B5vF,GAC9B6vF,mBACC,QAAEj2D,EAAO,eAAEyzD,EAAc,aAAEG,EAAY,aAAEC,EAAY,aAAEC,GAAkB58G,KAAKyM,cAAc6vG,kBAC5FA,EAAoB,kBAAuC,CAC7DnmG,QACAqpG,WAAYD,EAAaE,gBACzBC,eAAgB78D,IAEpBy5D,EAAkBuC,WAAW/1D,GAC7BwzD,EAAkBqD,kBAAkBpD,GACpCD,EAAkBsD,gBAAgBlD,GAClCJ,EAAkBuD,gBAAgBlD,GAClCL,EAAkBwD,gBAAgBlD,GAClCN,EAAkByD,0BAClB//G,KAAKw+G,mBAAmBtvF,GAAc,CAClCotF,oBACAnmG,SAEJja,EAAS8jH,UAAUhgH,KAAKg1D,cAAesnD,GACvCiD,EAAatjH,SACbC,EAASiyB,qBAAqBlyB,SAC9B+D,KAAK0+G,0BAA0BxvF,IAAc,CACjD,CACJ,CACA,uBAAMowF,GACF,MAAMW,EAAMjgH,KAAKyM,cAAcswG,qBAAqBf,GAAkBkC,QACjEC,YACC+B,QAAiBC,MAAMF,GACvBG,QAAoBF,EAASE,cAC7BC,EAAY,oBAClBA,EAAUC,mBAAmBF,GAC7BC,EAAUxpC,SACV,MAAM/kC,EAAW,oBACjBA,EAASyuE,YAAYF,EAAU38B,iBAC/B5xC,EAAS7E,eAAeuzE,iBAAiB,SACzC,MAAMr8D,EAAS,oBACfA,EAAOgO,aAAargB,GACpBqS,EAAOs8D,8BACP,MAAMtqG,EAAQ,oBAGd,OAFAA,EAAMi8C,UAAUjO,GAChBhuC,EAAMuqG,QAAQ,KACPvqG,CACX,CACA,oBAAAkpG,CAAqBtC,GACjB,MAAM5mG,EAAQ,oBAoBd,OAnBAA,EAAMwqG,gBAAgB,IAAK5D,EAAqBY,eAChDxnG,EAAMyqG,qBAAqB,IACpB7D,EAAqBC,eAAeC,QAE3C9mG,EAAM0qG,sBAAsB,IACrB9D,EAAqBC,eAAeK,SAE3ClnG,EAAM2qG,qBAAqB,IACpB/D,EAAqBC,eAAeM,QAE3CnnG,EAAM4qG,sBAAsB,IACrBhE,EAAqBC,eAAeQ,SAE3CrnG,EAAM6qG,qBAAqB,IACpBjE,EAAqBC,eAAeS,QAE3CtnG,EAAM8qG,sBAAsB,IACrBlE,EAAqBC,eAAeU,SAEpCvnG,CACX,CACA,8BAAM+qG,GACF,MAAM70D,EAAO,qBACP,eAAE2wD,EAAc,aAAEW,GAAiB39G,KAAKyM,cAAc00G,cAM5D,OALA90D,EAAKs0D,gBAAgBhD,GACrB/9G,OAAO4B,KAAKw7G,GAAgB/7G,QAASd,IACjC,MAAMihH,EAAa,MAAMjhH,EAAIkhH,OAAO,GAAGnmD,cAAgB/6D,EAAIO,MAAM,iBACjE2rD,EAAK+0D,GAAYpE,EAAe78G,MAE7BksD,CACX,EAEJ4vD,GAAsBr4D,SAAW,oB,4BCnRjC,MAAM09D,WAA0B,aACnBthH,KAAKuhH,WAAa,CACvBC,OAAQ,SACRC,OAAQ,SACT,CACH,WAAAhiH,CAAYsiD,EAAY,CAAC,EAAGC,EAAmB,CAC3CC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXi1G,aAAc,IACdtmC,KAAMkmC,GAAkBC,WAAWE,OACnCE,aAAc,KAGlBrgE,MAAMS,EAAWC,GACjBhiD,KAAK03D,kBAAqBtV,IACtB,GAAIpiD,KAAKo7E,OAAS,EAAA1qC,UAAUH,OAU5B,OAPIvwC,KAAK4hH,YACLnQ,aAAazxG,KAAK4hH,YAEtB5hH,KAAK4hH,WAAajwF,WAAW,KACzB3xB,KAAK6hH,kBAAkBz/D,GACvBpiD,KAAK4hH,WAAa,MACnB5hH,KAAKyM,cAAci1G,eACf,GAEX1hH,KAAK+pD,iBAAmB,KACpB/pD,KAAK4kD,mBAET5kD,KAAK4kD,gBAAkB,KACnB5kD,KAAK4hH,WAAa,MAEtB5hH,KAAKqlD,kBAAoB,KACrBrlD,KAAK4hH,WAAa,MAEtB5hH,KAAK4hH,WAAa,IACtB,CACA,iBAAAC,CAAkBz/D,EAAM,CAAC,GACrB,GAAI,KAAM8a,sBACN,OAEJ,MAAM,QAAE/tC,EAAO,cAAE62B,GAAkB5D,EAAIrtB,OACjCsa,EAAa2W,EAAcvC,MAC3BnoD,GAAiB,IAAAy/B,mBAAkB5L,GACzC,IAAK7zB,EACD,OAEJ,MAAM,SAAEY,GAAaZ,EACfg6G,GAAqB,KAAAwM,uBAAsB5lH,EAASmN,IACrDisG,GAGLt1G,KAAK+hH,yBAAyBzM,EAAoBjmE,EAAYnzC,EAClE,CACA,wBAAA6lH,CAAyBzM,EAAoBjmE,EAAYnzC,GAErD,IADsBA,EAASq8B,eAE3B,OAEJ,MAAM,eAAEokD,EAAc,mBAAE+4B,GAAuBJ,EAC/C,IAAI0M,EAoBJ,GAnBIhiH,KAAKyM,cAAc2uE,OAASkmC,GAAkBC,WAAWC,OACzDQ,GAAsB,IAAAC,6BAA4BtlC,EAAgBttC,EAAY,CAC1EnzC,aAIAw5G,EAAmB74B,SACnBmlC,GAAsB,IAAAE,iCAAgCvlC,EAAgBttC,EAAY,CAC9EnzC,WACAylH,aAAc3hH,KAAKyM,cAAck1G,eAGhCjM,EAAmByM,QACxBH,GACI,IAAAI,yCAAwCzlC,GAEvC+4B,EAAmB2M,SAG3BL,GAA+C,IAAxBA,EACxB,QAEJ,KAAAM,uBAAsB3lC,EAAgBqlC,GACtC,MACMnoG,EADkB3d,EAASiyB,qBACGiI,eAAe/vB,IAAKoJ,GAAMA,EAAEpG,KAChE,KAAAk5G,6BAA4B5lC,IAC5B,EAAA5lB,EAAA,GAAsCl9C,EAC1C,EAEJynG,GAAkB19D,SAAW,oB,gBCzF7B,MAAM4+D,WAAiCC,GAAA,SAC1BziH,KAAK4jD,SAAW,sBAAwB,CACjD,WAAAnkD,CAAYsiD,EAAY,CAAC,GACrBT,MAAMS,GACN/hD,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,IAAIS,GAAe,EACnB,MAAM,SAAEx8D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACdgzB,EAAahzB,EAASmN,GAC5B,IAAIkrD,GAAc,IAAA4H,gBAAen8D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAGX,GADAnE,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAAO83D,EAEX,MAAMlyC,EAAWxmB,KAAKszE,YAAYp3E,GAC5Byd,EAAkBzd,EAASiyB,qBAC3B4zC,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6qD,EAAY3zD,OAAQ8I,IAAK,CACzC,MAAM4pC,EAAaihB,EAAY7qD,IACzB,cAAEirD,EAAa,KAAEznD,GAASomC,GAC1B,OAAE7kC,EAAM,kBAAEymE,GAAsBhoE,EAAK+nD,QACrC+M,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IACnEqzD,EAAepN,cAAgBA,EAC/B,MAAM,aAAEw8C,EAAY,eAAEx0B,GAAmBrpC,EAAWpsC,UAC9C,UAAEgtD,EAAS,SAAE0H,EAAQ,OAAEyM,GAAWroE,KAAKiiE,mBAAmB,CAC5D3uB,aACAyuB,mBAGE3lE,EAAQ,QADK,KAAAsmH,sBAAqBxzF,EAAYytD,EAAgBw0B,GACpCzwG,MAAM,EAAG,GAAGgtB,KAAK,QAajD,GAZKxgB,EAAKs0D,YAAYh7C,IACiB,MAAnCtZ,EAAKs0D,YAAYh7C,GAAUoqE,KAQtBt9C,EAAW/3C,aAChByE,KAAK6wF,+BAA+Bv9C,EAAY35B,EAAiBre,IARjE4R,EAAKs0D,YAAYh7C,GAAY,CACzB5lB,OAAQ,KACRhE,MAAO,KACPg0F,KAAM,MAEV5wF,KAAK8wF,sBAAsBx9C,EAAY35B,EAAiBre,KAKvDY,EAASiyB,qBAEV,OADA/d,QAAQC,KAAK,uCACNqoD,EAEX,IAAIge,EACJ,KAAK,KAAAC,qBAAoBhiB,GACrB,SAOJ,IALK,KAAAkD,oBAAmBlD,IACnB30D,KAAK29D,UACgB,OAAtBuX,IACAwB,EAA2B,CAAC1U,EAAkBkT,KAE9CwB,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAA7I,aAAe9V,EAAkBtD,EAAeiiB,EAAgBF,EAA0B,CACtFt6E,SAER,CACA,MAAMumH,EAAU,GAAGhuD,WACbiuD,EAAU,GAAGjuD,WACb8G,EAAU,KAChB,IAAAC,UAAYzD,EAAkBtD,EAAe8G,EAASuG,EAAkB,GAAIA,EAAkB,GAAI,CAC9F5lE,QACA83D,YACA0H,WACAyM,UACDs6C,GACH,MAAME,EAAgB,KACtB,IAAAnnD,UAAYzD,EAAkBtD,EAAekuD,EAAe7gD,EAAkB,GAAIA,EAAkB,GAAI,CACpG5lE,QACA83D,YACA0H,WACAyM,UACDu6C,GACHlqD,GAAe,EACf,MAAMt0D,EAAUpE,KAAKuvF,sBAAsBxtB,EAAgBzuB,GAC3D,IAAKlvC,EAAQurB,WAAY,CACrBziB,EAAK+nD,QAAQ+vB,QAAU,CACnB9O,UAAU,EACV+O,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChB7tD,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB6tD,YAAa,CAAC,EAAG,EAAG,KAG5B,QACJ,CACA/6E,EAAQhI,MAAQA,EAChB,MAAM40F,EAAYhxF,KAAKyM,cAAc6jF,aAAapjF,EAAMsZ,GACxD,IAAKwqE,GAAkC,IAArBA,EAAUpwF,OACxB,SAEJ,IAAIqwF,EACC/jF,EAAK+nD,QAAQ+vB,QAAQ9O,WACtB+a,GAAsB,IAAAC,wBAAuBlvB,GAC7C90D,EAAK+nD,QAAQ+vB,QAAQC,cACjB/oF,EAASk1B,cAAc6/D,IAE/B,MAAME,EAAkBj1F,EAASinD,cAAcj2C,EAAK+nD,QAAQ+vB,QAAQC,eAC9DuK,EAAa,IACb4B,GAAc,IAAAC,mBAAqBp5B,EAAkBtD,EAAe66B,EAAYwB,EAAWG,EAAiBnvB,EAAmB,CAAC,EAAG59D,IACjI9G,EAAGilE,EAAM/kE,EAAGmX,EAAG,MAAE/X,EAAK,OAAEC,GAAWu0F,EAC3ClkF,EAAK+nD,QAAQ+vB,QAAQE,iBAAmB,CACpChG,QAAShjF,EAASk1B,cAAc,CAACmxC,EAAM5tD,IACvC0c,SAAUn1B,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,IAChD2c,WAAYp1B,EAASk1B,cAAc,CAACmxC,EAAM5tD,EAAM9X,IAChDsiF,YAAajjF,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,EAAM9X,IAEjE,CACA,OAAO67D,EAEf,CACA,gBAAAiG,CAAiBvc,GACb,MAAMrxB,EAAcqxB,EAAIrtB,QAClB,cAAEixB,EAAa,QAAE72B,GAAY4B,EAC7BzP,EAAW0kC,EAAcvC,MACzBnoD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACrB0E,KAAKqhE,WAAY,EACjB,MAAM7+C,EAAStmB,EAASumB,aAClB,gBAAElB,EAAe,OAAEyjB,GAAWxiB,EAC9Bjc,EAAoBvG,KAAKshE,qBAAqBplE,EAAUolB,EAAUC,EAAiByjB,GACnFh7B,EAAsB9N,EAASqlE,yBAC/BjuB,EAAa,CACfuhB,aAAa,EACbt5D,aAAa,EACb2L,SAAU,CACN08C,SAAU5jD,KAAKg1D,cACfzzC,gBAAiB,IAAIA,GACrByjB,OAAQ,IAAIA,GACZh7B,sBACAzD,uBACGrK,EAASkgC,iBAAiB,CAAE3tB,OAAQ,CAAC6S,MAE5CpU,KAAM,CACF+nD,QAAS,CACLxmD,OAAQ,CACJ,IAAI6S,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,IAER0jE,QAAS,CACL9O,UAAU,EACV+O,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChB7tD,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB6tD,YAAa,CAAC,EAAG,EAAG,KAG5BjK,kBAAmB,MAEvBthD,MAAO,GACP4tC,YAAa,CAAC,KAGtB,IAAAnM,eAAc/hB,EAAYnkB,GAC1B,MAAM0uC,GAAsB,IAAAC,gCAA+B3uC,EAASnvB,KAAKg1D,eAazE,OAZAh1D,KAAK29D,SAAW,CACZrqB,aACAuqB,sBACAkY,YAAa,EACbya,eAAe,EACfxa,eAAe,EACfE,UAAU,GAEdl2E,KAAKyhE,cAActyC,IACnB,KAAAooC,mBAAkBpoC,GAClBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsC8G,GAC/BvqB,CACX,QACStzC,KAAKyvF,QAAU,CAACvgE,EAAYu2B,EAAMrhD,KACvC,MAAM9I,GAAiB,IAAAq9E,+BAA8BzpD,GACrD,IAAK5zB,EACD,OAEJ,MAAM,SAAEY,GAAaZ,EAEfwnH,GADsB,IAAArtC,qBACgB3gE,OAAQw+B,GAAgD,yBAAjCA,EAAWpsC,SAAS08C,UACjFm/D,EAAqBD,EAAgBplG,KAAM41B,IAC7C,MAAM,SAAEpsC,GAAaosC,EACrB,OAAIpsC,EAASiqG,eAAiB/sG,GAAS+sG,cACnCjqG,EAASy1E,iBAAmBv4E,GAASu4E,iBAKzComC,IACA,IAAAruD,kBAAiBquD,EAAmBpuD,eAExC,MAAM,oBAAE3qD,EAAmB,kBAAEzD,EAAiB,gBAAEgb,EAAe,SAAEklB,GAAczmC,KAAKwxF,YAAYgxB,GAA0BlnH,EAAgBmqD,EAAK,GAAIrhD,IAC5I4+G,EAAWC,GAAax9D,GACxBy9D,EAAQC,GAAUH,GAClBI,EAAQC,GAAUJ,EACnBx0G,EAAS,CAACy0G,EAAQC,EAAQC,EAAQC,IAClC,aAAE7mC,KAAiBiV,GAAwBrtF,GAAW,CAAC,EACvDkvC,EAAa,CACfqhB,cAAevwD,GAASuwD,eAAiB,EAAA3jB,UAAA,SACzC9jC,KAAM,CACF+nD,QAAS,CACLxmD,SACAymE,kBAAmB,KACnB8P,QAAS,CACL9O,UAAU,EACV+O,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChB7tD,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB6tD,YAAa,CAAC,EAAG,EAAG,MAIhC3d,YAAa,CAAC,GAElB3M,aAAa,EACb66B,eAAe,EACfn0F,aAAa,EACbmyF,UAAU,EACVC,WAAW,EACXzmF,SAAU,CACNiqG,aAAc/sG,GAAS+sG,aACvBx0B,eAAgBv4E,GAASu4E,eACzB/4B,SAAUnd,EAASuuB,cACnBzzC,kBACAvX,sBACAzD,uBACGkrF,IAKX,OAFA,IAAAp8B,eAAc/hB,EAAYp3C,EAASizB,UACnC,EAAA4nC,EAAA,GAAsC,CAAC76D,EAASmN,KACzCiqC,EACR,E,SC1PP,MAAMgwE,WAAyB,MAC3B,WAAA7jH,CAAYsiD,EAAY,CACpB70C,KAAM,CACF+nD,QAAS,CACL+vB,QAAS,CACLC,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChB7tD,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB6tD,YAAa,CAAC,EAAG,EAAG,QAKrCn9B,EAAmB,CAClBC,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CACXi1G,aAAc,IACdC,aAAc,EACdvlH,MAAO,KACPigC,WAAY,QAGhBilB,MAAMS,EAAWC,GACjBhiD,KAAK03D,kBAAqBtV,IAClBpiD,KAAK4hH,YACLnQ,aAAazxG,KAAK4hH,YAEtB5hH,KAAK4hH,WAAajwF,WAAW,KACzB3xB,KAAKujH,mBAAmBnhE,GACxBpiD,KAAK4hH,WAAa,MACnB5hH,KAAKyM,cAAci1G,eACf,GAEX1hH,KAAK+pD,iBAAmB,KACpB/pD,KAAK4kD,mBAET5kD,KAAK4kD,gBAAkB,KACnB5kD,KAAK4hH,WAAa,MAEtB5hH,KAAKqlD,kBAAoB,KACrBrlD,KAAK4hH,WAAa,MAEtB5hH,KAAKkN,KAAO60C,EAAU70C,MAAQ,CAC1B+nD,QAAS,CACL+vB,QAAS,CACLC,cAAe,CAAC,EAAG,EAAG,GACtBC,iBAAkB,CACdhG,QAAS,CAAC,EAAG,EAAG,GAChB7tD,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnB6tD,YAAa,CAAC,EAAG,EAAG,OAKpCn/E,KAAK4hH,WAAa,IACtB,CACA,kBAAA2B,CAAmBnhE,EAAM,CAAC,GACtB,GAAI,KAAM8a,sBACN,OAEJ,MAAM,QAAE/tC,EAAO,cAAE62B,GAAkB5D,EAAIrtB,OACjCsa,EAAa2W,EAAcvC,MAC3BnoD,GAAiB,IAAAy/B,mBAAkB5L,GACzC,IAAK7zB,EACD,OAEJ,MAAM,SAAEY,GAAaZ,EACfg6G,GAAqB,KAAAwM,uBAAsB5lH,EAASmN,IACrDisG,GAGLt1G,KAAKwjH,0BAA0BlO,EAAoBjmE,EAAYnzC,EACnE,CACA,yBAAAsnH,CAA0BlO,EAAoBjmE,EAAYnzC,GAEtD,IADsBA,EAASq8B,eAE3B,OAEJ,MAAM,eAAEokD,GAAmB24B,EACrB0M,GAAsB,IAAAC,6BAA4BtlC,EAAgBttC,EAAY,CAChFnzC,aAEEi2C,EAAUmjE,EAAmB5P,SAASsc,GACtC5lH,EAAQ4D,KAAKyM,cAAcrQ,OAC7B,qCAA8CF,EAASmN,GAAIszE,EAAgBqlC,GACzEpuF,EAAQue,GAASve,MACjBouC,EAAoB9lE,EAASinD,cAAc9T,GAOjD,GANArvC,KAAKyjH,UAAY,CACbzB,sBACA0B,oBAAqB9vF,EACrBouC,oBACA5lE,UAEC4lH,GAA+C,IAAxBA,EACxB,OAEJ,MACMnoG,EADkB3d,EAASiyB,qBACGiI,eAAe/vB,IAAKoJ,GAAMA,EAAEpG,KAChE,KAAAk5G,6BAA4B5lC,IAC5B,EAAA5lB,EAAA,GAAsCl9C,EAC1C,CACA,gBAAAm+C,CAAiB18D,EAAgB28D,GAC7B,IAAKj4D,KAAKyjH,UACN,OAEJ,MAAM,SAAEvnH,GAAaZ,GACf,oBAAE0mH,EAAmB,oBAAE0B,EAAmB,kBAAE1hD,EAAiB,MAAE5lE,GAAW4D,KAAKyjH,UACrF,IAAKzB,EACD,OAEJ,MACM7wB,EAAkB,CACpBnvB,EAAkB,IAFP,GAGXA,EAAkB,IAHP,IAKTovB,GAAc,IAAA3H,aAAexxB,EAAkB,+BAAgC,4BAA6B,CAACyrD,GAAuB,qBAAsBvyB,EAAiB,CAC7K/0F,MAAO,QAAQA,EAAM,OAAOA,EAAM,OAAOA,EAAM,OAAOA,EAAM,MAC5DigC,WAAYr8B,KAAKyM,cAAc4vB,iBAAcr+B,IAE3CukE,EAAOP,EAAkB,GACzBrtD,EAAMqtD,EAAkB,IACxB,MAAEplE,EAAK,OAAEC,GAAWu0F,EAC1BpxF,KAAKkN,KAAK+nD,QAAQ+vB,QAAQE,iBAAmB,CACzChG,QAAShjF,EAASk1B,cAAc,CAACmxC,EAAM5tD,IACvC0c,SAAUn1B,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,IAChD2c,WAAYp1B,EAASk1B,cAAc,CAACmxC,EAAM5tD,EAAM9X,IAChDsiF,YAAajjF,EAASk1B,cAAc,CAACmxC,EAAO3lE,EAAO+X,EAAM9X,IAEjE,EAEJymH,GAAiB1/D,SAAW,mB,gBCxI5B,MAAM+/D,WAAoCC,GAAA,SAC7B5jH,KAAK4jD,SAAW,yBAA2B,QAC3C5jD,KAAK6jH,yBAA2B,IAAIryG,GAAO,QAC3CxR,KAAK8jH,mBAAqB,EAAI,CACvC,WAAArkH,CAAYsiD,EAAY,CAAC,GAOrBT,MANqB,EAAAtQ,UAAA,UAAoB,CACrCvkC,cAAe,CACXy+E,gBAAgB,EAChB64B,mBAAmB,IAExBhiE,IAEH/hD,KAAKgkH,iCACDhkH,KAAKikH,2BAA2BzzG,KAAKxQ,MACzCA,KAAKkkH,6BAA+BlkH,KAAKmkH,uBAAuB3zG,KAAKxQ,KACzE,CACA,mBAAAo9F,GACIumB,GAA4BE,yBAAyB/vG,QACrD6vG,GAA4BG,mBAAqB,GACjD,EAAAlvF,YAAYnK,iBAAiB,EAAAgH,OAAO4pE,oBAAqBr7F,KAAKokH,oBAC9D,EAAAxvF,YAAYnK,iBAAiB,EAAAgH,OAAO2pE,qBAAsBp7F,KAAKg9F,qBAC/D,EAAApoE,YAAYnK,iBAAiB,EAAAgH,OAAO2zB,yBAA0BplD,KAAKgkH,kCACnE,EAAApvF,YAAYnK,iBAAiB,EAAAgH,OAAO4yF,sBAAuBrkH,KAAKkkH,8BAChE,EAAAtvF,YAAYnK,iBAAiB,EAAAgH,OAAO6yF,qCAAsCtkH,KAAKkkH,6BACnF,CACA,gBAAAK,GACIZ,GAA4BE,yBAAyB/vG,QACrD6vG,GAA4BG,mBAAqB,GACjD,EAAAlvF,YAAY9J,oBAAoB,EAAA2G,OAAO4pE,oBAAqBr7F,KAAKokH,oBACjE,EAAAxvF,YAAY9J,oBAAoB,EAAA2G,OAAO2pE,qBAAsBp7F,KAAKg9F,qBAClE,EAAApoE,YAAY9J,oBAAoB,EAAA2G,OAAO2zB,yBAA0BplD,KAAKikH,2BAA2BzzG,KAAKxQ,OACtG,EAAA40B,YAAY9J,oBAAoB,EAAA2G,OAAO4yF,sBAAuBrkH,KAAKmkH,uBAAuB3zG,KAAKxQ,OAC/F,EAAA40B,YAAY9J,oBAAoB,EAAA2G,OAAO6yF,qCAAsCtkH,KAAKmkH,uBAAuB3zG,KAAKxQ,MAClH,CACA,8BAAMwkH,CAAyBt1F,GAC3B,GAAIy0F,GAA4BG,mBAAmBjpG,SAASqU,GACxD,OAEJ,MAAMu1F,EAAY,yBAAmCv1F,GACrD,IAAKu1F,EAED,OADAr0G,QAAQ6Q,IAAI,oCACL,EAEX,MAAM07D,EAAiB8nC,EAAU9nC,eAkBjC,OAjBK8nC,EAAU/O,mBAAmByM,QAe9BwB,GAA4BG,mBAAmBn7G,KAAKumB,IAdpDy0F,GAA4BG,mBAAmBn7G,KAAKumB,SAC9C,sCAAgDA,EAAY,CAC9D,CACIytD,iBACA71E,KAAM,EAAA81E,4BAA4BulC,WAG1C,yBAAmC,CAC/BxlC,iBACA71E,KAAM,EAAA81E,4BAA4BulC,QAClCj1G,KAAM,CAAC,MAMR,CACX,CACA,0BAAA+2G,CAA2B7hE,GACvB,MAAM,YAAEsC,EAAW,WAAEx1B,GAAekzB,EAAIrtB,OACpC2vB,IAAgB1kD,KAAK0kD,aAGzB1kD,KAAKwkH,yBAAyBt1F,EAClC,CACA,sBAAAi1F,CAAuB/hE,GACnB,MAAM,eAAEu6B,GAAmBv6B,EAAIrtB,QAAU,CAAC,EAC1C,IAAK4nD,EACD,OAEJ,MAAM+nC,GAAkB,EAAAC,GAAA,IAA+ChoC,GAClE+nC,GAGLA,EAAgBzjH,QAAQ46B,OAAS3M,sBAAuBlvB,KAAKwkH,yBAAyBt1F,GAC1F,CACA,gBAAA66B,GACI/pD,KAAKo9F,qBACT,CACA,eAAAx4C,GACI5kD,KAAKo9F,qBACT,CACA,iBAAA/3C,GACIrlD,KAAKukH,kBACT,CACA,kBAAAH,CAAmBhiE,GACf,MAAM,WAAE9O,EAAU,kBAAEplB,EAAiB,WAAEgB,GAAekzB,EAAIrtB,OACpD74B,GAAW,IAAAiyB,oBAAmBD,IAAoBkC,YAAYlB,GAC/DhzB,GAGLynH,GAA4BE,yBAAyB3jH,IAAIozC,EAAWqhB,cAAez4D,EACvF,CACA,mBAAA8gG,CAAoB56C,GAChB,MAAM,WAAE9O,GAAe8O,EAAIrtB,QACrB,SAAEojB,GAAa7E,EAAWpmC,MAAMqlC,SAAW,CAAC,EAClD,GAAIe,GAAYpsC,UAAU08C,WAAa+/D,GAA4B//D,UAG9DzL,GAGDwrE,GAA4BE,yBAAyBxgH,IAAIiwC,EAAWqhB,eAAgB,CACpF,MAAMz4D,EAAWynH,GAA4BE,yBAAyBzjH,IAAIkzC,EAAWqhB,eACjFxc,EAASv3C,OAAS,GAClBgkH,GAAA,EAAUC,2BAA2B3oH,EAE7C,CACJ,E,gBC1GJ,MAAM4oH,WAA2B,aACpB9kH,KAAK4jD,SAAW,gBAAkB,CAC3C,WAAAnkD,CAAYslH,EAAoB,CAAC,GAC7BzjE,MAAMyjE,EAAmB,CACrB9iE,0BAA2B,CAAC,QAAS,SACrCx1C,cAAe,CAAE47D,QAAQ,EAAM+b,2BAA2B,KAE9DpkF,KAAK2+D,iBAAoBvc,IACrB,MAAM5f,EAAY4f,EAAIrtB,QAChB,cAAEixB,EAAa,QAAE72B,GAAYqT,EAC7BlhB,EAAW0kC,EAAcvC,MACzBnoD,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,EACrB0E,KAAKqhE,WAAY,EACjB,MAAM/tB,EAActzC,KAAgB,YAAE2yF,4BAA4Bz2F,EAAU,CACxEgR,KAAM,CACF+nD,QAAS,CACLxmD,OAAQ,CACJ,IAAI6S,GACJ,IAAIA,GACJ,IAAIA,GACJ,IAAIA,SAKpB,QAAcgyB,EAAYnkB,GAC1B,MAAM61F,GAAuB,IAAAlnD,gCAA+B3uC,EAASnvB,KAAKg1D,eAAe,GAYzF,OAXAh1D,KAAK29D,SAAW,CACZrqB,aACA0xE,uBACAjvC,YAAa,EACbC,eAAe,EACfE,UAAU,GAEdl2E,KAAKyhE,cAActyC,IACnB,KAAAooC,mBAAkBpoC,GAClBizB,EAAIoV,kBACJ,EAAAT,EAAA,GAAsCiuD,GAC/B1xE,GAEXtzC,KAAKwqE,wBAA0B,CAACr7C,EAASmkB,EAAY2jB,EAAcC,KAC/D,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,KAAE4R,GAASomC,GACX,OAAE7kC,GAAWvB,EAAK+nD,QACxB,IAAK,IAAIvrD,EAAI,EAAGA,EAAI+E,EAAO7N,OAAQ8I,IAAK,CACpC,MAAM4E,EAAQG,EAAO/E,GACfu7G,EAA2B/oH,EAASinD,cAAc70C,GAExD,IAAa,IADA,cAAc2oD,EAAcguD,GAA4B/tD,EAGjE,OADAhqD,EAAK+nD,QAAQigB,kBAAoBxrE,EAC1B4E,CAEf,CACApB,EAAK+nD,QAAQigB,kBAAoB,MAErCl1E,KAAKg3D,gBAAkB,CAAC7nC,EAASmkB,EAAY2jB,EAAcC,KACvD,MAAM57D,GAAiB,IAAAy/B,mBAAkB5L,IACnC,SAAEjzB,GAAaZ,GACf,KAAE4R,GAASomC,GACX,OAAE7kC,GAAWvB,EAAK+nD,QAClBw7B,EAAev0F,EAASinD,cAAc10C,EAAO,IAC7CiiF,EAAex0F,EAASinD,cAAc10C,EAAO,IAC7Cy2G,EAAOllH,KAAKmlH,8BAA8B,CAC5C10B,EACAC,IAEEpiF,EAAQ,CAAC2oD,EAAa,GAAIA,EAAa,KACvC,KAAEsL,EAAI,IAAE5tD,EAAG,MAAE/X,EAAK,OAAEC,GAAWqoH,EAErC,GADwBE,GAAUroE,gBAAgB,CAACwlB,EAAM5tD,EAAK/X,EAAOC,GAASyR,IACvD4oD,EACnB,OAAO,GAGfl3D,KAAKo3D,qBAAuB,CAAChV,EAAK9O,EAAY+jB,EAAkB,WAC5D,MAAM70B,EAAY4f,EAAIrtB,QAChB,QAAE5F,GAAYqT,GACd,KAAEt1B,GAASomC,EACjBpmC,EAAKm4G,QAAS,EACd,MAAML,GAAuB,IAAAlnD,gCAA+B3uC,EAASnvB,KAAKg1D,eAAe,GACzFh1D,KAAK29D,SAAW,CACZrqB,aACA0xE,wBAEJhlH,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,IAClB,EAAA4nC,EAAA,GAAsCiuD,GACtC5iE,EAAIoV,kBAERx3D,KAAK8+D,uBAAyB,CAAC1c,EAAK9O,EAAYyrB,EAAQ1H,EAAkB,WACtE,MAAM70B,EAAY4f,EAAIrtB,QAChB,QAAE5F,GAAYqT,GACd,KAAEt1B,GAASomC,EACjBpmC,EAAKm4G,QAAS,EACd,IACItvC,EADAya,GAAgB,EAEhBzxB,EAAOkmB,cACPuL,GAAgB,EAGhBza,EAAc7oE,EAAK+nD,QAAQxmD,OAAO+D,UAAW9D,GAAMA,IAAMqwD,GAE7D,MAAMimD,GAAuB,IAAAlnD,gCAA+B3uC,EAASnvB,KAAKg1D,eAAe,GACzFh1D,KAAK29D,SAAW,CACZrqB,aACA0xE,uBACAjvC,eAEJ/1E,KAAKs3D,gBAAgBnoC,IACrB,KAAAooC,mBAAkBpoC,IAClB,EAAA4nC,EAAA,GAAsCiuD,GACtC5iE,EAAIoV,kBAERx3D,KAAKo9D,aAAgBhb,IACjB,MAAM5f,EAAY4f,EAAIrtB,QAChB,QAAE5F,GAAYqT,GACd,WAAE8Q,EAAU,qBAAE0xE,EAAoB,cAAEhvC,EAAa,SAAEE,GAAal2E,KAAK29D,UACrE,KAAEzwD,GAASomC,EACb0iC,IAAkBE,IAGtBl2E,KAAKsvF,eACLpiF,EAAKm4G,QAAS,EACdn4G,EAAK+nD,QAAQigB,kBAAoB,KACjCl1E,KAAK09D,kBAAkBvuC,GACvBnvB,KAAK0hE,gBAAgBvyC,IACrB,KAAAyuC,oBAAmBzuC,GACnBnvB,KAAK29D,SAAW,KAChB39D,KAAKqhE,WAAY,EACbrhE,KAAKwkF,sBACLxkF,KAAKyM,cAAc23E,4BACnB,QAAiB9wC,EAAWqhB,gBAEhC,EAAAoC,EAAA,GAAsCiuD,KAE1ChlH,KAAKqiD,cAAiBD,IAClBpiD,KAAKqhE,WAAY,EACjB,MAAM7+B,EAAY4f,EAAIrtB,QAChB,QAAE5F,GAAYqT,GACd,WAAE8Q,EAAU,qBAAE0xE,EAAoB,YAAEjvC,EAAW,cAAEC,GAAkBh2E,KAAK29D,SAC9E39D,KAAK21B,WAAWxG,EAASmkB,EAAY,CAAE0iC,kBACvC,MAAM,KAAE9oE,GAASomC,EACjB,QAAoBt1C,IAAhB+3E,EAA2B,CAC3B,MAAM,YAAExyB,GAAgB/gB,EAClBmuD,EAAgBptC,EAAYE,OAC5B,OAAEh1C,GAAWvB,EAAK+nD,QACxBxmD,EAAOxN,QAASqN,IACZA,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,GAC1BriF,EAAM,IAAMqiF,EAAc,KAE9BzjF,EAAK3R,aAAc,CACvB,KACK,CACD,MAAM,cAAEyqD,GAAkBxjB,EACpBlnC,GAAiB,IAAAy/B,mBAAkB5L,IACnC,cAAEg0B,EAAa,cAAE/xB,GAAkB91B,EAAeY,SAClDolB,EAAW0kC,EAAcvC,OACzB,OAAEh1C,GAAWvB,EAAK+nD,QAExB,IAAIn7B,EACAD,EACAgoC,EACAjoC,EACAM,EACAD,EACAF,EACAC,EACJ,OATAvrB,EAAOsnE,GAAe,IAAIz0D,GASlBy0D,GACJ,KAAK,EACL,KAAK,EACDj8C,EAAmBqpB,EAAc10C,EAAO,IACxCmrB,EAAiBupB,EAAc10C,EAAO,IACtCorB,EAAoB,CAACD,EAAe,GAAIE,EAAiB,IACzD+nC,EAAgB,CAAC/nC,EAAiB,GAAIF,EAAe,IACrDK,EAAmB7I,EAAcyI,GACjCE,EAAe3I,EAAcywC,GAC7BpzD,EAAO,GAAKwrB,EACZxrB,EAAO,GAAKsrB,EACZ,MACJ,KAAK,EACL,KAAK,EACDF,EAAoBspB,EAAc10C,EAAO,IACzCozD,EAAgB1e,EAAc10C,EAAO,IACrCqrB,EAAmB,CACf+nC,EAAc,GACdhoC,EAAkB,IAEtBD,EAAiB,CACbC,EAAkB,GAClBgoC,EAAc,IAElB3nC,EAAkB9I,EAAc0I,GAChCE,EAAgB5I,EAAcwI,GAC9BnrB,EAAO,GAAKyrB,EACZzrB,EAAO,GAAKurB,EAGpB9sB,EAAK3R,aAAc,CACvB,CACAyE,KAAK29D,SAASuY,UAAW,GACF,IAAAn7C,mBAAkB5L,IACzC,EAAA4nC,EAAA,GAAsCiuD,IAE1ChlH,KAAKyhE,cAAiBtyC,IAClB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAOqwC,WAAY9hE,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,gBAErDriD,KAAK0hE,gBAAmBvyC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAOqwC,WAAY9hE,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,gBAExDriD,KAAKs3D,gBAAmBnoC,IACpB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQ1E,iBAAiB,EAAAgH,OAAO0rC,SAAUn9D,KAAKo9D,cAC/CjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO4rC,WAAYr9D,KAAKqiD,eACjDlzB,EAAQ1E,iBAAiB,EAAAgH,OAAO6rC,YAAat9D,KAAKo9D,cAClDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO8rC,UAAWv9D,KAAKo9D,cAChDjuC,EAAQ1E,iBAAiB,EAAAgH,OAAO+rC,WAAYx9D,KAAKqiD,gBAErDriD,KAAK09D,kBAAqBvuC,IACtB,KAAM+tC,uBAAwB,EAC9B/tC,EAAQrE,oBAAoB,EAAA2G,OAAO0rC,SAAUn9D,KAAKo9D,cAClDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO4rC,WAAYr9D,KAAKqiD,eACpDlzB,EAAQrE,oBAAoB,EAAA2G,OAAO6rC,YAAat9D,KAAKo9D,cACrDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO8rC,UAAWv9D,KAAKo9D,cACnDjuC,EAAQrE,oBAAoB,EAAA2G,OAAO+rC,WAAYx9D,KAAKqiD,gBAExDriD,KAAKg4D,iBAAmB,CAAC18D,EAAgB28D,KACrC,MAAMS,GAAe,GACf,SAAEx8D,GAAaZ,GACf,QAAE6zB,GAAYjzB,EACpB,IAAIq4D,GAAc,QAAev0D,KAAKg1D,cAAe7lC,GACrD,IAAKolC,GAAa3zD,OACd,OAAO83D,EAGX,GADAnE,EAAcv0D,KAAKy0D,wCAAwCtlC,EAASolC,IAC/DA,GAAa3zD,OACd,OAAO83D,EAEX,MAAMqJ,EAAiB,CACnBrd,YAAa1kD,KAAK0kD,YAClBd,SAAU5jD,KAAKg1D,cACf9lC,WAAY5zB,EAAeY,SAASmN,IAExC,IAAK,IAAIK,EAAI,EAAGA,EAAI6qD,EAAY3zD,OAAQ8I,IAAK,CACzC,MAAM4pC,EAAaihB,EAAY7qD,IACzB,cAAEirD,GAAkBrhB,EACpBpmC,EAAOomC,EAAWpmC,MAClB,OAAEuB,EAAM,kBAAEymE,GAAsBhoE,EAAK+nD,QACrC+M,EAAoBvzD,EAAOpI,IAAKqI,GAAMxS,EAASinD,cAAcz0C,IAC7DwlD,EAAYl0D,KAAKy2E,SAAS,YAAa1U,EAAgBzuB,GACvDsoB,EAAW57D,KAAKy2E,SAAS,WAAY1U,EAAgBzuB,GACrDl3C,EAAQ4D,KAAKy2E,SAAS,QAAS1U,EAAgBzuB,GACrD,IAAKp3C,EAASiyB,qBAEV,YADA/d,QAAQC,KAAK,uCAGjB,IAAIqmE,EAKJ,GAJK12E,KAAK29D,UACgB,OAAtBuX,IACAwB,EAA2B,CAAC1U,EAAkBkT,KAE9CwB,EAA0B,CAC1B,MAAME,EAAiB,KACvB,IAAA7I,aAAe9V,EAAkBtD,EAAeiiB,EAAgBF,EAA0B,CACtFt6E,SAER,CACA,MAAM+lE,EAAe,KACrB,IAAAmjD,mBAAqBrtD,EAAkBtD,EAAewN,EAAcH,EAAkB,GAAIA,EAAkB,GAAI,CAC5G5lE,MAAO,QACPw/D,WACA1H,aAER,GAEJl0D,KAAKmlH,8BAAiC12G,IAClC,MAAO82G,EAAQ3zD,GAAUnjD,EACzB,MAAO,CACH8zD,KAAMtlE,KAAKa,IAAIynH,EAAO,GAAI3zD,EAAO,IACjCj9C,IAAK1X,KAAKa,IAAIynH,EAAO,GAAI3zD,EAAO,IAChCh1D,MAAOK,KAAK6e,IAAIypG,EAAO,GAAK3zD,EAAO,IACnC/0D,OAAQI,KAAK6e,IAAIypG,EAAO,GAAK3zD,EAAO,MAG5C5xD,KAAK8wF,sBAAwB,CAACx9C,EAAY/xB,EAAiByjB,EAAQrrB,EAAiBre,KAChF,MAAM,KAAE4R,GAASomC,GACX,YAAEkyE,EAAW,mBAAEC,EAAkB,SAAEC,GAAapqH,EAChDu2F,EAAY3kF,EAAK+nD,QAAQxmD,OAAO,GAChCqjF,EAAY5kF,EAAK+nD,QAAQxmD,OAAO,IAChC,YAAE+yD,GAAgBt0D,EAClBy4G,EAAa/lH,OAAO4B,KAAKggE,GAC/B,IAAK,IAAI93D,EAAI,EAAGA,EAAIi8G,EAAW/kH,OAAQ8I,IAAK,CACxC,MAAMk8G,EAAYD,EAAWj8G,IACvB,YAAE2X,GAAgBrhB,KAAK6lH,6BAA6BD,EAAWjsG,IAC/D,WAAE9R,EAAU,WAAE1C,EAAYiqC,aAAczqB,EAAS,SAAEzd,GAAcma,EACjEi4F,EAAiB,gBAAgB,EAAG,EAAG,GACvCG,EAAiB,gBAAgB,EAAG,EAAG,GAS7C,GARA90F,EAAUmhG,iBAAiBj0B,EAAWynB,GACtCA,EAAe,GAAKr8G,KAAK+Q,MAAMsrG,EAAe,IAC9CA,EAAe,GAAKr8G,KAAK+Q,MAAMsrG,EAAe,IAC9CA,EAAe,GAAKr8G,KAAK+Q,MAAMsrG,EAAe,IAC9C30F,EAAUmhG,iBAAiBh0B,EAAW2nB,GACtCA,EAAe,GAAKx8G,KAAK+Q,MAAMyrG,EAAe,IAC9CA,EAAe,GAAKx8G,KAAK+Q,MAAMyrG,EAAe,IAC9CA,EAAe,GAAKx8G,KAAK+Q,MAAMyrG,EAAe,IAC1Cz5G,KAAKgwF,gBAAgBspB,EAAgBG,EAAgB5xG,GAAa,CAClE7H,KAAKwkF,sBAAuB,EAC5B,MAAMl3C,EAAOrwC,KAAKa,IAAIw7G,EAAe,GAAIG,EAAe,IAClDlsE,EAAOtwC,KAAKkS,IAAImqG,EAAe,GAAIG,EAAe,IAClDjsE,EAAOvwC,KAAKa,IAAIw7G,EAAe,GAAIG,EAAe,IAClDhsE,EAAOxwC,KAAKkS,IAAImqG,EAAe,GAAIG,EAAe,IAClD/rE,EAAOzwC,KAAKa,IAAIw7G,EAAe,GAAIG,EAAe,IAClD9rE,EAAO1wC,KAAKkS,IAAImqG,EAAe,GAAIG,EAAe,KAClD,WAAEtjB,EAAU,YAAEC,IAAgB,EAAAC,GAAA,GAAoC90E,EAAiByjB,EAAQ6sD,EAAWC,GACtG8D,EAAOO,EAAaC,EAC1B,IAAInnF,EAAQ,EACRi3B,EAAO,EACPC,EAAS,EACb,MAAM2H,EAAYjmC,EAAW,GACvBkmC,EAAYlmC,EAAW,GAAKA,EAAW,GAC7C,IAAK,IAAIwK,EAAIq7B,EAAMr7B,GAAKs7B,EAAMt7B,IAC1B,IAAK,IAAIJ,EAAIu7B,EAAMv7B,GAAKw7B,EAAMx7B,IAC1B,IAAK,IAAIvI,EAAI4jC,EAAM5jC,GAAK6jC,EAAM7jC,IAAK,CAE/BuF,IACAi3B,GAFc/gC,EAAWkN,EAAI07B,EAAY97B,EAAI67B,EAAYpkC,EAG7D,CAGRw8B,GAAQj3B,EACR,IAAK,IAAIoD,EAAIq7B,EAAMr7B,GAAKs7B,EAAMt7B,IAC1B,IAAK,IAAIJ,EAAIu7B,EAAMv7B,GAAKw7B,EAAMx7B,IAC1B,IAAK,IAAIvI,EAAI4jC,EAAM5jC,GAAK6jC,EAAM7jC,IAAK,CAC/B,MACMq8G,EADQ5gH,EAAWkN,EAAI07B,EAAY97B,EAAI67B,EAAYpkC,GAC1Bw8B,EAC/BC,GAAU4/E,EAAiBA,CAC/B,CAGR5/E,GAAUl3B,EACVk3B,EAASlpC,KAAKopC,KAAKF,GACnBq7B,EAAYokD,GAAa,CACrB79E,SAAU7gC,EAAS6gC,SACnB6tD,OACA1vD,OACAC,SAER,MAEInmC,KAAKwkF,sBAAuB,EAC5BhjB,EAAYokD,GAAa,CACrB79E,SAAU7gC,EAAS6gC,SAG/B,CACA,MAAMxsC,EAAc+3C,EAAW/3C,YAE/B,GADA+3C,EAAW/3C,aAAc,EACrBA,EAAa,CACb,MAAM4/F,EAAY,EAAA1pE,OAAO4pE,oBACnBtqE,EAAc,CAChBuiB,aACAkyE,cACAC,qBACAC,SAAUA,EACVzyB,WAAY,EAAAx/C,YAAYu+C,eAE5B,IAAA5vD,cAAa,EAAAxN,YAAaumE,EAAWpqE,EACzC,CACA,OAAOywC,GAEXxhE,KAAKgwF,gBAAkB,CAACC,EAAQC,EAAQroF,IAC5B,kCAA8BooF,EAAQpoF,IAC1C,kCAA8BqoF,EAAQroF,GAE9C7H,KAAKgmH,oBAAuBC,IACxB,GAAIjmH,KAAKyM,cAAcy5G,UACnB,OAAOlmH,KAAKyM,cAAcy5G,UAE9B,MAAMx/F,EAAeu/F,EAAME,kBAC3B,OAAKz/F,GAAiBA,EAAa9lB,OAG5B8lB,EAAa,GAAG5D,SAHvB,GAKJ9iB,KAAK6wF,gCAAiC,EAAAS,EAAA,GAAStxF,KAAK8wF,sBAAuB,IAAK,CAAES,UAAU,GAChG,CACA,MAAAtmF,CAAOkkB,GACH,IAAKnvB,KAAKqhE,UACN,OAEJrhE,KAAKqhE,WAAY,EACjBrhE,KAAK0hE,gBAAgBvyC,GACrBnvB,KAAK09D,kBAAkBvuC,IACvB,KAAAyuC,oBAAmBzuC,GACnB,MAAM,WAAEmkB,EAAU,qBAAE0xE,GAAyBhlH,KAAK29D,UAC5C,KAAEzwD,GAASomC,EAKjB,OAJApmC,EAAKm4G,QAAS,EACdn4G,EAAK+nD,QAAQigB,kBAAoB,MACjC,EAAAne,EAAA,GAAsCiuD,GACtChlH,KAAK29D,SAAW,KACTrqB,EAAWqhB,aACtB,CACA,4BAAAkxD,CAA6BD,EAAWjsG,GACpC,IAAI0H,EACJ,GAAIukG,EAAU5kH,WAAW,eAAgB,CACrC,MAAMolH,EAAcR,EAAU5iH,QAAQ,KAChCwiH,EAAcI,EAAUt/F,UAAU8/F,EAAc,GAEtD/kG,EADiB1H,EAAgByW,YAAYo1F,GACtBjtF,cAC3B,MAEIlX,EAAc,EAAAiS,MAAMxM,UAAU8+F,GAElC,MAAO,CAAEvkG,cAAanlB,SAVLA,UAWrB,CACA,kBAAAmqH,CAAmBnqH,GACf,MAAO,eAAeA,EAAS4mB,KACnC,E,wCCxbJ,MAAMwjG,GACK,EADLA,IAEO,EAEPC,GAAU,IAAI7qF,IA0GpB,MAAM8qF,GAAiB,CAAC,EAIxB,SAASplH,GAAOqlH,EAAWC,GACzB,IAAIC,EAAgBC,UAAUhmH,OAAS,QAAsB5C,IAAjB4oH,UAAU,GAAmBA,UAAU,GAAK,CAAC,EACzFhnH,OAAO23E,OAAOmvC,EAAOF,GAAgBG,GACrC,GAAAE,EAAMnmG,IAAI+lG,EAAWC,GACrB,GAAAG,EAAMC,KAAKL,EAAWC,EAAO,EAAG,GAjHlC,SAAkCD,GAChCA,EAAUM,YAAc,CAACC,EAAQC,KAC/B,MAAO79F,GAAS49F,EACXC,EAAQ,KACXA,EAAQ,GAAK,qBAEf,MAAOC,GAAUD,EACjBR,EAAUU,gBAAgB/9F,EAAO89F,GACjCA,EAAOh3E,YAETu2E,EAAUW,aAAe,CAACC,EAAItlG,EAAKulG,EAAaC,EAAWC,KACzD,IAAIC,EAASH,EACTI,EAAWH,EACXI,GAAa,EACbC,EAAc,EAClB,MAAQD,GAAY,CAClB,MAAM,aACJE,GACER,EAAGS,cAAcL,GACrB,IAAKI,EAEH,SAEFH,EAAWG,EAAa,KAAOH,EAAWG,EAAa,GAAKA,EAAa,GACzED,IAGA,MAAM18E,EAAInpB,EAAM6lG,EAChBJ,EAAW7+G,KAAK,CACduiC,IACA68E,KAAML,IAER,MAAMM,EAAWX,EAAGY,cAAcP,GAClC,GAAwB,IAApBM,EAASpnH,QAAgB8mH,IAAaH,EAExC,OAAOG,EAEe,IAApBM,EAASpnH,QAEX6mH,EAASO,EAAS,KAAOP,EAASO,EAAS,GAAKA,EAAS,GACzDzB,GAAQjjH,IAAImkH,IAGZE,GAAa,CAEjB,CACA,OAAOD,GAETjB,EAAUU,gBAAkB,CAAC/9F,EAAO89F,KAClC,MAAMgB,EAAQ,GACd3B,GAAQzyG,QACR,MAAMq0G,EAAU/+F,EAAM4oB,WACtBk1E,EAAOt0E,YAAYw1E,QAAQn/G,aAAa1G,KAAK6mB,EAAMwpB,YAAYzF,YAI/D,IAAK,IAAIk7E,EAAK,EAAGA,EAAKF,EAAQG,mBAAoBD,IAAM,CACtD,GAAI9B,GAAQljH,IAAIglH,GAEd,SAEF,MAAM,aACJR,GACEz+F,EAAM0+F,cAAcO,GACxB,IAAKR,EAEH,SAEFtB,GAAQjjH,IAAI+kH,GACZ,MAAMd,EAAYM,EAAa,GACzBL,EAAa,GACnBA,EAAW7+G,KAAK,CACduiC,EAAG,EACH68E,KAAMR,IAGJA,IADYd,EAAUW,aAAah+F,EAAOk9F,GAAa+B,EAAId,EAAWC,KAGxEf,EAAUW,aAAah+F,EAAOk9F,GAAc+B,EAAId,EAAWC,GAC3DA,EAAWvrG,KAAK,CAACC,EAAGhF,IAAMgF,EAAEgvB,EAAIh0B,EAAEg0B,GAAK,EAAI,GAEvCs8E,EAAW5mH,QAAU4mH,EAAW,GAAGO,OAASP,EAAWA,EAAW5mH,OAAS,IAAImnH,MACjFP,EAAW7+G,KAAK,IACX6+G,EAAWA,EAAW5mH,OAAS,MAIpC4mH,EAAW5mH,QACbsnH,EAAMv/G,KAAK6+G,EAEf,CAGA,MAAMe,EAAWrB,EAAOl1E,WACxBu2E,EAAS9pC,OAAO,GAChBypC,EAAMjnH,QAAQ2hC,IACZ2lF,EAASC,eAAe5lF,EAAKv8B,IAAIif,GAAMA,EAAGyiG,SAGhD,CAeEU,CAAyBhC,EAC3B,CAQA,IAAI,GAAQ,CACViC,YALkB,GAAA7B,EAAM6B,YAAYtnH,GAAQ,4BAM5CA,W,YC5HF,MAAQ82C,MAAQC,UAAU,cAAE4F,GAAa,QAAE2+C,GAAO,YAAEisB,KAAkBC,uBAAuB,mBAAEC,GAAkB,aAAEC,IAAgB13B,aAAa,+BAAE23B,IAAkCx0G,QAAQ,wBAAEy0G,KAA+B,EAY7N,MAAMC,GAAoB,CACtBC,QAAS,KACTC,qBAAqB,EACrBC,2BAA4B,KAC5B,uBAAMC,CAAkBC,GACpB,IAAIC,EACJ,IACIA,SAlBZ1tF,eAA0B2tF,GACtB,IACI,GAAiB,sBAAbA,EACA,OAAO,+BAEf,CACA,MAAO7jH,GAEH,OADAyK,QAAQC,KAAK,0BAA2B1K,GACjC,IACX,CACJ,CAQgC8jH,CAAW,sBAAsBC,OACzD,CACA,MAAO/jH,GAGH,OAFAyK,QAAQzK,MAAMA,QACdyK,QAAQqM,MAAM,+EAElB,CACIzc,KAAKmpH,0BACCnpH,KAAKopH,2BAGXppH,KAAKkpH,SAASziF,WAGlBzmC,KAAKmpH,qBAAsB,EAC3BnpH,KAAKopH,2BAA6B,IAAIvkH,QAASC,IAC3C9E,KAAKkpH,QAAU,IAAIK,EACnBvpH,KAAKkpH,QACAS,WAAW,CACZC,eAAgBN,IAEfvkH,KAAK,KACN/E,KAAKmpH,qBAAsB,EAC3BrkH,cAGF9E,KAAKopH,2BACf,EACA,6BAAMS,CAAwBC,KAASC,GACnC,MAAM,UAAEC,EAAS,eAAEC,GAAmBH,GAC/BR,GAAoBS,QACrB/pH,KAAKqpH,kBAAkBC,GAE7B,aADsBtpH,KAAKkpH,QAAQziF,SAASyjF,2BAA2BF,EAAWC,EAEtF,EACA,8BAAME,CAAyBL,KAASC,GACpC,MAAOT,GAAoBS,QACrB/pH,KAAKqpH,kBAAkBC,GAC7B,MAAMc,EAAUpqH,KAAKkpH,QAAQziF,SAAS0jF,yBAAyBL,EAAK3kH,WAAY2kH,EAAKjiH,WAAYiiH,EAAKhiH,QAASgiH,EAAK7hH,UAAW6hH,EAAK/hH,OAAQ,CAAC+hH,EAAK3Y,eAC5IkZ,EAAexB,GAAmBiB,EAAK7hH,WAC7C,IAAKoiH,EAAaC,WAAY,CAC1B,MAAMC,EAAgBzB,GAAauB,EAAaG,eAAgBV,EAAK/hH,OAAQqiH,EAAQ37G,QACrF27G,EAAQ37G,OAAS,IAAI87G,EACzB,CACA,OAAOH,CACX,EACA,oCAAMK,CAA+BX,KAASC,GAC1C,MAAOT,GAAoBS,QACrB/pH,KAAKqpH,kBAAkBC,GAC7B,MAAM,eAAEoB,EAAc,WAAEvlH,EAAU,2BAAEwlH,EAA0B,WAAE9iH,EAAU,OAAEE,EAAM,UAAEE,EAAS,QAAEH,GAAagiH,EACtGc,EAA2B,EAAA55E,UAAA,aAAuB65E,+BAA+B,CACnFhjH,aACA1C,eAEEwf,EAAY,oBAClBA,EAAUmmG,cAAcjjH,GACxB8c,EAAUmoC,UAAU/kD,GACpB4c,EAAUomG,aAAa9iH,GACvB0c,EAAUqmG,WAAWljH,GACrB,MAAMmjH,EAAc,kBAAyB,CACzC3qH,KAAM,SACN2E,mBAAoB,EACpB0V,OAAQxV,IAEZwf,EAAUsoB,eAAei+E,WAAWD,GACpCtmG,EAAUurB,WACV,IAAK,MAAM1nC,KAASkiH,EAAgB,CAChC,MAAMn2D,EAAco2D,EAA2BvqH,IAAIoI,GACnD,IAAK,MAAM8qC,KAAcihB,EAAa,CAClC,IAAKjhB,EAAW6E,SACZ,SAEJ,MAAM,SAAEA,EAAQ,cAAEgzE,GAAkB73E,EAC9B/qB,EAASwgG,GAA+B5wE,IACvC7K,EAAME,EAAME,GAAQ,EAAAsD,UAAA,sBAAgCrsB,EAAW,CAClE4D,EAAO,GAAG,GACVA,EAAO,GAAG,GACVA,EAAO,GAAG,MAEPglB,EAAME,EAAME,GAAQ,EAAAqD,UAAA,sBAAgCrsB,EAAW,CAClE4D,EAAO,GAAG,GACVA,EAAO,GAAG,GACVA,EAAO,GAAG,MAER,kBAAE6iG,EAAiB,qBAAEC,GAAyB1C,GAAYxwE,GAC1DmzE,EAAQH,GAAe9kH,IAAKklH,IAC9B,MAAQH,kBAAmBI,GAAkB7C,GAAY4C,GACzD,OAAOC,IAELC,GAAYJ,EAAuB,GAAK,EACxCK,GAAaL,EAAuB,GAAK,EAChC,EAAAr6E,UAAA,aAAuB65E,+BAA+B,CACjEhjH,aACA1C,eAEGlE,QAAQ,EAAG2sC,eACdg9E,EAAyBe,cAAc/9E,EAAUplC,IAClD,CACCmc,YACA8xE,WAAavoD,IACT,MAAM09E,EAAU,CAAC19E,EAASu9E,GAAWv9E,EAASw9E,IAI9C,OAHiB3tE,GAAcqtE,EAAmBQ,EAAS,CACvDN,WAIRp2G,UAAW,CACP,CAACo4B,EAAMC,GACP,CAACC,EAAMC,GACP,CAACC,EAAMC,KAGnB,CACJ,CACA,OAAOi9E,EAAyBzlH,UACpC,EACA,mCAAM0mH,CAA8B/B,KAASC,GACzC,MAAOT,GAAoBS,QACrB/pH,KAAKqpH,kBAAkBC,GAC7B,MAAM,kBAAEwC,EAAiB,2BAAEnB,EAA0B,eAAED,GAAmBZ,EACpEiC,EAA4B,IAAIv6G,IACtCs6G,EAAkB7qH,QAAQ,CAAC+qH,EAAkBzlH,KACzC,MAAM,WAAEsB,EAAU,WAAE1C,EAAU,UAAE8C,EAAS,QAAEH,EAAO,OAAEC,GAAWikH,EACzDC,EAAU,EAAAj7E,UAAA,aAAuB65E,+BAA+B,CAClEhjH,aACA1C,eAEEwf,EAAY,oBAClBA,EAAUmmG,cAAcjjH,GACxB8c,EAAUmoC,UAAU/kD,GACpB4c,EAAUomG,aAAa9iH,GACvB0c,EAAUqmG,WAAWljH,GACrB,MAAMmjH,EAAc,kBAAyB,CACzC3qH,KAAM,SACN2E,mBAAoB,EACpB0V,OAAQxV,IAEZwf,EAAUsoB,eAAei+E,WAAWD,GACpCtmG,EAAUurB,WACV67E,EAA0B7rH,IAAIqG,EAAmB,CAAE0lH,UAAStnG,gBAEhE,IAAK,MAAMnc,KAASkiH,EAAgB,CAChC,MAAMn2D,EAAco2D,EAA2BvqH,IAAIoI,GACnD,IAAK,MAAM8qC,KAAcihB,EAAa,CAClC,IAAKjhB,EAAW6E,SACZ,SAEJ,MAAM,SAAEA,EAAQ,cAAEgzE,EAAa,kBAAE5kH,GAAsB+sC,EACjD/qB,EAASwgG,GAA+B5wE,IACtC8zE,QAASrB,EAAwB,UAAEjmG,GAAconG,EAA0B3rH,IAAImG,IAChF+mC,EAAME,EAAME,GAAQ,EAAAsD,UAAA,sBAAgCrsB,EAAW,CAClE4D,EAAO,GAAG,GACVA,EAAO,GAAG,GACVA,EAAO,GAAG,MAEPglB,EAAME,EAAME,GAAQ,EAAAqD,UAAA,sBAAgCrsB,EAAW,CAClE4D,EAAO,GAAG,GACVA,EAAO,GAAG,GACVA,EAAO,GAAG,MAER,kBAAE6iG,EAAiB,qBAAEC,GAAyB1C,GAAYxwE,GAC1DmzE,EAAQH,GAAe9kH,IAAKklH,IAC9B,MAAQH,kBAAmBI,GAAkB7C,GAAY4C,GACzD,OAAOC,IAELC,GAAYJ,EAAuB,GAAK,EACxCK,GAAaL,EAAuB,GAAK,EAChC,EAAAr6E,UAAA,aAAuB9rC,wBAAwB,CAC1DtI,MAAO+nB,EAAUM,gBAAgB,GACjCpoB,OAAQ8nB,EAAUM,gBAAgB,GAClC9f,WAAYwf,EAAUsoB,eAAeC,aAAaC,YAE/ClsC,QAAQ,EAAG2sC,eACdg9E,EAAyBe,cAAc/9E,EAAUplC,IAClD,CACCmc,YACA8xE,WAAavoD,IACT,MAAM09E,EAAU,CAAC19E,EAASu9E,GAAWv9E,EAASw9E,IAI9C,OAHiB3tE,GAAcqtE,EAAmBQ,EAAS,CACvDN,WAIRp2G,UAAW,CACP,CAACo4B,EAAMC,GACP,CAACC,EAAMC,GACP,CAACC,EAAMC,KAGnB,CACJ,CAKA,OAJAm+E,EAAkB7qH,QAAQ,CAAC+qH,EAAkBzlH,KACzC,MAAQ0lH,QAASrB,GAA6BmB,EAA0B3rH,IAAImG,GAC5EylH,EAAiB7mH,WAAaylH,EAAyBzlH,aAEpD2mH,CACX,EACA,oCAAMI,CAA+BpC,KAASC,GAC1C,MAAOT,GAAoBS,QACrB/pH,KAAKqpH,kBAAkBC,GAE7B,OADgBtpH,KAAKkpH,QAAQziF,SAAS0lF,yBAAyBrC,EAAKr7G,OAAQq7G,EAAKsC,MAAOtC,EAAKjiH,WAAYiiH,EAAKhiH,QAASgiH,EAAK7hH,UAAW6hH,EAAK/hH,OAEhJ,EACA,qCAAMskH,CAAgCvC,KAASC,GAC3C,MAAOT,GAAoBS,QACrB/pH,KAAKqpH,kBAAkBC,GAC7B,MAAM,aAAEgD,GAAiBxC,EACnByC,EAAW7tH,MAAM6D,KAAK+pH,EAAa9qH,QAAQ6E,IAAK8qG,IAClD,MAAM,OAAE1iG,EAAM,MAAE29G,GAAUE,EAAalsH,IAAI+wG,GAE3C,MAAO,IADQnxG,KAAKkpH,QAAQziF,SAAS0lF,yBAAyB19G,EAAQ29G,EAAOtC,EAAKjiH,WAAYiiH,EAAKhiH,QAASgiH,EAAK7hH,UAAW6hH,EAAK/hH,QAG7HopG,kBAGFiZ,QAAgBvlH,QAAQ2nH,IAAID,GAC5BE,EAAkB,oBACxBA,EAAgB3B,cAAchB,EAAKjiH,YACnC4kH,EAAgB3/D,UAAUg9D,EAAK/hH,QAC/B0kH,EAAgBzB,WAAWlB,EAAKhiH,SAChC2kH,EAAgB1B,aAAajB,EAAK7hH,WAClC,MAAMykH,EAAY5C,EAAKjiH,WAAW,GAAKiiH,EAAKjiH,WAAW,GAAKiiH,EAAKjiH,WAAW,GACtEojH,EAAc,kBAAyB,CACzC3qH,KAAM,SACN2E,mBAAoB,EACpB0V,OAAQ,IAAI3R,WAAW0jH,KAE3BD,EAAgBx/E,eAAei+E,WAAWD,GAC1CwB,EAAgBv8E,WAChB,MAAM,WAAEroC,GAAeiiH,EACjB3kH,EAAasnH,EAAgBx/E,eAAeC,aAAaC,UACzDy9E,EAA2B,EAAA55E,UAAA,aAAuB65E,+BAA+B,CACnFhjH,aACA1C,eAEEwnH,EAAoBvC,EAAQ/jH,IAAKk4B,IACnC,MAAM,KAAErxB,EAAI,WAAErF,EAAU,UAAEI,EAAS,OAAEF,EAAM,QAAED,GAAYy2B,EACnDpY,EAAS,oBACfA,EAAO2kG,cAAcjjH,GACrBse,EAAO2mC,UAAU/kD,GACjBoe,EAAO6kG,WAAWljH,GAClBqe,EAAO4kG,aAAa9iH,GACpB,MAAMgjH,EAAc,kBAAyB,CACzC3qH,KAAM,SACN2E,mBAAoB,EACpB0V,OAAQzN,IAEZiZ,EAAO8mB,eAAei+E,WAAWD,GACjC9kG,EAAO+pB,WACP,MAAMlrC,EAAe,EAAAgsC,UAAA,aAAuB65E,+BAA+B,CACvEhjH,aACA1C,WAAY+H,IAEV0/G,EAASzmG,EAAOsC,YACtB,MAAO,CACHtC,SACAnhB,eACA4nH,SACAznH,WAAY+H,EACZikG,aAAc5yE,EAAO4yE,gBA+B7B,OA5Be,EAAAngE,UAAA,aAAuB65E,+BAA+B,CACjEhjH,WAAY4kH,EAAgBxnG,gBAC5B9f,WAAYsnH,EAAgBx/E,eAAeC,aAAaC,YAErDlsC,QAAQ,EAAG2sC,WAAUM,eACxB,IACI,IAAK,MAAMjwB,KAAc0uG,EAAmB,CACxC,MAAM,OAAExmG,EAAM,OAAEymG,EAAM,aAAE5nH,EAAY,aAAEmsG,GAAiBlzF,EACjDzV,EAAQ2d,EAAOiU,aAAa8T,GAClC,GAAI1lC,EAAM,GAAKokH,EAAO,IAClBpkH,EAAM,GAAKokH,EAAO,IAClBpkH,EAAM,GAAKokH,EAAO,IAClBpkH,EAAM,GAAKokH,EAAO,IAClBpkH,EAAM,GAAKokH,EAAO,IAClBpkH,EAAM,GAAKokH,EAAO,GAClB,SAEJ,MAAMC,EAAerkH,EAAMnC,IAAIpJ,KAAKgmB,OAEpC,GADcje,EAAaq2G,YAAYwR,GAC3B,EAAG,CACXjC,EAAyBe,cAAc/9E,EAAUujE,GACjD,KACJ,CACJ,CACJ,CACA,MAAOxrG,GACP,GACD,CAAEgf,UAAW8nG,IACT7B,EAAyBzlH,UACpC,EACA,gBAAA2nH,EAAiB,aAAEC,IACf,MAAMC,EAAQ,IAAIx7G,IAClB,IAAK,MAAM,OAAE/C,EAAM,GAAEpF,KAAQ0jH,EAAc,CACvC,MAAM/yE,EAAO0iD,GAAQjuF,EAAQ,CAAEw+G,cAAe,IAC9CD,EAAM9sH,IAAImJ,EAAI2wC,EAClB,CACA,OAAOgzE,CACX,EACA,qBAAAE,EAAsB,WAAEC,EAAU,aAAEJ,EAAY,aAAEK,EAAe,IAAI57G,KAAS83G,EAAkB+D,GAC5F,MAAMC,EAAiBH,EAAWvsH,OAC5B2sH,EAAS,oBACTC,EAAS,oBACfD,EAAOE,eAAeD,GACtB,MAAME,EAAkB,oBACxB,IACI,IAAK,MAAOllH,EAAOmlH,KAAcR,EAAWliG,UAAW,CACnD,MAAM,WAAE2iG,EAAU,OAAEhgE,GAAW+/D,EACzBE,EAAkB,IAAIr8G,IAC5B,IAAK,MAAMs8G,KAAgBf,EAAc,CACrC,MAAM,OAAEt+G,EAAM,MAAE29G,EAAK,GAAE/iH,EAAE,aAAE8nG,GAAiB2c,EACtCC,EAAQX,EAAahtH,IAAIiJ,IAAOqzF,GAAQjuF,EAAQ,CAAEw+G,cAAe,IAClEG,EAAa/pH,IAAIgG,IAClB+jH,EAAaltH,IAAImJ,EAAI0kH,GAEzB,MAAM,KAAEroG,EAAI,KAAE+d,EAAI,KAAEE,EAAI,KAAEhe,EAAI,KAAE+d,EAAI,KAAEE,GAASmqF,GACzC,OAAEhmH,EAAM,OAAEojC,GAAWyiB,EAAO,GAClC,IAAKo7D,GAAwBjhH,EAAQojC,EAAQzlB,EAAM+d,EAAME,EAAMhe,EAAM+d,EAAME,GACvE,SAEJ8pF,EAAgB96E,YAAYw1E,QAAQ35G,EAAQ,GAC5Ci/G,EAAgBM,WAAW5F,QAAQgE,GACnCsB,EAAgBx9E,WAChBq9E,EAAOp7D,aAAau7D,GACpBF,EAAO1gE,UAAU/kD,GACjBylH,EAAOS,UAAU9iF,GACjB,IACIoiF,EAAO12C,QACX,CACA,MAAOnnE,GACHU,QAAQC,KAAK,wBAAyBX,GACtC,QACJ,CACA,MAAMoiC,EAAWy7E,EAAO7pC,gBACxB,IAAK5xC,IACAA,EAASc,aACmC,IAA7Cd,EAASc,YAAYs7E,oBACrB,SAEJ,MAAMC,EAAer8E,EACrBq8E,EAAaC,aACb,MAAMC,EAAiB,iBACvBA,EAAel8D,aAAag8D,GAC5B,IACIE,EAAex3C,SACf,MAAMy3C,EAAaD,EAAe3qC,gBAC9B4qC,GACAA,EAAW17E,aACX07E,EAAWt8E,YACXs8E,EAAW17E,YAAYs7E,oBAAsB,GAC7CI,EAAWt8E,WAAWs2E,mBAAqB,GAC3CuF,EAAgB3tH,IAAIixG,EAAc,CAC9B1iG,OAAQ6/G,EAAW17E,YAAYzF,UAC/B6kB,MAAOs8D,EAAWt8E,WAAW7E,UAC7BohF,cAAeD,EAAWt8E,WAAWs2E,mBACrCnX,gBAGZ,CACA,MAAOqd,GACHp+G,QAAQC,KAAK,gCAAiCm+G,GAC9C,QACJ,CACJ,CACAlF,EAAiB,CAAEmF,UAAWjmH,EAAQ,GAAK8kH,IAC3CD,EAAoB,CAAEO,aAAYC,mBACtC,CACJ,CACA,MAAOn+G,GACHU,QAAQC,KAAK,0BAA2BX,EAC5C,CACA,QACIq9G,EAAe,KACfS,EAAOhqH,QACX,CACJ,IAEJ,OAAOylH,G,gDCtZP,MAiQA,EAjQ8B,CAC1B,CAAC,EAAG,EAAG,EAAG,GACV,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,GAAI,KACd,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,GAAI,IAAK,KACd,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IAAK,GAAI,KACf,CAAC,GAAI,IAAK,IAAK,KACf,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,GAAI,IAAK,GAAI,KACd,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,IAAK,IAAK,KAChB,CAAC,IAAK,GAAI,IAAK,KACf,CAAC,IAAK,IA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","sources":["webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/drawImageSync.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/calculateTransform.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/RenderingEngine/helpers/cpuFallback/rendering/getDefaultViewport.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/enums/GenerateImageType.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/Settings.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/loaders/imageLoader.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/FrameRange.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/PointsManager.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/ProgressiveIterator.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/RLEVoxelMap.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/actorCheck.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/applyPreset.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/autoLoad.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/buildMetadata.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calculateSpacingBetweenImageIds.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/clamp.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/colormap.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createLinearRGBTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createSigmoidRGBTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/decimate.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepClone.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/fnv1aHash.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getClosestImageId.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageDataMetadata.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageSliceDataForVolumeViewport.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getScalingParameters.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSliceRange.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getSpacingInNormalDirection.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getTargetVolumeAndSpacingInNormalDir.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportsWithVolumeId.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVoiFromSigmoidRGBTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeActorCorners.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeId.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeSliceRangeInfo.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeViewportScrollInfo.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/hasFloatScalingParameters.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/hasNaNValues.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageIdToURI.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageRetrieveMetadataProvider.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/eventListener/TargetEventListeners.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/eventListener/MultiTargetEventListenerManager.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/scaleRgbTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getMinMax.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getRuntimeId.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calibratedPixelSpacingMetadataProvider.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isOpposite.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/indexWithinDimensions.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeViewportsContainingSameVolumes.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isPTPrescaledWithSUV.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/renderToCanvasGPU.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/renderToCanvasCPU.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/loadImageToCanvas.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/asArray.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/historyMemo/index.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/worldToImageCoords.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/imageToWorldCoords.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportsWithImageURI.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getClosestStackImageIndexForPoint.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getCurrentVolumeViewportSlice.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/spatialRegistrationMetadataProvider.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calculateViewportsSpatialRegistration.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportImageCornersInWorld.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getImageLegacy.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isValidVolume.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isVideoTransferSyntax.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertStackToVolumeViewport.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertVolumeToStackViewport.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/roundNumber.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/convertToGrayscale.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportImageIds.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getRandomSampleFromArray.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/color.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/deepEqual.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/splitImageIdsBy4DTags.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getDynamicVolumeInfo.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/scaleArray.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/clip.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/scroll.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/jumpToSlice.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/createSubVolume.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getVolumeDirectionVectors.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/calculateNeighborhoodStats.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getPixelSpacingInformation.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/index.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/getViewportModality.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/invertRgbTransferFunction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/isEqual.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/logger.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/makeVolumeMetadata.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/planar.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/pointInShapeCallback.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/snapFocalPointToSlice.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/sortImageIdsAndGetSpacing.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transferFunctionUtils.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformCanvasToIJK.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformIndexToWorld.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/transformWorldToIndex.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/updatePlaneRestriction.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/updateVTKImageDataWithCornerstoneImage.js","webpack:///../../../node_modules/@cornerstonejs/core/dist/esm/utilities/windowLevel.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraModifiedEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/imageSpacingCalibratedEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/annotationInterpolationEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/cameraResetEventDispatcher.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createCameraPositionSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createPresentationViewSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createZoomPanSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createImageSliceSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/synchronizers/synchronizers/createSlabThicknessSynchronizer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/calibrateImageSpacing.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/events.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/cine/playClip.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/rectangleROITool/isAxisAlignedRectangle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackPrefetch.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/stackPrefetch/stackContextPrefetch.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/dynamicVolume/generateImageFromTimeData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/polyData/utils.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/Colorbar.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/ViewportColorbar.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/extractWindowLevelRegionToolData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointInSurroundingSphereCallback.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/setAnnotationLabel.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/calculateFanShapeCorners.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/deriveFanGeometry.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/fanExtraction.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/segmentLargestUSOutlineFromBuffer.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/utils/generateConvexHullFromContour.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/Spline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CubicSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/BSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CardinalSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/CatmullRomSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/splines/LinearSpline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PanTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/TrackballRotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeCroppingTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeCroppingControlTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/WindowLevelRegionTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/getLuminanceFromRegion.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/windowlevel/calculateMinMaxMean.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/StackScrollTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/PlanarRotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ZoomTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MIPJumpToClickTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/CrosshairsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/MagnifyTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AdvancedMagnifyTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceLinesTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OverlayGridTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SegmentationIntersectionTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/pointToString.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ReferenceCursors.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/ScaleOverlayTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/SculptorTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/VolumeRotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LabelTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LengthTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/HeightTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ProbeTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/DragProbeTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/EllipticalROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CircleROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ETDRSGridTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/SplineContourSegmentationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/LivewireContourSegmentationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/ArrowAnnotateTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/AngleTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/CobbAngleTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundDirectionalTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/UltrasoundPleuraBLineTool/UltrasoundPleuraBLineTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/KeyImageTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/AnnotationEraserTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RegionSegmentPlusTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/WholeBodySegmentTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/RectangleScissorsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleScissorsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SphereScissorsTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/CircleROIStartEndThresholdTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/PaintFillTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/OrientationMarkerTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentSelectTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentBidirectionalTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/SegmentLabelTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapEditWithContour.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/VideoRedactionTool.js","webpack:///../../../node_modules/@kitware/vtk.js/Filters/General/ContourLoopExtraction.js","webpack:///../../../node_modules/@cornerstonejs/polymorphic-segmentation/dist/esm/workers/polySegConverters.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/constants/COLOR_LUT.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/getSvgDrawingHelper.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/draw.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawCircle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawEllipseByCoordinates.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHandles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLink.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawLinkedTextBox.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRect.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawHeight.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawFan.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawArrow.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/drawRedactionRect.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/ChangeTypes.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/enums/Touch.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventListeners/segmentation/imageChangeEventListener.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationRenderingEngine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStateManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/SegmentationStyle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/activeSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/setActiveSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addColorLUT.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentationRepresentationsToViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/normalizeSegmentationInput.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/addSegmentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/config/segmentationColor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationDataModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getActiveSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getNextColorLUTIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentationRepresentationVisibility.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getViewportSegmentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeStackLabelmapFromVolume.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/computeVolumeLabelmapFromStack.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddRepresentationData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/internalAddSegmentationRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeSegmentationRepresentations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentLocking.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationEventManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/removeColorLUT.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getStackSegmentationImageIdsForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/segmentationState.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/updateLabelmapSegmentationImageReferences.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/utilities/getAnnotationsUIDMapFromSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupForViewport.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/svgNodeCache.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/BidirectionalTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandContourSegmentationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/PlanarFreehandROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/RectangleROITool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/BrushTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/LabelmapBaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillCircle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillRectangle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/annotationHydration.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/extend2DBoundingBoxInViewAxis.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/boundingBox/getBoundingBoxAroundShape.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contourSegmentation/convertContourSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/findHandlePolylineIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/debounce.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/drawing/getTextBoxCoordsCanvas.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getCalibratedUnits.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getSphereBoundsInfo.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/getViewportForAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/isObject.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/sphere/pointInSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/SegmentStatsCalculator.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/floodFill.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getBrushToolInstances.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getHoveredContourSegmentationAnnotation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtLabelmapBorder.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSegmentIndexAtWorldPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/growCutShader.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCut.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForBoundingBox.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runGrowCutForSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/growCut/runOneClickGrowCut.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/invalidateBrushCursor.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/throttle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/touch/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForToolGroupIds.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/triggerAnnotationRenderForViewportIds.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewport/isViewportPreScaled.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/voi/colorbar/enums/ColorbarRangeTextPosition.js","webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/DataSetAttributes/Constants.js","webpack:///../../../node_modules/@kitware/vtk.js/Common/DataModel/ImageData.js","webpack:///../../../node_modules/@kitware/vtk.js/Rendering/Core/ColorTransferFunction.js","webpack:///../../../node_modules/gl-matrix/esm/vec3.js","webpack:///../../../node_modules/d3-array/src/bisector.js","webpack:///../../../node_modules/d3-array/src/zip.js","webpack:///../../../node_modules/d3-interpolate/src/constant.js","webpack:///../../../node_modules/d3-interpolate/src/number.js","webpack:///../../../node_modules/d3-interpolate/src/quantize.js","webpack:///../../../node_modules/d3-interpolate/src/round.js"],"sourcesContent":["import now from './rendering/now';\nimport { renderColorImage } from './rendering/renderColorImage';\nimport { renderGrayscaleImage } from './rendering/renderGrayscaleImage';\nimport { renderPseudoColorImage } from './rendering/renderPseudoColorImage';\nexport default function (enabledElement, invalidated) {\n    const image = enabledElement.image;\n    if (!enabledElement.canvas || !enabledElement.image) {\n        return;\n    }\n    const start = now();\n    image.stats = {\n        lastGetPixelDataTime: -1.0,\n        lastStoredPixelDataToCanvasImageDataTime: -1.0,\n        lastPutImageDataTime: -1.0,\n        lastRenderTime: -1.0,\n        lastLutGenerateTime: -1.0,\n    };\n    if (image) {\n        let render = image.render;\n        if (!render) {\n            if (enabledElement.viewport.colormap) {\n                render = renderPseudoColorImage;\n            }\n            else if (image.color) {\n                render = renderColorImage;\n            }\n            else {\n                render = renderGrayscaleImage;\n            }\n        }\n        render(enabledElement, invalidated);\n    }\n    const renderTimeInMs = now() - start;\n    image.stats.lastRenderTime = renderTimeInMs;\n    enabledElement.invalid = false;\n    enabledElement.needsRedraw = false;\n}\n","import { Transform } from './transform';\nexport default function (enabledElement, scale) {\n    const transform = new Transform();\n    if (!enabledElement.viewport.displayedArea) {\n        return transform;\n    }\n    transform.translate(enabledElement.canvas.width / 2, enabledElement.canvas.height / 2);\n    const angle = enabledElement.viewport.rotation;\n    if (angle !== 0) {\n        transform.rotate((angle * Math.PI) / 180);\n    }\n    let widthScale = enabledElement.viewport.scale;\n    let heightScale = enabledElement.viewport.scale;\n    const width = enabledElement.viewport.displayedArea.brhc.x -\n        (enabledElement.viewport.displayedArea.tlhc.x - 1);\n    const height = enabledElement.viewport.displayedArea.brhc.y -\n        (enabledElement.viewport.displayedArea.tlhc.y - 1);\n    if (enabledElement.viewport.displayedArea.presentationSizeMode === 'NONE') {\n        if (enabledElement.image.rowPixelSpacing <\n            enabledElement.image.columnPixelSpacing) {\n            widthScale *=\n                enabledElement.image.columnPixelSpacing /\n                    enabledElement.image.rowPixelSpacing;\n        }\n        else if (enabledElement.image.columnPixelSpacing <\n            enabledElement.image.rowPixelSpacing) {\n            heightScale *=\n                enabledElement.image.rowPixelSpacing /\n                    enabledElement.image.columnPixelSpacing;\n        }\n    }\n    else {\n        widthScale = enabledElement.viewport.displayedArea.columnPixelSpacing;\n        heightScale = enabledElement.viewport.displayedArea.rowPixelSpacing;\n        if (enabledElement.viewport.displayedArea.presentationSizeMode ===\n            'SCALE TO FIT') {\n            const verticalScale = enabledElement.canvas.height / (height * heightScale);\n            const horizontalScale = enabledElement.canvas.width / (width * widthScale);\n            widthScale = heightScale = Math.min(horizontalScale, verticalScale);\n            if (enabledElement.viewport.displayedArea.rowPixelSpacing <\n                enabledElement.viewport.displayedArea.columnPixelSpacing) {\n                widthScale *=\n                    enabledElement.viewport.displayedArea.columnPixelSpacing /\n                        enabledElement.viewport.displayedArea.rowPixelSpacing;\n            }\n            else if (enabledElement.viewport.displayedArea.columnPixelSpacing <\n                enabledElement.viewport.displayedArea.rowPixelSpacing) {\n                heightScale *=\n                    enabledElement.viewport.displayedArea.rowPixelSpacing /\n                        enabledElement.viewport.displayedArea.columnPixelSpacing;\n            }\n        }\n    }\n    transform.scale(widthScale, heightScale);\n    if (angle !== 0) {\n        transform.rotate((-angle * Math.PI) / 180);\n    }\n    transform.translate(enabledElement.viewport.translation.x, enabledElement.viewport.translation.y);\n    if (angle !== 0) {\n        transform.rotate((angle * Math.PI) / 180);\n    }\n    if (scale !== undefined) {\n        transform.scale(scale, scale);\n    }\n    if (enabledElement.viewport.hflip) {\n        transform.scale(-1, 1);\n    }\n    if (enabledElement.viewport.vflip) {\n        transform.scale(1, -1);\n    }\n    transform.translate(-width / 2, -height / 2);\n    return transform;\n}\n","import createViewport from './createViewport';\nimport getImageFitScale from './getImageFitScale';\nexport default function (canvas, image, modality, colormap) {\n    if (canvas === undefined) {\n        throw new Error('getDefaultViewport: parameter canvas must not be undefined');\n    }\n    if (image === undefined) {\n        return createViewport();\n    }\n    const scale = getImageFitScale(canvas, image, 0).scaleFactor;\n    let voi;\n    if (modality === 'PT' && image.isPreScaled) {\n        voi = {\n            windowWidth: 5,\n            windowCenter: 2.5,\n        };\n    }\n    else if (image.windowWidth !== undefined &&\n        image.windowCenter !== undefined) {\n        voi = {\n            windowWidth: Array.isArray(image.windowWidth)\n                ? image.windowWidth[0]\n                : image.windowWidth,\n            windowCenter: Array.isArray(image.windowCenter)\n                ? image.windowCenter[0]\n                : image.windowCenter,\n        };\n    }\n    return {\n        scale,\n        translation: {\n            x: 0,\n            y: 0,\n        },\n        voi,\n        invert: image.invert,\n        pixelReplication: false,\n        rotation: 0,\n        hflip: false,\n        vflip: false,\n        modalityLUT: image.modalityLUT,\n        modality,\n        voiLUT: image.voiLUT,\n        colormap: colormap !== undefined ? colormap : image.colormap,\n        displayedArea: {\n            tlhc: {\n                x: 1,\n                y: 1,\n            },\n            brhc: {\n                x: image.columns,\n                y: image.rows,\n            },\n            rowPixelSpacing: image.rowPixelSpacing === undefined ? 1 : image.rowPixelSpacing,\n            columnPixelSpacing: image.columnPixelSpacing === undefined ? 1 : image.columnPixelSpacing,\n            presentationSizeMode: 'NONE',\n        },\n    };\n}\n","export var GenerateImageType;\n(function (GenerateImageType) {\n    GenerateImageType[\"SUM\"] = \"SUM\";\n    GenerateImageType[\"SUBTRACT\"] = \"SUBTRACT\";\n    GenerateImageType[\"AVERAGE\"] = \"AVERAGE\";\n})(GenerateImageType || (GenerateImageType = {}));\n","const DEFAULT_SETTINGS = Symbol('DefaultSettings');\nconst RUNTIME_SETTINGS = Symbol('RuntimeSettings');\nconst OBJECT_SETTINGS_MAP = Symbol('ObjectSettingsMap');\nconst DICTIONARY = Symbol('Dictionary');\nexport default class Settings {\n    constructor(base) {\n        const dictionary = Object.create((base instanceof Settings && DICTIONARY in base\n            ? base[DICTIONARY]\n            : null));\n        Object.seal(Object.defineProperty(this, DICTIONARY, {\n            value: dictionary,\n        }));\n    }\n    set(key, value) {\n        return set(this[DICTIONARY], key, value, null);\n    }\n    get(key) {\n        return get(this[DICTIONARY], key);\n    }\n    unset(key) {\n        return unset(this[DICTIONARY], key + '');\n    }\n    forEach(callback) {\n        iterate(this[DICTIONARY], callback);\n    }\n    extend() {\n        return new Settings(this);\n    }\n    import(root) {\n        if (isPlainObject(root)) {\n            Object.keys(root).forEach((key) => {\n                set(this[DICTIONARY], key, root[key], null);\n            });\n        }\n    }\n    dump() {\n        const context = {};\n        iterate(this[DICTIONARY], (key, value) => {\n            if (typeof value !== 'undefined') {\n                deepSet(context, key, value);\n            }\n        });\n        return context;\n    }\n    static assert(subject) {\n        return subject instanceof Settings\n            ? subject\n            : Settings.getRuntimeSettings();\n    }\n    static getDefaultSettings(subfield = null) {\n        let defaultSettings = Settings[DEFAULT_SETTINGS];\n        if (!(defaultSettings instanceof Settings)) {\n            defaultSettings = new Settings();\n            Settings[DEFAULT_SETTINGS] = defaultSettings;\n        }\n        if (subfield) {\n            const settingObj = {};\n            defaultSettings.forEach((name) => {\n                if (name.startsWith(subfield)) {\n                    const setting = name.split(`${subfield}.`)[1];\n                    settingObj[setting] = defaultSettings.get(name);\n                }\n            });\n            return settingObj;\n        }\n        return defaultSettings;\n    }\n    static getRuntimeSettings() {\n        let runtimeSettings = Settings[RUNTIME_SETTINGS];\n        if (!(runtimeSettings instanceof Settings)) {\n            runtimeSettings = new Settings(Settings.getDefaultSettings());\n            Settings[RUNTIME_SETTINGS] = runtimeSettings;\n        }\n        return runtimeSettings;\n    }\n    static getObjectSettings(subject, from) {\n        let settings = null;\n        if (subject instanceof Settings) {\n            settings = subject;\n        }\n        else if (typeof subject === 'object' && subject !== null) {\n            let objectSettingsMap = Settings[OBJECT_SETTINGS_MAP];\n            if (!(objectSettingsMap instanceof WeakMap)) {\n                objectSettingsMap = new WeakMap();\n                Settings[OBJECT_SETTINGS_MAP] = objectSettingsMap;\n            }\n            settings = objectSettingsMap.get(subject);\n            if (!(settings instanceof Settings)) {\n                settings = new Settings(Settings.assert(Settings.getObjectSettings(from)));\n                objectSettingsMap.set(subject, settings);\n            }\n        }\n        return settings;\n    }\n    static extendRuntimeSettings() {\n        return Settings.getRuntimeSettings().extend();\n    }\n}\nfunction unset(dictionary, name) {\n    if (name.endsWith('.')) {\n        let deleteCount = 0;\n        const namespace = name;\n        const base = namespace.slice(0, -1);\n        const deleteAll = base.length === 0;\n        for (const key in dictionary) {\n            if (Object.prototype.hasOwnProperty.call(dictionary, key) &&\n                (deleteAll || key.startsWith(namespace) || key === base)) {\n                delete dictionary[key];\n                ++deleteCount;\n            }\n        }\n        return deleteCount > 0;\n    }\n    return delete dictionary[name];\n}\nfunction iterate(dictionary, callback) {\n    for (const key in dictionary) {\n        callback(key, dictionary[key]);\n    }\n}\nfunction setAll(dictionary, prefix, record, references) {\n    let failCount;\n    if (references.has(record)) {\n        return set(dictionary, prefix, null, references);\n    }\n    references.add(record);\n    failCount = 0;\n    for (const field in record) {\n        if (Object.prototype.hasOwnProperty.call(record, field)) {\n            const key = field.length === 0 ? prefix : `${prefix}.${field}`;\n            if (!set(dictionary, key, record[field], references)) {\n                ++failCount;\n            }\n        }\n    }\n    references.delete(record);\n    return failCount === 0;\n}\nfunction set(dictionary, key, value, references) {\n    if (isValidKey(key)) {\n        if (isPlainObject(value)) {\n            return setAll(dictionary, key, value, references instanceof WeakSet ? references : new WeakSet());\n        }\n        dictionary[key] = value;\n        return true;\n    }\n    return false;\n}\nfunction get(dictionary, key) {\n    return dictionary[key];\n}\nfunction isValidKey(key) {\n    let last, current, previous;\n    if (typeof key !== 'string' || (last = key.length - 1) < 0) {\n        return false;\n    }\n    previous = -1;\n    while ((current = key.indexOf('.', previous + 1)) >= 0) {\n        if (current - previous < 2 || current === last) {\n            return false;\n        }\n        previous = current;\n    }\n    return true;\n}\nfunction isPlainObject(subject) {\n    if (typeof subject === 'object' && subject !== null) {\n        const prototype = Object.getPrototypeOf(subject);\n        if (prototype === Object.prototype || prototype === null) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction deepSet(context, key, value) {\n    const separator = key.indexOf('.');\n    if (separator >= 0) {\n        const subKey = key.slice(0, separator);\n        let subContext = context[subKey];\n        if (typeof subContext !== 'object' || subContext === null) {\n            const subContextValue = subContext;\n            subContext = {};\n            if (typeof subContextValue !== 'undefined') {\n                subContext[''] = subContextValue;\n            }\n            context[subKey] = subContext;\n        }\n        deepSet(subContext, key.slice(separator + 1, key.length), value);\n    }\n    else {\n        context[key] = value;\n    }\n}\nSettings.getDefaultSettings().set('useCursors', true);\n","import cache from '../cache/cache';\nimport Events from '../enums/Events';\nimport eventTarget from '../eventTarget';\nimport genericMetadataProvider from '../utilities/genericMetadataProvider';\nimport { getBufferConfiguration } from '../utilities/getBufferConfiguration';\nimport triggerEvent from '../utilities/triggerEvent';\nimport uuidv4 from '../utilities/uuidv4';\nimport VoxelManager from '../utilities/VoxelManager';\nimport imageLoadPoolManager from '../requestPool/imageLoadPoolManager';\nimport * as metaData from '../metaData';\nimport VoxelManagerEnum from '../enums/VoxelManagerEnum';\nconst imageLoaders = {};\nlet unknownImageLoader;\nfunction loadImageFromImageLoader(imageId, options) {\n    const cachedImageLoadObject = cache.getImageLoadObject(imageId);\n    if (cachedImageLoadObject) {\n        handleImageLoadPromise(cachedImageLoadObject.promise, imageId);\n        return cachedImageLoadObject;\n    }\n    const scheme = imageId.split(':')[0];\n    const loader = imageLoaders[scheme] || unknownImageLoader;\n    if (!loader) {\n        throw new Error(`loadImageFromImageLoader: No image loader found for scheme '${scheme}'`);\n    }\n    const imageLoadObject = loader(imageId, options);\n    handleImageLoadPromise(imageLoadObject.promise, imageId);\n    return imageLoadObject;\n}\nfunction handleImageLoadPromise(imagePromise, imageId) {\n    Promise.resolve(imagePromise)\n        .then((image) => {\n        ensureVoxelManager(image);\n        triggerEvent(eventTarget, Events.IMAGE_LOADED, { image });\n    })\n        .catch((error) => {\n        const errorDetails = {\n            imageId,\n            error,\n        };\n        triggerEvent(eventTarget, Events.IMAGE_LOAD_FAILED, errorDetails);\n    });\n}\nfunction ensureVoxelManager(image) {\n    if (!image.voxelManager) {\n        const { width, height, numberOfComponents } = image;\n        const voxelManager = VoxelManager.createImageVoxelManager({\n            scalarData: image.getPixelData(),\n            width,\n            height,\n            numberOfComponents,\n        });\n        image.voxelManager = voxelManager;\n        image.getPixelData = () => voxelManager.getScalarData();\n        delete image.imageFrame.pixelData;\n    }\n}\nexport function loadImage(imageId, options = { priority: 0, requestType: 'prefetch' }) {\n    if (imageId === undefined) {\n        throw new Error('loadImage: parameter imageId must not be undefined');\n    }\n    return loadImageFromImageLoader(imageId, options).promise;\n}\nexport function loadAndCacheImage(imageId, options = { priority: 0, requestType: 'prefetch' }) {\n    if (imageId === undefined) {\n        throw new Error('loadAndCacheImage: parameter imageId must not be undefined');\n    }\n    const imageLoadObject = loadImageFromImageLoader(imageId, options);\n    if (!cache.getImageLoadObject(imageId)) {\n        cache.putImageLoadObject(imageId, imageLoadObject);\n    }\n    return imageLoadObject.promise;\n}\nexport function loadAndCacheImages(imageIds, options = { priority: 0, requestType: 'prefetch' }) {\n    if (!imageIds || imageIds.length === 0) {\n        throw new Error('loadAndCacheImages: parameter imageIds must be list of image Ids');\n    }\n    const allPromises = imageIds.map((imageId) => {\n        return loadAndCacheImage(imageId, options);\n    });\n    return allPromises;\n}\nexport function createAndCacheDerivedImage(referencedImageId, options = {}) {\n    if (referencedImageId === undefined) {\n        throw new Error('createAndCacheDerivedImage: parameter imageId must not be undefined');\n    }\n    if (options.imageId === undefined) {\n        options.imageId = `derived:${uuidv4()}`;\n    }\n    const { imageId, skipCreateBuffer, onCacheAdd, voxelRepresentation } = options;\n    const imagePlaneModule = metaData.get('imagePlaneModule', referencedImageId);\n    const length = imagePlaneModule.rows * imagePlaneModule.columns;\n    const { TypedArrayConstructor } = getBufferConfiguration(options.targetBuffer?.type, length);\n    const imageScalarData = new TypedArrayConstructor(skipCreateBuffer ? 1 : length);\n    const derivedImageId = imageId;\n    const referencedImagePlaneMetadata = metaData.get('imagePlaneModule', referencedImageId);\n    genericMetadataProvider.add(derivedImageId, {\n        type: 'imagePlaneModule',\n        metadata: referencedImagePlaneMetadata,\n    });\n    const referencedImageGeneralSeriesMetadata = metaData.get('generalSeriesModule', referencedImageId);\n    genericMetadataProvider.add(derivedImageId, {\n        type: 'generalSeriesModule',\n        metadata: referencedImageGeneralSeriesMetadata,\n    });\n    genericMetadataProvider.add(derivedImageId, {\n        type: 'generalImageModule',\n        metadata: {\n            instanceNumber: options.instanceNumber,\n        },\n    });\n    const imagePixelModule = metaData.get('imagePixelModule', referencedImageId);\n    genericMetadataProvider.add(derivedImageId, {\n        type: 'imagePixelModule',\n        metadata: {\n            ...imagePixelModule,\n            bitsAllocated: 8,\n            bitsStored: 8,\n            highBit: 7,\n            samplesPerPixel: 1,\n            pixelRepresentation: 0,\n        },\n    });\n    const localImage = createAndCacheLocalImage(imageId, {\n        scalarData: imageScalarData,\n        onCacheAdd,\n        skipCreateBuffer,\n        targetBuffer: {\n            type: imageScalarData.constructor.name,\n        },\n        voxelRepresentation,\n        dimensions: [imagePlaneModule.columns, imagePlaneModule.rows],\n        spacing: [\n            imagePlaneModule.columnPixelSpacing,\n            imagePlaneModule.rowPixelSpacing,\n        ],\n        origin: imagePlaneModule.imagePositionPatient,\n        direction: imagePlaneModule.imageOrientationPatient,\n        frameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\n        referencedImageId: referencedImageId,\n    });\n    localImage.referencedImageId = referencedImageId;\n    if (!cache.getImageLoadObject(imageId)) {\n        cache.putImageSync(imageId, localImage);\n    }\n    return localImage;\n}\nexport function createAndCacheDerivedImages(referencedImageIds, options = {}) {\n    if (referencedImageIds.length === 0) {\n        throw new Error('createAndCacheDerivedImages: parameter imageIds must be list of image Ids');\n    }\n    const derivedImageIds = [];\n    const images = referencedImageIds.map((referencedImageId, index) => {\n        const newOptions = {\n            imageId: options?.getDerivedImageId?.(referencedImageId) ||\n                `derived:${uuidv4()}`,\n            ...options,\n        };\n        derivedImageIds.push(newOptions.imageId);\n        return createAndCacheDerivedImage(referencedImageId, {\n            ...newOptions,\n            instanceNumber: index + 1,\n        });\n    });\n    return images;\n}\nexport function createAndCacheLocalImage(imageId, options) {\n    const { scalarData, origin, direction, targetBuffer, skipCreateBuffer, onCacheAdd, frameOfReferenceUID, voxelRepresentation, referencedImageId, } = options;\n    const dimensions = options.dimensions;\n    const spacing = options.spacing;\n    if (!dimensions || !spacing) {\n        throw new Error('createAndCacheLocalImage: dimensions and spacing are required');\n    }\n    const width = dimensions[0];\n    const height = dimensions[1];\n    const columnPixelSpacing = spacing[0];\n    const rowPixelSpacing = spacing[1];\n    const imagePlaneModule = {\n        frameOfReferenceUID,\n        rows: height,\n        columns: width,\n        imageOrientationPatient: direction ?? [1, 0, 0, 0, 1, 0],\n        rowCosines: direction ? direction.slice(0, 3) : [1, 0, 0],\n        columnCosines: direction ? direction.slice(3, 6) : [0, 1, 0],\n        imagePositionPatient: origin ?? [0, 0, 0],\n        pixelSpacing: [rowPixelSpacing, columnPixelSpacing],\n        rowPixelSpacing: rowPixelSpacing,\n        columnPixelSpacing: columnPixelSpacing,\n    };\n    const length = width * height;\n    const numberOfComponents = scalarData.length / length;\n    let scalarDataToUse;\n    if (scalarData) {\n        if (!(scalarData instanceof Uint8Array ||\n            scalarData instanceof Float32Array ||\n            scalarData instanceof Uint16Array ||\n            scalarData instanceof Int16Array)) {\n            throw new Error('createAndCacheLocalImage: scalarData must be of type Uint8Array, Uint16Array, Int16Array or Float32Array');\n        }\n        scalarDataToUse = scalarData;\n    }\n    else if (!skipCreateBuffer) {\n        const { TypedArrayConstructor } = getBufferConfiguration(targetBuffer?.type, length);\n        const imageScalarData = new TypedArrayConstructor(length);\n        scalarDataToUse = imageScalarData;\n    }\n    let bitsAllocated, bitsStored, highBit;\n    if (scalarDataToUse instanceof Uint8Array) {\n        bitsAllocated = 8;\n        bitsStored = 8;\n        highBit = 7;\n    }\n    else if (scalarDataToUse instanceof Uint16Array) {\n        bitsAllocated = 16;\n        bitsStored = 16;\n        highBit = 15;\n    }\n    else if (scalarDataToUse instanceof Int16Array) {\n        bitsAllocated = 16;\n        bitsStored = 16;\n        highBit = 15;\n    }\n    else if (scalarDataToUse instanceof Float32Array) {\n        bitsAllocated = 32;\n        bitsStored = 32;\n        highBit = 31;\n    }\n    else {\n        throw new Error('Unsupported scalarData type');\n    }\n    const imagePixelModule = {\n        samplesPerPixel: 1,\n        photometricInterpretation: scalarDataToUse.length > dimensions[0] * dimensions[1]\n            ? 'RGB'\n            : 'MONOCHROME2',\n        rows: height,\n        columns: width,\n        bitsAllocated,\n        bitsStored,\n        highBit,\n    };\n    const metadata = {\n        imagePlaneModule,\n        imagePixelModule,\n    };\n    ['imagePlaneModule', 'imagePixelModule'].forEach((type) => {\n        genericMetadataProvider.add(imageId, {\n            type,\n            metadata: metadata[type] || {},\n        });\n    });\n    const id = imageId;\n    const voxelManager = (voxelRepresentation === VoxelManagerEnum.RLE &&\n        VoxelManager.createRLEImageVoxelManager({ dimensions, id })) ||\n        VoxelManager.createImageVoxelManager({\n            height,\n            width,\n            numberOfComponents,\n            scalarData: scalarDataToUse,\n            id,\n        });\n    let minPixelValue = scalarDataToUse[0];\n    let maxPixelValue = scalarDataToUse[0];\n    for (let i = 1; i < scalarDataToUse.length; i++) {\n        if (scalarDataToUse[i] < minPixelValue) {\n            minPixelValue = scalarDataToUse[i];\n        }\n        if (scalarDataToUse[i] > maxPixelValue) {\n            maxPixelValue = scalarDataToUse[i];\n        }\n    }\n    const image = {\n        imageId: imageId,\n        intercept: 0,\n        windowCenter: 0,\n        windowWidth: 0,\n        color: imagePixelModule.photometricInterpretation === 'RGB',\n        numberOfComponents: imagePixelModule.samplesPerPixel,\n        dataType: targetBuffer?.type,\n        slope: 1,\n        minPixelValue,\n        maxPixelValue,\n        rows: imagePixelModule.rows,\n        columns: imagePixelModule.columns,\n        getCanvas: undefined,\n        height: imagePixelModule.rows,\n        width: imagePixelModule.columns,\n        rgba: undefined,\n        columnPixelSpacing: imagePlaneModule.columnPixelSpacing,\n        rowPixelSpacing: imagePlaneModule.rowPixelSpacing,\n        FrameOfReferenceUID: imagePlaneModule.frameOfReferenceUID,\n        invert: false,\n        getPixelData: () => voxelManager.getScalarData(),\n        voxelManager,\n        sizeInBytes: scalarData.byteLength,\n        referencedImageId,\n    };\n    onCacheAdd?.(image);\n    cache.putImageSync(image.imageId, image);\n    return image;\n}\nexport function cancelLoadImage(imageId) {\n    const filterFunction = ({ additionalDetails }) => {\n        if (additionalDetails.imageId) {\n            return additionalDetails.imageId !== imageId;\n        }\n        return true;\n    };\n    imageLoadPoolManager.filterRequests(filterFunction);\n    const imageLoadObject = cache.getImageLoadObject(imageId);\n    if (imageLoadObject) {\n        imageLoadObject.cancelFn();\n    }\n}\nexport function cancelLoadImages(imageIds) {\n    imageIds.forEach((imageId) => {\n        cancelLoadImage(imageId);\n    });\n}\nexport function cancelLoadAll() {\n    const requestPool = imageLoadPoolManager.getRequestPool();\n    Object.keys(requestPool).forEach((type) => {\n        const requests = requestPool[type];\n        Object.keys(requests).forEach((priority) => {\n            const requestDetails = requests[priority].pop();\n            if (!requestDetails) {\n                return;\n            }\n            const additionalDetails = requestDetails.additionalDetails;\n            const { imageId, volumeId } = additionalDetails;\n            let loadObject;\n            if (imageId) {\n                loadObject = cache.getImageLoadObject(imageId);\n            }\n            else if (volumeId) {\n                loadObject = cache.getVolumeLoadObject(volumeId);\n            }\n            if (loadObject) {\n                loadObject.cancel();\n            }\n        });\n        imageLoadPoolManager.clearRequestStack(type);\n    });\n}\nexport function registerImageLoader(scheme, imageLoader) {\n    imageLoaders[scheme] = imageLoader;\n}\nexport function registerUnknownImageLoader(imageLoader) {\n    const oldImageLoader = unknownImageLoader;\n    unknownImageLoader = imageLoader;\n    return oldImageLoader;\n}\nexport function unregisterAllImageLoaders() {\n    Object.keys(imageLoaders).forEach((imageLoader) => delete imageLoaders[imageLoader]);\n    unknownImageLoader = undefined;\n}\nexport function createAndCacheDerivedLabelmapImages(referencedImageIds, options = {}) {\n    return createAndCacheDerivedImages(referencedImageIds, {\n        ...options,\n        targetBuffer: { type: 'Uint8Array' },\n    });\n}\nexport function createAndCacheDerivedLabelmapImage(referencedImageId, options = {}) {\n    return createAndCacheDerivedImage(referencedImageId, {\n        ...options,\n        targetBuffer: { type: 'Uint8Array' },\n    });\n}\n","export default class FrameRange {\n    static { this.frameRangeExtractor = /(\\/frames\\/|[&?]frameNumber=)([^/&?]*)/i; }\n    static imageIdToFrames(imageId) {\n        const match = imageId.match(this.frameRangeExtractor);\n        if (!match || !match[2]) {\n            return null;\n        }\n        const range = match[2].split('-').map((it) => Number(it));\n        if (range.length === 1) {\n            return range[0];\n        }\n        return range;\n    }\n    static imageIdToFrameEnd(imageId) {\n        const range = this.imageIdToFrames(imageId);\n        return Array.isArray(range) ? range[1] : range;\n    }\n    static imageIdToFrameStart(imageId) {\n        const range = this.imageIdToFrames(imageId);\n        return Array.isArray(range) ? range[0] : range;\n    }\n    static framesToString(range) {\n        if (Array.isArray(range)) {\n            return `${range[0]}-${range[1]}`;\n        }\n        return String(range);\n    }\n    static framesToImageId(imageId, range) {\n        const match = imageId.match(this.frameRangeExtractor);\n        if (!match || !match[2]) {\n            return null;\n        }\n        const newRangeString = this.framesToString(range);\n        return imageId.replace(this.frameRangeExtractor, `${match[1]}${newRangeString}`);\n    }\n}\n","export default class PointsManager {\n    constructor(configuration = {}) {\n        this._dimensions = 3;\n        this._length = 0;\n        this._byteSize = 4;\n        this.growSize = 128;\n        const { initialSize = 1024, dimensions = 3, growSize = 128, } = configuration;\n        const itemLength = initialSize * dimensions;\n        this.growSize = growSize;\n        this.array = new ArrayBuffer(itemLength * this._byteSize);\n        this.data = new Float32Array(this.array);\n        this._dimensions = dimensions;\n    }\n    forEach(func) {\n        for (let i = 0; i < this._length; i++) {\n            func(this.getPoint(i), i);\n        }\n    }\n    get length() {\n        return this._length;\n    }\n    get dimensions() {\n        return this._dimensions;\n    }\n    get dimensionLength() {\n        return this._length * this._dimensions;\n    }\n    getPoint(index) {\n        if (index < 0) {\n            index += this._length;\n        }\n        if (index < 0 || index >= this._length) {\n            return;\n        }\n        const offset = this._dimensions * index;\n        return this.data.subarray(offset, offset + this._dimensions);\n    }\n    getPointArray(index) {\n        const array = [];\n        if (index < 0) {\n            index += this._length;\n        }\n        if (index < 0 || index >= this._length) {\n            return;\n        }\n        const offset = this._dimensions * index;\n        for (let i = 0; i < this._dimensions; i++) {\n            array.push(this.data[i + offset]);\n        }\n        return array;\n    }\n    grow(additionalSize = 1, growSize = this.growSize) {\n        if (this.dimensionLength + additionalSize * this._dimensions <=\n            this.data.length) {\n            return;\n        }\n        const newSize = this.data.length + growSize;\n        const newArray = new ArrayBuffer(newSize * this._dimensions * this._byteSize);\n        const newData = new Float32Array(newArray);\n        newData.set(this.data);\n        this.data = newData;\n        this.array = newArray;\n    }\n    reverse() {\n        const midLength = Math.floor(this._length / 2);\n        for (let i = 0; i < midLength; i++) {\n            const indexStart = i * this._dimensions;\n            const indexEnd = (this._length - 1 - i) * this._dimensions;\n            for (let dimension = 0; dimension < this._dimensions; dimension++) {\n                const valueStart = this.data[indexStart + dimension];\n                this.data[indexStart + dimension] = this.data[indexEnd + dimension];\n                this.data[indexEnd + dimension] = valueStart;\n            }\n        }\n    }\n    getTypedArray() {\n        return this.data;\n    }\n    push(point) {\n        this.grow(1);\n        const offset = this.length * this._dimensions;\n        for (let i = 0; i < this._dimensions; i++) {\n            this.data[i + offset] = point[i];\n        }\n        this._length++;\n    }\n    map(f) {\n        const mapData = [];\n        for (let i = 0; i < this._length; i++) {\n            mapData.push(f(this.getPoint(i), i));\n        }\n        return mapData;\n    }\n    get points() {\n        return this.map((p) => p);\n    }\n    toXYZ() {\n        const xyz = { x: [], y: [] };\n        if (this._dimensions >= 3) {\n            xyz.z = [];\n        }\n        const { x, y, z } = xyz;\n        this.forEach((p) => {\n            x.push(p[0]);\n            y.push(p[1]);\n            if (z) {\n                z.push(p[2]);\n            }\n        });\n        return xyz;\n    }\n    static fromXYZ({ x, y, z }) {\n        const array = PointsManager.create3(x.length);\n        let offset = 0;\n        for (let i = 0; i < x.length; i++) {\n            array.data[offset++] = x[i];\n            array.data[offset++] = y[i];\n            array.data[offset++] = z ? z[i] : 0;\n        }\n        array._length = x.length;\n        return array;\n    }\n    subselect(count = 10, offset = 0) {\n        const selected = new PointsManager({\n            initialSize: count,\n            dimensions: this._dimensions,\n        });\n        for (let i = 0; i < count; i++) {\n            const index = (offset + Math.floor((this.length * i) / count)) % this.length;\n            selected.push(this.getPoint(index));\n        }\n        return selected;\n    }\n    static create3(initialSize = 128, points) {\n        initialSize = Math.max(initialSize, points?.length || 0);\n        const newPoints = new PointsManager({ initialSize, dimensions: 3 });\n        if (points) {\n            points.forEach((point) => newPoints.push(point));\n        }\n        return newPoints;\n    }\n    static create2(initialSize = 128) {\n        return new PointsManager({ initialSize, dimensions: 2 });\n    }\n}\n","export class PromiseIterator extends Promise {\n}\nexport default class ProgressiveIterator {\n    constructor(name) {\n        this.name = name || 'unknown';\n    }\n    static as(promise) {\n        if (promise.iterator) {\n            return promise.iterator;\n        }\n        const iterator = new ProgressiveIterator('as iterator');\n        promise.then((v) => {\n            try {\n                iterator.add(v, true);\n            }\n            catch (e) {\n                iterator.reject(e);\n            }\n        }, (reason) => {\n            iterator.reject(reason);\n        });\n        return iterator;\n    }\n    add(x, done = false) {\n        this.nextValue = x;\n        this.done ||= done;\n        if (this.waiting) {\n            this.waiting.resolve(x);\n            this.waiting = undefined;\n        }\n    }\n    resolve() {\n        this.done = true;\n        if (this.waiting) {\n            this.waiting.resolve(this.nextValue);\n            this.waiting = undefined;\n        }\n    }\n    reject(reason) {\n        this.rejectReason = reason;\n        this.waiting?.reject(reason);\n    }\n    getRecent() {\n        if (this.rejectReason) {\n            throw this.rejectReason;\n        }\n        return this.nextValue;\n    }\n    async *[Symbol.asyncIterator]() {\n        while (!this.done) {\n            if (this.rejectReason) {\n                throw this.rejectReason;\n            }\n            if (this.nextValue !== undefined) {\n                yield this.nextValue;\n                if (this.done) {\n                    break;\n                }\n            }\n            if (!this.waiting) {\n                this.waiting = {};\n                this.waiting.promise = new Promise((resolve, reject) => {\n                    this.waiting.resolve = resolve;\n                    this.waiting.reject = reject;\n                });\n            }\n            await this.waiting.promise;\n        }\n        yield this.nextValue;\n    }\n    async forEach(callback, errorCallback) {\n        let index = 0;\n        try {\n            for await (const value of this) {\n                const { done } = this;\n                try {\n                    await callback(value, done, index);\n                    index++;\n                }\n                catch (e) {\n                    if (!done) {\n                        console.warn('Caught exception in intermediate value', e);\n                        continue;\n                    }\n                    if (errorCallback) {\n                        errorCallback(e, done);\n                    }\n                    else {\n                        throw e;\n                    }\n                }\n            }\n        }\n        catch (e) {\n            if (errorCallback) {\n                errorCallback(e, true);\n            }\n            else {\n                throw e;\n            }\n        }\n    }\n    generate(processFunction, errorCallback) {\n        return processFunction(this, this.reject.bind(this)).then(() => {\n            if (!this.done) {\n                this.resolve();\n            }\n        }, (reason) => {\n            this.reject(reason);\n            if (errorCallback) {\n                errorCallback(reason);\n            }\n            else {\n                console.warn(\"Couldn't process because\", reason);\n            }\n        });\n    }\n    async nextPromise() {\n        for await (const i of this) {\n            if (i) {\n                return i;\n            }\n        }\n        return this.nextValue;\n    }\n    async donePromise() {\n        for await (const i of this) {\n        }\n        return this.nextValue;\n    }\n    getNextPromise() {\n        const promise = this.nextPromise();\n        promise.iterator = this;\n        return promise;\n    }\n    getDonePromise() {\n        const promise = this.donePromise();\n        promise.iterator = this;\n        return promise;\n    }\n}\n","const ADJACENT_ALL = [\n    [0, -1, 0],\n    [0, 1, 0],\n    [0, 0, -1],\n    [0, 0, 1],\n];\nconst ADJACENT_SINGLE_PLANE = [\n    [0, -1, 0],\n    [0, 1, 0],\n];\nconst ADJACENT_IN = [\n    [0, -1, 0],\n    [0, 1, 0],\n    [0, 0, -1],\n];\nconst ADJACENT_OUT = [\n    [0, -1, 0],\n    [0, 1, 0],\n    [0, 0, 1],\n];\nexport default class RLEVoxelMap {\n    static copyMap(destination, source) {\n        for (const [index, row] of source.rows) {\n            destination.rows.set(index, structuredClone(row));\n        }\n    }\n    constructor(width, height, depth = 1) {\n        this.rows = new Map();\n        this.height = 1;\n        this.width = 1;\n        this.depth = 1;\n        this.jMultiple = 1;\n        this.kMultiple = 1;\n        this.numComps = 1;\n        this.pixelDataConstructor = Uint8Array;\n        this.updateScalarData = function (scalarData) {\n            scalarData.fill(0);\n            const callback = (index, rle, row) => {\n                const { start, end, value } = rle;\n                for (let i = start; i < end; i++) {\n                    scalarData[index + i] = value;\n                }\n            };\n            this.forEach(callback);\n        };\n        this.get = (index) => {\n            const i = index % this.jMultiple;\n            const j = (index - i) / this.jMultiple;\n            const rle = this.getRLE(i, j);\n            return rle?.value ?? this.defaultValue;\n        };\n        this.getRun = (j, k) => {\n            const runIndex = j + k * this.height;\n            return this.rows.get(runIndex);\n        };\n        this.set = (index, value) => {\n            if (value === undefined) {\n                return;\n            }\n            const i = index % this.width;\n            const j = (index - i) / this.width;\n            const row = this.rows.get(j);\n            if (!row) {\n                this.rows.set(j, [{ start: i, end: i + 1, value }]);\n                return;\n            }\n            const rleIndex = this.findIndex(row, i);\n            const rle1 = row[rleIndex];\n            const rle0 = row[rleIndex - 1];\n            if (!rle1) {\n                if (!rle0 || rle0.value !== value || rle0.end !== i) {\n                    row[rleIndex] = { start: i, end: i + 1, value };\n                    return;\n                }\n                rle0.end++;\n                return;\n            }\n            const { start, end, value: oldValue } = rle1;\n            if (value === oldValue && i >= start) {\n                return;\n            }\n            const rleInsert = { start: i, end: i + 1, value };\n            const isAfter = i > start;\n            const insertIndex = isAfter ? rleIndex + 1 : rleIndex;\n            const rlePrev = isAfter ? rle1 : rle0;\n            let rleNext = isAfter ? row[rleIndex + 1] : rle1;\n            if (rlePrev?.value === value && rlePrev?.end === i) {\n                rlePrev.end++;\n                if (rleNext?.value === value && rleNext.start === i + 1) {\n                    rlePrev.end = rleNext.end;\n                    row.splice(rleIndex, 1);\n                }\n                else if (rleNext?.start === i) {\n                    rleNext.start++;\n                    if (rleNext.start === rleNext.end) {\n                        row.splice(rleIndex, 1);\n                        rleNext = row[rleIndex];\n                        if (rleNext?.start === i + 1 && rleNext.value === value) {\n                            rlePrev.end = rleNext.end;\n                            row.splice(rleIndex, 1);\n                        }\n                    }\n                }\n                return;\n            }\n            if (rleNext?.value === value && rleNext.start === i + 1) {\n                rleNext.start--;\n                if (rlePrev?.end > i) {\n                    rlePrev.end = i;\n                    if (rlePrev.end === rlePrev.start) {\n                        row.splice(rleIndex, 1);\n                    }\n                }\n                return;\n            }\n            if (rleNext?.start === i && rleNext.end === i + 1) {\n                rleNext.value = value;\n                const nextnext = row[rleIndex + 1];\n                if (nextnext?.start == i + 1 && nextnext.value === value) {\n                    row.splice(rleIndex + 1, 1);\n                    rleNext.end = nextnext.end;\n                }\n                return;\n            }\n            if (i === rleNext?.start) {\n                rleNext.start++;\n            }\n            if (isAfter && end > i + 1) {\n                row.splice(insertIndex, 0, rleInsert, {\n                    start: i + 1,\n                    end: rlePrev.end,\n                    value: rlePrev.value,\n                });\n            }\n            else {\n                row.splice(insertIndex, 0, rleInsert);\n            }\n            if (rlePrev?.end > i) {\n                rlePrev.end = i;\n            }\n        };\n        this.width = width;\n        this.height = height;\n        this.depth = depth;\n        this.jMultiple = width;\n        this.kMultiple = this.jMultiple * height;\n    }\n    static { this.getScalarData = function (ArrayType = Uint8ClampedArray) {\n        const scalarData = new ArrayType(this.frameSize);\n        this.map.updateScalarData(scalarData);\n        return scalarData;\n    }; }\n    toIJK(index) {\n        const i = index % this.jMultiple;\n        const j = ((index - i) / this.jMultiple) % this.height;\n        const k = Math.floor(index / this.kMultiple);\n        return [i, j, k];\n    }\n    toIndex([i, j, k]) {\n        return i + k * this.kMultiple + j * this.jMultiple;\n    }\n    getRLE(i, j, k = 0) {\n        const row = this.rows.get(j + k * this.height);\n        if (!row) {\n            return;\n        }\n        const index = this.findIndex(row, i);\n        const rle = row[index];\n        return i >= rle?.start ? rle : undefined;\n    }\n    has(index) {\n        const i = index % this.jMultiple;\n        const j = (index - i) / this.jMultiple;\n        const rle = this.getRLE(i, j);\n        return rle?.value !== undefined;\n    }\n    delete(index) {\n        const i = index % this.width;\n        const j = (index - i) / this.width;\n        const row = this.rows.get(j);\n        if (!row) {\n            return;\n        }\n        const rleIndex = this.findIndex(row, i);\n        const rle = row[rleIndex];\n        if (!rle || rle.start > i) {\n            return;\n        }\n        if (rle.end === i + 1) {\n            rle.end--;\n            if (rle.start >= rle.end) {\n                row.splice(rleIndex, 1);\n                if (!row.length) {\n                    this.rows.delete(j);\n                }\n            }\n            return;\n        }\n        if (rle.start === i) {\n            rle.start++;\n            return;\n        }\n        const newRle = {\n            value: rle.value,\n            start: i + 1,\n            end: rle.end,\n        };\n        rle.end = i;\n        row.splice(rleIndex + 1, 0, newRle);\n    }\n    findIndex(row, i) {\n        for (let index = 0; index < row.length; index++) {\n            const { end: iEnd } = row[index];\n            if (i < iEnd) {\n                return index;\n            }\n        }\n        return row.length;\n    }\n    forEach(callback, options) {\n        const rowModified = options?.rowModified;\n        for (const [baseIndex, row] of this.rows) {\n            const rowToUse = rowModified ? [...row] : row;\n            for (const rle of rowToUse) {\n                callback(baseIndex * this.width, rle, row);\n            }\n        }\n    }\n    forEachRow(callback) {\n        for (const [baseIndex, row] of this.rows) {\n            callback(baseIndex * this.width, row);\n        }\n    }\n    clear() {\n        this.rows.clear();\n    }\n    keys() {\n        return [...this.rows.keys()];\n    }\n    getPixelData(k = 0, pixelData) {\n        if (!pixelData) {\n            pixelData = new this.pixelDataConstructor(this.width * this.height * this.numComps);\n        }\n        else {\n            pixelData.fill(0);\n        }\n        const { width, height, numComps } = this;\n        for (let j = 0; j < height; j++) {\n            const row = this.getRun(j, k);\n            if (!row) {\n                continue;\n            }\n            if (numComps === 1) {\n                for (const rle of row) {\n                    const rowOffset = j * width;\n                    const { start, end, value } = rle;\n                    for (let i = start; i < end; i++) {\n                        pixelData[rowOffset + i] = value;\n                    }\n                }\n            }\n            else {\n                for (const rle of row) {\n                    const rowOffset = j * width * numComps;\n                    const { start, end, value } = rle;\n                    for (let i = start; i < end; i += numComps) {\n                        for (let comp = 0; comp < numComps; comp++) {\n                            pixelData[rowOffset + i + comp] = value[comp];\n                        }\n                    }\n                }\n            }\n        }\n        return pixelData;\n    }\n    floodFill(i, j, k, value, options) {\n        const rle = this.getRLE(i, j, k);\n        if (!rle) {\n            throw new Error(`Initial point ${i},${j},${k} isn't in the RLE`);\n        }\n        const stack = [[rle, j, k]];\n        const replaceValue = rle.value;\n        if (replaceValue === value) {\n            throw new Error(`source (${replaceValue}) and destination (${value}) are identical`);\n        }\n        return this.flood(stack, replaceValue, value, options);\n    }\n    flood(stack, sourceValue, value, options) {\n        let sum = 0;\n        const { planar = true, diagonals = true, singlePlane = false, } = options || {};\n        const childOptions = { planar, diagonals, singlePlane };\n        while (stack.length) {\n            const top = stack.pop();\n            const [current] = top;\n            if (current.value !== sourceValue) {\n                continue;\n            }\n            current.value = value;\n            sum += current.end - current.start;\n            const adjacents = this.findAdjacents(top, childOptions).filter((adjacent) => adjacent && adjacent[0].value === sourceValue);\n            stack.push(...adjacents);\n        }\n        return sum;\n    }\n    fillFrom(getter, boundsIJK) {\n        for (let k = boundsIJK[2][0]; k <= boundsIJK[2][1]; k++) {\n            for (let j = boundsIJK[1][0]; j <= boundsIJK[1][1]; j++) {\n                let rle;\n                let row;\n                for (let i = boundsIJK[0][0]; i <= boundsIJK[0][1]; i++) {\n                    const value = getter(i, j, k);\n                    if (value === undefined) {\n                        rle = undefined;\n                        continue;\n                    }\n                    if (!row) {\n                        row = [];\n                        this.rows.set(j + k * this.height, row);\n                    }\n                    if (rle && rle.value !== value) {\n                        rle = undefined;\n                    }\n                    if (!rle) {\n                        rle = { start: i, end: i, value };\n                        row.push(rle);\n                    }\n                    rle.end++;\n                }\n            }\n        }\n    }\n    findAdjacents(item, { diagonals = true, planar = true, singlePlane = false }) {\n        const [rle, j, k, adjacentsDelta] = item;\n        const { start, end } = rle;\n        const leftRle = start > 0 && this.getRLE(start - 1, j, k);\n        const rightRle = end < this.width && this.getRLE(end, j, k);\n        const range = diagonals\n            ? [start > 0 ? start - 1 : start, end < this.width ? end + 1 : end]\n            : [start, end];\n        const adjacents = [];\n        if (leftRle) {\n            adjacents.push([leftRle, j, k]);\n        }\n        if (rightRle) {\n            adjacents.push([rightRle, j, k]);\n        }\n        for (const delta of adjacentsDelta ||\n            (singlePlane ? ADJACENT_SINGLE_PLANE : ADJACENT_ALL)) {\n            const [, delta1, delta2] = delta;\n            const testJ = delta1 + j;\n            const testK = delta2 + k;\n            if (testJ < 0 || testJ >= this.height) {\n                continue;\n            }\n            if (testK < 0 || testK >= this.depth) {\n                continue;\n            }\n            const row = this.getRun(testJ, testK);\n            if (!row) {\n                continue;\n            }\n            for (const testRle of row) {\n                const newAdjacentDelta = adjacentsDelta ||\n                    (singlePlane && ADJACENT_SINGLE_PLANE) ||\n                    (planar && delta2 > 0 && ADJACENT_OUT) ||\n                    (planar && delta2 < 0 && ADJACENT_IN) ||\n                    ADJACENT_ALL;\n                if (!(testRle.end <= range[0] || testRle.start >= range[1])) {\n                    adjacents.push([testRle, testJ, testK, newAdjacentDelta]);\n                }\n            }\n        }\n        return adjacents;\n    }\n}\n","export function isImageActor(actorEntry) {\n    return (actorIsA(actorEntry, 'vtkVolume') || actorIsA(actorEntry, 'vtkImageSlice'));\n}\nexport function actorIsA(actorEntry, actorType) {\n    const actorToCheck = 'isA' in actorEntry ? actorEntry : actorEntry.actor;\n    if (!actorToCheck) {\n        return false;\n    }\n    return !!actorToCheck.isA(actorType);\n}\n","import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nexport default function applyPreset(actor, preset) {\n    const colorTransferArray = preset.colorTransfer\n        .split(' ')\n        .splice(1)\n        .map(parseFloat);\n    const { shiftRange } = getShiftRange(colorTransferArray);\n    const min = shiftRange[0];\n    const width = shiftRange[1] - shiftRange[0];\n    const cfun = vtkColorTransferFunction.newInstance();\n    const normColorTransferValuePoints = [];\n    for (let i = 0; i < colorTransferArray.length; i += 4) {\n        let value = colorTransferArray[i];\n        const r = colorTransferArray[i + 1];\n        const g = colorTransferArray[i + 2];\n        const b = colorTransferArray[i + 3];\n        value = (value - min) / width;\n        normColorTransferValuePoints.push([value, r, g, b]);\n    }\n    applyPointsToRGBFunction(normColorTransferValuePoints, shiftRange, cfun);\n    actor.getProperty().setRGBTransferFunction(0, cfun);\n    const scalarOpacityArray = preset.scalarOpacity\n        .split(' ')\n        .splice(1)\n        .map(parseFloat);\n    const ofun = vtkPiecewiseFunction.newInstance();\n    const normPoints = [];\n    for (let i = 0; i < scalarOpacityArray.length; i += 2) {\n        let value = scalarOpacityArray[i];\n        const opacity = scalarOpacityArray[i + 1];\n        value = (value - min) / width;\n        normPoints.push([value, opacity]);\n    }\n    applyPointsToPiecewiseFunction(normPoints, shiftRange, ofun);\n    const property = actor.getProperty();\n    property.setScalarOpacity(0, ofun);\n    const [gradientMinValue, gradientMinOpacity, gradientMaxValue, gradientMaxOpacity,] = preset.gradientOpacity.split(' ').splice(1).map(parseFloat);\n    property.setUseGradientOpacity(0, true);\n    property.setGradientOpacityMinimumValue(0, gradientMinValue);\n    property.setGradientOpacityMinimumOpacity(0, gradientMinOpacity);\n    property.setGradientOpacityMaximumValue(0, gradientMaxValue);\n    property.setGradientOpacityMaximumOpacity(0, gradientMaxOpacity);\n    if (preset.interpolation === '1') {\n        property.setInterpolationTypeToFastLinear();\n    }\n    property.setShade(preset.shade === '1');\n    const ambient = parseFloat(preset.ambient);\n    const diffuse = parseFloat(preset.diffuse);\n    const specular = parseFloat(preset.specular);\n    const specularPower = parseFloat(preset.specularPower);\n    property.setAmbient(ambient);\n    property.setDiffuse(diffuse);\n    property.setSpecular(specular);\n    property.setSpecularPower(specularPower);\n}\nfunction getShiftRange(colorTransferArray) {\n    let min = Infinity;\n    let max = -Infinity;\n    for (let i = 0; i < colorTransferArray.length; i += 4) {\n        min = Math.min(min, colorTransferArray[i]);\n        max = Math.max(max, colorTransferArray[i]);\n    }\n    const center = (max - min) / 2;\n    return {\n        shiftRange: [-center, center],\n        min,\n        max,\n    };\n}\nfunction applyPointsToRGBFunction(points, range, cfun) {\n    const width = range[1] - range[0];\n    const rescaled = points.map(([x, r, g, b]) => [\n        x * width + range[0],\n        r,\n        g,\n        b,\n    ]);\n    cfun.removeAllPoints();\n    rescaled.forEach(([x, r, g, b]) => cfun.addRGBPoint(x, r, g, b));\n    return rescaled;\n}\nfunction applyPointsToPiecewiseFunction(points, range, pwf) {\n    const width = range[1] - range[0];\n    const rescaled = points.map(([x, y]) => [x * width + range[0], y]);\n    pwf.removeAllPoints();\n    rescaled.forEach(([x, y]) => pwf.addPoint(x, y));\n    return rescaled;\n}\n","import { getRenderingEngines } from '../RenderingEngine/getRenderingEngine';\nimport getViewportsWithVolumeId from './getViewportsWithVolumeId';\nconst autoLoad = (volumeId) => {\n    const renderingEngineAndViewportIds = getRenderingEngineAndViewportsContainingVolume(volumeId);\n    if (!renderingEngineAndViewportIds?.length) {\n        return;\n    }\n    renderingEngineAndViewportIds.forEach(({ renderingEngine, viewportIds }) => {\n        if (!renderingEngine.hasBeenDestroyed) {\n            renderingEngine.renderViewports(viewportIds);\n        }\n    });\n};\nfunction getRenderingEngineAndViewportsContainingVolume(volumeId) {\n    const renderingEnginesArray = getRenderingEngines();\n    const renderingEngineAndViewportIds = [];\n    renderingEnginesArray.forEach((renderingEngine) => {\n        const viewports = getViewportsWithVolumeId(volumeId);\n        if (viewports.length) {\n            renderingEngineAndViewportIds.push({\n                renderingEngine,\n                viewportIds: viewports.map((viewport) => viewport.id),\n            });\n        }\n    });\n    return renderingEngineAndViewportIds;\n}\nexport default autoLoad;\n","import * as metaData from '../metaData';\nimport { MetadataModules, VOILUTFunctionType } from '../enums';\nexport function getValidVOILUTFunction(voiLUTFunction) {\n    if (!Object.values(VOILUTFunctionType).includes(voiLUTFunction)) {\n        return VOILUTFunctionType.LINEAR;\n    }\n    return voiLUTFunction;\n}\nexport function getImagePlaneModule(imageId) {\n    const imagePlaneModule = metaData.get(MetadataModules.IMAGE_PLANE, imageId);\n    const newImagePlaneModule = {\n        ...imagePlaneModule,\n    };\n    if (!newImagePlaneModule.columnPixelSpacing) {\n        newImagePlaneModule.columnPixelSpacing = 1;\n    }\n    if (!newImagePlaneModule.rowPixelSpacing) {\n        newImagePlaneModule.rowPixelSpacing = 1;\n    }\n    if (!newImagePlaneModule.columnCosines) {\n        newImagePlaneModule.columnCosines = [0, 1, 0];\n    }\n    if (!newImagePlaneModule.rowCosines) {\n        newImagePlaneModule.rowCosines = [1, 0, 0];\n    }\n    if (!newImagePlaneModule.imagePositionPatient) {\n        newImagePlaneModule.imagePositionPatient = [0, 0, 0];\n    }\n    if (!newImagePlaneModule.imageOrientationPatient) {\n        newImagePlaneModule.imageOrientationPatient = new Float32Array([\n            1, 0, 0, 0, 1, 0,\n        ]);\n    }\n    return newImagePlaneModule;\n}\nexport function calibrateImagePlaneModule(imageId, imagePlaneModule, currentCalibration) {\n    const calibration = metaData.get('calibratedPixelSpacing', imageId);\n    const isUpdated = currentCalibration !== calibration;\n    const { scale } = calibration || {};\n    const hasPixelSpacing = scale > 0 || imagePlaneModule.rowPixelSpacing > 0;\n    imagePlaneModule.calibration = calibration;\n    if (!isUpdated) {\n        return { imagePlaneModule, hasPixelSpacing };\n    }\n    return {\n        imagePlaneModule,\n        hasPixelSpacing,\n        calibrationEvent: {\n            scale,\n            calibration,\n        },\n    };\n}\nexport function buildMetadata(image) {\n    const imageId = image.imageId;\n    const { pixelRepresentation, bitsAllocated, bitsStored, highBit, photometricInterpretation, samplesPerPixel, } = metaData.get('imagePixelModule', imageId);\n    const { windowWidth, windowCenter, voiLUTFunction } = image;\n    const { modality } = metaData.get('generalSeriesModule', imageId);\n    const imageIdScalingFactor = metaData.get('scalingModule', imageId);\n    const calibration = metaData.get(MetadataModules.CALIBRATION, imageId);\n    const voiLUTFunctionEnum = getValidVOILUTFunction(voiLUTFunction);\n    const imagePlaneModule = getImagePlaneModule(imageId);\n    return {\n        calibration,\n        scalingFactor: imageIdScalingFactor,\n        voiLUTFunction: voiLUTFunctionEnum,\n        modality,\n        imagePlaneModule,\n        imagePixelModule: {\n            bitsAllocated,\n            bitsStored,\n            samplesPerPixel,\n            highBit,\n            photometricInterpretation,\n            pixelRepresentation,\n            windowWidth: windowWidth,\n            windowCenter: windowCenter,\n            modality,\n            voiLUTFunction: voiLUTFunctionEnum,\n        },\n    };\n}\n","import { vec3 } from 'gl-matrix';\nimport * as metaData from '../metaData';\nimport { getConfiguration } from '../init';\nexport default function calculateSpacingBetweenImageIds(imageIds) {\n    const { imagePositionPatient: referenceImagePositionPatient, imageOrientationPatient, } = metaData.get('imagePlaneModule', imageIds[0]);\n    const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n    const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n    const scanAxisNormal = vec3.create();\n    vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\n    const refIppVec = vec3.fromValues(referenceImagePositionPatient[0], referenceImagePositionPatient[1], referenceImagePositionPatient[2]);\n    const usingWadoUri = imageIds[0].split(':')[0] === 'wadouri';\n    let spacing;\n    function getDistance(imageId) {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const positionVector = vec3.create();\n        const ippVec = vec3.fromValues(imagePositionPatient[0], imagePositionPatient[1], imagePositionPatient[2]);\n        vec3.sub(positionVector, refIppVec, ippVec);\n        return vec3.dot(positionVector, scanAxisNormal);\n    }\n    if (!usingWadoUri) {\n        const distanceImagePairs = imageIds.map((imageId) => {\n            const distance = getDistance(imageId);\n            return {\n                distance,\n                imageId,\n            };\n        });\n        distanceImagePairs.sort((a, b) => b.distance - a.distance);\n        const numImages = distanceImagePairs.length;\n        spacing =\n            Math.abs(distanceImagePairs[numImages - 1].distance -\n                distanceImagePairs[0].distance) /\n                (numImages - 1);\n    }\n    else {\n        const prefetchedImageIds = [\n            imageIds[0],\n            imageIds[Math.floor(imageIds.length / 2)],\n        ];\n        const firstImageDistance = getDistance(prefetchedImageIds[0]);\n        const middleImageDistance = getDistance(prefetchedImageIds[1]);\n        const metadataForMiddleImage = metaData.get('imagePlaneModule', prefetchedImageIds[1]);\n        if (!metadataForMiddleImage) {\n            throw new Error('Incomplete metadata required for volume construction.');\n        }\n        const positionVector = vec3.create();\n        const middleIppVec = vec3.fromValues(metadataForMiddleImage.imagePositionPatient[0], metadataForMiddleImage.imagePositionPatient[1], metadataForMiddleImage.imagePositionPatient[2]);\n        vec3.sub(positionVector, refIppVec, middleIppVec);\n        const distanceBetweenFirstAndMiddleImages = vec3.dot(positionVector, scanAxisNormal);\n        spacing =\n            Math.abs(distanceBetweenFirstAndMiddleImages) /\n                Math.floor(imageIds.length / 2);\n    }\n    const { sliceThickness, spacingBetweenSlices } = metaData.get('imagePlaneModule', imageIds[0]);\n    const { strictZSpacingForVolumeViewport } = getConfiguration().rendering;\n    if ((spacing === 0 || isNaN(spacing)) && !strictZSpacingForVolumeViewport) {\n        if (spacingBetweenSlices) {\n            console.debug('Could not calculate spacing. Using spacingBetweenSlices');\n            spacing = spacingBetweenSlices;\n        }\n        else if (sliceThickness) {\n            console.debug('Could not calculate spacing and no spacingBetweenSlices. Using sliceThickness');\n            spacing = sliceThickness;\n        }\n        else {\n            console.debug('Could not calculate spacing. The VolumeViewport visualization is compromised. Setting spacing to 1 to render');\n            spacing = 1;\n        }\n    }\n    return spacing;\n}\n","function clamp(value, min, max) {\n    return Math.max(min, Math.min(max, value));\n}\nexport { clamp as default, clamp };\n","import vtkColorMaps from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction/ColorMaps';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nimport isEqual from './isEqual';\nimport { actorIsA } from './actorCheck';\nconst _colormaps = new Map();\nfunction registerColormap(colormap) {\n    colormap.name = colormap.name || colormap.Name;\n    _colormaps.set(colormap.name, colormap);\n}\nfunction getColormap(name) {\n    return _colormaps.get(name);\n}\nfunction getColormapNames() {\n    return Array.from(_colormaps.keys());\n}\nfunction findMatchingColormap(rgbPoints, actor) {\n    const colormapsVTK = vtkColorMaps.rgbPresetNames.map((presetName) => vtkColorMaps.getPresetByName(presetName));\n    const colormapsCS3D = getColormapNames().map((colormapName) => getColormap(colormapName));\n    const colormaps = colormapsVTK.concat(colormapsCS3D);\n    const matchedColormap = colormaps.find((colormap) => {\n        const { RGBPoints: presetRGBPoints } = colormap;\n        if (presetRGBPoints.length !== rgbPoints.length) {\n            return false;\n        }\n        for (let i = 0; i < presetRGBPoints.length; i += 4) {\n            if (!isEqual(presetRGBPoints.slice(i + 1, i + 4), rgbPoints.slice(i + 1, i + 4))) {\n                return false;\n            }\n        }\n        return true;\n    });\n    if (!matchedColormap) {\n        return null;\n    }\n    const opacity = [];\n    if (actorIsA(actor, 'vtkVolume')) {\n        const opacityPoints = actor\n            .getProperty()\n            .getScalarOpacity(0)\n            .getDataPointer();\n        if (!opacityPoints) {\n            return {\n                name: matchedColormap.Name,\n            };\n        }\n        for (let i = 0; i < opacityPoints.length; i += 2) {\n            opacity.push({\n                value: opacityPoints[i],\n                opacity: opacityPoints[i + 1],\n            });\n        }\n    }\n    const result = {\n        name: matchedColormap.Name,\n        ...(Array.isArray(opacity) && opacity.length > 0 && { opacity }),\n        ...(typeof opacity === 'number' && { opacity }),\n    };\n    return result;\n}\nexport function setColorMapTransferFunctionForVolumeActor(volumeInfo) {\n    const { volumeActor, preset, opacity = 0.9, threshold = null, colorRange = [0, 5], } = volumeInfo;\n    const mapper = volumeActor.getMapper();\n    mapper.setSampleDistance(1.0);\n    const cfun = vtkColorTransferFunction.newInstance();\n    const presetToUse = preset || vtkColorMaps.getPresetByName('hsv');\n    cfun.applyColorMap(presetToUse);\n    cfun.setMappingRange(colorRange[0], colorRange[1]);\n    volumeActor.getProperty().setRGBTransferFunction(0, cfun);\n    updateOpacityWithThreshold(volumeActor, opacity, threshold);\n}\nexport function updateOpacity(volumeActor, newOpacity) {\n    const currentThreshold = getThresholdValue(volumeActor);\n    updateOpacityWithThreshold(volumeActor, newOpacity, currentThreshold);\n}\nexport function updateThreshold(volumeActor, newThreshold) {\n    const currentOpacity = getMaxOpacity(volumeActor);\n    updateOpacityWithThreshold(volumeActor, currentOpacity, newThreshold);\n}\nfunction updateOpacityWithThreshold(volumeActor, opacity, threshold) {\n    const meta = volumeActor.getMapper().getInputData().get('voxelManager');\n    if (!meta?.voxelManager) {\n        throw new Error('No voxel manager was found for the volume actor, or you cannot yet update opacity with a threshold using stacked images');\n    }\n    const range = meta.voxelManager.getRange();\n    const ofun = vtkPiecewiseFunction.newInstance();\n    if (threshold !== null) {\n        const delta = Math.abs(range[1] - range[0]) * 0.001;\n        const thresholdValue = Math.max(range[0], Math.min(range[1], threshold));\n        ofun.addPoint(range[0], 0);\n        ofun.addPoint(thresholdValue - delta, 0);\n        ofun.addPoint(thresholdValue, opacity);\n        ofun.addPoint(range[1], opacity);\n    }\n    else {\n        ofun.addPoint(range[0], opacity);\n        ofun.addPoint(range[1], opacity);\n    }\n    volumeActor.getProperty().setScalarOpacity(0, ofun);\n}\nfunction getThresholdValue(volumeActor) {\n    const opacityFunction = volumeActor.getProperty().getScalarOpacity(0);\n    if (!opacityFunction) {\n        return null;\n    }\n    const dataArray = opacityFunction.getDataPointer();\n    if (!dataArray || dataArray.length <= 4) {\n        return null;\n    }\n    for (let i = 0; i < dataArray.length - 2; i += 2) {\n        const x1 = dataArray[i];\n        const y1 = dataArray[i + 1];\n        const x2 = dataArray[i + 2];\n        const y2 = dataArray[i + 3];\n        if (y1 === 0 && y2 > 0) {\n            return x2;\n        }\n    }\n    return null;\n}\nfunction getMaxOpacity(volumeActor) {\n    const opacityFunction = volumeActor.getProperty().getScalarOpacity(0);\n    if (!opacityFunction) {\n        return 1.0;\n    }\n    const dataArray = opacityFunction.getDataPointer();\n    if (!dataArray || dataArray.length === 0) {\n        return 1.0;\n    }\n    let maxOpacity = 0;\n    for (let i = 1; i < dataArray.length; i += 2) {\n        if (dataArray[i] > maxOpacity) {\n            maxOpacity = dataArray[i];\n        }\n    }\n    return maxOpacity;\n}\nexport { getColormap, getColormapNames, registerColormap, findMatchingColormap, getThresholdValue, getMaxOpacity, };\n","import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nexport default function createLinearRGBTransferFunction(voiRange) {\n    const cfun = vtkColorTransferFunction.newInstance();\n    let lower = 0;\n    let upper = 1024;\n    if (voiRange.lower !== undefined && voiRange.upper !== undefined) {\n        lower = voiRange.lower;\n        upper = voiRange.upper;\n    }\n    cfun.addRGBPoint(lower, 0.0, 0.0, 0.0);\n    cfun.addRGBPoint(upper, 1.0, 1.0, 1.0);\n    return cfun;\n}\n","import vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport * as windowLevelUtil from './windowLevel';\nimport { logit } from './logit';\nexport default function createSigmoidRGBTransferFunction(voiRange, approximationNodes = 1024) {\n    const { windowWidth, windowCenter } = windowLevelUtil.toWindowLevel(voiRange.lower, voiRange.upper);\n    const range = Array.from({ length: approximationNodes }, (_, i) => (i + 1) / (approximationNodes + 2));\n    const table = range.flatMap((y) => {\n        const x = logit(y, windowCenter, windowWidth);\n        return [x, y, y, y, 0.5, 0.0];\n    });\n    const cfun = vtkColorTransferFunction.newInstance();\n    cfun.buildFunctionFromArray(vtkDataArray.newInstance({\n        values: table,\n        numberOfComponents: 6,\n    }));\n    return cfun;\n}\n","export default function decimate(list, interleave, offset = 0) {\n    const interleaveIndices = [];\n    for (let i = offset; i < list.length; i += interleave) {\n        interleaveIndices.push(i);\n    }\n    return interleaveIndices;\n}\n","export function deepClone(obj) {\n    if (obj === null || typeof obj !== 'object') {\n        return obj;\n    }\n    if (typeof obj === 'function') {\n        return obj;\n    }\n    if (typeof structuredClone === 'function') {\n        return obj;\n    }\n    if (Array.isArray(obj)) {\n        return obj.map(deepClone);\n    }\n    else {\n        const clonedObj = {};\n        for (const key in obj) {\n            if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                clonedObj[key] = deepClone(obj[key]);\n            }\n        }\n        return clonedObj;\n    }\n}\n","export default function fnv1aHash(str) {\n    let hash = 0x811c9dc5;\n    for (let i = 0; i < str.length; i++) {\n        hash ^= str.charCodeAt(i);\n        hash +=\n            (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);\n    }\n    return (hash >>> 0).toString(36);\n}\n","import { vec3 } from 'gl-matrix';\nimport * as metaData from '../metaData';\nimport { coreLog } from './logger';\nimport getSpacingInNormalDirection from './getSpacingInNormalDirection';\nimport { EPSILON } from '../constants';\nconst log = coreLog.getLogger('utilities', 'getClosestImageId');\nexport default function getClosestImageId(imageVolume, worldPos, viewPlaneNormal, options) {\n    const { direction, spacing, imageIds } = imageVolume;\n    const { ignoreSpacing = false } = options || {};\n    if (!imageIds?.length) {\n        return;\n    }\n    const kVector = direction.slice(6, 9);\n    const dotProduct = vec3.dot(kVector, viewPlaneNormal);\n    if (Math.abs(dotProduct) < 1 - EPSILON) {\n        return;\n    }\n    let halfSpacingInNormalDirection;\n    if (!ignoreSpacing) {\n        const spacingInNormalDirection = getSpacingInNormalDirection({ direction, spacing }, viewPlaneNormal);\n        halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    }\n    let closestImageId;\n    let minDistance = Infinity;\n    for (let i = 0; i < imageIds.length; i++) {\n        const imageId = imageIds[i];\n        const imagePlaneModule = metaData.get('imagePlaneModule', imageId);\n        if (!imagePlaneModule?.imagePositionPatient) {\n            log.warn(`Missing imagePositionPatient for imageId: ${imageId}`);\n            continue;\n        }\n        const { imagePositionPatient } = imagePlaneModule;\n        const dir = vec3.create();\n        vec3.sub(dir, worldPos, imagePositionPatient);\n        const distance = Math.abs(vec3.dot(dir, viewPlaneNormal));\n        if (ignoreSpacing) {\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestImageId = imageId;\n            }\n        }\n        else {\n            if (distance < halfSpacingInNormalDirection && distance < minDistance) {\n                minDistance = distance;\n                closestImageId = imageId;\n            }\n        }\n    }\n    if (closestImageId === undefined) {\n        log.warn('No imageId found within the specified criteria (half spacing or absolute closest).');\n    }\n    return closestImageId;\n}\n","import { vec3 } from 'gl-matrix';\nimport { EPSILON } from '../constants';\nimport { buildMetadata } from './buildMetadata';\nexport function getImageDataMetadata(image) {\n    const { imagePlaneModule, imagePixelModule, voiLUTFunction, modality, scalingFactor, calibration, } = buildMetadata(image);\n    let { rowCosines, columnCosines } = imagePlaneModule;\n    if (rowCosines == null || columnCosines == null) {\n        rowCosines = [1, 0, 0];\n        columnCosines = [0, 1, 0];\n    }\n    const rowCosineVec = vec3.fromValues(rowCosines[0], rowCosines[1], rowCosines[2]);\n    const colCosineVec = vec3.fromValues(columnCosines[0], columnCosines[1], columnCosines[2]);\n    const scanAxisNormal = vec3.create();\n    vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\n    let origin = imagePlaneModule.imagePositionPatient;\n    if (origin == null) {\n        origin = [0, 0, 0];\n    }\n    const xSpacing = imagePlaneModule.columnPixelSpacing || image.columnPixelSpacing;\n    const ySpacing = imagePlaneModule.rowPixelSpacing || image.rowPixelSpacing;\n    const xVoxels = image.columns;\n    const yVoxels = image.rows;\n    const zSpacing = EPSILON;\n    const zVoxels = 1;\n    if (!imagePixelModule.photometricInterpretation &&\n        image.sizeInBytes === 3 * image.width * image.height) {\n        image.numberOfComponents = 3;\n    }\n    const numberOfComponents = image.numberOfComponents ||\n        _getNumCompsFromPhotometricInterpretation(imagePixelModule.photometricInterpretation);\n    return {\n        numberOfComponents,\n        origin,\n        direction: [...rowCosineVec, ...colCosineVec, ...scanAxisNormal],\n        dimensions: [xVoxels, yVoxels, zVoxels],\n        spacing: [xSpacing, ySpacing, zSpacing],\n        numVoxels: xVoxels * yVoxels * zVoxels,\n        imagePlaneModule,\n        imagePixelModule,\n        bitsAllocated: imagePixelModule.bitsAllocated,\n        voiLUTFunction,\n        modality,\n        scalingFactor,\n        calibration,\n        scanAxisNormal: scanAxisNormal,\n    };\n}\nfunction _getNumCompsFromPhotometricInterpretation(photometricInterpretation) {\n    let numberOfComponents = 1;\n    if (photometricInterpretation === 'RGB' ||\n        photometricInterpretation?.includes('YBR') ||\n        photometricInterpretation === 'PALETTE COLOR') {\n        numberOfComponents = 3;\n    }\n    return numberOfComponents;\n}\n","import getSliceRange from './getSliceRange';\nimport getTargetVolumeAndSpacingInNormalDir from './getTargetVolumeAndSpacingInNormalDir';\nfunction getImageSliceDataForVolumeViewport(viewport) {\n    const camera = viewport.getCamera();\n    const { spacingInNormalDirection, imageVolume } = getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n    if (!imageVolume) {\n        return;\n    }\n    const { viewPlaneNormal, focalPoint } = camera;\n    const actorEntry = viewport\n        .getActors()\n        .find((a) => a.referencedId === imageVolume.volumeId ||\n        a.uid === imageVolume.volumeId);\n    if (!actorEntry) {\n        console.warn('No actor found for with actorUID of', imageVolume.volumeId);\n    }\n    const volumeActor = actorEntry.actor;\n    const sliceRange = getSliceRange(volumeActor, viewPlaneNormal, focalPoint);\n    const { min, max, current } = sliceRange;\n    const numberOfSlices = Math.round((max - min) / spacingInNormalDirection) + 1;\n    let imageIndex = ((current - min) / (max - min)) * numberOfSlices;\n    imageIndex = Math.floor(imageIndex);\n    if (imageIndex > numberOfSlices - 1) {\n        imageIndex = numberOfSlices - 1;\n    }\n    else if (imageIndex < 0) {\n        imageIndex = 0;\n    }\n    return {\n        numberOfSlices,\n        imageIndex,\n    };\n}\nexport default getImageSliceDataForVolumeViewport;\n","import * as metaData from '../metaData';\nexport default function getScalingParameters(imageId) {\n    const modalityLutModule = metaData.get('modalityLutModule', imageId) || {};\n    const generalSeriesModule = metaData.get('generalSeriesModule', imageId) || {};\n    const { modality } = generalSeriesModule;\n    const scalingParameters = {\n        rescaleSlope: modalityLutModule.rescaleSlope || 1,\n        rescaleIntercept: modalityLutModule.rescaleIntercept ?? 0,\n        modality,\n    };\n    const scalingModules = metaData.get('scalingModule', imageId) || {};\n    return {\n        ...scalingParameters,\n        ...(modality === 'PT' && {\n            suvbw: scalingModules.suvbw,\n            suvbsa: scalingModules.suvbsa,\n            suvlbm: scalingModules.suvlbm,\n        }),\n        ...(modality === 'RTDOSE' && {\n            doseGridScaling: scalingModules.DoseGridScaling,\n            doseSummation: scalingModules.DoseSummation,\n            doseType: scalingModules.DoseType,\n            doseUnit: scalingModules.DoseUnit,\n        }),\n    };\n}\n","import vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\nimport getVolumeActorCorners from './getVolumeActorCorners';\nimport { EPSILON } from '../constants';\nconst SMALL_EPSILON = EPSILON * EPSILON;\nconst isOne = (v) => Math.abs(Math.abs(v) - 1) < SMALL_EPSILON;\nconst isUnit = (v, off) => isOne(v[off]) || isOne(v[off + 1]) || isOne(v[off + 2]);\nconst isOrthonormal = (v) => isUnit(v, 0) && isUnit(v, 3) && isUnit(v, 6);\nexport default function getSliceRange(volumeActor, viewPlaneNormal, focalPoint) {\n    const imageData = volumeActor.getMapper().getInputData();\n    let corners;\n    const direction = imageData.getDirection();\n    if (isOrthonormal(direction)) {\n        corners = getVolumeActorCorners(volumeActor);\n    }\n    else {\n        const [dx, dy, dz] = imageData.getDimensions();\n        const cornersIdx = [\n            [0, 0, 0],\n            [dx - 1, 0, 0],\n            [0, dy - 1, 0],\n            [dx - 1, dy - 1, 0],\n            [0, 0, dz - 1],\n            [dx - 1, 0, dz - 1],\n            [0, dy - 1, dz - 1],\n            [dx - 1, dy - 1, dz - 1],\n        ];\n        corners = cornersIdx.map((it) => imageData.indexToWorld(it));\n    }\n    const transform = vtkMatrixBuilder\n        .buildFromDegree()\n        .identity()\n        .rotateFromDirections(viewPlaneNormal, [1, 0, 0]);\n    corners.forEach((pt) => transform.apply(pt));\n    const transformedFocalPoint = [...focalPoint];\n    transform.apply(transformedFocalPoint);\n    const currentSlice = transformedFocalPoint[0];\n    let minX = Infinity;\n    let maxX = -Infinity;\n    for (let i = 0; i < 8; i++) {\n        const x = corners[i][0];\n        if (x > maxX) {\n            maxX = x;\n        }\n        if (x < minX) {\n            minX = x;\n        }\n    }\n    return {\n        min: minX,\n        max: maxX,\n        current: currentSlice,\n        actor: volumeActor,\n        viewPlaneNormal,\n        focalPoint,\n    };\n}\n","import { vec3 } from 'gl-matrix';\nexport default function getSpacingInNormalDirection(imageVolume, viewPlaneNormal) {\n    const { direction, spacing } = imageVolume;\n    const iVector = direction.slice(0, 3);\n    const jVector = direction.slice(3, 6);\n    const kVector = direction.slice(6, 9);\n    const dotProducts = [\n        vec3.dot(iVector, viewPlaneNormal),\n        vec3.dot(jVector, viewPlaneNormal),\n        vec3.dot(kVector, viewPlaneNormal),\n    ];\n    const projectedSpacing = vec3.create();\n    vec3.set(projectedSpacing, dotProducts[0] * spacing[0], dotProducts[1] * spacing[1], dotProducts[2] * spacing[2]);\n    const spacingInNormalDirection = vec3.length(projectedSpacing);\n    return spacingInNormalDirection;\n}\n","import cache from '../cache/cache';\nimport { EPSILON } from '../constants';\nimport getSpacingInNormalDirection from './getSpacingInNormalDirection';\nimport { getVolumeLoaderSchemes } from '../loaders/volumeLoader';\nimport { getVolumeId } from './getVolumeId';\nconst EPSILON_PART = 1 + EPSILON;\nconst startsWith = (str, starts) => starts === str.substring(0, Math.min(str.length, starts.length));\nconst isPrimaryVolume = (volume) => !!getVolumeLoaderSchemes().find((scheme) => startsWith(volume.volumeId, scheme));\nexport default function getTargetVolumeAndSpacingInNormalDir(viewport, camera, targetId, useSlabThickness = false) {\n    const { viewPlaneNormal } = camera;\n    const volumeActors = viewport.getActors();\n    if (!volumeActors.length) {\n        return {\n            spacingInNormalDirection: null,\n            imageVolume: null,\n            actorUID: null,\n        };\n    }\n    const imageVolumes = volumeActors\n        .map((va) => {\n        const actorUID = va.referencedId ?? va.uid;\n        return cache.getVolume(actorUID);\n    })\n        .filter((iv) => !!iv);\n    if (targetId) {\n        const targetVolumeId = getVolumeId(targetId);\n        const imageVolumeIndex = imageVolumes.findIndex((iv) => targetVolumeId.includes(iv.volumeId));\n        const imageVolume = imageVolumes[imageVolumeIndex];\n        const { uid: actorUID } = volumeActors[imageVolumeIndex];\n        const spacingInNormalDirection = getSpacingInNormal(imageVolume, viewPlaneNormal, viewport, useSlabThickness);\n        return { imageVolume, spacingInNormalDirection, actorUID };\n    }\n    if (!imageVolumes.length) {\n        return {\n            spacingInNormalDirection: null,\n            imageVolume: null,\n            actorUID: null,\n        };\n    }\n    const smallest = {\n        spacingInNormalDirection: Infinity,\n        imageVolume: null,\n        actorUID: null,\n    };\n    const hasPrimaryVolume = imageVolumes.find(isPrimaryVolume);\n    for (let i = 0; i < imageVolumes.length; i++) {\n        const imageVolume = imageVolumes[i];\n        if (hasPrimaryVolume && !isPrimaryVolume(imageVolume)) {\n            continue;\n        }\n        const spacingInNormalDirection = getSpacingInNormal(imageVolume, viewPlaneNormal, viewport);\n        if (spacingInNormalDirection * EPSILON_PART <\n            smallest.spacingInNormalDirection) {\n            smallest.spacingInNormalDirection = spacingInNormalDirection;\n            smallest.imageVolume = imageVolume;\n            smallest.actorUID = volumeActors[i].uid;\n        }\n    }\n    return smallest;\n}\nfunction getSpacingInNormal(imageVolume, viewPlaneNormal, viewport, useSlabThickness = false) {\n    const { slabThickness } = viewport.getProperties();\n    let spacingInNormalDirection = slabThickness;\n    if (!slabThickness || !useSlabThickness) {\n        spacingInNormalDirection = getSpacingInNormalDirection(imageVolume, viewPlaneNormal);\n    }\n    return spacingInNormalDirection;\n}\n","import { getRenderingEngines } from '../RenderingEngine/getRenderingEngine';\nfunction getViewportsWithVolumeId(volumeId) {\n    const renderingEngines = getRenderingEngines();\n    const targetViewports = [];\n    renderingEngines.forEach((renderingEngine) => {\n        const viewports = renderingEngine.getVolumeViewports();\n        const filteredViewports = viewports.filter((vp) => vp.hasVolumeId(volumeId));\n        targetViewports.push(...filteredViewports);\n    });\n    return targetViewports;\n}\nexport default getViewportsWithVolumeId;\n","export default function getVoiFromSigmoidRGBTransferFunction(cfun) {\n    let cfunRange = [];\n    const [lower, upper] = cfun.getRange();\n    cfun.getTable(lower, upper, 1024, cfunRange);\n    cfunRange = cfunRange.filter((v, k) => k % 3 === 0);\n    const cfunDomain = [...Array(1024).keys()].map((v, k) => {\n        return lower + ((upper - lower) / (1024 - 1)) * k;\n    });\n    const y1 = cfunRange[256];\n    const logy1 = Math.log((1 - y1) / y1);\n    const x1 = cfunDomain[256];\n    const y2 = cfunRange[256 * 3];\n    const logy2 = Math.log((1 - y2) / y2);\n    const x2 = cfunDomain[256 * 3];\n    const ww = Math.round((4 * (x2 - x1)) / (logy1 - logy2));\n    const wc = Math.round(x1 + (ww * logy1) / 4);\n    return [Math.round(wc - ww / 2), Math.round(wc + ww / 2)];\n}\n","export default function getVolumeActorCorners(volumeActor) {\n    const imageData = volumeActor.getMapper().getInputData();\n    const bounds = imageData.extentToBounds(imageData.getExtent());\n    return [\n        [bounds[0], bounds[2], bounds[4]],\n        [bounds[0], bounds[2], bounds[5]],\n        [bounds[0], bounds[3], bounds[4]],\n        [bounds[0], bounds[3], bounds[5]],\n        [bounds[1], bounds[2], bounds[4]],\n        [bounds[1], bounds[2], bounds[5]],\n        [bounds[1], bounds[3], bounds[4]],\n        [bounds[1], bounds[3], bounds[5]],\n    ];\n}\n","export const getVolumeId = (targetId) => {\n    const prefix = 'volumeId:';\n    const str = targetId.includes(prefix)\n        ? targetId.substring(prefix.length)\n        : targetId;\n    const index = str.indexOf('sliceIndex=');\n    return index === -1 ? str : str.substring(0, index - 1);\n};\n","import getSliceRange from './getSliceRange';\nimport getTargetVolumeAndSpacingInNormalDir from './getTargetVolumeAndSpacingInNormalDir';\nfunction getVolumeSliceRangeInfo(viewport, volumeId, useSlabThickness = false) {\n    const camera = viewport.getCamera();\n    const { focalPoint, viewPlaneNormal } = camera;\n    const { spacingInNormalDirection, actorUID } = getTargetVolumeAndSpacingInNormalDir(viewport, camera, volumeId, useSlabThickness);\n    if (!actorUID) {\n        throw new Error(`Could not find image volume with id ${volumeId} in the viewport`);\n    }\n    const actorEntry = viewport.getActor(actorUID);\n    if (!actorEntry) {\n        console.warn('No actor found for with actorUID of', actorUID);\n        return null;\n    }\n    const volumeActor = actorEntry.actor;\n    const sliceRange = getSliceRange(volumeActor, viewPlaneNormal, focalPoint);\n    return {\n        sliceRange,\n        spacingInNormalDirection,\n        camera,\n    };\n}\nexport default getVolumeSliceRangeInfo;\n","import getVolumeSliceRangeInfo from './getVolumeSliceRangeInfo';\nfunction getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness = false) {\n    const { sliceRange, spacingInNormalDirection, camera } = getVolumeSliceRangeInfo(viewport, volumeId, useSlabThickness);\n    const { min, max, current } = sliceRange;\n    const numScrollSteps = Math.round((max - min) / spacingInNormalDirection);\n    const fraction = (current - min) / (max - min);\n    const floatingStepNumber = fraction * numScrollSteps;\n    const currentStepIndex = Math.round(floatingStepNumber);\n    return {\n        numScrollSteps,\n        currentStepIndex,\n        sliceRangeInfo: {\n            sliceRange,\n            spacingInNormalDirection,\n            camera,\n        },\n    };\n}\nexport default getVolumeViewportScrollInfo;\n","export const hasFloatScalingParameters = (scalingParameters) => {\n    const hasFloatRescale = Object.values(scalingParameters).some((value) => typeof value === 'number' && !Number.isInteger(value));\n    return hasFloatRescale;\n};\n","export default function hasNaNValues(input) {\n    if (Array.isArray(input)) {\n        return input.some((value) => Number.isNaN(value));\n    }\n    return Number.isNaN(input);\n}\n","export default function imageIdToURI(imageId) {\n    const colonIndex = imageId.indexOf(':');\n    return imageId.substring(colonIndex + 1);\n}\n","import { addProvider } from '../metaData';\nconst retrieveConfigurationState = new Map();\nconst IMAGE_RETRIEVE_CONFIGURATION = 'imageRetrieveConfiguration';\nconst imageRetrieveMetadataProvider = {\n    IMAGE_RETRIEVE_CONFIGURATION,\n    clear: () => {\n        retrieveConfigurationState.clear();\n    },\n    add: (key, payload) => {\n        retrieveConfigurationState.set(key, payload);\n    },\n    clone: () => {\n        return new Map(retrieveConfigurationState);\n    },\n    restore: (state) => {\n        retrieveConfigurationState.clear();\n        state.forEach((value, key) => {\n            retrieveConfigurationState.set(key, value);\n        });\n    },\n    get: (type, ...queries) => {\n        if (type === IMAGE_RETRIEVE_CONFIGURATION) {\n            return queries\n                .map((query) => retrieveConfigurationState.get(query))\n                .find((it) => it !== undefined);\n        }\n    },\n};\naddProvider(imageRetrieveMetadataProvider.get.bind(imageRetrieveMetadataProvider));\nexport default imageRetrieveMetadataProvider;\n","var EventListenerPhases;\n(function (EventListenerPhases) {\n    EventListenerPhases[EventListenerPhases[\"None\"] = 0] = \"None\";\n    EventListenerPhases[EventListenerPhases[\"Capture\"] = 1] = \"Capture\";\n    EventListenerPhases[EventListenerPhases[\"Bubble\"] = 2] = \"Bubble\";\n})(EventListenerPhases || (EventListenerPhases = {}));\nclass TargetEventListeners {\n    constructor(target) {\n        this._eventListeners = new Map();\n        this._children = new Map();\n        this._target = target;\n    }\n    get isEmpty() {\n        return this._eventListeners.size === 0 && this._children.size === 0;\n    }\n    addEventListener(type, callback, options) {\n        const dotIndex = type.indexOf('.');\n        const isNamespace = dotIndex !== -1;\n        if (isNamespace) {\n            const namespaceToken = type.substring(0, dotIndex);\n            let childElementEventListener = this._children.get(namespaceToken);\n            if (!childElementEventListener) {\n                childElementEventListener = new TargetEventListeners(this._target);\n                this._children.set(namespaceToken, childElementEventListener);\n            }\n            type = type.substring(dotIndex + 1);\n            childElementEventListener.addEventListener(type, callback, options);\n        }\n        else {\n            this._addEventListener(type, callback, options);\n        }\n    }\n    removeEventListener(type, callback, options) {\n        const dotIndex = type.indexOf('.');\n        const isNamespace = dotIndex !== -1;\n        if (isNamespace) {\n            const namespaceToken = type.substring(0, dotIndex);\n            const childElementEventListener = this._children.get(namespaceToken);\n            if (!childElementEventListener) {\n                return;\n            }\n            type = type.substring(dotIndex + 1);\n            childElementEventListener.removeEventListener(type, callback, options);\n            if (childElementEventListener.isEmpty) {\n                this._children.delete(namespaceToken);\n            }\n        }\n        else {\n            this._removeEventListener(type, callback, options);\n        }\n    }\n    reset() {\n        Array.from(this._children.entries()).forEach(([namespace, child]) => {\n            child.reset();\n            if (child.isEmpty) {\n                this._children.delete(namespace);\n            }\n            else {\n                throw new Error('Child is not empty and cannot be removed');\n            }\n        });\n        this._unregisterAllEvents();\n    }\n    _addEventListener(type, callback, options) {\n        let listenersMap = this._eventListeners.get(type);\n        if (!listenersMap) {\n            listenersMap = new Map();\n            this._eventListeners.set(type, listenersMap);\n        }\n        const useCapture = options?.capture ?? false;\n        const listenerPhase = useCapture\n            ? EventListenerPhases.Capture\n            : EventListenerPhases.Bubble;\n        const registeredPhases = listenersMap.get(callback) ?? EventListenerPhases.None;\n        if (registeredPhases & listenerPhase) {\n            console.warn('A listener is already registered for this phase');\n            return;\n        }\n        listenersMap.set(callback, registeredPhases | listenerPhase);\n        this._target.addEventListener(type, callback, options);\n    }\n    _removeEventListener(type, callback, options) {\n        const useCapture = options?.capture ?? false;\n        const listenerPhase = useCapture\n            ? EventListenerPhases.Capture\n            : EventListenerPhases.Bubble;\n        const listenersMap = this._eventListeners.get(type);\n        if (!listenersMap) {\n            return;\n        }\n        const callbacks = callback ? [callback] : Array.from(listenersMap.keys());\n        callbacks.forEach((callbackItem) => {\n            const registeredPhases = listenersMap.get(callbackItem) ?? EventListenerPhases.None;\n            const phaseRegistered = !!(registeredPhases & listenerPhase);\n            if (!phaseRegistered) {\n                return;\n            }\n            this._target.removeEventListener(type, callbackItem, options);\n            const newListenerPhase = registeredPhases ^ listenerPhase;\n            if (newListenerPhase === EventListenerPhases.None) {\n                listenersMap.delete(callbackItem);\n            }\n            else {\n                listenersMap.set(callbackItem, newListenerPhase);\n            }\n        });\n        if (!listenersMap.size) {\n            this._eventListeners.delete(type);\n        }\n    }\n    _unregisterAllListeners(type, listenersMap) {\n        Array.from(listenersMap.entries()).forEach(([listener, eventPhases]) => {\n            const startPhase = EventListenerPhases.Capture;\n            for (let currentPhase = startPhase; eventPhases; currentPhase <<= 1) {\n                if (!(eventPhases & currentPhase)) {\n                    continue;\n                }\n                const useCapture = currentPhase === EventListenerPhases.Capture ? true : false;\n                this.removeEventListener(type, listener, { capture: useCapture });\n                eventPhases ^= currentPhase;\n            }\n        });\n    }\n    _unregisterAllEvents() {\n        Array.from(this._eventListeners.entries()).forEach(([type, listenersMap]) => {\n            this._unregisterAllListeners(type, listenersMap);\n        });\n    }\n}\nexport { TargetEventListeners as default, TargetEventListeners };\n","import TargetEventListeners from './TargetEventListeners';\nclass MultiTargetEventListenerManager {\n    constructor() {\n        this._targetsEventListeners = new Map();\n    }\n    addEventListener(target, type, callback, options) {\n        let eventListeners = this._targetsEventListeners.get(target);\n        if (!eventListeners) {\n            eventListeners = new TargetEventListeners(target);\n            this._targetsEventListeners.set(target, eventListeners);\n        }\n        eventListeners.addEventListener(type, callback, options);\n    }\n    removeEventListener(target, type, callback, options) {\n        const eventListeners = this._targetsEventListeners.get(target);\n        if (!eventListeners) {\n            return;\n        }\n        eventListeners.removeEventListener(type, callback, options);\n        if (eventListeners.isEmpty) {\n            this._targetsEventListeners.delete(target);\n        }\n    }\n    reset() {\n        Array.from(this._targetsEventListeners.entries()).forEach(([target, targetEventListeners]) => {\n            targetEventListeners.reset();\n            this._targetsEventListeners.delete(target);\n        });\n    }\n}\nexport { MultiTargetEventListenerManager as default, MultiTargetEventListenerManager, };\n","export default function scaleRGBTransferFunction(rgbTransferFunction, scalingFactor) {\n    const size = rgbTransferFunction.getSize();\n    for (let index = 0; index < size; index++) {\n        const nodeValue1 = [];\n        rgbTransferFunction.getNodeValue(index, nodeValue1);\n        nodeValue1[1] = nodeValue1[1] * scalingFactor;\n        nodeValue1[2] = nodeValue1[2] * scalingFactor;\n        nodeValue1[3] = nodeValue1[3] * scalingFactor;\n        rgbTransferFunction.setNodeValue(index, nodeValue1);\n    }\n}\n","export default function getMinMax(storedPixelData) {\n    let min = storedPixelData[0];\n    let max = storedPixelData[0];\n    let storedPixel;\n    const numPixels = storedPixelData.length;\n    for (let index = 1; index < numPixels; index++) {\n        storedPixel = storedPixelData[index];\n        min = Math.min(min, storedPixel);\n        max = Math.max(max, storedPixel);\n    }\n    return {\n        min,\n        max,\n    };\n}\n","const LAST_RUNTIME_ID = Symbol('LastRuntimeId');\nconst GLOBAL_CONTEXT = {};\nconst DEFAULT_MAX = 0xffffffff;\nconst DEFAULT_SEPARATOR = '-';\nexport default function getRuntimeId(context, separator, max) {\n    return getNextRuntimeId(context !== null && typeof context === 'object' ? context : GLOBAL_CONTEXT, LAST_RUNTIME_ID, (typeof max === 'number' && max > 0 ? max : DEFAULT_MAX) >>> 0).join(typeof separator === 'string' ? separator : DEFAULT_SEPARATOR);\n}\nfunction getNextRuntimeId(context, symbol, max) {\n    let idComponents = context[symbol];\n    if (!(idComponents instanceof Array)) {\n        idComponents = [0];\n        Object.defineProperty(context, symbol, { value: idComponents });\n    }\n    for (let carry = true, i = 0; carry && i < idComponents.length; ++i) {\n        let n = idComponents[i] | 0;\n        if (n < max) {\n            carry = false;\n            n = n + 1;\n        }\n        else {\n            n = 0;\n            if (i + 1 === idComponents.length) {\n                idComponents.push(0);\n            }\n        }\n        idComponents[i] = n;\n    }\n    return idComponents;\n}\n","import imageIdToURI from './imageIdToURI';\nconst state = {};\nconst metadataProvider = {\n    add: (imageId, payload) => {\n        const imageURI = imageIdToURI(imageId);\n        state[imageURI] = payload;\n    },\n    get: (type, imageId) => {\n        if (type === 'calibratedPixelSpacing') {\n            const imageURI = imageIdToURI(imageId);\n            return state[imageURI];\n        }\n    },\n};\nexport default metadataProvider;\n","export default function isOpposite(v1, v2, tolerance = 1e-5) {\n    return (Math.abs(v1[0] + v2[0]) < tolerance &&\n        Math.abs(v1[1] + v2[1]) < tolerance &&\n        Math.abs(v1[2] + v2[2]) < tolerance);\n}\n","export default function indexWithinDimensions(index, dimensions) {\n    if (index[0] < 0 ||\n        index[0] >= dimensions[0] ||\n        index[1] < 0 ||\n        index[1] >= dimensions[1] ||\n        index[2] < 0 ||\n        index[2] >= dimensions[2]) {\n        return false;\n    }\n    return true;\n}\n","import { getRenderingEngines, getRenderingEngine, } from '../RenderingEngine/getRenderingEngine';\nfunction getVolumeViewportsContainingSameVolumes(targetViewport, renderingEngineId) {\n    let renderingEngines;\n    if (renderingEngineId) {\n        renderingEngines = [getRenderingEngine(renderingEngineId)];\n    }\n    else {\n        renderingEngines = getRenderingEngines();\n    }\n    const sameVolumesViewports = [];\n    renderingEngines.forEach((renderingEngine) => {\n        const targetActors = targetViewport.getActors();\n        const viewports = renderingEngine.getVolumeViewports();\n        for (const vp of viewports) {\n            const vpActors = vp.getActors();\n            if (vpActors.length !== targetActors.length) {\n                continue;\n            }\n            const sameVolumes = targetActors.every(({ uid }) => vpActors.find((vpActor) => uid === vpActor.uid));\n            if (sameVolumes) {\n                sameVolumesViewports.push(vp);\n            }\n        }\n    });\n    return sameVolumesViewports;\n}\nexport default getVolumeViewportsContainingSameVolumes;\n","const isPTPrescaledWithSUV = (image) => {\n    return image.preScale.scaled && image.preScale.scalingParameters.suvbw;\n};\nexport default isPTPrescaledWithSUV;\n","import { vec3 } from 'gl-matrix';\nimport getOrCreateCanvas, { EPSILON, } from '../RenderingEngine/helpers/getOrCreateCanvas';\nimport { ViewportType, Events } from '../enums';\nimport { getRenderingEngine } from '../RenderingEngine/getRenderingEngine';\nimport TiledRenderingEngine from '../RenderingEngine/TiledRenderingEngine';\nimport isPTPrescaledWithSUV from './isPTPrescaledWithSUV';\nexport default function renderToCanvasGPU(canvas, imageOrVolume, modality = undefined, renderingEngineId = '_thumbnails', viewportOptions = {\n    displayArea: { imageArea: [1, 1] },\n}) {\n    if (!canvas || !(canvas instanceof HTMLCanvasElement)) {\n        throw new Error('canvas element is required');\n    }\n    const isVolume = !imageOrVolume.imageId;\n    const image = !isVolume && imageOrVolume;\n    const volume = isVolume && imageOrVolume;\n    const imageIdToPrint = image.imageId || volume.volumeId;\n    const viewportId = `renderGPUViewport-${imageIdToPrint}`;\n    const element = document.createElement('div');\n    const devicePixelRatio = window.devicePixelRatio || 1;\n    if (!viewportOptions.displayArea) {\n        viewportOptions.displayArea = { imageArea: [1, 1] };\n    }\n    const originalWidth = canvas.width;\n    const originalHeight = canvas.height;\n    element.style.width = `${originalWidth / devicePixelRatio + EPSILON}px`;\n    element.style.height = `${originalHeight / devicePixelRatio + EPSILON}px`;\n    element.style.visibility = 'hidden';\n    element.style.position = 'absolute';\n    document.body.appendChild(element);\n    const uniqueId = viewportId.split(':').join('-');\n    element.setAttribute('viewport-id-for-remove', uniqueId);\n    const temporaryCanvas = getOrCreateCanvas(element);\n    const renderingEngine = getRenderingEngine(renderingEngineId) ||\n        new TiledRenderingEngine(renderingEngineId);\n    let viewport = renderingEngine.getViewport(viewportId);\n    if (!viewport) {\n        const viewportInput = {\n            viewportId,\n            type: isVolume ? ViewportType.ORTHOGRAPHIC : ViewportType.STACK,\n            element,\n            defaultOptions: {\n                ...viewportOptions,\n                suppressEvents: true,\n            },\n        };\n        renderingEngine.enableElement(viewportInput);\n        viewport = renderingEngine.getViewport(viewportId);\n    }\n    return new Promise((resolve) => {\n        let elementRendered = false;\n        let { viewReference } = viewportOptions;\n        const onImageRendered = (eventDetail) => {\n            if (elementRendered) {\n                return;\n            }\n            if (viewReference) {\n                const useViewRef = viewReference;\n                viewReference = null;\n                viewport.setViewReference(useViewRef);\n                viewport.render();\n                return;\n            }\n            const context = canvas.getContext('2d');\n            context.drawImage(temporaryCanvas, 0, 0, temporaryCanvas.width, temporaryCanvas.height, 0, 0, canvas.width, canvas.height);\n            const origin = viewport.canvasToWorld([0, 0]);\n            const topRight = viewport.canvasToWorld([\n                temporaryCanvas.width / devicePixelRatio,\n                0,\n            ]);\n            const bottomLeft = viewport.canvasToWorld([\n                0,\n                temporaryCanvas.height / devicePixelRatio,\n            ]);\n            const rightVector = vec3.sub([0, 0, 0], viewport.canvasToWorld([1 / devicePixelRatio, 0]), origin);\n            const downVector = vec3.sub([0, 0, 0], viewport.canvasToWorld([0, 1 / devicePixelRatio]), origin);\n            const thicknessMm = 1;\n            elementRendered = true;\n            element.removeEventListener(Events.IMAGE_RENDERED, onImageRendered);\n            setTimeout(() => {\n                renderingEngine.disableElement(viewportId);\n                const elements = document.querySelectorAll(`[viewport-id-for-remove=\"${uniqueId}\"]`);\n                elements.forEach((element) => {\n                    element.remove();\n                });\n            }, 0);\n            resolve({\n                origin,\n                bottomLeft,\n                topRight,\n                thicknessMm,\n                rightVector,\n                downVector,\n            });\n        };\n        element.addEventListener(Events.IMAGE_RENDERED, onImageRendered);\n        if (isVolume) {\n            viewport.setVolumes([volume], false, true);\n        }\n        else {\n            viewport.renderImageObject(imageOrVolume);\n        }\n        viewport.resetCamera();\n        if (modality === 'PT' && !isPTPrescaledWithSUV(image)) {\n            viewport.setProperties({\n                voiRange: {\n                    lower: image.minPixelValue,\n                    upper: image.maxPixelValue,\n                },\n            });\n        }\n        viewport.render();\n    });\n}\n","import getDefaultViewport from '../RenderingEngine/helpers/cpuFallback/rendering/getDefaultViewport';\nimport calculateTransform from '../RenderingEngine/helpers/cpuFallback/rendering/calculateTransform';\nimport drawImageSync from '../RenderingEngine/helpers/cpuFallback/drawImageSync';\nexport default function renderToCanvasCPU(canvas, imageOrVolume, modality, _renderingEngineId, _viewportOptions) {\n    const volume = imageOrVolume;\n    if (volume.volumeId) {\n        throw new Error('Unsupported volume rendering for CPU');\n    }\n    const image = imageOrVolume;\n    const viewport = getDefaultViewport(canvas, image, modality);\n    const enabledElement = {\n        canvas,\n        viewport,\n        image,\n        renderingTools: {},\n    };\n    enabledElement.transform = calculateTransform(enabledElement);\n    const invalidated = true;\n    return new Promise((resolve, reject) => {\n        drawImageSync(enabledElement, invalidated);\n        resolve(null);\n    });\n}\n","import { loadAndCacheImage } from '../loaders/imageLoader';\nimport * as metaData from '../metaData';\nimport { RequestType } from '../enums';\nimport imageLoadPoolManager from '../requestPool/imageLoadPoolManager';\nimport renderToCanvasGPU from './renderToCanvasGPU';\nimport renderToCanvasCPU from './renderToCanvasCPU';\nimport cache from '../cache/cache';\nexport default function loadImageToCanvas(options) {\n    const { canvas, imageId, viewReference, requestType = RequestType.Thumbnail, priority = -5, renderingEngineId = '_thumbnails', useCPURendering = false, thumbnail = false, imageAspect = false, viewportOptions: baseViewportOptions, } = options;\n    const volumeId = viewReference?.volumeId;\n    const isVolume = volumeId && !imageId;\n    const viewportOptions = viewReference && baseViewportOptions\n        ? { ...baseViewportOptions, viewReference }\n        : baseViewportOptions;\n    const renderFn = useCPURendering ? renderToCanvasCPU : renderToCanvasGPU;\n    return new Promise((resolve, reject) => {\n        function successCallback(imageOrVolume, imageId) {\n            const { modality } = metaData.get('generalSeriesModule', imageId) || {};\n            const image = !isVolume && imageOrVolume;\n            const volume = isVolume && imageOrVolume;\n            if (image) {\n                image.isPreScaled = image.isPreScaled || image.preScale?.scaled;\n            }\n            if (thumbnail) {\n                canvas.height = 256;\n                canvas.width = 256;\n            }\n            if (imageAspect && image) {\n                canvas.width = image && (canvas.height * image.width) / image.height;\n            }\n            canvas.style.width = `${canvas.width / devicePixelRatio}px`;\n            canvas.style.height = `${canvas.height / devicePixelRatio}px`;\n            if (volume && useCPURendering) {\n                reject(new Error('CPU rendering of volume not supported'));\n            }\n            renderFn(canvas, imageOrVolume, modality, renderingEngineId, viewportOptions).then(resolve);\n        }\n        function errorCallback(error, imageId) {\n            console.error(error, imageId);\n            reject(error);\n        }\n        function sendRequest(imageId, imageIdIndex, options) {\n            return loadAndCacheImage(imageId, options).then((image) => {\n                successCallback.call(this, image, imageId);\n            }, (error) => {\n                errorCallback.call(this, error, imageId);\n            });\n        }\n        const options = {\n            useRGBA: !!useCPURendering,\n            requestType,\n        };\n        if (volumeId) {\n            const volume = cache.getVolume(volumeId);\n            if (!volume) {\n                reject(new Error(`Volume id ${volumeId} not found in cache`));\n            }\n            const useImageId = volume.imageIds[0];\n            successCallback(volume, useImageId);\n        }\n        else {\n            imageLoadPoolManager.addRequest(sendRequest.bind(null, imageId, null, options), requestType, { imageId }, priority);\n        }\n    });\n}\n","export function asArray(item) {\n    if (Array.isArray(item)) {\n        return item;\n    }\n    return [item];\n}\n","import eventTarget from '../../eventTarget';\nimport { asArray } from '../asArray';\nconst Events = {\n    HISTORY_UNDO: 'CORNERSTONE_TOOLS_HISTORY_UNDO',\n    HISTORY_REDO: 'CORNERSTONE_TOOLS_HISTORY_REDO',\n};\nexport class HistoryMemo {\n    constructor(label = 'Tools', size = 50) {\n        this.position = -1;\n        this.redoAvailable = 0;\n        this.undoAvailable = 0;\n        this.ring = new Array();\n        this.isRecordingGrouped = false;\n        this.label = label;\n        this._size = size;\n    }\n    get size() {\n        return this._size;\n    }\n    set size(newSize) {\n        this.ring = new Array(newSize);\n        this._size = newSize;\n        this.position = -1;\n        this.redoAvailable = 0;\n        this.undoAvailable = 0;\n    }\n    get canUndo() {\n        return this.undoAvailable > 0;\n    }\n    get canRedo() {\n        return this.redoAvailable > 0;\n    }\n    undo(items = 1) {\n        while (items > 0 && this.undoAvailable > 0) {\n            const item = this.ring[this.position];\n            for (const subitem of asArray(item).reverse()) {\n                subitem.restoreMemo(true);\n                this.dispatchHistoryEvent({ item: subitem, isUndo: true });\n            }\n            items--;\n            this.redoAvailable++;\n            this.undoAvailable--;\n            this.position = (this.position - 1 + this.size) % this.size;\n        }\n    }\n    undoIf(condition) {\n        if (this.undoAvailable > 0 && condition(this.ring[this.position])) {\n            this.undo();\n            return true;\n        }\n        return false;\n    }\n    dispatchHistoryEvent({ item, isUndo }) {\n        if (item.id) {\n            eventTarget.dispatchEvent(new CustomEvent(isUndo ? Events.HISTORY_UNDO : Events.HISTORY_REDO, {\n                detail: {\n                    isUndo,\n                    id: item.id,\n                    operationType: item.operationType || 'annotation',\n                    memo: item,\n                },\n            }));\n        }\n    }\n    redo(items = 1) {\n        while (items > 0 && this.redoAvailable > 0) {\n            const newPosition = (this.position + 1) % this.size;\n            const item = this.ring[newPosition];\n            for (const subitem of asArray(item).reverse()) {\n                subitem.restoreMemo(false);\n                this.dispatchHistoryEvent({ item: subitem, isUndo: false });\n            }\n            items--;\n            this.position = newPosition;\n            this.undoAvailable++;\n            this.redoAvailable--;\n        }\n    }\n    initializeGroupItem() {\n        this.redoAvailable = 0;\n        if (this.undoAvailable < this._size) {\n            this.undoAvailable++;\n        }\n        this.position = (this.position + 1) % this._size;\n        this.ring[this.position] = [];\n    }\n    startGroupRecording() {\n        this.isRecordingGrouped = true;\n        this.initializeGroupItem();\n    }\n    rollbackUnusedGroupItem() {\n        this.ring[this.position] = undefined;\n        this.position = (this.position - 1) % this._size;\n        this.undoAvailable--;\n    }\n    endGroupRecording() {\n        this.isRecordingGrouped = false;\n        const lastItem = this.ring[this.position];\n        const lastItemIsEmpty = Array.isArray(lastItem) && lastItem.length === 0;\n        if (lastItemIsEmpty) {\n            this.rollbackUnusedGroupItem();\n        }\n    }\n    pushGrouped(memo) {\n        const lastMemo = this.ring[this.position];\n        if (Array.isArray(lastMemo)) {\n            lastMemo.push(memo);\n            return memo;\n        }\n        throw new Error('Last item should be an array for grouped memos.');\n    }\n    push(item) {\n        if (!item) {\n            return;\n        }\n        const memo = item.restoreMemo\n            ? item\n            : item.createMemo?.();\n        if (!memo) {\n            return;\n        }\n        if (this.isRecordingGrouped) {\n            return this.pushGrouped(memo);\n        }\n        this.redoAvailable = 0;\n        if (this.undoAvailable < this._size) {\n            this.undoAvailable++;\n        }\n        this.position = (this.position + 1) % this._size;\n        this.ring[this.position] = memo;\n        return memo;\n    }\n}\nconst DefaultHistoryMemo = new HistoryMemo();\nexport { DefaultHistoryMemo };\n","import { vec3 } from 'gl-matrix';\nimport { get } from '../metaData';\nfunction worldToImageCoords(imageId, worldCoords) {\n    const imagePlaneModule = get('imagePlaneModule', imageId);\n    if (!imagePlaneModule) {\n        throw new Error(`No imagePlaneModule found for imageId: ${imageId}`);\n    }\n    const { columnCosines, rowCosines, imagePositionPatient: origin, } = imagePlaneModule;\n    let { columnPixelSpacing, rowPixelSpacing } = imagePlaneModule;\n    columnPixelSpacing ||= 1;\n    rowPixelSpacing ||= 1;\n    const newOrigin = vec3.create();\n    vec3.scaleAndAdd(newOrigin, origin, columnCosines, -columnPixelSpacing / 2);\n    vec3.scaleAndAdd(newOrigin, newOrigin, rowCosines, -rowPixelSpacing / 2);\n    const sub = vec3.create();\n    vec3.sub(sub, worldCoords, newOrigin);\n    const rowDistance = vec3.dot(sub, rowCosines);\n    const columnDistance = vec3.dot(sub, columnCosines);\n    const imageCoords = [\n        rowDistance / rowPixelSpacing,\n        columnDistance / columnPixelSpacing,\n    ];\n    return imageCoords;\n}\nexport default worldToImageCoords;\n","import { vec3 } from 'gl-matrix';\nimport { get } from '../metaData';\nexport default function imageToWorldCoords(imageId, imageCoords) {\n    const imagePlaneModule = get('imagePlaneModule', imageId);\n    if (!imagePlaneModule) {\n        throw new Error(`No imagePlaneModule found for imageId: ${imageId}`);\n    }\n    const { columnCosines, rowCosines, imagePositionPatient: origin, } = imagePlaneModule;\n    let { columnPixelSpacing, rowPixelSpacing } = imagePlaneModule;\n    columnPixelSpacing ||= 1;\n    rowPixelSpacing ||= 1;\n    const imageCoordsInWorld = vec3.create();\n    vec3.scaleAndAdd(imageCoordsInWorld, origin, rowCosines, rowPixelSpacing * (imageCoords[0] - 0.5));\n    vec3.scaleAndAdd(imageCoordsInWorld, imageCoordsInWorld, columnCosines, columnPixelSpacing * (imageCoords[1] - 0.5));\n    return Array.from(imageCoordsInWorld);\n}\n","import { getRenderingEngines } from '../RenderingEngine/getRenderingEngine';\nexport default function getViewportsWithImageURI(imageURI) {\n    const renderingEngines = getRenderingEngines();\n    const viewports = [];\n    renderingEngines.forEach((renderingEngine) => {\n        const viewportsForRenderingEngine = renderingEngine.getViewports();\n        viewportsForRenderingEngine.forEach((viewport) => {\n            if (viewport.hasImageURI(imageURI)) {\n                viewports.push(viewport);\n            }\n        });\n    });\n    return viewports;\n}\n","import { vec3 } from 'gl-matrix';\nimport * as planar from './planar';\nimport * as metaData from '../metaData';\nexport default function getClosestStackImageIndexForPoint(point, viewport) {\n    const minimalDistance = calculateMinimalDistanceForStackViewport(point, viewport);\n    return minimalDistance ? minimalDistance.index : null;\n}\nexport function calculateMinimalDistanceForStackViewport(point, viewport) {\n    const imageIds = viewport.getImageIds();\n    const currentImageIdIndex = viewport.getCurrentImageIdIndex();\n    if (imageIds.length === 0) {\n        return null;\n    }\n    const getDistance = (imageId) => {\n        const planeMetadata = getPlaneMetadata(imageId);\n        if (!planeMetadata) {\n            return null;\n        }\n        const plane = planar.planeEquation(planeMetadata.planeNormal, planeMetadata.imagePositionPatient);\n        const distance = planar.planeDistanceToPoint(plane, point);\n        return distance;\n    };\n    const closestStack = {\n        distance: getDistance(imageIds[currentImageIdIndex]) ?? Infinity,\n        index: currentImageIdIndex,\n    };\n    const higherImageIds = imageIds.slice(currentImageIdIndex + 1);\n    for (let i = 0; i < higherImageIds.length; i++) {\n        const id = higherImageIds[i];\n        const distance = getDistance(id);\n        if (distance === null) {\n            continue;\n        }\n        if (distance <= closestStack.distance) {\n            closestStack.distance = distance;\n            closestStack.index = i + currentImageIdIndex + 1;\n        }\n        else {\n            break;\n        }\n    }\n    const lowerImageIds = imageIds.slice(0, currentImageIdIndex);\n    for (let i = lowerImageIds.length - 1; i >= 0; i--) {\n        const id = lowerImageIds[i];\n        const distance = getDistance(id);\n        if (distance === null || distance === closestStack.distance) {\n            continue;\n        }\n        if (distance < closestStack.distance) {\n            closestStack.distance = distance;\n            closestStack.index = i;\n        }\n        else {\n            break;\n        }\n    }\n    return closestStack.distance === Infinity ? null : closestStack;\n}\nfunction getPlaneMetadata(imageId) {\n    const targetImagePlane = metaData.get('imagePlaneModule', imageId);\n    if (!targetImagePlane ||\n        !(targetImagePlane.rowCosines instanceof Array &&\n            targetImagePlane.rowCosines.length === 3) ||\n        !(targetImagePlane.columnCosines instanceof Array &&\n            targetImagePlane.columnCosines.length === 3) ||\n        !(targetImagePlane.imagePositionPatient instanceof Array &&\n            targetImagePlane.imagePositionPatient.length === 3)) {\n        return null;\n    }\n    const { rowCosines, columnCosines, imagePositionPatient, } = targetImagePlane;\n    const rowVec = vec3.set(vec3.create(), ...rowCosines);\n    const colVec = vec3.set(vec3.create(), ...columnCosines);\n    const planeNormal = vec3.cross(vec3.create(), rowVec, colVec);\n    return { rowCosines, columnCosines, imagePositionPatient, planeNormal };\n}\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport { transformCanvasToIJK } from './transformCanvasToIJK';\nfunction getCurrentVolumeViewportSlice(viewport) {\n    const { width: canvasWidth, height: canvasHeight } = viewport.getCanvas();\n    const { sliceToIndexMatrix, indexToSliceMatrix } = viewport.getSliceViewInfo();\n    const ijkOriginPoint = transformCanvasToIJK(viewport, [0, 0]);\n    const ijkRowPoint = transformCanvasToIJK(viewport, [canvasWidth - 1, 0]);\n    const ijkColPoint = transformCanvasToIJK(viewport, [0, canvasHeight - 1]);\n    const ijkRowVec = vec3.sub(vec3.create(), ijkRowPoint, ijkOriginPoint);\n    const ijkColVec = vec3.sub(vec3.create(), ijkColPoint, ijkOriginPoint);\n    const ijkSliceVec = vec3.cross(vec3.create(), ijkRowVec, ijkColVec);\n    vec3.normalize(ijkRowVec, ijkRowVec);\n    vec3.normalize(ijkColVec, ijkColVec);\n    vec3.normalize(ijkSliceVec, ijkSliceVec);\n    const maxIJKRowVec = Math.max(Math.abs(ijkRowVec[0]), Math.abs(ijkRowVec[1]), Math.abs(ijkRowVec[2]));\n    const maxIJKColVec = Math.max(Math.abs(ijkColVec[0]), Math.abs(ijkColVec[1]), Math.abs(ijkColVec[2]));\n    if (!glMatrix.equals(1, maxIJKRowVec) || !glMatrix.equals(1, maxIJKColVec)) {\n        throw new Error('Livewire is not available for rotate/oblique viewports');\n    }\n    const { voxelManager } = viewport.getImageData();\n    const sliceViewInfo = viewport.getSliceViewInfo();\n    const scalarData = voxelManager.getSliceData(sliceViewInfo);\n    return {\n        width: sliceViewInfo.width,\n        height: sliceViewInfo.height,\n        scalarData,\n        sliceToIndexMatrix,\n        indexToSliceMatrix,\n    };\n}\nexport { getCurrentVolumeViewportSlice as default, getCurrentVolumeViewportSlice, };\n","import { mat4 } from 'gl-matrix';\nimport { addProvider } from '../metaData';\nconst state = {};\nconst spatialRegistrationMetadataProvider = {\n    add: (query, payload) => {\n        const [viewportId1, viewportId2] = query;\n        const entryId = `${viewportId1}_${viewportId2}`;\n        if (!state[entryId]) {\n            state[entryId] = {};\n        }\n        state[entryId] = payload;\n    },\n    get: (type, viewportId1, viewportId2) => {\n        if (type !== 'spatialRegistrationModule') {\n            return;\n        }\n        const entryId = `${viewportId1}_${viewportId2}`;\n        if (state[entryId]) {\n            return state[entryId];\n        }\n        const entryIdReverse = `${viewportId2}_${viewportId1}`;\n        if (state[entryIdReverse]) {\n            return mat4.invert(mat4.create(), state[entryIdReverse]);\n        }\n    },\n};\naddProvider(spatialRegistrationMetadataProvider.get.bind(spatialRegistrationMetadataProvider));\nexport default spatialRegistrationMetadataProvider;\n","import { vec3, mat4 } from 'gl-matrix';\nimport spatialRegistrationMetadataProvider from './spatialRegistrationMetadataProvider';\nimport { get } from '../metaData';\nconst ALLOWED_DELTA = 0.05;\nfunction calculateViewportsSpatialRegistration(viewport1, viewport2) {\n    const imageId1 = viewport1.getSliceIndex();\n    const imageId2 = viewport2.getSliceIndex();\n    const imagePlaneModule1 = get('imagePlaneModule', imageId1.toString());\n    const imagePlaneModule2 = get('imagePlaneModule', imageId2.toString());\n    if (!imagePlaneModule1 || !imagePlaneModule2) {\n        console.log('Viewport spatial registration requires image plane module');\n        return;\n    }\n    const { imageOrientationPatient: iop2 } = imagePlaneModule2;\n    const isSameImagePlane = imagePlaneModule1.imageOrientationPatient.every((v, i) => Math.abs(v - iop2[i]) < ALLOWED_DELTA);\n    if (!isSameImagePlane) {\n        console.log('Viewport spatial registration only supported for same orientation (hence translation only) for now', imagePlaneModule1?.imageOrientationPatient, imagePlaneModule2?.imageOrientationPatient);\n        return;\n    }\n    const imagePositionPatient1 = imagePlaneModule1.imagePositionPatient;\n    const imagePositionPatient2 = imagePlaneModule2.imagePositionPatient;\n    const translation = vec3.subtract(vec3.create(), imagePositionPatient1, imagePositionPatient2);\n    const mat = mat4.fromTranslation(mat4.create(), translation);\n    spatialRegistrationMetadataProvider.add([viewport1.id, viewport2.id], mat);\n}\nexport default calculateViewportsSpatialRegistration;\n","export default function getViewportImageCornersInWorld(viewport) {\n    const { imageData, dimensions } = viewport.getImageData() || {};\n    if (!imageData || !dimensions) {\n        return [];\n    }\n    const { canvas } = viewport;\n    const ratio = window.devicePixelRatio;\n    const topLeftCanvas = [0, 0];\n    const topRightCanvas = [canvas.width / ratio, 0];\n    const bottomRightCanvas = [\n        canvas.width / ratio,\n        canvas.height / ratio,\n    ];\n    const bottomLeftCanvas = [0, canvas.height / ratio];\n    const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n    const topRightWorld = viewport.canvasToWorld(topRightCanvas);\n    const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n    const bottomLeftWorld = viewport.canvasToWorld(bottomLeftCanvas);\n    const topLeftImage = imageData.worldToIndex(topLeftWorld);\n    const topRightImage = imageData.worldToIndex(topRightWorld);\n    const bottomRightImage = imageData.worldToIndex(bottomRightWorld);\n    const bottomLeftImage = imageData.worldToIndex(bottomLeftWorld);\n    return _getStackViewportImageCorners({\n        dimensions,\n        imageData,\n        topLeftImage,\n        topRightImage,\n        bottomRightImage,\n        bottomLeftImage,\n        topLeftWorld,\n        topRightWorld,\n        bottomRightWorld,\n        bottomLeftWorld,\n    });\n}\nfunction _getStackViewportImageCorners({ dimensions, imageData, topLeftImage, topRightImage, bottomRightImage, bottomLeftImage, topLeftWorld, topRightWorld, bottomRightWorld, bottomLeftWorld, }) {\n    const topLeftImageWorld = _isInBounds(topLeftImage, dimensions)\n        ? topLeftWorld\n        : imageData.indexToWorld([0, 0, 0]);\n    const topRightImageWorld = _isInBounds(topRightImage, dimensions)\n        ? topRightWorld\n        : imageData.indexToWorld([dimensions[0] - 1, 0, 0]);\n    const bottomRightImageWorld = _isInBounds(bottomRightImage, dimensions)\n        ? bottomRightWorld\n        : imageData.indexToWorld([\n            dimensions[0] - 1,\n            dimensions[1] - 1,\n            0,\n        ]);\n    const bottomLeftImageWorld = _isInBounds(bottomLeftImage, dimensions)\n        ? bottomLeftWorld\n        : imageData.indexToWorld([0, dimensions[1] - 1, 0]);\n    return [\n        topLeftImageWorld,\n        topRightImageWorld,\n        bottomLeftImageWorld,\n        bottomRightImageWorld,\n    ];\n}\nfunction _isInBounds(imageCoord, dimensions) {\n    return (imageCoord[0] > 0 ||\n        imageCoord[0] < dimensions[0] - 1 ||\n        imageCoord[1] > 0 ||\n        imageCoord[1] < dimensions[1] - 1 ||\n        imageCoord[2] > 0 ||\n        imageCoord[2] < dimensions[2] - 1);\n}\n","import StackViewport from '../RenderingEngine/StackViewport';\nimport getEnabledElement from '../getEnabledElement';\nfunction getImageLegacy(element) {\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    if (!(viewport instanceof StackViewport)) {\n        throw new Error(`An image can only be fetched for a stack viewport and not for a viewport of type: ${viewport.type}`);\n    }\n    return viewport.getCornerstoneImage();\n}\nexport default getImageLegacy;\n","import * as metaData from '../metaData';\nimport isEqual from './isEqual';\nfunction isValidVolume(imageIds) {\n    if (imageIds.length <= 1) {\n        return false;\n    }\n    const imageId0 = imageIds[0];\n    const { modality, seriesInstanceUID } = metaData.get('generalSeriesModule', imageId0);\n    const { imageOrientationPatient, pixelSpacing, frameOfReferenceUID, columns, rows, usingDefaultValues, } = metaData.get('imagePlaneModule', imageId0);\n    if (usingDefaultValues) {\n        return false;\n    }\n    const baseMetadata = {\n        modality,\n        imageOrientationPatient,\n        pixelSpacing,\n        frameOfReferenceUID,\n        columns,\n        rows,\n        seriesInstanceUID,\n    };\n    let validVolume = true;\n    for (let i = 0; i < imageIds.length; i++) {\n        const imageId = imageIds[i];\n        const { modality, seriesInstanceUID } = metaData.get('generalSeriesModule', imageId);\n        const { imageOrientationPatient, pixelSpacing, columns, rows } = metaData.get('imagePlaneModule', imageId);\n        if (seriesInstanceUID !== baseMetadata.seriesInstanceUID) {\n            validVolume = false;\n            break;\n        }\n        if (modality !== baseMetadata.modality) {\n            validVolume = false;\n            break;\n        }\n        if (columns !== baseMetadata.columns) {\n            validVolume = false;\n            break;\n        }\n        if (rows !== baseMetadata.rows) {\n            validVolume = false;\n            break;\n        }\n        if (!isEqual(imageOrientationPatient, baseMetadata.imageOrientationPatient)) {\n            validVolume = false;\n            break;\n        }\n        if (!isEqual(pixelSpacing, baseMetadata.pixelSpacing)) {\n            validVolume = false;\n            break;\n        }\n    }\n    return validVolume;\n}\nexport { isValidVolume };\n","export const videoUIDs = new Set([\n    '1.2.840.10008.1.2.4.100',\n    '1.2.840.10008.1.2.4.100.1',\n    '1.2.840.10008.1.2.4.101',\n    '1.2.840.10008.1.2.4.101.1',\n    '1.2.840.10008.1.2.4.102',\n    '1.2.840.10008.1.2.4.102.1',\n    '1.2.840.10008.1.2.4.103',\n    '1.2.840.10008.1.2.4.103.1',\n    '1.2.840.10008.1.2.4.104',\n    '1.2.840.10008.1.2.4.104.1',\n    '1.2.840.10008.1.2.4.105',\n    '1.2.840.10008.1.2.4.105.1',\n    '1.2.840.10008.1.2.4.106',\n    '1.2.840.10008.1.2.4.106.1',\n    '1.2.840.10008.1.2.4.107',\n    '1.2.840.10008.1.2.4.108',\n]);\nexport default function isVideoTransferSyntax(uidOrUids) {\n    if (!uidOrUids) {\n        return false;\n    }\n    const uids = Array.isArray(uidOrUids) ? uidOrUids : [uidOrUids];\n    return uids.find((uid) => videoUIDs.has(uid));\n}\n","import { setVolumesForViewports } from '../RenderingEngine/helpers';\nimport { createAndCacheVolume, getUnknownVolumeLoaderSchema, } from '../loaders/volumeLoader';\nimport { Events, ViewportType } from '../enums';\nimport uuidv4 from './uuidv4';\nasync function convertStackToVolumeViewport({ viewport, options = {}, }) {\n    const renderingEngine = viewport.getRenderingEngine();\n    let volumeId = options.volumeId || `${uuidv4()}`;\n    if (volumeId.split(':').length === 0) {\n        const schema = getUnknownVolumeLoaderSchema();\n        volumeId = `${schema}:${volumeId}`;\n    }\n    const { id, element } = viewport;\n    const viewportId = options.viewportId || id;\n    const imageIds = viewport.getImageIds();\n    const prevViewPresentation = viewport.getViewPresentation();\n    const prevViewReference = viewport.getViewReference();\n    renderingEngine.enableElement({\n        viewportId,\n        type: ViewportType.ORTHOGRAPHIC,\n        element,\n        defaultOptions: {\n            background: options.background,\n            orientation: options.orientation,\n        },\n    });\n    const volume = (await createAndCacheVolume(volumeId, {\n        imageIds,\n    }));\n    volume.load();\n    const volumeViewport = renderingEngine.getViewport(viewportId);\n    await setVolumesForViewports(renderingEngine, [\n        {\n            volumeId,\n        },\n    ], [viewportId]);\n    const volumeViewportNewVolumeHandler = () => {\n        volumeViewport.render();\n        element.removeEventListener(Events.VOLUME_VIEWPORT_NEW_VOLUME, volumeViewportNewVolumeHandler);\n    };\n    const addVolumeViewportNewVolumeListener = () => {\n        element.addEventListener(Events.VOLUME_VIEWPORT_NEW_VOLUME, volumeViewportNewVolumeHandler);\n    };\n    addVolumeViewportNewVolumeListener();\n    volumeViewport.setViewPresentation(prevViewPresentation);\n    volumeViewport.setViewReference(prevViewReference);\n    volumeViewport.render();\n    return volumeViewport;\n}\nexport { convertStackToVolumeViewport };\n","import cache from '../cache/cache';\nimport { ImageVolume } from '../cache/classes/ImageVolume';\nimport { ViewportType } from '../enums';\nasync function convertVolumeToStackViewport({ viewport, options, }) {\n    const volumeViewport = viewport;\n    const { id, element } = volumeViewport;\n    const renderingEngine = viewport.getRenderingEngine();\n    const { background } = options;\n    const viewportId = options.viewportId || id;\n    const volume = cache.getVolume(volumeViewport.getVolumeId());\n    if (!(volume instanceof ImageVolume)) {\n        throw new Error('Currently, you cannot decache a volume that is not an ImageVolume. So, unfortunately, volumes such as nifti  (which are basic Volume, without imageIds) cannot be decached.');\n    }\n    const viewportInput = {\n        viewportId,\n        type: ViewportType.STACK,\n        element,\n        defaultOptions: {\n            background,\n        },\n    };\n    const prevView = volumeViewport.getViewReference();\n    renderingEngine.enableElement(viewportInput);\n    const stackViewport = renderingEngine.getViewport(viewportId);\n    await stackViewport.setStack(volume.imageIds);\n    stackViewport.setViewReference(prevView);\n    stackViewport.render();\n    return stackViewport;\n}\nexport { convertVolumeToStackViewport };\n","import { EPSILON } from '../constants';\nfunction roundNumber(value, precision = 2) {\n    if (Array.isArray(value)) {\n        return value.map((v) => roundNumber(v, precision)).join(', ');\n    }\n    if (value === undefined || value === null || value === '') {\n        return 'NaN';\n    }\n    value = Number(value);\n    const absValue = Math.abs(value);\n    if (absValue < 0.0001) {\n        return `${value}`;\n    }\n    const fixedPrecision = absValue >= 100\n        ? precision - 2\n        : absValue >= 10\n            ? precision - 1\n            : absValue >= 1\n                ? precision\n                : absValue >= 0.1\n                    ? precision + 1\n                    : absValue >= 0.01\n                        ? precision + 2\n                        : absValue >= 0.001\n                            ? precision + 3\n                            : precision + 4;\n    return value.toFixed(fixedPrecision);\n}\nfunction roundToPrecision(value) {\n    return Math.round(value / EPSILON) * EPSILON;\n}\nexport { roundToPrecision };\nexport default roundNumber;\n","export default function convertToGrayscale(scalarData, width, height) {\n    const isRGBA = scalarData.length === width * height * 4;\n    const isRGB = scalarData.length === width * height * 3;\n    if (isRGBA || isRGB) {\n        const newScalarData = new Float32Array(width * height);\n        let offset = 0;\n        let destOffset = 0;\n        const increment = isRGBA ? 4 : 3;\n        for (let x = 0; x < width; x++) {\n            for (let y = 0; y < height; y++) {\n                const r = scalarData[offset];\n                const g = scalarData[offset + 1];\n                const b = scalarData[offset + 2];\n                newScalarData[destOffset] = (r + g + b) / 3;\n                offset += increment;\n                destOffset++;\n            }\n        }\n        return newScalarData;\n    }\n    else {\n        return scalarData;\n    }\n}\n","import { VolumeViewport } from '../RenderingEngine';\nimport cache from '../cache/cache';\nfunction getViewportImageIds(viewport) {\n    if (viewport instanceof VolumeViewport) {\n        const volume = cache.getVolume(viewport.getVolumeId());\n        return volume.imageIds;\n    }\n    else if (viewport.getImageIds) {\n        return viewport.getImageIds();\n    }\n}\nexport default getViewportImageIds;\n","export function getRandomSampleFromArray(array, size) {\n    const clonedArray = [...array];\n    if (size >= clonedArray.length) {\n        shuffleArray(clonedArray);\n        return clonedArray;\n    }\n    shuffleArray(clonedArray);\n    return clonedArray.slice(0, size);\n}\nfunction shuffleArray(array) {\n    for (let i = array.length - 1; i > 0; i--) {\n        const j = Math.floor(Math.random() * (i + 1));\n        [array[i], array[j]] = [array[j], array[i]];\n    }\n}\n","function componentToHex(c) {\n    const hex = c.toString(16);\n    return hex.length == 1 ? '0' + hex : hex;\n}\nfunction rgbToHex(r, g, b) {\n    return '#' + componentToHex(r) + componentToHex(g) + componentToHex(b);\n}\nfunction hexToRgb(hex) {\n    const result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n    return result\n        ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16),\n        }\n        : null;\n}\nexport { hexToRgb, rgbToHex };\n","export function deepEqual(obj1, obj2) {\n    if (obj1 === obj2) {\n        return true;\n    }\n    if (obj1 == null || obj2 == null) {\n        return false;\n    }\n    try {\n        return JSON.stringify(obj1) === JSON.stringify(obj2);\n    }\n    catch (error) {\n        console.debug('Error in JSON.stringify during deep comparison:', error);\n        return obj1 === obj2;\n    }\n}\n","import * as metaData from '../metaData';\nconst groupBy = (array, key) => {\n    return array.reduce((rv, x) => {\n        (rv[x[key]] = rv[x[key]] || []).push(x);\n        return rv;\n    }, {});\n};\nfunction getIPPGroups(imageIds) {\n    const ippMetadata = imageIds.map((imageId) => {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId) || {};\n        return { imageId, imagePositionPatient };\n    });\n    if (!ippMetadata.every((item) => item.imagePositionPatient)) {\n        return null;\n    }\n    const positionGroups = groupBy(ippMetadata, 'imagePositionPatient');\n    const positions = Object.keys(positionGroups);\n    const frame_count = positionGroups[positions[0]].length;\n    if (frame_count === 1) {\n        return null;\n    }\n    const frame_count_equal = positions.every((k) => positionGroups[k].length === frame_count);\n    if (!frame_count_equal) {\n        return null;\n    }\n    return positionGroups;\n}\nfunction test4DTag(IPPGroups, value_getter) {\n    const frame_groups = {};\n    let first_frame_value_set = [];\n    const positions = Object.keys(IPPGroups);\n    for (let i = 0; i < positions.length; i++) {\n        const frame_value_set = new Set();\n        const frames = IPPGroups[positions[i]];\n        for (let j = 0; j < frames.length; j++) {\n            const frame_value = value_getter(frames[j].imageId) || 0;\n            frame_groups[frame_value] = frame_groups[frame_value] || [];\n            frame_groups[frame_value].push({ imageId: frames[j].imageId });\n            frame_value_set.add(frame_value);\n            if (frame_value_set.size - 1 < j) {\n                return undefined;\n            }\n        }\n        if (i == 0) {\n            first_frame_value_set = Array.from(frame_value_set);\n        }\n        else if (!setEquals(first_frame_value_set, frame_value_set)) {\n            return undefined;\n        }\n    }\n    return frame_groups;\n}\nfunction getTagValue(imageId, tag) {\n    const value = metaData.get(tag, imageId);\n    try {\n        return parseFloat(value);\n    }\n    catch {\n        return undefined;\n    }\n}\nfunction getPhilipsPrivateBValue(imageId) {\n    const value = metaData.get('20011003', imageId);\n    try {\n        const { InlineBinary } = value;\n        if (InlineBinary) {\n            const value_bytes = atob(InlineBinary);\n            const ary_buf = new ArrayBuffer(value_bytes.length);\n            const dv = new DataView(ary_buf);\n            for (let i = 0; i < value_bytes.length; i++) {\n                dv.setUint8(i, value_bytes.charCodeAt(i));\n            }\n            return new Float32Array(ary_buf)[0];\n        }\n        return parseFloat(value);\n    }\n    catch {\n        return undefined;\n    }\n}\nfunction getSiemensPrivateBValue(imageId) {\n    let value = metaData.get('0019100c', imageId) || metaData.get('0019100C', imageId);\n    try {\n        const { InlineBinary } = value;\n        if (InlineBinary) {\n            value = atob(InlineBinary);\n        }\n        return parseFloat(value);\n    }\n    catch {\n        return undefined;\n    }\n}\nfunction getGEPrivateBValue(imageId) {\n    let value = metaData.get('00431039', imageId);\n    try {\n        const { InlineBinary } = value;\n        if (InlineBinary) {\n            value = atob(InlineBinary).split('//');\n        }\n        return parseFloat(value[0]) % 100000;\n    }\n    catch {\n        return undefined;\n    }\n}\nfunction setEquals(set_a, set_b) {\n    if (set_a.length != set_b.size) {\n        return false;\n    }\n    for (let i = 0; i < set_a.length; i++) {\n        if (!set_b.has(set_a[i])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction getPetFrameReferenceTime(imageId) {\n    const moduleInfo = metaData.get('petImageModule', imageId);\n    return moduleInfo ? moduleInfo['frameReferenceTime'] : 0;\n}\nfunction splitImageIdsBy4DTags(imageIds) {\n    const positionGroups = getIPPGroups(imageIds);\n    if (!positionGroups) {\n        return { imageIdGroups: [imageIds], splittingTag: null };\n    }\n    const tags = [\n        'TemporalPositionIdentifier',\n        'DiffusionBValue',\n        'TriggerTime',\n        'EchoTime',\n        'EchoNumber',\n        'PhilipsPrivateBValue',\n        'SiemensPrivateBValue',\n        'GEPrivateBValue',\n        'PetFrameReferenceTime',\n    ];\n    const fncList2 = [\n        (imageId) => getTagValue(imageId, tags[0]),\n        (imageId) => getTagValue(imageId, tags[1]),\n        (imageId) => getTagValue(imageId, tags[2]),\n        (imageId) => getTagValue(imageId, tags[3]),\n        (imageId) => getTagValue(imageId, tags[4]),\n        getPhilipsPrivateBValue,\n        getSiemensPrivateBValue,\n        getGEPrivateBValue,\n        getPetFrameReferenceTime,\n    ];\n    for (let i = 0; i < fncList2.length; i++) {\n        const frame_groups = test4DTag(positionGroups, fncList2[i]);\n        if (frame_groups) {\n            const sortedKeys = Object.keys(frame_groups)\n                .map(Number.parseFloat)\n                .sort((a, b) => a - b);\n            const imageIdGroups = sortedKeys.map((key) => frame_groups[key].map((item) => item.imageId));\n            return { imageIdGroups, splittingTag: tags[i] };\n        }\n    }\n    return { imageIdGroups: [imageIds], splittingTag: null };\n}\nexport default splitImageIdsBy4DTags;\n","import splitImageIdsBy4DTags from './splitImageIdsBy4DTags';\nfunction getDynamicVolumeInfo(imageIds) {\n    const { imageIdGroups: timePoints, splittingTag } = splitImageIdsBy4DTags(imageIds);\n    const isDynamicVolume = timePoints.length > 1;\n    return { isDynamicVolume, timePoints, splittingTag };\n}\nexport default getDynamicVolumeInfo;\n","export default function scaleArray(array, scalingParameters) {\n    const arrayLength = array.length;\n    const { rescaleSlope, rescaleIntercept, suvbw } = scalingParameters;\n    if (scalingParameters.modality === 'PT' && typeof suvbw === 'number') {\n        for (let i = 0; i < arrayLength; i++) {\n            array[i] = suvbw * (array[i] * rescaleSlope + rescaleIntercept);\n        }\n    }\n    else {\n        for (let i = 0; i < arrayLength; i++) {\n            array[i] = array[i] * rescaleSlope + rescaleIntercept;\n        }\n    }\n    return array;\n}\n","export function clip(val, low, high) {\n    return Math.min(Math.max(low, val), high);\n}\nexport function clipToBox(point, box) {\n    point.x = clip(point.x, 0, box.width);\n    point.y = clip(point.y, 0, box.height);\n}\nexport default clip;\n","import { Events } from '../enums';\nimport { StackViewport, VolumeViewport } from '../RenderingEngine';\nimport getVolumeViewportScrollInfo from './getVolumeViewportScrollInfo';\nimport snapFocalPointToSlice from './snapFocalPointToSlice';\nimport getEnabledElement from '../getEnabledElement';\nimport triggerEvent from './triggerEvent';\nimport eventTarget from '../eventTarget';\nexport default function scroll(viewport, options) {\n    const enabledElement = getEnabledElement(viewport.element);\n    if (!enabledElement) {\n        throw new Error('Scroll::Viewport is not enabled (it might be disabled)');\n    }\n    if (viewport instanceof StackViewport &&\n        viewport.getImageIds().length === 0) {\n        throw new Error('Scroll::Stack Viewport has no images');\n    }\n    const { volumeId, delta, scrollSlabs } = options;\n    if (viewport instanceof VolumeViewport) {\n        scrollVolume(viewport, volumeId, delta, scrollSlabs);\n    }\n    else {\n        const imageIdIndex = viewport.getCurrentImageIdIndex();\n        if (imageIdIndex + delta >\n            viewport.getImageIds().length - 1 ||\n            imageIdIndex + delta < 0) {\n            const eventData = {\n                imageIdIndex,\n                direction: delta,\n            };\n            triggerEvent(eventTarget, Events.STACK_SCROLL_OUT_OF_BOUNDS, eventData);\n        }\n        viewport.scroll(delta, options.debounceLoading, options.loop);\n    }\n}\nexport function scrollVolume(viewport, volumeId, delta, scrollSlabs = false) {\n    const useSlabThickness = scrollSlabs;\n    const { numScrollSteps, currentStepIndex, sliceRangeInfo } = getVolumeViewportScrollInfo(viewport, volumeId, useSlabThickness);\n    if (!sliceRangeInfo) {\n        return;\n    }\n    const { sliceRange, spacingInNormalDirection, camera } = sliceRangeInfo;\n    const { focalPoint, viewPlaneNormal, position } = camera;\n    const { newFocalPoint, newPosition } = snapFocalPointToSlice(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, delta);\n    viewport.setCamera({\n        focalPoint: newFocalPoint,\n        position: newPosition,\n    });\n    viewport.render();\n    const desiredStepIndex = currentStepIndex + delta;\n    const VolumeScrollEventDetail = {\n        volumeId,\n        viewport,\n        delta,\n        desiredStepIndex,\n        currentStepIndex,\n        numScrollSteps,\n        currentImageId: viewport.getCurrentImageId(),\n    };\n    if ((desiredStepIndex > numScrollSteps || desiredStepIndex < 0) &&\n        viewport.getCurrentImageId()) {\n        triggerEvent(eventTarget, Events.VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS, VolumeScrollEventDetail);\n    }\n    else {\n        triggerEvent(eventTarget, Events.VOLUME_VIEWPORT_SCROLL, VolumeScrollEventDetail);\n    }\n}\n","import clip from './clip';\nimport scroll from './scroll';\nimport getEnabledElement from '../getEnabledElement';\nimport StackViewport from '../RenderingEngine/StackViewport';\nasync function jumpToSlice(element, options = {}) {\n    const { imageIndex, debounceLoading, volumeId } = options;\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        throw new Error('Element has been disabled');\n    }\n    const { viewport } = enabledElement;\n    const { imageIndex: currentImageIndex, numberOfSlices } = _getImageSliceData(viewport, debounceLoading);\n    const imageIndexToJump = _getImageIndexToJump(numberOfSlices, imageIndex);\n    const delta = imageIndexToJump - currentImageIndex;\n    scroll(viewport, { delta, debounceLoading, volumeId });\n}\nfunction _getImageSliceData(viewport, debounceLoading) {\n    if (viewport instanceof StackViewport) {\n        return {\n            numberOfSlices: viewport.getImageIds().length,\n            imageIndex: debounceLoading\n                ? viewport.getTargetImageIdIndex()\n                : viewport.getCurrentImageIdIndex(),\n        };\n    }\n    return {\n        numberOfSlices: viewport.getNumberOfSlices(),\n        imageIndex: viewport.getSliceIndex(),\n    };\n}\nfunction _getImageIndexToJump(numberOfSlices, imageIndex) {\n    const lastSliceIndex = numberOfSlices - 1;\n    return clip(imageIndex, 0, lastSliceIndex);\n}\nexport { jumpToSlice };\n","import transformWorldToIndex from './transformWorldToIndex';\nimport transformIndexToWorld from './transformIndexToWorld';\nimport uuidv4 from './uuidv4';\nimport { createLocalVolume } from '../loaders/volumeLoader';\nimport cache from '../cache/cache';\nfunction createSubVolume(referencedVolumeId, boundsIJK, options = {}) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    if (!referencedVolume) {\n        throw new Error(`Referenced volume with id ${referencedVolumeId} does not exist.`);\n    }\n    const { metadata, spacing, direction, dimensions: refVolumeDim, } = referencedVolume;\n    const { minX, maxX, minY, maxY, minZ, maxZ } = boundsIJK;\n    const ijkTopLeft = [\n        Math.min(minX, maxX),\n        Math.min(minY, maxY),\n        Math.min(minZ, maxZ),\n    ];\n    const boundingBoxOriginWorld = transformIndexToWorld(referencedVolume.imageData, ijkTopLeft);\n    const dimensions = [\n        Math.abs(maxX - minX) + 1,\n        Math.abs(maxY - minY) + 1,\n        Math.abs(maxZ - minZ) + 1,\n    ];\n    const { targetBuffer } = options;\n    const subVolumeOptions = {\n        metadata,\n        dimensions,\n        spacing,\n        origin: boundingBoxOriginWorld,\n        direction,\n        targetBuffer,\n        scalarData: targetBuffer?.type === 'Float32Array'\n            ? new Float32Array(dimensions[0] * dimensions[1] * dimensions[2])\n            : undefined,\n    };\n    const subVolume = createLocalVolume(uuidv4(), subVolumeOptions);\n    const subVolumeData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const subVolumeSliceSize = dimensions[0] * dimensions[1];\n    const refVolumeSliceSize = refVolumeDim[0] * refVolumeDim[1];\n    const refVolumeData = referencedVolume.voxelManager.getCompleteScalarDataArray();\n    for (let z = 0; z < dimensions[2]; z++) {\n        for (let y = 0; y < dimensions[1]; y++) {\n            const rowStartWorld = transformIndexToWorld(subVolume.imageData, [\n                0,\n                y,\n                z,\n            ]);\n            const refVolumeRowStartIJK = transformWorldToIndex(referencedVolume.imageData, rowStartWorld);\n            const refVolumeRowStartOffset = refVolumeRowStartIJK[2] * refVolumeSliceSize +\n                refVolumeRowStartIJK[1] * refVolumeDim[0] +\n                refVolumeRowStartIJK[0];\n            const rowData = refVolumeData.slice(refVolumeRowStartOffset, refVolumeRowStartOffset + dimensions[0]);\n            const subVolumeLineStartOffset = z * subVolumeSliceSize + y * dimensions[0];\n            subVolumeData.set(rowData, subVolumeLineStartOffset);\n        }\n    }\n    subVolume.voxelManager.setCompleteScalarDataArray(subVolumeData);\n    return subVolume;\n}\nexport { createSubVolume as default, createSubVolume };\n","import { vec3 } from 'gl-matrix';\nimport { transformWorldToIndexContinuous } from './transformWorldToIndex';\nfunction getVolumeDirectionVectors(imageData, camera) {\n    const { viewUp, viewPlaneNormal } = camera;\n    const ijkOrigin = transformWorldToIndexContinuous(imageData, [0, 0, 0]);\n    const worldVecColDir = vec3.negate(vec3.create(), viewUp);\n    const worldVecSliceDir = vec3.negate(vec3.create(), viewPlaneNormal);\n    const worldVecRowDir = vec3.cross(vec3.create(), worldVecColDir, worldVecSliceDir);\n    const ijkVecColDir = vec3.sub(vec3.create(), transformWorldToIndexContinuous(imageData, worldVecColDir), ijkOrigin);\n    const ijkVecSliceDir = vec3.sub(vec3.create(), transformWorldToIndexContinuous(imageData, worldVecSliceDir), ijkOrigin);\n    vec3.normalize(ijkVecColDir, ijkVecColDir);\n    vec3.normalize(ijkVecSliceDir, ijkVecSliceDir);\n    const ijkVecRowDir = vec3.cross(vec3.create(), ijkVecColDir, ijkVecSliceDir);\n    return {\n        worldVecRowDir,\n        worldVecColDir,\n        worldVecSliceDir,\n        ijkVecRowDir,\n        ijkVecColDir,\n        ijkVecSliceDir,\n    };\n}\nexport { getVolumeDirectionVectors as default, getVolumeDirectionVectors };\n","export function calculateNeighborhoodStats(scalarData, dimensions, centerIjk, radius) {\n    const [width, height, numSlices] = dimensions;\n    const numPixelsPerSlice = width * height;\n    let sum = 0;\n    let sumSq = 0;\n    let count = 0;\n    const [cx, cy, cz] = centerIjk.map(Math.round);\n    for (let z = cz - radius; z <= cz + radius; z++) {\n        if (z < 0 || z >= numSlices) {\n            continue;\n        }\n        for (let y = cy - radius; y <= cy + radius; y++) {\n            if (y < 0 || y >= height) {\n                continue;\n            }\n            for (let x = cx - radius; x <= cx + radius; x++) {\n                if (x < 0 || x >= width) {\n                    continue;\n                }\n                const index = z * numPixelsPerSlice + y * width + x;\n                const value = scalarData[index];\n                sum += value;\n                sumSq += value * value;\n                count++;\n            }\n        }\n    }\n    if (count === 0) {\n        const centerIndex = cz * numPixelsPerSlice + cy * width + cx;\n        if (centerIndex >= 0 && centerIndex < scalarData.length) {\n            const centerValue = scalarData[centerIndex];\n            return { mean: centerValue, stdDev: 0, count: 1 };\n        }\n        else {\n            return { mean: 0, stdDev: 0, count: 0 };\n        }\n    }\n    const mean = sum / count;\n    const variance = sumSq / count - mean * mean;\n    const stdDev = Math.sqrt(Math.max(0, variance));\n    return { mean, stdDev, count };\n}\n","import { isEqual } from './isEqual';\nimport { CalibrationTypes } from '../enums';\nconst projectionRadiographSOPClassUIDs = new Set([\n    '1.2.840.10008.5.1.4.1.1.1',\n    '1.2.840.10008.5.1.4.1.1.1.1',\n    '1.2.840.10008.5.1.4.1.1.1.1.1',\n    '1.2.840.10008.5.1.4.1.1.1.2',\n    '1.2.840.10008.5.1.4.1.1.1.2.1',\n    '1.2.840.10008.5.1.4.1.1.1.3',\n    '1.2.840.10008.5.1.4.1.1.1.3.1',\n    '1.2.840.10008.5.1.4.1.1.12.1',\n    '1.2.840.10008.5.1.4.1.1.12.1.1',\n    '1.2.840.10008.5.1.4.1.1.12.2',\n    '1.2.840.10008.5.1.4.1.1.12.2.1',\n    '1.2.840.10008.5.1.4.1.1.12.3',\n]);\nconst alreadySeenWarn = new Set();\nfunction calculateRadiographicPixelSpacing(instance) {\n    const { PixelSpacing, ImagerPixelSpacing, EstimatedRadiographicMagnificationFactor, PixelSpacingCalibrationType, PixelSpacingCalibrationDescription, } = instance;\n    const isProjection = true;\n    if (!ImagerPixelSpacing) {\n        return {\n            PixelSpacing,\n            type: CalibrationTypes.UNKNOWN,\n            isProjection,\n        };\n    }\n    if (!PixelSpacing) {\n        if (!EstimatedRadiographicMagnificationFactor) {\n            if (!alreadySeenWarn.has(instance.SeriesInstanceUID)) {\n                console.warn('EstimatedRadiographicMagnificationFactor was not present on series', instance.SeriesInstanceUID, ' Unable to correct ImagerPixelSpacing.');\n                alreadySeenWarn.add(instance.SeriesInstanceUID);\n            }\n            return {\n                PixelSpacing: ImagerPixelSpacing,\n                type: CalibrationTypes.PROJECTION,\n                isProjection,\n            };\n        }\n        const correctedPixelSpacing = ImagerPixelSpacing.map((pixelSpacing) => pixelSpacing / EstimatedRadiographicMagnificationFactor);\n        return {\n            PixelSpacing: correctedPixelSpacing,\n            type: CalibrationTypes.ERMF,\n            isProjection,\n        };\n    }\n    if (isEqual(PixelSpacing, ImagerPixelSpacing)) {\n        return {\n            PixelSpacing,\n            type: CalibrationTypes.PROJECTION,\n            isProjection,\n        };\n    }\n    if (PixelSpacingCalibrationType || PixelSpacingCalibrationDescription) {\n        return {\n            PixelSpacing,\n            type: CalibrationTypes.CALIBRATED,\n            isProjection,\n            PixelSpacingCalibrationType,\n            PixelSpacingCalibrationDescription,\n        };\n    }\n    return {\n        PixelSpacing,\n        type: CalibrationTypes.UNKNOWN,\n        isProjection,\n    };\n}\nfunction calculateUSPixelSpacing(instance) {\n    const { SequenceOfUltrasoundRegions } = instance;\n    const isArrayOfSequences = Array.isArray(SequenceOfUltrasoundRegions);\n    if (isArrayOfSequences && SequenceOfUltrasoundRegions.length > 1) {\n        console.warn('Sequence of Ultrasound Regions > one entry. This is not yet implemented, all measurements will be shown in pixels.');\n        return;\n    }\n    const { PhysicalDeltaX, PhysicalDeltaY } = isArrayOfSequences\n        ? SequenceOfUltrasoundRegions[0]\n        : SequenceOfUltrasoundRegions;\n    const USPixelSpacing = [\n        Math.abs(PhysicalDeltaX) * 10,\n        Math.abs(PhysicalDeltaY) * 10,\n    ];\n    return {\n        PixelSpacing: USPixelSpacing,\n    };\n}\nexport default function getPixelSpacingInformation(instance) {\n    const { PixelSpacing, SOPClassUID, SequenceOfUltrasoundRegions } = instance;\n    if (SequenceOfUltrasoundRegions) {\n        return calculateUSPixelSpacing(instance);\n    }\n    const isProjection = projectionRadiographSOPClassUIDs.has(SOPClassUID);\n    if (isProjection) {\n        return calculateRadiographicPixelSpacing(instance);\n    }\n    return {\n        PixelSpacing,\n        type: CalibrationTypes.NOT_APPLICABLE,\n        isProjection: false,\n    };\n}\n","import * as eventListener from './eventListener';\nimport csUtils from './invertRgbTransferFunction';\nimport createSigmoidRGBTransferFunction from './createSigmoidRGBTransferFunction';\nimport getVoiFromSigmoidRGBTransferFunction from './getVoiFromSigmoidRGBTransferFunction';\nimport createLinearRGBTransferFunction from './createLinearRGBTransferFunction';\nimport scaleRgbTransferFunction from './scaleRgbTransferFunction';\nimport triggerEvent from './triggerEvent';\nimport uuidv4 from './uuidv4';\nimport getMinMax from './getMinMax';\nimport getRuntimeId from './getRuntimeId';\nimport imageIdToURI from './imageIdToURI';\nimport calibratedPixelSpacingMetadataProvider from './calibratedPixelSpacingMetadataProvider';\nimport clamp from './clamp';\nimport isOpposite from './isOpposite';\nimport getClosestImageId from './getClosestImageId';\nimport getSpacingInNormalDirection from './getSpacingInNormalDirection';\nimport getTargetVolumeAndSpacingInNormalDir from './getTargetVolumeAndSpacingInNormalDir';\nimport getVolumeActorCorners from './getVolumeActorCorners';\nimport indexWithinDimensions from './indexWithinDimensions';\nimport getVolumeViewportsContainingSameVolumes from './getVolumeViewportsContainingSameVolumes';\nimport getViewportsWithVolumeId from './getViewportsWithVolumeId';\nimport transformWorldToIndex, { transformWorldToIndexContinuous, } from './transformWorldToIndex';\nimport transformIndexToWorld from './transformIndexToWorld';\nimport loadImageToCanvas from './loadImageToCanvas';\nimport * as HistoryMemo from './historyMemo';\nimport renderToCanvasCPU from './renderToCanvasCPU';\nimport renderToCanvasGPU from './renderToCanvasGPU';\nimport worldToImageCoords from './worldToImageCoords';\nimport imageToWorldCoords from './imageToWorldCoords';\nimport getVolumeSliceRangeInfo from './getVolumeSliceRangeInfo';\nimport getVolumeViewportScrollInfo from './getVolumeViewportScrollInfo';\nimport getSliceRange from './getSliceRange';\nimport snapFocalPointToSlice from './snapFocalPointToSlice';\nimport getImageSliceDataForVolumeViewport from './getImageSliceDataForVolumeViewport';\nimport { isImageActor, actorIsA } from './actorCheck';\nimport getViewportsWithImageURI from './getViewportsWithImageURI';\nimport getClosestStackImageIndexForPoint from './getClosestStackImageIndexForPoint';\nimport getCurrentVolumeViewportSlice from './getCurrentVolumeViewportSlice';\nimport calculateViewportsSpatialRegistration from './calculateViewportsSpatialRegistration';\nimport spatialRegistrationMetadataProvider from './spatialRegistrationMetadataProvider';\nimport getViewportImageCornersInWorld from './getViewportImageCornersInWorld';\nimport hasNaNValues from './hasNaNValues';\nimport applyPreset from './applyPreset';\nimport PointsManager from './PointsManager';\nimport deepMerge from './deepMerge';\nimport getScalingParameters from './getScalingParameters';\nimport isPTPrescaledWithSUV from './isPTPrescaledWithSUV';\nimport getImageLegacy from './getImageLegacy';\nimport sortImageIdsAndGetSpacing from './sortImageIdsAndGetSpacing';\nimport makeVolumeMetadata from './makeVolumeMetadata';\nimport genericMetadataProvider from './genericMetadataProvider';\nimport { isValidVolume } from './isValidVolume';\nimport { updateVTKImageDataWithCornerstoneImage } from './updateVTKImageDataWithCornerstoneImage';\nimport ProgressiveIterator from './ProgressiveIterator';\nimport decimate from './decimate';\nimport imageRetrieveMetadataProvider from './imageRetrieveMetadataProvider';\nimport isVideoTransferSyntax from './isVideoTransferSyntax';\nimport { getBufferConfiguration } from './getBufferConfiguration';\nimport { generateVolumePropsFromImageIds } from './generateVolumePropsFromImageIds';\nimport { convertStackToVolumeViewport } from './convertStackToVolumeViewport';\nimport { convertVolumeToStackViewport } from './convertVolumeToStackViewport';\nimport VoxelManager from './VoxelManager';\nimport RLEVoxelMap from './RLEVoxelMap';\nimport roundNumber, { roundToPrecision } from './roundNumber';\nimport convertToGrayscale from './convertToGrayscale';\nimport getViewportImageIds from './getViewportImageIds';\nimport { getRandomSampleFromArray } from './getRandomSampleFromArray';\nimport { getVolumeId } from './getVolumeId';\nimport { hasFloatScalingParameters } from './hasFloatScalingParameters';\nimport { pointInShapeCallback } from './pointInShapeCallback';\nexport * as planar from './planar';\nimport * as windowLevel from './windowLevel';\nimport * as colormap from './colormap';\nimport * as transferFunctionUtils from './transferFunctionUtils';\nimport * as color from './color';\nimport { deepEqual } from './deepEqual';\nimport FrameRange from './FrameRange';\nimport fnv1aHash from './fnv1aHash';\nimport { getImageDataMetadata } from './getImageDataMetadata';\nimport { buildMetadata } from './buildMetadata';\nimport { _getViewportModality } from './getViewportModality';\nimport cache from '../cache/cache';\nimport getDynamicVolumeInfo from './getDynamicVolumeInfo';\nimport autoLoad from './autoLoad';\nimport scaleArray from './scaleArray';\nimport splitImageIdsBy4DTags from './splitImageIdsBy4DTags';\nimport { deepClone } from './deepClone';\nimport { jumpToSlice } from './jumpToSlice';\nimport scroll from './scroll';\nimport clip from './clip';\nimport createSubVolume from './createSubVolume';\nimport getVolumeDirectionVectors from './getVolumeDirectionVectors';\nimport calculateSpacingBetweenImageIds from './calculateSpacingBetweenImageIds';\nexport * as logger from './logger';\nimport { calculateNeighborhoodStats } from './calculateNeighborhoodStats';\nimport getPixelSpacingInformation from './getPixelSpacingInformation';\nimport { asArray } from './asArray';\nexport { updatePlaneRestriction } from './updatePlaneRestriction';\nconst getViewportModality = (viewport, volumeId) => _getViewportModality(viewport, volumeId, cache.getVolume);\nexport * from './isEqual';\nexport { FrameRange, eventListener, csUtils as invertRgbTransferFunction, createSigmoidRGBTransferFunction, getVoiFromSigmoidRGBTransferFunction, createLinearRGBTransferFunction, scaleRgbTransferFunction, triggerEvent, imageIdToURI, fnv1aHash, calibratedPixelSpacingMetadataProvider, clamp, uuidv4, getMinMax, getRuntimeId, isOpposite, getViewportModality, windowLevel, convertToGrayscale, getClosestImageId, getSpacingInNormalDirection, getTargetVolumeAndSpacingInNormalDir, getVolumeActorCorners, indexWithinDimensions, getVolumeViewportsContainingSameVolumes, getViewportsWithVolumeId, transformWorldToIndex, transformIndexToWorld, loadImageToCanvas, renderToCanvasCPU, renderToCanvasGPU, worldToImageCoords, imageToWorldCoords, getVolumeSliceRangeInfo, getVolumeViewportScrollInfo, getSliceRange, snapFocalPointToSlice, getImageSliceDataForVolumeViewport, isImageActor, isPTPrescaledWithSUV, actorIsA, getViewportsWithImageURI, getClosestStackImageIndexForPoint, getCurrentVolumeViewportSlice, calculateViewportsSpatialRegistration, spatialRegistrationMetadataProvider, getViewportImageCornersInWorld, hasNaNValues, applyPreset, deepMerge, PointsManager, getScalingParameters, colormap, getImageLegacy, ProgressiveIterator, decimate, imageRetrieveMetadataProvider, transferFunctionUtils, updateVTKImageDataWithCornerstoneImage, sortImageIdsAndGetSpacing, makeVolumeMetadata, isValidVolume, genericMetadataProvider, isVideoTransferSyntax, HistoryMemo, generateVolumePropsFromImageIds, getBufferConfiguration, VoxelManager, RLEVoxelMap, convertStackToVolumeViewport, convertVolumeToStackViewport, roundNumber, roundToPrecision, getViewportImageIds, getRandomSampleFromArray, getVolumeId, color, hasFloatScalingParameters, getDynamicVolumeInfo, autoLoad, scaleArray, deepClone, splitImageIdsBy4DTags, pointInShapeCallback, deepEqual, jumpToSlice, scroll, clip, transformWorldToIndexContinuous, createSubVolume, getVolumeDirectionVectors, calculateSpacingBetweenImageIds, getImageDataMetadata, buildMetadata, calculateNeighborhoodStats, getPixelSpacingInformation, asArray, };\n","function _getViewportModality(viewport, volumeId, getVolume) {\n    if (!getVolume) {\n        throw new Error('getVolume is required, use the utilities export instead ');\n    }\n    if (viewport.modality) {\n        return viewport.modality;\n    }\n    if (viewport.setVolumes) {\n        volumeId = volumeId ?? viewport.getVolumeId();\n        if (!volumeId || !getVolume) {\n            return;\n        }\n        const volume = getVolume(volumeId);\n        return volume.metadata.Modality;\n    }\n    throw new Error('Invalid viewport type');\n}\nexport { _getViewportModality };\n","export default function invertRgbTransferFunction(rgbTransferFunction) {\n    if (!rgbTransferFunction) {\n        return;\n    }\n    const size = rgbTransferFunction.getSize();\n    for (let index = 0; index < size; index++) {\n        const nodeValue1 = [];\n        rgbTransferFunction.getNodeValue(index, nodeValue1);\n        nodeValue1[1] = 1 - nodeValue1[1];\n        nodeValue1[2] = 1 - nodeValue1[2];\n        nodeValue1[3] = 1 - nodeValue1[3];\n        rgbTransferFunction.setNodeValue(index, nodeValue1);\n    }\n}\n","function areNumbersEqualWithTolerance(num1, num2, tolerance) {\n    return Math.abs(num1 - num2) <= tolerance;\n}\nfunction areArraysEqual(arr1, arr2, tolerance = 1e-5) {\n    if (arr1.length !== arr2.length) {\n        return false;\n    }\n    for (let i = 0; i < arr1.length; i++) {\n        if (!areNumbersEqualWithTolerance(arr1[i], arr2[i], tolerance)) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction isNumberType(value) {\n    return typeof value === 'number';\n}\nfunction isNumberArrayLike(value) {\n    return (value &&\n        typeof value === 'object' &&\n        'length' in value &&\n        typeof value.length === 'number' &&\n        value.length > 0 &&\n        typeof value[0] === 'number');\n}\nexport function isEqual(v1, v2, tolerance = 1e-5) {\n    if (typeof v1 !== typeof v2 || v1 === null || v2 === null) {\n        return false;\n    }\n    if (isNumberType(v1) && isNumberType(v2)) {\n        return areNumbersEqualWithTolerance(v1, v2, tolerance);\n    }\n    if (isNumberArrayLike(v1) && isNumberArrayLike(v2)) {\n        return areArraysEqual(v1, v2, tolerance);\n    }\n    return false;\n}\nconst negative = (v) => typeof v === 'number' ? -v : v?.map ? v.map(negative) : !v;\nconst abs = (v) => typeof v === 'number' ? Math.abs(v) : v?.map ? v.map(abs) : v;\nexport const isEqualNegative = (v1, v2, tolerance = undefined) => isEqual(v1, negative(v2), tolerance);\nexport const isEqualAbs = (v1, v2, tolerance = undefined) => isEqual(abs(v1), abs(v2), tolerance);\nexport function isNumber(n) {\n    if (Array.isArray(n)) {\n        return isNumber(n[0]);\n    }\n    return isFinite(n) && !isNaN(n);\n}\nexport default isEqual;\n","import loglevelImport from 'loglevel';\nconst loglevel = loglevelImport.noConflict();\nif (typeof window !== 'undefined') {\n    window.log = loglevel;\n}\nexport function getRootLogger(name) {\n    const logger = loglevel.getLogger(name[0]);\n    logger.getLogger = (...names) => {\n        return getRootLogger(`${name}.${names.join('.')}`);\n    };\n    return logger;\n}\nexport function getLogger(...name) {\n    return getRootLogger(name.join('.'));\n}\nexport const cs3dLog = getRootLogger('cs3d');\nexport const coreLog = cs3dLog.getLogger('core');\nexport const toolsLog = cs3dLog.getLogger('tools');\nexport const loaderLog = cs3dLog.getLogger('dicomImageLoader');\nexport const aiLog = cs3dLog.getLogger('ai');\nexport const examplesLog = cs3dLog.getLogger('examples');\nexport const dicomConsistencyLog = getLogger('consistency', 'dicom');\nexport const imageConsistencyLog = getLogger('consistency', 'image');\n","import { get } from '../metaData';\nexport default function makeVolumeMetadata(imageIds) {\n    const imageId0 = imageIds[0];\n    const { pixelRepresentation, bitsAllocated, bitsStored, highBit, photometricInterpretation, samplesPerPixel, } = get('imagePixelModule', imageId0);\n    const voiLut = [];\n    const voiLutModule = get('voiLutModule', imageId0);\n    let voiLUTFunction;\n    if (voiLutModule) {\n        const { windowWidth, windowCenter } = voiLutModule;\n        voiLUTFunction = voiLutModule?.voiLUTFunction;\n        if (Array.isArray(windowWidth)) {\n            for (let i = 0; i < windowWidth.length; i++) {\n                voiLut.push({\n                    windowWidth: windowWidth[i],\n                    windowCenter: windowCenter[i],\n                });\n            }\n        }\n        else {\n            voiLut.push({\n                windowWidth: windowWidth,\n                windowCenter: windowCenter,\n            });\n        }\n    }\n    else {\n        voiLut.push({\n            windowWidth: undefined,\n            windowCenter: undefined,\n        });\n    }\n    const { modality, seriesInstanceUID } = get('generalSeriesModule', imageId0);\n    const { imageOrientationPatient, pixelSpacing, frameOfReferenceUID, columns, rows, } = get('imagePlaneModule', imageId0);\n    return {\n        BitsAllocated: bitsAllocated,\n        BitsStored: bitsStored,\n        SamplesPerPixel: samplesPerPixel,\n        HighBit: highBit,\n        PhotometricInterpretation: photometricInterpretation,\n        PixelRepresentation: pixelRepresentation,\n        Modality: modality,\n        ImageOrientationPatient: imageOrientationPatient,\n        PixelSpacing: pixelSpacing,\n        FrameOfReferenceUID: frameOfReferenceUID,\n        Columns: columns,\n        Rows: rows,\n        voiLut,\n        VOILUTFunction: voiLUTFunction,\n        SeriesInstanceUID: seriesInstanceUID,\n    };\n}\n","import { mat3 } from 'gl-matrix';\nimport { EPSILON } from '../constants';\nfunction linePlaneIntersection(p0, p1, plane) {\n    const [x0, y0, z0] = p0;\n    const [x1, y1, z1] = p1;\n    const [A, B, C, D] = plane;\n    const a = x1 - x0;\n    const b = y1 - y0;\n    const c = z1 - z0;\n    const t = (-1 * (A * x0 + B * y0 + C * z0 - D)) / (A * a + B * b + C * c);\n    const X = a * t + x0;\n    const Y = b * t + y0;\n    const Z = c * t + z0;\n    return [X, Y, Z];\n}\nfunction planeEquation(normal, point, normalized = false) {\n    const [A, B, C] = normal;\n    const D = A * point[0] + B * point[1] + C * point[2];\n    if (normalized) {\n        const length = Math.sqrt(A * A + B * B + C * C);\n        return [A / length, B / length, C / length, D / length];\n    }\n    return [A, B, C, D];\n}\nfunction threePlaneIntersection(firstPlane, secondPlane, thirdPlane) {\n    const [A1, B1, C1, D1] = firstPlane;\n    const [A2, B2, C2, D2] = secondPlane;\n    const [A3, B3, C3, D3] = thirdPlane;\n    const m0 = mat3.fromValues(A1, A2, A3, B1, B2, B3, C1, C2, C3);\n    const m1 = mat3.fromValues(D1, D2, D3, B1, B2, B3, C1, C2, C3);\n    const m2 = mat3.fromValues(A1, A2, A3, D1, D2, D3, C1, C2, C3);\n    const m3 = mat3.fromValues(A1, A2, A3, B1, B2, B3, D1, D2, D3);\n    const x = mat3.determinant(m1) / mat3.determinant(m0);\n    const y = mat3.determinant(m2) / mat3.determinant(m0);\n    const z = mat3.determinant(m3) / mat3.determinant(m0);\n    return [x, y, z];\n}\nfunction planeDistanceToPoint(plane, point, signed = false) {\n    const [A, B, C, D] = plane;\n    const [x, y, z] = point;\n    const numerator = A * x + B * y + C * z - D;\n    const distance = Math.abs(numerator) / Math.sqrt(A * A + B * B + C * C);\n    const sign = signed ? Math.sign(numerator) : 1;\n    return sign * distance;\n}\nfunction isPointOnPlane(point, plane, tolerance = EPSILON) {\n    return planeDistanceToPoint(plane, point) < tolerance;\n}\nexport { linePlaneIntersection, planeEquation, threePlaneIntersection, planeDistanceToPoint, isPointOnPlane, };\n","import { createPositionCallback } from './createPositionCallback';\nexport function pointInShapeCallback(imageData, options) {\n    const { pointInShapeFn, callback, boundsIJK, returnPoints = false } = options;\n    let scalarData;\n    if (imageData.getScalarData) {\n        scalarData = imageData.getScalarData();\n    }\n    else {\n        const scalars = imageData.getPointData().getScalars();\n        if (scalars) {\n            scalarData = scalars.getData();\n        }\n        else {\n            const { voxelManager } = imageData.get('voxelManager') || {};\n            if (voxelManager) {\n                scalarData = voxelManager.getCompleteScalarDataArray();\n            }\n        }\n    }\n    const dimensions = imageData.getDimensions();\n    const defaultBoundsIJK = [\n        [0, dimensions[0]],\n        [0, dimensions[1]],\n        [0, dimensions[2]],\n    ];\n    const bounds = boundsIJK || defaultBoundsIJK;\n    const pointsInShape = iterateOverPointsInShape({\n        imageData,\n        bounds,\n        scalarData,\n        pointInShapeFn,\n        callback,\n    });\n    return returnPoints ? pointsInShape : undefined;\n}\nexport function iterateOverPointsInShape({ imageData, bounds, scalarData, pointInShapeFn, callback, }) {\n    const [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = bounds;\n    const { numComps } = imageData;\n    const dimensions = imageData.getDimensions();\n    const indexToWorld = createPositionCallback(imageData);\n    const pointIJK = [0, 0, 0];\n    const xMultiple = numComps ||\n        scalarData.length / dimensions[2] / dimensions[1] / dimensions[0];\n    const yMultiple = dimensions[0] * xMultiple;\n    const zMultiple = dimensions[1] * yMultiple;\n    const pointsInShape = [];\n    for (let k = kMin; k <= kMax; k++) {\n        pointIJK[2] = k;\n        const indexK = k * zMultiple;\n        for (let j = jMin; j <= jMax; j++) {\n            pointIJK[1] = j;\n            const indexJK = indexK + j * yMultiple;\n            for (let i = iMin; i <= iMax; i++) {\n                pointIJK[0] = i;\n                const pointLPS = indexToWorld(pointIJK);\n                if (pointInShapeFn(pointLPS, pointIJK)) {\n                    const index = indexJK + i * xMultiple;\n                    let value;\n                    if (xMultiple > 2) {\n                        value = [\n                            scalarData[index],\n                            scalarData[index + 1],\n                            scalarData[index + 2],\n                        ];\n                    }\n                    else {\n                        value = scalarData[index];\n                    }\n                    pointsInShape.push({\n                        value,\n                        index,\n                        pointIJK,\n                        pointLPS: pointLPS.slice(),\n                    });\n                    callback({ value, index, pointIJK, pointLPS });\n                }\n            }\n        }\n    }\n    return pointsInShape;\n}\nexport function iterateOverPointsInShapeVoxelManager({ voxelManager, bounds, imageData, pointInShapeFn, callback, returnPoints, }) {\n    const [[iMin, iMax], [jMin, jMax], [kMin, kMax]] = bounds;\n    const indexToWorld = createPositionCallback(imageData);\n    const pointIJK = [0, 0, 0];\n    const pointsInShape = [];\n    for (let k = kMin; k <= kMax; k++) {\n        pointIJK[2] = k;\n        for (let j = jMin; j <= jMax; j++) {\n            pointIJK[1] = j;\n            for (let i = iMin; i <= iMax; i++) {\n                pointIJK[0] = i;\n                const pointLPS = indexToWorld(pointIJK);\n                if (pointInShapeFn(pointLPS, pointIJK)) {\n                    const index = voxelManager.toIndex(pointIJK);\n                    const value = voxelManager.getAtIndex(index);\n                    if (returnPoints) {\n                        pointsInShape.push({\n                            value,\n                            index,\n                            pointIJK: [...pointIJK],\n                            pointLPS: pointLPS.slice(),\n                        });\n                    }\n                    callback?.({ value, index, pointIJK, pointLPS });\n                }\n            }\n        }\n    }\n    return pointsInShape;\n}\n","import { vec3 } from 'gl-matrix';\nexport default function snapFocalPointToSlice(focalPoint, position, sliceRange, viewPlaneNormal, spacingInNormalDirection, deltaFrames) {\n    const { min, max, current } = sliceRange;\n    const posDiffFromFocalPoint = vec3.create();\n    vec3.sub(posDiffFromFocalPoint, position, focalPoint);\n    const steps = Math.round((max - min) / spacingInNormalDirection);\n    const fraction = (current - min) / (max - min);\n    const floatingStepNumber = fraction * steps;\n    let frameIndex = Math.round(floatingStepNumber);\n    let newFocalPoint = [\n        focalPoint[0] -\n            viewPlaneNormal[0] * floatingStepNumber * spacingInNormalDirection,\n        focalPoint[1] -\n            viewPlaneNormal[1] * floatingStepNumber * spacingInNormalDirection,\n        focalPoint[2] -\n            viewPlaneNormal[2] * floatingStepNumber * spacingInNormalDirection,\n    ];\n    frameIndex += deltaFrames;\n    if (frameIndex > steps) {\n        frameIndex = steps;\n    }\n    else if (frameIndex < 0) {\n        frameIndex = 0;\n    }\n    const newSlicePosFromMin = frameIndex * spacingInNormalDirection;\n    newFocalPoint = [\n        newFocalPoint[0] + viewPlaneNormal[0] * newSlicePosFromMin,\n        newFocalPoint[1] + viewPlaneNormal[1] * newSlicePosFromMin,\n        newFocalPoint[2] + viewPlaneNormal[2] * newSlicePosFromMin,\n    ];\n    const newPosition = [\n        newFocalPoint[0] + posDiffFromFocalPoint[0],\n        newFocalPoint[1] + posDiffFromFocalPoint[1],\n        newFocalPoint[2] + posDiffFromFocalPoint[2],\n    ];\n    return { newFocalPoint, newPosition };\n}\n","import { vec3 } from 'gl-matrix';\nimport * as metaData from '../metaData';\nimport calculateSpacingBetweenImageIds from './calculateSpacingBetweenImageIds';\nexport default function sortImageIdsAndGetSpacing(imageIds, scanAxisNormal) {\n    const { imagePositionPatient: referenceImagePositionPatient, imageOrientationPatient, } = metaData.get('imagePlaneModule', imageIds[0]);\n    if (!scanAxisNormal) {\n        const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n        const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n        scanAxisNormal = vec3.create();\n        vec3.cross(scanAxisNormal, rowCosineVec, colCosineVec);\n    }\n    const usingWadoUri = imageIds[0].split(':')[0] === 'wadouri';\n    const zSpacing = calculateSpacingBetweenImageIds(imageIds);\n    let sortedImageIds;\n    function getDistance(imageId) {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const positionVector = vec3.create();\n        vec3.sub(positionVector, referenceImagePositionPatient, imagePositionPatient);\n        return vec3.dot(positionVector, scanAxisNormal);\n    }\n    if (!usingWadoUri) {\n        const distanceImagePairs = imageIds.map((imageId) => {\n            const distance = getDistance(imageId);\n            return {\n                distance,\n                imageId,\n            };\n        });\n        distanceImagePairs.sort((a, b) => b.distance - a.distance);\n        sortedImageIds = distanceImagePairs.map((a) => a.imageId);\n    }\n    else {\n        const prefetchedImageIds = [\n            imageIds[0],\n            imageIds[Math.floor(imageIds.length / 2)],\n        ];\n        sortedImageIds = imageIds;\n        const firstImageDistance = getDistance(prefetchedImageIds[0]);\n        const middleImageDistance = getDistance(prefetchedImageIds[1]);\n        if (firstImageDistance - middleImageDistance < 0) {\n            sortedImageIds.reverse();\n        }\n    }\n    const { imagePositionPatient: origin } = metaData.get('imagePlaneModule', sortedImageIds[0]);\n    const result = {\n        zSpacing,\n        origin,\n        sortedImageIds,\n    };\n    return result;\n}\n","function getTransferFunctionNodes(transferFunction) {\n    const size = transferFunction.getSize();\n    const values = [];\n    for (let index = 0; index < size; index++) {\n        const nodeValue1 = [];\n        transferFunction.getNodeValue(index, nodeValue1);\n        values.push(nodeValue1);\n    }\n    return values;\n}\nfunction setTransferFunctionNodes(transferFunction, nodes) {\n    if (!nodes?.length) {\n        return;\n    }\n    transferFunction.removeAllPoints();\n    nodes.forEach((node) => {\n        transferFunction.addRGBPoint(...node);\n    });\n}\nexport { getTransferFunctionNodes, setTransferFunctionNodes };\n","import transformWorldToIndex from './transformWorldToIndex';\nexport function transformCanvasToIJK(viewport, canvasPoint) {\n    const { imageData: vtkImageData } = viewport.getImageData();\n    const worldPoint = viewport.canvasToWorld(canvasPoint);\n    return transformWorldToIndex(vtkImageData, worldPoint);\n}\n","export default function transformIndexToWorld(imageData, voxelPos) {\n    return imageData.indexToWorld(voxelPos);\n}\n","export default function transformWorldToIndex(imageData, worldPos) {\n    const continuousIndex = imageData.worldToIndex(worldPos);\n    const index = continuousIndex.map(Math.round);\n    return index;\n}\nexport function transformWorldToIndexContinuous(imageData, worldPos) {\n    return imageData.worldToIndex(worldPos);\n}\n","import { isEqual } from '../utilities/isEqual';\nimport { vec3 } from 'gl-matrix';\nconst ORTHOGONAL_TEST_VALUE = 0.95;\nexport function updatePlaneRestriction(points, reference) {\n    if (!points?.length || !reference.FrameOfReferenceUID) {\n        return;\n    }\n    reference.planeRestriction ||= {\n        FrameOfReferenceUID: reference.FrameOfReferenceUID,\n        point: points[0],\n        inPlaneVector1: null,\n        inPlaneVector2: null,\n    };\n    const { planeRestriction } = reference;\n    if (points.length === 1) {\n        planeRestriction.inPlaneVector1 = null;\n        planeRestriction.inPlaneVector2 = null;\n        return planeRestriction;\n    }\n    const v1 = vec3.sub(vec3.create(), points[0], points[Math.floor(points.length / 2)]);\n    vec3.normalize(v1, v1);\n    planeRestriction.inPlaneVector1 = v1;\n    planeRestriction.inPlaneVector2 = null;\n    const n = points.length;\n    if (n > 2) {\n        for (let i = Math.floor(n / 3); i < n; i++) {\n            const testVector = vec3.sub(vec3.create(), points[i], points[0]);\n            const length = vec3.length(testVector);\n            if (isEqual(length, 0)) {\n                continue;\n            }\n            if (vec3.dot(testVector, planeRestriction.inPlaneVector1) <\n                length * ORTHOGONAL_TEST_VALUE) {\n                vec3.normalize(testVector, testVector);\n                planeRestriction.inPlaneVector2 = testVector;\n                return planeRestriction;\n            }\n        }\n    }\n    return planeRestriction;\n}\n","function updateVTKImageDataWithCornerstoneImage(sourceImageData, image) {\n    const pixelData = image.voxelManager.getScalarData();\n    if (!sourceImageData.getPointData) {\n        return;\n    }\n    const scalarData = sourceImageData\n        .getPointData()\n        .getScalars()\n        .getData();\n    if (image.color && image.rgba) {\n        const newPixelData = new Uint8Array(image.columns * image.rows * 3);\n        for (let i = 0; i < image.columns * image.rows; i++) {\n            newPixelData[i * 3] = pixelData[i * 4];\n            newPixelData[i * 3 + 1] = pixelData[i * 4 + 1];\n            newPixelData[i * 3 + 2] = pixelData[i * 4 + 2];\n        }\n        image.rgba = false;\n        image.getPixelData = () => newPixelData;\n        scalarData.set(newPixelData);\n    }\n    else {\n        scalarData.set(pixelData);\n    }\n    sourceImageData.modified();\n}\nexport { updateVTKImageDataWithCornerstoneImage };\n","import VOILUTFunctionType from '../enums/VOILUTFunctionType';\nimport { logit } from './logit';\nfunction toWindowLevel(low, high) {\n    const windowWidth = Math.abs(high - low) + 1;\n    const windowCenter = (low + high + 1) / 2;\n    return { windowWidth, windowCenter };\n}\nfunction toLowHighRange(windowWidth, windowCenter, voiLUTFunction = VOILUTFunctionType.LINEAR) {\n    if (voiLUTFunction === VOILUTFunctionType.LINEAR ||\n        voiLUTFunction === VOILUTFunctionType.SAMPLED_SIGMOID) {\n        return {\n            lower: windowCenter - 0.5 - (windowWidth - 1) / 2,\n            upper: windowCenter - 0.5 + (windowWidth - 1) / 2,\n        };\n    }\n    else if (voiLUTFunction === VOILUTFunctionType.LINEAR_EXACT) {\n        return {\n            lower: windowCenter - windowWidth / 2,\n            upper: windowCenter + windowWidth / 2,\n        };\n    }\n    else {\n        throw new Error('Invalid VOI LUT function');\n    }\n}\nexport { toWindowLevel, toLowHighRange };\n","import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onCameraModified = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onCameraModified) {\n            tool.onCameraModified(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.CAMERA_MODIFIED, onCameraModified);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onImageSpacingCalibrated = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onImageSpacingCalibrated) {\n            tool.onImageSpacingCalibrated(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.IMAGE_SPACING_CALIBRATED, onImageSpacingCalibrated);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { eventTarget } from '@cornerstonejs/core';\nimport Events from '../enums/Events';\nimport InterpolationManager from '../utilities/segmentation/InterpolationManager/InterpolationManager';\nconst enable = function () {\n    eventTarget.addEventListener(Events.ANNOTATION_COMPLETED, InterpolationManager.handleAnnotationCompleted);\n    eventTarget.addEventListener(Events.ANNOTATION_MODIFIED, InterpolationManager.handleAnnotationUpdate);\n    eventTarget.addEventListener(Events.ANNOTATION_REMOVED, InterpolationManager.handleAnnotationDelete);\n};\nconst disable = function () {\n    eventTarget.removeEventListener(Events.ANNOTATION_COMPLETED, InterpolationManager.handleAnnotationCompleted);\n    eventTarget.removeEventListener(Events.ANNOTATION_MODIFIED, InterpolationManager.handleAnnotationUpdate);\n    eventTarget.removeEventListener(Events.ANNOTATION_REMOVED, InterpolationManager.handleAnnotationDelete);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { Enums } from '@cornerstonejs/core';\nimport { ToolModes } from '../enums';\nimport getToolsWithModesForMouseEvent from './shared/getToolsWithModesForMouseEvent';\nconst { Active, Passive, Enabled } = ToolModes;\nconst onCameraReset = function (evt) {\n    const enabledTools = getToolsWithModesForMouseEvent(evt, [\n        Active,\n        Passive,\n        Enabled,\n    ]);\n    enabledTools.forEach((tool) => {\n        if (tool.onResetCamera) {\n            tool.onResetCamera(evt);\n        }\n    });\n};\nconst enable = function (element) {\n    element.addEventListener(Enums.Events.CAMERA_RESET, onCameraReset);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.CAMERA_RESET, onCameraReset);\n};\nexport default {\n    enable,\n    disable,\n};\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport cameraSyncCallback from '../callbacks/cameraSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createCameraPositionSynchronizer(synchronizerName) {\n    const cameraPositionSynchronizer = createSynchronizer(synchronizerName, CAMERA_MODIFIED, cameraSyncCallback);\n    return cameraPositionSynchronizer;\n}\n","import { Enums } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport presentationViewSyncCallback from '../callbacks/presentationViewSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createPresentationViewSynchronizer(synchronizerName, options) {\n    const presentationView = createSynchronizer(synchronizerName, CAMERA_MODIFIED, presentationViewSyncCallback, { viewPresentation: options });\n    return presentationView;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport zoomPanSyncCallback from '../callbacks/zoomPanSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createZoomPanSynchronizer(synchronizerName) {\n    const zoomPanSynchronizer = createSynchronizer(synchronizerName, CAMERA_MODIFIED, zoomPanSyncCallback);\n    return zoomPanSynchronizer;\n}\n","import { createSynchronizer } from '../../store/SynchronizerManager';\nimport { Enums } from '@cornerstonejs/core';\nimport imageSliceSyncCallback from '../callbacks/imageSliceSyncCallback';\nconst { STACK_NEW_IMAGE, VOLUME_NEW_IMAGE } = Enums.Events;\nexport default function createImageSliceSynchronizer(synchronizerName) {\n    const stackImageSynchronizer = createSynchronizer(synchronizerName, STACK_NEW_IMAGE, imageSliceSyncCallback, {\n        auxiliaryEvents: [\n            {\n                name: 'VOLUME_NEW_IMAGE',\n            },\n        ],\n    });\n    return stackImageSynchronizer;\n}\n","import { Enums } from '@cornerstonejs/core';\nimport { createSynchronizer } from '../../store/SynchronizerManager';\nimport slabThicknessSyncCallback from '../callbacks/slabThicknessSyncCallback';\nconst { CAMERA_MODIFIED } = Enums.Events;\nexport default function createPresentationViewSynchronizer(synchronizerName) {\n    const presentationView = createSynchronizer(synchronizerName, CAMERA_MODIFIED, slabThicknessSyncCallback);\n    return presentationView;\n}\n","import { utilities, Enums } from '@cornerstonejs/core';\nconst { calibratedPixelSpacingMetadataProvider } = utilities;\nexport default function calibrateImageSpacing(imageId, renderingEngine, calibrationOrScale) {\n    if (typeof calibrationOrScale === 'number') {\n        calibrationOrScale = {\n            type: Enums.CalibrationTypes.USER,\n            scale: calibrationOrScale,\n        };\n    }\n    calibratedPixelSpacingMetadataProvider.add(imageId, calibrationOrScale);\n    const viewports = renderingEngine.getStackViewports();\n    viewports.forEach((viewport) => {\n        const imageIds = viewport.getImageIds();\n        if (imageIds.includes(imageId)) {\n            viewport.calibrateSpacing(imageId);\n        }\n    });\n}\n","var Events;\n(function (Events) {\n    Events[\"CLIP_STOPPED\"] = \"CORNERSTONE_CINE_TOOL_STOPPED\";\n    Events[\"CLIP_STARTED\"] = \"CORNERSTONE_CINE_TOOL_STARTED\";\n})(Events || (Events = {}));\nexport default Events;\n","import { glMatrix, vec3 } from 'gl-matrix';\nimport { utilities as csUtils, getEnabledElement, StackViewport, VideoViewport, VolumeViewport, cache, BaseVolumeViewport, Enums, } from '@cornerstonejs/core';\nimport CINE_EVENTS from './events';\nimport { addToolState, getToolState, getToolStateByViewportId } from './state';\nconst { ViewportStatus } = Enums;\nconst { triggerEvent } = csUtils;\nconst debounced = true;\nconst dynamicVolumesPlayingMap = new Map();\nfunction playClip(element, playClipOptions) {\n    let playClipTimeouts;\n    let playClipIsTimeVarying;\n    if (element === undefined) {\n        throw new Error('playClip: element must not be undefined');\n    }\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        throw new Error('playClip: element must be a valid Cornerstone enabled element');\n    }\n    if (!playClipOptions) {\n        playClipOptions = {};\n    }\n    playClipOptions.dynamicCineEnabled =\n        playClipOptions.dynamicCineEnabled ?? true;\n    const { viewport } = enabledElement;\n    const playClipContext = _createCinePlayContext(viewport, playClipOptions);\n    let playClipData = getToolState(element);\n    const isDynamicCinePlaying = playClipOptions.dynamicCineEnabled;\n    if (isDynamicCinePlaying) {\n        _stopDynamicVolumeCine(element);\n    }\n    if (!playClipData) {\n        playClipData = {\n            intervalId: undefined,\n            framesPerSecond: 30,\n            lastFrameTimeStamp: undefined,\n            ignoreFrameTimeVector: false,\n            usingFrameTimeVector: false,\n            frameTimeVector: playClipOptions.frameTimeVector ?? undefined,\n            speed: playClipOptions.frameTimeVectorSpeedMultiplier ?? 1,\n            reverse: playClipOptions.reverse ?? false,\n            loop: playClipOptions.loop ?? true,\n            bounce: playClipOptions.bounce ?? false,\n        };\n        addToolState(element, playClipData);\n    }\n    else {\n        _stopClip(element, {\n            stopDynamicCine: !isDynamicCinePlaying,\n            viewportId: viewport.id,\n        });\n    }\n    playClipData.dynamicCineEnabled = playClipOptions.dynamicCineEnabled;\n    if (playClipOptions.framesPerSecond < 0 ||\n        playClipOptions.framesPerSecond > 0) {\n        playClipData.framesPerSecond = Number(playClipOptions.framesPerSecond);\n        playClipData.reverse = playClipData.framesPerSecond < 0;\n        playClipData.ignoreFrameTimeVector = true;\n    }\n    if (playClipData.ignoreFrameTimeVector !== true &&\n        playClipData.frameTimeVector &&\n        playClipData.frameTimeVector.length === playClipContext.numScrollSteps &&\n        playClipContext.frameTimeVectorEnabled) {\n        const { timeouts, isTimeVarying } = _getPlayClipTimeouts(playClipData.frameTimeVector, playClipData.speed);\n        playClipTimeouts = timeouts;\n        playClipIsTimeVarying = isTimeVarying;\n    }\n    if (playClipOptions.bounce !== undefined) {\n        playClipData.bounce = playClipOptions.bounce;\n    }\n    const playClipAction = () => {\n        const { numScrollSteps, currentStepIndex } = playClipContext;\n        let newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n        const outOfRange = newStepIndex < 0 || newStepIndex >= numScrollSteps;\n        if (outOfRange) {\n            if (playClipData.bounce) {\n                playClipData.reverse = !playClipData.reverse;\n                newStepIndex = currentStepIndex + (playClipData.reverse ? -1 : 1);\n                newStepIndex = Math.max(0, Math.min(numScrollSteps - 1, newStepIndex));\n            }\n            else if (!playClipData.loop) {\n                _stopClip(element, {\n                    stopDynamicCine: !isDynamicCinePlaying,\n                    viewportId: viewport.id,\n                });\n                triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, { element });\n                return;\n            }\n            else {\n                newStepIndex = playClipData.reverse ? numScrollSteps - 1 : 0;\n            }\n        }\n        const delta = newStepIndex - currentStepIndex;\n        if (delta) {\n            try {\n                playClipContext.scroll(delta);\n            }\n            catch (e) {\n                console.warn('Play clip not scrolling', e);\n                _stopClipWithData(playClipData);\n                triggerEvent(element, CINE_EVENTS.CLIP_STOPPED, { element });\n            }\n        }\n    };\n    if (isDynamicCinePlaying) {\n        const volume = _getVolumeFromViewport(viewport);\n        if (volume) {\n            dynamicVolumesPlayingMap.set(volume.volumeId, element);\n        }\n    }\n    if (playClipContext.play) {\n        playClipData.framesPerSecond = playClipContext.play(playClipOptions.framesPerSecond);\n    }\n    else if (playClipTimeouts &&\n        playClipTimeouts.length > 0 &&\n        playClipIsTimeVarying) {\n        playClipData.usingFrameTimeVector = true;\n        playClipData.intervalId = window.setTimeout(function playClipTimeoutHandler() {\n            playClipData.intervalId = window.setTimeout(playClipTimeoutHandler, playClipTimeouts[playClipContext.currentStepIndex]);\n            playClipAction();\n        }, 0);\n    }\n    else {\n        playClipData.usingFrameTimeVector = false;\n        playClipData.intervalId = window.setInterval(playClipAction, 1000 / Math.abs(playClipData.framesPerSecond));\n    }\n    const eventDetail = {\n        element,\n    };\n    triggerEvent(element, CINE_EVENTS.CLIP_STARTED, eventDetail);\n}\nfunction stopClip(element, options = {}) {\n    _stopClip(element, {\n        stopDynamicCine: true,\n        ...options,\n    });\n}\nfunction _stopClip(element, options = { stopDynamicCine: true, viewportId: undefined }) {\n    const { stopDynamicCine, viewportId } = options;\n    const enabledElement = getEnabledElement(element);\n    let toolState;\n    const viewport = enabledElement?.viewport;\n    if (!enabledElement) {\n        if (viewportId) {\n            toolState = getToolStateByViewportId(viewportId);\n        }\n        else {\n            return;\n        }\n    }\n    else {\n        const { viewport } = enabledElement;\n        toolState = getToolState(viewport.element);\n    }\n    if (toolState) {\n        _stopClipWithData(toolState);\n    }\n    if (viewport instanceof VideoViewport) {\n        viewport.pause();\n    }\n    else if (stopDynamicCine && viewport instanceof BaseVolumeViewport) {\n        _stopDynamicVolumeCine(element);\n    }\n}\nfunction _stopDynamicVolumeCine(element) {\n    const { viewport } = getEnabledElement(element);\n    if (viewport instanceof VolumeViewport) {\n        const volume = _getVolumeFromViewport(viewport);\n        if (volume?.isDynamicVolume()) {\n            const dynamicCineElement = dynamicVolumesPlayingMap.get(volume.volumeId);\n            dynamicVolumesPlayingMap.delete(volume.volumeId);\n            if (dynamicCineElement && dynamicCineElement !== element) {\n                stopClip(dynamicCineElement);\n            }\n        }\n    }\n}\nfunction _getPlayClipTimeouts(vector, speed) {\n    let i;\n    let sample;\n    let delay;\n    let sum = 0;\n    const limit = vector.length;\n    const timeouts = [];\n    let isTimeVarying = false;\n    if (typeof speed !== 'number' || speed <= 0) {\n        speed = 1;\n    }\n    for (i = 1; i < limit; i++) {\n        delay = (Number(vector[i]) / speed) | 0;\n        timeouts.push(delay);\n        if (i === 1) {\n            sample = delay;\n        }\n        else if (delay !== sample) {\n            isTimeVarying = true;\n        }\n        sum += delay;\n    }\n    if (timeouts.length > 0) {\n        if (isTimeVarying) {\n            delay = (sum / timeouts.length) | 0;\n        }\n        else {\n            delay = timeouts[0];\n        }\n        timeouts.push(delay);\n    }\n    return { timeouts, isTimeVarying };\n}\nfunction _stopClipWithData(playClipData) {\n    const id = playClipData.intervalId;\n    if (typeof id !== 'undefined') {\n        playClipData.intervalId = undefined;\n        if (playClipData.usingFrameTimeVector) {\n            clearTimeout(id);\n        }\n        else {\n            clearInterval(id);\n        }\n    }\n}\nfunction _getVolumeFromViewport(viewport) {\n    if (!(viewport instanceof VolumeViewport)) {\n        return undefined;\n    }\n    const volumeIds = viewport.getAllVolumeIds();\n    if (!volumeIds?.length) {\n        return undefined;\n    }\n    const dynamicVolumeId = volumeIds.find((volumeId) => cache.getVolume(volumeId)?.isDynamicVolume());\n    const volumeId = dynamicVolumeId ?? volumeIds[0];\n    return cache.getVolume(volumeId);\n}\nfunction _createStackViewportCinePlayContext(viewport, waitForRendered) {\n    const imageIds = viewport.getImageIds();\n    return {\n        get numScrollSteps() {\n            return imageIds.length;\n        },\n        get currentStepIndex() {\n            return viewport.getTargetImageIdIndex();\n        },\n        get frameTimeVectorEnabled() {\n            return true;\n        },\n        waitForRenderedCount: 0,\n        scroll(delta) {\n            if (this.waitForRenderedCount <= waitForRendered &&\n                viewport.viewportStatus !== ViewportStatus.RENDERED) {\n                this.waitForRenderedCount++;\n                return;\n            }\n            this.waitForRenderedCount = 0;\n            csUtils.scroll(viewport, { delta, debounceLoading: debounced });\n        },\n    };\n}\nfunction _createVideoViewportCinePlayContext(viewport, waitForRendered) {\n    return {\n        get numScrollSteps() {\n            return viewport.getNumberOfSlices();\n        },\n        get currentStepIndex() {\n            return viewport.getSliceIndex();\n        },\n        get frameTimeVectorEnabled() {\n            return true;\n        },\n        waitForRenderedCount: 0,\n        scroll(delta) {\n            if (this.waitForRenderedCount <= waitForRendered &&\n                viewport.viewportStatus !== ViewportStatus.RENDERED) {\n                this.waitForRenderedCount++;\n                return;\n            }\n            this.waitForRenderedCount = 0;\n            csUtils.scroll(viewport, { delta, debounceLoading: debounced });\n        },\n        play(fps) {\n            if (fps) {\n                viewport.setPlaybackRate(fps / 24);\n            }\n            viewport.play();\n            return viewport.getFrameRate();\n        },\n    };\n}\nfunction _createVolumeViewportCinePlayContext(viewport, volume) {\n    const { volumeId } = volume;\n    const cachedScrollInfo = {\n        viewPlaneNormal: vec3.create(),\n        scrollInfo: null,\n    };\n    const getScrollInfo = () => {\n        const camera = viewport.getCamera();\n        const updateCache = !cachedScrollInfo.scrollInfo ||\n            !vec3.equals(camera.viewPlaneNormal, cachedScrollInfo.viewPlaneNormal);\n        if (updateCache) {\n            const scrollInfo = csUtils.getVolumeViewportScrollInfo(viewport, volumeId);\n            cachedScrollInfo.viewPlaneNormal = camera.viewPlaneNormal;\n            cachedScrollInfo.scrollInfo = scrollInfo;\n        }\n        return cachedScrollInfo.scrollInfo;\n    };\n    return {\n        get numScrollSteps() {\n            return getScrollInfo().numScrollSteps;\n        },\n        get currentStepIndex() {\n            return getScrollInfo().currentStepIndex;\n        },\n        get frameTimeVectorEnabled() {\n            const camera = viewport.getCamera();\n            const volumeViewPlaneNormal = volume.direction\n                .slice(6, 9)\n                .map((x) => -x);\n            const dot = vec3.dot(volumeViewPlaneNormal, camera.viewPlaneNormal);\n            return glMatrix.equals(dot, 1);\n        },\n        scroll(delta) {\n            getScrollInfo().currentStepIndex += delta;\n            csUtils.scroll(viewport, { delta });\n        },\n    };\n}\nfunction _createDynamicVolumeViewportCinePlayContext(volume) {\n    return {\n        get numScrollSteps() {\n            return volume.numDimensionGroups;\n        },\n        get currentStepIndex() {\n            return volume.dimensionGroupNumber - 1;\n        },\n        get frameTimeVectorEnabled() {\n            return false;\n        },\n        scroll(delta) {\n            volume.scroll(delta);\n        },\n    };\n}\nfunction _createCinePlayContext(viewport, playClipOptions) {\n    if (viewport instanceof StackViewport) {\n        return _createStackViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);\n    }\n    if (viewport instanceof VolumeViewport) {\n        const volume = _getVolumeFromViewport(viewport);\n        if (playClipOptions.dynamicCineEnabled && volume?.isDynamicVolume()) {\n            return _createDynamicVolumeViewportCinePlayContext(volume);\n        }\n        return _createVolumeViewportCinePlayContext(viewport, volume);\n    }\n    if (viewport instanceof VideoViewport) {\n        return _createVideoViewportCinePlayContext(viewport, playClipOptions.waitForRendered ?? 30);\n    }\n    throw new Error('Unknown viewport type');\n}\nexport { playClip, stopClip };\n","import smoothAnnotation from './smoothAnnotation';\nexport default {\n    smoothAnnotation,\n};\nexport { smoothAnnotation };\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nconst { isEqual } = csUtils;\nconst iAxis = vec3.fromValues(1, 0, 0);\nconst jAxis = vec3.fromValues(0, 1, 0);\nconst kAxis = vec3.fromValues(0, 0, 1);\nconst axisList = [iAxis, jAxis, kAxis];\nfunction isAxisAlignedRectangle(rectangleCornersIJK) {\n    const rectangleVec1 = vec3.subtract(vec3.create(), rectangleCornersIJK[0], rectangleCornersIJK[1]);\n    const rectangleVec2 = vec3.subtract(vec3.create(), rectangleCornersIJK[0], rectangleCornersIJK[2]);\n    const anglesVec1 = calculateAnglesWithAxes(rectangleVec1, axisList);\n    const anglesVec2 = calculateAnglesWithAxes(rectangleVec2, axisList);\n    const isAligned = [...anglesVec1, ...anglesVec2].every((angle) => isEqual(angle, 0) ||\n        isEqual(angle, 90) ||\n        isEqual(angle, 180) ||\n        isEqual(angle, 270));\n    return isAligned;\n}\nfunction calculateAnglesWithAxes(vec, axes) {\n    return axes.map((axis) => (vec3.angle(vec, axis) * 180) / Math.PI);\n}\nexport { isAxisAlignedRectangle };\n","import { imageLoader, Enums, eventTarget, imageLoadPoolManager, cache, metaData, utilities, triggerEvent, } from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport { getStackData, requestType, priority, getPromiseRemovedHandler, nearestIndex, range, } from './stackPrefetchUtils';\nimport { Events } from '../../enums';\nconst { imageRetrieveMetadataProvider } = utilities;\nlet configuration = {\n    maxImagesToPrefetch: Infinity,\n    preserveExistingPool: true,\n};\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 10;\nfunction prefetch(element) {\n    const stackPrefetchData = getToolState(element);\n    if (!stackPrefetchData) {\n        return;\n    }\n    const stackPrefetch = (stackPrefetchData || {});\n    const stack = getStackData(element);\n    if (!stack?.imageIds?.length) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    const { currentImageIdIndex } = stack;\n    stackPrefetch.enabled =\n        stackPrefetch.enabled && (stackPrefetch.indicesToRequest?.length ?? 0) > 0;\n    if (stackPrefetch.enabled === false) {\n        return;\n    }\n    function removeFromList(imageIdIndex) {\n        const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n        if (index > -1) {\n            stackPrefetch.indicesToRequest.splice(index, 1);\n        }\n    }\n    stackPrefetchData.indicesToRequest.sort((a, b) => a - b);\n    const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n    indicesToRequestCopy.forEach(function (imageIdIndex) {\n        const imageId = stack.imageIds[imageIdIndex];\n        if (!imageId) {\n            return;\n        }\n        const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n        const imageCached = distance < 6\n            ? cache.getImageLoadObject(imageId)\n            : cache.isLoaded(imageId);\n        if (imageCached) {\n            removeFromList(imageIdIndex);\n        }\n    });\n    if (!stackPrefetch.indicesToRequest.length) {\n        return;\n    }\n    if (!configuration.preserveExistingPool) {\n        imageLoadPoolManager.clearRequestStack(requestType);\n    }\n    const nearest = nearestIndex(stackPrefetch.indicesToRequest, stack.currentImageIdIndex);\n    let imageId;\n    let nextImageIdIndex;\n    const preventCache = false;\n    function doneCallback(imageId) {\n        console.log('prefetch done: %s', imageId);\n        const imageIdIndex = stack.imageIds.indexOf(imageId);\n        removeFromList(imageIdIndex);\n        if (stackPrefetch.indicesToRequest.length === 0) {\n            const eventDetail = {\n                element: element,\n                lastPrefetchedImageId: imageId,\n            };\n            triggerEvent(eventTarget, Events.STACK_PREFETCH_COMPLETE, eventDetail);\n        }\n    }\n    let lowerIndex = nearest.low;\n    let higherIndex = nearest.high;\n    const imageIdsToPrefetch = [];\n    while (lowerIndex >= 0 ||\n        higherIndex < stackPrefetch.indicesToRequest.length) {\n        const currentIndex = stack.currentImageIdIndex;\n        const shouldSkipLower = currentIndex - stackPrefetch.indicesToRequest[lowerIndex] >\n            configuration.maxImagesToPrefetch;\n        const shouldSkipHigher = stackPrefetch.indicesToRequest[higherIndex] - currentIndex >\n            configuration.maxImagesToPrefetch;\n        const shouldLoadLower = !shouldSkipLower && lowerIndex >= 0;\n        const shouldLoadHigher = !shouldSkipHigher && higherIndex < stackPrefetch.indicesToRequest.length;\n        if (!shouldLoadHigher && !shouldLoadLower) {\n            break;\n        }\n        if (shouldLoadLower) {\n            nextImageIdIndex = stackPrefetch.indicesToRequest[lowerIndex--];\n            imageId = stack.imageIds[nextImageIdIndex];\n            imageIdsToPrefetch.push(imageId);\n        }\n        if (shouldLoadHigher) {\n            nextImageIdIndex = stackPrefetch.indicesToRequest[higherIndex++];\n            imageId = stack.imageIds[nextImageIdIndex];\n            imageIdsToPrefetch.push(imageId);\n        }\n    }\n    const requestFn = (imageId, options) => {\n        const { retrieveOptions = {} } = metaData.get(imageRetrieveMetadataProvider.IMAGE_RETRIEVE_CONFIGURATION, imageId, 'stack') || {};\n        options.retrieveOptions = {\n            ...options.retrieveOptions,\n            ...(retrieveOptions.default || Object.values(retrieveOptions)?.[0] || {}),\n        };\n        return imageLoader\n            .loadAndCacheImage(imageId, options)\n            .then(() => doneCallback(imageId));\n    };\n    imageIdsToPrefetch.forEach((imageId) => {\n        const options = {\n            requestType,\n        };\n        imageLoadPoolManager.addRequest(requestFn.bind(null, imageId, options), requestType, {\n            imageId,\n        }, priority);\n    });\n}\nfunction onImageUpdated(e) {\n    clearTimeout(resetPrefetchTimeout);\n    resetPrefetchTimeout = setTimeout(function () {\n        const element = e.target;\n        try {\n            prefetch(element);\n        }\n        catch (error) {\n            return;\n        }\n    }, resetPrefetchDelay);\n}\nfunction enable(element) {\n    const stack = getStackData(element);\n    if (!stack || !stack.imageIds || stack.imageIds.length === 0) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    const stackPrefetchData = {\n        indicesToRequest: range(0, stack.imageIds.length - 1),\n        enabled: true,\n        direction: 1,\n    };\n    const indexOfCurrentImage = stackPrefetchData.indicesToRequest.indexOf(stack.currentImageIdIndex);\n    stackPrefetchData.indicesToRequest.splice(indexOfCurrentImage, 1);\n    addToolState(element, stackPrefetchData);\n    prefetch(element);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    eventTarget.addEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n}\nfunction disable(element) {\n    clearTimeout(resetPrefetchTimeout);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    const stackPrefetchData = getToolState(element);\n    if (stackPrefetchData && stackPrefetchData.indicesToRequest.length) {\n        stackPrefetchData.enabled = false;\n        imageLoadPoolManager.clearRequestStack(requestType);\n    }\n}\nfunction getConfiguration() {\n    return configuration;\n}\nfunction setConfiguration(config) {\n    configuration = config;\n}\nconst stackPrefetch = { enable, disable, getConfiguration, setConfiguration };\nexport default stackPrefetch;\n","import { imageLoader, Enums, eventTarget, imageLoadPoolManager, cache, metaData, utilities, triggerEvent, } from '@cornerstonejs/core';\nimport { addToolState, getToolState } from './state';\nimport { getStackData, requestType, clearFromImageIds, getPromiseRemovedHandler, } from './stackPrefetchUtils';\nimport { Events } from '../../enums';\nconst { imageRetrieveMetadataProvider } = utilities;\nlet configuration = {\n    maxImagesToPrefetch: Infinity,\n    minBefore: 2,\n    maxAfter: 2,\n    directionExtraImages: 10,\n    preserveExistingPool: false,\n};\nlet resetPrefetchTimeout;\nconst resetPrefetchDelay = 5;\nconst priorities = {};\nconst enable = (element, priority = 0) => {\n    const stack = getStackData(element);\n    if (!stack) {\n        return;\n    }\n    if (!stack.imageIds?.length) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    updateToolState(element);\n    priorities[element] = priority;\n    prefetch(element, priority);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    element.addEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    eventTarget.addEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n};\nfunction prefetch(element, priority = 0) {\n    const stack = getStackData(element);\n    if (!stack) {\n        return;\n    }\n    if (!stack?.imageIds?.length) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    const stackPrefetchData = getToolState(element);\n    if (!stackPrefetchData) {\n        return;\n    }\n    const stackPrefetch = (stackPrefetchData || {});\n    stackPrefetch.enabled =\n        stackPrefetch.enabled && (stackPrefetch.indicesToRequest?.length ?? 0) > 0;\n    if (stackPrefetch.enabled === false) {\n        return;\n    }\n    function removeFromList(imageIdIndex) {\n        const index = stackPrefetch.indicesToRequest.indexOf(imageIdIndex);\n        if (index > -1) {\n            stackPrefetch.indicesToRequest.splice(index, 1);\n        }\n    }\n    const indicesToRequestCopy = stackPrefetch.indicesToRequest.slice();\n    const { currentImageIdIndex } = stack;\n    indicesToRequestCopy.forEach((imageIdIndex) => {\n        const imageId = stack.imageIds[imageIdIndex];\n        if (!imageId) {\n            return;\n        }\n        const distance = Math.abs(currentImageIdIndex - imageIdIndex);\n        const imageCached = distance < 6\n            ? cache.getImageLoadObject(imageId)\n            : cache.isLoaded(imageId);\n        if (imageCached) {\n            removeFromList(imageIdIndex);\n        }\n    });\n    if (!stackPrefetch.indicesToRequest.length) {\n        return;\n    }\n    if (!configuration.preserveExistingPool) {\n        imageLoadPoolManager.filterRequests(clearFromImageIds(stack));\n    }\n    function doneCallback(imageId) {\n        const imageIdIndex = stack.imageIds.indexOf(imageId);\n        removeFromList(imageIdIndex);\n        const image = cache.getCachedImageBasedOnImageURI(imageId);\n        const { stats } = stackPrefetch;\n        const decodeTimeInMS = image?.image?.decodeTimeInMS || 0;\n        if (decodeTimeInMS) {\n            stats.imageIds.set(imageId, decodeTimeInMS);\n            stats.decodeTimeInMS += decodeTimeInMS;\n            const loadTimeInMS = image?.image?.loadTimeInMS || 0;\n            stats.loadTimeInMS += loadTimeInMS;\n        }\n        if (!stackPrefetch.indicesToRequest.length) {\n            if (image?.sizeInBytes) {\n                const { sizeInBytes } = image;\n                const usage = cache.getMaxCacheSize() / 4 / sizeInBytes;\n                if (!stackPrefetch.cacheFill) {\n                    stats.initialTime = Date.now() - stats.start;\n                    stats.initialSize = stats.imageIds.size;\n                    updateToolState(element, usage);\n                    prefetch(element, priority);\n                }\n                else if (stats.imageIds.size) {\n                    stats.fillTime = Date.now() - stats.start;\n                    const { size } = stats.imageIds;\n                    stats.fillSize = size;\n                }\n            }\n        }\n        if (stackPrefetch.indicesToRequest.length === 0) {\n            const eventDetail = {\n                element: element,\n                lastPrefetchedImageId: imageId,\n            };\n            triggerEvent(eventTarget, Events.STACK_PREFETCH_COMPLETE, eventDetail);\n        }\n    }\n    const requestFn = (imageId, options) => {\n        const { retrieveOptions = {} } = metaData.get(imageRetrieveMetadataProvider.IMAGE_RETRIEVE_CONFIGURATION, imageId, 'stack') || {};\n        options.retrieveOptions = {\n            ...options.retrieveOptions,\n            ...(retrieveOptions.default || Object.values(retrieveOptions)?.[0] || {}),\n        };\n        return imageLoader\n            .loadAndCacheImage(imageId, options)\n            .then(() => doneCallback(imageId));\n    };\n    stackPrefetch.indicesToRequest.forEach((imageIdIndex) => {\n        const imageId = stack.imageIds[imageIdIndex];\n        const options = {\n            requestType,\n        };\n        imageLoadPoolManager.addRequest(requestFn.bind(null, imageId, options), requestType, {\n            imageId,\n        }, priority);\n    });\n}\nfunction onImageUpdated(e) {\n    clearTimeout(resetPrefetchTimeout);\n    resetPrefetchTimeout = setTimeout(function () {\n        const element = e.target;\n        try {\n            updateToolState(element);\n            prefetch(element, priorities[element]);\n        }\n        catch (error) {\n            return;\n        }\n    }, resetPrefetchDelay);\n}\nconst signum = (x) => (x < 0 ? -1 : 1);\nconst updateToolState = (element, usage) => {\n    const stack = getStackData(element);\n    if (!stack) {\n        return;\n    }\n    if (!stack.imageIds?.length) {\n        console.warn('CornerstoneTools.stackPrefetch: No images in stack.');\n        return;\n    }\n    const { currentImageIdIndex } = stack;\n    let { maxAfter = 2, minBefore = 2 } = configuration;\n    const { directionExtraImages = 10 } = configuration;\n    const stackPrefetchData = getToolState(element) ||\n        {\n            indicesToRequest: [],\n            currentImageIdIndex,\n            stackCount: 0,\n            enabled: true,\n            direction: 1,\n            stats: {\n                start: Date.now(),\n                imageIds: new Map(),\n                decodeTimeInMS: 0,\n                loadTimeInMS: 0,\n                totalBytes: 0,\n            },\n        };\n    const delta = currentImageIdIndex - stackPrefetchData.currentImageIdIndex;\n    stackPrefetchData.direction = signum(delta);\n    stackPrefetchData.currentImageIdIndex = currentImageIdIndex;\n    stackPrefetchData.enabled = true;\n    if (stackPrefetchData.stackCount < 100) {\n        stackPrefetchData.stackCount += directionExtraImages;\n    }\n    if (Math.abs(delta) > maxAfter || !delta) {\n        stackPrefetchData.stackCount = 0;\n        if (usage) {\n            const positionFraction = currentImageIdIndex / stack.imageIds.length;\n            minBefore = Math.ceil(usage * positionFraction);\n            maxAfter = Math.ceil(usage * (1 - positionFraction));\n            stackPrefetchData.cacheFill = true;\n        }\n        else {\n            stackPrefetchData.cacheFill = false;\n        }\n    }\n    else if (delta < 0) {\n        minBefore += stackPrefetchData.stackCount;\n        maxAfter = 0;\n    }\n    else {\n        maxAfter += stackPrefetchData.stackCount;\n        minBefore = 0;\n    }\n    const minIndex = Math.max(0, currentImageIdIndex - minBefore);\n    const maxIndex = Math.min(stack.imageIds.length - 1, currentImageIdIndex + maxAfter);\n    const indicesToRequest = [];\n    for (let i = currentImageIdIndex + 1; i <= maxIndex; i++) {\n        indicesToRequest.push(i);\n    }\n    for (let i = currentImageIdIndex - 1; i >= minIndex; i--) {\n        indicesToRequest.push(i);\n    }\n    stackPrefetchData.indicesToRequest = indicesToRequest;\n    addToolState(element, stackPrefetchData);\n};\nfunction disable(element) {\n    clearTimeout(resetPrefetchTimeout);\n    element.removeEventListener(Enums.Events.STACK_NEW_IMAGE, onImageUpdated);\n    const promiseRemovedHandler = getPromiseRemovedHandler(element);\n    eventTarget.removeEventListener(Enums.Events.IMAGE_CACHE_IMAGE_REMOVED, promiseRemovedHandler);\n    const stackPrefetchData = getToolState(element);\n    if (stackPrefetchData) {\n        stackPrefetchData.enabled = false;\n    }\n}\nfunction getConfiguration() {\n    return configuration;\n}\nfunction setConfiguration(config) {\n    configuration = config;\n}\nconst stackContextPrefetch = {\n    enable,\n    disable,\n    getConfiguration,\n    setConfiguration,\n};\nexport default stackContextPrefetch;\n","import { Enums } from '@cornerstonejs/core';\nfunction sumOverDimensionGroups(voxelManager, dimensionGroups) {\n    const arrayLength = voxelManager.getScalarDataLength();\n    const resultArray = new Float32Array(arrayLength);\n    for (const dimensionGroupNumber of dimensionGroups) {\n        const scalarData = voxelManager.getDimensionGroupScalarData(dimensionGroupNumber);\n        for (let i = 0; i < arrayLength; i++) {\n            resultArray[i] += scalarData[i];\n        }\n    }\n    return resultArray;\n}\nfunction averageOverDimensionGroups(voxelManager, dimensionGroups) {\n    const sumArray = sumOverDimensionGroups(voxelManager, dimensionGroups);\n    const numDimensionGroups = dimensionGroups.length;\n    for (let i = 0; i < sumArray.length; i++) {\n        sumArray[i] /= numDimensionGroups;\n    }\n    return sumArray;\n}\nconst operationFunctions = {\n    [Enums.GenerateImageType.SUM]: (voxelManager, dimensionGroups, callback) => {\n        const resultArray = sumOverDimensionGroups(voxelManager, dimensionGroups);\n        for (let i = 0; i < resultArray.length; i++) {\n            callback(i, resultArray[i]);\n        }\n    },\n    [Enums.GenerateImageType.AVERAGE]: (voxelManager, dimensionGroups, callback) => {\n        const resultArray = averageOverDimensionGroups(voxelManager, dimensionGroups);\n        for (let i = 0; i < resultArray.length; i++) {\n            callback(i, resultArray[i]);\n        }\n    },\n    [Enums.GenerateImageType.SUBTRACT]: (voxelManager, dimensionGroups, callback) => {\n        if (dimensionGroups.length !== 2) {\n            throw new Error('Please provide only 2 dimension groups for subtraction.');\n        }\n        const arrayLength = voxelManager.getScalarDataLength();\n        const scalarData1 = voxelManager.getDimensionGroupScalarData(dimensionGroups[0]);\n        const scalarData2 = voxelManager.getDimensionGroupScalarData(dimensionGroups[1]);\n        for (let i = 0; i < arrayLength; i++) {\n            const difference = scalarData1[i] - scalarData2[i];\n            callback(i, difference);\n        }\n    },\n};\nfunction generateImageFromTimeData(dynamicVolume, operation, options) {\n    const { dimensionGroupNumbers, frameNumbers } = options;\n    if (frameNumbers) {\n        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');\n    }\n    const dimensionGroups = dimensionGroupNumbers ||\n        frameNumbers ||\n        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);\n    if (dimensionGroups.length <= 1) {\n        throw new Error('Please provide two or more dimension groups');\n    }\n    const voxelManager = dynamicVolume.voxelManager;\n    const arrayLength = voxelManager.getScalarDataLength();\n    const operationFunction = operationFunctions[operation];\n    if (!operationFunction) {\n        throw new Error(`Unsupported operation: ${operation}`);\n    }\n    const resultArray = new Float32Array(arrayLength);\n    operationFunction(voxelManager, dimensionGroups, (index, value) => {\n        resultArray[index] = value;\n    });\n    return resultArray;\n}\nfunction updateVolumeFromTimeData(dynamicVolume, operation, options) {\n    const { dimensionGroupNumbers, frameNumbers, targetVolume } = options;\n    if (!targetVolume) {\n        throw new Error('A target volume must be provided');\n    }\n    if (frameNumbers) {\n        console.warn('Warning: frameNumbers parameter is deprecated. Please use dimensionGroupNumbers instead.');\n    }\n    const dimensionGroups = dimensionGroupNumbers ||\n        frameNumbers ||\n        Array.from({ length: dynamicVolume.numDimensionGroups }, (_, i) => i + 1);\n    if (dimensionGroups.length <= 1) {\n        throw new Error('Please provide two or more dimension groups');\n    }\n    const voxelManager = dynamicVolume.voxelManager;\n    const targetVoxelManager = targetVolume.voxelManager;\n    const operationFunction = operationFunctions[operation];\n    if (!operationFunction) {\n        throw new Error(`Unsupported operation: ${operation}`);\n    }\n    operationFunction(voxelManager, dimensionGroups, (index, value) => {\n        targetVoxelManager.setAtIndex(index, value);\n    });\n    targetVoxelManager.resetModifiedSlices();\n    for (let k = 0; k < targetVolume.dimensions[2]; k++) {\n        targetVoxelManager.modifiedSlices.add(k);\n    }\n}\nexport { generateImageFromTimeData, updateVolumeFromTimeData };\n","import { vec3 } from 'gl-matrix';\nexport function getPoint(points, idx) {\n    const idx3 = idx * 3;\n    if (idx3 < points.length) {\n        return vec3.fromValues(points[idx3], points[idx3 + 1], points[idx3 + 2]);\n    }\n}\nexport function getPolyDataPointIndexes(polyData) {\n    const linesData = polyData.getLines().getData();\n    let idx = 0;\n    const lineSegments = new Map();\n    while (idx < linesData.length) {\n        const segmentSize = linesData[idx++];\n        const segment = [];\n        for (let i = 0; i < segmentSize; i++) {\n            segment.push(linesData[idx + i]);\n        }\n        lineSegments.set(segment[0], segment);\n        idx += segmentSize;\n    }\n    const contours = [];\n    const findStartingPoint = (map) => {\n        for (const [key, value] of map.entries()) {\n            if (value !== undefined) {\n                return key;\n            }\n        }\n        return -1;\n    };\n    let startPoint = findStartingPoint(lineSegments);\n    while (startPoint !== -1) {\n        const contour = [startPoint];\n        while (lineSegments.has(startPoint)) {\n            const nextPoint = lineSegments.get(startPoint)[1];\n            if (lineSegments.has(nextPoint)) {\n                contour.push(nextPoint);\n            }\n            lineSegments.delete(startPoint);\n            startPoint = nextPoint;\n        }\n        contours.push(contour);\n        startPoint = findStartingPoint(lineSegments);\n    }\n    return contours.length ? contours : undefined;\n}\nexport function getPolyDataPoints(polyData) {\n    const contoursIndexes = getPolyDataPointIndexes(polyData);\n    if (!contoursIndexes) {\n        return;\n    }\n    const rawPointsData = polyData.getPoints().getData();\n    return contoursIndexes.map((contourIndexes) => contourIndexes.map((index) => getPoint(rawPointsData, index)));\n}\n","import { vec2 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { isRangeValid, areColorbarRangesEqual } from './common';\nimport { ColorbarRangeTextPosition } from './enums/ColorbarRangeTextPosition';\nimport { ColorbarCanvas } from './ColorbarCanvas';\nimport { ColorbarTicks } from './ColorbarTicks';\nimport isRangeTextPositionValid from './common/isRangeTextPositionValid';\nimport Widget from '../../../widgets/Widget';\nconst DEFAULTS = {\n    MULTIPLIER: 1,\n    RANGE_TEXT_POSITION: ColorbarRangeTextPosition.Right,\n    TICKS_BAR_SIZE: 50,\n};\nclass Colorbar extends Widget {\n    constructor(props) {\n        super(props);\n        this._isMouseOver = false;\n        this._isInteracting = false;\n        this._mouseOverCallback = (evt) => {\n            this._isMouseOver = true;\n            this.showTicks();\n            evt.stopPropagation();\n        };\n        this._mouseOutCallback = (evt) => {\n            this._isMouseOver = false;\n            this.hideTicks();\n            evt.stopPropagation();\n        };\n        this._mouseDownCallback = (evt) => {\n            this._isInteracting = true;\n            this.showTicks();\n            this._addVOIEventListeners(evt);\n            evt.stopPropagation();\n        };\n        this._mouseDragCallback = (evt, initialState) => {\n            const multipliers = this.getVOIMultipliers();\n            const currentPoints = this._getPointsFromMouseEvent(evt);\n            const { points: startPoints, voiRange: startVOIRange } = initialState;\n            const canvasDelta = vec2.sub(vec2.create(), currentPoints.local, startPoints.local);\n            const wwDelta = canvasDelta[0] * multipliers[0];\n            const wcDelta = canvasDelta[1] * multipliers[1];\n            if (!wwDelta && !wcDelta) {\n                return;\n            }\n            const { lower: voiLower, upper: voiUpper } = startVOIRange;\n            let { windowWidth, windowCenter } = csUtils.windowLevel.toWindowLevel(voiLower, voiUpper);\n            windowWidth = Math.max(windowWidth + wwDelta, 1);\n            windowCenter += wcDelta;\n            const newVoiRange = csUtils.windowLevel.toLowHighRange(windowWidth, windowCenter);\n            this.voiRange = newVoiRange;\n            evt.stopPropagation();\n            evt.preventDefault();\n        };\n        this._mouseUpCallback = (evt) => {\n            this._isInteracting = false;\n            this.hideTicks();\n            this._removeVOIEventListeners();\n            evt.stopPropagation();\n        };\n        this._eventListenersManager =\n            new csUtils.eventListener.MultiTargetEventListenerManager();\n        this._colormaps = Colorbar.getColormapsMap(props);\n        this._activeColormapName = Colorbar.getInitialColormapName(props);\n        this._canvas = this._createCanvas(props);\n        this._ticksBar = this._createTicksBar(props);\n        this._rangeTextPosition =\n            props.ticks?.position ?? DEFAULTS.RANGE_TEXT_POSITION;\n        this._canvas.appendTo(this.rootElement);\n        this._ticksBar.appendTo(this.rootElement);\n        this._addRootElementEventListeners();\n    }\n    get activeColormapName() {\n        return this._activeColormapName;\n    }\n    set activeColormapName(colormapName) {\n        if (colormapName === this._activeColormapName) {\n            return;\n        }\n        const colormap = this._colormaps.get(colormapName);\n        if (!colormap) {\n            console.warn(`Invalid colormap name (${colormapName})`);\n            return;\n        }\n        this._activeColormapName = colormapName;\n        this._canvas.colormap = colormap;\n    }\n    get imageRange() {\n        return this._canvas.imageRange;\n    }\n    set imageRange(imageRange) {\n        this._canvas.imageRange = imageRange;\n        this._ticksBar.imageRange = imageRange;\n    }\n    get voiRange() {\n        return this._canvas.voiRange;\n    }\n    set voiRange(voiRange) {\n        const { voiRange: currentVoiRange } = this._canvas;\n        if (!isRangeValid(voiRange) ||\n            areColorbarRangesEqual(voiRange, currentVoiRange)) {\n            return;\n        }\n        this._canvas.voiRange = voiRange;\n        this._ticksBar.voiRange = voiRange;\n        this.onVoiChange(voiRange);\n    }\n    get showFullImageRange() {\n        return this._canvas.showFullImageRange;\n    }\n    set showFullImageRange(value) {\n        this._canvas.showFullImageRange = value;\n        this._ticksBar.showFullPixelValueRange = value;\n    }\n    destroy() {\n        super.destroy();\n        this._eventListenersManager.reset();\n    }\n    createRootElement() {\n        const rootElement = document.createElement('div');\n        Object.assign(rootElement.style, {\n            position: 'relative',\n            fontSize: '0',\n            width: '100%',\n            height: '100%',\n        });\n        return rootElement;\n    }\n    onContainerResize() {\n        super.onContainerResize();\n        this.updateTicksBar();\n        this._canvas.size = this.containerSize;\n    }\n    getVOIMultipliers() {\n        return [DEFAULTS.MULTIPLIER, DEFAULTS.MULTIPLIER];\n    }\n    onVoiChange(voiRange) {\n    }\n    showTicks() {\n        this.updateTicksBar();\n        this._ticksBar.visible = true;\n    }\n    hideTicks() {\n        if (this._isInteracting || this._isMouseOver) {\n            return;\n        }\n        this._ticksBar.visible = false;\n    }\n    static getColormapsMap(props) {\n        const { colormaps } = props;\n        return colormaps.reduce((items, item) => items.set(item.Name, item), new Map());\n    }\n    static getInitialColormapName(props) {\n        const { activeColormapName, colormaps } = props;\n        const colormapExists = !!activeColormapName &&\n            colormaps.some((cm) => cm.Name === activeColormapName);\n        return colormapExists ? activeColormapName : colormaps[0].Name;\n    }\n    _createCanvas(props) {\n        const { imageRange, voiRange, showFullPixelValueRange } = props;\n        const colormap = this._colormaps.get(this._activeColormapName);\n        return new ColorbarCanvas({\n            colormap,\n            imageRange,\n            voiRange: voiRange,\n            showFullPixelValueRange,\n        });\n    }\n    _createTicksBar(props) {\n        const ticksProps = props.ticks;\n        return new ColorbarTicks({\n            imageRange: props.imageRange,\n            voiRange: props.voiRange,\n            ticks: ticksProps,\n            showFullPixelValueRange: props.showFullPixelValueRange,\n        });\n    }\n    _getPointsFromMouseEvent(evt) {\n        const { rootElement: element } = this;\n        const clientPoint = [evt.clientX, evt.clientY];\n        const pagePoint = [evt.pageX, evt.pageY];\n        const rect = element.getBoundingClientRect();\n        const localPoints = [\n            pagePoint[0] - rect.left - window.pageXOffset,\n            pagePoint[1] - rect.top - window.pageYOffset,\n        ];\n        return { client: clientPoint, page: pagePoint, local: localPoints };\n    }\n    updateTicksBar() {\n        const { width: containerWidth, height: containerHeight } = this.containerSize;\n        if (containerWidth === 0 && containerHeight === 0) {\n            return;\n        }\n        const { _ticksBar: ticksBar, _rangeTextPosition: rangeTextPosition } = this;\n        const isHorizontal = containerWidth >= containerHeight;\n        const width = isHorizontal ? containerWidth : DEFAULTS.TICKS_BAR_SIZE;\n        const height = isHorizontal ? DEFAULTS.TICKS_BAR_SIZE : containerHeight;\n        if (!isRangeTextPositionValid(containerWidth, containerHeight, rangeTextPosition)) {\n            throw new Error('Invalid rangeTextPosition value for the current colobar orientation');\n        }\n        let ticksBarTop;\n        let ticksBarLeft;\n        ticksBar.size = { width, height };\n        if (isHorizontal) {\n            ticksBarLeft = 0;\n            ticksBarTop =\n                rangeTextPosition === ColorbarRangeTextPosition.Top\n                    ? -height\n                    : containerHeight;\n        }\n        else {\n            ticksBarTop = 0;\n            ticksBarLeft =\n                rangeTextPosition === ColorbarRangeTextPosition.Left\n                    ? -width\n                    : containerWidth;\n        }\n        ticksBar.top = ticksBarTop;\n        ticksBar.left = ticksBarLeft;\n    }\n    _addRootElementEventListeners() {\n        const { _eventListenersManager: manager } = this;\n        const { rootElement: element } = this;\n        manager.addEventListener(element, 'mouseover', this._mouseOverCallback);\n        manager.addEventListener(element, 'mouseout', this._mouseOutCallback);\n        manager.addEventListener(element, 'mousedown', this._mouseDownCallback);\n    }\n    _addVOIEventListeners(evt) {\n        const { _eventListenersManager: manager } = this;\n        const points = this._getPointsFromMouseEvent(evt);\n        const voiRange = { ...this._canvas.voiRange };\n        const initialDragState = { points, voiRange };\n        this._removeVOIEventListeners();\n        manager.addEventListener(document, 'voi.mouseup', this._mouseUpCallback);\n        manager.addEventListener(document, 'voi.mousemove', (evt) => this._mouseDragCallback(evt, initialDragState));\n    }\n    _removeVOIEventListeners() {\n        const { _eventListenersManager: manager } = this;\n        manager.removeEventListener(document, 'voi.mouseup');\n        manager.removeEventListener(document, 'voi.mousemove');\n    }\n}\nexport { Colorbar as default, Colorbar };\n","import { eventTarget, VolumeViewport, StackViewport, Enums, utilities, getEnabledElement, cache, } from '@cornerstonejs/core';\nimport { Colorbar } from './Colorbar';\nimport { getVOIMultipliers } from '../../getVOIMultipliers';\nconst { Events } = Enums;\nconst defaultImageRange = { lower: -1000, upper: 1000 };\nclass ViewportColorbar extends Colorbar {\n    constructor(props) {\n        const { element, volumeId } = props;\n        const imageRange = ViewportColorbar._getImageRange(element, volumeId);\n        const voiRange = ViewportColorbar._getVOIRange(element, volumeId);\n        super({ ...props, imageRange, voiRange });\n        this.autoHideTicks = () => {\n            if (this._hideTicksTimeoutId) {\n                return;\n            }\n            const timeLeft = this._hideTicksTime - Date.now();\n            if (timeLeft <= 0) {\n                this.hideTicks();\n            }\n            else {\n                this._hideTicksTimeoutId = window.setTimeout(() => {\n                    this._hideTicksTimeoutId = 0;\n                    this.autoHideTicks();\n                }, timeLeft);\n            }\n        };\n        this._stackNewImageCallback = () => {\n            this.imageRange = ViewportColorbar._getImageRange(this._element);\n        };\n        this._imageVolumeModifiedCallback = (evt) => {\n            const { volumeId } = evt.detail;\n            if (volumeId !== this._volumeId) {\n                return;\n            }\n            const { _element: element } = this;\n            this.imageRange = ViewportColorbar._getImageRange(element, volumeId);\n        };\n        this._viewportVOIModifiedCallback = (evt) => {\n            const { viewportId, volumeId, range: voiRange, colormap } = evt.detail;\n            const { viewport } = this.enabledElement;\n            if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n                return;\n            }\n            this.voiRange = voiRange;\n            if (colormap) {\n                this.activeColormapName = colormap.name;\n            }\n            this.showAndAutoHideTicks();\n        };\n        this._viewportColormapModifiedCallback = (evt) => {\n            const { viewportId, colormap, volumeId } = evt.detail;\n            const { viewport } = this.enabledElement;\n            if (viewportId !== viewport.id || volumeId !== this._volumeId) {\n                return;\n            }\n            this.activeColormapName = colormap.name;\n        };\n        this._element = element;\n        this._volumeId = volumeId;\n        this._addCornerstoneEventListener();\n    }\n    get element() {\n        return this._element;\n    }\n    get enabledElement() {\n        return getEnabledElement(this._element);\n    }\n    getVOIMultipliers() {\n        const { viewport } = this.enabledElement;\n        return getVOIMultipliers(viewport, this._volumeId);\n    }\n    onVoiChange(voiRange) {\n        super.onVoiChange(voiRange);\n        const { viewport } = this.enabledElement;\n        if (viewport instanceof StackViewport) {\n            viewport.setProperties({\n                voiRange: voiRange,\n            });\n            viewport.render();\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const { _volumeId: volumeId } = this;\n            const viewportsContainingVolumeUID = utilities.getViewportsWithVolumeId(volumeId);\n            viewport.setProperties({ voiRange }, volumeId);\n            viewportsContainingVolumeUID.forEach((vp) => vp.render());\n        }\n    }\n    static _getImageRange(element, volumeId) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const actor = viewport.getImageActor(volumeId);\n        if (!actor) {\n            return defaultImageRange;\n        }\n        const imageData = actor.getMapper().getInputData();\n        const scalarData = imageData.getPointData().getScalars();\n        let imageRange;\n        if (!scalarData) {\n            if (!volumeId) {\n                throw new Error('volumeId is required when scalarData is not available');\n            }\n            const volume = cache.getVolume(volumeId);\n            const [minValue, maxValue] = volume.voxelManager.getRange();\n            imageRange = [minValue, maxValue];\n        }\n        else {\n            imageRange = scalarData.getRange();\n        }\n        return imageRange[0] === 0 && imageRange[1] === 0\n            ? defaultImageRange\n            : { lower: imageRange[0], upper: imageRange[1] };\n    }\n    static _getVOIRange(element, volumeId) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const actor = viewport.getImageActor(volumeId);\n        if (!actor) {\n            return defaultImageRange;\n        }\n        const voiRange = actor.getProperty().getRGBTransferFunction(0).getRange();\n        return voiRange[0] === 0 && voiRange[1] === 0\n            ? defaultImageRange\n            : { lower: voiRange[0], upper: voiRange[1] };\n    }\n    showAndAutoHideTicks(interval = 1000) {\n        this._hideTicksTime = Date.now() + interval;\n        this.showTicks();\n        this.autoHideTicks();\n    }\n    _addCornerstoneEventListener() {\n        const { _element: element } = this;\n        eventTarget.addEventListener(Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedCallback);\n        element.addEventListener(Events.STACK_NEW_IMAGE, this._stackNewImageCallback);\n        element.addEventListener(Events.VOI_MODIFIED, this._viewportVOIModifiedCallback);\n        element.addEventListener(Events.COLORMAP_MODIFIED, this._viewportColormapModifiedCallback);\n    }\n    destroy() {\n        super.destroy();\n        const { _element: element } = this;\n        eventTarget.removeEventListener(Events.IMAGE_VOLUME_MODIFIED, this._imageVolumeModifiedCallback);\n        element.removeEventListener(Events.STACK_NEW_IMAGE, this._stackNewImageCallback);\n        element.removeEventListener(Events.VOI_MODIFIED, this._viewportVOIModifiedCallback);\n        element.removeEventListener(Events.COLORMAP_MODIFIED, this._viewportColormapModifiedCallback);\n    }\n}\nexport { ViewportColorbar as default, ViewportColorbar };\n","import { utilities as csUtils, StackViewport, VolumeViewport, } from '@cornerstonejs/core';\nfunction extractWindowLevelRegionToolData(viewport) {\n    if (viewport instanceof VolumeViewport) {\n        return extractImageDataVolume(viewport);\n    }\n    if (viewport instanceof StackViewport) {\n        return extractImageDataStack(viewport);\n    }\n    throw new Error('Viewport not supported');\n}\nfunction extractImageDataVolume(viewport) {\n    const { scalarData, width, height } = csUtils.getCurrentVolumeViewportSlice(viewport);\n    const { min: minPixelValue, max: maxPixelValue } = csUtils.getMinMax(scalarData);\n    return {\n        scalarData,\n        minPixelValue,\n        maxPixelValue,\n        width,\n        height,\n        rows: width,\n        columns: height,\n    };\n}\nfunction extractImageDataStack(viewport) {\n    const imageData = viewport.getImageData();\n    const { scalarData } = imageData;\n    const { min: minPixelValue, max: maxPixelValue } = csUtils.getMinMax(scalarData);\n    const width = imageData.dimensions[0];\n    const height = imageData.dimensions[1];\n    const { rows, columns, color } = viewport.getCornerstoneImage();\n    return {\n        scalarData,\n        width,\n        height,\n        minPixelValue,\n        maxPixelValue,\n        rows,\n        columns,\n        color,\n    };\n}\nexport { extractWindowLevelRegionToolData };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { pointInSphere } from './math/sphere';\nimport { getBoundingBoxAroundShape } from './boundingBox';\nconst { transformWorldToIndex } = csUtils;\nexport function pointInSurroundingSphereCallback(imageData, circlePoints, callback, viewport) {\n    const { boundsIJK, centerWorld, radiusWorld } = _getBounds(circlePoints, imageData, viewport);\n    const sphereObj = {\n        center: centerWorld,\n        radius: radiusWorld,\n    };\n    const dimensions = imageData.getDimensions();\n    const voxelManager = csUtils.VoxelManager.createScalarVolumeVoxelManager({\n        dimensions: dimensions,\n        scalarData: imageData.getPointData().getScalars().getData(),\n    });\n    voxelManager.forEach(callback, {\n        boundsIJK,\n        isInObject: (pointLPS) => pointInSphere(sphereObj, pointLPS),\n        imageData,\n    });\n}\nfunction _getBounds(circlePoints, imageData, viewport) {\n    const [bottom, top] = circlePoints;\n    const centerWorld = vec3.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);\n    const radiusWorld = vec3.distance(bottom, top) / 2;\n    let boundsIJK;\n    if (!viewport) {\n        const centerIJK = transformWorldToIndex(imageData, centerWorld);\n        const spacings = imageData.getSpacing();\n        const minSpacing = Math.min(...spacings);\n        const maxRadiusIJK = Math.ceil(radiusWorld / minSpacing);\n        boundsIJK = [\n            [centerIJK[0] - maxRadiusIJK, centerIJK[0] + maxRadiusIJK],\n            [centerIJK[1] - maxRadiusIJK, centerIJK[1] + maxRadiusIJK],\n            [centerIJK[2] - maxRadiusIJK, centerIJK[2] + maxRadiusIJK],\n        ];\n        return {\n            boundsIJK,\n            centerWorld: centerWorld,\n            radiusWorld,\n        };\n    }\n    boundsIJK = _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld);\n    return {\n        boundsIJK,\n        centerWorld: centerWorld,\n        radiusWorld,\n    };\n}\nfunction _computeBoundsIJKWithCamera(imageData, viewport, circlePoints, centerWorld, radiusWorld) {\n    const [bottom, top] = circlePoints;\n    const dimensions = imageData.getDimensions();\n    const camera = viewport.getCamera();\n    const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n    const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const topLeftWorld = vec3.create();\n    const bottomRightWorld = vec3.create();\n    vec3.scaleAndAdd(topLeftWorld, top, viewPlaneNormal, radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottom, viewPlaneNormal, -radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, viewRight, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, viewRight, radiusWorld);\n    const sphereCornersIJK = [\n        transformWorldToIndex(imageData, topLeftWorld),\n        (transformWorldToIndex(imageData, bottomRightWorld)),\n    ];\n    const boundsIJK = getBoundingBoxAroundShape(sphereCornersIJK, dimensions);\n    return boundsIJK;\n}\n","import { triggerAnnotationModified } from '../stateManagement/annotation/helpers/state';\nimport { ChangeTypes } from '../enums';\nexport default function setAnnotationLabel(annotation, element, updatedLabel) {\n    annotation.data.label = updatedLabel;\n    triggerAnnotationModified(annotation, element, ChangeTypes.LabelChange);\n}\n","export function pickPoints(hull, slack = 7) {\n    if (!hull.length) {\n        throw new Error('Convex hull is empty');\n    }\n    const n = hull.length;\n    const next = (i) => (i + 1) % n;\n    const walk = (from, to) => {\n        const idx = [];\n        for (let i = from;; i = next(i)) {\n            idx.push(i);\n            if (i === to) {\n                break;\n            }\n        }\n        return idx;\n    };\n    let i2 = 0, i3 = 0;\n    for (let i = 1; i < n; i++) {\n        if (hull[i][0] < hull[i2][0]) {\n            i2 = i;\n        }\n        if (hull[i][0] > hull[i3][0]) {\n            i3 = i;\n        }\n    }\n    const P2 = hull[i2];\n    const P3 = hull[i3];\n    const pathA = walk(i2, i3);\n    const pathB = walk(i3, i2);\n    const globalYmin = Math.min(...hull.map((p) => p[1]));\n    const upperPath = pathA.some((i) => hull[i][1] === globalYmin)\n        ? pathA\n        : pathB;\n    const topY = Math.min(...upperPath.map((i) => hull[i][1]));\n    let arcPts = upperPath\n        .map((i) => hull[i])\n        .filter((p) => Math.abs(p[1] - topY) <= slack);\n    if (arcPts.length < 2) {\n        arcPts = upperPath\n            .map((i) => hull[i])\n            .sort((a, b) => a[1] - b[1])\n            .slice(0, 2);\n    }\n    const P1 = arcPts.reduce((best, p) => (p[0] < best[0] ? p : best), arcPts[0]);\n    const P4 = arcPts.reduce((best, p) => (p[0] > best[0] ? p : best), arcPts[0]);\n    return { P1, P2, P3, P4 };\n}\nexport function computeEdgeBuffer(buffer, width, height) {\n    const total = width * height;\n    const channels = buffer.length / total;\n    if (![1, 3, 4].includes(channels)) {\n        throw new Error('Buffer must be 1,3 or 4 channels per pixel');\n    }\n    const gray = new Float32Array(total);\n    for (let i = 0; i < total; i++) {\n        if (channels === 1) {\n            gray[i] = buffer[i];\n        }\n        else {\n            const base = i * channels;\n            const r = buffer[base];\n            const g = buffer[base + 1];\n            const b = buffer[base + 2];\n            gray[i] = 0.299 * r + 0.587 * g + 0.114 * b;\n        }\n    }\n    const edgeBuf = new Float32Array(total);\n    for (let y = 1; y < height - 1; y++) {\n        for (let x = 1; x < width - 1; x++) {\n            const idx = y * width + x;\n            const i00 = idx - width - 1;\n            const i01 = idx - width;\n            const i02 = idx - width + 1;\n            const i10 = idx - 1;\n            const i11 = idx;\n            const i12 = idx + 1;\n            const i20 = idx + width - 1;\n            const i21 = idx + width;\n            const i22 = idx + width + 1;\n            const gx = -gray[i00] +\n                gray[i02] +\n                -2 * gray[i10] +\n                2 * gray[i12] +\n                -gray[i20] +\n                gray[i22];\n            const gy = gray[i00] +\n                2 * gray[i01] +\n                gray[i02] -\n                gray[i20] -\n                2 * gray[i21] -\n                gray[i22];\n            edgeBuf[idx] = Math.hypot(gx, gy);\n        }\n    }\n    return edgeBuf;\n}\nexport function refineCornersDirectional(edgeBuf, width, height, rough, contour, opts = {}) {\n    const { maxDist = 15, slack = 2 } = opts;\n    const directions = {\n        P1: { dx: -1, dy: -1 },\n        P2: { dx: -1, dy: +1 },\n        P3: { dx: +1, dy: +1 },\n        P4: { dx: +1, dy: -1 },\n    };\n    function snapQuadrant(pt, { dx, dy }, threshold = 5) {\n        const xmin = dx < 0 ? pt[0] - maxDist : pt[0] - slack;\n        const xmax = dx < 0 ? pt[0] + slack : pt[0] + maxDist;\n        const ymin = dy < 0 ? pt[1] - maxDist : pt[1] - slack;\n        const ymax = dy < 0 ? pt[1] + slack : pt[1] + maxDist;\n        let best = pt;\n        for (const [cx, cy] of contour) {\n            if (cx < xmin || cx > xmax || cy < ymin || cy > ymax) {\n                continue;\n            }\n            const xi = Math.round(cx);\n            const yi = Math.round(cy);\n            if (xi < 0 || xi >= width || yi < 0 || yi >= height) {\n                continue;\n            }\n            const xAlign = (xi - best[0]) * dx;\n            const yAlign = (yi - best[0]) * dy;\n            const v = edgeBuf[yi * width + xi];\n            if (v > threshold && (xAlign > 0 || yAlign > 0)) {\n                best = [cx, cy];\n            }\n        }\n        return best;\n    }\n    return {\n        P1: snapQuadrant(rough.P1, directions.P1),\n        P2: snapQuadrant(rough.P2, directions.P2),\n        P3: snapQuadrant(rough.P3, directions.P3),\n        P4: snapQuadrant(rough.P4, directions.P4),\n    };\n}\nexport function calculateFanShapeCorners(imageBuffer, width, height, hull, roughContour) {\n    const rough = pickPoints(hull);\n    const refined = refineCornersDirectional(imageBuffer, width, height, rough, roughContour, {\n        maxDist: 20,\n        step: 0.5,\n    });\n    return refined;\n}\n","import { intersectLine } from '../../../../utilities/math/line';\nfunction angleRad(center, p) {\n    return Math.atan2(p[1] - center[1], p[0] - center[0]);\n}\nexport function deriveFanGeometry(params) {\n    const { P1, P2, P3, P4 } = params;\n    const centerResult = intersectLine(P1, P2, P4, P3, true);\n    if (!centerResult) {\n        throw new Error('Fan edges appear parallel  no apex found');\n    }\n    const center = centerResult;\n    let startAngle = angleRad(center, P1) * (180 / Math.PI);\n    let endAngle = angleRad(center, P4) * (180 / Math.PI);\n    if (endAngle <= startAngle) {\n        const tempAngle = startAngle;\n        startAngle = endAngle;\n        endAngle = tempAngle;\n    }\n    const d1 = Math.hypot(P1[0] - center[0], P1[1] - center[1]);\n    const d4 = Math.hypot(P4[0] - center[0], P4[1] - center[1]);\n    const d2 = Math.hypot(P2[0] - center[0], P2[1] - center[1]);\n    const d3 = Math.hypot(P3[0] - center[0], P3[1] - center[1]);\n    const innerRadius = Math.min(d1, d4);\n    const outerRadius = Math.max(d2, d3);\n    return {\n        center,\n        startAngle,\n        endAngle,\n        innerRadius,\n        outerRadius,\n    };\n}\n","import { cache } from '@cornerstonejs/core';\nimport { segmentLargestUSOutlineFromBuffer } from './segmentLargestUSOutlineFromBuffer';\nimport { generateConvexHullFromContour } from './generateConvexHullFromContour';\nimport { calculateFanShapeCorners } from './calculateFanShapeCorners';\nimport { deriveFanGeometry } from './deriveFanGeometry';\nexport function exportContourJpeg(pixelData, width, height, contour, opts = {}) {\n    const { strokeStyle = '#f00', lineWidth = 2, quality = 0.92 } = opts;\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    const totalPixels = width * height;\n    const channels = pixelData.length / totalPixels;\n    const imgData = ctx.createImageData(width, height);\n    const out = imgData.data;\n    for (let i = 0; i < totalPixels; i++) {\n        const baseIn = i * channels;\n        const baseOut = i * 4;\n        if (channels === 1) {\n            const v = pixelData[baseIn];\n            out[baseOut] = v;\n            out[baseOut + 1] = v;\n            out[baseOut + 2] = v;\n            out[baseOut + 3] = 255;\n        }\n        else {\n            out[baseOut] = pixelData[baseIn];\n            out[baseOut + 1] = pixelData[baseIn + 1];\n            out[baseOut + 2] = pixelData[baseIn + 2];\n            out[baseOut + 3] = channels === 4 ? pixelData[baseIn + 3] : 255;\n        }\n    }\n    ctx.putImageData(imgData, 0, 0);\n    if (contour.length > 0) {\n        ctx.strokeStyle = strokeStyle;\n        ctx.lineWidth = lineWidth;\n        ctx.beginPath();\n        ctx.moveTo(contour[0][0] + 0.5, contour[0][1] + 0.5);\n        for (let i = 1; i < contour.length; i++) {\n            ctx.lineTo(contour[i][0] + 0.5, contour[i][1] + 0.5);\n        }\n        ctx.closePath();\n        ctx.stroke();\n    }\n    return canvas.toDataURL('image/jpeg', quality);\n}\nexport function getPixelData(imageId) {\n    const image = cache.getImage(imageId);\n    if (!image) {\n        return;\n    }\n    const width = image.width;\n    const height = image.height;\n    const pixelData = image.getPixelData();\n    return {\n        pixelData,\n        width,\n        height,\n    };\n}\nexport default function saveBinaryData(url, filename) {\n    const a = document.createElement('a');\n    a.href = url;\n    a.download = filename;\n    document.body.appendChild(a);\n    a.style.display = 'none';\n    a.click();\n    a.remove();\n}\nfunction exportFanJpeg(pixelData, width, height, fan, opts = {}) {\n    const { center, startAngle: startAngleInDegrees, endAngle: endAngleInDegrees, innerRadius, outerRadius, } = fan;\n    const { strokeStyle = '#0ff', lineWidth = 2, quality = 0.92 } = opts;\n    const startAngle = (startAngleInDegrees * Math.PI) / 180;\n    const endAngle = (endAngleInDegrees * Math.PI) / 180;\n    const canvas = document.createElement('canvas');\n    canvas.width = width;\n    canvas.height = height;\n    const ctx = canvas.getContext('2d');\n    const total = width * height;\n    const channels = pixelData.length / total;\n    const imgData = ctx.createImageData(width, height);\n    const out = imgData.data;\n    for (let i = 0; i < total; i++) {\n        const baseOut = i * 4;\n        if (channels === 1) {\n            const v = pixelData[i];\n            out[baseOut] = v;\n            out[baseOut + 1] = v;\n            out[baseOut + 2] = v;\n            out[baseOut + 3] = 255;\n        }\n        else {\n            const baseIn = i * channels;\n            out[baseOut] = pixelData[baseIn];\n            out[baseOut + 1] = pixelData[baseIn + 1];\n            out[baseOut + 2] = pixelData[baseIn + 2];\n            out[baseOut + 3] = channels === 4 ? pixelData[baseIn + 3] : 255;\n        }\n    }\n    ctx.putImageData(imgData, 0, 0);\n    ctx.beginPath();\n    for (let a = startAngle; a <= endAngle; a += 0.01) {\n        const x = center[0] + innerRadius * Math.cos(a);\n        const y = center[1] + innerRadius * Math.sin(a);\n        if (a === startAngle) {\n            ctx.moveTo(x, y);\n        }\n        else {\n            ctx.lineTo(x, y);\n        }\n    }\n    for (let a = endAngle; a >= startAngle; a -= 0.01) {\n        const x = center[0] + outerRadius * Math.cos(a);\n        const y = center[1] + outerRadius * Math.sin(a);\n        ctx.lineTo(x, y);\n    }\n    ctx.closePath();\n    ctx.strokeStyle = strokeStyle;\n    ctx.lineWidth = lineWidth;\n    ctx.stroke();\n    return canvas.toDataURL('image/jpeg', quality);\n}\nexport function downloadFanJpeg(imageId, contourType = 5) {\n    const { contour, simplified, hull, refined, fanGeometry } = calculateFanGeometry(imageId);\n    const { pixelData, width, height } = getPixelData(imageId) || {};\n    if (!pixelData) {\n        return;\n    }\n    let jpegDataUrl;\n    if (contourType === 1) {\n        jpegDataUrl = exportContourJpeg(pixelData, width, height, contour);\n    }\n    else if (contourType === 2) {\n        jpegDataUrl = exportContourJpeg(pixelData, width, height, simplified);\n    }\n    else if (contourType === 3) {\n        jpegDataUrl = exportContourJpeg(pixelData, width, height, hull);\n    }\n    else if (contourType === 4) {\n        jpegDataUrl = exportContourJpeg(pixelData, width, height, [\n            refined.P1,\n            refined.P2,\n            refined.P3,\n            refined.P4,\n        ]);\n    }\n    else {\n        jpegDataUrl = exportFanJpeg(pixelData, width, height, fanGeometry, {\n            strokeStyle: '#f00',\n            lineWidth: 3,\n            quality: 0.95,\n        });\n    }\n    saveBinaryData(jpegDataUrl, 'contour.jpg');\n}\nexport function calculateFanGeometry(imageId) {\n    const { pixelData, width, height } = getPixelData(imageId) || {};\n    if (!pixelData) {\n        return;\n    }\n    const contour = segmentLargestUSOutlineFromBuffer(pixelData, width, height);\n    const { simplified, hull } = generateConvexHullFromContour(contour);\n    const refined = calculateFanShapeCorners(pixelData, width, height, hull, simplified);\n    const fanGeometry = deriveFanGeometry({\n        P1: refined.P1,\n        P2: refined.P2,\n        P3: refined.P3,\n        P4: refined.P4,\n    });\n    return { contour, simplified, hull, refined, fanGeometry };\n}\n","import { floodFill } from '../../../../utilities/segmentation';\nexport function segmentLargestUSOutlineFromBuffer(buffer, width, height) {\n    const totalPixels = width * height;\n    const channelCount = buffer.length / totalPixels;\n    if (![1, 3, 4].includes(channelCount)) {\n        throw new Error('Buffer must be 1, 3, or 4 channels per pixel');\n    }\n    const mask = Array.from({ length: height }, () => new Array(width).fill(false));\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            const pixelIndex = y * width + x;\n            const base = pixelIndex * channelCount;\n            let isForeground = false;\n            for (let c = 0; c < Math.min(3, channelCount); c++) {\n                if (buffer[base + c] > 0) {\n                    isForeground = true;\n                    break;\n                }\n            }\n            mask[y][x] = isForeground;\n        }\n    }\n    const labels = Array.from({ length: height }, () => new Array(width).fill(0));\n    let currentLabel = 0;\n    const regionSizes = {};\n    for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (mask[y][x] && labels[y][x] === 0) {\n                currentLabel++;\n                const getter = (px, py) => {\n                    if (px < 0 || px >= width || py < 0 || py >= height) {\n                        return false;\n                    }\n                    return mask[py][px] && labels[py][px] === 0;\n                };\n                let pixelCount = 0;\n                const options = {\n                    onFlood: (px, py) => {\n                        labels[py][px] = currentLabel;\n                        pixelCount++;\n                    },\n                    diagonals: false,\n                };\n                floodFill(getter, [x, y], options);\n                regionSizes[currentLabel] = pixelCount;\n            }\n        }\n    }\n    if (currentLabel === 0) {\n        return [];\n    }\n    const largestLabel = Object.keys(regionSizes).reduce((a, b) => regionSizes[a] > regionSizes[b] ? a : b);\n    function isBorder(x, y) {\n        if (labels[y][x] !== +largestLabel) {\n            return false;\n        }\n        for (const [dx, dy] of [\n            [1, 0],\n            [-1, 0],\n            [0, 1],\n            [0, -1],\n        ]) {\n            const nx = x + dx, ny = y + dy;\n            if (nx < 0 ||\n                nx >= width ||\n                ny < 0 ||\n                ny >= height ||\n                labels[ny][nx] !== +largestLabel) {\n                return true;\n            }\n        }\n        return false;\n    }\n    let start = null;\n    outer: for (let y = 0; y < height; y++) {\n        for (let x = 0; x < width; x++) {\n            if (isBorder(x, y)) {\n                start = [x, y];\n                break outer;\n            }\n        }\n    }\n    if (!start) {\n        return [];\n    }\n    const dirs = [\n        [1, 0],\n        [1, 1],\n        [0, 1],\n        [-1, 1],\n        [-1, 0],\n        [-1, -1],\n        [0, -1],\n        [1, -1],\n    ];\n    const contour = [];\n    let current = start;\n    let prev = [start[0] - 1, start[1]];\n    do {\n        contour.push([current[0], current[1]]);\n        const dx0 = prev[0] - current[0], dy0 = prev[1] - current[1];\n        let startDir = dirs.findIndex((d) => d[0] === dx0 && d[1] === dy0);\n        if (startDir < 0) {\n            startDir = 0;\n        }\n        let nextPt = null;\n        for (let k = 1; k <= 8; k++) {\n            const [dx, dy] = dirs[(startDir + k) % 8];\n            const nx = current[0] + dx, ny = current[1] + dy;\n            if (nx >= 0 && nx < width && ny >= 0 && ny < height && isBorder(nx, ny)) {\n                nextPt = [nx, ny];\n                const [bdx, bdy] = dirs[(startDir + k - 1 + 8) % 8];\n                prev = [current[0] + bdx, current[1] + bdy];\n                break;\n            }\n        }\n        if (!nextPt) {\n            break;\n        }\n        current = nextPt;\n    } while (current[0] !== start[0] || current[1] !== start[1]);\n    return contour;\n}\n","import * as math from '../../../../utilities/math';\nexport function generateConvexHullFromContour(contour) {\n    const simplified = math.polyline.decimate(contour, 2);\n    const hull = math.polyline.convexHull(simplified);\n    return { simplified, hull };\n}\n","import { utilities, triggerEvent } from '@cornerstonejs/core';\nimport { getAnnotationNearPoint, getAnnotationNearPointOnEnabledElement, } from './getAnnotationNearPoint';\nimport debounce from './debounce';\nimport throttle from './throttle';\nimport isObject from './isObject';\nimport calibrateImageSpacing from './calibrateImageSpacing';\nimport { getCalibratedLengthUnitsAndScale, getCalibratedProbeUnitsAndValue, getCalibratedAspect, } from './getCalibratedUnits';\nimport triggerAnnotationRenderForViewportIds from './triggerAnnotationRenderForViewportIds';\nimport triggerAnnotationRenderForToolGroupIds from './triggerAnnotationRenderForToolGroupIds';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getSphereBoundsInfo } from './getSphereBoundsInfo';\nimport { pointToString } from './pointToString';\nimport AnnotationMultiSlice from './AnnotationMultiSlice';\nimport getViewportForAnnotation from './getViewportForAnnotation';\nimport { annotationHydration, getClosestImageIdForStackViewport, } from './annotationHydration';\nimport * as contours from './contours';\nimport * as segmentation from './segmentation';\nimport * as drawing from './drawing';\nimport * as math from './math';\nimport * as planar from './planar';\nimport * as viewportFilters from './viewportFilters';\nimport * as orientation from './orientation';\nimport * as cine from './cine';\nimport * as boundingBox from './boundingBox';\nimport * as planarFreehandROITool from './planarFreehandROITool';\nimport * as rectangleROITool from './rectangleROITool';\nimport { stackPrefetch, stackContextPrefetch } from './stackPrefetch';\nimport * as viewport from './viewport';\nimport * as touch from './touch';\nimport * as dynamicVolume from './dynamicVolume';\nimport * as polyDataUtils from './polyData/utils';\nimport * as voi from './voi';\nimport * as contourSegmentation from './contourSegmentation';\nimport { pointInSurroundingSphereCallback } from './pointInSurroundingSphereCallback';\nconst roundNumber = utilities.roundNumber;\nimport normalizeViewportPlane from './normalizeViewportPlane';\nimport IslandRemoval from './segmentation/islandRemoval';\nimport { getPixelValueUnits, getPixelValueUnitsImageId, } from './getPixelValueUnits';\nimport * as geometricSurfaceUtils from './geometricSurfaceUtils';\nimport setAnnotationLabel from './setAnnotationLabel';\nimport { moveAnnotationToViewPlane } from './moveAnnotationToViewPlane';\nimport getOrCreateImageVolume from './segmentation/getOrCreateImageVolume';\nimport * as usFanExtraction from '../tools/annotation/UltrasoundPleuraBLineTool/utils/fanExtraction';\nexport { math, planar, viewportFilters, drawing, debounce, dynamicVolume, throttle, orientation, isObject, touch, triggerEvent, calibrateImageSpacing, getCalibratedLengthUnitsAndScale, getCalibratedProbeUnitsAndValue, getCalibratedAspect, getPixelValueUnits, getPixelValueUnitsImageId, segmentation, contours, triggerAnnotationRenderForViewportIds, triggerAnnotationRenderForToolGroupIds, triggerAnnotationRender, getSphereBoundsInfo, getAnnotationNearPoint, getViewportForAnnotation, getAnnotationNearPointOnEnabledElement, viewport, cine, boundingBox, rectangleROITool, planarFreehandROITool, stackPrefetch, stackContextPrefetch, roundNumber, pointToString, polyDataUtils, voi, AnnotationMultiSlice, contourSegmentation, annotationHydration, getClosestImageIdForStackViewport, pointInSurroundingSphereCallback, normalizeViewportPlane, IslandRemoval, geometricSurfaceUtils, usFanExtraction, setAnnotationLabel, moveAnnotationToViewPlane, getOrCreateImageVolume, };\n","import * as math from '../../../utilities/math';\nclass Spline {\n    constructor(props) {\n        this._controlPoints = [];\n        this._invalidated = false;\n        this._length = 0;\n        this._controlPoints = [];\n        this._resolution = props?.resolution ?? 20;\n        this._fixedResolution = props?.fixedResolution ?? false;\n        this._closed = props?.closed ?? false;\n        this._invalidated = true;\n    }\n    get controlPoints() {\n        return this._controlPoints;\n    }\n    get numControlPoints() {\n        return this._controlPoints.length;\n    }\n    get resolution() {\n        return this._resolution;\n    }\n    set resolution(resolution) {\n        if (this._fixedResolution || this._resolution === resolution) {\n            return;\n        }\n        this._resolution = resolution;\n        this.invalidated = true;\n    }\n    get fixedResolution() {\n        return this._fixedResolution;\n    }\n    get closed() {\n        return this._closed;\n    }\n    set closed(closed) {\n        if (this._closed === closed) {\n            return;\n        }\n        this._closed = closed;\n        this.invalidated = true;\n    }\n    get aabb() {\n        this._update();\n        return this._aabb;\n    }\n    get length() {\n        this._update();\n        return this._length;\n    }\n    get invalidated() {\n        return this._invalidated;\n    }\n    set invalidated(invalidated) {\n        this._invalidated = invalidated;\n    }\n    hasTangentPoints() {\n        return false;\n    }\n    addControlPoint(point) {\n        this._controlPoints.push([point[0], point[1]]);\n        this.invalidated = true;\n    }\n    addControlPoints(points) {\n        points.forEach((point) => this.addControlPoint(point));\n    }\n    addControlPointAtU(u) {\n        const lineSegment = this._getLineSegmentAt(u);\n        const { start: startPoint, end: endPoint } = lineSegment.points;\n        const curveSegmentIndex = Math.floor(u);\n        const curveSegment = this._curveSegments[curveSegmentIndex];\n        const t = u - Math.floor(curveSegmentIndex);\n        const controlPointPos = [\n            startPoint[0] + t * (endPoint[0] - startPoint[0]),\n            startPoint[1] + t * (endPoint[1] - startPoint[1]),\n        ];\n        const insertIndex = this._controlPoints.indexOf(curveSegment.controlPoints.p1) + 1;\n        this._controlPoints.splice(insertIndex, 0, controlPointPos);\n        this.invalidated = true;\n        return {\n            index: insertIndex,\n            point: controlPointPos,\n        };\n    }\n    deleteControlPointByIndex(index) {\n        const minControlPoints = this._closed ? 3 : 1;\n        const canDelete = index >= 0 &&\n            index < this._controlPoints.length &&\n            this._controlPoints.length > minControlPoints;\n        if (!canDelete) {\n            return false;\n        }\n        this._controlPoints.splice(index, 1);\n        this.invalidated = true;\n        return true;\n    }\n    clearControlPoints() {\n        this._controlPoints = [];\n        this.invalidated = true;\n    }\n    setControlPoints(points) {\n        this.clearControlPoints();\n        this.addControlPoints(points);\n    }\n    updateControlPoint(index, newControlPoint) {\n        if (index < 0 || index >= this._controlPoints.length) {\n            throw new Error('Index out of bounds');\n        }\n        this._controlPoints[index] = [...newControlPoint];\n        this.invalidated = true;\n    }\n    getControlPoints() {\n        return this._controlPoints.map((controlPoint) => [\n            controlPoint[0],\n            controlPoint[1],\n        ]);\n    }\n    getClosestControlPoint(point) {\n        const controlPoints = this._controlPoints;\n        let minSquaredDist = Infinity;\n        let closestPointIndex = -1;\n        for (let i = 0, len = controlPoints.length; i < len; i++) {\n            const controlPoint = controlPoints[i];\n            const dx = point[0] - controlPoint[0];\n            const dy = point[1] - controlPoint[1];\n            const squaredDist = dx * dx + dy * dy;\n            if (squaredDist < minSquaredDist) {\n                minSquaredDist = squaredDist;\n                closestPointIndex = i;\n            }\n        }\n        return {\n            index: closestPointIndex,\n            point: closestPointIndex === -1\n                ? undefined\n                : [...controlPoints[closestPointIndex]],\n            distance: Math.sqrt(minSquaredDist),\n        };\n    }\n    getClosestControlPointWithinDistance(point, maxDist) {\n        const closestControlPoint = this.getClosestControlPoint(point);\n        return closestControlPoint.distance <= maxDist\n            ? closestControlPoint\n            : undefined;\n    }\n    getClosestPoint(point) {\n        this._update();\n        const curveSegmentsDistInfo = this._getCurveSegmmentsDistanceSquaredInfo(point);\n        if (!curveSegmentsDistInfo.length) {\n            return;\n        }\n        curveSegmentsDistInfo.sort((csA, csB) => csA.distanceSquared - csB.distanceSquared);\n        let closestPoint;\n        let closestPointCurveSegmentIndex = -1;\n        let minDistSquared = Infinity;\n        let minDistCurveSegment;\n        let minDistLineSegment;\n        for (let i = 0; i < curveSegmentsDistInfo.length; i++) {\n            const curveSegmentDistInfo = curveSegmentsDistInfo[i];\n            if (curveSegmentDistInfo.distanceSquared > minDistSquared) {\n                continue;\n            }\n            const { curveSegmentIndex, curveSegment } = curveSegmentDistInfo;\n            const { lineSegments } = curveSegment;\n            for (let j = 0; j < lineSegments.length; j++) {\n                const lineSegment = lineSegments[j];\n                const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = math.lineSegment.distanceToPointSquaredInfo(lineSegment.points.start, lineSegment.points.end, point);\n                if (lineSegDistSquared < minDistSquared) {\n                    minDistLineSegment = lineSegment;\n                    closestPointCurveSegmentIndex = curveSegmentIndex;\n                    minDistCurveSegment = curveSegmentDistInfo.curveSegment;\n                    closestPoint = lineSegPoint;\n                    minDistSquared = lineSegDistSquared;\n                }\n            }\n        }\n        const curveSegmentLengthToPoint = minDistLineSegment.previousLineSegmentsLength +\n            math.point.distanceToPoint(minDistLineSegment.points.start, closestPoint);\n        const t = curveSegmentLengthToPoint / minDistCurveSegment.length;\n        const u = closestPointCurveSegmentIndex + t;\n        return {\n            point: closestPoint,\n            uValue: u,\n            distance: Math.sqrt(minDistSquared),\n        };\n    }\n    getClosestPointOnControlPointLines(point) {\n        const linePoints = [...this._controlPoints];\n        if (this._closed) {\n            linePoints.push(this._controlPoints[0]);\n        }\n        if (!linePoints.length) {\n            return;\n        }\n        let closestPoint;\n        let minDistSquared = Infinity;\n        let startPoint = linePoints[0];\n        for (let i = 1, len = linePoints.length; i < len; i++) {\n            const endPoint = linePoints[i];\n            const { point: lineSegPoint, distanceSquared: lineSegDistSquared } = math.lineSegment.distanceToPointSquaredInfo(startPoint, endPoint, point);\n            if (lineSegDistSquared < minDistSquared) {\n                closestPoint = lineSegPoint;\n                minDistSquared = lineSegDistSquared;\n            }\n            startPoint = endPoint;\n        }\n        return {\n            point: closestPoint,\n            distance: Math.sqrt(minDistSquared),\n        };\n    }\n    getPolylinePoints() {\n        this._update();\n        return this._convertCurveSegmentsToPolyline(this._curveSegments);\n    }\n    getPreviewPolylinePoints(controlPointPreview, closeDistance) {\n        if (this._closed) {\n            return [];\n        }\n        this._update();\n        const closestControlPoint = this.getClosestControlPointWithinDistance(controlPointPreview, closeDistance);\n        const closeSpline = closestControlPoint?.index === 0;\n        const previewCurveSegments = this.getPreviewCurveSegments(controlPointPreview, closeSpline);\n        return previewCurveSegments?.length\n            ? this._convertCurveSegmentsToPolyline(previewCurveSegments)\n            : [];\n    }\n    isPointNearCurve(point, maxDist) {\n        this._update();\n        const curveSegments = this._getCurveSegmmentsWithinDistance(point, maxDist);\n        const maxDistSquared = maxDist * maxDist;\n        for (let i = 0; i < curveSegments.length; i++) {\n            const { lineSegments } = curveSegments[i];\n            for (let j = 0; j < lineSegments.length; j++) {\n                const lineSegment = lineSegments[j];\n                const lineDistSquared = math.lineSegment.distanceToPointSquared(lineSegment.points.start, lineSegment.points.end, point);\n                if (lineDistSquared <= maxDistSquared) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    containsPoint(point) {\n        this._update();\n        const controlPoints = this._controlPoints;\n        if (controlPoints.length < 3) {\n            return false;\n        }\n        const curveSegments = [...this._curveSegments];\n        const closingCurveSegment = this._getClosingCurveSegmentWithStraightLineSegment();\n        if (closingCurveSegment) {\n            curveSegments.push(closingCurveSegment);\n        }\n        let numIntersections = 0;\n        for (let i = 0; i < curveSegments.length; i++) {\n            const curveSegment = curveSegments[i];\n            const { aabb: curveSegAABB } = curveSegment;\n            const mayIntersectCurveSegment = point[0] <= curveSegAABB.maxX &&\n                point[1] >= curveSegAABB.minY &&\n                point[1] < curveSegAABB.maxY;\n            if (!mayIntersectCurveSegment) {\n                continue;\n            }\n            const { lineSegments } = curveSegment;\n            for (let i = 0; i < lineSegments.length; i++) {\n                const lineSegment = lineSegments[i];\n                const { aabb: lineSegmentAABB } = lineSegment;\n                const mayIntersectLineSegment = point[0] <= lineSegmentAABB.maxX &&\n                    point[1] >= lineSegmentAABB.minY &&\n                    point[1] < lineSegmentAABB.maxY;\n                if (mayIntersectLineSegment) {\n                    const { start: p1, end: p2 } = lineSegment.points;\n                    const isVerticalLine = p1[0] === p2[0];\n                    const xIntersection = ((point[1] - p1[1]) * (p2[0] - p1[0])) / (p2[1] - p1[1]) + p1[0];\n                    numIntersections +=\n                        isVerticalLine || point[0] <= xIntersection ? 1 : 0;\n                }\n            }\n        }\n        return numIntersections % 2 === 1;\n    }\n    _update() {\n        if (!this._invalidated) {\n            return;\n        }\n        const curveSegments = this.getSplineCurves();\n        let length = 0;\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n        for (let i = 0, len = curveSegments.length; i < len; i++) {\n            const { aabb: curveSegAABB, length: curveSegLength } = curveSegments[i];\n            minX = minX <= curveSegAABB.minX ? minX : curveSegAABB.minX;\n            minY = minY <= curveSegAABB.minY ? minY : curveSegAABB.minY;\n            maxX = maxX >= curveSegAABB.maxX ? maxX : curveSegAABB.maxX;\n            maxY = maxY >= curveSegAABB.maxY ? maxY : curveSegAABB.maxY;\n            length += curveSegLength;\n        }\n        this._curveSegments = curveSegments;\n        this._aabb = { minX, minY, maxX, maxY };\n        this._length = length;\n        this._invalidated = false;\n    }\n    _convertCurveSegmentsToPolyline(curveSegments) {\n        this._update();\n        const polylinePoints = [];\n        curveSegments.forEach(({ lineSegments }, curveSegIndex) => {\n            lineSegments.forEach((lineSegment, lineSegIndex) => {\n                if (curveSegIndex === 0 && lineSegIndex === 0) {\n                    polylinePoints.push([...lineSegment.points.start]);\n                }\n                polylinePoints.push([...lineSegment.points.end]);\n            });\n        });\n        return polylinePoints;\n    }\n    _getCurveSegmmentsDistanceSquaredInfo(point) {\n        this._update();\n        const curveSegmentsDistanceSquared = [];\n        const { _curveSegments: curveSegments } = this;\n        for (let i = 0; i < curveSegments.length; i++) {\n            const curveSegment = curveSegments[i];\n            const distanceSquared = math.aabb.distanceToPointSquared(curveSegment.aabb, point);\n            curveSegmentsDistanceSquared.push({\n                curveSegmentIndex: i,\n                curveSegment,\n                distanceSquared,\n            });\n        }\n        return curveSegmentsDistanceSquared;\n    }\n    _getCurveSegmmentsWithinDistance(point, maxDist) {\n        this._update();\n        const maxDistSquared = maxDist * maxDist;\n        if (math.aabb.distanceToPointSquared(this.aabb, point) > maxDistSquared) {\n            return [];\n        }\n        const curveSegmentsDistance = this._getCurveSegmmentsDistanceSquaredInfo(point);\n        const curveSegmentsWithinRange = [];\n        for (let i = 0, len = curveSegmentsDistance.length; i < len; i++) {\n            const { curveSegment, distanceSquared: curveSegmentDistSquared } = curveSegmentsDistance[i];\n            if (curveSegmentDistSquared <= maxDistSquared) {\n                curveSegmentsWithinRange.push(curveSegment);\n            }\n        }\n        return curveSegmentsWithinRange;\n    }\n    _getLineSegmentAt(u) {\n        this._update();\n        const curveSegmentIndex = Math.floor(u);\n        const t = u - curveSegmentIndex;\n        const curveSegment = this._curveSegments[curveSegmentIndex];\n        const { lineSegments } = curveSegment;\n        const pointLength = curveSegment.length * t;\n        for (let i = 0; i < lineSegments.length; i++) {\n            const lineSegment = lineSegments[i];\n            const lengthEnd = lineSegment.previousLineSegmentsLength + lineSegment.length;\n            if (pointLength >= lineSegment.previousLineSegmentsLength &&\n                pointLength <= lengthEnd) {\n                return lineSegment;\n            }\n        }\n    }\n    _getClosingCurveSegmentWithStraightLineSegment() {\n        if (this.closed) {\n            return;\n        }\n        const controlPoints = this._controlPoints;\n        const startControlPoint = controlPoints[0];\n        const endControlPoint = controlPoints[controlPoints.length - 1];\n        const closingLineSegment = {\n            points: {\n                start: [...startControlPoint],\n                end: [...endControlPoint],\n            },\n            aabb: {\n                minX: Math.min(startControlPoint[0], endControlPoint[0]),\n                minY: Math.min(startControlPoint[1], endControlPoint[1]),\n                maxX: Math.max(startControlPoint[0], endControlPoint[0]),\n                maxY: Math.max(startControlPoint[1], endControlPoint[1]),\n            },\n        };\n        return {\n            aabb: {\n                minX: closingLineSegment.aabb.minX,\n                minY: closingLineSegment.aabb.minY,\n                maxX: closingLineSegment.aabb.maxX,\n                maxY: closingLineSegment.aabb.maxY,\n            },\n            lineSegments: [closingLineSegment],\n        };\n    }\n}\nexport { Spline as default, Spline };\n","import { vec4 } from 'gl-matrix';\nimport { Spline } from './Spline';\nimport * as math from '../../../utilities/math';\nconst MAX_U_ERROR = 1e-8;\nclass CubicSpline extends Spline {\n    getPreviewCurveSegments(controlPointPreview, closeSpline) {\n        const previewNumCurveSegments = this._getNumCurveSegments() + 1;\n        const startCurveSegIndex = Math.max(0, previewNumCurveSegments - 2);\n        const endCurveSegIndex = closeSpline\n            ? previewNumCurveSegments\n            : previewNumCurveSegments - 1;\n        const transformMatrix = this.getTransformMatrix();\n        const controlPoints = [...this.controlPoints];\n        const curveSegments = [];\n        if (!closeSpline) {\n            controlPoints.push(controlPointPreview);\n        }\n        for (let i = startCurveSegIndex; i <= endCurveSegIndex; i++) {\n            const curveSegment = this._getCurveSegment(i, transformMatrix, controlPoints, closeSpline);\n            curveSegments.push(curveSegment);\n        }\n        return curveSegments;\n    }\n    getSplineCurves() {\n        const numCurveSegments = this._getNumCurveSegments();\n        const curveSegments = new Array(numCurveSegments);\n        if (numCurveSegments <= 0) {\n            return [];\n        }\n        const transformMatrix = this.getTransformMatrix();\n        let previousCurveSegmentsLength = 0;\n        for (let i = 0; i < numCurveSegments; i++) {\n            const curveSegment = this._getCurveSegment(i, transformMatrix);\n            curveSegment.previousCurveSegmentsLength = previousCurveSegmentsLength;\n            curveSegments[i] = curveSegment;\n            previousCurveSegmentsLength += curveSegment.length;\n        }\n        return curveSegments;\n    }\n    _getNumCurveSegments(controlPoints = this.controlPoints, closed = this.closed) {\n        return closed\n            ? controlPoints.length\n            : Math.max(0, controlPoints.length - 1);\n    }\n    _getPoint(u, transformMatrix, controlPoints = this.controlPoints, closed = this.closed) {\n        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n        const uInt = Math.floor(u);\n        let curveSegmentIndex = uInt % numCurveSegments;\n        const t = u - uInt;\n        const curveSegmentIndexOutOfBounds = curveSegmentIndex < 0 || curveSegmentIndex >= numCurveSegments;\n        if (curveSegmentIndexOutOfBounds) {\n            if (this.closed) {\n                curveSegmentIndex =\n                    (numCurveSegments + curveSegmentIndex) % numCurveSegments;\n            }\n            else {\n                return;\n            }\n        }\n        const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed);\n        const tt = t * t;\n        const ttt = tt * t;\n        const tValues = vec4.fromValues(1, t, tt, ttt);\n        const qValues = vec4.transformMat4(vec4.create(), tValues, transformMatrix);\n        return [\n            vec4.dot(qValues, vec4.fromValues(p0[0], p1[0], p2[0], p3[0])),\n            vec4.dot(qValues, vec4.fromValues(p0[1], p1[1], p2[1], p3[1])),\n        ];\n    }\n    _getCurveSegmentPoints(curveSegmentIndex, controlPoints = this.controlPoints, closed = this.closed) {\n        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n        const p1Index = curveSegmentIndex;\n        const p0Index = p1Index - 1;\n        const p2Index = closed ? (p1Index + 1) % numCurveSegments : p1Index + 1;\n        const p3Index = p2Index + 1;\n        const p1 = controlPoints[p1Index];\n        const p2 = controlPoints[p2Index];\n        let p0;\n        let p3;\n        if (p0Index >= 0) {\n            p0 = controlPoints[p0Index];\n        }\n        else {\n            p0 = closed\n                ? controlPoints[controlPoints.length - 1]\n                : math.point.mirror(p2, p1);\n        }\n        if (p3Index < controlPoints.length) {\n            p3 = controlPoints[p3Index];\n        }\n        else {\n            p3 = closed ? controlPoints[0] : math.point.mirror(p1, p2);\n        }\n        return { p0, p1, p2, p3 };\n    }\n    _getLineSegments(curveSegmentIndex, transformMatrix, controlPoints = this.controlPoints, closed = this.closed) {\n        const numCurveSegments = this._getNumCurveSegments(controlPoints, closed);\n        const numLineSegments = this.resolution + 1;\n        const inc = 1 / numLineSegments;\n        const minU = curveSegmentIndex;\n        let maxU = minU + 1;\n        if (!closed && curveSegmentIndex === numCurveSegments - 1) {\n            maxU -= MAX_U_ERROR;\n        }\n        const lineSegments = [];\n        let startPoint;\n        let endPoint;\n        let previousLineSegmentsLength = 0;\n        for (let i = 0, u = minU; i <= numLineSegments; i++, u += inc) {\n            u = u > maxU ? maxU : u;\n            const point = this._getPoint(u, transformMatrix, controlPoints, closed);\n            if (!i) {\n                startPoint = point;\n                continue;\n            }\n            endPoint = point;\n            const dx = endPoint[0] - startPoint[0];\n            const dy = endPoint[1] - startPoint[1];\n            const length = Math.sqrt(dx ** 2 + dy ** 2);\n            const aabb = {\n                minX: startPoint[0] <= endPoint[0] ? startPoint[0] : endPoint[0],\n                maxX: startPoint[0] >= endPoint[0] ? startPoint[0] : endPoint[0],\n                minY: startPoint[1] <= endPoint[1] ? startPoint[1] : endPoint[1],\n                maxY: startPoint[1] >= endPoint[1] ? startPoint[1] : endPoint[1],\n            };\n            lineSegments.push({\n                points: {\n                    start: startPoint,\n                    end: endPoint,\n                },\n                aabb,\n                length,\n                previousLineSegmentsLength,\n            });\n            startPoint = endPoint;\n            previousLineSegmentsLength += length;\n        }\n        return lineSegments;\n    }\n    _getCurveSegment(curveSegmentIndex, transformMatrix = this.getTransformMatrix(), controlPoints = this.controlPoints, closed = this.closed) {\n        const { p0, p1, p2, p3 } = this._getCurveSegmentPoints(curveSegmentIndex, controlPoints, closed);\n        const lineSegments = this._getLineSegments(curveSegmentIndex, transformMatrix, controlPoints, closed);\n        let curveSegmentLength = 0;\n        let minX = Infinity;\n        let minY = Infinity;\n        let maxX = -Infinity;\n        let maxY = -Infinity;\n        lineSegments.forEach(({ aabb: lineSegAABB, length: lineSegLength }) => {\n            minX = Math.min(minX, lineSegAABB.minX);\n            minY = Math.min(minY, lineSegAABB.minY);\n            maxX = Math.max(maxX, lineSegAABB.maxX);\n            maxY = Math.max(maxY, lineSegAABB.maxY);\n            curveSegmentLength += lineSegLength;\n        });\n        return {\n            controlPoints: { p0, p1, p2, p3 },\n            aabb: { minX, minY, maxX, maxY },\n            length: curveSegmentLength,\n            previousCurveSegmentsLength: 0,\n            lineSegments,\n        };\n    }\n}\nexport { CubicSpline as default, CubicSpline };\n","import { mat4 } from 'gl-matrix';\nimport { CubicSpline } from './CubicSpline';\nconst TRANSFORM_MATRIX = mat4.multiplyScalar(mat4.create(), mat4.fromValues(1, 4, 1, 0, -3, 0, 3, 0, 3, -6, 3, 0, -1, 3, -3, 1), 1 / 6);\nclass BSpline extends CubicSpline {\n    getTransformMatrix() {\n        return TRANSFORM_MATRIX;\n    }\n}\nexport { BSpline as default, BSpline };\n","import { CubicSpline } from './CubicSpline';\nclass CardinalSpline extends CubicSpline {\n    constructor(props) {\n        super(props);\n        this._scale = props?.scale ?? 0.5;\n        this._fixedScale = props?.fixedScale ?? false;\n    }\n    get scale() {\n        return this._scale;\n    }\n    set scale(scale) {\n        if (this._fixedScale || this._scale === scale) {\n            return;\n        }\n        this._scale = scale;\n        this.invalidated = true;\n    }\n    get fixedScale() {\n        return this._fixedScale;\n    }\n    getTransformMatrix() {\n        const { scale: s } = this;\n        const s2 = 2 * s;\n        return [\n            0, 1, 0, 0,\n            -s, 0, s, 0,\n            s2, s - 3, 3 - s2, -s,\n            -s, 2 - s, s - 2, s\n        ];\n    }\n}\nexport { CardinalSpline as default, CardinalSpline };\n","import { CardinalSpline } from './CardinalSpline';\nclass CatmullRomSpline extends CardinalSpline {\n    constructor() {\n        super({ scale: 0.5, fixedScale: true });\n    }\n}\nexport { CatmullRomSpline as default, CatmullRomSpline };\n","import { CardinalSpline } from './CardinalSpline';\nclass LinearSpline extends CardinalSpline {\n    constructor() {\n        super({ resolution: 0, fixedResolution: true, scale: 0, fixedScale: true });\n    }\n}\nexport { LinearSpline as default, LinearSpline };\n","import { BaseTool } from './base';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nclass PanTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            limitToViewport: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    touchDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    mouseDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    _checkImageInViewport(viewport, deltaPointsCanvas) {\n        const { canvas } = viewport;\n        const ratio = window.devicePixelRatio;\n        const viewportLeft = 0;\n        const viewportRight = canvas.width / ratio;\n        const viewportTop = 0;\n        const viewportBottom = canvas.height / ratio;\n        const defaultActor = viewport.getDefaultActor();\n        const renderer = viewport.getRenderer();\n        let bounds;\n        if (defaultActor && csUtils.isImageActor(defaultActor)) {\n            const imageData = defaultActor.actor.getMapper().getInputData();\n            bounds = imageData.getBounds();\n        }\n        else {\n            bounds = renderer.computeVisiblePropBounds();\n        }\n        const [imageLeft, imageTop] = viewport.worldToCanvas([\n            bounds[0],\n            bounds[2],\n            bounds[4],\n        ]);\n        const [imageRight, imageBottom] = viewport.worldToCanvas([\n            bounds[1],\n            bounds[3],\n            bounds[5],\n        ]);\n        const zoom = viewport.getZoom();\n        if (zoom <= 1) {\n            if ((imageLeft + deltaPointsCanvas[0] < viewportLeft &&\n                deltaPointsCanvas[0] < 0) ||\n                (imageRight + deltaPointsCanvas[0] > viewportRight &&\n                    deltaPointsCanvas[0] > 0) ||\n                (imageTop + deltaPointsCanvas[1] < viewportTop &&\n                    deltaPointsCanvas[1] < 0) ||\n                (imageBottom + deltaPointsCanvas[1] > viewportBottom &&\n                    deltaPointsCanvas[1] > 0)) {\n                return false;\n            }\n        }\n        else {\n            if ((imageLeft + deltaPointsCanvas[0] > viewportLeft &&\n                deltaPointsCanvas[0] > 0) ||\n                (imageRight + deltaPointsCanvas[0] < viewportRight &&\n                    deltaPointsCanvas[0] < 0) ||\n                (imageTop + deltaPointsCanvas[1] > viewportTop &&\n                    deltaPointsCanvas[1] > 0) ||\n                (imageBottom + deltaPointsCanvas[1] < viewportBottom &&\n                    deltaPointsCanvas[1] < 0)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _dragCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const deltaPointsWorld = deltaPoints.world;\n        const deltaPointsCanvas = deltaPoints.canvas;\n        if (deltaPointsWorld[0] === 0 &&\n            deltaPointsWorld[1] === 0 &&\n            deltaPointsWorld[2] === 0) {\n            return;\n        }\n        const viewport = enabledElement.viewport;\n        const camera = viewport.getCamera();\n        const { focalPoint, position } = camera;\n        if (this.configuration.limitToViewport &&\n            !this._checkImageInViewport(viewport, deltaPointsCanvas)) {\n            return;\n        }\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        viewport.render();\n    }\n}\nPanTool.toolName = 'Pan';\nexport default PanTool;\n","import vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { Events } from '../enums';\nimport { eventTarget, getEnabledElement, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport { getToolGroup } from '../store/ToolGroupManager';\nclass TrackballRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            rotateIncrementDegrees: 2,\n            rotateSampleDistanceFactor: 2,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._resizeObservers = new Map();\n        this._hasResolutionChanged = false;\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const actorEntry = viewport.getDefaultActor();\n            const actor = actorEntry.actor;\n            const mapper = actor.getMapper();\n            const hasSampleDistance = 'getSampleDistance' in mapper || 'getCurrentSampleDistance' in mapper;\n            if (!hasSampleDistance) {\n                return true;\n            }\n            const originalSampleDistance = mapper.getSampleDistance();\n            if (!this._hasResolutionChanged) {\n                const { rotateSampleDistanceFactor } = this.configuration;\n                mapper.setSampleDistance(originalSampleDistance * rotateSampleDistanceFactor);\n                this._hasResolutionChanged = true;\n                if (this.cleanUp !== null) {\n                    document.removeEventListener('mouseup', this.cleanUp);\n                }\n                this.cleanUp = () => {\n                    mapper.setSampleDistance(originalSampleDistance);\n                    viewport.render();\n                    this._hasResolutionChanged = false;\n                };\n                document.addEventListener('mouseup', this.cleanUp, { once: true });\n            }\n            return true;\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.onSetToolActive = () => {\n            const subscribeToElementResize = () => {\n                const viewportsInfo = this._getViewportsInfo();\n                viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                    if (!this._resizeObservers.has(viewportId)) {\n                        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId) || { viewport: null };\n                        if (!viewport) {\n                            return;\n                        }\n                        const { element } = viewport;\n                        const resizeObserver = new ResizeObserver(() => {\n                            const element = getEnabledElementByIds(viewportId, renderingEngineId);\n                            if (!element) {\n                                return;\n                            }\n                            const { viewport } = element;\n                            const viewPresentation = viewport.getViewPresentation();\n                            viewport.resetCamera();\n                            viewport.setViewPresentation(viewPresentation);\n                            viewport.render();\n                        });\n                        resizeObserver.observe(element);\n                        this._resizeObservers.set(viewportId, resizeObserver);\n                    }\n                });\n            };\n            subscribeToElementResize();\n            this._viewportAddedListener = (evt) => {\n                if (evt.detail.toolGroupId === this.toolGroupId) {\n                    subscribeToElementResize();\n                }\n            };\n            eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n        };\n        this.onSetToolDisabled = () => {\n            this._resizeObservers.forEach((resizeObserver, viewportId) => {\n                resizeObserver.disconnect();\n                this._resizeObservers.delete(viewportId);\n            });\n            if (this._viewportAddedListener) {\n                eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n                this._viewportAddedListener = null;\n            }\n        };\n        this.rotateCamera = (viewport, centerWorld, axis, angle) => {\n            const vtkCamera = viewport.getVtkActiveCamera();\n            const viewUp = vtkCamera.getViewUp();\n            const focalPoint = vtkCamera.getFocalPoint();\n            const position = vtkCamera.getPosition();\n            const newPosition = [0, 0, 0];\n            const newFocalPoint = [0, 0, 0];\n            const newViewUp = [0, 0, 0];\n            const transform = mat4.identity(new Float32Array(16));\n            mat4.translate(transform, transform, centerWorld);\n            mat4.rotate(transform, transform, angle, axis);\n            mat4.translate(transform, transform, [\n                -centerWorld[0],\n                -centerWorld[1],\n                -centerWorld[2],\n            ]);\n            vec3.transformMat4(newPosition, position, transform);\n            vec3.transformMat4(newFocalPoint, focalPoint, transform);\n            mat4.identity(transform);\n            mat4.rotate(transform, transform, angle, axis);\n            vec3.transformMat4(newViewUp, viewUp, transform);\n            viewport.setCamera({\n                position: newPosition,\n                viewUp: newViewUp,\n                focalPoint: newFocalPoint,\n            });\n        };\n        this.touchDragCallback = this._dragCallback.bind(this);\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    _dragCallback(evt) {\n        const { element, currentPoints, lastPoints } = evt.detail;\n        const currentPointsCanvas = currentPoints.canvas;\n        const lastPointsCanvas = lastPoints.canvas;\n        const { rotateIncrementDegrees } = this.configuration;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const width = element.clientWidth;\n        const height = element.clientHeight;\n        const normalizedPosition = [\n            currentPointsCanvas[0] / width,\n            currentPointsCanvas[1] / height,\n        ];\n        const normalizedPreviousPosition = [\n            lastPointsCanvas[0] / width,\n            lastPointsCanvas[1] / height,\n        ];\n        const center = [width * 0.5, height * 0.5];\n        const centerWorld = viewport.canvasToWorld(center);\n        const normalizedCenter = [0.5, 0.5];\n        const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n        const op = [normalizedPreviousPosition[0], 0, 0];\n        const oe = [normalizedPosition[0], 0, 0];\n        const opsq = op[0] ** 2;\n        const oesq = oe[0] ** 2;\n        const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n        const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n        const nop = [op[0], 0, lop];\n        vtkMath.normalize(nop);\n        const noe = [oe[0], 0, loe];\n        vtkMath.normalize(noe);\n        const dot = vtkMath.dot(nop, noe);\n        if (Math.abs(dot) > 0.0001) {\n            const angleX = -2 *\n                Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\n                Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\n                rotateIncrementDegrees;\n            const upVec = camera.viewUp;\n            const atV = camera.viewPlaneNormal;\n            const rightV = [0, 0, 0];\n            const forwardV = [0, 0, 0];\n            vtkMath.cross(upVec, atV, rightV);\n            vtkMath.normalize(rightV);\n            vtkMath.cross(atV, rightV, forwardV);\n            vtkMath.normalize(forwardV);\n            vtkMath.normalize(upVec);\n            this.rotateCamera(viewport, centerWorld, forwardV, angleX);\n            const angleY = (normalizedPreviousPosition[1] - normalizedPosition[1]) *\n                rotateIncrementDegrees;\n            this.rotateCamera(viewport, centerWorld, rightV, angleY);\n            viewport.render();\n        }\n    }\n}\nTrackballRotateTool.toolName = 'TrackballRotate';\nexport default TrackballRotateTool;\n","import vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkPoints from '@kitware/vtk.js/Common/Core/Points';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkSphereSource from '@kitware/vtk.js/Filters/Sources/SphereSource';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkPlane from '@kitware/vtk.js/Common/DataModel/Plane';\nimport { BaseTool } from './base';\nimport { getRenderingEngine, getEnabledElementByIds, getEnabledElement, Enums, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport { Events } from '../enums';\nconst PLANEINDEX = {\n    XMIN: 0,\n    XMAX: 1,\n    YMIN: 2,\n    YMAX: 3,\n    ZMIN: 4,\n    ZMAX: 5,\n};\nconst SPHEREINDEX = {\n    XMIN: 0,\n    XMAX: 1,\n    YMIN: 2,\n    YMAX: 3,\n    ZMIN: 4,\n    ZMAX: 5,\n    XMIN_YMIN_ZMIN: 6,\n    XMIN_YMIN_ZMAX: 7,\n    XMIN_YMAX_ZMIN: 8,\n    XMIN_YMAX_ZMAX: 9,\n    XMAX_YMIN_ZMIN: 10,\n    XMAX_YMIN_ZMAX: 11,\n    XMAX_YMAX_ZMIN: 12,\n    XMAX_YMAX_ZMAX: 13,\n};\nclass VolumeCroppingTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            showCornerSpheres: true,\n            showHandles: true,\n            showClippingPlanes: true,\n            mobile: {\n                enabled: false,\n                opacity: 0.8,\n            },\n            initialCropFactor: 0.08,\n            sphereColors: {\n                SAGITTAL: [1.0, 1.0, 0.0],\n                CORONAL: [0.0, 1.0, 0.0],\n                AXIAL: [1.0, 0.0, 0.0],\n                CORNERS: [0.0, 0.0, 1.0],\n            },\n            sphereRadius: 8,\n            grabSpherePixelDistance: 20,\n            rotateIncrementDegrees: 2,\n            rotateSampleDistanceFactor: 2,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._resizeObservers = new Map();\n        this._hasResolutionChanged = false;\n        this.originalClippingPlanes = [];\n        this.draggingSphereIndex = null;\n        this.toolCenter = [0, 0, 0];\n        this.cornerDragOffset = null;\n        this.faceDragOffset = null;\n        this.sphereStates = [];\n        this.edgeLines = {};\n        this.onSetToolConfiguration = () => {\n            console.debug('Setting tool settoolconfiguration : volumeCropping');\n        };\n        this.onSetToolEnabled = () => {\n            console.debug('Setting tool enabled: volumeCropping');\n        };\n        this.onCameraModified = (evt) => {\n            const { element } = evt.currentTarget\n                ? { element: evt.currentTarget }\n                : evt.detail;\n            const enabledElement = getEnabledElement(element);\n            this._updateClippingPlanes(enabledElement.viewport);\n            enabledElement.viewport.render();\n        };\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const actorEntry = viewport.getDefaultActor();\n            const actor = actorEntry.actor;\n            const mapper = actor.getMapper();\n            const mouseCanvas = [\n                evt.detail.currentPoints.canvas[0],\n                evt.detail.currentPoints.canvas[1],\n            ];\n            this.draggingSphereIndex = null;\n            this.cornerDragOffset = null;\n            this.faceDragOffset = null;\n            for (let i = 0; i < this.sphereStates.length; ++i) {\n                const sphereCanvas = viewport.worldToCanvas(this.sphereStates[i].point);\n                const dist = Math.sqrt(Math.pow(mouseCanvas[0] - sphereCanvas[0], 2) +\n                    Math.pow(mouseCanvas[1] - sphereCanvas[1], 2));\n                if (dist < this.configuration.grabSpherePixelDistance) {\n                    this.draggingSphereIndex = i;\n                    element.style.cursor = 'grabbing';\n                    const sphereState = this.sphereStates[i];\n                    const mouseWorld = viewport.canvasToWorld(mouseCanvas);\n                    if (sphereState.isCorner) {\n                        this.cornerDragOffset = [\n                            sphereState.point[0] - mouseWorld[0],\n                            sphereState.point[1] - mouseWorld[1],\n                            sphereState.point[2] - mouseWorld[2],\n                        ];\n                        this.faceDragOffset = null;\n                    }\n                    else {\n                        const axisIdx = { x: 0, y: 1, z: 2 }[sphereState.axis];\n                        this.faceDragOffset =\n                            sphereState.point[axisIdx] - mouseWorld[axisIdx];\n                        this.cornerDragOffset = null;\n                    }\n                    return true;\n                }\n            }\n            const hasSampleDistance = 'getSampleDistance' in mapper || 'getCurrentSampleDistance' in mapper;\n            if (!hasSampleDistance) {\n                return true;\n            }\n            const originalSampleDistance = mapper.getSampleDistance();\n            if (!this._hasResolutionChanged) {\n                const { rotateSampleDistanceFactor } = this.configuration;\n                mapper.setSampleDistance(originalSampleDistance * rotateSampleDistanceFactor);\n                this._hasResolutionChanged = true;\n                if (this.cleanUp !== null) {\n                    document.removeEventListener('mouseup', this.cleanUp);\n                }\n                this.cleanUp = () => {\n                    mapper.setSampleDistance(originalSampleDistance);\n                    evt.target.style.cursor = '';\n                    if (this.draggingSphereIndex !== null) {\n                        const sphereState = this.sphereStates[this.draggingSphereIndex];\n                        const [viewport3D] = this._getViewportsInfo();\n                        const renderingEngine = getRenderingEngine(viewport3D.renderingEngineId);\n                        const viewport = renderingEngine.getViewport(viewport3D.viewportId);\n                        if (sphereState.isCorner) {\n                            this._updateCornerSpheres();\n                            this._updateFaceSpheresFromCorners();\n                            this._updateClippingPlanesFromFaceSpheres(viewport);\n                        }\n                    }\n                    this.draggingSphereIndex = null;\n                    this.cornerDragOffset = null;\n                    this.faceDragOffset = null;\n                    viewport.render();\n                    this._hasResolutionChanged = false;\n                };\n                document.addEventListener('mouseup', this.cleanUp, { once: true });\n            }\n            return true;\n        };\n        this._onMouseMoveSphere = (evt) => {\n            if (this.draggingSphereIndex === null) {\n                return false;\n            }\n            const sphereState = this.sphereStates[this.draggingSphereIndex];\n            if (!sphereState) {\n                return false;\n            }\n            const { viewport, world } = this._getViewportAndWorldCoords(evt);\n            if (!viewport || !world) {\n                return false;\n            }\n            if (sphereState.isCorner) {\n                const newCorner = this._calculateNewCornerPosition(world);\n                this._updateSpherePosition(sphereState, newCorner);\n                const axisFlags = this._parseCornerKey(sphereState.uid);\n                this._updateRelatedCorners(sphereState, newCorner, axisFlags);\n                this._updateFaceSpheresFromCorners();\n                this._updateCornerSpheres();\n            }\n            else {\n                const axisIdx = { x: 0, y: 1, z: 2 }[sphereState.axis];\n                let newValue = world[axisIdx];\n                if (this.faceDragOffset !== null) {\n                    newValue += this.faceDragOffset;\n                }\n                sphereState.point[axisIdx] = newValue;\n                sphereState.sphereSource.setCenter(...sphereState.point);\n                sphereState.sphereSource.modified();\n                this._updateCornerSpheresFromFaces();\n                this._updateFaceSpheresFromCorners();\n                this._updateCornerSpheres();\n            }\n            this._updateClippingPlanesFromFaceSpheres(viewport);\n            viewport.render();\n            this._triggerToolChangedEvent(sphereState);\n            return true;\n        };\n        this._onControlToolChange = (evt) => {\n            const viewport = this._getViewport();\n            if (!evt.detail.toolCenter) {\n                triggerEvent(eventTarget, Events.VOLUMECROPPING_TOOL_CHANGED, {\n                    originalClippingPlanes: this.originalClippingPlanes,\n                    viewportId: viewport.id,\n                    renderingEngineId: viewport.renderingEngineId,\n                    seriesInstanceUID: this.seriesInstanceUID,\n                });\n            }\n            else {\n                if (evt.detail.seriesInstanceUID !== this.seriesInstanceUID) {\n                    return;\n                }\n                const isMin = evt.detail.handleType === 'min';\n                const toolCenter = isMin\n                    ? evt.detail.toolCenterMin\n                    : evt.detail.toolCenterMax;\n                const normals = isMin\n                    ? [\n                        [1, 0, 0],\n                        [0, 1, 0],\n                        [0, 0, 1],\n                    ]\n                    : [\n                        [-1, 0, 0],\n                        [0, -1, 0],\n                        [0, 0, -1],\n                    ];\n                const planeIndices = isMin\n                    ? [PLANEINDEX.XMIN, PLANEINDEX.YMIN, PLANEINDEX.ZMIN]\n                    : [PLANEINDEX.XMAX, PLANEINDEX.YMAX, PLANEINDEX.ZMAX];\n                const sphereIndices = isMin\n                    ? [SPHEREINDEX.XMIN, SPHEREINDEX.YMIN, SPHEREINDEX.ZMIN]\n                    : [SPHEREINDEX.XMAX, SPHEREINDEX.YMAX, SPHEREINDEX.ZMAX];\n                const axes = ['x', 'y', 'z'];\n                const orientationAxes = [\n                    Enums.OrientationAxis.SAGITTAL,\n                    Enums.OrientationAxis.CORONAL,\n                    Enums.OrientationAxis.AXIAL,\n                ];\n                for (let i = 0; i < 3; ++i) {\n                    const origin = [0, 0, 0];\n                    origin[i] = toolCenter[i];\n                    const plane = vtkPlane.newInstance({\n                        origin,\n                        normal: normals[i],\n                    });\n                    this.originalClippingPlanes[planeIndices[i]].origin = plane.getOrigin();\n                    this.sphereStates[sphereIndices[i]].point[i] = plane.getOrigin()[i];\n                    this.sphereStates[sphereIndices[i]].sphereSource.setCenter(...this.sphereStates[sphereIndices[i]].point);\n                    this.sphereStates[sphereIndices[i]].sphereSource.modified();\n                    const otherSphere = this.sphereStates.find((s, idx) => s.axis === axes[i] && idx !== sphereIndices[i]);\n                    const newCenter = (otherSphere.point[i] + plane.getOrigin()[i]) / 2;\n                    this.sphereStates.forEach((state) => {\n                        if (!state.isCorner &&\n                            state.axis !== axes[i] &&\n                            !evt.detail.viewportOrientation.includes(orientationAxes[i])) {\n                            state.point[i] = newCenter;\n                            state.sphereSource.setCenter(state.point);\n                            state.sphereActor.getProperty().setColor(state.color);\n                            state.sphereSource.modified();\n                        }\n                    });\n                    const volumeActor = viewport.getDefaultActor()?.actor;\n                    if (volumeActor) {\n                        const mapper = volumeActor.getMapper();\n                        const clippingPlanes = mapper.getClippingPlanes();\n                        if (clippingPlanes) {\n                            clippingPlanes[planeIndices[i]].setOrigin(plane.getOrigin());\n                        }\n                    }\n                }\n                this._updateCornerSpheres();\n                viewport.render();\n            }\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this._initialize3DViewports = (viewportsInfo) => {\n            if (!viewportsInfo || !viewportsInfo.length || !viewportsInfo[0]) {\n                console.warn('VolumeCroppingTool: No viewportsInfo available for initialization of volumecroppingtool.');\n                return;\n            }\n            const viewport = this._getViewport();\n            const volumeActors = viewport.getActors();\n            if (!volumeActors || volumeActors.length === 0) {\n                console.warn('VolumeCroppingTool: No volume actors found in the viewport.');\n                return;\n            }\n            const imageData = volumeActors[0].actor.getMapper().getInputData();\n            if (!imageData) {\n                console.warn('VolumeCroppingTool: No image data found for volume actor.');\n                return;\n            }\n            this.seriesInstanceUID = imageData.seriesInstanceUID || 'unknown';\n            const worldBounds = imageData.getBounds();\n            const cropFactor = this.configuration.initialCropFactor || 0.1;\n            const xRange = worldBounds[1] - worldBounds[0];\n            const yRange = worldBounds[3] - worldBounds[2];\n            const zRange = worldBounds[5] - worldBounds[4];\n            const xMin = worldBounds[0] + cropFactor * xRange;\n            const xMax = worldBounds[1] - cropFactor * xRange;\n            const yMin = worldBounds[2] + cropFactor * yRange;\n            const yMax = worldBounds[3] - cropFactor * yRange;\n            const zMin = worldBounds[4] + cropFactor * zRange;\n            const zMax = worldBounds[5] - cropFactor * zRange;\n            const planes = [];\n            const planeXmin = vtkPlane.newInstance({\n                origin: [xMin, 0, 0],\n                normal: [1, 0, 0],\n            });\n            const planeXmax = vtkPlane.newInstance({\n                origin: [xMax, 0, 0],\n                normal: [-1, 0, 0],\n            });\n            const planeYmin = vtkPlane.newInstance({\n                origin: [0, yMin, 0],\n                normal: [0, 1, 0],\n            });\n            const planeYmax = vtkPlane.newInstance({\n                origin: [0, yMax, 0],\n                normal: [0, -1, 0],\n            });\n            const planeZmin = vtkPlane.newInstance({\n                origin: [0, 0, zMin],\n                normal: [0, 0, 1],\n            });\n            const planeZmax = vtkPlane.newInstance({\n                origin: [0, 0, zMax],\n                normal: [0, 0, -1],\n            });\n            const mapper = viewport\n                .getDefaultActor()\n                .actor.getMapper();\n            planes.push(planeXmin);\n            planes.push(planeXmax);\n            planes.push(planeYmin);\n            planes.push(planeYmax);\n            planes.push(planeZmin);\n            planes.push(planeZmax);\n            const originalPlanes = planes.map((plane) => ({\n                origin: [...plane.getOrigin()],\n                normal: [...plane.getNormal()],\n            }));\n            this.originalClippingPlanes = originalPlanes;\n            const sphereXminPoint = [xMin, (yMax + yMin) / 2, (zMax + zMin) / 2];\n            const sphereXmaxPoint = [xMax, (yMax + yMin) / 2, (zMax + zMin) / 2];\n            const sphereYminPoint = [(xMax + xMin) / 2, yMin, (zMax + zMin) / 2];\n            const sphereYmaxPoint = [(xMax + xMin) / 2, yMax, (zMax + zMin) / 2];\n            const sphereZminPoint = [(xMax + xMin) / 2, (yMax + yMin) / 2, zMin];\n            const sphereZmaxPoint = [(xMax + xMin) / 2, (yMax + yMin) / 2, zMax];\n            const adaptiveRadius = this._calculateAdaptiveSphereRadius(Math.sqrt(xRange * xRange + yRange * yRange + zRange * zRange));\n            this._addSphere(viewport, sphereXminPoint, 'x', 'min', null, adaptiveRadius);\n            this._addSphere(viewport, sphereXmaxPoint, 'x', 'max', null, adaptiveRadius);\n            this._addSphere(viewport, sphereYminPoint, 'y', 'min', null, adaptiveRadius);\n            this._addSphere(viewport, sphereYmaxPoint, 'y', 'max', null, adaptiveRadius);\n            this._addSphere(viewport, sphereZminPoint, 'z', 'min', null, adaptiveRadius);\n            this._addSphere(viewport, sphereZmaxPoint, 'z', 'max', null, adaptiveRadius);\n            const corners = [\n                [xMin, yMin, zMin],\n                [xMin, yMin, zMax],\n                [xMin, yMax, zMin],\n                [xMin, yMax, zMax],\n                [xMax, yMin, zMin],\n                [xMax, yMin, zMax],\n                [xMax, yMax, zMin],\n                [xMax, yMax, zMax],\n            ];\n            const cornerKeys = [\n                'XMIN_YMIN_ZMIN',\n                'XMIN_YMIN_ZMAX',\n                'XMIN_YMAX_ZMIN',\n                'XMIN_YMAX_ZMAX',\n                'XMAX_YMIN_ZMIN',\n                'XMAX_YMIN_ZMAX',\n                'XMAX_YMAX_ZMIN',\n                'XMAX_YMAX_ZMAX',\n            ];\n            for (let i = 0; i < corners.length; i++) {\n                this._addSphere(viewport, corners[i], 'corner', null, cornerKeys[i], adaptiveRadius);\n            }\n            const edgeCornerPairs = [\n                ['XMIN_YMIN_ZMIN', 'XMAX_YMIN_ZMIN'],\n                ['XMIN_YMIN_ZMAX', 'XMAX_YMIN_ZMAX'],\n                ['XMIN_YMAX_ZMIN', 'XMAX_YMAX_ZMIN'],\n                ['XMIN_YMAX_ZMAX', 'XMAX_YMAX_ZMAX'],\n                ['XMIN_YMIN_ZMIN', 'XMIN_YMAX_ZMIN'],\n                ['XMIN_YMIN_ZMAX', 'XMIN_YMAX_ZMAX'],\n                ['XMAX_YMIN_ZMIN', 'XMAX_YMAX_ZMIN'],\n                ['XMAX_YMIN_ZMAX', 'XMAX_YMAX_ZMAX'],\n                ['XMIN_YMIN_ZMIN', 'XMIN_YMIN_ZMAX'],\n                ['XMIN_YMAX_ZMIN', 'XMIN_YMAX_ZMAX'],\n                ['XMAX_YMIN_ZMIN', 'XMAX_YMIN_ZMAX'],\n                ['XMAX_YMAX_ZMIN', 'XMAX_YMAX_ZMAX'],\n            ];\n            edgeCornerPairs.forEach(([key1, key2], i) => {\n                const state1 = this.sphereStates.find((s) => s.uid === `corner_${key1}`);\n                const state2 = this.sphereStates.find((s) => s.uid === `corner_${key2}`);\n                if (state1 && state2) {\n                    const uid = `edge_${key1}_${key2}`;\n                    const { actor, source } = this._addLine3DBetweenPoints(viewport, state1.point, state2.point, [0.7, 0.7, 0.7], uid);\n                    this.edgeLines[uid] = { actor, source, key1, key2 };\n                }\n            });\n            mapper.addClippingPlane(planeXmin);\n            mapper.addClippingPlane(planeXmax);\n            mapper.addClippingPlane(planeYmin);\n            mapper.addClippingPlane(planeYmax);\n            mapper.addClippingPlane(planeZmin);\n            mapper.addClippingPlane(planeZmax);\n            eventTarget.addEventListener(Events.VOLUMECROPPINGCONTROL_TOOL_CHANGED, (evt) => {\n                this._onControlToolChange(evt);\n            });\n            viewport.render();\n        };\n        this._getViewportAndWorldCoords = (evt) => {\n            const viewport = this._getViewport();\n            const x = evt.detail.currentPoints.canvas[0];\n            const y = evt.detail.currentPoints.canvas[1];\n            const world = viewport.canvasToWorld([x, y]);\n            return { viewport, world };\n        };\n        this._getViewport = () => {\n            const [viewport3D] = this._getViewportsInfo();\n            const renderingEngine = getRenderingEngine(viewport3D.renderingEngineId);\n            return renderingEngine.getViewport(viewport3D.viewportId);\n        };\n        this._handleCornerSphereMovement = (sphereState, world, viewport) => {\n            const newCorner = this._calculateNewCornerPosition(world);\n            this._updateSpherePosition(sphereState, newCorner);\n            const axisFlags = this._parseCornerKey(sphereState.uid);\n            this._updateRelatedCorners(sphereState, newCorner, axisFlags);\n            this._updateAfterCornerMovement(viewport);\n        };\n        this._handleFaceSphereMovement = (sphereState, world, viewport) => {\n            const axisIdx = { x: 0, y: 1, z: 2 }[sphereState.axis];\n            let newValue = world[axisIdx];\n            if (this.faceDragOffset !== null) {\n                newValue += this.faceDragOffset;\n            }\n            sphereState.point[axisIdx] = newValue;\n            sphereState.sphereSource.setCenter(...sphereState.point);\n            sphereState.sphereSource.modified();\n            this._updateAfterFaceMovement(viewport);\n        };\n        this._calculateNewCornerPosition = (world) => {\n            let newCorner = [world[0], world[1], world[2]];\n            if (this.cornerDragOffset) {\n                newCorner = [\n                    world[0] + this.cornerDragOffset[0],\n                    world[1] + this.cornerDragOffset[1],\n                    world[2] + this.cornerDragOffset[2],\n                ];\n            }\n            return newCorner;\n        };\n        this._parseCornerKey = (uid) => {\n            const cornerKey = uid.replace('corner_', '');\n            return {\n                isXMin: cornerKey.includes('XMIN'),\n                isXMax: cornerKey.includes('XMAX'),\n                isYMin: cornerKey.includes('YMIN'),\n                isYMax: cornerKey.includes('YMAX'),\n                isZMin: cornerKey.includes('ZMIN'),\n                isZMax: cornerKey.includes('ZMAX'),\n            };\n        };\n        this._updateSpherePosition = (sphereState, newPosition) => {\n            sphereState.point = newPosition;\n            sphereState.sphereSource.setCenter(...newPosition);\n            sphereState.sphereSource.modified();\n        };\n        this._updateRelatedCorners = (draggedSphere, newCorner, axisFlags) => {\n            this.sphereStates.forEach((state) => {\n                if (!state.isCorner || state === draggedSphere) {\n                    return;\n                }\n                const key = state.uid.replace('corner_', '');\n                const shouldUpdate = this._shouldUpdateCorner(key, axisFlags);\n                if (shouldUpdate) {\n                    this._updateCornerCoordinates(state, newCorner, key, axisFlags);\n                }\n            });\n        };\n        this._shouldUpdateCorner = (cornerKey, axisFlags) => {\n            return ((axisFlags.isXMin && cornerKey.includes('XMIN')) ||\n                (axisFlags.isXMax && cornerKey.includes('XMAX')) ||\n                (axisFlags.isYMin && cornerKey.includes('YMIN')) ||\n                (axisFlags.isYMax && cornerKey.includes('YMAX')) ||\n                (axisFlags.isZMin && cornerKey.includes('ZMIN')) ||\n                (axisFlags.isZMax && cornerKey.includes('ZMAX')));\n        };\n        this._updateCornerCoordinates = (state, newCorner, cornerKey, axisFlags) => {\n            if ((axisFlags.isXMin && cornerKey.includes('XMIN')) ||\n                (axisFlags.isXMax && cornerKey.includes('XMAX'))) {\n                state.point[0] = newCorner[0];\n            }\n            if ((axisFlags.isYMin && cornerKey.includes('YMIN')) ||\n                (axisFlags.isYMax && cornerKey.includes('YMAX'))) {\n                state.point[1] = newCorner[1];\n            }\n            if ((axisFlags.isZMin && cornerKey.includes('ZMIN')) ||\n                (axisFlags.isZMax && cornerKey.includes('ZMAX'))) {\n                state.point[2] = newCorner[2];\n            }\n            state.sphereSource.setCenter(...state.point);\n            state.sphereSource.modified();\n        };\n        this._updateAfterCornerMovement = (viewport) => {\n            this._updateFaceSpheresFromCorners();\n            this._updateCornerSpheres();\n            this._updateClippingPlanesFromFaceSpheres(viewport);\n        };\n        this._updateAfterFaceMovement = (viewport) => {\n            this._updateCornerSpheresFromFaces();\n            this._updateClippingPlanesFromFaceSpheres(viewport);\n        };\n        this._triggerToolChangedEvent = (sphereState) => {\n            triggerEvent(eventTarget, Events.VOLUMECROPPING_TOOL_CHANGED, {\n                toolCenter: sphereState.point,\n                axis: sphereState.isCorner ? 'corner' : sphereState.axis,\n                draggingSphereIndex: this.draggingSphereIndex,\n                seriesInstanceUID: this.seriesInstanceUID,\n            });\n        };\n        this._onNewVolume = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            this.originalClippingPlanes = [];\n            this.sphereStates = [];\n            this.edgeLines = {};\n            this._initialize3DViewports(viewportsInfo);\n        };\n        this._rotateCamera = (viewport, centerWorld, axis, angle) => {\n            const vtkCamera = viewport.getVtkActiveCamera();\n            const viewUp = vtkCamera.getViewUp();\n            const focalPoint = vtkCamera.getFocalPoint();\n            const position = vtkCamera.getPosition();\n            const newPosition = [0, 0, 0];\n            const newFocalPoint = [0, 0, 0];\n            const newViewUp = [0, 0, 0];\n            const transform = mat4.identity(new Float32Array(16));\n            mat4.translate(transform, transform, centerWorld);\n            mat4.rotate(transform, transform, angle, axis);\n            mat4.translate(transform, transform, [\n                -centerWorld[0],\n                -centerWorld[1],\n                -centerWorld[2],\n            ]);\n            vec3.transformMat4(newPosition, position, transform);\n            vec3.transformMat4(newFocalPoint, focalPoint, transform);\n            mat4.identity(transform);\n            mat4.rotate(transform, transform, angle, axis);\n            vec3.transformMat4(newViewUp, viewUp, transform);\n            viewport.setCamera({\n                position: newPosition,\n                viewUp: newViewUp,\n                focalPoint: newFocalPoint,\n            });\n        };\n        this.touchDragCallback = this._dragCallback.bind(this);\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    onSetToolActive() {\n        if (this.sphereStates && this.sphereStates.length > 0) {\n            if (this.configuration.showHandles) {\n                this.setHandlesVisible(false);\n                this.setClippingPlanesVisible(false);\n            }\n            else {\n                this.setHandlesVisible(true);\n                this.setClippingPlanesVisible(true);\n            }\n        }\n        else {\n            const viewportsInfo = this._getViewportsInfo();\n            const subscribeToElementResize = () => {\n                viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                    if (!this._resizeObservers.has(viewportId)) {\n                        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId) || { viewport: null };\n                        if (!viewport) {\n                            return;\n                        }\n                        const { element } = viewport;\n                        const resizeObserver = new ResizeObserver(() => {\n                            const element = getEnabledElementByIds(viewportId, renderingEngineId);\n                            if (!element) {\n                                return;\n                            }\n                            const { viewport } = element;\n                            const viewPresentation = viewport.getViewPresentation();\n                            viewport.resetCamera();\n                            viewport.setViewPresentation(viewPresentation);\n                            viewport.render();\n                        });\n                        resizeObserver.observe(element);\n                        this._resizeObservers.set(viewportId, resizeObserver);\n                    }\n                });\n            };\n            subscribeToElementResize();\n            this._viewportAddedListener = (evt) => {\n                if (evt.detail.toolGroupId === this.toolGroupId) {\n                    subscribeToElementResize();\n                }\n            };\n            eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n            this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n            this._subscribeToViewportNewVolumeSet(viewportsInfo);\n            this._initialize3DViewports(viewportsInfo);\n            if (this.sphereStates && this.sphereStates.length > 0) {\n                this.setHandlesVisible(true);\n            }\n            else {\n                this.originalClippingPlanes = [];\n                this._initialize3DViewports(viewportsInfo);\n            }\n        }\n    }\n    onSetToolDisabled() {\n        this._resizeObservers.forEach((resizeObserver, viewportId) => {\n            resizeObserver.disconnect();\n            this._resizeObservers.delete(viewportId);\n        });\n        if (this._viewportAddedListener) {\n            eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this._viewportAddedListener);\n            this._viewportAddedListener = null;\n        }\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n    }\n    setHandlesVisible(visible) {\n        this.configuration.showHandles = visible;\n        if (visible) {\n            this.sphereStates[SPHEREINDEX.XMIN].point[0] =\n                this.originalClippingPlanes[PLANEINDEX.XMIN].origin[0];\n            this.sphereStates[SPHEREINDEX.XMAX].point[0] =\n                this.originalClippingPlanes[PLANEINDEX.XMAX].origin[0];\n            this.sphereStates[SPHEREINDEX.YMIN].point[1] =\n                this.originalClippingPlanes[PLANEINDEX.YMIN].origin[1];\n            this.sphereStates[SPHEREINDEX.YMAX].point[1] =\n                this.originalClippingPlanes[PLANEINDEX.YMAX].origin[1];\n            this.sphereStates[SPHEREINDEX.ZMIN].point[2] =\n                this.originalClippingPlanes[PLANEINDEX.ZMIN].origin[2];\n            this.sphereStates[SPHEREINDEX.ZMAX].point[2] =\n                this.originalClippingPlanes[PLANEINDEX.ZMAX].origin[2];\n            [\n                SPHEREINDEX.XMIN,\n                SPHEREINDEX.XMAX,\n                SPHEREINDEX.YMIN,\n                SPHEREINDEX.YMAX,\n                SPHEREINDEX.ZMIN,\n                SPHEREINDEX.ZMAX,\n            ].forEach((idx) => {\n                const s = this.sphereStates[idx];\n                s.sphereSource.setCenter(...s.point);\n                s.sphereSource.modified();\n            });\n            this._updateCornerSpheres();\n        }\n        this._updateHandlesVisibility();\n        const viewportsInfo = this._getViewportsInfo();\n        const [viewport3D] = viewportsInfo;\n        const renderingEngine = getRenderingEngine(viewport3D.renderingEngineId);\n        const viewport = renderingEngine.getViewport(viewport3D.viewportId);\n        viewport.render();\n    }\n    getHandlesVisible() {\n        return this.configuration.showHandles;\n    }\n    getClippingPlanesVisible() {\n        return this.configuration.showClippingPlanes;\n    }\n    setClippingPlanesVisible(visible) {\n        this.configuration.showClippingPlanes = visible;\n        const viewport = this._getViewport();\n        this._updateClippingPlanes(viewport);\n        viewport.render();\n    }\n    _dragCallback(evt) {\n        const { element, currentPoints, lastPoints } = evt.detail;\n        if (this.draggingSphereIndex !== null) {\n            this._onMouseMoveSphere(evt);\n        }\n        else {\n            const currentPointsCanvas = currentPoints.canvas;\n            const lastPointsCanvas = lastPoints.canvas;\n            const { rotateIncrementDegrees } = this.configuration;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const width = element.clientWidth;\n            const height = element.clientHeight;\n            const normalizedPosition = [\n                currentPointsCanvas[0] / width,\n                currentPointsCanvas[1] / height,\n            ];\n            const normalizedPreviousPosition = [\n                lastPointsCanvas[0] / width,\n                lastPointsCanvas[1] / height,\n            ];\n            const center = [width * 0.5, height * 0.5];\n            const centerWorld = viewport.canvasToWorld(center);\n            const normalizedCenter = [0.5, 0.5];\n            const radsq = (1.0 + Math.abs(normalizedCenter[0])) ** 2.0;\n            const op = [normalizedPreviousPosition[0], 0, 0];\n            const oe = [normalizedPosition[0], 0, 0];\n            const opsq = op[0] ** 2;\n            const oesq = oe[0] ** 2;\n            const lop = opsq > radsq ? 0 : Math.sqrt(radsq - opsq);\n            const loe = oesq > radsq ? 0 : Math.sqrt(radsq - oesq);\n            const nop = [op[0], 0, lop];\n            vtkMath.normalize(nop);\n            const noe = [oe[0], 0, loe];\n            vtkMath.normalize(noe);\n            const dot = vtkMath.dot(nop, noe);\n            if (Math.abs(dot) > 0.0001) {\n                const angleX = -2 *\n                    Math.acos(vtkMath.clampValue(dot, -1.0, 1.0)) *\n                    Math.sign(normalizedPosition[0] - normalizedPreviousPosition[0]) *\n                    rotateIncrementDegrees;\n                const upVec = camera.viewUp;\n                const atV = camera.viewPlaneNormal;\n                const rightV = [0, 0, 0];\n                const forwardV = [0, 0, 0];\n                vtkMath.cross(upVec, atV, rightV);\n                vtkMath.normalize(rightV);\n                vtkMath.cross(atV, rightV, forwardV);\n                vtkMath.normalize(forwardV);\n                vtkMath.normalize(upVec);\n                this._rotateCamera(viewport, centerWorld, forwardV, angleX);\n                const angleY = (normalizedPreviousPosition[1] - normalizedPosition[1]) *\n                    rotateIncrementDegrees;\n                this._rotateCamera(viewport, centerWorld, rightV, angleY);\n            }\n            viewport.render();\n        }\n    }\n    _updateClippingPlanes(viewport) {\n        const actorEntry = viewport.getDefaultActor();\n        if (!actorEntry || !actorEntry.actor) {\n            if (!viewport._missingActorWarned) {\n                console.warn('VolumeCroppingTool._updateClippingPlanes: No default actor found in viewport.');\n                viewport._missingActorWarned = true;\n            }\n            return;\n        }\n        const actor = actorEntry.actor;\n        const mapper = actor.getMapper();\n        const matrix = actor.getMatrix();\n        if (!this.configuration.showClippingPlanes) {\n            mapper.removeAllClippingPlanes();\n            return;\n        }\n        const rot = mat3.create();\n        mat3.fromMat4(rot, matrix);\n        const normalMatrix = mat3.create();\n        mat3.invert(normalMatrix, rot);\n        mat3.transpose(normalMatrix, normalMatrix);\n        const originalPlanes = this.originalClippingPlanes;\n        if (!originalPlanes || !originalPlanes.length) {\n            return;\n        }\n        mapper.removeAllClippingPlanes();\n        const transformedOrigins = [];\n        const transformedNormals = [];\n        for (let i = 0; i < originalPlanes.length; ++i) {\n            const plane = originalPlanes[i];\n            const oVec = vec3.create();\n            vec3.transformMat4(oVec, new Float32Array(plane.origin), matrix);\n            const o = [oVec[0], oVec[1], oVec[2]];\n            const nVec = vec3.create();\n            vec3.transformMat3(nVec, new Float32Array(plane.normal), normalMatrix);\n            vec3.normalize(nVec, nVec);\n            const n = [nVec[0], nVec[1], nVec[2]];\n            transformedOrigins.push(o);\n            transformedNormals.push(n);\n        }\n        for (let i = 0; i < transformedOrigins.length; ++i) {\n            const planeInstance = vtkPlane.newInstance({\n                origin: transformedOrigins[i],\n                normal: transformedNormals[i],\n            });\n            mapper.addClippingPlane(planeInstance);\n        }\n    }\n    _updateHandlesVisibility() {\n        this.sphereStates.forEach((state) => {\n            if (state.sphereActor) {\n                state.sphereActor.setVisibility(this.configuration.showHandles);\n            }\n        });\n        Object.values(this.edgeLines).forEach(({ actor }) => {\n            if (actor) {\n                actor.setVisibility(this.configuration.showHandles);\n            }\n        });\n    }\n    _addLine3DBetweenPoints(viewport, point1, point2, color = [0.7, 0.7, 0.7], uid = '') {\n        if (point1[0] === point2[0] &&\n            point1[1] === point2[1] &&\n            point1[2] === point2[2]) {\n            return { actor: null, source: null };\n        }\n        const points = vtkPoints.newInstance();\n        points.setNumberOfPoints(2);\n        points.setPoint(0, point1[0], point1[1], point1[2]);\n        points.setPoint(1, point2[0], point2[1], point2[2]);\n        const lines = vtkCellArray.newInstance({ values: [2, 0, 1] });\n        const polyData = vtkPolyData.newInstance();\n        polyData.setPoints(points);\n        polyData.setLines(lines);\n        const mapper = vtkMapper.newInstance();\n        mapper.setInputData(polyData);\n        const actor = vtkActor.newInstance();\n        actor.setMapper(mapper);\n        actor.getProperty().setColor(...color);\n        actor.getProperty().setLineWidth(0.5);\n        actor.getProperty().setOpacity(1.0);\n        actor.getProperty().setInterpolationToFlat();\n        actor.getProperty().setAmbient(1.0);\n        actor.getProperty().setDiffuse(0.0);\n        actor.getProperty().setSpecular(0.0);\n        actor.setVisibility(this.configuration.showHandles);\n        viewport.addActor({ actor, uid });\n        return { actor, source: polyData };\n    }\n    _addSphere(viewport, point, axis, position, cornerKey = null, adaptiveRadius) {\n        const uid = cornerKey ? `corner_${cornerKey}` : `${axis}_${position}`;\n        const sphereState = this.sphereStates.find((s) => s.uid === uid);\n        if (sphereState) {\n            return;\n        }\n        const sphereSource = vtkSphereSource.newInstance();\n        sphereSource.setCenter(point);\n        sphereSource.setRadius(adaptiveRadius);\n        const sphereMapper = vtkMapper.newInstance();\n        sphereMapper.setInputConnection(sphereSource.getOutputPort());\n        const sphereActor = vtkActor.newInstance();\n        sphereActor.setMapper(sphereMapper);\n        let color = [0.0, 1.0, 0.0];\n        const sphereColors = this.configuration.sphereColors || {};\n        if (cornerKey) {\n            color = sphereColors.CORNERS || [0.0, 0.0, 1.0];\n        }\n        else if (axis === 'z') {\n            color = sphereColors.AXIAL || [1.0, 0.0, 0.0];\n        }\n        else if (axis === 'x') {\n            color = sphereColors.SAGITTAL || [1.0, 1.0, 0.0];\n        }\n        else if (axis === 'y') {\n            color = sphereColors.CORONAL || [0.0, 1.0, 0.0];\n        }\n        const idx = this.sphereStates.findIndex((s) => s.uid === uid);\n        if (idx === -1) {\n            this.sphereStates.push({\n                point: point.slice(),\n                axis,\n                uid,\n                sphereSource,\n                sphereActor,\n                isCorner: !!cornerKey,\n                color,\n            });\n        }\n        else {\n            this.sphereStates[idx].point = point.slice();\n            this.sphereStates[idx].sphereSource = sphereSource;\n        }\n        const existingActors = viewport.getActors();\n        const existing = existingActors.find((a) => a.uid === uid);\n        if (existing) {\n            return;\n        }\n        sphereActor.getProperty().setColor(color);\n        sphereActor.setVisibility(this.configuration.showHandles);\n        viewport.addActor({ actor: sphereActor, uid: uid });\n    }\n    _calculateAdaptiveSphereRadius(diagonal) {\n        const baseRadius = this.configuration.sphereRadius !== undefined\n            ? this.configuration.sphereRadius\n            : 8;\n        const scaleFactor = this.configuration.sphereRadiusScale || 0.01;\n        const adaptiveRadius = diagonal * scaleFactor;\n        const minRadius = this.configuration.minSphereRadius || 2;\n        const maxRadius = this.configuration.maxSphereRadius || 50;\n        return Math.max(minRadius, Math.min(maxRadius, adaptiveRadius));\n    }\n    _updateClippingPlanesFromFaceSpheres(viewport) {\n        const mapper = viewport.getDefaultActor().actor.getMapper();\n        this.originalClippingPlanes[0].origin = [\n            ...this.sphereStates[SPHEREINDEX.XMIN].point,\n        ];\n        this.originalClippingPlanes[1].origin = [\n            ...this.sphereStates[SPHEREINDEX.XMAX].point,\n        ];\n        this.originalClippingPlanes[2].origin = [\n            ...this.sphereStates[SPHEREINDEX.YMIN].point,\n        ];\n        this.originalClippingPlanes[3].origin = [\n            ...this.sphereStates[SPHEREINDEX.YMAX].point,\n        ];\n        this.originalClippingPlanes[4].origin = [\n            ...this.sphereStates[SPHEREINDEX.ZMIN].point,\n        ];\n        this.originalClippingPlanes[5].origin = [\n            ...this.sphereStates[SPHEREINDEX.ZMAX].point,\n        ];\n        mapper.removeAllClippingPlanes();\n        for (let i = 0; i < 6; ++i) {\n            const origin = this.originalClippingPlanes[i].origin;\n            const normal = this.originalClippingPlanes[i].normal;\n            const plane = vtkPlane.newInstance({\n                origin,\n                normal,\n            });\n            mapper.addClippingPlane(plane);\n        }\n    }\n    _updateCornerSpheresFromFaces() {\n        const xMin = this.sphereStates[SPHEREINDEX.XMIN].point[0];\n        const xMax = this.sphereStates[SPHEREINDEX.XMAX].point[0];\n        const yMin = this.sphereStates[SPHEREINDEX.YMIN].point[1];\n        const yMax = this.sphereStates[SPHEREINDEX.YMAX].point[1];\n        const zMin = this.sphereStates[SPHEREINDEX.ZMIN].point[2];\n        const zMax = this.sphereStates[SPHEREINDEX.ZMAX].point[2];\n        const corners = [\n            { key: 'XMIN_YMIN_ZMIN', pos: [xMin, yMin, zMin] },\n            { key: 'XMIN_YMIN_ZMAX', pos: [xMin, yMin, zMax] },\n            { key: 'XMIN_YMAX_ZMIN', pos: [xMin, yMax, zMin] },\n            { key: 'XMIN_YMAX_ZMAX', pos: [xMin, yMax, zMax] },\n            { key: 'XMAX_YMIN_ZMIN', pos: [xMax, yMin, zMin] },\n            { key: 'XMAX_YMIN_ZMAX', pos: [xMax, yMin, zMax] },\n            { key: 'XMAX_YMAX_ZMIN', pos: [xMax, yMax, zMin] },\n            { key: 'XMAX_YMAX_ZMAX', pos: [xMax, yMax, zMax] },\n        ];\n        for (const corner of corners) {\n            const state = this.sphereStates.find((s) => s.uid === `corner_${corner.key}`);\n            if (state) {\n                state.point[0] = corner.pos[0];\n                state.point[1] = corner.pos[1];\n                state.point[2] = corner.pos[2];\n                state.sphereSource.setCenter(...state.point);\n                state.sphereSource.modified();\n            }\n        }\n    }\n    _updateFaceSpheresFromCorners() {\n        const corners = [\n            this.sphereStates[SPHEREINDEX.XMIN_YMIN_ZMIN].point,\n            this.sphereStates[SPHEREINDEX.XMIN_YMIN_ZMAX].point,\n            this.sphereStates[SPHEREINDEX.XMIN_YMAX_ZMIN].point,\n            this.sphereStates[SPHEREINDEX.XMIN_YMAX_ZMAX].point,\n            this.sphereStates[SPHEREINDEX.XMAX_YMIN_ZMIN].point,\n            this.sphereStates[SPHEREINDEX.XMAX_YMIN_ZMAX].point,\n            this.sphereStates[SPHEREINDEX.XMAX_YMAX_ZMIN].point,\n            this.sphereStates[SPHEREINDEX.XMAX_YMAX_ZMAX].point,\n        ];\n        const xs = corners.map((p) => p[0]);\n        const ys = corners.map((p) => p[1]);\n        const zs = corners.map((p) => p[2]);\n        const xMin = Math.min(...xs), xMax = Math.max(...xs);\n        const yMin = Math.min(...ys), yMax = Math.max(...ys);\n        const zMin = Math.min(...zs), zMax = Math.max(...zs);\n        this.sphereStates[SPHEREINDEX.XMIN].point = [\n            xMin,\n            (yMin + yMax) / 2,\n            (zMin + zMax) / 2,\n        ];\n        this.sphereStates[SPHEREINDEX.XMAX].point = [\n            xMax,\n            (yMin + yMax) / 2,\n            (zMin + zMax) / 2,\n        ];\n        this.sphereStates[SPHEREINDEX.YMIN].point = [\n            (xMin + xMax) / 2,\n            yMin,\n            (zMin + zMax) / 2,\n        ];\n        this.sphereStates[SPHEREINDEX.YMAX].point = [\n            (xMin + xMax) / 2,\n            yMax,\n            (zMin + zMax) / 2,\n        ];\n        this.sphereStates[SPHEREINDEX.ZMIN].point = [\n            (xMin + xMax) / 2,\n            (yMin + yMax) / 2,\n            zMin,\n        ];\n        this.sphereStates[SPHEREINDEX.ZMAX].point = [\n            (xMin + xMax) / 2,\n            (yMin + yMax) / 2,\n            zMax,\n        ];\n        [\n            SPHEREINDEX.XMIN,\n            SPHEREINDEX.XMAX,\n            SPHEREINDEX.YMIN,\n            SPHEREINDEX.YMAX,\n            SPHEREINDEX.ZMIN,\n            SPHEREINDEX.ZMAX,\n        ].forEach((idx) => {\n            const s = this.sphereStates[idx];\n            s.sphereSource.setCenter(...s.point);\n            s.sphereSource.modified();\n        });\n    }\n    _updateCornerSpheres() {\n        const xMin = this.sphereStates[SPHEREINDEX.XMIN].point[0];\n        const xMax = this.sphereStates[SPHEREINDEX.XMAX].point[0];\n        const yMin = this.sphereStates[SPHEREINDEX.YMIN].point[1];\n        const yMax = this.sphereStates[SPHEREINDEX.YMAX].point[1];\n        const zMin = this.sphereStates[SPHEREINDEX.ZMIN].point[2];\n        const zMax = this.sphereStates[SPHEREINDEX.ZMAX].point[2];\n        const corners = [\n            { key: 'XMIN_YMIN_ZMIN', pos: [xMin, yMin, zMin] },\n            { key: 'XMIN_YMIN_ZMAX', pos: [xMin, yMin, zMax] },\n            { key: 'XMIN_YMAX_ZMIN', pos: [xMin, yMax, zMin] },\n            { key: 'XMIN_YMAX_ZMAX', pos: [xMin, yMax, zMax] },\n            { key: 'XMAX_YMIN_ZMIN', pos: [xMax, yMin, zMin] },\n            { key: 'XMAX_YMIN_ZMAX', pos: [xMax, yMin, zMax] },\n            { key: 'XMAX_YMAX_ZMIN', pos: [xMax, yMax, zMin] },\n            { key: 'XMAX_YMAX_ZMAX', pos: [xMax, yMax, zMax] },\n        ];\n        for (const corner of corners) {\n            const state = this.sphereStates.find((s) => s.uid === `corner_${corner.key}`);\n            if (state) {\n                state.point[0] = corner.pos[0];\n                state.point[1] = corner.pos[1];\n                state.point[2] = corner.pos[2];\n                state.sphereSource.setCenter(...state.point);\n                state.sphereSource.modified();\n            }\n        }\n        Object.values(this.edgeLines).forEach(({ source, key1, key2 }) => {\n            const state1 = this.sphereStates.find((s) => s.uid === `corner_${key1}`);\n            const state2 = this.sphereStates.find((s) => s.uid === `corner_${key2}`);\n            if (state1 && state2) {\n                const points = source.getPoints();\n                points.setPoint(0, state1.point[0], state1.point[1], state1.point[2]);\n                points.setPoint(1, state2.point[0], state2.point[1], state2.point[2]);\n                points.modified();\n                source.modified();\n            }\n        });\n    }\n    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _subscribeToViewportNewVolumeSet(viewports) {\n        viewports.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n}\nVolumeCroppingTool.toolName = 'VolumeCropping';\nexport default VolumeCroppingTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { AnnotationTool } from './base';\nimport { getRenderingEngine, getEnabledElementByIds, getEnabledElement, utilities as csUtils, Enums, CONSTANTS, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { getToolGroup, getToolGroupForViewport, } from '../store/ToolGroupManager';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { drawCircle as drawCircleSvg, drawLine as drawLineSvg, } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\nimport * as lineSegment from '../utilities/math/line';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nconst { RENDERING_DEFAULTS } = CONSTANTS;\nfunction defaultReferenceLineColor() {\n    return 'rgb(0, 200, 0)';\n}\nfunction defaultReferenceLineControllable() {\n    return true;\n}\nconst OPERATION = {\n    DRAG: 1,\n    ROTATE: 2,\n    SLAB: 3,\n};\nclass VolumeCroppingControlTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse'],\n        configuration: {\n            viewportIndicators: false,\n            viewportIndicatorsConfig: {\n                radius: 5,\n                x: null,\n                y: null,\n            },\n            extendReferenceLines: true,\n            initialCropFactor: 0.2,\n            mobile: {\n                enabled: false,\n                opacity: 0.8,\n            },\n            lineColors: {\n                AXIAL: [1.0, 0.0, 0.0],\n                CORONAL: [0.0, 1.0, 0.0],\n                SAGITTAL: [1.0, 1.0, 0.0],\n                UNKNOWN: [0.0, 0.0, 1.0],\n            },\n            lineWidth: 1.5,\n            lineWidthActive: 2.5,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._virtualAnnotations = [];\n        this.sphereStates = [];\n        this.draggingSphereIndex = null;\n        this.toolCenter = [0, 0, 0];\n        this.toolCenterMin = [0, 0, 0];\n        this.toolCenterMax = [0, 0, 0];\n        this.initializeViewport = ({ renderingEngineId, viewportId, }) => {\n            if (!renderingEngineId || !viewportId) {\n                console.warn('VolumeCroppingControlTool: Missing renderingEngineId or viewportId');\n                return;\n            }\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            this._updateToolCentersFromViewport(viewport);\n            const { element } = viewport;\n            const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\n            let annotations = this._getAnnotations(enabledElement);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (annotations?.length) {\n                removeAnnotation(annotations[0].annotationUID);\n            }\n            const orientation = this._getOrientationFromNormal(viewport.getCamera().viewPlaneNormal);\n            const annotation = {\n                highlighted: false,\n                metadata: {\n                    cameraPosition: [...position],\n                    cameraFocalPoint: [...focalPoint],\n                    toolName: this.getToolName(),\n                },\n                data: {\n                    handles: {\n                        toolCenter: this.toolCenter,\n                        toolCenterMin: this.toolCenterMin,\n                        toolCenterMax: this.toolCenterMax,\n                    },\n                    activeOperation: null,\n                    activeViewportIds: [],\n                    viewportId,\n                    referenceLines: [],\n                    orientation,\n                },\n            };\n            addAnnotation(annotation, element);\n            return {\n                normal: viewPlaneNormal,\n                point: viewport.canvasToWorld([100, 100]),\n            };\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.resetCroppingSpheres = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            for (const viewportInfo of viewportsInfo) {\n                const { viewportId, renderingEngineId } = viewportInfo;\n                const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n                const viewport = enabledElement.viewport;\n                const resetPan = true;\n                const resetZoom = true;\n                const resetToCenter = true;\n                const resetRotation = true;\n                const suppressEvents = true;\n                viewport.resetCamera({\n                    resetPan,\n                    resetZoom,\n                    resetToCenter,\n                    resetRotation,\n                    suppressEvents,\n                });\n                viewport.resetSlabThickness();\n                const { element } = viewport;\n                let annotations = this._getAnnotations(enabledElement);\n                annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n                if (annotations.length) {\n                    removeAnnotation(annotations[0].annotationUID);\n                }\n                viewport.render();\n            }\n            this._computeToolCenter(viewportsInfo);\n        };\n        this.computeToolCenter = () => {\n            const viewportsInfo = this._getViewportsInfo();\n        };\n        this._computeToolCenter = (viewportsInfo) => {\n            if (!viewportsInfo || !viewportsInfo[0]) {\n                console.warn('  _computeToolCenter : No valid viewportsInfo for computeToolCenter.');\n                return;\n            }\n            const orientationIds = ['AXIAL', 'CORONAL', 'SAGITTAL'];\n            const presentOrientations = viewportsInfo\n                .map((vp) => {\n                if (vp.renderingEngineId) {\n                    const renderingEngine = getRenderingEngine(vp.renderingEngineId);\n                    const viewport = renderingEngine.getViewport(vp.viewportId);\n                    if (viewport && viewport.getCamera) {\n                        const orientation = this._getOrientationFromNormal(viewport.getCamera().viewPlaneNormal);\n                        if (orientation) {\n                            return orientation;\n                        }\n                    }\n                }\n                return null;\n            })\n                .filter(Boolean);\n            const missingOrientation = orientationIds.find((id) => !presentOrientations.includes(id));\n            const presentNormals = [];\n            const presentCenters = [];\n            const presentViewportInfos = viewportsInfo.filter((vp) => {\n                let orientation = null;\n                if (vp.renderingEngineId) {\n                    const renderingEngine = getRenderingEngine(vp.renderingEngineId);\n                    const viewport = renderingEngine.getViewport(vp.viewportId);\n                    if (viewport && viewport.getCamera) {\n                        orientation = this._getOrientationFromNormal(viewport.getCamera().viewPlaneNormal);\n                    }\n                }\n                return orientation && orientationIds.includes(orientation);\n            });\n            presentViewportInfos.forEach((vpInfo) => {\n                const { normal, point } = this.initializeViewport(vpInfo);\n                presentNormals.push(normal);\n                presentCenters.push(point);\n            });\n            if (presentViewportInfos.length === 2 && missingOrientation) {\n                const virtualNormal = [0, 0, 0];\n                vec3.cross(virtualNormal, presentNormals[0], presentNormals[1]);\n                vec3.normalize(virtualNormal, virtualNormal);\n                const virtualCenter = [\n                    (presentCenters[0][0] + presentCenters[1][0]) / 2,\n                    (presentCenters[0][1] + presentCenters[1][1]) / 2,\n                    (presentCenters[0][2] + presentCenters[1][2]) / 2,\n                ];\n                const orientation = null;\n                const virtualAnnotation = {\n                    highlighted: false,\n                    metadata: {\n                        cameraPosition: [...virtualCenter],\n                        cameraFocalPoint: [...virtualCenter],\n                        toolName: this.getToolName(),\n                    },\n                    data: {\n                        handles: {\n                            activeOperation: null,\n                            toolCenter: this.toolCenter,\n                            toolCenterMin: this.toolCenterMin,\n                            toolCenterMax: this.toolCenterMax,\n                        },\n                        activeViewportIds: [],\n                        viewportId: missingOrientation,\n                        referenceLines: [],\n                        orientation,\n                    },\n                    isVirtual: true,\n                    virtualNormal,\n                };\n                this._virtualAnnotations = [virtualAnnotation];\n            }\n            else if (presentViewportInfos.length === 1) {\n                let presentOrientation = null;\n                const vpInfo = presentViewportInfos[0];\n                if (vpInfo.renderingEngineId) {\n                    const renderingEngine = getRenderingEngine(vpInfo.renderingEngineId);\n                    const viewport = renderingEngine.getViewport(vpInfo.viewportId);\n                    if (viewport && viewport.getCamera) {\n                        presentOrientation = this._getOrientationFromNormal(viewport.getCamera().viewPlaneNormal);\n                    }\n                }\n                const presentCenter = presentCenters[0];\n                const canonicalNormals = {\n                    AXIAL: [0, 0, 1],\n                    CORONAL: [0, 1, 0],\n                    SAGITTAL: [1, 0, 0],\n                };\n                const missingIds = orientationIds.filter((id) => id !== presentOrientation);\n                const virtualAnnotations = missingIds.map((orientation) => {\n                    const normal = canonicalNormals[orientation];\n                    const virtualAnnotation = {\n                        highlighted: false,\n                        metadata: {\n                            cameraPosition: [...presentCenter],\n                            cameraFocalPoint: [...presentCenter],\n                            toolName: this.getToolName(),\n                        },\n                        data: {\n                            handles: {\n                                activeOperation: null,\n                                toolCenter: this.toolCenter,\n                                toolCenterMin: this.toolCenterMin,\n                                toolCenterMax: this.toolCenterMax,\n                            },\n                            activeViewportIds: [],\n                            viewportId: orientation,\n                            referenceLines: [],\n                            orientation,\n                        },\n                        isVirtual: true,\n                        virtualNormal: normal,\n                    };\n                    return virtualAnnotation;\n                });\n                this._virtualAnnotations = virtualAnnotations;\n            }\n            if (viewportsInfo && viewportsInfo.length) {\n                triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n            }\n        };\n        this.cancel = () => {\n            console.log('Not implemented yet');\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.onResetCamera = (evt) => {\n            this.resetCroppingSpheres();\n        };\n        this.mouseMoveCallback = (evt, filteredToolAnnotations) => {\n            if (!filteredToolAnnotations) {\n                return;\n            }\n            const { element, currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            let imageNeedsUpdate = false;\n            for (let i = 0; i < filteredToolAnnotations.length; i++) {\n                const annotation = filteredToolAnnotations[i];\n                if (isAnnotationLocked(annotation.annotationUID)) {\n                    continue;\n                }\n                const { data, highlighted } = annotation;\n                if (!data.handles) {\n                    continue;\n                }\n                const previousActiveOperation = data.handles.activeOperation;\n                const previousActiveViewportIds = data.activeViewportIds && data.activeViewportIds.length > 0\n                    ? [...data.activeViewportIds]\n                    : [];\n                data.activeViewportIds = [];\n                let near = false;\n                near = this._pointNearTool(element, annotation, canvasCoords, 6);\n                const nearToolAndNotMarkedActive = near && !highlighted;\n                const notNearToolAndMarkedActive = !near && highlighted;\n                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n                    annotation.highlighted = !highlighted;\n                    imageNeedsUpdate = true;\n                }\n            }\n            return imageNeedsUpdate;\n        };\n        this.filterInteractableAnnotationsForElement = (element, annotations) => {\n            if (!annotations || !annotations.length) {\n                return [];\n            }\n            const enabledElement = getEnabledElement(element);\n            let orientation = null;\n            if (enabledElement.viewport && enabledElement.viewport.getCamera) {\n                orientation = this._getOrientationFromNormal(enabledElement.viewport.getCamera().viewPlaneNormal);\n            }\n            const filtered = annotations.filter((annotation) => {\n                if (annotation.isVirtual) {\n                    return true;\n                }\n                if (annotation.data.orientation &&\n                    orientation &&\n                    annotation.data.orientation === orientation) {\n                    return true;\n                }\n                return false;\n            });\n            return filtered;\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            function lineIntersection2D(p1, p2, q1, q2) {\n                const s1_x = p2[0] - p1[0];\n                const s1_y = p2[1] - p1[1];\n                const s2_x = q2[0] - q1[0];\n                const s2_y = q2[1] - q1[1];\n                const denom = -s2_x * s1_y + s1_x * s2_y;\n                if (Math.abs(denom) < 1e-8) {\n                    return null;\n                }\n                const s = (-s1_y * (p1[0] - q1[0]) + s1_x * (p1[1] - q1[1])) / denom;\n                const t = (s2_x * (p1[1] - q1[1]) - s2_y * (p1[0] - q1[0])) / denom;\n                if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {\n                    return [p1[0] + t * s1_x, p1[1] + t * s1_y];\n                }\n                return null;\n            }\n            const viewportsInfo = this._getViewportsInfo();\n            if (!viewportsInfo || viewportsInfo.length === 0) {\n                return false;\n            }\n            let renderStatus = false;\n            const { viewport, renderingEngine } = enabledElement;\n            const { element } = viewport;\n            let annotations = this._getAnnotations(enabledElement);\n            if (this._virtualAnnotations && this._virtualAnnotations.length) {\n                annotations = annotations.concat(this._virtualAnnotations);\n            }\n            const camera = viewport.getCamera();\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation || !viewportAnnotation.data) {\n                return renderStatus;\n            }\n            const annotationUID = viewportAnnotation.annotationUID;\n            const { clientWidth, clientHeight } = viewport.canvas;\n            const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n            const data = viewportAnnotation.data;\n            const otherViewportAnnotations = annotations;\n            const volumeCroppingCenterCanvasMin = viewport.worldToCanvas(this.toolCenterMin);\n            const volumeCroppingCenterCanvasMax = viewport.worldToCanvas(this.toolCenterMax);\n            const referenceLines = [];\n            const canvasBox = [0, 0, clientWidth, clientHeight];\n            otherViewportAnnotations.forEach((annotation) => {\n                const data = annotation.data;\n                const isVirtual = 'isVirtual' in annotation &&\n                    annotation.isVirtual === true;\n                data.handles.toolCenter = this.toolCenter;\n                let otherViewport, otherCamera, clientWidth, clientHeight, otherCanvasDiagonalLength, otherCanvasCenter, otherViewportCenterWorld;\n                if (isVirtual) {\n                    const realViewports = viewportsInfo.filter((vp) => vp.viewportId !== data.viewportId);\n                    if (realViewports.length === 2) {\n                        const vp1 = renderingEngine.getViewport(realViewports[0].viewportId);\n                        const vp2 = renderingEngine.getViewport(realViewports[1].viewportId);\n                        const normal1 = vp1.getCamera().viewPlaneNormal;\n                        const normal2 = vp2.getCamera().viewPlaneNormal;\n                        const virtualNormal = vec3.create();\n                        vec3.cross(virtualNormal, normal1, normal2);\n                        vec3.normalize(virtualNormal, virtualNormal);\n                        otherCamera = {\n                            viewPlaneNormal: virtualNormal,\n                            position: data.handles.toolCenter,\n                            focalPoint: data.handles.toolCenter,\n                            viewUp: [0, 1, 0],\n                        };\n                        clientWidth = viewport.canvas.clientWidth;\n                        clientHeight = viewport.canvas.clientHeight;\n                        otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n                        otherCanvasCenter = [clientWidth * 0.5, clientHeight * 0.5];\n                        otherViewportCenterWorld = data.handles.toolCenter;\n                        otherViewport = {\n                            id: data.viewportId,\n                            canvas: viewport.canvas,\n                            canvasToWorld: () => data.handles.toolCenter,\n                        };\n                    }\n                    else {\n                        const virtualNormal = annotation\n                            .virtualNormal ?? [0, 0, 1];\n                        otherCamera = {\n                            viewPlaneNormal: virtualNormal,\n                            position: data.handles.toolCenter,\n                            focalPoint: data.handles.toolCenter,\n                            viewUp: [0, 1, 0],\n                        };\n                        clientWidth = viewport.canvas.clientWidth;\n                        clientHeight = viewport.canvas.clientHeight;\n                        otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n                        otherCanvasCenter = [clientWidth * 0.5, clientHeight * 0.5];\n                        otherViewportCenterWorld = data.handles.toolCenter;\n                        otherViewport = {\n                            id: data.viewportId,\n                            canvas: viewport.canvas,\n                            canvasToWorld: () => data.handles.toolCenter,\n                        };\n                    }\n                }\n                else {\n                    otherViewport = renderingEngine.getViewport(data.viewportId);\n                    otherCamera = otherViewport.getCamera();\n                    clientWidth = otherViewport.canvas.clientWidth;\n                    clientHeight = otherViewport.canvas.clientHeight;\n                    otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n                    otherCanvasCenter = [clientWidth * 0.5, clientHeight * 0.5];\n                    otherViewportCenterWorld =\n                        otherViewport.canvasToWorld(otherCanvasCenter);\n                }\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const direction = [0, 0, 0];\n                vtkMath.cross(camera.viewPlaneNormal, otherCamera.viewPlaneNormal, direction);\n                vtkMath.normalize(direction);\n                vtkMath.multiplyScalar(direction, otherCanvasDiagonalLength);\n                const pointWorld0 = [0, 0, 0];\n                vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\n                const pointWorld1 = [0, 0, 0];\n                vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\n                const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\n                const otherViewportCenterCanvas = viewport.worldToCanvas([\n                    otherViewportCenterWorld[0] ?? 0,\n                    otherViewportCenterWorld[1] ?? 0,\n                    otherViewportCenterWorld[2] ?? 0,\n                ]);\n                const canvasUnitVectorFromCenter = vec2.create();\n                vec2.subtract(canvasUnitVectorFromCenter, pointCanvas0, otherViewportCenterCanvas);\n                vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n                const canvasVectorFromCenterLong = vec2.create();\n                vec2.scale(canvasVectorFromCenterLong, canvasUnitVectorFromCenter, canvasDiagonalLength * 100);\n                const refLinesCenterMin = otherViewportControllable\n                    ? vec2.clone(volumeCroppingCenterCanvasMin)\n                    : vec2.clone(otherViewportCenterCanvas);\n                const refLinePointMinOne = vec2.create();\n                const refLinePointMinTwo = vec2.create();\n                vec2.add(refLinePointMinOne, refLinesCenterMin, canvasVectorFromCenterLong);\n                vec2.subtract(refLinePointMinTwo, refLinesCenterMin, canvasVectorFromCenterLong);\n                liangBarksyClip(refLinePointMinOne, refLinePointMinTwo, canvasBox);\n                referenceLines.push([\n                    otherViewport,\n                    refLinePointMinOne,\n                    refLinePointMinTwo,\n                    'min',\n                ]);\n                const refLinesCenterMax = otherViewportControllable\n                    ? vec2.clone(volumeCroppingCenterCanvasMax)\n                    : vec2.clone(otherViewportCenterCanvas);\n                const refLinePointMaxOne = vec2.create();\n                const refLinePointMaxTwo = vec2.create();\n                vec2.add(refLinePointMaxOne, refLinesCenterMax, canvasVectorFromCenterLong);\n                vec2.subtract(refLinePointMaxTwo, refLinesCenterMax, canvasVectorFromCenterLong);\n                liangBarksyClip(refLinePointMaxOne, refLinePointMaxTwo, canvasBox);\n                referenceLines.push([\n                    otherViewport,\n                    refLinePointMaxOne,\n                    refLinePointMaxTwo,\n                    'max',\n                ]);\n            });\n            data.referenceLines = referenceLines;\n            const viewportColor = this._getReferenceLineColor(viewport.id);\n            const color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n            referenceLines.forEach((line, lineIndex) => {\n                const intersections = [];\n                for (let j = 0; j < referenceLines.length; ++j) {\n                    if (j === lineIndex) {\n                        continue;\n                    }\n                    const otherLine = referenceLines[j];\n                    const intersection = lineIntersection2D(line[1], line[2], otherLine[1], otherLine[2]);\n                    if (intersection) {\n                        intersections.push({\n                            with: otherLine[3],\n                            point: intersection,\n                        });\n                    }\n                }\n                const otherViewport = line[0];\n                let orientation = null;\n                if (otherViewport && otherViewport.id) {\n                    const annotationForViewport = annotations.find((a) => a.data.viewportId === otherViewport.id);\n                    if (annotationForViewport && annotationForViewport.data.orientation) {\n                        orientation = String(annotationForViewport.data.orientation).toUpperCase();\n                    }\n                    else {\n                        const idUpper = otherViewport.id.toUpperCase();\n                        if (idUpper.includes('AXIAL')) {\n                            orientation = 'AXIAL';\n                        }\n                        else if (idUpper.includes('CORONAL')) {\n                            orientation = 'CORONAL';\n                        }\n                        else if (idUpper.includes('SAGITTAL')) {\n                            orientation = 'SAGITTAL';\n                        }\n                    }\n                }\n                const lineColors = this.configuration.lineColors || {};\n                const colorArr = lineColors[orientation] ||\n                    lineColors.unknown || [1.0, 0.0, 0.0];\n                const color = Array.isArray(colorArr)\n                    ? `rgb(${colorArr.map((v) => Math.round(v * 255)).join(',')})`\n                    : colorArr;\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const selectedViewportId = data.activeViewportIds.find((id) => id === otherViewport.id);\n                let lineWidth = this.configuration.lineWidth ?? 1.5;\n                const lineActive = data.handles.activeOperation !== null &&\n                    data.handles.activeOperation === OPERATION.DRAG &&\n                    selectedViewportId;\n                if (lineActive) {\n                    lineWidth = this.configuration.activeLineWidth ?? 2.5;\n                }\n                const lineUID = `${lineIndex}`;\n                if (viewportControllable) {\n                    if (intersections.length === 2) {\n                        drawLineSvg(svgDrawingHelper, annotationUID, lineUID, intersections[0].point, intersections[1].point, {\n                            color,\n                            lineWidth,\n                        });\n                    }\n                    if (this.configuration.extendReferenceLines &&\n                        intersections.length === 2) {\n                        if (this.configuration.extendReferenceLines &&\n                            intersections.length === 2) {\n                            const sortedIntersections = intersections\n                                .map((intersection) => ({\n                                ...intersection,\n                                distance: vec2.distance(line[1], intersection.point),\n                            }))\n                                .sort((a, b) => a.distance - b.distance);\n                            drawLineSvg(svgDrawingHelper, annotationUID, lineUID + '_dashed_before', line[1], sortedIntersections[0].point, { color, lineWidth, lineDash: [4, 4] });\n                            drawLineSvg(svgDrawingHelper, annotationUID, lineUID + '_dashed_after', sortedIntersections[1].point, line[2], { color, lineWidth, lineDash: [4, 4] });\n                        }\n                    }\n                }\n            });\n            renderStatus = true;\n            if (this.configuration.viewportIndicators) {\n                const { viewportIndicatorsConfig } = this.configuration;\n                const xOffset = viewportIndicatorsConfig?.xOffset || 0.95;\n                const yOffset = viewportIndicatorsConfig?.yOffset || 0.05;\n                const referenceColorCoordinates = [\n                    clientWidth * xOffset,\n                    clientHeight * yOffset,\n                ];\n                const circleRadius = viewportIndicatorsConfig?.circleRadius || canvasDiagonalLength * 0.01;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, referenceColorCoordinates, circleRadius, { color, fill: color });\n            }\n            return renderStatus;\n        };\n        this._getAnnotations = (enabledElement) => {\n            const { viewport } = enabledElement;\n            const annotations = getAnnotations(this.getToolName(), viewport.element) || [];\n            const viewportIds = this._getViewportsInfo().map(({ viewportId }) => viewportId);\n            const toolGroupAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                return viewportIds.includes(data.viewportId);\n            });\n            return toolGroupAnnotations;\n        };\n        this._onSphereMoved = (evt) => {\n            if (evt.detail.originalClippingPlanes) {\n                this._syncWithVolumeCroppingTool(evt.detail.originalClippingPlanes);\n            }\n            else {\n                if (evt.detail.seriesInstanceUID !== this.seriesInstanceUID) {\n                    return;\n                }\n                const { draggingSphereIndex, toolCenter } = evt.detail;\n                const newMin = [...this.toolCenterMin];\n                const newMax = [...this.toolCenterMax];\n                if (draggingSphereIndex >= 0 && draggingSphereIndex <= 5) {\n                    const axis = Math.floor(draggingSphereIndex / 2);\n                    const isMin = draggingSphereIndex % 2 === 0;\n                    (isMin ? newMin : newMax)[axis] = toolCenter[axis];\n                    this.setToolCenter(newMin, 'min');\n                    this.setToolCenter(newMax, 'max');\n                    return;\n                }\n                if (draggingSphereIndex >= 6 && draggingSphereIndex <= 13) {\n                    const idx = draggingSphereIndex;\n                    if (idx < 10) {\n                        newMin[0] = toolCenter[0];\n                    }\n                    else {\n                        newMax[0] = toolCenter[0];\n                    }\n                    if ([6, 7, 10, 11].includes(idx)) {\n                        newMin[1] = toolCenter[1];\n                    }\n                    else {\n                        newMax[1] = toolCenter[1];\n                    }\n                    if (idx % 2 === 0) {\n                        newMin[2] = toolCenter[2];\n                    }\n                    else {\n                        newMax[2] = toolCenter[2];\n                    }\n                    this.setToolCenter(newMin, 'min');\n                    this.setToolCenter(newMax, 'max');\n                }\n            }\n        };\n        this._onNewVolume = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            if (viewportsInfo && viewportsInfo.length > 0) {\n                const { viewportId, renderingEngineId } = viewportsInfo[0];\n                const renderingEngine = getRenderingEngine(renderingEngineId);\n                const viewport = renderingEngine.getViewport(viewportId);\n                const volumeActors = viewport.getActors();\n                if (volumeActors.length > 0) {\n                    const imageData = volumeActors[0].actor.getMapper().getInputData();\n                    if (imageData) {\n                        this.seriesInstanceUID = imageData.seriesInstanceUID;\n                        this._updateToolCentersFromViewport(viewport);\n                        const annotations = getAnnotations(this.getToolName(), viewportId) || [];\n                        annotations.forEach((annotation) => {\n                            if (annotation.data && annotation.data.handles) {\n                                annotation.data.handles.toolCenter = [...this.toolCenter];\n                            }\n                        });\n                    }\n                }\n            }\n            this._computeToolCenter(viewportsInfo);\n            triggerEvent(eventTarget, Events.VOLUMECROPPINGCONTROL_TOOL_CHANGED, {\n                toolGroupId: this.toolGroupId,\n                viewportsInfo: viewportsInfo,\n                seriesInstanceUID: this.seriesInstanceUID,\n            });\n        };\n        this._getAnnotationsForViewportsWithDifferentCameras = (enabledElement, annotations) => {\n            const { viewportId, renderingEngine, viewport } = enabledElement;\n            const otherViewportAnnotations = annotations.filter((annotation) => annotation.data.viewportId !== viewportId);\n            if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, position } = camera;\n            const viewportsWithDifferentCameras = otherViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const targetViewport = renderingEngine.getViewport(viewportId);\n                const cameraOfTarget = targetViewport.getCamera();\n                return !(csUtils.isEqual(cameraOfTarget.viewPlaneNormal, viewPlaneNormal, 1e-2) && csUtils.isEqual(cameraOfTarget.position, position, 1));\n            });\n            return viewportsWithDifferentCameras;\n        };\n        this._filterViewportWithSameOrientation = (enabledElement, referenceAnnotation, annotations) => {\n            const { renderingEngine } = enabledElement;\n            const { data } = referenceAnnotation;\n            const viewport = renderingEngine.getViewport(data.viewportId);\n            const linkedViewportAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return otherViewportControllable === true;\n            });\n            if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const viewPlaneNormal = camera.viewPlaneNormal;\n            vtkMath.normalize(viewPlaneNormal);\n            const otherViewportsAnnotationsWithSameCameraDirection = linkedViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                return (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\n                    csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2));\n            });\n            return otherViewportsAnnotationsWithSameCameraDirection;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = !this.configuration.mobile?.enabled;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            this.editData.annotation.data.handles.activeOperation = null;\n            this.editData.annotation.data.activeViewportIds = [];\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            const requireSameOrientation = false;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const delta = eventDetail.deltaPoints.world;\n            if (Math.abs(delta[0]) < 1e-3 &&\n                Math.abs(delta[1]) < 1e-3 &&\n                Math.abs(delta[2]) < 1e-3) {\n                return;\n            }\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            if (viewport.type === Enums.ViewportType.VOLUME_3D) {\n                return;\n            }\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation) {\n                return;\n            }\n            const { handles } = viewportAnnotation.data;\n            if (handles.activeOperation === OPERATION.DRAG) {\n                if (handles.activeType === 'min') {\n                    this.toolCenterMin[0] += delta[0];\n                    this.toolCenterMin[1] += delta[1];\n                    this.toolCenterMin[2] += delta[2];\n                }\n                else if (handles.activeType === 'max') {\n                    this.toolCenterMax[0] += delta[0];\n                    this.toolCenterMax[1] += delta[1];\n                    this.toolCenterMax[2] += delta[2];\n                }\n                else {\n                    this.toolCenter[0] += delta[0];\n                    this.toolCenter[1] += delta[1];\n                    this.toolCenter[2] += delta[2];\n                }\n                const viewportsInfo = this._getViewportsInfo();\n                triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n                triggerEvent(eventTarget, Events.VOLUMECROPPINGCONTROL_TOOL_CHANGED, {\n                    toolGroupId: this.toolGroupId,\n                    toolCenter: this.toolCenter,\n                    toolCenterMin: this.toolCenterMin,\n                    toolCenterMax: this.toolCenterMax,\n                    handleType: handles.activeType,\n                    viewportOrientation: [],\n                    seriesInstanceUID: this.seriesInstanceUID,\n                });\n            }\n        };\n        this._getReferenceLineColor =\n            toolProps.configuration?.getReferenceLineColor ||\n                defaultReferenceLineColor;\n        this._getReferenceLineControllable =\n            toolProps.configuration?.getReferenceLineControllable ||\n                defaultReferenceLineControllable;\n        const viewportsInfo = getToolGroup(this.toolGroupId)?.viewportsInfo;\n        eventTarget.addEventListener(Events.VOLUMECROPPING_TOOL_CHANGED, this._onSphereMoved);\n        if (viewportsInfo && viewportsInfo.length > 0) {\n            const { viewportId, renderingEngineId } = viewportsInfo[0];\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            const viewport = renderingEngine.getViewport(viewportId);\n            const volumeActors = viewport.getActors();\n            if (!volumeActors || !volumeActors.length) {\n                console.warn(`VolumeCroppingControlTool: No volume actors found in viewport ${viewportId}.`);\n                return;\n            }\n            const imageData = volumeActors[0].actor.getMapper().getInputData();\n            if (imageData) {\n                const dimensions = imageData.getDimensions();\n                const spacing = imageData.getSpacing();\n                const origin = imageData.getOrigin();\n                this.seriesInstanceUID = imageData.seriesInstanceUID || 'unknown';\n                const cropFactor = this.configuration.initialCropFactor ?? 0.2;\n                this.toolCenter = [\n                    origin[0] + cropFactor * (dimensions[0] - 1) * spacing[0],\n                    origin[1] + cropFactor * (dimensions[1] - 1) * spacing[1],\n                    origin[2] + cropFactor * (dimensions[2] - 1) * spacing[2],\n                ];\n                const maxCropFactor = 1 - cropFactor;\n                this.toolCenterMin = [\n                    origin[0] + cropFactor * (dimensions[0] - 1) * spacing[0],\n                    origin[1] + cropFactor * (dimensions[1] - 1) * spacing[1],\n                    origin[2] + cropFactor * (dimensions[2] - 1) * spacing[2],\n                ];\n                this.toolCenterMax = [\n                    origin[0] + maxCropFactor * (dimensions[0] - 1) * spacing[0],\n                    origin[1] + maxCropFactor * (dimensions[1] - 1) * spacing[1],\n                    origin[2] + maxCropFactor * (dimensions[2] - 1) * spacing[2],\n                ];\n            }\n        }\n    }\n    _updateToolCentersFromViewport(viewport) {\n        const volumeActors = viewport.getActors();\n        if (!volumeActors || !volumeActors.length) {\n            return;\n        }\n        const imageData = volumeActors[0].actor.getMapper().getInputData();\n        if (!imageData) {\n            return;\n        }\n        this.seriesInstanceUID = imageData.seriesInstanceUID || 'unknown';\n        const dimensions = imageData.getDimensions();\n        const spacing = imageData.getSpacing();\n        const origin = imageData.getOrigin();\n        const cropFactor = this.configuration.initialCropFactor ?? 0.2;\n        const cropStart = cropFactor / 2;\n        const cropEnd = 1 - cropFactor / 2;\n        this.toolCenter = [\n            origin[0] +\n                ((cropStart + cropEnd) / 2) * (dimensions[0] - 1) * spacing[0],\n            origin[1] +\n                ((cropStart + cropEnd) / 2) * (dimensions[1] - 1) * spacing[1],\n            origin[2] +\n                ((cropStart + cropEnd) / 2) * (dimensions[2] - 1) * spacing[2],\n        ];\n        this.toolCenterMin = [\n            origin[0] + cropStart * (dimensions[0] - 1) * spacing[0],\n            origin[1] + cropStart * (dimensions[1] - 1) * spacing[1],\n            origin[2] + cropStart * (dimensions[2] - 1) * spacing[2],\n        ];\n        this.toolCenterMax = [\n            origin[0] + cropEnd * (dimensions[0] - 1) * spacing[0],\n            origin[1] + cropEnd * (dimensions[1] - 1) * spacing[1],\n            origin[2] + cropEnd * (dimensions[2] - 1) * spacing[2],\n        ];\n    }\n    onSetToolInactive() {\n        console.debug(`VolumeCroppingControlTool: onSetToolInactive called for tool ${this.getToolName()}`);\n    }\n    onSetToolActive() {\n        const viewportsInfo = this._getViewportsInfo();\n        let anyAnnotationExists = false;\n        for (const vpInfo of viewportsInfo) {\n            const enabledElement = getEnabledElementByIds(vpInfo.viewportId, vpInfo.renderingEngineId);\n            const annotations = this._getAnnotations(enabledElement);\n            if (annotations && annotations.length > 0) {\n                anyAnnotationExists = true;\n                break;\n            }\n        }\n        if (!anyAnnotationExists) {\n            this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n            this._subscribeToViewportNewVolumeSet(viewportsInfo);\n            this._computeToolCenter(viewportsInfo);\n            triggerEvent(eventTarget, Events.VOLUMECROPPINGCONTROL_TOOL_CHANGED, {\n                toolGroupId: this.toolGroupId,\n                viewportsInfo: viewportsInfo,\n                seriesInstanceUID: this.seriesInstanceUID,\n            });\n        }\n        else {\n            for (const vpInfo of viewportsInfo) {\n                const enabledElement = getEnabledElementByIds(vpInfo.viewportId, vpInfo.renderingEngineId);\n                if (!enabledElement) {\n                    continue;\n                }\n                const annotations = this._getAnnotations(enabledElement);\n                if (annotations && annotations.length > 0) {\n                    annotations.forEach((annotation) => {\n                        removeAnnotation(annotation.annotationUID);\n                    });\n                }\n                enabledElement.viewport.render();\n            }\n        }\n    }\n    onSetToolEnabled() {\n        console.debug(`VolumeCroppingControlTool: onSetToolEnabled called for tool ${this.getToolName()}`);\n        const viewportsInfo = this._getViewportsInfo();\n    }\n    onSetToolDisabled() {\n        console.debug(`VolumeCroppingControlTool: onSetToolDisabled called for tool ${this.getToolName()}`);\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n        viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const annotations = this._getAnnotations(enabledElement);\n            if (annotations?.length) {\n                annotations.forEach((annotation) => {\n                    removeAnnotation(annotation.annotationUID);\n                });\n            }\n        });\n    }\n    _getOrientationFromNormal(normal) {\n        if (!normal) {\n            return null;\n        }\n        const canonical = {\n            AXIAL: [0, 0, 1],\n            CORONAL: [0, 1, 0],\n            SAGITTAL: [1, 0, 0],\n        };\n        const tol = 1e-2;\n        for (const [key, value] of Object.entries(canonical)) {\n            if (Math.abs(normal[0] - value[0]) < tol &&\n                Math.abs(normal[1] - value[1]) < tol &&\n                Math.abs(normal[2] - value[2]) < tol) {\n                return key;\n            }\n            if (Math.abs(normal[0] + value[0]) < tol &&\n                Math.abs(normal[1] + value[1]) < tol &&\n                Math.abs(normal[2] + value[2]) < tol) {\n                return key;\n            }\n        }\n        return null;\n    }\n    _syncWithVolumeCroppingTool(originalClippingPlanes) {\n        const planes = originalClippingPlanes;\n        if (planes.length >= 6) {\n            this.toolCenterMin = [\n                planes[0].origin[0],\n                planes[2].origin[1],\n                planes[4].origin[2],\n            ];\n            this.toolCenterMax = [\n                planes[1].origin[0],\n                planes[3].origin[1],\n                planes[5].origin[2],\n            ];\n            this.toolCenter = [\n                (this.toolCenterMin[0] + this.toolCenterMax[0]) / 2,\n                (this.toolCenterMin[1] + this.toolCenterMax[1]) / 2,\n                (this.toolCenterMin[2] + this.toolCenterMax[2]) / 2,\n            ];\n            const viewportsInfo = this._getViewportsInfo();\n            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n                if (enabledElement) {\n                    const annotations = this._getAnnotations(enabledElement);\n                    annotations.forEach((annotation) => {\n                        if (annotation.data &&\n                            annotation.data.handles &&\n                            annotation.data.orientation) {\n                            const orientation = annotation.data.orientation;\n                            if (orientation === 'AXIAL') {\n                                annotation.data.handles.toolCenterMin = [\n                                    planes[0].origin[0],\n                                    planes[2].origin[1],\n                                    annotation.data.handles.toolCenterMin[2],\n                                ];\n                                annotation.data.handles.toolCenterMax = [\n                                    planes[1].origin[0],\n                                    planes[3].origin[1],\n                                    annotation.data.handles.toolCenterMax[2],\n                                ];\n                            }\n                            else if (orientation === 'CORONAL') {\n                                annotation.data.handles.toolCenterMin = [\n                                    planes[0].origin[0],\n                                    annotation.data.handles.toolCenterMin[1],\n                                    planes[4].origin[2],\n                                ];\n                                annotation.data.handles.toolCenterMax = [\n                                    planes[1].origin[0],\n                                    annotation.data.handles.toolCenterMax[1],\n                                    planes[5].origin[2],\n                                ];\n                            }\n                            else if (orientation === 'SAGITTAL') {\n                                annotation.data.handles.toolCenterMin = [\n                                    annotation.data.handles.toolCenterMin[0],\n                                    planes[2].origin[1],\n                                    planes[4].origin[2],\n                                ];\n                                annotation.data.handles.toolCenterMax = [\n                                    annotation.data.handles.toolCenterMax[0],\n                                    planes[3].origin[1],\n                                    planes[5].origin[2],\n                                ];\n                            }\n                            annotation.data.handles.toolCenter = [\n                                (annotation.data.handles.toolCenterMin[0] +\n                                    annotation.data.handles.toolCenterMax[0]) /\n                                    2,\n                                (annotation.data.handles.toolCenterMin[1] +\n                                    annotation.data.handles.toolCenterMax[1]) /\n                                    2,\n                                (annotation.data.handles.toolCenterMin[2] +\n                                    annotation.data.handles.toolCenterMax[2]) /\n                                    2,\n                            ];\n                        }\n                    });\n                }\n            });\n            if (this._virtualAnnotations && this._virtualAnnotations.length > 0) {\n                this._virtualAnnotations.forEach((annotation) => {\n                    if (annotation.data &&\n                        annotation.data.handles &&\n                        annotation.data.orientation) {\n                        const orientation = annotation.data.orientation.toUpperCase();\n                        if (orientation === 'AXIAL') {\n                            annotation.data.handles.toolCenterMin = [\n                                planes[0].origin[0],\n                                planes[2].origin[1],\n                                annotation.data.handles.toolCenterMin[2],\n                            ];\n                            annotation.data.handles.toolCenterMax = [\n                                planes[1].origin[0],\n                                planes[3].origin[1],\n                                annotation.data.handles.toolCenterMax[2],\n                            ];\n                        }\n                        else if (orientation === 'CORONAL') {\n                            annotation.data.handles.toolCenterMin = [\n                                planes[0].origin[0],\n                                annotation.data.handles.toolCenterMin[1],\n                                planes[4].origin[2],\n                            ];\n                            annotation.data.handles.toolCenterMax = [\n                                planes[1].origin[0],\n                                annotation.data.handles.toolCenterMax[1],\n                                planes[5].origin[2],\n                            ];\n                        }\n                        else if (orientation === 'SAGITTAL') {\n                            annotation.data.handles.toolCenterMin = [\n                                annotation.data.handles.toolCenterMin[0],\n                                planes[2].origin[1],\n                                planes[4].origin[2],\n                            ];\n                            annotation.data.handles.toolCenterMax = [\n                                annotation.data.handles.toolCenterMax[0],\n                                planes[3].origin[1],\n                                planes[5].origin[2],\n                            ];\n                        }\n                        annotation.data.handles.toolCenter = [\n                            (annotation.data.handles.toolCenterMin[0] +\n                                annotation.data.handles.toolCenterMax[0]) /\n                                2,\n                            (annotation.data.handles.toolCenterMin[1] +\n                                annotation.data.handles.toolCenterMax[1]) /\n                                2,\n                            (annotation.data.handles.toolCenterMin[2] +\n                                annotation.data.handles.toolCenterMax[2]) /\n                                2,\n                        ];\n                    }\n                });\n            }\n            triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        }\n    }\n    setToolCenter(toolCenter, handleType) {\n        if (handleType === 'min') {\n            this.toolCenterMin = [...toolCenter];\n        }\n        else if (handleType === 'max') {\n            this.toolCenterMax = [...toolCenter];\n        }\n        const viewportsInfo = this._getViewportsInfo();\n        triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const annotations = this._getAnnotations(enabledElement);\n        const filteredAnnotations = this.filterInteractableAnnotationsForElement(viewport.element, annotations);\n        if (!filteredAnnotations ||\n            filteredAnnotations.length === 0 ||\n            !filteredAnnotations[0]) {\n            return null;\n        }\n        const { data } = filteredAnnotations[0];\n        const viewportIdArray = [];\n        const referenceLines = data.referenceLines || [];\n        for (let i = 0; i < referenceLines.length; ++i) {\n            const otherViewport = referenceLines[i][0];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            if (!viewportControllable) {\n                continue;\n            }\n            viewportIdArray.push(otherViewport.id);\n            i++;\n        }\n        data.activeViewportIds = [...viewportIdArray];\n        data.handles.activeOperation = OPERATION.DRAG;\n        evt.preventDefault();\n        hideElementCursor(element);\n        this._activateModify(element);\n        return filteredAnnotations[0];\n    }\n    handleSelectedCallback(evt, annotation, handle, interactionType) {\n        this.toolSelectedCallback(evt, annotation, interactionType);\n    }\n    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _subscribeToViewportNewVolumeSet(viewports) {\n        viewports.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta) {\n        viewportsAnnotationsToUpdate.forEach((annotation) => {\n            this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\n        });\n    }\n    _applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta) {\n        const { data } = annotation;\n        const viewport = renderingEngine.getViewport(data.viewportId);\n        const camera = viewport.getCamera();\n        const normal = camera.viewPlaneNormal;\n        const dotProd = vtkMath.dot(delta, normal);\n        const projectedDelta = [...normal];\n        vtkMath.multiplyScalar(projectedDelta, dotProd);\n        if (Math.abs(projectedDelta[0]) > 1e-3 ||\n            Math.abs(projectedDelta[1]) > 1e-3 ||\n            Math.abs(projectedDelta[2]) > 1e-3) {\n            const newFocalPoint = [0, 0, 0];\n            const newPosition = [0, 0, 0];\n            vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\n            vtkMath.add(camera.position, projectedDelta, newPosition);\n            viewport.setCamera({\n                focalPoint: newFocalPoint,\n                position: newPosition,\n            });\n            viewport.render();\n        }\n    }\n    _pointNearTool(element, annotation, canvasCoords, proximity) {\n        const { data } = annotation;\n        const referenceLines = data.referenceLines;\n        const viewportIdArray = [];\n        if (referenceLines) {\n            for (let i = 0; i < referenceLines.length; ++i) {\n                const otherViewport = referenceLines[i][0];\n                const start1 = referenceLines[i][1];\n                const end1 = referenceLines[i][2];\n                const type = referenceLines[i][3];\n                const distance1 = lineSegment.distanceToPoint(start1, end1, [\n                    canvasCoords[0],\n                    canvasCoords[1],\n                ]);\n                if (distance1 <= proximity) {\n                    viewportIdArray.push(otherViewport.id);\n                    data.handles.activeOperation = 1;\n                    data.handles.activeType = type;\n                }\n            }\n        }\n        data.activeViewportIds = [...viewportIdArray];\n        this.editData = {\n            annotation,\n        };\n        return data.handles.activeOperation === 1 ? true : false;\n    }\n}\nVolumeCroppingControlTool.toolName = 'VolumeCroppingControl';\nexport default VolumeCroppingControlTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport, cache, utilities, } from '@cornerstonejs/core';\nconst DEFAULT_MULTIPLIER = 4;\nconst DEFAULT_IMAGE_DYNAMIC_RANGE = 1024;\nconst PT = 'PT';\nclass WindowLevelTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this._getImageDynamicRangeFromMiddleSlice = (scalarData, dimensions) => {\n            const middleSliceIndex = Math.floor(dimensions[2] / 2);\n            const frameLength = dimensions[0] * dimensions[1];\n            let bytesPerVoxel;\n            let TypedArrayConstructor;\n            if (scalarData instanceof Float32Array) {\n                bytesPerVoxel = 4;\n                TypedArrayConstructor = Float32Array;\n            }\n            else if (scalarData instanceof Uint8Array) {\n                bytesPerVoxel = 1;\n                TypedArrayConstructor = Uint8Array;\n            }\n            else if (scalarData instanceof Uint16Array) {\n                bytesPerVoxel = 2;\n                TypedArrayConstructor = Uint16Array;\n            }\n            else if (scalarData instanceof Int16Array) {\n                bytesPerVoxel = 2;\n                TypedArrayConstructor = Int16Array;\n            }\n            const buffer = scalarData.buffer;\n            const byteOffset = middleSliceIndex * frameLength * bytesPerVoxel;\n            const frame = new TypedArrayConstructor(buffer, byteOffset, frameLength);\n            const { max, min } = this._getMinMax(frame, frameLength);\n            return max - min;\n        };\n    }\n    touchDragCallback(evt) {\n        this.mouseDragCallback(evt);\n    }\n    mouseDragCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let volumeId, lower, upper, modality, newRange, viewportsContainingVolumeUID;\n        let isPreScaled = false;\n        const properties = viewport.getProperties();\n        if (viewport instanceof VolumeViewport) {\n            volumeId = viewport.getVolumeId();\n            viewportsContainingVolumeUID =\n                utilities.getViewportsWithVolumeId(volumeId);\n            ({ lower, upper } = properties.voiRange);\n            const volume = cache.getVolume(volumeId);\n            if (!volume) {\n                throw new Error('Volume not found ' + volumeId);\n            }\n            modality = volume.metadata.Modality;\n            isPreScaled = volume.scaling && Object.keys(volume.scaling).length > 0;\n        }\n        else if (properties.voiRange) {\n            modality = viewport.modality;\n            ({ lower, upper } = properties.voiRange);\n            const { preScale = { scaled: false } } = viewport.getImageData?.() || {};\n            isPreScaled =\n                preScale.scaled && preScale.scalingParameters?.suvbw !== undefined;\n        }\n        else {\n            throw new Error('Viewport is not a valid type');\n        }\n        if (modality === PT && isPreScaled) {\n            newRange = this.getPTScaledNewRange({\n                deltaPointsCanvas: deltaPoints.canvas,\n                lower,\n                upper,\n                clientHeight: element.clientHeight,\n                isPreScaled,\n                viewport,\n                volumeId,\n            });\n        }\n        else {\n            newRange = this.getNewRange({\n                viewport,\n                deltaPointsCanvas: deltaPoints.canvas,\n                volumeId,\n                lower,\n                upper,\n            });\n        }\n        if (newRange.lower >= newRange.upper) {\n            return;\n        }\n        viewport.setProperties({\n            voiRange: newRange,\n        });\n        viewport.render();\n        if (viewport instanceof VolumeViewport) {\n            viewportsContainingVolumeUID.forEach((vp) => {\n                if (viewport !== vp) {\n                    vp.render();\n                }\n            });\n            return;\n        }\n    }\n    getPTScaledNewRange({ deltaPointsCanvas, lower, upper, clientHeight, viewport, volumeId, isPreScaled, }) {\n        let multiplier = DEFAULT_MULTIPLIER;\n        if (isPreScaled) {\n            multiplier = 5 / clientHeight;\n        }\n        else {\n            multiplier =\n                this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n                    DEFAULT_MULTIPLIER;\n        }\n        const deltaY = deltaPointsCanvas[1];\n        const wcDelta = deltaY * multiplier;\n        upper -= wcDelta;\n        upper = isPreScaled ? Math.max(upper, 0.1) : upper;\n        return { lower, upper };\n    }\n    getNewRange({ viewport, deltaPointsCanvas, volumeId, lower, upper }) {\n        const multiplier = this._getMultiplierFromDynamicRange(viewport, volumeId) ||\n            DEFAULT_MULTIPLIER;\n        const wwDelta = deltaPointsCanvas[0] * multiplier;\n        const wcDelta = deltaPointsCanvas[1] * multiplier;\n        let { windowWidth, windowCenter } = utilities.windowLevel.toWindowLevel(lower, upper);\n        windowWidth += wwDelta;\n        windowCenter += wcDelta;\n        windowWidth = Math.max(windowWidth, 1);\n        const voiLutFunction = viewport.getProperties().VOILUTFunction;\n        return utilities.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);\n    }\n    _getMultiplierFromDynamicRange(viewport, volumeId) {\n        let imageDynamicRange;\n        if (volumeId) {\n            const imageVolume = cache.getVolume(volumeId);\n            const { voxelManager } = viewport.getImageData();\n            const middleSlicePixelData = voxelManager.getMiddleSliceData();\n            const calculatedDynamicRange = middleSlicePixelData.reduce((acc, pixel) => {\n                return [Math.min(acc[0], pixel), Math.max(acc[1], pixel)];\n            }, [Infinity, -Infinity]);\n            const BitsStored = imageVolume?.metadata?.BitsStored;\n            const metadataDynamicRange = BitsStored ? 2 ** BitsStored : Infinity;\n            const calculatedRange = calculatedDynamicRange[1] - calculatedDynamicRange[0];\n            imageDynamicRange = !Number.isFinite(calculatedRange)\n                ? metadataDynamicRange\n                : Math.min(calculatedRange, metadataDynamicRange);\n        }\n        else {\n            imageDynamicRange = this._getImageDynamicRangeFromViewport(viewport);\n        }\n        const ratio = imageDynamicRange / DEFAULT_IMAGE_DYNAMIC_RANGE;\n        return !Number.isFinite(ratio)\n            ? DEFAULT_IMAGE_DYNAMIC_RANGE\n            : ratio > 1\n                ? Math.round(ratio)\n                : ratio;\n    }\n    _getImageDynamicRangeFromViewport(viewport) {\n        const { imageData, voxelManager } = viewport.getImageData();\n        if (voxelManager?.getRange) {\n            const range = voxelManager.getRange();\n            return range[1] - range[0];\n        }\n        const dimensions = imageData.getDimensions();\n        if (imageData.getRange) {\n            const imageDataRange = imageData.getRange();\n            return imageDataRange[1] - imageDataRange[0];\n        }\n        let scalarData;\n        if (imageData.getScalarData) {\n            scalarData = imageData.getScalarData();\n        }\n        else {\n            scalarData = imageData.getPointData().getScalars().getData();\n        }\n        if (dimensions[2] !== 1) {\n            return this._getImageDynamicRangeFromMiddleSlice(scalarData, dimensions);\n        }\n        let range;\n        if (scalarData.getRange) {\n            range = scalarData.getRange();\n        }\n        else {\n            const { min, max } = this._getMinMax(scalarData, scalarData.length);\n            range = [min, max];\n        }\n        return range[1] - range[0];\n    }\n    _getMinMax(frame, frameLength) {\n        let min = Infinity;\n        let max = -Infinity;\n        for (let i = 0; i < frameLength; i++) {\n            const voxel = frame[i];\n            if (voxel < min) {\n                min = voxel;\n            }\n            if (voxel > max) {\n                max = voxel;\n            }\n        }\n        return { max, min };\n    }\n}\nWindowLevelTool.toolName = 'WindowLevel';\nexport default WindowLevelTool;\n","import { AnnotationTool } from './base';\nimport { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../stateManagement';\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\nimport { drawRect as drawRectSvg } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { windowLevel } from '../utilities/voi';\nclass WindowLevelRegionTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            minWindowWidth: 10,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                    },\n                    cachedStats: {},\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            removeAnnotation(annotation.annotationUID);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationCompleted(annotation);\n            this.applyWindowLevelRegion(annotation, element);\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            const { currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n            const worldPos = currentPoints.world;\n            const { points } = data.handles;\n            const DEFAULT_HANDLE_INDEX = 3;\n            points[DEFAULT_HANDLE_INDEX] = [...worldPos];\n            const bottomLeftCanvas = worldToCanvas(points[0]);\n            const topRightCanvas = worldToCanvas(points[3]);\n            const bottomRightCanvas = [\n                topRightCanvas[0],\n                bottomLeftCanvas[1],\n            ];\n            const topLeftCanvas = [\n                bottomLeftCanvas[0],\n                topRightCanvas[1],\n            ];\n            const bottomRightWorld = canvasToWorld(bottomRightCanvas);\n            const topLeftWorld = canvasToWorld(topLeftCanvas);\n            points[1] = bottomRightWorld;\n            points[2] = topLeftWorld;\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const dataId = `${annotationUID}-rect`;\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this.applyWindowLevelRegion = (annotation, element) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const imageData = windowLevel.extractWindowLevelRegionToolData(viewport);\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const startCanvas = canvasCoordinates[0];\n            const endCanvas = canvasCoordinates[3];\n            let left = Math.min(startCanvas[0], endCanvas[0]);\n            let top = Math.min(startCanvas[1], endCanvas[1]);\n            let width = Math.abs(startCanvas[0] - endCanvas[0]);\n            let height = Math.abs(startCanvas[1] - endCanvas[1]);\n            left = utilities.clip(left, 0, imageData.width);\n            top = utilities.clip(top, 0, imageData.height);\n            width = Math.floor(Math.min(width, Math.abs(imageData.width - left)));\n            height = Math.floor(Math.min(height, Math.abs(imageData.height - top)));\n            const pixelLuminanceData = windowLevel.getLuminanceFromRegion(imageData, Math.round(left), Math.round(top), width, height);\n            const minMaxMean = windowLevel.calculateMinMaxMean(pixelLuminanceData, imageData.minPixelValue, imageData.maxPixelValue);\n            if (this.configuration.minWindowWidth === undefined) {\n                this.configuration.minWindowWidth = 10;\n            }\n            const windowWidth = Math.max(Math.abs(minMaxMean.max - minMaxMean.min), this.configuration.minWindowWidth);\n            const windowCenter = minMaxMean.mean;\n            const voiLutFunction = viewport.getProperties().VOILUTFunction;\n            const voiRange = utilities.windowLevel.toLowHighRange(windowWidth, windowCenter, voiLutFunction);\n            viewport.setProperties({ voiRange });\n            viewport.render();\n        };\n        this.cancel = () => {\n            return null;\n        };\n        this.isPointNearTool = () => {\n            return null;\n        };\n        this.toolSelectedCallback = () => {\n            return null;\n        };\n        this.handleSelectedCallback = () => {\n            return null;\n        };\n        this._activateModify = () => {\n            return null;\n        };\n        this._deactivateModify = () => {\n            return null;\n        };\n    }\n}\nWindowLevelRegionTool.toolName = 'WindowLevelRegion';\nexport default WindowLevelRegionTool;\n","function getLuminanceFromRegion(imageData, x, y, width, height) {\n    const luminance = [];\n    let index = 0;\n    const pixelData = imageData.scalarData;\n    let spIndex, row, column;\n    if (imageData.color) {\n        for (row = 0; row < height; row++) {\n            for (column = 0; column < width; column++) {\n                spIndex = ((row + y) * imageData.columns + (column + x)) * 4;\n                const red = pixelData[spIndex];\n                const green = pixelData[spIndex + 1];\n                const blue = pixelData[spIndex + 2];\n                luminance[index++] = 0.2126 * red + 0.7152 * green + 0.0722 * blue;\n            }\n        }\n    }\n    else {\n        for (row = 0; row < height; row++) {\n            for (column = 0; column < width; column++) {\n                spIndex = (row + y) * imageData.columns + (column + x);\n                luminance[index++] = pixelData[spIndex];\n            }\n        }\n    }\n    return luminance;\n}\nexport { getLuminanceFromRegion };\n","function calculateMinMaxMean(pixelLuminance, globalMin, globalMax) {\n    const numPixels = pixelLuminance.length;\n    let min = globalMax;\n    let max = globalMin;\n    let sum = 0;\n    if (numPixels < 2) {\n        return {\n            min,\n            max,\n            mean: (globalMin + globalMax) / 2,\n        };\n    }\n    for (let index = 0; index < numPixels; index++) {\n        const spv = pixelLuminance[index];\n        min = Math.min(min, spv);\n        max = Math.max(max, spv);\n        sum += spv;\n    }\n    return {\n        min,\n        max,\n        mean: sum / numPixels,\n    };\n}\nexport { calculateMinMaxMean };\n","import { getEnabledElementByIds, getEnabledElement, VolumeViewport, BaseVolumeViewport, utilities, } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nclass StackScrollTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            invert: false,\n            debounceIfNotLoaded: true,\n            loop: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.deltaY = 1;\n    }\n    mouseWheelCallback(evt) {\n        this._scroll(evt);\n    }\n    mouseDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    touchDragCallback(evt) {\n        this._dragCallback(evt);\n    }\n    _dragCallback(evt) {\n        this._scrollDrag(evt);\n    }\n    _scrollDrag(evt) {\n        const { deltaPoints, viewportId, renderingEngineId } = evt.detail;\n        const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n        const { debounceIfNotLoaded, invert, loop } = this.configuration;\n        const deltaPointY = deltaPoints.canvas[1];\n        let volumeId;\n        if (viewport instanceof VolumeViewport) {\n            volumeId = viewport.getVolumeId();\n        }\n        const pixelsPerImage = this._getPixelPerImage(viewport);\n        const deltaY = deltaPointY + this.deltaY;\n        if (!pixelsPerImage) {\n            return;\n        }\n        if (Math.abs(deltaY) >= pixelsPerImage) {\n            const imageIdIndexOffset = Math.round(deltaY / pixelsPerImage);\n            utilities.scroll(viewport, {\n                delta: invert ? -imageIdIndexOffset : imageIdIndexOffset,\n                volumeId,\n                debounceLoading: debounceIfNotLoaded,\n                loop: loop,\n            });\n            this.deltaY = deltaY % pixelsPerImage;\n        }\n        else {\n            this.deltaY = deltaY;\n        }\n    }\n    _scroll(evt) {\n        const { wheel, element } = evt.detail;\n        const { direction } = wheel;\n        const { invert } = this.configuration;\n        const { viewport } = getEnabledElement(element);\n        const delta = direction * (invert ? -1 : 1);\n        utilities.scroll(viewport, {\n            delta,\n            debounceLoading: this.configuration.debounceIfNotLoaded,\n            loop: this.configuration.loop,\n            volumeId: viewport instanceof BaseVolumeViewport\n                ? viewport.getVolumeId()\n                : undefined,\n            scrollSlabs: this.configuration.scrollSlabs,\n        });\n    }\n    _getPixelPerImage(viewport) {\n        const { element } = viewport;\n        const numberOfSlices = viewport.getNumberOfSlices();\n        return Math.max(2, element.offsetHeight / Math.max(numberOfSlices, 8));\n    }\n}\nStackScrollTool.toolName = 'StackScroll';\nexport default StackScrollTool;\n","import { BaseVolumeViewport, getEnabledElement } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nimport { BaseTool } from './base';\nimport angleBetweenLines from '../utilities/math/angle/angleBetweenLines';\nclass PlanarRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseWheelCallback = (evt) => {\n            const { element, wheel } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { invert } = this.configuration;\n            const angle = wheel.direction * 10 * (invert ? -1 : 1);\n            this.setAngle(viewport, angle);\n        };\n        this.touchDragCallback = this._dragCallback.bind(this);\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    _dragCallback(evt) {\n        const { element, currentPoints, startPoints } = evt.detail;\n        const currentPointWorld = currentPoints.world;\n        const startPointWorld = startPoints.world;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const width = element.clientWidth;\n        const height = element.clientHeight;\n        const centerCanvas = [width * 0.5, height * 0.5];\n        const centerWorld = viewport.canvasToWorld(centerCanvas);\n        let angle = angleBetweenLines([startPointWorld, centerWorld], [centerWorld, currentPointWorld]);\n        const { viewPlaneNormal } = camera;\n        const v1 = vec3.sub(vec3.create(), centerWorld, startPointWorld);\n        const v2 = vec3.sub(vec3.create(), centerWorld, currentPointWorld);\n        const cross = vec3.cross(vec3.create(), v1, v2);\n        if (vec3.dot(viewPlaneNormal, cross) > 0) {\n            angle = -angle;\n        }\n        if (Number.isNaN(angle)) {\n            return;\n        }\n        this.setAngle(viewport, angle);\n    }\n    setAngle(viewport, angle) {\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        if (viewport instanceof BaseVolumeViewport) {\n            const rotAngle = (((angle + 360) % 360) * Math.PI) / 180;\n            const rotMat = mat4.identity(new Float32Array(16));\n            mat4.rotate(rotMat, rotMat, rotAngle, viewPlaneNormal);\n            const rotatedViewUp = vec3.transformMat4(vec3.create(), viewUp, rotMat);\n            viewport.setCamera({ viewUp: rotatedViewUp });\n        }\n        else {\n            const { rotation } = viewport.getViewPresentation();\n            viewport.setViewPresentation({\n                rotation: (rotation + angle + 360) % 360,\n            });\n        }\n        viewport.render();\n    }\n}\nPlanarRotateTool.toolName = 'PlanarRotate';\nexport default PlanarRotateTool;\n","import { vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { getConfiguration } from '@cornerstonejs/core';\nimport { Enums, getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { Events } from '../enums';\nclass ZoomTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            zoomToCenter: false,\n            minZoomScale: 0.001,\n            maxZoomScale: 3000,\n            pinchToZoom: true,\n            pan: true,\n            invert: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const camera = enabledElement.viewport.getCamera();\n            const { focalPoint } = camera;\n            this.initialMousePosWorld = worldPos;\n            let dirVec = vec3.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);\n            dirVec = vec3.normalize(vec3.create(), dirVec);\n            this.dirVec = dirVec;\n            return false;\n        };\n        this.preTouchStartCallback = (evt) => {\n            if (!this.configuration.pinchToZoom) {\n                return this.preMouseDownCallback(evt);\n            }\n        };\n        this._dragParallelProjection = (evt, viewport, camera, pinch = false) => {\n            const { element, deltaPoints } = evt.detail;\n            const deltaY = pinch\n                ? evt.detail.deltaDistance.canvas\n                : deltaPoints.canvas[1];\n            const size = [element.clientWidth, element.clientHeight];\n            const { parallelScale, focalPoint, position } = camera;\n            const zoomScale = 5 / size[1];\n            const k = deltaY * zoomScale * (this.configuration.invert ? -1 : 1);\n            const parallelScaleToSet = (1.0 - k) * parallelScale;\n            let focalPointToSet = focalPoint;\n            let positionToSet = position;\n            if (!this.configuration.zoomToCenter) {\n                const distanceToCanvasCenter = vec3.distance(focalPoint, this.initialMousePosWorld);\n                positionToSet = vec3.scaleAndAdd(vec3.create(), position, this.dirVec, -distanceToCanvasCenter * k);\n                focalPointToSet = vec3.scaleAndAdd(vec3.create(), focalPoint, this.dirVec, -distanceToCanvasCenter * k);\n            }\n            const imageData = viewport.getImageData();\n            let spacing = [1, 1, 1];\n            let cappedParallelScale = parallelScaleToSet;\n            let thresholdExceeded = false;\n            if (imageData) {\n                spacing = imageData.spacing;\n                const { dimensions } = imageData;\n                const imageWidth = dimensions[0] * spacing[0];\n                const imageHeight = dimensions[1] * spacing[1];\n                const canvasAspect = size[0] / size[1];\n                const insetImageMultiplier = getConfiguration().rendering\n                    ?.useLegacyCameraFOV\n                    ? 1.1\n                    : 1;\n                const displayArea = viewport.options?.displayArea;\n                const imageAreaScaleX = displayArea?.imageArea?.[0] ?? insetImageMultiplier;\n                const imageAreaScaleY = displayArea?.imageArea?.[1] ?? insetImageMultiplier;\n                const scaledImageWidth = imageWidth * imageAreaScaleX;\n                const scaledImageHeight = imageHeight * imageAreaScaleY;\n                const scaledImageAspect = scaledImageWidth / scaledImageHeight;\n                let minParallelScaleRequired;\n                if (scaledImageAspect > canvasAspect) {\n                    minParallelScaleRequired = (scaledImageWidth / canvasAspect) * 0.5;\n                }\n                else {\n                    minParallelScaleRequired = scaledImageHeight * 0.5;\n                }\n                const { minZoomScale, maxZoomScale } = this.configuration;\n                const minScaleInWorld = minParallelScaleRequired / maxZoomScale;\n                const maxScaleInWorld = minParallelScaleRequired / minZoomScale;\n                if (parallelScaleToSet < minScaleInWorld) {\n                    cappedParallelScale = minScaleInWorld;\n                    thresholdExceeded = true;\n                }\n                else if (parallelScaleToSet > maxScaleInWorld) {\n                    cappedParallelScale = maxScaleInWorld;\n                    thresholdExceeded = true;\n                }\n            }\n            viewport.setCamera({\n                parallelScale: cappedParallelScale,\n                focalPoint: thresholdExceeded ? focalPoint : focalPointToSet,\n                position: thresholdExceeded ? position : positionToSet,\n            });\n        };\n        this._dragPerspectiveProjection = (evt, viewport, camera, pinch = false) => {\n            const { element, deltaPoints } = evt.detail;\n            const deltaY = pinch\n                ? evt.detail.deltaDistance.canvas\n                : deltaPoints.canvas[1];\n            const size = [element.clientWidth, element.clientHeight];\n            const { position, focalPoint, viewPlaneNormal } = camera;\n            const distance = vtkMath.distance2BetweenPoints(position, focalPoint);\n            const zoomScale = Math.sqrt(distance) / size[1];\n            const directionOfProjection = [\n                -viewPlaneNormal[0],\n                -viewPlaneNormal[1],\n                -viewPlaneNormal[2],\n            ];\n            const k = this.configuration.invert\n                ? deltaY / zoomScale\n                : deltaY * zoomScale;\n            let tmp = k * directionOfProjection[0];\n            position[0] += tmp;\n            focalPoint[0] += tmp;\n            tmp = k * directionOfProjection[1];\n            position[1] += tmp;\n            focalPoint[1] += tmp;\n            tmp = k * directionOfProjection[2];\n            position[2] += tmp;\n            focalPoint[2] += tmp;\n            viewport.setCamera({ position, focalPoint });\n        };\n        this.initialMousePosWorld = [0, 0, 0];\n        this.dirVec = [0, 0, 0];\n        if (this.configuration.pinchToZoom) {\n            this.touchDragCallback = this._pinchCallback.bind(this);\n        }\n        else {\n            this.touchDragCallback = this._dragCallback.bind(this);\n        }\n        this.mouseDragCallback = this._dragCallback.bind(this);\n    }\n    mouseWheelCallback(evt) {\n        this._zoom(evt);\n    }\n    _pinchCallback(evt) {\n        const pointsList = evt.detail\n            .currentPointsList;\n        if (pointsList.length > 1) {\n            const { element, currentPoints } = evt.detail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const worldPos = currentPoints.world;\n            const { focalPoint } = camera;\n            this.initialMousePosWorld = worldPos;\n            let dirVec = vec3.fromValues(focalPoint[0] - worldPos[0], focalPoint[1] - worldPos[1], focalPoint[2] - worldPos[2]);\n            dirVec = vec3.normalize(vec3.create(), dirVec);\n            this.dirVec = dirVec;\n            if (camera.parallelProjection) {\n                this._dragParallelProjection(evt, viewport, camera, true);\n            }\n            else {\n                this._dragPerspectiveProjection(evt, viewport, camera, true);\n            }\n            viewport.render();\n        }\n        if (this.configuration.pan) {\n            this._panCallback(evt);\n        }\n    }\n    _dragCallback(evt) {\n        const { element } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        if (camera.parallelProjection) {\n            this._dragParallelProjection(evt, viewport, camera);\n        }\n        else {\n            this._dragPerspectiveProjection(evt, viewport, camera);\n        }\n        viewport.render();\n    }\n    _zoom(evt) {\n        const { element, points } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const wheelData = evt.detail.wheel;\n        const direction = wheelData.direction;\n        const eventDetails = {\n            detail: {\n                element,\n                eventName: Events.MOUSE_WHEEL,\n                renderingEngineId: enabledElement.renderingEngineId,\n                viewportId: viewport.id,\n                camera: {},\n                deltaPoints: {\n                    page: points.page,\n                    client: points.client,\n                    world: points.world,\n                    canvas: [0, -direction * 5],\n                },\n                startPoints: points,\n                lastPoints: points,\n                currentPoints: points,\n            },\n        };\n        if (viewport.type === Enums.ViewportType.STACK) {\n            this.preMouseDownCallback(eventDetails);\n        }\n        this._dragCallback(eventDetails);\n    }\n    _panCallback(evt) {\n        const { element, deltaPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const deltaPointsWorld = deltaPoints.world;\n        const camera = enabledElement.viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        enabledElement.viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        enabledElement.viewport.render();\n    }\n}\nZoomTool.toolName = 'Zoom';\nexport default ZoomTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement, VolumeViewport } from '@cornerstonejs/core';\nimport { utilities } from '@cornerstonejs/core';\nimport { getPointInLineOfSightWithCriteria } from '../utilities/planar';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass MIPJumpToClickTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            targetViewportIds: [],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    mouseClickCallback(evt) {\n        const { element, currentPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        const volumeId = viewport.getVolumeId();\n        if (!volumeId) {\n            throw new Error(`MIPJumpToClickTool: targetId is not a volumeId, you should only use MIPJumpToClickTool with a volumeId as the targetId`);\n        }\n        let maxIntensity = -Infinity;\n        const maxFn = (intensity, point) => {\n            if (intensity > maxIntensity) {\n                maxIntensity = intensity;\n                return point;\n            }\n        };\n        const brightestPoint = getPointInLineOfSightWithCriteria(viewport, currentPoints.world, volumeId, maxFn);\n        if (!brightestPoint || !brightestPoint.length) {\n            return;\n        }\n        const { targetViewportIds, toolGroupId } = this.configuration;\n        const viewports = renderingEngine.getViewports().filter((vp) => {\n            if (targetViewportIds?.indexOf(vp.id) >= 0) {\n                return true;\n            }\n            const foundToolGroup = getToolGroupForViewport(vp.id, renderingEngine.id);\n            if (toolGroupId && toolGroupId === foundToolGroup?.id) {\n                return true;\n            }\n            return false;\n        });\n        viewports.forEach((viewport) => {\n            if (viewport instanceof VolumeViewport) {\n                viewport.jumpToWorld(brightestPoint);\n            }\n            else {\n                console.warn('Cannot jump to specified world coordinates for a viewport that is not a VolumeViewport');\n            }\n        });\n    }\n}\nMIPJumpToClickTool.toolName = 'MIPJumpToClickTool';\nexport default MIPJumpToClickTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport vtkMatrixBuilder from '@kitware/vtk.js/Common/Core/MatrixBuilder';\nimport { AnnotationTool } from './base';\nimport { getRenderingEngine } from '@cornerstonejs/core';\nimport { getEnabledElementByIds, getEnabledElement, utilities as csUtils, Enums, CONSTANTS, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { getToolGroup, getToolGroupForViewport, } from '../store/ToolGroupManager';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLine as drawLineSvg, } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport liangBarksyClip from '../utilities/math/vec2/liangBarksyClip';\nimport * as lineSegment from '../utilities/math/line';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nconst { RENDERING_DEFAULTS } = CONSTANTS;\nfunction defaultReferenceLineColor() {\n    return 'rgb(0, 200, 0)';\n}\nfunction defaultReferenceLineControllable() {\n    return true;\n}\nfunction defaultReferenceLineDraggableRotatable() {\n    return true;\n}\nfunction defaultReferenceLineSlabThicknessControlsOn() {\n    return true;\n}\nconst OPERATION = {\n    DRAG: 1,\n    ROTATE: 2,\n    SLAB: 3,\n};\nclass CrosshairsTool extends AnnotationTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse'],\n        configuration: {\n            shadow: true,\n            viewportIndicators: false,\n            viewportIndicatorsConfig: {\n                radius: 5,\n                x: null,\n                y: null,\n            },\n            autoPan: {\n                enabled: false,\n                panSize: 10,\n            },\n            handleRadius: 3,\n            enableHDPIHandles: false,\n            referenceLinesCenterGapRadius: 20,\n            referenceLinesCenterGapRatio: null,\n            filterActorUIDsToSetSlabThickness: [],\n            slabThicknessBlendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n            centerPoint: {\n                enabled: false,\n                color: 'rgba(255, 255, 0, 0.5)',\n                size: 2,\n            },\n            mobile: {\n                enabled: false,\n                opacity: 0.8,\n                handleRadius: 9,\n                referenceLinesCenterGapRatio: 0.05,\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.toolCenter = [0, 0, 0];\n        this.initializeViewport = ({ renderingEngineId, viewportId, }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const { FrameOfReferenceUID, viewport } = enabledElement;\n            const { element } = viewport;\n            const { position, focalPoint, viewPlaneNormal } = viewport.getCamera();\n            let annotations = this._getAnnotations(enabledElement);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (annotations?.length) {\n                removeAnnotation(annotations[0].annotationUID);\n            }\n            const annotation = {\n                highlighted: false,\n                metadata: {\n                    cameraPosition: [...position],\n                    cameraFocalPoint: [...focalPoint],\n                    FrameOfReferenceUID,\n                    toolName: this.getToolName(),\n                },\n                data: {\n                    handles: {\n                        rotationPoints: [],\n                        slabThicknessPoints: [],\n                        toolCenter: this.toolCenter,\n                    },\n                    activeOperation: null,\n                    activeViewportIds: [],\n                    viewportId,\n                },\n            };\n            addAnnotation(annotation, element);\n            return {\n                normal: viewPlaneNormal,\n                point: viewport.canvasToWorld([\n                    viewport.canvas.clientWidth / 2,\n                    viewport.canvas.clientHeight / 2,\n                ]),\n            };\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.resetCrosshairs = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            for (const viewportInfo of viewportsInfo) {\n                const { viewportId, renderingEngineId } = viewportInfo;\n                const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n                const viewport = enabledElement.viewport;\n                const resetPan = true;\n                const resetZoom = true;\n                const resetToCenter = true;\n                const resetRotation = true;\n                const suppressEvents = true;\n                viewport.resetCamera({\n                    resetPan,\n                    resetZoom,\n                    resetToCenter,\n                    resetRotation,\n                    suppressEvents,\n                });\n                viewport.resetSlabThickness();\n                const { element } = viewport;\n                let annotations = this._getAnnotations(enabledElement);\n                annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n                if (annotations.length) {\n                    removeAnnotation(annotations[0].annotationUID);\n                }\n                viewport.render();\n            }\n            this._computeToolCenter(viewportsInfo);\n        };\n        this.computeToolCenter = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            this._computeToolCenter(viewportsInfo);\n        };\n        this._computeToolCenter = (viewportsInfo) => {\n            if (!viewportsInfo.length || viewportsInfo.length === 1) {\n                console.warn('For crosshairs to operate, at least two viewports must be given.');\n                return;\n            }\n            const [firstViewport, secondViewport, thirdViewport] = viewportsInfo;\n            const { normal: normal1, point: point1 } = this.initializeViewport(firstViewport);\n            const { normal: normal2, point: point2 } = this.initializeViewport(secondViewport);\n            let normal3 = [0, 0, 0];\n            let point3 = vec3.create();\n            if (thirdViewport) {\n                ({ normal: normal3, point: point3 } =\n                    this.initializeViewport(thirdViewport));\n            }\n            else {\n                vec3.add(point3, point1, point2);\n                vec3.scale(point3, point3, 0.5);\n                vec3.cross(normal3, normal1, normal2);\n            }\n            const firstPlane = csUtils.planar.planeEquation(normal1, point1);\n            const secondPlane = csUtils.planar.planeEquation(normal2, point2);\n            const thirdPlane = csUtils.planar.planeEquation(normal3, point3);\n            const toolCenter = csUtils.planar.threePlaneIntersection(firstPlane, secondPlane, thirdPlane);\n            this.setToolCenter(toolCenter);\n        };\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const jumpWorld = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this._jump(enabledElement, jumpWorld);\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredAnnotations = this.filterInteractableAnnotationsForElement(viewport.element, annotations);\n            const { data } = filteredAnnotations[0];\n            const { rotationPoints } = data.handles;\n            const viewportIdArray = [];\n            for (let i = 0; i < rotationPoints.length - 1; ++i) {\n                const otherViewport = rotationPoints[i][1];\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                if (!viewportControllable || !viewportDraggableRotatable) {\n                    continue;\n                }\n                viewportIdArray.push(otherViewport.id);\n                i++;\n            }\n            data.activeViewportIds = [...viewportIdArray];\n            data.handles.activeOperation = OPERATION.DRAG;\n            evt.preventDefault();\n            hideElementCursor(element);\n            this._activateModify(element);\n            return filteredAnnotations[0];\n        };\n        this.cancel = () => {\n            console.log('Not implemented yet');\n        };\n        this.handleSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            if (this._pointNearTool(element, annotation, canvasCoords, 6)) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.onCameraModified = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const viewport = enabledElement.viewport;\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation) {\n                return;\n            }\n            const currentCamera = viewport.getCamera();\n            const oldCameraPosition = viewportAnnotation.metadata.cameraPosition;\n            const deltaCameraPosition = [0, 0, 0];\n            vtkMath.subtract(currentCamera.position, oldCameraPosition, deltaCameraPosition);\n            const oldCameraFocalPoint = viewportAnnotation.metadata.cameraFocalPoint;\n            const deltaCameraFocalPoint = [0, 0, 0];\n            vtkMath.subtract(currentCamera.focalPoint, oldCameraFocalPoint, deltaCameraFocalPoint);\n            viewportAnnotation.metadata.cameraPosition = [...currentCamera.position];\n            viewportAnnotation.metadata.cameraFocalPoint = [\n                ...currentCamera.focalPoint,\n            ];\n            const viewportControllable = this._getReferenceLineControllable(viewport.id);\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(viewport.id);\n            if (!csUtils.isEqual(currentCamera.position, oldCameraPosition, 1e-3) &&\n                viewportControllable &&\n                viewportDraggableRotatable) {\n                let isRotation = false;\n                const cameraModifiedSameForPosAndFocalPoint = csUtils.isEqual(deltaCameraPosition, deltaCameraFocalPoint, 1e-3);\n                if (!cameraModifiedSameForPosAndFocalPoint) {\n                    isRotation = true;\n                }\n                const cameraModifiedInPlane = Math.abs(vtkMath.dot(deltaCameraPosition, currentCamera.viewPlaneNormal)) < 1e-2;\n                if (!isRotation && !cameraModifiedInPlane) {\n                    this.toolCenter[0] += deltaCameraPosition[0];\n                    this.toolCenter[1] += deltaCameraPosition[1];\n                    this.toolCenter[2] += deltaCameraPosition[2];\n                    triggerEvent(eventTarget, Events.CROSSHAIR_TOOL_CENTER_CHANGED, {\n                        toolGroupId: this.toolGroupId,\n                        toolCenter: this.toolCenter,\n                    });\n                }\n            }\n            if (this.configuration.autoPan?.enabled) {\n                const toolGroup = getToolGroupForViewport(viewport.id, renderingEngine.id);\n                const otherViewportIds = toolGroup\n                    .getViewportIds()\n                    .filter((id) => id !== viewport.id);\n                otherViewportIds.forEach((viewportId) => {\n                    this._autoPanViewportIfNecessary(viewportId, renderingEngine);\n                });\n            }\n            const requireSameOrientation = false;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.onResetCamera = (evt) => {\n            this.resetCrosshairs();\n        };\n        this.mouseMoveCallback = (evt, filteredToolAnnotations) => {\n            const { element, currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            let imageNeedsUpdate = false;\n            for (let i = 0; i < filteredToolAnnotations.length; i++) {\n                const annotation = filteredToolAnnotations[i];\n                if (isAnnotationLocked(annotation.annotationUID)) {\n                    continue;\n                }\n                const { data, highlighted } = annotation;\n                if (!data.handles) {\n                    continue;\n                }\n                const previousActiveOperation = data.handles.activeOperation;\n                const previousActiveViewportIds = data.activeViewportIds && data.activeViewportIds.length > 0\n                    ? [...data.activeViewportIds]\n                    : [];\n                data.activeViewportIds = [];\n                data.handles.activeOperation = null;\n                const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, 6);\n                let near = false;\n                if (handleNearImagePoint) {\n                    near = true;\n                }\n                else {\n                    near = this._pointNearTool(element, annotation, canvasCoords, 6);\n                }\n                const nearToolAndNotMarkedActive = near && !highlighted;\n                const notNearToolAndMarkedActive = !near && highlighted;\n                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n                    annotation.highlighted = !highlighted;\n                    imageNeedsUpdate = true;\n                }\n                else if (data.handles.activeOperation !== previousActiveOperation ||\n                    !this._areViewportIdArraysEqual(data.activeViewportIds, previousActiveViewportIds)) {\n                    imageNeedsUpdate = true;\n                }\n            }\n            return imageNeedsUpdate;\n        };\n        this.filterInteractableAnnotationsForElement = (element, annotations) => {\n            if (!annotations || !annotations.length) {\n                return [];\n            }\n            const enabledElement = getEnabledElement(element);\n            const { viewportId } = enabledElement;\n            const viewportUIDSpecificCrosshairs = annotations.filter((annotation) => annotation.data.viewportId === viewportId);\n            return viewportUIDSpecificCrosshairs;\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport, renderingEngine } = enabledElement;\n            const { element } = viewport;\n            const annotations = this._getAnnotations(enabledElement);\n            const camera = viewport.getCamera();\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!annotations?.length || !viewportAnnotation?.data) {\n                return renderStatus;\n            }\n            const annotationUID = viewportAnnotation.annotationUID;\n            const { clientWidth, clientHeight } = viewport.canvas;\n            const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n            const canvasMinDimensionLength = Math.min(clientWidth, clientHeight);\n            const data = viewportAnnotation.data;\n            const crosshairCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n            const otherViewportAnnotations = this._filterAnnotationsByUniqueViewportOrientations(enabledElement, annotations);\n            const referenceLines = [];\n            const canvasBox = [0, 0, clientWidth, clientHeight];\n            otherViewportAnnotations.forEach((annotation) => {\n                const { data } = annotation;\n                data.handles.toolCenter = this.toolCenter;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n                const { clientWidth, clientHeight } = otherViewport.canvas;\n                const otherCanvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n                const otherCanvasCenter = [\n                    clientWidth * 0.5,\n                    clientHeight * 0.5,\n                ];\n                const otherViewportCenterWorld = otherViewport.canvasToWorld(otherCanvasCenter);\n                const direction = [0, 0, 0];\n                vtkMath.cross(camera.viewPlaneNormal, otherCamera.viewPlaneNormal, direction);\n                vtkMath.normalize(direction);\n                vtkMath.multiplyScalar(direction, otherCanvasDiagonalLength);\n                const pointWorld0 = [0, 0, 0];\n                vtkMath.add(otherViewportCenterWorld, direction, pointWorld0);\n                const pointWorld1 = [0, 0, 0];\n                vtkMath.subtract(otherViewportCenterWorld, direction, pointWorld1);\n                const pointCanvas0 = viewport.worldToCanvas(pointWorld0);\n                const otherViewportCenterCanvas = viewport.worldToCanvas(otherViewportCenterWorld);\n                const canvasUnitVectorFromCenter = vec2.create();\n                vec2.subtract(canvasUnitVectorFromCenter, pointCanvas0, otherViewportCenterCanvas);\n                vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n                const canvasVectorFromCenterLong = vec2.create();\n                vec2.scale(canvasVectorFromCenterLong, canvasUnitVectorFromCenter, canvasDiagonalLength * 100);\n                const canvasVectorFromCenterMid = vec2.create();\n                vec2.scale(canvasVectorFromCenterMid, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.4);\n                const canvasVectorFromCenterShort = vec2.create();\n                vec2.scale(canvasVectorFromCenterShort, canvasUnitVectorFromCenter, canvasMinDimensionLength * 0.2);\n                const canvasVectorFromCenterStart = vec2.create();\n                const mobileConfig = this.configuration.mobile;\n                const { referenceLinesCenterGapRatio } = mobileConfig?.enabled\n                    ? mobileConfig\n                    : this.configuration;\n                const centerGap = referenceLinesCenterGapRatio > 0\n                    ? canvasMinDimensionLength * referenceLinesCenterGapRatio\n                    : this.configuration.referenceLinesCenterGapRadius;\n                vec2.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, otherViewportAnnotations.length === 2 ? centerGap : 0);\n                const refLinePointOne = vec2.create();\n                const refLinePointTwo = vec2.create();\n                const refLinePointThree = vec2.create();\n                const refLinePointFour = vec2.create();\n                let refLinesCenter = vec2.clone(crosshairCenterCanvas);\n                if (!otherViewportDraggableRotatable || !otherViewportControllable) {\n                    refLinesCenter = vec2.clone(otherViewportCenterCanvas);\n                }\n                vec2.add(refLinePointOne, refLinesCenter, canvasVectorFromCenterStart);\n                vec2.add(refLinePointTwo, refLinesCenter, canvasVectorFromCenterLong);\n                vec2.subtract(refLinePointThree, refLinesCenter, canvasVectorFromCenterStart);\n                vec2.subtract(refLinePointFour, refLinesCenter, canvasVectorFromCenterLong);\n                liangBarksyClip(refLinePointOne, refLinePointTwo, canvasBox);\n                liangBarksyClip(refLinePointThree, refLinePointFour, canvasBox);\n                const rotHandleOne = vec2.create();\n                vec2.subtract(rotHandleOne, crosshairCenterCanvas, canvasVectorFromCenterMid);\n                const rotHandleTwo = vec2.create();\n                vec2.add(rotHandleTwo, crosshairCenterCanvas, canvasVectorFromCenterMid);\n                let stHandlesCenterCanvas = vec2.clone(crosshairCenterCanvas);\n                if (!otherViewportDraggableRotatable &&\n                    otherViewportSlabThicknessControlsOn) {\n                    stHandlesCenterCanvas = vec2.clone(otherViewportCenterCanvas);\n                }\n                let stHandlesCenterWorld = [...this.toolCenter];\n                if (!otherViewportDraggableRotatable &&\n                    otherViewportSlabThicknessControlsOn) {\n                    stHandlesCenterWorld = [...otherViewportCenterWorld];\n                }\n                const worldUnitVectorFromCenter = [0, 0, 0];\n                vtkMath.subtract(pointWorld0, pointWorld1, worldUnitVectorFromCenter);\n                vtkMath.normalize(worldUnitVectorFromCenter);\n                const { viewPlaneNormal } = camera;\n                const { matrix } = vtkMatrixBuilder\n                    .buildFromDegree()\n                    .rotate(90, viewPlaneNormal);\n                const worldUnitOrthoVectorFromCenter = [0, 0, 0];\n                vec3.transformMat4(worldUnitOrthoVectorFromCenter, worldUnitVectorFromCenter, matrix);\n                const slabThicknessValue = otherViewport.getSlabThickness();\n                const worldOrthoVectorFromCenter = [\n                    ...worldUnitOrthoVectorFromCenter,\n                ];\n                vtkMath.multiplyScalar(worldOrthoVectorFromCenter, slabThicknessValue);\n                const worldVerticalRefPoint = [0, 0, 0];\n                vtkMath.add(stHandlesCenterWorld, worldOrthoVectorFromCenter, worldVerticalRefPoint);\n                const canvasVerticalRefPoint = viewport.worldToCanvas(worldVerticalRefPoint);\n                const canvasOrthoVectorFromCenter = vec2.create();\n                vec2.subtract(canvasOrthoVectorFromCenter, stHandlesCenterCanvas, canvasVerticalRefPoint);\n                const stLinePointOne = vec2.create();\n                vec2.subtract(stLinePointOne, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.add(stLinePointOne, stLinePointOne, canvasOrthoVectorFromCenter);\n                const stLinePointTwo = vec2.create();\n                vec2.add(stLinePointTwo, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.add(stLinePointTwo, stLinePointTwo, canvasOrthoVectorFromCenter);\n                liangBarksyClip(stLinePointOne, stLinePointTwo, canvasBox);\n                const stLinePointThree = vec2.create();\n                vec2.add(stLinePointThree, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.subtract(stLinePointThree, stLinePointThree, canvasOrthoVectorFromCenter);\n                const stLinePointFour = vec2.create();\n                vec2.subtract(stLinePointFour, stHandlesCenterCanvas, canvasVectorFromCenterLong);\n                vec2.subtract(stLinePointFour, stLinePointFour, canvasOrthoVectorFromCenter);\n                liangBarksyClip(stLinePointThree, stLinePointFour, canvasBox);\n                const stHandleOne = vec2.create();\n                const stHandleTwo = vec2.create();\n                const stHandleThree = vec2.create();\n                const stHandleFour = vec2.create();\n                vec2.subtract(stHandleOne, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.add(stHandleOne, stHandleOne, canvasOrthoVectorFromCenter);\n                vec2.add(stHandleTwo, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.add(stHandleTwo, stHandleTwo, canvasOrthoVectorFromCenter);\n                vec2.subtract(stHandleThree, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.subtract(stHandleThree, stHandleThree, canvasOrthoVectorFromCenter);\n                vec2.add(stHandleFour, stHandlesCenterCanvas, canvasVectorFromCenterShort);\n                vec2.subtract(stHandleFour, stHandleFour, canvasOrthoVectorFromCenter);\n                referenceLines.push([\n                    otherViewport,\n                    refLinePointOne,\n                    refLinePointTwo,\n                    refLinePointThree,\n                    refLinePointFour,\n                    stLinePointOne,\n                    stLinePointTwo,\n                    stLinePointThree,\n                    stLinePointFour,\n                    rotHandleOne,\n                    rotHandleTwo,\n                    stHandleOne,\n                    stHandleTwo,\n                    stHandleThree,\n                    stHandleFour,\n                ]);\n            });\n            const newRtpoints = [];\n            const newStpoints = [];\n            const viewportColor = this._getReferenceLineColor(viewport.id);\n            const color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n            referenceLines.forEach((line, lineIndex) => {\n                const otherViewport = line[0];\n                const viewportColor = this._getReferenceLineColor(otherViewport.id);\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id) ||\n                    this.configuration.mobile?.enabled;\n                const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id) ||\n                    this.configuration.mobile?.enabled;\n                const selectedViewportId = data.activeViewportIds.find((id) => id === otherViewport.id);\n                let color = viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n                let lineWidth = 1;\n                const lineActive = data.handles.activeOperation !== null &&\n                    data.handles.activeOperation === OPERATION.DRAG &&\n                    selectedViewportId;\n                if (lineActive) {\n                    lineWidth = 2.5;\n                }\n                let lineUID = `${lineIndex}`;\n                if (viewportControllable && viewportDraggableRotatable) {\n                    lineUID = `${lineIndex}One`;\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[1], line[2], {\n                        color,\n                        lineWidth,\n                    });\n                    lineUID = `${lineIndex}Two`;\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[3], line[4], {\n                        color,\n                        lineWidth,\n                    });\n                }\n                else {\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[2], line[4], {\n                        color,\n                        lineWidth,\n                    });\n                }\n                if (viewportControllable) {\n                    color =\n                        viewportColor !== undefined ? viewportColor : 'rgb(200, 200, 200)';\n                    const rotHandlesActive = data.handles.activeOperation === OPERATION.ROTATE;\n                    const rotationHandles = [line[9], line[10]];\n                    const rotHandleWorldOne = [\n                        viewport.canvasToWorld(line[9]),\n                        otherViewport,\n                        line[1],\n                        line[2],\n                    ];\n                    const rotHandleWorldTwo = [\n                        viewport.canvasToWorld(line[10]),\n                        otherViewport,\n                        line[3],\n                        line[4],\n                    ];\n                    newRtpoints.push(rotHandleWorldOne, rotHandleWorldTwo);\n                    const slabThicknessHandlesActive = data.handles.activeOperation === OPERATION.SLAB;\n                    const slabThicknessHandles = [line[11], line[12], line[13], line[14]];\n                    const slabThicknessHandleWorldOne = [\n                        viewport.canvasToWorld(line[11]),\n                        otherViewport,\n                        line[5],\n                        line[6],\n                    ];\n                    const slabThicknessHandleWorldTwo = [\n                        viewport.canvasToWorld(line[12]),\n                        otherViewport,\n                        line[5],\n                        line[6],\n                    ];\n                    const slabThicknessHandleWorldThree = [\n                        viewport.canvasToWorld(line[13]),\n                        otherViewport,\n                        line[7],\n                        line[8],\n                    ];\n                    const slabThicknessHandleWorldFour = [\n                        viewport.canvasToWorld(line[14]),\n                        otherViewport,\n                        line[7],\n                        line[8],\n                    ];\n                    newStpoints.push(slabThicknessHandleWorldOne, slabThicknessHandleWorldTwo, slabThicknessHandleWorldThree, slabThicknessHandleWorldFour);\n                    let handleRadius = this.configuration.handleRadius *\n                        (this.configuration.enableHDPIHandles ? window.devicePixelRatio : 1);\n                    let opacity = 1;\n                    if (this.configuration.mobile?.enabled) {\n                        handleRadius = this.configuration.mobile.handleRadius;\n                        opacity = this.configuration.mobile.opacity;\n                    }\n                    if ((lineActive || this.configuration.mobile?.enabled) &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportDraggableRotatable &&\n                        viewportSlabThicknessControlsOn) {\n                        let handleUID = `${lineIndex}One`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'circle',\n                        });\n                        handleUID = `${lineIndex}Two`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'rect',\n                        });\n                    }\n                    else if (lineActive &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportDraggableRotatable) {\n                        const handleUID = `${lineIndex}`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'circle',\n                        });\n                    }\n                    else if (selectedViewportId &&\n                        !rotHandlesActive &&\n                        !slabThicknessHandlesActive &&\n                        viewportSlabThicknessControlsOn) {\n                        const handleUID = `${lineIndex}`;\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, slabThicknessHandles, {\n                            color,\n                            handleRadius,\n                            opacity,\n                            type: 'rect',\n                        });\n                    }\n                    else if (rotHandlesActive && viewportDraggableRotatable) {\n                        const handleUID = `${lineIndex}`;\n                        const handleRadius = this.configuration.handleRadius *\n                            (this.configuration.enableHDPIHandles\n                                ? window.devicePixelRatio\n                                : 1);\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, handleUID, rotationHandles, {\n                            color,\n                            handleRadius,\n                            fill: color,\n                            type: 'circle',\n                        });\n                    }\n                    else if (slabThicknessHandlesActive &&\n                        selectedViewportId &&\n                        viewportSlabThicknessControlsOn) {\n                        const handleRadius = this.configuration.handleRadius *\n                            (this.configuration.enableHDPIHandles\n                                ? window.devicePixelRatio\n                                : 1);\n                        drawHandlesSvg(svgDrawingHelper, annotationUID, lineUID, slabThicknessHandles, {\n                            color,\n                            handleRadius,\n                            fill: color,\n                            type: 'rect',\n                        });\n                    }\n                    const slabThicknessValue = otherViewport.getSlabThickness();\n                    if (slabThicknessValue > 0.5 && viewportSlabThicknessControlsOn) {\n                        lineUID = `${lineIndex}STOne`;\n                        drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[5], line[6], {\n                            color,\n                            width: 1,\n                            lineDash: [2, 3],\n                        });\n                        lineUID = `${lineIndex}STTwo`;\n                        drawLineSvg(svgDrawingHelper, annotationUID, lineUID, line[7], line[8], {\n                            color,\n                            width: line,\n                            lineDash: [2, 3],\n                        });\n                    }\n                }\n            });\n            renderStatus = true;\n            data.handles.rotationPoints = newRtpoints;\n            data.handles.slabThicknessPoints = newStpoints;\n            if (this.configuration.viewportIndicators) {\n                const { viewportIndicatorsConfig } = this.configuration;\n                const xOffset = viewportIndicatorsConfig?.xOffset || 0.95;\n                const yOffset = viewportIndicatorsConfig?.yOffset || 0.05;\n                const referenceColorCoordinates = [\n                    clientWidth * xOffset,\n                    clientHeight * yOffset,\n                ];\n                const circleRadius = viewportIndicatorsConfig?.circleRadius || canvasDiagonalLength * 0.01;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, referenceColorCoordinates, circleRadius, { color, fill: color });\n            }\n            if (this.configuration.centerPoint?.enabled) {\n                const defaultColor = 'rgba(255, 255, 0, 0.5)';\n                const defaultSize = 2;\n                const maxAllowedSize = 5;\n                const centerPointColor = this.configuration.centerPoint.color || defaultColor;\n                const centerPointSize = Math.min(this.configuration.centerPoint.size || defaultSize, maxAllowedSize);\n                drawCircleSvg(svgDrawingHelper, annotationUID, 'centerPoint', crosshairCenterCanvas, centerPointSize, {\n                    color: centerPointColor,\n                    fill: centerPointColor,\n                });\n            }\n            return renderStatus;\n        };\n        this._getAnnotations = (enabledElement) => {\n            const { viewport } = enabledElement;\n            const annotations = getAnnotations(this.getToolName(), viewport.element) || [];\n            const viewportIds = this._getViewportsInfo().map(({ viewportId }) => viewportId);\n            const toolGroupAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                return viewportIds.includes(data.viewportId);\n            });\n            return toolGroupAnnotations;\n        };\n        this._onNewVolume = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            this._computeToolCenter(viewportsInfo);\n        };\n        this._areViewportIdArraysEqual = (viewportIdArrayOne, viewportIdArrayTwo) => {\n            if (viewportIdArrayOne.length !== viewportIdArrayTwo.length) {\n                return false;\n            }\n            viewportIdArrayOne.forEach((id) => {\n                let itemFound = false;\n                for (let i = 0; i < viewportIdArrayTwo.length; ++i) {\n                    if (id === viewportIdArrayTwo[i]) {\n                        itemFound = true;\n                        break;\n                    }\n                }\n                if (itemFound === false) {\n                    return false;\n                }\n            });\n            return true;\n        };\n        this._getAnnotationsForViewportsWithDifferentCameras = (enabledElement, annotations) => {\n            const { viewportId, renderingEngine, viewport } = enabledElement;\n            const otherViewportAnnotations = annotations.filter((annotation) => annotation.data.viewportId !== viewportId);\n            if (!otherViewportAnnotations || !otherViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, position } = camera;\n            const viewportsWithDifferentCameras = otherViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const targetViewport = renderingEngine.getViewport(viewportId);\n                const cameraOfTarget = targetViewport.getCamera();\n                return !(csUtils.isEqual(cameraOfTarget.viewPlaneNormal, viewPlaneNormal, 1e-2) && csUtils.isEqual(cameraOfTarget.position, position, 1));\n            });\n            return viewportsWithDifferentCameras;\n        };\n        this._filterViewportWithSameOrientation = (enabledElement, referenceAnnotation, annotations) => {\n            const { renderingEngine } = enabledElement;\n            const { data } = referenceAnnotation;\n            const viewport = renderingEngine.getViewport(data.viewportId);\n            const linkedViewportAnnotations = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return otherViewportControllable === true;\n            });\n            if (!linkedViewportAnnotations || !linkedViewportAnnotations.length) {\n                return [];\n            }\n            const camera = viewport.getCamera();\n            const viewPlaneNormal = camera.viewPlaneNormal;\n            vtkMath.normalize(viewPlaneNormal);\n            const otherViewportsAnnotationsWithSameCameraDirection = linkedViewportAnnotations.filter((annotation) => {\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                return (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) &&\n                    csUtils.isEqual(camera.viewUp, otherCamera.viewUp, 1e-2));\n            });\n            return otherViewportsAnnotationsWithSameCameraDirection;\n        };\n        this._filterAnnotationsByUniqueViewportOrientations = (enabledElement, annotations) => {\n            const { renderingEngine, viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const viewPlaneNormal = camera.viewPlaneNormal;\n            vtkMath.normalize(viewPlaneNormal);\n            const otherLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return (viewport !== otherViewport &&\n                    otherViewportControllable === true);\n            });\n            const otherViewportsAnnotationsWithUniqueCameras = [];\n            for (let i = 0; i < otherLinkedViewportAnnotationsFromSameScene.length; ++i) {\n                const annotation = otherLinkedViewportAnnotationsFromSameScene[i];\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            const otherNonLinkedViewportAnnotationsFromSameScene = annotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                return (viewport !== otherViewport &&\n                    otherViewportControllable !== true);\n            });\n            for (let i = 0; i < otherNonLinkedViewportAnnotationsFromSameScene.length; ++i) {\n                const annotation = otherNonLinkedViewportAnnotationsFromSameScene[i];\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n            for (let i = 0; i < otherViewportAnnotations.length; ++i) {\n                const annotation = otherViewportAnnotations[i];\n                if (otherViewportsAnnotationsWithUniqueCameras.some((element) => element === annotation)) {\n                    continue;\n                }\n                const { viewportId } = annotation.data;\n                const otherViewport = renderingEngine.getViewport(viewportId);\n                const otherCamera = otherViewport.getCamera();\n                const otherViewPlaneNormal = otherCamera.viewPlaneNormal;\n                vtkMath.normalize(otherViewPlaneNormal);\n                if (csUtils.isEqual(viewPlaneNormal, otherViewPlaneNormal, 1e-2) ||\n                    csUtils.isOpposite(viewPlaneNormal, otherViewPlaneNormal, 1e-2)) {\n                    continue;\n                }\n                let cameraFound = false;\n                for (let jj = 0; jj < otherViewportsAnnotationsWithUniqueCameras.length; ++jj) {\n                    const annotation = otherViewportsAnnotationsWithUniqueCameras[jj];\n                    const { viewportId } = annotation.data;\n                    const stockedViewport = renderingEngine.getViewport(viewportId);\n                    const cameraOfStocked = stockedViewport.getCamera();\n                    if (csUtils.isEqual(cameraOfStocked.viewPlaneNormal, otherCamera.viewPlaneNormal, 1e-2) &&\n                        csUtils.isEqual(cameraOfStocked.position, otherCamera.position, 1)) {\n                        cameraFound = true;\n                    }\n                }\n                if (!cameraFound) {\n                    otherViewportsAnnotationsWithUniqueCameras.push(annotation);\n                }\n            }\n            return otherViewportsAnnotationsWithUniqueCameras;\n        };\n        this._checkIfViewportsRenderingSameScene = (viewport, otherViewport) => {\n            const volumeIds = viewport.getAllVolumeIds();\n            const otherVolumeIds = otherViewport.getAllVolumeIds();\n            return (volumeIds.length === otherVolumeIds.length &&\n                volumeIds.every((id) => otherVolumeIds.includes(id)));\n        };\n        this._jump = (enabledElement, jumpWorld) => {\n            state.isInteractingWithTool = true;\n            const { viewport, renderingEngine } = enabledElement;\n            const annotations = this._getAnnotations(enabledElement);\n            const delta = [0, 0, 0];\n            vtkMath.subtract(jumpWorld, this.toolCenter, delta);\n            const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n            const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                const { data } = annotation;\n                const otherViewport = renderingEngine.getViewport(data.viewportId);\n                const sameScene = this._checkIfViewportsRenderingSameScene(viewport, otherViewport);\n                return (this._getReferenceLineControllable(otherViewport.id) &&\n                    this._getReferenceLineDraggableRotatable(otherViewport.id) &&\n                    sameScene);\n            });\n            if (viewportsAnnotationsToUpdate.length === 0) {\n                state.isInteractingWithTool = false;\n                return false;\n            }\n            this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);\n            state.isInteractingWithTool = false;\n            return true;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = !this.configuration.mobile?.enabled;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            this.editData.annotation.data.handles.activeOperation = null;\n            this.editData.annotation.data.activeViewportIds = [];\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            const requireSameOrientation = false;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), requireSameOrientation);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const delta = eventDetail.deltaPoints.world;\n            if (Math.abs(delta[0]) < 1e-3 &&\n                Math.abs(delta[1]) < 1e-3 &&\n                Math.abs(delta[2]) < 1e-3) {\n                return;\n            }\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const annotations = this._getAnnotations(enabledElement);\n            const filteredToolAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const viewportAnnotation = filteredToolAnnotations[0];\n            if (!viewportAnnotation) {\n                return;\n            }\n            const { handles } = viewportAnnotation.data;\n            const { currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            if (handles.activeOperation === OPERATION.DRAG) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportDraggableRotatable === true &&\n                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));\n                });\n                this._applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta);\n            }\n            else if (handles.activeOperation === OPERATION.ROTATE) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const viewportsAnnotationsToUpdate = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportDraggableRotatable === true);\n                });\n                const dir1 = vec2.create();\n                const dir2 = vec2.create();\n                const center = [\n                    this.toolCenter[0],\n                    this.toolCenter[1],\n                    this.toolCenter[2],\n                ];\n                const centerCanvas = viewport.worldToCanvas(center);\n                const finalPointCanvas = eventDetail.currentPoints.canvas;\n                const originalPointCanvas = vec2.create();\n                vec2.sub(originalPointCanvas, finalPointCanvas, eventDetail.deltaPoints.canvas);\n                vec2.sub(dir1, originalPointCanvas, centerCanvas);\n                vec2.sub(dir2, finalPointCanvas, centerCanvas);\n                let angle = vec2.angle(dir1, dir2);\n                if (this._isClockWise(centerCanvas, originalPointCanvas, finalPointCanvas)) {\n                    angle *= -1;\n                }\n                angle = Math.round(angle * 100) / 100;\n                const rotationAxis = viewport.getCamera().viewPlaneNormal;\n                const { matrix } = vtkMatrixBuilder\n                    .buildFromRadian()\n                    .translate(center[0], center[1], center[2])\n                    .rotate(angle, rotationAxis)\n                    .translate(-center[0], -center[1], -center[2]);\n                const otherViewportsIds = [];\n                viewportsAnnotationsToUpdate.forEach((annotation) => {\n                    const { data } = annotation;\n                    data.handles.toolCenter = center;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const camera = otherViewport.getCamera();\n                    const { viewUp, position, focalPoint } = camera;\n                    viewUp[0] += position[0];\n                    viewUp[1] += position[1];\n                    viewUp[2] += position[2];\n                    vec3.transformMat4(focalPoint, focalPoint, matrix);\n                    vec3.transformMat4(position, position, matrix);\n                    vec3.transformMat4(viewUp, viewUp, matrix);\n                    viewUp[0] -= position[0];\n                    viewUp[1] -= position[1];\n                    viewUp[2] -= position[2];\n                    otherViewport.setCamera({\n                        position,\n                        viewUp,\n                        focalPoint,\n                    });\n                    otherViewportsIds.push(otherViewport.id);\n                });\n                renderingEngine.renderViewports(otherViewportsIds);\n            }\n            else if (handles.activeOperation === OPERATION.SLAB) {\n                const otherViewportAnnotations = this._getAnnotationsForViewportsWithDifferentCameras(enabledElement, annotations);\n                const referenceAnnotations = otherViewportAnnotations.filter((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const otherViewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                    const otherViewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n                    return (otherViewportControllable === true &&\n                        otherViewportSlabThicknessControlsOn === true &&\n                        viewportAnnotation.data.activeViewportIds.find((id) => id === otherViewport.id));\n                });\n                if (referenceAnnotations.length === 0) {\n                    return;\n                }\n                const viewportsAnnotationsToUpdate = this._filterViewportWithSameOrientation(enabledElement, referenceAnnotations[0], annotations);\n                const viewportsIds = [];\n                viewportsIds.push(viewport.id);\n                viewportsAnnotationsToUpdate.forEach((annotation) => {\n                    const { data } = annotation;\n                    const otherViewport = renderingEngine.getViewport(data.viewportId);\n                    const camera = otherViewport.getCamera();\n                    const normal = camera.viewPlaneNormal;\n                    const dotProd = vtkMath.dot(delta, normal);\n                    const projectedDelta = [...normal];\n                    vtkMath.multiplyScalar(projectedDelta, dotProd);\n                    if (Math.abs(projectedDelta[0]) > 1e-3 ||\n                        Math.abs(projectedDelta[1]) > 1e-3 ||\n                        Math.abs(projectedDelta[2]) > 1e-3) {\n                        const mod = Math.sqrt(projectedDelta[0] * projectedDelta[0] +\n                            projectedDelta[1] * projectedDelta[1] +\n                            projectedDelta[2] * projectedDelta[2]);\n                        const currentPoint = eventDetail.lastPoints.world;\n                        const direction = [0, 0, 0];\n                        const currentCenter = [\n                            this.toolCenter[0],\n                            this.toolCenter[1],\n                            this.toolCenter[2],\n                        ];\n                        const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n                        if (!viewportDraggableRotatable) {\n                            const { rotationPoints } = (this.editData.annotation.data).handles;\n                            const otherViewportRotationPoints = rotationPoints.filter((point) => point[1].uid === otherViewport.id);\n                            if (otherViewportRotationPoints.length === 2) {\n                                const point1 = viewport.canvasToWorld(otherViewportRotationPoints[0][3]);\n                                const point2 = viewport.canvasToWorld(otherViewportRotationPoints[1][3]);\n                                vtkMath.add(point1, point2, currentCenter);\n                                vtkMath.multiplyScalar(currentCenter, 0.5);\n                            }\n                        }\n                        vtkMath.subtract(currentPoint, currentCenter, direction);\n                        const dotProdDirection = vtkMath.dot(direction, normal);\n                        const projectedDirection = [...normal];\n                        vtkMath.multiplyScalar(projectedDirection, dotProdDirection);\n                        const normalizedProjectedDirection = [\n                            projectedDirection[0],\n                            projectedDirection[1],\n                            projectedDirection[2],\n                        ];\n                        vec3.normalize(normalizedProjectedDirection, normalizedProjectedDirection);\n                        const normalizedProjectedDelta = [\n                            projectedDelta[0],\n                            projectedDelta[1],\n                            projectedDelta[2],\n                        ];\n                        vec3.normalize(normalizedProjectedDelta, normalizedProjectedDelta);\n                        let slabThicknessValue = otherViewport.getSlabThickness();\n                        if (csUtils.isOpposite(normalizedProjectedDirection, normalizedProjectedDelta, 1e-3)) {\n                            slabThicknessValue -= mod;\n                        }\n                        else {\n                            slabThicknessValue += mod;\n                        }\n                        slabThicknessValue = Math.abs(slabThicknessValue);\n                        slabThicknessValue = Math.max(RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS, slabThicknessValue);\n                        const near = this._pointNearReferenceLine(viewportAnnotation, canvasCoords, 6, otherViewport);\n                        if (near) {\n                            slabThicknessValue = RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS;\n                        }\n                        const toolGroup = getToolGroupForViewport(otherViewport.id, renderingEngine.id);\n                        const crosshairsInstance = toolGroup.getToolInstance(this.getToolName());\n                        crosshairsInstance.setSlabThickness(otherViewport, slabThicknessValue);\n                        viewportsIds.push(otherViewport.id);\n                    }\n                });\n                renderingEngine.renderViewports(viewportsIds);\n            }\n        };\n        this._pointNearReferenceLine = (annotation, canvasCoords, proximity, lineViewport) => {\n            const { data } = annotation;\n            const { rotationPoints } = data.handles;\n            for (let i = 0; i < rotationPoints.length - 1; ++i) {\n                const otherViewport = rotationPoints[i][1];\n                if (otherViewport.id !== lineViewport.id) {\n                    continue;\n                }\n                const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n                if (!viewportControllable) {\n                    continue;\n                }\n                const lineSegment1 = {\n                    start: {\n                        x: rotationPoints[i][2][0],\n                        y: rotationPoints[i][2][1],\n                    },\n                    end: {\n                        x: rotationPoints[i][3][0],\n                        y: rotationPoints[i][3][1],\n                    },\n                };\n                const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n                const lineSegment2 = {\n                    start: {\n                        x: rotationPoints[i + 1][2][0],\n                        y: rotationPoints[i + 1][2][1],\n                    },\n                    end: {\n                        x: rotationPoints[i + 1][3][0],\n                        y: rotationPoints[i + 1][3][1],\n                    },\n                };\n                const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n                if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                    return true;\n                }\n                i++;\n            }\n            return false;\n        };\n        this._getReferenceLineColor =\n            toolProps.configuration?.getReferenceLineColor ||\n                defaultReferenceLineColor;\n        this._getReferenceLineControllable =\n            toolProps.configuration?.getReferenceLineControllable ||\n                defaultReferenceLineControllable;\n        this._getReferenceLineDraggableRotatable =\n            toolProps.configuration?.getReferenceLineDraggableRotatable ||\n                defaultReferenceLineDraggableRotatable;\n        this._getReferenceLineSlabThicknessControlsOn =\n            toolProps.configuration?.getReferenceLineSlabThicknessControlsOn ||\n                defaultReferenceLineSlabThicknessControlsOn;\n    }\n    onSetToolActive() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n        this._subscribeToViewportNewVolumeSet(viewportsInfo);\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolPassive() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolEnabled() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._computeToolCenter(viewportsInfo);\n    }\n    onSetToolDisabled() {\n        const viewportsInfo = this._getViewportsInfo();\n        this._unsubscribeToViewportNewVolumeSet(viewportsInfo);\n        viewportsInfo.forEach(({ renderingEngineId, viewportId }) => {\n            const enabledElement = getEnabledElementByIds(viewportId, renderingEngineId);\n            if (!enabledElement) {\n                return;\n            }\n            const annotations = this._getAnnotations(enabledElement);\n            if (annotations?.length) {\n                annotations.forEach((annotation) => {\n                    removeAnnotation(annotation.annotationUID);\n                });\n            }\n        });\n    }\n    setToolCenter(toolCenter, suppressEvents = false) {\n        const viewportsInfo = this._getViewportsInfo();\n        viewportsInfo.map(({ renderingEngineId, viewportId }) => {\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            const viewport = renderingEngine.getViewport(viewportId);\n            const camera = viewport.getCamera();\n            const { focalPoint, position, viewPlaneNormal } = camera;\n            const delta = [\n                toolCenter[0] - focalPoint[0],\n                toolCenter[1] - focalPoint[1],\n                toolCenter[2] - focalPoint[2],\n            ];\n            const scroll = delta[0] * viewPlaneNormal[0] +\n                delta[1] * viewPlaneNormal[1] +\n                delta[2] * viewPlaneNormal[2];\n            const scrollDelta = [\n                scroll * viewPlaneNormal[0],\n                scroll * viewPlaneNormal[1],\n                scroll * viewPlaneNormal[2],\n            ];\n            const newFocalPoint = [\n                focalPoint[0] + scrollDelta[0],\n                focalPoint[1] + scrollDelta[1],\n                focalPoint[2] + scrollDelta[2],\n            ];\n            const newPosition = [\n                position[0] + scrollDelta[0],\n                position[1] + scrollDelta[1],\n                position[2] + scrollDelta[2],\n            ];\n            viewport.setCamera({\n                focalPoint: newFocalPoint,\n                position: newPosition,\n            });\n            viewport.render();\n        });\n        this.toolCenter = toolCenter;\n        if (!suppressEvents) {\n            triggerEvent(eventTarget, Events.CROSSHAIR_TOOL_CENTER_CHANGED, {\n                toolGroupId: this.toolGroupId,\n                toolCenter: this.toolCenter,\n            });\n        }\n    }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let point = this._getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);\n        if (point !== null) {\n            return point;\n        }\n        point = this._getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity);\n        if (point !== null) {\n            return point;\n        }\n    }\n    _unsubscribeToViewportNewVolumeSet(viewportsInfo) {\n        viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _subscribeToViewportNewVolumeSet(viewports) {\n        viewports.forEach(({ viewportId, renderingEngineId }) => {\n            const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n            const { element } = viewport;\n            element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this._onNewVolume);\n        });\n    }\n    _autoPanViewportIfNecessary(viewportId, renderingEngine) {\n        const viewport = renderingEngine.getViewport(viewportId);\n        const { clientWidth, clientHeight } = viewport.canvas;\n        const toolCenterCanvas = viewport.worldToCanvas(this.toolCenter);\n        const pan = this.configuration.autoPan.panSize;\n        const visiblePointCanvas = [\n            toolCenterCanvas[0],\n            toolCenterCanvas[1],\n        ];\n        if (toolCenterCanvas[0] < 0) {\n            visiblePointCanvas[0] = pan;\n        }\n        else if (toolCenterCanvas[0] > clientWidth) {\n            visiblePointCanvas[0] = clientWidth - pan;\n        }\n        if (toolCenterCanvas[1] < 0) {\n            visiblePointCanvas[1] = pan;\n        }\n        else if (toolCenterCanvas[1] > clientHeight) {\n            visiblePointCanvas[1] = clientHeight - pan;\n        }\n        if (visiblePointCanvas[0] === toolCenterCanvas[0] &&\n            visiblePointCanvas[1] === toolCenterCanvas[1]) {\n            return;\n        }\n        const visiblePointWorld = viewport.canvasToWorld(visiblePointCanvas);\n        const deltaPointsWorld = [\n            visiblePointWorld[0] - this.toolCenter[0],\n            visiblePointWorld[1] - this.toolCenter[1],\n            visiblePointWorld[2] - this.toolCenter[2],\n        ];\n        const camera = viewport.getCamera();\n        const { focalPoint, position } = camera;\n        const updatedPosition = [\n            position[0] - deltaPointsWorld[0],\n            position[1] - deltaPointsWorld[1],\n            position[2] - deltaPointsWorld[2],\n        ];\n        const updatedFocalPoint = [\n            focalPoint[0] - deltaPointsWorld[0],\n            focalPoint[1] - deltaPointsWorld[1],\n            focalPoint[2] - deltaPointsWorld[2],\n        ];\n        viewport.setCamera({\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n        viewport.render();\n    }\n    setSlabThickness(viewport, slabThickness) {\n        let actorUIDs;\n        const { filterActorUIDsToSetSlabThickness } = this.configuration;\n        if (filterActorUIDsToSetSlabThickness &&\n            filterActorUIDsToSetSlabThickness.length > 0) {\n            actorUIDs = filterActorUIDsToSetSlabThickness;\n        }\n        let blendModeToUse = this.configuration.slabThicknessBlendMode;\n        if (slabThickness === RENDERING_DEFAULTS.MINIMUM_SLAB_THICKNESS) {\n            blendModeToUse = Enums.BlendModes.COMPOSITE;\n        }\n        const immediate = false;\n        viewport.setBlendMode(blendModeToUse, actorUIDs, immediate);\n        viewport.setSlabThickness(slabThickness, actorUIDs);\n    }\n    _isClockWise(a, b, c) {\n        return (b[0] - a[0]) * (c[1] - a[1]) - (b[1] - a[1]) * (c[0] - a[0]) > 0;\n    }\n    _applyDeltaShiftToSelectedViewportCameras(renderingEngine, viewportsAnnotationsToUpdate, delta) {\n        viewportsAnnotationsToUpdate.forEach((annotation) => {\n            this._applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta);\n        });\n    }\n    _applyDeltaShiftToViewportCamera(renderingEngine, annotation, delta) {\n        const { data } = annotation;\n        const viewport = renderingEngine.getViewport(data.viewportId);\n        const camera = viewport.getCamera();\n        const normal = camera.viewPlaneNormal;\n        const dotProd = vtkMath.dot(delta, normal);\n        const projectedDelta = [...normal];\n        vtkMath.multiplyScalar(projectedDelta, dotProd);\n        if (Math.abs(projectedDelta[0]) > 1e-3 ||\n            Math.abs(projectedDelta[1]) > 1e-3 ||\n            Math.abs(projectedDelta[2]) > 1e-3) {\n            const newFocalPoint = [0, 0, 0];\n            const newPosition = [0, 0, 0];\n            vtkMath.add(camera.focalPoint, projectedDelta, newFocalPoint);\n            vtkMath.add(camera.position, projectedDelta, newPosition);\n            viewport.setCamera({\n                focalPoint: newFocalPoint,\n                position: newPosition,\n            });\n            viewport.render();\n        }\n    }\n    _getRotationHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {\n        const { data } = annotation;\n        const { rotationPoints } = data.handles;\n        for (let i = 0; i < rotationPoints.length; i++) {\n            const point = rotationPoints[i][0];\n            const otherViewport = rotationPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            if (!viewportControllable) {\n                continue;\n            }\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportDraggableRotatable) {\n                continue;\n            }\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n                data.handles.activeOperation = OPERATION.ROTATE;\n                this.editData = {\n                    annotation,\n                };\n                return point;\n            }\n        }\n        return null;\n    }\n    _getSlabThicknessHandleNearImagePoint(viewport, annotation, canvasCoords, proximity) {\n        const { data } = annotation;\n        const { slabThicknessPoints } = data.handles;\n        for (let i = 0; i < slabThicknessPoints.length; i++) {\n            const point = slabThicknessPoints[i][0];\n            const otherViewport = slabThicknessPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            if (!viewportControllable) {\n                continue;\n            }\n            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n            if (!viewportSlabThicknessControlsOn) {\n                continue;\n            }\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            if (vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity) {\n                data.handles.activeOperation = OPERATION.SLAB;\n                data.activeViewportIds = [otherViewport.id];\n                this.editData = {\n                    annotation,\n                };\n                return point;\n            }\n        }\n        return null;\n    }\n    _pointNearTool(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { clientWidth, clientHeight } = viewport.canvas;\n        const canvasDiagonalLength = Math.sqrt(clientWidth * clientWidth + clientHeight * clientHeight);\n        const { data } = annotation;\n        const { rotationPoints } = data.handles;\n        const { slabThicknessPoints } = data.handles;\n        const viewportIdArray = [];\n        for (let i = 0; i < rotationPoints.length - 1; ++i) {\n            const otherViewport = rotationPoints[i][1];\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            const viewportDraggableRotatable = this._getReferenceLineDraggableRotatable(otherViewport.id);\n            if (!viewportControllable || !viewportDraggableRotatable) {\n                continue;\n            }\n            const lineSegment1 = {\n                start: {\n                    x: rotationPoints[i][2][0],\n                    y: rotationPoints[i][2][1],\n                },\n                end: {\n                    x: rotationPoints[i][3][0],\n                    y: rotationPoints[i][3][1],\n                },\n            };\n            const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const lineSegment2 = {\n                start: {\n                    x: rotationPoints[i + 1][2][0],\n                    y: rotationPoints[i + 1][2][1],\n                },\n                end: {\n                    x: rotationPoints[i + 1][3][0],\n                    y: rotationPoints[i + 1][3][1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                viewportIdArray.push(otherViewport.id);\n                data.handles.activeOperation = OPERATION.DRAG;\n            }\n            i++;\n        }\n        for (let i = 0; i < slabThicknessPoints.length - 1; ++i) {\n            const otherViewport = slabThicknessPoints[i][1];\n            if (viewportIdArray.find((id) => id === otherViewport.id)) {\n                continue;\n            }\n            const viewportControllable = this._getReferenceLineControllable(otherViewport.id);\n            const viewportSlabThicknessControlsOn = this._getReferenceLineSlabThicknessControlsOn(otherViewport.id);\n            if (!viewportControllable || !viewportSlabThicknessControlsOn) {\n                continue;\n            }\n            const stPointLineCanvas1 = slabThicknessPoints[i][2];\n            const stPointLineCanvas2 = slabThicknessPoints[i][3];\n            const centerCanvas = vec2.create();\n            vec2.add(centerCanvas, stPointLineCanvas1, stPointLineCanvas2);\n            vec2.scale(centerCanvas, centerCanvas, 0.5);\n            const canvasUnitVectorFromCenter = vec2.create();\n            vec2.subtract(canvasUnitVectorFromCenter, stPointLineCanvas1, centerCanvas);\n            vec2.normalize(canvasUnitVectorFromCenter, canvasUnitVectorFromCenter);\n            const canvasVectorFromCenterStart = vec2.create();\n            vec2.scale(canvasVectorFromCenterStart, canvasUnitVectorFromCenter, canvasDiagonalLength * 0.05);\n            const stPointLineCanvas1Start = vec2.create();\n            const stPointLineCanvas2Start = vec2.create();\n            vec2.add(stPointLineCanvas1Start, centerCanvas, canvasVectorFromCenterStart);\n            vec2.subtract(stPointLineCanvas2Start, centerCanvas, canvasVectorFromCenterStart);\n            const lineSegment1 = {\n                start: {\n                    x: stPointLineCanvas1Start[0],\n                    y: stPointLineCanvas1Start[1],\n                },\n                end: {\n                    x: stPointLineCanvas1[0],\n                    y: stPointLineCanvas1[1],\n                },\n            };\n            const distanceToPoint1 = lineSegment.distanceToPoint([lineSegment1.start.x, lineSegment1.start.y], [lineSegment1.end.x, lineSegment1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const lineSegment2 = {\n                start: {\n                    x: stPointLineCanvas2Start[0],\n                    y: stPointLineCanvas2Start[1],\n                },\n                end: {\n                    x: stPointLineCanvas2[0],\n                    y: stPointLineCanvas2[1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([lineSegment2.start.x, lineSegment2.start.y], [lineSegment2.end.x, lineSegment2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint1 <= proximity || distanceToPoint2 <= proximity) {\n                viewportIdArray.push(otherViewport.id);\n                data.handles.activeOperation = null;\n            }\n            i++;\n        }\n        data.activeViewportIds = [...viewportIdArray];\n        this.editData = {\n            annotation,\n        };\n        return data.handles.activeOperation === OPERATION.DRAG ? true : false;\n    }\n}\nCrosshairsTool.toolName = 'Crosshairs';\nexport default CrosshairsTool;\n","import { BaseTool } from './base';\nimport { Events } from '../enums';\nimport { getEnabledElement, StackViewport, Enums } from '@cornerstonejs/core';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { state } from '../store/state';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nconst MAGNIFY_VIEWPORT_ID = 'magnify-viewport';\nclass MagnifyTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            magnifySize: 10,\n            magnifyWidth: 250,\n            magnifyHeight: 250,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._hasBeenRemoved = false;\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            if (!(viewport instanceof StackViewport)) {\n                throw new Error('MagnifyTool only works on StackViewports');\n            }\n            const referencedImageId = this._getReferencedImageId(viewport);\n            if (!referencedImageId) {\n                throw new Error('MagnifyTool: No referenced image id found, reconstructed planes not supported yet');\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                referencedImageId,\n                viewportIdsToRender,\n                enabledElement,\n                renderingEngine,\n                currentPoints,\n            };\n            this._createMagnificationViewport();\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this.preTouchStartCallback = (evt) => {\n            this.preMouseDownCallback(evt);\n        };\n        this._createMagnificationViewport = () => {\n            const { enabledElement, referencedImageId, viewportIdsToRender, renderingEngine, currentPoints, } = this.editData;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const viewportProperties = viewport.getProperties();\n            const { rotation: originalViewportRotation } = viewport.getViewPresentation();\n            const { canvas: canvasPos, world: worldPos } = currentPoints;\n            let magnifyToolElement;\n            magnifyToolElement = element.querySelector('.magnifyTool');\n            if (magnifyToolElement === null) {\n                const magnifyElement = document.createElement('div');\n                magnifyElement.classList.add('magnifyTool');\n                magnifyElement.style.display = 'block';\n                magnifyElement.style.width = `${this.configuration.magnifyWidth}px`;\n                magnifyElement.style.height = `${this.configuration.magnifyHeight}px`;\n                magnifyElement.style.position = 'absolute';\n                magnifyToolElement = magnifyElement;\n                const viewportElement = element.querySelector('.viewport-element');\n                viewportElement.appendChild(magnifyElement);\n                const viewportInput = {\n                    viewportId: MAGNIFY_VIEWPORT_ID,\n                    type: Enums.ViewportType.STACK,\n                    element: magnifyToolElement,\n                };\n                renderingEngine.enableElement(viewportInput);\n            }\n            magnifyToolElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;\n            magnifyToolElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;\n            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n            magnifyViewport.setStack([referencedImageId]).then(() => {\n                if (this._hasBeenRemoved) {\n                    return;\n                }\n                magnifyViewport.setProperties(viewportProperties);\n                magnifyViewport.setViewPresentation({\n                    rotation: originalViewportRotation,\n                });\n                const { parallelScale } = viewport.getCamera();\n                const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();\n                const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +\n                    Math.pow(focalPoint[1] - position[1], 2) +\n                    Math.pow(focalPoint[2] - position[2], 2));\n                const updatedFocalPoint = [\n                    worldPos[0],\n                    worldPos[1],\n                    worldPos[2],\n                ];\n                const updatedPosition = [\n                    updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n                    updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n                    updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n                ];\n                magnifyViewport.setCamera({\n                    parallelScale: parallelScale * (1 / this.configuration.magnifySize),\n                    focalPoint: updatedFocalPoint,\n                    position: updatedPosition,\n                });\n                magnifyViewport.render();\n            });\n            magnifyToolElement.style.display = 'block';\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._cancelCallback = (evt) => {\n            evt.preventDefault();\n            evt.stopPropagation();\n            this._dragEndCallback(evt);\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { deltaPoints, element, currentPoints } = eventDetail;\n            const deltaPointsWorld = deltaPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            const magnifyViewport = renderingEngine.getViewport(MAGNIFY_VIEWPORT_ID);\n            const magnifyElement = element.querySelector('.magnifyTool');\n            if (!magnifyElement) {\n                return;\n            }\n            magnifyElement.style.top = `${canvasPos[1] - this.configuration.magnifyHeight / 2}px`;\n            magnifyElement.style.left = `${canvasPos[0] - this.configuration.magnifyWidth / 2}px`;\n            const { focalPoint, position } = magnifyViewport.getCamera();\n            const updatedPosition = [\n                position[0] + deltaPointsWorld[0],\n                position[1] + deltaPointsWorld[1],\n                position[2] + deltaPointsWorld[2],\n            ];\n            const updatedFocalPoint = [\n                focalPoint[0] + deltaPointsWorld[0],\n                focalPoint[1] + deltaPointsWorld[1],\n                focalPoint[2] + deltaPointsWorld[2],\n            ];\n            magnifyViewport.setCamera({\n                focalPoint: updatedFocalPoint,\n                position: updatedPosition,\n            });\n            magnifyViewport.render();\n        };\n        this._dragEndCallback = (evt) => {\n            let { element } = evt.detail;\n            if (element === undefined) {\n                const { enabledElement } = this.editData;\n                const { viewport } = enabledElement;\n                element = viewport.element;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            renderingEngine.disableElement(MAGNIFY_VIEWPORT_ID);\n            const viewportElement = element.querySelector('.viewport-element');\n            const magnifyToolElement = viewportElement.querySelector('.magnifyTool');\n            viewportElement.removeChild(magnifyToolElement);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this._hasBeenRemoved = true;\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            this._hasBeenRemoved = false;\n            element.addEventListener(Events.MOUSE_UP, this._dragEndCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._dragEndCallback);\n            element.addEventListener('contextmenu', this._cancelCallback);\n            element.addEventListener(Events.TOUCH_END, this._dragEndCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._dragEndCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._dragEndCallback);\n            element.removeEventListener('contextmenu', this._cancelCallback);\n            element.removeEventListener(Events.TOUCH_END, this._dragEndCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n    }\n    _getReferencedImageId(viewport) {\n        const targetId = this.getTargetId(viewport);\n        let referencedImageId;\n        if (viewport instanceof StackViewport) {\n            referencedImageId = targetId.split('imageId:')[1];\n        }\n        return referencedImageId;\n    }\n}\nMagnifyTool.toolName = 'Magnify';\nexport default MagnifyTool;\n","import { AnnotationTool } from './base';\nimport { getEnabledElement, utilities as csUtils, eventTarget, Enums, getRenderingEngine, CONSTANTS, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { addAnnotation, getAllAnnotations, getAnnotations, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted } from '../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, } from '../drawingSvg';\nimport { state } from '../store/state';\nimport { Events, MouseBindings, KeyboardBindings, Events as cstEvents, SegmentationRepresentations, ToolModes, } from '../enums';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { getCanvasCircleRadius } from '../utilities/math/circle';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nimport debounce from '../utilities/debounce';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { addSegmentationRepresentations } from '../stateManagement/segmentation';\nconst MAGNIFY_CLASSNAME = 'advancedMagnifyTool';\nconst MAGNIFY_VIEWPORT_INITIAL_RADIUS = 125;\nconst { Events: csEvents } = Enums;\nconst isSegmentation = (actor) => !!actor.representationUID;\nvar AdvancedMagnifyToolActions;\n(function (AdvancedMagnifyToolActions) {\n    AdvancedMagnifyToolActions[\"ShowZoomFactorsList\"] = \"showZoomFactorsList\";\n})(AdvancedMagnifyToolActions || (AdvancedMagnifyToolActions = {}));\nconst ADVANCED_MAGNIFY_TOOL_NAME = 'AdvancedMagnify';\nconst PARALLEL_THRESHOLD = 1 - CONSTANTS.EPSILON;\nclass AdvancedMagnifyTool extends AnnotationTool {\n    static { this.Actions = AdvancedMagnifyToolActions; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            magnifyingGlass: {\n                radius: 125,\n                zoomFactor: 3,\n                zoomFactorList: [1.5, 2, 2.5, 3, 3.5, 4, 4.5, 5],\n                autoPan: {\n                    enabled: true,\n                    padding: 10,\n                },\n            },\n            actions: {\n                showZoomFactorsList: {\n                    method: 'showZoomFactorsList',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Secondary,\n                            modifierKey: KeyboardBindings.Shift,\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const { magnifyingGlass: config } = this.configuration;\n            const { radius, zoomFactor, autoPan } = config;\n            const canvasHandlePoints = this._getCanvasHandlePoints(canvasPos, radius);\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotationUID = csUtils.uuidv4();\n            const magnifyViewportId = csUtils.uuidv4();\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                annotationUID,\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    sourceViewportId: viewport.id,\n                    magnifyViewportId,\n                    zoomFactor,\n                    isCanvasAnnotation: true,\n                    handles: {\n                        points: canvasHandlePoints,\n                        activeHandleIndex: null,\n                    },\n                },\n            };\n            this.magnifyViewportManager.createViewport(annotation, {\n                magnifyViewportId,\n                sourceEnabledElement: enabledElement,\n                position: canvasPos,\n                radius,\n                zoomFactor,\n                autoPan: {\n                    enabled: autoPan.enabled,\n                    padding: autoPan.padding,\n                    callback: (data) => {\n                        const annotationPoints = annotation.data.handles.points;\n                        const { canvas: canvasDelta } = data.delta;\n                        for (let i = 0, len = annotationPoints.length; i < len; i++) {\n                            const point = annotationPoints[i];\n                            point[0] += canvasDelta[0];\n                            point[1] += canvasDelta[1];\n                            annotation.invalidated = true;\n                        }\n                    },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.onSetToolDisabled = () => {\n            this.magnifyViewportManager.dispose();\n            const annotations = getAllAnnotations();\n            annotations.forEach((annotation) => {\n                if (annotation.metadata.toolName === this.getToolName()) {\n                    removeAnnotation(annotation.annotationUID);\n                }\n            });\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points;\n            const canvasTop = canvasCoordinates[0];\n            const canvasBottom = canvasCoordinates[2];\n            const canvasLeft = canvasCoordinates[3];\n            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n            const center = [\n                canvasLeft[0] + radius,\n                canvasTop[1] + radius,\n            ];\n            const radiusPoint = getCanvasCircleRadius([center, canvasCoords]);\n            if (Math.abs(radiusPoint - radius) < proximity * 2) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            const { points } = data.handles;\n            const handleIndex = points.findIndex((p) => p === handle);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { deltaPoints } = eventDetail;\n            const canvasDelta = deltaPoints?.canvas ?? [0, 0, 0];\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { points } = annotation.data.handles;\n            points.forEach((point) => {\n                point[0] += canvasDelta[0];\n                point[1] += canvasDelta[1];\n            });\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n            const { data } = annotation;\n            if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const canvasDelta = deltaPoints.canvas;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += canvasDelta[0];\n                    point[1] += canvasDelta[1];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points;\n            const canvasTop = canvasCoordinates[0];\n            const canvasBottom = canvasCoordinates[2];\n            const canvasLeft = canvasCoordinates[3];\n            const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n            const canvasCenter = [\n                canvasLeft[0] + radius,\n                canvasTop[1] + radius,\n            ];\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const newRadius = getCanvasCircleRadius([\n                canvasCenter,\n                currentCanvasPoints,\n            ]);\n            const newCanvasHandlePoints = this._getCanvasHandlePoints(canvasCenter, newRadius);\n            points[0] = newCanvasHandlePoints[0];\n            points[1] = newCanvasHandlePoints[1];\n            points[2] = newCanvasHandlePoints[2];\n            points[3] = newCanvasHandlePoints[3];\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = annotations?.filter((annotation) => annotation.data.sourceViewportId ===\n                viewport.id);\n            const filteredAnnotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!filteredAnnotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < filteredAnnotations.length; i++) {\n                const annotation = filteredAnnotations[i];\n                const { annotationUID, data } = annotation;\n                const { magnifyViewportId, zoomFactor, handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points;\n                const canvasTop = canvasCoordinates[0];\n                const canvasBottom = canvasCoordinates[2];\n                const canvasLeft = canvasCoordinates[3];\n                const radius = Math.abs(canvasBottom[1] - canvasTop[1]) * 0.5;\n                const center = [\n                    canvasLeft[0] + radius,\n                    canvasTop[1] + radius,\n                ];\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-advancedMagnify`;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineWidth: 5,\n                }, dataId);\n                const magnifyViewport = this.magnifyViewportManager.getViewport(magnifyViewportId);\n                magnifyViewport.position = center;\n                magnifyViewport.radius = radius;\n                magnifyViewport.zoomFactor = zoomFactor;\n                magnifyViewport.update();\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this._getCanvasHandlePoints = (canvasCenterPos, canvasRadius) => {\n            return [\n                [canvasCenterPos[0], canvasCenterPos[1] - canvasRadius, 0],\n                [canvasCenterPos[0] + canvasRadius, canvasCenterPos[1], 0],\n                [canvasCenterPos[0], canvasCenterPos[1] + canvasRadius, 0],\n                [canvasCenterPos[0] - canvasRadius, canvasCenterPos[1], 0],\n            ];\n        };\n        this.magnifyViewportManager = AdvancedMagnifyViewportManager.getInstance();\n    }\n    showZoomFactorsList(evt, annotation) {\n        const { element, currentPoints } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { canvas: canvasPoint } = currentPoints;\n        const viewportElement = element.querySelector(':scope .viewport-element');\n        const currentZoomFactor = annotation.data.zoomFactor;\n        const remove = () => dropdown.parentElement.removeChild(dropdown);\n        const dropdown = this._getZoomFactorsListDropdown(currentZoomFactor, (newZoomFactor) => {\n            if (newZoomFactor !== undefined) {\n                annotation.data.zoomFactor = Number.parseFloat(newZoomFactor);\n                annotation.invalidated = true;\n            }\n            remove();\n            viewport.render();\n        });\n        Object.assign(dropdown.style, {\n            left: `${canvasPoint[0]}px`,\n            top: `${canvasPoint[1]}px`,\n        });\n        viewportElement.appendChild(dropdown);\n        dropdown.focus();\n    }\n    _getZoomFactorsListDropdown(currentZoomFactor, onChangeCallback) {\n        const { zoomFactorList } = this.configuration.magnifyingGlass;\n        const dropdown = document.createElement('select');\n        dropdown.size = 5;\n        Object.assign(dropdown.style, {\n            width: '50px',\n            position: 'absolute',\n        });\n        ['mousedown', 'mouseup', 'mousemove', 'click'].forEach((eventName) => {\n            dropdown.addEventListener(eventName, (evt) => evt.stopPropagation());\n        });\n        dropdown.addEventListener('change', (evt) => {\n            evt.stopPropagation();\n            onChangeCallback(dropdown.value);\n        });\n        dropdown.addEventListener('keydown', (evt) => {\n            const shouldCancel = (evt.keyCode ?? evt.which === 27) ||\n                evt.key?.toLowerCase() === 'escape';\n            if (shouldCancel) {\n                evt.stopPropagation();\n                onChangeCallback();\n            }\n        });\n        zoomFactorList.forEach((zoomFactor) => {\n            const option = document.createElement('option');\n            option.label = zoomFactor;\n            option.title = `Zoom factor ${zoomFactor.toFixed(1)}`;\n            option.value = zoomFactor;\n            option.defaultSelected = zoomFactor === currentZoomFactor;\n            dropdown.add(option);\n        });\n        return dropdown;\n    }\n}\nclass AdvancedMagnifyViewportManager {\n    constructor() {\n        this.createViewport = (annotation, viewportInfo) => {\n            const { magnifyViewportId, sourceEnabledElement, position, radius, zoomFactor, autoPan, } = viewportInfo;\n            const { viewport: sourceViewport } = sourceEnabledElement;\n            const { element: sourceElement } = sourceViewport;\n            const magnifyViewport = new AdvancedMagnifyViewport({\n                magnifyViewportId,\n                sourceEnabledElement,\n                radius,\n                position,\n                zoomFactor,\n                autoPan,\n            });\n            this._addSourceElementEventListener(sourceElement);\n            this._magnifyViewportsMap.set(magnifyViewport.viewportId, {\n                annotation,\n                magnifyViewport,\n                magnifyViewportInfo: viewportInfo,\n            });\n            return magnifyViewport;\n        };\n        this._annotationRemovedCallback = (evt) => {\n            const { annotation } = evt.detail;\n            if (annotation.metadata.toolName !== ADVANCED_MAGNIFY_TOOL_NAME) {\n                return;\n            }\n            this.destroyViewport(annotation.data.magnifyViewportId);\n        };\n        this._newStackImageCallback = (evt) => {\n            const { viewportId: sourceViewportId, imageId } = evt.detail;\n            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n            const { viewport } = getEnabledElementByViewportId(sourceViewportId);\n            if (viewport.stackActorReInitialized) {\n                this._reset(sourceViewportId);\n            }\n            magnifyViewportsMapEntries.forEach(({ annotation }) => {\n                annotation.metadata.referencedImageId = imageId;\n                annotation.invalidated = true;\n            });\n        };\n        this._newVolumeImageCallback = (evt) => {\n            const { renderingEngineId, viewportId: sourceViewportId } = evt.detail;\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            const sourceViewport = renderingEngine.getViewport(sourceViewportId);\n            const { viewPlaneNormal: currentViewPlaneNormal } = sourceViewport.getCamera();\n            const magnifyViewportsMapEntries = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n            magnifyViewportsMapEntries.forEach(({ annotation }) => {\n                const { viewPlaneNormal } = annotation.metadata;\n                const isParallel = Math.abs(vec3.dot(viewPlaneNormal, currentViewPlaneNormal)) >\n                    PARALLEL_THRESHOLD;\n                if (!isParallel) {\n                    return;\n                }\n                const { handles } = annotation.data;\n                const worldImagePlanePoint = sourceViewport.canvasToWorld([0, 0]);\n                const vecHandleToImagePlane = vec3.sub(vec3.create(), worldImagePlanePoint, handles.points[0]);\n                const worldDist = vec3.dot(vecHandleToImagePlane, currentViewPlaneNormal);\n                const worldDelta = vec3.scale(vec3.create(), currentViewPlaneNormal, worldDist);\n                for (let i = 0, len = handles.points.length; i < len; i++) {\n                    const point = handles.points[i];\n                    point[0] += worldDelta[0];\n                    point[1] += worldDelta[1];\n                    point[2] += worldDelta[2];\n                }\n                annotation.invalidated = true;\n            });\n        };\n        this._magnifyViewportsMap = new Map();\n        this._initialize();\n    }\n    static getInstance() {\n        AdvancedMagnifyViewportManager._singleton =\n            AdvancedMagnifyViewportManager._singleton ??\n                new AdvancedMagnifyViewportManager();\n        return AdvancedMagnifyViewportManager._singleton;\n    }\n    getViewport(magnifyViewportId) {\n        return this._magnifyViewportsMap.get(magnifyViewportId)?.magnifyViewport;\n    }\n    dispose() {\n        this._removeEventListeners();\n        this._destroyViewports();\n    }\n    destroyViewport(magnifyViewportId) {\n        const magnifyViewportMapEntry = this._magnifyViewportsMap.get(magnifyViewportId);\n        if (magnifyViewportMapEntry) {\n            const { magnifyViewport } = magnifyViewportMapEntry;\n            const { viewport: sourceViewport } = magnifyViewport.sourceEnabledElement;\n            const { element: sourceElement } = sourceViewport;\n            this._removeSourceElementEventListener(sourceElement);\n            magnifyViewport.dispose();\n            this._magnifyViewportsMap.delete(magnifyViewportId);\n        }\n    }\n    _destroyViewports() {\n        const magnifyViewportIds = Array.from(this._magnifyViewportsMap.keys());\n        magnifyViewportIds.forEach((magnifyViewportId) => this.destroyViewport(magnifyViewportId));\n    }\n    _getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId) {\n        const magnifyViewportsMapEntries = Array.from(this._magnifyViewportsMap.values());\n        return magnifyViewportsMapEntries.filter(({ magnifyViewport }) => {\n            const { viewport } = magnifyViewport.sourceEnabledElement;\n            return viewport.id === sourceViewportId;\n        });\n    }\n    _reset(sourceViewportId) {\n        const magnifyViewports = this._getMagnifyViewportsMapEntriesBySourceViewportId(sourceViewportId);\n        magnifyViewports.forEach(({ magnifyViewport, annotation, magnifyViewportInfo }) => {\n            this.destroyViewport(magnifyViewport.viewportId);\n            const newEnabledElement = getEnabledElementByViewportId(sourceViewportId);\n            this.createViewport(annotation, {\n                ...magnifyViewportInfo,\n                sourceEnabledElement: {\n                    ...newEnabledElement,\n                },\n            });\n        });\n    }\n    _addEventListeners() {\n        eventTarget.addEventListener(cstEvents.ANNOTATION_REMOVED, this._annotationRemovedCallback);\n    }\n    _removeEventListeners() {\n        eventTarget.removeEventListener(cstEvents.ANNOTATION_REMOVED, this._annotationRemovedCallback);\n    }\n    _addSourceElementEventListener(element) {\n        element.addEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);\n        const newStackHandler = (evt) => {\n            const { viewportId: sourceViewportId } = evt.detail;\n            this._reset(sourceViewportId);\n        };\n        element.addEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, newStackHandler);\n        const newVolumeHandler = (evt) => {\n            const { viewportId: sourceViewportId } = evt.detail;\n            this._reset(sourceViewportId);\n        };\n        element.addEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, newVolumeHandler);\n        element.addEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);\n        element.newStackHandler = newStackHandler;\n        element.newVolumeHandler = newVolumeHandler;\n    }\n    _removeSourceElementEventListener(element) {\n        element.removeEventListener(csEvents.STACK_NEW_IMAGE, this._newStackImageCallback);\n        element.removeEventListener(csEvents.VOLUME_NEW_IMAGE, this._newVolumeImageCallback);\n        element.removeEventListener(csEvents.VIEWPORT_NEW_IMAGE_SET, element.newStackHandler);\n        element.removeEventListener(csEvents.VOLUME_VIEWPORT_NEW_VOLUME, element.newVolumeHandler);\n        delete element.newStackHandler;\n        delete element.newVolumeHandler;\n    }\n    _initialize() {\n        this._addEventListeners();\n    }\n}\nclass AdvancedMagnifyViewport {\n    constructor({ magnifyViewportId, sourceEnabledElement, radius = MAGNIFY_VIEWPORT_INITIAL_RADIUS, position = [0, 0], zoomFactor, autoPan, }) {\n        this._enabledElement = null;\n        this._sourceToolGroup = null;\n        this._magnifyToolGroup = null;\n        this._isViewportReady = false;\n        this._radius = 0;\n        this._resized = false;\n        this._canAutoPan = false;\n        this._viewportId = magnifyViewportId ?? csUtils.uuidv4();\n        this._sourceEnabledElement = sourceEnabledElement;\n        this._autoPan = autoPan;\n        this.radius = radius;\n        this.position = position;\n        this.zoomFactor = zoomFactor;\n        this.visible = true;\n        this._browserMouseDownCallback = this._browserMouseDownCallback.bind(this);\n        this._browserMouseUpCallback = this._browserMouseUpCallback.bind(this);\n        this._handleToolModeChanged = this._handleToolModeChanged.bind(this);\n        this._mouseDragCallback = this._mouseDragCallback.bind(this);\n        this._resizeViewportAsync = (debounce(this._resizeViewport.bind(this), 1));\n        this._initialize();\n    }\n    get sourceEnabledElement() {\n        return this._sourceEnabledElement;\n    }\n    get viewportId() {\n        return this._viewportId;\n    }\n    get radius() {\n        return this._radius;\n    }\n    set radius(radius) {\n        if (Math.abs(this._radius - radius) > 0.00001) {\n            this._radius = radius;\n            this._resized = true;\n        }\n    }\n    update() {\n        const { radius, position, visible } = this;\n        const { viewport } = this._enabledElement;\n        const { element } = viewport;\n        const size = 2 * radius;\n        const [x, y] = position;\n        if (this._resized) {\n            this._resizeViewportAsync();\n            this._resized = false;\n        }\n        Object.assign(element.style, {\n            display: visible ? 'block' : 'hidden',\n            width: `${size}px`,\n            height: `${size}px`,\n            left: `${-radius}px`,\n            top: `${-radius}px`,\n            transform: `translate(${x}px, ${y}px)`,\n        });\n        if (this._isViewportReady) {\n            this._syncViewports();\n            viewport.render();\n        }\n    }\n    dispose() {\n        const { viewport } = this._enabledElement;\n        const { element } = viewport;\n        const renderingEngine = viewport.getRenderingEngine();\n        this._removeEventListeners(element);\n        renderingEngine.disableElement(viewport.id);\n        if (element.parentNode) {\n            element.parentNode.removeChild(element);\n        }\n    }\n    _handleToolModeChanged(evt) {\n        const { _magnifyToolGroup: magnifyToolGroup } = this;\n        const { toolGroupId, toolName, mode, toolBindingsOptions } = evt.detail;\n        if (this._sourceToolGroup?.id !== toolGroupId) {\n            return;\n        }\n        switch (mode) {\n            case ToolModes.Active:\n                magnifyToolGroup.setToolActive(toolName, toolBindingsOptions);\n                break;\n            case ToolModes.Passive:\n                magnifyToolGroup.setToolPassive(toolName);\n                break;\n            case ToolModes.Enabled:\n                magnifyToolGroup.setToolEnabled(toolName);\n                break;\n            case ToolModes.Disabled:\n                magnifyToolGroup.setToolDisabled(toolName);\n                break;\n            default:\n                throw new Error(`Unknow tool mode (${mode})`);\n        }\n    }\n    _inheritBorderRadius(magnifyElement) {\n        const viewport = magnifyElement.querySelector('.viewport-element');\n        const canvas = magnifyElement.querySelector('.cornerstone-canvas');\n        viewport.style.borderRadius = 'inherit';\n        canvas.style.borderRadius = 'inherit';\n    }\n    _createViewportNode() {\n        const magnifyElement = document.createElement('div');\n        const { radius } = this;\n        const size = radius * 2;\n        magnifyElement.classList.add(MAGNIFY_CLASSNAME);\n        Object.assign(magnifyElement.style, {\n            display: 'block',\n            width: `${size}px`,\n            height: `${size}px`,\n            position: 'absolute',\n            overflow: 'hidden',\n            borderRadius: '50%',\n            boxSizing: 'border-box',\n            left: `${-radius}px`,\n            top: `${-radius}px`,\n            transform: `translate(-1000px, -1000px)`,\n        });\n        return magnifyElement;\n    }\n    _convertZoomFactorToParallelScale(viewport, magnifyViewport, zoomFactor) {\n        const { parallelScale } = viewport.getCamera();\n        const canvasRatio = magnifyViewport.canvas.offsetWidth / viewport.canvas.offsetWidth;\n        return parallelScale * (1 / zoomFactor) * canvasRatio;\n    }\n    _isStackViewport(viewport) {\n        return 'setStack' in viewport;\n    }\n    _isVolumeViewport(viewport) {\n        return 'addVolumes' in viewport;\n    }\n    _cloneToolGroups(sourceViewport, magnifyViewport) {\n        const sourceActors = sourceViewport.getActors();\n        const magnifyToolGroupId = `${magnifyViewport.id}-toolGroup`;\n        const sourceToolGroup = getToolGroupForViewport(sourceViewport.id, sourceViewport.renderingEngineId);\n        const magnifyToolGroup = sourceToolGroup.clone(magnifyToolGroupId, (toolName) => {\n            const toolInstance = sourceToolGroup.getToolInstance(toolName);\n            const isAnnotationTool = toolInstance instanceof AnnotationTool &&\n                !(toolInstance instanceof AdvancedMagnifyTool);\n            return isAnnotationTool;\n        });\n        magnifyToolGroup.addViewport(magnifyViewport.id, magnifyViewport.renderingEngineId);\n        sourceActors.filter(isSegmentation).forEach((actor) => {\n            addSegmentationRepresentations(this.viewportId, [\n                {\n                    segmentationId: actor.referencedId,\n                    type: SegmentationRepresentations.Labelmap,\n                },\n            ]);\n        });\n        return { sourceToolGroup, magnifyToolGroup };\n    }\n    _cloneStack(sourceViewport, magnifyViewport) {\n        const imageIds = sourceViewport.getImageIds();\n        magnifyViewport.setStack(imageIds).then(() => {\n            this._isViewportReady = true;\n            this.update();\n        });\n    }\n    _cloneVolumes(sourceViewport, magnifyViewport) {\n        const actors = sourceViewport.getActors();\n        const volumeInputArray = actors\n            .filter((actor) => !isSegmentation(actor))\n            .map((actor) => ({ volumeId: actor.referencedId }));\n        magnifyViewport.setVolumes(volumeInputArray).then(() => {\n            this._isViewportReady = true;\n            this.update();\n        });\n        return magnifyViewport;\n    }\n    _cloneViewport(sourceViewport, magnifyElement) {\n        const { viewportId: magnifyViewportId } = this;\n        const renderingEngine = sourceViewport.getRenderingEngine();\n        const { options: sourceViewportOptions } = sourceViewport;\n        const viewportInput = {\n            element: magnifyElement,\n            viewportId: magnifyViewportId,\n            type: sourceViewport.type,\n            defaultOptions: { ...sourceViewportOptions },\n        };\n        renderingEngine.enableElement(viewportInput);\n        const magnifyViewport = (renderingEngine.getViewport(magnifyViewportId));\n        if (this._isStackViewport(sourceViewport)) {\n            this._cloneStack(sourceViewport, magnifyViewport);\n        }\n        else if (this._isVolumeViewport(sourceViewport)) {\n            this._cloneVolumes(sourceViewport, magnifyViewport);\n        }\n        this._inheritBorderRadius(magnifyElement);\n        const toolGroups = this._cloneToolGroups(sourceViewport, magnifyViewport);\n        this._sourceToolGroup = toolGroups.sourceToolGroup;\n        this._magnifyToolGroup = toolGroups.magnifyToolGroup;\n    }\n    _cancelMouseEventCallback(evt) {\n        evt.stopPropagation();\n        evt.preventDefault();\n    }\n    _browserMouseUpCallback(evt) {\n        const { element } = this._enabledElement.viewport;\n        document.removeEventListener('mouseup', this._browserMouseUpCallback);\n        element.addEventListener('mouseup', this._cancelMouseEventCallback);\n        element.addEventListener('mousemove', this._cancelMouseEventCallback);\n    }\n    _browserMouseDownCallback(evt) {\n        const { element } = this._enabledElement.viewport;\n        this._canAutoPan = !!evt.target?.closest('.advancedMagnifyTool');\n        document.addEventListener('mouseup', this._browserMouseUpCallback);\n        element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n        element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n    }\n    _mouseDragCallback(evt) {\n        if (!state.isInteractingWithTool) {\n            return;\n        }\n        const { _autoPan: autoPan } = this;\n        if (!autoPan.enabled || !this._canAutoPan) {\n            return;\n        }\n        const { currentPoints } = evt.detail;\n        const { viewport } = this._enabledElement;\n        const { canvasToWorld } = viewport;\n        const { canvas: canvasCurrent } = currentPoints;\n        const { radius: magnifyRadius } = this;\n        const canvasCenter = [magnifyRadius, magnifyRadius];\n        const dist = distanceToPoint(canvasCenter, canvasCurrent);\n        const maxDist = magnifyRadius - autoPan.padding;\n        if (dist <= maxDist) {\n            return;\n        }\n        const panDist = dist - maxDist;\n        const canvasDeltaPos = vec2.sub(vec2.create(), canvasCurrent, canvasCenter);\n        vec2.normalize(canvasDeltaPos, canvasDeltaPos);\n        vec2.scale(canvasDeltaPos, canvasDeltaPos, panDist);\n        const newCanvasPosition = vec2.add(vec2.create(), this.position, canvasDeltaPos);\n        const currentWorldPos = canvasToWorld(this.position);\n        const newWorldPos = canvasToWorld(newCanvasPosition);\n        const worldDeltaPos = vec3.sub(vec3.create(), newWorldPos, currentWorldPos);\n        const autoPanCallbackData = {\n            points: {\n                currentPosition: {\n                    canvas: this.position,\n                    world: currentWorldPos,\n                },\n                newPosition: {\n                    canvas: newCanvasPosition,\n                    world: newWorldPos,\n                },\n            },\n            delta: {\n                canvas: canvasDeltaPos,\n                world: worldDeltaPos,\n            },\n        };\n        autoPan.callback(autoPanCallbackData);\n    }\n    _addBrowserEventListeners(element) {\n        document.addEventListener('mousedown', this._browserMouseDownCallback, true);\n        element.addEventListener('mousedown', this._cancelMouseEventCallback);\n        element.addEventListener('mouseup', this._cancelMouseEventCallback);\n        element.addEventListener('mousemove', this._cancelMouseEventCallback);\n        element.addEventListener('dblclick', this._cancelMouseEventCallback);\n    }\n    _removeBrowserEventListeners(element) {\n        document.removeEventListener('mousedown', this._browserMouseDownCallback, true);\n        document.removeEventListener('mouseup', this._browserMouseUpCallback);\n        element.removeEventListener('mousedown', this._cancelMouseEventCallback);\n        element.removeEventListener('mouseup', this._cancelMouseEventCallback);\n        element.removeEventListener('mousemove', this._cancelMouseEventCallback);\n        element.removeEventListener('dblclick', this._cancelMouseEventCallback);\n    }\n    _addEventListeners(element) {\n        eventTarget.addEventListener(cstEvents.TOOL_MODE_CHANGED, this._handleToolModeChanged);\n        element.addEventListener(cstEvents.MOUSE_MOVE, this._mouseDragCallback);\n        element.addEventListener(cstEvents.MOUSE_DRAG, this._mouseDragCallback);\n        this._addBrowserEventListeners(element);\n    }\n    _removeEventListeners(element) {\n        eventTarget.removeEventListener(cstEvents.TOOL_MODE_CHANGED, this._handleToolModeChanged);\n        element.addEventListener(cstEvents.MOUSE_MOVE, this._mouseDragCallback);\n        element.addEventListener(cstEvents.MOUSE_DRAG, this._mouseDragCallback);\n        this._removeBrowserEventListeners(element);\n    }\n    _initialize() {\n        const { _sourceEnabledElement: sourceEnabledElement } = this;\n        const { viewport: sourceViewport } = sourceEnabledElement;\n        const { canvas: sourceCanvas } = sourceViewport;\n        const magnifyElement = this._createViewportNode();\n        sourceCanvas.parentNode.appendChild(magnifyElement);\n        this._addEventListeners(magnifyElement);\n        this._cloneViewport(sourceViewport, magnifyElement);\n        this._enabledElement = getEnabledElement(magnifyElement);\n    }\n    _syncViewportsCameras(sourceViewport, magnifyViewport) {\n        const worldPos = sourceViewport.canvasToWorld(this.position);\n        const parallelScale = this._convertZoomFactorToParallelScale(sourceViewport, magnifyViewport, this.zoomFactor);\n        const { focalPoint, position, viewPlaneNormal } = magnifyViewport.getCamera();\n        const distance = Math.sqrt(Math.pow(focalPoint[0] - position[0], 2) +\n            Math.pow(focalPoint[1] - position[1], 2) +\n            Math.pow(focalPoint[2] - position[2], 2));\n        const updatedFocalPoint = [\n            worldPos[0],\n            worldPos[1],\n            worldPos[2],\n        ];\n        const updatedPosition = [\n            updatedFocalPoint[0] + distance * viewPlaneNormal[0],\n            updatedFocalPoint[1] + distance * viewPlaneNormal[1],\n            updatedFocalPoint[2] + distance * viewPlaneNormal[2],\n        ];\n        magnifyViewport.setCamera({\n            parallelScale,\n            focalPoint: updatedFocalPoint,\n            position: updatedPosition,\n        });\n    }\n    _syncStackViewports(sourceViewport, magnifyViewport) {\n        magnifyViewport.setImageIdIndex(sourceViewport.getCurrentImageIdIndex());\n    }\n    _syncViewports() {\n        const { viewport: sourceViewport } = this._sourceEnabledElement;\n        const { viewport: magnifyViewport } = this._enabledElement;\n        const sourceProperties = sourceViewport.getProperties();\n        const imageData = magnifyViewport.getImageData();\n        if (!imageData) {\n            return;\n        }\n        magnifyViewport.setProperties(sourceProperties);\n        this._syncViewportsCameras(sourceViewport, magnifyViewport);\n        if (this._isStackViewport(sourceViewport)) {\n            this._syncStackViewports(sourceViewport, magnifyViewport);\n        }\n        this._syncViewportsCameras(sourceViewport, magnifyViewport);\n        magnifyViewport.render();\n    }\n    _resizeViewport() {\n        const { viewport } = this._enabledElement;\n        const renderingEngine = viewport.getRenderingEngine();\n        renderingEngine.resize();\n    }\n}\nAdvancedMagnifyTool.toolName = 'AdvancedMagnify';\nexport { AdvancedMagnifyTool as default };\n","import { vec3 } from 'gl-matrix';\nimport { getRenderingEngines, CONSTANTS, utilities as csUtils, } from '@cornerstonejs/core';\nimport { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nconst { EPSILON } = CONSTANTS;\nclass ReferenceLines extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            sourceViewportId: '',\n            enforceSameFrameOfReference: true,\n            showFullDimension: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.editData = null;\n        this._init = () => {\n            const renderingEngines = getRenderingEngines();\n            const renderingEngine = renderingEngines[0];\n            if (!renderingEngine) {\n                return;\n            }\n            let viewports = renderingEngine.getViewports();\n            viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n            const sourceViewport = renderingEngine.getViewport(this.configuration.sourceViewportId);\n            if (!sourceViewport?.getImageData()) {\n                return;\n            }\n            const { element } = sourceViewport;\n            const { viewUp, viewPlaneNormal } = sourceViewport.getCamera();\n            const sourceViewportCanvasCornersInWorld = csUtils.getViewportImageCornersInWorld(sourceViewport);\n            let annotation = this.editData?.annotation;\n            const FrameOfReferenceUID = sourceViewport.getFrameOfReferenceUID();\n            if (!annotation) {\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        viewPlaneNormal: [...viewPlaneNormal],\n                        viewUp: [...viewUp],\n                        FrameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        handles: {\n                            points: sourceViewportCanvasCornersInWorld,\n                        },\n                    },\n                };\n                addAnnotation(newAnnotation, element);\n                annotation = newAnnotation;\n            }\n            else {\n                this.editData.annotation.data.handles.points =\n                    sourceViewportCanvasCornersInWorld;\n            }\n            this.editData = {\n                sourceViewportId: sourceViewport.id,\n                renderingEngine,\n                annotation,\n            };\n            triggerAnnotationRenderForViewportIds(viewports\n                .filter((viewport) => viewport.id !== sourceViewport.id)\n                .map((viewport) => viewport.id));\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onSetToolConfiguration = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this._init();\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const { viewport: targetViewport } = enabledElement;\n            if (!this.editData) {\n                return false;\n            }\n            const { annotation, sourceViewportId } = this.editData;\n            let renderStatus = false;\n            const { viewport: sourceViewport } = getEnabledElementByViewportId(sourceViewportId) || {};\n            if (!sourceViewport) {\n                return renderStatus;\n            }\n            if (sourceViewport.id === targetViewport.id) {\n                return renderStatus;\n            }\n            if (!annotation || !annotation?.data?.handles?.points) {\n                return renderStatus;\n            }\n            if (this.configuration.enforceSameFrameOfReference &&\n                sourceViewport.getFrameOfReferenceUID() !==\n                    targetViewport.getFrameOfReferenceUID()) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const topLeft = annotation.data.handles.points[0];\n            const topRight = annotation.data.handles.points[1];\n            const bottomLeft = annotation.data.handles.points[2];\n            const bottomRight = annotation.data.handles.points[3];\n            const { focalPoint, viewPlaneNormal, viewUp } = targetViewport.getCamera();\n            const { viewPlaneNormal: sourceViewPlaneNormal } = sourceViewport.getCamera();\n            if (this.isParallel(viewPlaneNormal, sourceViewPlaneNormal)) {\n                return renderStatus;\n            }\n            const targetViewportPlane = csUtils.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n            let pointSetToUse = pointSet1;\n            let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n            topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n            let topRightVec = vec3.subtract(vec3.create(), pointSet1[2], pointSet1[0]);\n            topRightVec = vec3.normalize(vec3.create(), topRightVec);\n            const newNormal = vec3.cross(vec3.create(), topBottomVec, topRightVec);\n            if (this.isParallel(newNormal, viewPlaneNormal)) {\n                return renderStatus;\n            }\n            if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n                pointSetToUse = pointSet2;\n            }\n            const lineStartWorld = csUtils.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);\n            const lineEndWorld = csUtils.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);\n            const { annotationUID } = annotation;\n            styleSpecifier.annotationUID = annotationUID;\n            const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n            const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n            const color = this.getStyle('color', styleSpecifier, annotation);\n            const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n            let canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));\n            if (this.configuration.showFullDimension) {\n                canvasCoordinates = this.handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates);\n            }\n            if (canvasCoordinates.length < 2) {\n                return renderStatus;\n            }\n            const dataId = `${annotationUID}-line`;\n            const lineUID = '1';\n            drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                color,\n                width: lineWidth,\n                lineDash,\n                shadow,\n            }, dataId);\n            renderStatus = true;\n            return renderStatus;\n        };\n        this.isPerpendicular = (vec1, vec2) => {\n            const dot = vec3.dot(vec1, vec2);\n            return Math.abs(dot) < EPSILON;\n        };\n    }\n    handleFullDimension(targetViewport, lineStartWorld, viewPlaneNormal, viewUp, lineEndWorld, canvasCoordinates) {\n        const renderingEngine = targetViewport.getRenderingEngine();\n        const targetId = this.getTargetId(targetViewport);\n        const targetImage = this.getTargetImageData(targetId);\n        const referencedImageId = this.getReferencedImageId(targetViewport, lineStartWorld, viewPlaneNormal, viewUp);\n        if (referencedImageId && targetImage) {\n            try {\n                const { imageData, dimensions } = targetImage;\n                const [topLeftImageCoord, topRightImageCoord, bottomRightImageCoord, bottomLeftImageCoord,] = [\n                    imageData.indexToWorld([0, 0, 0]),\n                    imageData.indexToWorld([dimensions[0] - 1, 0, 0]),\n                    imageData.indexToWorld([\n                        dimensions[0] - 1,\n                        dimensions[1] - 1,\n                        0,\n                    ]),\n                    imageData.indexToWorld([0, dimensions[1] - 1, 0]),\n                ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n                const [lineStartImageCoord, lineEndImageCoord] = [\n                    lineStartWorld,\n                    lineEndWorld,\n                ].map((world) => csUtils.worldToImageCoords(referencedImageId, world));\n                canvasCoordinates = [\n                    [topLeftImageCoord, topRightImageCoord],\n                    [topRightImageCoord, bottomRightImageCoord],\n                    [bottomLeftImageCoord, bottomRightImageCoord],\n                    [topLeftImageCoord, bottomLeftImageCoord],\n                ]\n                    .map(([start, end]) => this.intersectInfiniteLines(start, end, lineStartImageCoord, lineEndImageCoord))\n                    .filter((point) => point && this.isInBound(point, dimensions))\n                    .map((point) => {\n                    const world = csUtils.imageToWorldCoords(referencedImageId, point);\n                    return targetViewport.worldToCanvas(world);\n                });\n            }\n            catch (err) {\n                console.log(err);\n            }\n        }\n        return canvasCoordinates;\n    }\n    intersectInfiniteLines(line1Start, line1End, line2Start, line2End) {\n        const [x1, y1] = line1Start;\n        const [x2, y2] = line1End;\n        const [x3, y3] = line2Start;\n        const [x4, y4] = line2End;\n        const a1 = y2 - y1;\n        const b1 = x1 - x2;\n        const c1 = x2 * y1 - x1 * y2;\n        const a2 = y4 - y3;\n        const b2 = x3 - x4;\n        const c2 = x4 * y3 - x3 * y4;\n        if (Math.abs(a1 * b2 - a2 * b1) < EPSILON) {\n            return;\n        }\n        const x = (b1 * c2 - b2 * c1) / (a1 * b2 - a2 * b1);\n        const y = (a2 * c1 - a1 * c2) / (a1 * b2 - a2 * b1);\n        return [x, y];\n    }\n    isParallel(vec1, vec2) {\n        return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n    }\n    isInBound(point, dimensions) {\n        return (point[0] >= 0 &&\n            point[0] <= dimensions[0] &&\n            point[1] >= 0 &&\n            point[1] <= dimensions[1]);\n    }\n}\nReferenceLines.toolName = 'ReferenceLines';\nexport default ReferenceLines;\n","import { vec3 } from 'gl-matrix';\nimport { metaData, CONSTANTS, getRenderingEngine, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport { drawLine as drawLineSvg } from '../drawingSvg';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nconst { EPSILON } = CONSTANTS;\nclass OverlayGridTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            sourceImageIds: [],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onSetToolActive = () => {\n            this._init();\n        };\n        this._init = () => {\n            const sourceImageIds = this.configuration.sourceImageIds;\n            if (!sourceImageIds?.length) {\n                console.warn('OverlayGridTool: No sourceImageIds provided in configuration');\n                return;\n            }\n            const imagePlaneModule = metaData.get('imagePlaneModule', sourceImageIds[0]);\n            if (!imagePlaneModule) {\n                console.warn('OverlayGridTool: No imagePlaneModule found for sourceImageIds');\n                return;\n            }\n            const { frameOfReferenceUID } = imagePlaneModule;\n            const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportsInfo?.length) {\n                console.warn('OverlayGridTool: No viewports found');\n                return;\n            }\n            const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n            if (!annotations?.length) {\n                const pointSets = sourceImageIds.map((id) => {\n                    return this.calculateImageIdPointSets(id);\n                });\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        FrameOfReferenceUID: frameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        viewportData: new Map(),\n                        pointSets,\n                    },\n                };\n                addAnnotation(newAnnotation, frameOfReferenceUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        };\n        this.calculateImageIdPointSets = (imageId) => {\n            const { imagePositionPatient, rows, columns, rowCosines, columnCosines, rowPixelSpacing, columnPixelSpacing, } = metaData.get('imagePlaneModule', imageId);\n            const topLeft = [...imagePositionPatient];\n            const topRight = [...imagePositionPatient];\n            const bottomLeft = [...imagePositionPatient];\n            const bottomRight = [...imagePositionPatient];\n            vec3.scaleAndAdd(topRight, imagePositionPatient, columnCosines, columns * columnPixelSpacing);\n            vec3.scaleAndAdd(bottomLeft, imagePositionPatient, rowCosines, rows * rowPixelSpacing);\n            vec3.scaleAndAdd(bottomRight, bottomLeft, columnCosines, columns * columnPixelSpacing);\n            const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n            const pointSet2 = [topLeft, topRight, bottomLeft, bottomRight];\n            return { pointSet1, pointSet2 };\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const sourceImageIds = this.configuration.sourceImageIds;\n            let renderStatus = false;\n            if (!sourceImageIds?.length) {\n                return renderStatus;\n            }\n            const { viewport: targetViewport, FrameOfReferenceUID } = enabledElement;\n            const targetImageIds = targetViewport.getImageIds();\n            if (targetImageIds.length < 2) {\n                return renderStatus;\n            }\n            const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const annotation = annotations[0];\n            const { annotationUID } = annotation;\n            const { focalPoint, viewPlaneNormal } = targetViewport.getCamera();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const imageIdNormal = (this.getImageIdNormal(sourceImageIds[0]));\n            if (this.isParallel(viewPlaneNormal, imageIdNormal)) {\n                return renderStatus;\n            }\n            const targetViewportPlane = csUtils.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const pointSets = annotation.data.pointSets;\n            const viewportData = annotation.data.viewportData;\n            for (let i = 0; i < sourceImageIds.length; i++) {\n                const { pointSet1, pointSet2 } = pointSets[i];\n                const targetData = viewportData.get(targetViewport.id) ||\n                    this.initializeViewportData(viewportData, targetViewport.id);\n                if (!targetData.pointSetsToUse[i]) {\n                    let pointSetToUse = pointSet1;\n                    let topBottomVec = vec3.subtract(vec3.create(), pointSet1[0], pointSet1[1]);\n                    topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n                    if (this.isPerpendicular(topBottomVec, viewPlaneNormal)) {\n                        pointSetToUse = pointSet2;\n                    }\n                    targetData.pointSetsToUse[i] = pointSetToUse;\n                    targetData.lineStartsWorld[i] = csUtils.planar.linePlaneIntersection(pointSetToUse[0], pointSetToUse[1], targetViewportPlane);\n                    targetData.lineEndsWorld[i] = csUtils.planar.linePlaneIntersection(pointSetToUse[2], pointSetToUse[3], targetViewportPlane);\n                }\n                const lineStartWorld = targetData.lineStartsWorld[i];\n                const lineEndWorld = targetData.lineEndsWorld[i];\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n                const canvasCoordinates = [lineStartWorld, lineEndWorld].map((world) => targetViewport.worldToCanvas(world));\n                const dataId = `${annotationUID}-line`;\n                const lineUID = `${i}`;\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n            }\n            renderStatus = true;\n            return renderStatus;\n        };\n        this.initializeViewportData = (viewportData, id) => {\n            viewportData.set(id, {\n                pointSetsToUse: [],\n                lineStartsWorld: [],\n                lineEndsWorld: [],\n            });\n            return viewportData.get(id);\n        };\n        this.isPerpendicular = (vec1, vec2) => {\n            const dot = vec3.dot(vec1, vec2);\n            return Math.abs(dot) < EPSILON;\n        };\n    }\n    isParallel(vec1, vec2) {\n        return Math.abs(vec3.dot(vec1, vec2)) > 1 - EPSILON;\n    }\n    getImageIdNormal(imageId) {\n        const { imageOrientationPatient } = metaData.get('imagePlaneModule', imageId);\n        const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n        const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n        return vec3.cross(vec3.create(), rowCosineVec, colCosineVec);\n    }\n}\nOverlayGridTool.toolName = 'OverlayGrid';\nexport default OverlayGridTool;\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { drawPath } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { distanceToPoint } from '../utilities/math/point';\nimport { pointToString } from '../utilities/pointToString';\nimport { polyDataUtils } from '../utilities';\nclass SegmentationIntersectionTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            opacity: 0.5,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._init = () => {\n            const viewportsInfo = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportsInfo?.length) {\n                console.warn(this.getToolName() + 'Tool: No viewports found');\n                return;\n            }\n            const firstViewport = getRenderingEngine(viewportsInfo[0].renderingEngineId)?.getViewport(viewportsInfo[0].viewportId);\n            if (!firstViewport) {\n                return;\n            }\n            const frameOfReferenceUID = firstViewport.getFrameOfReferenceUID();\n            const annotations = getAnnotations(this.getToolName(), frameOfReferenceUID);\n            if (!annotations?.length) {\n                const actorsWorldPointsMap = new Map();\n                calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo);\n                const newAnnotation = {\n                    highlighted: true,\n                    invalidated: true,\n                    metadata: {\n                        toolName: this.getToolName(),\n                        FrameOfReferenceUID: frameOfReferenceUID,\n                        referencedImageId: null,\n                    },\n                    data: {\n                        actorsWorldPointsMap,\n                    },\n                };\n                addAnnotation(newAnnotation, frameOfReferenceUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportsInfo.map(({ viewportId }) => viewportId));\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this._init();\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const { viewport, FrameOfReferenceUID } = enabledElement;\n            let renderStatus = false;\n            const annotations = getAnnotations(this.getToolName(), FrameOfReferenceUID);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const annotation = annotations[0];\n            const { annotationUID } = annotation;\n            const actorsWorldPointsMap = (annotation).data.actorsWorldPointsMap;\n            calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);\n            const actorEntries = viewport.getActors();\n            const cacheId = getCacheId(viewport);\n            actorEntries.forEach((actorEntry) => {\n                if (!actorEntry?.clippingFilter) {\n                    return;\n                }\n                const actorWorldPointMap = actorsWorldPointsMap.get(actorEntry.uid);\n                if (!actorWorldPointMap) {\n                    return;\n                }\n                if (!actorWorldPointMap.get(cacheId)) {\n                    return;\n                }\n                let polyLineIdx = 1;\n                const { worldPointsSet, color } = actorWorldPointMap.get(cacheId);\n                for (let i = 0; i < worldPointsSet.length; i++) {\n                    const worldPoints = worldPointsSet[i];\n                    const canvasPoints = worldPoints.map((point) => viewport.worldToCanvas(point));\n                    const options = {\n                        color: color,\n                        fillColor: color,\n                        fillOpacity: this.configuration.opacity,\n                        closePath: true,\n                        lineWidth: 2,\n                    };\n                    const polyLineUID = actorEntry.uid + '#' + polyLineIdx;\n                    drawPath(svgDrawingHelper, annotationUID, polyLineUID, canvasPoints, options);\n                    polyLineIdx++;\n                }\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nfunction calculateSurfaceSegmentationIntersections(actorsWorldPointsMap, viewportsInfo) {\n    viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n        const viewport = getRenderingEngine(renderingEngineId)?.getViewport(viewportId);\n        calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport);\n    });\n}\nfunction calculateSurfaceSegmentationIntersectionsForViewport(actorsWorldPointsMap, viewport) {\n    const actorEntries = viewport.getActors();\n    const cacheId = getCacheId(viewport);\n    actorEntries.forEach((actorEntry) => {\n        if (!actorEntry?.clippingFilter) {\n            return;\n        }\n        let actorWorldPointsMap = actorsWorldPointsMap.get(actorEntry.uid);\n        if (!actorWorldPointsMap) {\n            actorWorldPointsMap = new Map();\n            actorsWorldPointsMap.set(actorEntry.uid, actorWorldPointsMap);\n        }\n        if (!actorWorldPointsMap.get(cacheId)) {\n            const polyData = actorEntry.clippingFilter.getOutputData();\n            const worldPointsSet = polyDataUtils.getPolyDataPoints(polyData);\n            if (!worldPointsSet) {\n                return;\n            }\n            const colorArray = actorEntry.actor.getProperty().getColor();\n            const color = colorToString(colorArray);\n            actorWorldPointsMap.set(cacheId, { worldPointsSet, color });\n        }\n    });\n}\nfunction getCacheId(viewport) {\n    const { viewPlaneNormal } = viewport.getCamera();\n    const imageIndex = viewport.getCurrentImageIdIndex();\n    return `${viewport.id}-${pointToString(viewPlaneNormal)}-${imageIndex}`;\n}\nfunction colorToString(colorArray) {\n    function colorComponentToString(component) {\n        let componentString = Math.floor(component * 255).toString(16);\n        if (componentString.length === 1) {\n            componentString = '0' + componentString;\n        }\n        return componentString;\n    }\n    return ('#' +\n        colorComponentToString(colorArray[0]) +\n        colorComponentToString(colorArray[1]) +\n        colorComponentToString(colorArray[2]));\n}\nfunction removeExtraPoints(viewport, worldPointsSet) {\n    return worldPointsSet.map((worldPoints) => {\n        const canvasPoints = worldPoints.map((point) => {\n            const canvasPoint = viewport.worldToCanvas(point);\n            return [Math.floor(canvasPoint[0]), Math.floor(canvasPoint[1])];\n        });\n        let lastPoint;\n        const newWorldPoints = [];\n        let newCanvasPoints = [];\n        for (let i = 0; i < worldPoints.length; i++) {\n            if (lastPoint) {\n                if (distanceToPoint(lastPoint, canvasPoints[i]) > 0) {\n                    newWorldPoints.push(worldPoints[i]);\n                    newCanvasPoints.push(canvasPoints[i]);\n                }\n            }\n            lastPoint = canvasPoints[i];\n        }\n        const firstPoint = newCanvasPoints[0];\n        for (let j = Math.min(30, newCanvasPoints.length); j < newCanvasPoints.length; j++) {\n            if (distanceToPoint(firstPoint, newCanvasPoints[j]) < 0.5) {\n                newCanvasPoints = newCanvasPoints.slice(0, j);\n                return newWorldPoints.slice(0, j);\n            }\n        }\n        return newWorldPoints;\n    });\n}\nSegmentationIntersectionTool.toolName = 'SegmentationIntersection';\nexport default SegmentationIntersectionTool;\n","export function pointToString(point, decimals = 5) {\n    return (parseFloat(point[0]).toFixed(decimals) +\n        ',' +\n        parseFloat(point[1]).toFixed(decimals) +\n        ',' +\n        parseFloat(point[2]).toFixed(decimals) +\n        ',');\n}\n","import { getEnabledElement, StackViewport, VolumeViewport, utilities, getEnabledElementByIds, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../stateManagement/annotation/annotationVisibility';\nimport { drawLine } from '../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { vec3 } from 'gl-matrix';\nimport AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport vtkMath from '@kitware/vtk.js/Common/Core/Math';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nimport { getToolGroup } from '../store/ToolGroupManager';\nclass ReferenceCursors extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            displayThreshold: 5,\n            positionSync: true,\n            disableCursor: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isDrawing = false;\n        this.isHandleOutsideImage = false;\n        this._elementWithCursor = null;\n        this._currentCursorWorldPosition = null;\n        this._currentCanvasPosition = null;\n        this._disableCursorEnabled = false;\n        this.mouseMoveCallback = (evt) => {\n            const { detail } = evt;\n            const { element, currentPoints } = detail;\n            this._currentCursorWorldPosition = currentPoints.world;\n            this._currentCanvasPosition = currentPoints.canvas;\n            this._elementWithCursor = element;\n            const annotation = this.getActiveAnnotation(element);\n            if (annotation === null) {\n                this.createInitialAnnotation(currentPoints.world, element);\n                return false;\n            }\n            this.updateAnnotationPosition(element, annotation);\n            return false;\n        };\n        this.createInitialAnnotation = (worldPos, element) => {\n            const enabledElement = getEnabledElement(element);\n            if (!enabledElement) {\n                throw new Error('No enabled element found');\n            }\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            if (!viewPlaneNormal || !viewUp) {\n                throw new Error('Camera not found');\n            }\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        points: [[...worldPos]],\n                        activeHandleIndex: null,\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                },\n            };\n            const annotations = getAnnotations(this.getToolName(), element);\n            if (annotations.length > 0) {\n                return null;\n            }\n            const annotationId = addAnnotation(annotation, element);\n            if (annotationId === null) {\n                return;\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.onCameraModified = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, previousCamera, camera } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const viewport = enabledElement.viewport;\n            if (element !== this._elementWithCursor) {\n                return;\n            }\n            const oldFocalPoint = previousCamera.focalPoint;\n            const cameraNormal = camera.viewPlaneNormal;\n            const newFocalPoint = camera.focalPoint;\n            const deltaCameraFocalPoint = [0, 0, 0];\n            vtkMath.subtract(newFocalPoint, oldFocalPoint, deltaCameraFocalPoint);\n            if (deltaCameraFocalPoint.reduce((a, b) => a + b, 0) === 0) {\n                return;\n            }\n            const dotProduct = vtkMath.dot(deltaCameraFocalPoint, cameraNormal);\n            if (Math.abs(dotProduct) < 1e-2) {\n                return;\n            }\n            if (!this._currentCanvasPosition) {\n                return;\n            }\n            const newWorldPos = viewport.canvasToWorld(this._currentCanvasPosition);\n            this._currentCursorWorldPosition = newWorldPos;\n            this.updateAnnotationPosition(element, this.getActiveAnnotation(element));\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport, FrameOfReferenceUID } = enabledElement;\n            const isElementWithCursor = this._elementWithCursor === viewport.element;\n            if (this.configuration.positionSync && !isElementWithCursor) {\n                this.updateViewportImage(viewport);\n            }\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points } = handles;\n                if (!annotationUID) {\n                    return renderStatus;\n                }\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidthBase = parseFloat(this.getStyle('lineWidth', styleSpecifier, annotation));\n                const lineWidth = typeof lineWidthBase === 'number' && isElementWithCursor\n                    ? lineWidthBase\n                    : lineWidthBase;\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (points[0].some((e) => isNaN(e))) {\n                    return renderStatus;\n                }\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const crosshairUIDs = {\n                    upper: 'upper',\n                    right: 'right',\n                    lower: 'lower',\n                    left: 'left',\n                };\n                const [x, y] = canvasCoordinates[0];\n                const centerSpace = isElementWithCursor ? 20 : 7;\n                const lineLength = isElementWithCursor ? 5 : 7;\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.upper, [x, y - (centerSpace / 2 + lineLength)], [x, y - centerSpace / 2], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.lower, [x, y + (centerSpace / 2 + lineLength)], [x, y + centerSpace / 2], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.right, [x + (centerSpace / 2 + lineLength), y], [x + centerSpace / 2, y], { color, lineDash, lineWidth });\n                drawLine(svgDrawingHelper, annotationUID, crosshairUIDs.left, [x - (centerSpace / 2 + lineLength), y], [x - centerSpace / 2, y], { color, lineDash, lineWidth });\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n        this._disableCursorEnabled = this.configuration.disableCursor;\n    }\n    onSetToolActive() {\n        this._disableCursorEnabled = this.configuration.disableCursor;\n        if (!this._disableCursorEnabled) {\n            return;\n        }\n        const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n        if (!viewportIds) {\n            return;\n        }\n        const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n        enabledElements.forEach((element) => {\n            if (element) {\n                hideElementCursor(element.viewport.element);\n            }\n        });\n    }\n    onSetToolDisabled() {\n        if (!this._disableCursorEnabled) {\n            return;\n        }\n        const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n        if (!viewportIds) {\n            return;\n        }\n        const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n        enabledElements.forEach((element) => {\n            if (element) {\n                resetElementCursor(element.viewport.element);\n            }\n        });\n    }\n    getActiveAnnotation(element) {\n        const annotations = getAnnotations(this.getToolName(), element);\n        if (!annotations.length) {\n            return null;\n        }\n        const targetAnnotation = annotations[0];\n        return targetAnnotation;\n    }\n    updateAnnotationPosition(element, annotation) {\n        const worldPos = this._currentCursorWorldPosition;\n        if (!worldPos) {\n            return;\n        }\n        if (!annotation.data?.handles?.points) {\n            return;\n        }\n        annotation.data.handles.points = [[...worldPos]];\n        annotation.invalidated = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!(annotations instanceof Array) || annotations.length === 0) {\n            return [];\n        }\n        const annotation = annotations[0];\n        const viewport = getEnabledElement(element)?.viewport;\n        if (!viewport) {\n            return [];\n        }\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, focalPoint } = camera;\n        if (!viewPlaneNormal || !focalPoint) {\n            return [];\n        }\n        const points = annotation.data?.handles?.points;\n        if (!(points instanceof Array) || points.length !== 1) {\n            return [];\n        }\n        const worldPos = points[0];\n        const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n        const distance = utilities.planar.planeDistanceToPoint(plane, worldPos);\n        return distance < this.configuration.displayThreshold ? [annotation] : [];\n    }\n    updateViewportImage(viewport) {\n        const currentMousePosition = this._currentCursorWorldPosition;\n        if (!currentMousePosition || currentMousePosition.some((e) => isNaN(e))) {\n            return;\n        }\n        if (viewport instanceof StackViewport) {\n            const closestIndex = utilities.getClosestStackImageIndexForPoint(currentMousePosition, viewport);\n            if (closestIndex === null) {\n                return;\n            }\n            if (closestIndex !== viewport.getCurrentImageIdIndex()) {\n                viewport.setImageIdIndex(closestIndex);\n            }\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const { focalPoint, viewPlaneNormal } = viewport.getCamera();\n            if (!focalPoint || !viewPlaneNormal) {\n                return;\n            }\n            const plane = utilities.planar.planeEquation(viewPlaneNormal, focalPoint);\n            const currentDistance = utilities.planar.planeDistanceToPoint(plane, currentMousePosition, true);\n            if (Math.abs(currentDistance) < 0.5) {\n                return;\n            }\n            const normalizedViewPlane = vec3.normalize(vec3.create(), vec3.fromValues(...viewPlaneNormal));\n            const scaledPlaneNormal = vec3.scale(vec3.create(), normalizedViewPlane, currentDistance);\n            const newFocalPoint = vec3.add(vec3.create(), vec3.fromValues(...focalPoint), scaledPlaneNormal);\n            const isInBounds = true;\n            if (isInBounds) {\n                viewport.setCamera({ focalPoint: newFocalPoint });\n                const renderingEngine = viewport.getRenderingEngine();\n                if (renderingEngine) {\n                    renderingEngine.renderViewport(viewport.id);\n                }\n            }\n        }\n    }\n}\nReferenceCursors.toolName = 'ReferenceCursors';\nexport default ReferenceCursors;\n","import AnnotationDisplayTool from './base/AnnotationDisplayTool';\nimport { vec3 } from 'gl-matrix';\nimport { getEnabledElementByIds, getRenderingEngines, utilities as csUtils, } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, } from '../stateManagement/annotation/annotationState';\nimport { drawLine as drawLineSvg, drawTextBox as drawTextBoxSvg, } from '../drawingSvg';\nimport { getToolGroup } from '../store/ToolGroupManager';\nconst viewportsWithAnnotations = [];\nclass ScaleOverlayTool extends AnnotationDisplayTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            viewportId: '',\n            scaleLocation: 'bottom',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.editData = null;\n        this._init = () => {\n            const renderingEngines = getRenderingEngines();\n            const renderingEngine = renderingEngines[0];\n            if (!renderingEngine) {\n                return;\n            }\n            const viewportIds = getToolGroup(this.toolGroupId).viewportsInfo;\n            if (!viewportIds) {\n                return;\n            }\n            const enabledElements = viewportIds.map((e) => getEnabledElementByIds(e.viewportId, e.renderingEngineId));\n            let { viewport } = enabledElements[0];\n            const { FrameOfReferenceUID } = enabledElements[0];\n            if (this.configuration.viewportId) {\n                enabledElements.forEach((element) => {\n                    if (element.viewport.id == this.configuration.viewportId) {\n                        viewport = element.viewport;\n                    }\n                });\n            }\n            if (!viewport) {\n                return;\n            }\n            const { viewUp, viewPlaneNormal } = viewport.getCamera();\n            const viewportCanvasCornersInWorld = csUtils.getViewportImageCornersInWorld(viewport);\n            let annotation = this.editData?.annotation;\n            const annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (annotations.length) {\n                annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];\n            }\n            enabledElements.forEach((element) => {\n                const { viewport } = element;\n                if (!viewportsWithAnnotations.includes(viewport.id)) {\n                    const newAnnotation = {\n                        metadata: {\n                            toolName: this.getToolName(),\n                            viewPlaneNormal: [...viewPlaneNormal],\n                            viewUp: [...viewUp],\n                            FrameOfReferenceUID,\n                            referencedImageId: null,\n                        },\n                        data: {\n                            handles: {\n                                points: csUtils.getViewportImageCornersInWorld(viewport),\n                            },\n                            viewportId: viewport.id,\n                        },\n                    };\n                    viewportsWithAnnotations.push(viewport.id);\n                    addAnnotation(newAnnotation, viewport.element);\n                    annotation = newAnnotation;\n                }\n            });\n            if (this.editData?.annotation &&\n                this.editData.annotation.data.viewportId == viewport.id) {\n                this.editData.annotation.data.handles.points =\n                    viewportCanvasCornersInWorld;\n                this.editData.annotation.data.viewportId = viewport.id;\n            }\n            this.editData = {\n                viewport,\n                renderingEngine,\n                annotation,\n            };\n        };\n        this.onSetToolEnabled = () => {\n            this._init();\n        };\n        this.onCameraModified = (evt) => {\n            this.configuration.viewportId = evt.detail.viewportId;\n            this._init();\n        };\n        this.computeScaleSize = (worldWidthViewport, worldHeightViewport, location) => {\n            const scaleSizes = [\n                16000, 8000, 4000, 2000, 1000, 500, 250, 100, 50, 25, 10, 5, 2,\n            ];\n            let currentScaleSize;\n            if (location == 'top' || location == 'bottom') {\n                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldWidthViewport * 0.6 &&\n                    scaleSize > worldWidthViewport * 0.2);\n            }\n            else {\n                currentScaleSize = scaleSizes.filter((scaleSize) => scaleSize < worldHeightViewport * 0.6 &&\n                    scaleSize > worldHeightViewport * 0.2);\n            }\n            return currentScaleSize[0];\n        };\n        this.computeEndScaleTicks = (canvasCoordinates, location) => {\n            const locationTickOffset = {\n                bottom: [\n                    [0, -10],\n                    [0, -10],\n                ],\n                top: [\n                    [0, 10],\n                    [0, 10],\n                ],\n                left: [\n                    [0, 0],\n                    [10, 0],\n                ],\n                right: [\n                    [0, 0],\n                    [-10, 0],\n                ],\n            };\n            const endTick1 = [\n                [\n                    canvasCoordinates[1][0] + locationTickOffset[location][0][0],\n                    canvasCoordinates[1][1] + locationTickOffset[location][0][0],\n                ],\n                [\n                    canvasCoordinates[1][0] + locationTickOffset[location][1][0],\n                    canvasCoordinates[1][1] + locationTickOffset[location][1][1],\n                ],\n            ];\n            const endTick2 = [\n                [\n                    canvasCoordinates[0][0] + locationTickOffset[location][0][0],\n                    canvasCoordinates[0][1] + locationTickOffset[location][0][0],\n                ],\n                [\n                    canvasCoordinates[0][0] + locationTickOffset[location][1][0],\n                    canvasCoordinates[0][1] + locationTickOffset[location][1][1],\n                ],\n            ];\n            return {\n                endTick1: endTick1,\n                endTick2: endTick2,\n            };\n        };\n        this.computeInnerScaleTicks = (scaleSize, location, annotationUID, leftTick, rightTick) => {\n            let canvasScaleSize;\n            if (location == 'bottom' || location == 'top') {\n                canvasScaleSize = rightTick[0][0] - leftTick[0][0];\n            }\n            else if (location == 'left' || location == 'right') {\n                canvasScaleSize = rightTick[0][1] - leftTick[0][1];\n            }\n            const tickIds = [];\n            const tickUIDs = [];\n            const tickCoordinates = [];\n            let numberSmallTicks = scaleSize;\n            if (scaleSize >= 50) {\n                numberSmallTicks = scaleSize / 10;\n            }\n            const tickSpacing = canvasScaleSize / numberSmallTicks;\n            for (let i = 0; i < numberSmallTicks - 1; i++) {\n                const locationOffset = {\n                    bottom: [\n                        [tickSpacing * (i + 1), 0],\n                        [tickSpacing * (i + 1), 5],\n                    ],\n                    top: [\n                        [tickSpacing * (i + 1), 0],\n                        [tickSpacing * (i + 1), -5],\n                    ],\n                    left: [\n                        [0, tickSpacing * (i + 1)],\n                        [-5, tickSpacing * (i + 1)],\n                    ],\n                    right: [\n                        [0, tickSpacing * (i + 1)],\n                        [5, tickSpacing * (i + 1)],\n                    ],\n                };\n                tickIds.push(`${annotationUID}-tick${i}`);\n                tickUIDs.push(`tick${i}`);\n                if ((i + 1) % 5 == 0) {\n                    tickCoordinates.push([\n                        [\n                            leftTick[0][0] + locationOffset[location][0][0],\n                            leftTick[0][1] + locationOffset[location][0][1],\n                        ],\n                        [\n                            leftTick[1][0] + locationOffset[location][0][0],\n                            leftTick[1][1] + locationOffset[location][0][1],\n                        ],\n                    ]);\n                }\n                else {\n                    tickCoordinates.push([\n                        [\n                            leftTick[0][0] + locationOffset[location][0][0],\n                            leftTick[0][1] + locationOffset[location][0][1],\n                        ],\n                        [\n                            leftTick[1][0] + locationOffset[location][1][0],\n                            leftTick[1][1] + locationOffset[location][1][1],\n                        ],\n                    ]);\n                }\n            }\n            return { tickIds, tickUIDs, tickCoordinates };\n        };\n        this.computeWorldScaleCoordinates = (scaleSize, location, pointSet) => {\n            let worldCoordinates;\n            let topBottomVec = vec3.subtract(vec3.create(), pointSet[0], pointSet[1]);\n            topBottomVec = vec3.normalize(vec3.create(), topBottomVec);\n            let topRightVec = vec3.subtract(vec3.create(), pointSet[2], pointSet[0]);\n            topRightVec = vec3.normalize(vec3.create(), topRightVec);\n            const midpointLocation = {\n                bottom: [pointSet[1], pointSet[2]],\n                top: [pointSet[0], pointSet[3]],\n                right: [pointSet[2], pointSet[3]],\n                left: [pointSet[0], pointSet[1]],\n            };\n            const midpoint = vec3\n                .add(vec3.create(), midpointLocation[location][0], midpointLocation[location][0])\n                .map((i) => i / 2);\n            const offset = scaleSize /\n                2 /\n                Math.sqrt(Math.pow(topBottomVec[0], 2) +\n                    Math.pow(topBottomVec[1], 2) +\n                    Math.pow(topBottomVec[2], 2));\n            if (location == 'top' || location == 'bottom') {\n                worldCoordinates = [\n                    vec3.subtract(vec3.create(), midpoint, topRightVec.map((i) => i * offset)),\n                    vec3.add(vec3.create(), midpoint, topRightVec.map((i) => i * offset)),\n                ];\n            }\n            else if (location == 'left' || location == 'right') {\n                worldCoordinates = [\n                    vec3.add(vec3.create(), midpoint, topBottomVec.map((i) => i * offset)),\n                    vec3.subtract(vec3.create(), midpoint, topBottomVec.map((i) => i * offset)),\n                ];\n            }\n            return worldCoordinates;\n        };\n        this.computeCanvasScaleCoordinates = (canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location) => {\n            let scaleCanvasCoordinates;\n            if (location == 'top' || location == 'bottom') {\n                const worldDistanceOnCanvas = canvasCoordinates[0][0] - canvasCoordinates[1][0];\n                scaleCanvasCoordinates = [\n                    [canvasSize.width / 2 - worldDistanceOnCanvas / 2, vscaleBounds.height],\n                    [canvasSize.width / 2 + worldDistanceOnCanvas / 2, vscaleBounds.height],\n                ];\n            }\n            else if (location == 'left' || location == 'right') {\n                const worldDistanceOnCanvas = canvasCoordinates[0][1] - canvasCoordinates[1][1];\n                scaleCanvasCoordinates = [\n                    [hscaleBounds.width, canvasSize.height / 2 - worldDistanceOnCanvas / 2],\n                    [hscaleBounds.width, canvasSize.height / 2 + worldDistanceOnCanvas / 2],\n                ];\n            }\n            return scaleCanvasCoordinates;\n        };\n        this.computeScaleBounds = (canvasSize, horizontalReduction, verticalReduction, location) => {\n            const hReduction = horizontalReduction * Math.min(1000, canvasSize.width);\n            const vReduction = verticalReduction * Math.min(1000, canvasSize.height);\n            const locationBounds = {\n                bottom: [-vReduction, -hReduction],\n                top: [vReduction, hReduction],\n                left: [vReduction, hReduction],\n                right: [-vReduction, -hReduction],\n            };\n            const canvasBounds = {\n                bottom: [canvasSize.height, canvasSize.width],\n                top: [0, canvasSize.width],\n                left: [canvasSize.height, 0],\n                right: [canvasSize.height, canvasSize.width],\n            };\n            return {\n                height: canvasBounds[location][0] + locationBounds[location][0],\n                width: canvasBounds[location][1] + locationBounds[location][1],\n            };\n        };\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this.editData || !this.editData.viewport) {\n            return;\n        }\n        const location = this.configuration.scaleLocation;\n        const { viewport } = enabledElement;\n        const annotations = getAnnotations(this.getToolName(), viewport.element);\n        const annotation = annotations.filter((thisAnnotation) => thisAnnotation.data.viewportId == viewport.id)[0];\n        const canvas = enabledElement.viewport.canvas;\n        const renderStatus = false;\n        if (!viewport) {\n            return renderStatus;\n        }\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        const canvasSize = {\n            width: canvas.width / window.devicePixelRatio || 1,\n            height: canvas.height / window.devicePixelRatio || 1,\n        };\n        const topLeft = annotation.data.handles.points[0];\n        const topRight = annotation.data.handles.points[1];\n        const bottomLeft = annotation.data.handles.points[2];\n        const bottomRight = annotation.data.handles.points[3];\n        const pointSet1 = [topLeft, bottomLeft, topRight, bottomRight];\n        const worldWidthViewport = vec3.distance(bottomLeft, bottomRight);\n        const worldHeightViewport = vec3.distance(topLeft, bottomLeft);\n        const hscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);\n        const vscaleBounds = this.computeScaleBounds(canvasSize, 0.05, 0.05, location);\n        const scaleSize = this.computeScaleSize(worldWidthViewport, worldHeightViewport, location);\n        const canvasCoordinates = this.computeWorldScaleCoordinates(scaleSize, location, pointSet1).map((world) => viewport.worldToCanvas(world));\n        const scaleCanvasCoordinates = this.computeCanvasScaleCoordinates(canvasSize, canvasCoordinates, vscaleBounds, hscaleBounds, location);\n        const scaleTicks = this.computeEndScaleTicks(scaleCanvasCoordinates, location);\n        const { annotationUID } = annotation;\n        styleSpecifier.annotationUID = annotationUID;\n        const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n        const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n        const color = this.getStyle('color', styleSpecifier, annotation);\n        const shadow = this.getStyle('shadow', styleSpecifier, annotation);\n        const scaleId = `${annotationUID}-scaleline`;\n        const scaleLineUID = '1';\n        drawLineSvg(svgDrawingHelper, annotationUID, scaleLineUID, scaleCanvasCoordinates[0], scaleCanvasCoordinates[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, scaleId);\n        const leftTickId = `${annotationUID}-left`;\n        const leftTickUID = '2';\n        drawLineSvg(svgDrawingHelper, annotationUID, leftTickUID, scaleTicks.endTick1[0], scaleTicks.endTick1[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, leftTickId);\n        const rightTickId = `${annotationUID}-right`;\n        const rightTickUID = '3';\n        drawLineSvg(svgDrawingHelper, annotationUID, rightTickUID, scaleTicks.endTick2[0], scaleTicks.endTick2[1], {\n            color,\n            width: lineWidth,\n            lineDash,\n            shadow,\n        }, rightTickId);\n        const locationTextOffest = {\n            bottom: [-10, -42],\n            top: [-12, -35],\n            left: [-40, -20],\n            right: [-50, -20],\n        };\n        const textCanvasCoordinates = [\n            scaleCanvasCoordinates[0][0] + locationTextOffest[location][0],\n            scaleCanvasCoordinates[0][1] + locationTextOffest[location][1],\n        ];\n        const textBoxLines = this._getTextLines(scaleSize);\n        const { tickIds, tickUIDs, tickCoordinates } = this.computeInnerScaleTicks(scaleSize, location, annotationUID, scaleTicks.endTick1, scaleTicks.endTick2);\n        for (let i = 0; i < tickUIDs.length; i++) {\n            drawLineSvg(svgDrawingHelper, annotationUID, tickUIDs[i], tickCoordinates[i][0], tickCoordinates[i][1], {\n                color,\n                width: lineWidth,\n                lineDash,\n                shadow,\n            }, tickIds[i]);\n        }\n        const textUID = 'text0';\n        drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textBoxLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], {\n            fontFamily: 'Helvetica Neue, Helvetica, Arial, sans-serif',\n            fontSize: '14px',\n            lineDash: '2,3',\n            lineWidth: '1',\n            shadow: true,\n            color: color,\n        });\n        return renderStatus;\n    }\n    _getTextLines(scaleSize) {\n        let scaleSizeDisplayValue;\n        let scaleSizeUnits;\n        if (scaleSize >= 50) {\n            scaleSizeDisplayValue = scaleSize / 10;\n            scaleSizeUnits = ' cm';\n        }\n        else {\n            scaleSizeDisplayValue = scaleSize;\n            scaleSizeUnits = ' mm';\n        }\n        const textLines = [scaleSizeDisplayValue.toString().concat(scaleSizeUnits)];\n        return textLines;\n    }\n}\nScaleOverlayTool.toolName = 'ScaleOverlay';\nexport default ScaleOverlayTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from './base';\nimport { getAnnotations } from '../stateManagement';\nimport { point } from '../utilities/math';\nimport { Events, ToolModes, AnnotationStyleStates, ChangeTypes, } from '../enums';\nimport { triggerAnnotationRenderForViewportIds } from '../utilities/triggerAnnotationRenderForViewportIds';\nimport { hideElementCursor, resetElementCursor, } from '../cursors/elementCursor';\nimport { getStyleProperty } from '../stateManagement/annotation/config/helpers';\nimport { triggerAnnotationModified } from '../stateManagement/annotation/helpers/state';\nimport CircleSculptCursor from './SculptorTool/CircleSculptCursor';\nimport { distancePointToContour } from './distancePointToContour';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass SculptorTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            minSpacing: 1,\n            referencedToolNames: [\n                'PlanarFreehandROI',\n                'PlanarFreehandContourSegmentationTool',\n            ],\n            toolShape: 'circle',\n            referencedToolName: 'PlanarFreehandROI',\n            updateCursorSize: 'dynamic',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.registeredShapes = new Map();\n        this.isActive = false;\n        this.commonData = {\n            activeAnnotationUID: null,\n            viewportIdsToRender: [],\n            isEditingOpenContour: false,\n            canvasLocation: undefined,\n        };\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const element = eventData.element;\n            this.configureToolSize(evt);\n            this.selectFreehandTool(eventData);\n            if (this.commonData.activeAnnotationUID === null) {\n                return;\n            }\n            this.isActive = true;\n            hideElementCursor(element);\n            this.activateModify(element);\n            return true;\n        };\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode === ToolModes.Active) {\n                this.configureToolSize(evt);\n                this.updateCursor(evt);\n            }\n            else {\n                this.commonData.canvasLocation = undefined;\n            }\n        };\n        this.endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const config = this.configuration;\n            const enabledElement = getEnabledElement(element);\n            this.isActive = false;\n            this.deactivateModify(element);\n            resetElementCursor(element);\n            const { renderingEngineId, viewportId } = enabledElement;\n            const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n            const toolInstance = toolGroup.getToolInstance(config.referencedToolName);\n            const annotations = this.filterSculptableAnnotationsForElement(element);\n            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n            if (toolInstance.configuration.calculateStats) {\n                activeAnnotation.invalidated = true;\n            }\n            triggerAnnotationModified(activeAnnotation, element, ChangeTypes.HandlesUpdated);\n        };\n        this.dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const element = eventData.element;\n            this.updateCursor(evt);\n            const annotations = this.filterSculptableAnnotationsForElement(element);\n            const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n            if (!annotations?.length || !this.isActive) {\n                return;\n            }\n            const points = activeAnnotation.data.contour.polyline;\n            this.sculpt(eventData, points);\n        };\n        this.registerShapes(CircleSculptCursor.shapeName, CircleSculptCursor);\n        this.setToolShape(this.configuration.toolShape);\n    }\n    registerShapes(shapeName, shapeClass) {\n        const shape = new shapeClass();\n        this.registeredShapes.set(shapeName, shape);\n    }\n    sculpt(eventData, points) {\n        const config = this.configuration;\n        const element = eventData.element;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        this.sculptData = {\n            mousePoint: eventData.currentPoints.world,\n            mouseCanvasPoint: eventData.currentPoints.canvas,\n            deltaWorld: eventData.deltaPoints.world,\n            points,\n            maxSpacing: cursorShape.getMaxSpacing(config.minSpacing),\n            element: element,\n        };\n        const pushedHandles = cursorShape.pushHandles(viewport, this.sculptData);\n        if (pushedHandles.first !== undefined) {\n            this.insertNewHandles(pushedHandles);\n        }\n    }\n    interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing) {\n        const { element } = this.sculptData;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const nextHandleIndex = contourIndex(i + 1, points.length);\n        const currentCanvasPoint = viewport.worldToCanvas(points[i]);\n        const nextCanvasPoint = viewport.worldToCanvas(points[nextHandleIndex]);\n        const distanceToNextHandle = point.distanceToPoint(currentCanvasPoint, nextCanvasPoint);\n        if (distanceToNextHandle > maxSpacing) {\n            indicesToInsertAfter.push(i);\n        }\n    }\n    updateCursor(evt) {\n        const eventData = evt.detail;\n        const element = eventData.element;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine, viewport } = enabledElement;\n        this.commonData.viewportIdsToRender = [viewport.id];\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const activeAnnotation = annotations.find((annotation) => annotation.annotationUID === this.commonData.activeAnnotationUID);\n        this.commonData.canvasLocation = eventData.currentPoints.canvas;\n        if (this.isActive) {\n            activeAnnotation.highlighted = true;\n        }\n        else {\n            const cursorShape = this.registeredShapes.get(this.selectedShape);\n            const canvasCoords = eventData.currentPoints.canvas;\n            if (this.configuration.updateCursorSize === 'dynamic') {\n                cursorShape.updateToolSize(canvasCoords, viewport, activeAnnotation);\n            }\n        }\n        triggerAnnotationRenderForViewportIds(this.commonData.viewportIdsToRender);\n    }\n    filterSculptableAnnotationsForElement(element) {\n        const config = this.configuration;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngineId, viewportId } = enabledElement;\n        const sculptableAnnotations = [];\n        const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n        const toolInstance = toolGroup.getToolInstance(config.referencedToolName);\n        config.referencedToolNames.forEach((referencedToolName) => {\n            const annotations = getAnnotations(referencedToolName, element);\n            if (annotations) {\n                sculptableAnnotations.push(...annotations);\n            }\n        });\n        return toolInstance.filterInteractableAnnotationsForElement(element, sculptableAnnotations);\n    }\n    configureToolSize(evt) {\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        cursorShape.configureToolSize(evt);\n    }\n    insertNewHandles(pushedHandles) {\n        const indicesToInsertAfter = this.findNewHandleIndices(pushedHandles);\n        let newIndexModifier = 0;\n        for (let i = 0; i < indicesToInsertAfter?.length; i++) {\n            const insertIndex = indicesToInsertAfter[i] + 1 + newIndexModifier;\n            this.insertHandleRadially(insertIndex);\n            newIndexModifier++;\n        }\n    }\n    findNewHandleIndices(pushedHandles) {\n        const { points, maxSpacing } = this.sculptData;\n        const indicesToInsertAfter = [];\n        for (let i = pushedHandles.first; i <= pushedHandles.last; i++) {\n            this.interpolatePointsWithinMaxSpacing(i, points, indicesToInsertAfter, maxSpacing);\n        }\n        return indicesToInsertAfter;\n    }\n    insertHandleRadially(insertIndex) {\n        const { points } = this.sculptData;\n        if (insertIndex > points.length - 1 &&\n            this.commonData.isEditingOpenContour) {\n            return;\n        }\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        const previousIndex = insertIndex - 1;\n        const nextIndex = contourIndex(insertIndex, points.length);\n        const insertPosition = cursorShape.getInsertPosition(previousIndex, nextIndex, this.sculptData);\n        const handleData = insertPosition;\n        points.splice(insertIndex, 0, handleData);\n    }\n    selectFreehandTool(eventData) {\n        const closestAnnotationUID = this.getClosestFreehandToolOnElement(eventData);\n        if (closestAnnotationUID === undefined) {\n            return;\n        }\n        this.commonData.activeAnnotationUID = closestAnnotationUID;\n    }\n    getClosestFreehandToolOnElement(eventData) {\n        const { element } = eventData;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const config = this.configuration;\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const canvasPoints = eventData.currentPoints.canvas;\n        const closest = {\n            distance: Infinity,\n            toolIndex: undefined,\n            annotationUID: undefined,\n        };\n        for (let i = 0; i < annotations?.length; i++) {\n            if (annotations[i].isLocked || !annotations[i].isVisible) {\n                continue;\n            }\n            const distanceFromTool = distancePointToContour(viewport, annotations[i], canvasPoints);\n            if (distanceFromTool === -1) {\n                continue;\n            }\n            if (distanceFromTool < closest.distance) {\n                closest.distance = distanceFromTool;\n                closest.toolIndex = i;\n                closest.annotationUID = annotations[i].annotationUID;\n            }\n        }\n        this.commonData.isEditingOpenContour =\n            !annotations[closest.toolIndex].data.contour.closed;\n        config.referencedToolName =\n            annotations[closest.toolIndex].metadata.toolName;\n        return closest.annotationUID;\n    }\n    activateModify(element) {\n        element.addEventListener(Events.MOUSE_UP, this.endCallback);\n        element.addEventListener(Events.MOUSE_CLICK, this.endCallback);\n        element.addEventListener(Events.MOUSE_DRAG, this.dragCallback);\n        element.addEventListener(Events.TOUCH_TAP, this.endCallback);\n        element.addEventListener(Events.TOUCH_END, this.endCallback);\n        element.addEventListener(Events.TOUCH_DRAG, this.dragCallback);\n    }\n    deactivateModify(element) {\n        element.removeEventListener(Events.MOUSE_UP, this.endCallback);\n        element.removeEventListener(Events.MOUSE_CLICK, this.endCallback);\n        element.removeEventListener(Events.MOUSE_DRAG, this.dragCallback);\n        element.removeEventListener(Events.TOUCH_TAP, this.endCallback);\n        element.removeEventListener(Events.TOUCH_END, this.endCallback);\n        element.removeEventListener(Events.TOUCH_DRAG, this.dragCallback);\n    }\n    setToolShape(toolShape) {\n        this.selectedShape =\n            this.registeredShapes.get(toolShape) ?? CircleSculptCursor.shapeName;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const viewportIdsToRender = this.commonData.viewportIdsToRender;\n        if (!this.commonData.canvasLocation ||\n            this.mode !== ToolModes.Active ||\n            !viewportIdsToRender.includes(viewport.id)) {\n            return;\n        }\n        const annotations = this.filterSculptableAnnotationsForElement(element);\n        if (!annotations?.length) {\n            return;\n        }\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        let color = getStyleProperty('color', styleSpecifier, AnnotationStyleStates.Default, this.mode);\n        if (this.isActive) {\n            color = getStyleProperty('color', styleSpecifier, AnnotationStyleStates.Highlighted, this.mode);\n        }\n        const cursorShape = this.registeredShapes.get(this.selectedShape);\n        cursorShape.renderShape(svgDrawingHelper, this.commonData.canvasLocation, {\n            color,\n        });\n    }\n}\nexport const contourIndex = (i, length) => {\n    return (i + length) % length;\n};\nSculptorTool.toolName = 'SculptorTool';\nexport default SculptorTool;\n","import { BaseTool } from './base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { mat4, vec3 } from 'gl-matrix';\nconst DIRECTIONS = {\n    X: [1, 0, 0],\n    Y: [0, 1, 0],\n    Z: [0, 0, 1],\n    CUSTOM: [],\n};\nclass VolumeRotateTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            direction: DIRECTIONS.Z,\n            rotateIncrementDegrees: 30,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n    }\n    mouseWheelCallback(evt) {\n        const { element, wheel } = evt.detail;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { direction, rotateIncrementDegrees } = this.configuration;\n        const camera = viewport.getCamera();\n        const { viewUp, position, focalPoint } = camera;\n        const { direction: deltaY } = wheel;\n        const [cx, cy, cz] = focalPoint;\n        const [ax, ay, az] = direction;\n        const angle = (deltaY * (rotateIncrementDegrees * Math.PI)) / 180;\n        const newPosition = [0, 0, 0];\n        const newFocalPoint = [0, 0, 0];\n        const newViewUp = [0, 0, 0];\n        const transform = mat4.identity(new Float32Array(16));\n        mat4.translate(transform, transform, [cx, cy, cz]);\n        mat4.rotate(transform, transform, angle, [ax, ay, az]);\n        mat4.translate(transform, transform, [-cx, -cy, -cz]);\n        vec3.transformMat4(newPosition, position, transform);\n        vec3.transformMat4(newFocalPoint, focalPoint, transform);\n        mat4.identity(transform);\n        mat4.rotate(transform, transform, angle, [ax, ay, az]);\n        vec3.transformMat4(newViewUp, viewUp, transform);\n        viewport.setCamera({\n            position: newPosition,\n            viewUp: newViewUp,\n            focalPoint: newFocalPoint,\n        });\n        viewport.render();\n    }\n}\nVolumeRotateTool.toolName = 'VolumeRotateMouseWheel';\nexport default VolumeRotateTool;\n","import { vec2 } from 'gl-matrix';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { drawTextBox as drawTextBoxSvg } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nclass LabelTool extends AnnotationTool {\n    static { this.toolName = 'Label'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            getTextCallback,\n            changeTextCallback,\n            preventHandleOutsideImage: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { annotationUID } = annotation;\n            const point = annotation.data.handles.points[0];\n            const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n            const dist = vec2.distance(canvasCoords, annotationCanvasCoordinate);\n            if (dist < proximity) {\n                return true;\n            }\n            const svgLayer = element.querySelector('svg');\n            if (!svgLayer) {\n                return false;\n            }\n            const textGroup = svgLayer.querySelector(`g[data-annotation-uid=\"${annotationUID}\"]`);\n            if (!textGroup) {\n                return false;\n            }\n            const textGroupElement = textGroup;\n            const bbox = textGroupElement.getBBox();\n            const transform = textGroupElement.getAttribute('transform');\n            let translateX = 0;\n            let translateY = 0;\n            if (transform) {\n                const matches = transform.match(/translate\\(([-\\d.]+)\\s+([-\\d.]+)\\)/);\n                if (matches) {\n                    translateX = parseFloat(matches[1]);\n                    translateY = parseFloat(matches[2]);\n                }\n            }\n            const x = bbox.x + translateX;\n            const y = bbox.y + translateY;\n            const isNear = canvasCoords[0] >= x &&\n                canvasCoords[0] <= x + bbox.width &&\n                canvasCoords[1] >= y &&\n                canvasCoords[1] <= y + bbox.height;\n            return isNear;\n        };\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n                offset: [0, 0, 0],\n            };\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.configuration.getTextCallback((label) => {\n                if (!label) {\n                    removeAnnotation(annotation.annotationUID);\n                    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                    this.isDrawing = false;\n                    return;\n                }\n                resetElementCursor(element);\n                annotation.data.label = label;\n                triggerAnnotationCompleted(annotation);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            });\n            this.createMemo(element, annotation, { newAnnotation: true });\n            return annotation;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            let offset = [0, 0, 0];\n            if (currentPoints && currentPoints.world) {\n                const initialWorldPos = currentPoints.world;\n                const anchorWorldPos = annotation.data.handles.points[0];\n                offset = [\n                    anchorWorldPos[0] - initialWorldPos[0],\n                    anchorWorldPos[1] - initialWorldPos[1],\n                    anchorWorldPos[2] - initialWorldPos[2],\n                ];\n            }\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                offset,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            this._deactivateDraw(element);\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            if (newAnnotation) {\n                this.createMemo(element, annotation, { newAnnotation });\n            }\n            this.editData = null;\n            this.isDrawing = false;\n            this.doneEditMemo();\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { annotation, viewportIdsToRender, offset } = this.editData;\n            if (offset) {\n                annotation.data.handles.points[0] = [\n                    worldPos[0] + offset[0],\n                    worldPos[1] + offset[1],\n                    worldPos[2] + offset[2],\n                ];\n            }\n            else {\n                annotation.data.handles.points[0] = [...worldPos];\n            }\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.LabelChange);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const point = data.handles.points[0];\n                styleSpecifier.annotationUID = annotationUID;\n                const canvasCoordinates = viewport.worldToCanvas(point);\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!data.label) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                const textBoxUID = '1';\n                drawTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, [data.label], canvasCoordinates, {\n                    ...options,\n                    padding: 0,\n                });\n            }\n            return renderStatus;\n        };\n    }\n    static { this.hydrate = (viewportId, position, label, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const { viewPlaneNormal, viewUp } = viewport.getCamera();\n        const instance = new this();\n        const referencedImageId = instance.getReferencedImageId(viewport, position, viewPlaneNormal, viewUp);\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                label,\n                handles: {\n                    points: [position],\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...options,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(_evt, _annotation, _handle, _interactionType) { }\n    _doneChangingTextCallback(element, annotation, updatedLabel) {\n        annotation.data.label = updatedLabel;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        triggerAnnotationModified(annotation, element);\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nLabelTool.toolName = 'Label';\nexport default LabelTool;\n","import { Events, ChangeTypes } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, utilities, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass LengthTool extends AnnotationTool {\n    static { this.toolName = 'Length'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            actions: {\n                undo: {\n                    method: 'undo',\n                    bindings: [{ key: 'z' }],\n                },\n                redo: {\n                    method: 'redo',\n                    bindings: [{ key: 'y' }],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const dataId = `${annotationUID}-line`;\n                const lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(LengthTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateLength(pos1, pos2) {\n        const dx = pos1[0] - pos2[0];\n        const dy = pos1[1] - pos2[1];\n        const dz = pos1[2] - pos2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData, dimensions } = image;\n            const index1 = transformWorldToIndex(imageData, worldPos1);\n            const index2 = transformWorldToIndex(imageData, worldPos2);\n            const handles = [index1, index2];\n            const { scale, unit } = getCalibratedLengthUnitsAndScale(image, handles);\n            const length = this._calculateLength(worldPos1, worldPos2) / scale;\n            if (this._isInsideVolume(index1, index2, dimensions)) {\n                this.isHandleOutsideImage = false;\n            }\n            else {\n                this.isHandleOutsideImage = true;\n            }\n            cachedStats[targetId] = {\n                length,\n                unit,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { length, unit } = cachedVolumeStats;\n    if (length === undefined || length === null || isNaN(length)) {\n        return;\n    }\n    const textLines = [`${csUtils.roundNumber(length)} ${unit}`];\n    return textLines;\n}\nexport default LengthTool;\n","import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawHeight as drawHeightSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass HeightTool extends AnnotationTool {\n    static { this.toolName = 'Height'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const enabledElement = getEnabledElement(element);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                let activeHandleCanvasCoords;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const heightUID = '0';\n                drawHeightSvg(svgDrawingHelper, annotationUID, heightUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash: lineDash,\n                });\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateHeight(pos1, pos2) {\n        const dx = pos2[0] - pos1[0];\n        const dy = pos2[1] - pos1[1];\n        const dz = pos2[2] - pos1[2];\n        if (dx == 0) {\n            if (dy != 0) {\n                return Math.abs(dz);\n            }\n            else {\n                return 0;\n            }\n        }\n        else if (dy == 0) {\n            return Math.abs(dz);\n        }\n        else if (dz == 0) {\n            return Math.abs(dy);\n        }\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData, dimensions } = image;\n            const index1 = transformWorldToIndex(imageData, worldPos1);\n            const index2 = transformWorldToIndex(imageData, worldPos2);\n            const handles = [index1, index2];\n            const { scale, unit } = getCalibratedLengthUnitsAndScale(image, handles);\n            const height = this._calculateHeight(worldPos1, worldPos2) / scale;\n            const outside = this._isInsideVolume(index1, index2, dimensions);\n            this.isHandleOutsideImage = outside;\n            cachedStats[targetId] = {\n                height,\n                unit,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { height, unit } = cachedVolumeStats;\n    if (height === undefined || height === null || isNaN(height)) {\n        return;\n    }\n    const textLines = [`${csUtils.roundNumber(height)} ${unit}`];\n    return textLines;\n}\nexport default HeightTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nimport { drawHandles as drawHandlesSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nconst { transformWorldToIndex } = csUtils;\nclass ProbeTool extends AnnotationTool {\n    static { this.toolName = 'Probe'; }\n    static { this.probeDefaults = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            handleRadius: '6',\n            textCanvasOffset: {\n                x: 6,\n                y: -6,\n            },\n        },\n    }; }\n    constructor(toolProps = {}, defaultToolProps) {\n        super(toolProps, AnnotationTool.mergeDefaultProps(ProbeTool.probeDefaults, defaultToolProps));\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: { points: [[...worldPos]] },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { viewportId, renderingEngine } = getEnabledElement(element);\n            this.eventDispatchDetail = {\n                viewportId,\n                renderingEngineId: renderingEngine.id,\n            };\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            if (newAnnotation) {\n                this.createMemo(element, annotation, { newAnnotation });\n            }\n            this.editData = null;\n            this.isDrawing = false;\n            this.doneEditMemo();\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            data.handles.points[0] = [...worldPos];\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const annotationUID = annotation.annotationUID;\n                const data = annotation.data;\n                const point = data.handles.points[0];\n                const canvasCoordinates = viewport.worldToCanvas(point);\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!data.cachedStats) {\n                    data.cachedStats = {};\n                }\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].value === null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        index: null,\n                        value: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement, ChangeTypes.StatsUpdated);\n                }\n                else if (annotation.invalidated) {\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const handleGroupUID = '0';\n                drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color, lineWidth, handleRadius: this.configuration.handleRadius });\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (textLines) {\n                    const textCanvasCoordinates = [\n                        canvasCoordinates[0] + this.configuration.textCanvasOffset.x,\n                        canvasCoordinates[1] + this.configuration.textCanvasOffset.y,\n                    ];\n                    const textUID = '0';\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], options);\n                }\n            }\n            return renderStatus;\n        };\n    }\n    isPointNearTool(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const point = data.handles.points[0];\n        const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n        return vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n    }\n    toolSelectedCallback() { }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, viewUp, instance, viewport, } = this.hydrateBase(ProbeTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const point = data.handles.points[0];\n        const annotationCanvasCoordinate = viewport.worldToCanvas(point);\n        const near = vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n        if (near === true) {\n            return point;\n        }\n    }\n    handleSelectedCallback(evt, annotation) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement, changeType = ChangeTypes.StatsUpdated) {\n        const data = annotation.data;\n        const { renderingEngineId, viewport } = enabledElement;\n        const { element } = viewport;\n        const worldPos = data.handles.points[0];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const pixelUnitsOptions = {\n                isPreScaled: isViewportPreScaled(viewport, targetId),\n                isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n            };\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { dimensions, imageData, metadata, voxelManager } = image;\n            const modality = metadata.Modality;\n            let ijk = transformWorldToIndex(imageData, worldPos);\n            ijk = vec3.round(ijk, ijk);\n            if (csUtils.indexWithinDimensions(ijk, dimensions)) {\n                this.isHandleOutsideImage = false;\n                let value = voxelManager.getAtIJKPoint(ijk);\n                if (targetId.startsWith('imageId:')) {\n                    const imageId = targetId.split('imageId:')[1];\n                    const imageURI = csUtils.imageIdToURI(imageId);\n                    const viewports = csUtils.getViewportsWithImageURI(imageURI);\n                    const viewport = viewports[0];\n                    ijk[2] = viewport.getCurrentImageIdIndex();\n                }\n                let modalityUnit;\n                if (modality === 'US') {\n                    const calibratedResults = getCalibratedProbeUnitsAndValue(image, [\n                        ijk,\n                    ]);\n                    const hasEnhancedRegionValues = calibratedResults.values.every((value) => value !== null);\n                    value = (hasEnhancedRegionValues ? calibratedResults.values : value);\n                    modalityUnit = hasEnhancedRegionValues\n                        ? calibratedResults.units\n                        : 'raw';\n                }\n                else {\n                    modalityUnit = getPixelValueUnits(modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                }\n                cachedStats[targetId] = {\n                    index: ijk,\n                    value,\n                    Modality: modality,\n                    modalityUnit,\n                };\n                annotation.invalidated = true;\n            }\n            else {\n                this.isHandleOutsideImage = true;\n                cachedStats[targetId] = {\n                    index: ijk,\n                    Modality: modality,\n                };\n            }\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, changeType);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { index, value, modalityUnit } = cachedVolumeStats;\n    if (value === undefined || !index) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n    if (value instanceof Array && modalityUnit instanceof Array) {\n        for (let i = 0; i < value.length; i++) {\n            textLines.push(`${csUtils.roundNumber(value[i])} ${modalityUnit[i]}`);\n        }\n    }\n    else {\n        textLines.push(`${csUtils.roundNumber(value)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default ProbeTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { drawHandles as drawHandlesSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport ProbeTool from './ProbeTool';\nclass DragProbeTool extends ProbeTool {\n    static { this.toolName = 'DragProbe'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.postMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                isVisible: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId,\n                },\n                data: {\n                    label: '',\n                    handles: { points: [[...worldPos]] },\n                    cachedStats: {},\n                },\n            };\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                newAnnotation: true,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.postTouchStartCallback = (evt) => {\n            return this.postMouseDownCallback(evt);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const annotations = this.filterInteractableAnnotationsForElement(viewport.element, [this.editData.annotation]);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const annotation = this.editData.annotation;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const point = data.handles.points[0];\n            const canvasCoordinates = viewport.worldToCanvas(point);\n            styleSpecifier.annotationUID = annotationUID;\n            const { color } = this.getAnnotationStyle({\n                annotation,\n                styleSpecifier,\n            });\n            if (!data.cachedStats[targetId] ||\n                data.cachedStats[targetId].value === null) {\n                data.cachedStats[targetId] = {\n                    Modality: null,\n                    index: null,\n                    value: null,\n                };\n                this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n            }\n            else if (annotation.invalidated) {\n                this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n            }\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, [canvasCoordinates], { color });\n            renderStatus = true;\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (textLines) {\n                const textCanvasCoordinates = [\n                    canvasCoordinates[0] + 6,\n                    canvasCoordinates[1] - 6,\n                ];\n                const textUID = '0';\n                drawTextBoxSvg(svgDrawingHelper, annotationUID, textUID, textLines, [textCanvasCoordinates[0], textCanvasCoordinates[1]], this.getLinkedTextBoxStyle(styleSpecifier, annotation));\n            }\n            return renderStatus;\n        };\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { index, value, modalityUnit } = cachedVolumeStats;\n    if (value === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`(${index[0]}, ${index[1]}, ${index[2]})`);\n    textLines.push(`${value.toFixed(2)} ${modalityUnit}`);\n    return textLines;\n}\nexport default DragProbeTool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, EPSILON, } from '@cornerstonejs/core';\nimport { getCalibratedAspect, getCalibratedLengthUnitsAndScale, } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawEllipseByCoordinates as drawEllipseSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { pointInEllipse, getCanvasEllipseCorners, } from '../../utilities/math/ellipse';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { vec2 } from 'gl-matrix';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass EllipticalROITool extends AnnotationTool {\n    static { this.toolName = 'EllipticalROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            storePointData: false,\n            centerPointRadius: 0,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                centerWorld: worldPos,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const [bottom, top, left, right] = canvasCoordinates;\n            const w = Math.hypot(left[0] - right[0], left[1] - right[1]);\n            const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);\n            const angle = Math.atan2(left[1] - right[1], left[0] - right[0]);\n            const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];\n            const minorEllipse = {\n                center,\n                xRadius: (w - proximity) / 2,\n                yRadius: (h - proximity) / 2,\n                angle,\n            };\n            const majorEllipse = {\n                center,\n                xRadius: (w + proximity) / 2,\n                yRadius: (h + proximity) / 2,\n                angle,\n            };\n            const pointInMinorEllipse = this._pointInEllipseCanvas(minorEllipse, canvasCoords);\n            const pointInMajorEllipse = this._pointInEllipseCanvas(majorEllipse, canvasCoords);\n            if (pointInMajorEllipse && !pointInMinorEllipse) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            let centerCanvas;\n            let centerWorld;\n            let canvasWidth;\n            let canvasHeight;\n            let originalHandleCanvas;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                const { viewport } = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = viewport;\n                handleIndex = points.findIndex((p) => p === handle);\n                const pointsCanvas = points.map(worldToCanvas);\n                originalHandleCanvas = pointsCanvas[handleIndex];\n                canvasWidth = Math.abs(pointsCanvas[2][0] - pointsCanvas[3][0]);\n                canvasHeight = Math.abs(pointsCanvas[0][1] - pointsCanvas[1][1]);\n                centerCanvas = [\n                    (pointsCanvas[2][0] + pointsCanvas[3][0]) / 2,\n                    (pointsCanvas[0][1] + pointsCanvas[1][1]) / 2,\n                ];\n                centerWorld = canvasToWorld(centerCanvas);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                canvasWidth,\n                canvasHeight,\n                centerWorld,\n                originalHandleCanvas,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerWorld, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const centerCanvas = viewport.worldToCanvas(centerWorld);\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const bottomCanvas = [centerCanvas[0], centerCanvas[1] - dY];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] + dY];\n            const leftCanvas = [centerCanvas[0] - dX, centerCanvas[1]];\n            const rightCanvas = [centerCanvas[0] + dX, centerCanvas[1]];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { viewport } = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = viewport;\n            const { annotation, canvasWidth, canvasHeight, handleIndex, centerWorld, originalHandleCanvas, } = this.editData;\n            const centerCanvas = viewport.worldToCanvas(centerWorld);\n            const { data } = annotation;\n            const { points } = data.handles;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            if (handleIndex === 0 || handleIndex === 1) {\n                const dYCanvas = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n                const canvasBottom = [\n                    centerCanvas[0],\n                    centerCanvas[1] - dYCanvas,\n                ];\n                const canvasTop = [\n                    centerCanvas[0],\n                    centerCanvas[1] + dYCanvas,\n                ];\n                points[0] = canvasToWorld(canvasBottom);\n                points[1] = canvasToWorld(canvasTop);\n                const dXCanvas = currentCanvasPoints[0] - originalHandleCanvas[0];\n                const newHalfCanvasWidth = canvasWidth / 2 + dXCanvas;\n                const canvasLeft = [\n                    centerCanvas[0] - newHalfCanvasWidth,\n                    centerCanvas[1],\n                ];\n                const canvasRight = [\n                    centerCanvas[0] + newHalfCanvasWidth,\n                    centerCanvas[1],\n                ];\n                points[2] = canvasToWorld(canvasLeft);\n                points[3] = canvasToWorld(canvasRight);\n            }\n            else {\n                const dXCanvas = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n                const canvasLeft = [\n                    centerCanvas[0] - dXCanvas,\n                    centerCanvas[1],\n                ];\n                const canvasRight = [\n                    centerCanvas[0] + dXCanvas,\n                    centerCanvas[1],\n                ];\n                points[2] = canvasToWorld(canvasLeft);\n                points[3] = canvasToWorld(canvasRight);\n                const dYCanvas = currentCanvasPoints[1] - originalHandleCanvas[1];\n                const newHalfCanvasHeight = canvasHeight / 2 + dYCanvas;\n                const canvasBottom = [\n                    centerCanvas[0],\n                    centerCanvas[1] - newHalfCanvasHeight,\n                ];\n                const canvasTop = [\n                    centerCanvas[0],\n                    centerCanvas[1] + newHalfCanvasHeight,\n                ];\n                points[0] = canvasToWorld(canvasBottom);\n                points[1] = canvasToWorld(canvasTop);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasCorners = (getCanvasEllipseCorners(canvasCoordinates));\n                const { centerPointRadius } = this.configuration;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                    };\n                    this._calculateCachedStats(annotation, viewport, renderingEngine);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, showHandlesAlways ? canvasCoordinates : activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-ellipse`;\n                const ellipseUID = '0';\n                drawEllipseSvg(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                if (centerPointRadius > 0) {\n                    const minRadius = Math.min(Math.abs(canvasCorners[0][0] - canvasCorners[1][0]) / 2, Math.abs(canvasCorners[0][1] - canvasCorners[1][1]) / 2);\n                    if (minRadius > 3 * centerPointRadius) {\n                        const centerPoint = this._getCanvasEllipseCenter(canvasCoordinates);\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${ellipseUID}-center`, centerPoint, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            const { element } = viewport;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasEllipseCorners(canvasCoordinates));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const pos2Index = transformWorldToIndex(imageData, worldPos2);\n                pos2Index[0] = Math.floor(pos2Index[0]);\n                pos2Index[1] = Math.floor(pos2Index[1]);\n                pos2Index[2] = Math.floor(pos2Index[2]);\n                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n                    const iMin = Math.min(pos1Index[0], pos2Index[0]);\n                    const iMax = Math.max(pos1Index[0], pos2Index[0]);\n                    const jMin = Math.min(pos1Index[1], pos2Index[1]);\n                    const jMax = Math.max(pos1Index[1], pos2Index[1]);\n                    const kMin = Math.min(pos1Index[2], pos2Index[2]);\n                    const kMax = Math.max(pos1Index[2], pos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const center = [\n                        (topLeftWorld[0] + bottomRightWorld[0]) / 2,\n                        (topLeftWorld[1] + bottomRightWorld[1]) / 2,\n                        (topLeftWorld[2] + bottomRightWorld[2]) / 2,\n                    ];\n                    const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;\n                    const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;\n                    const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;\n                    const ellipseObj = {\n                        center,\n                        xRadius: xRadius < EPSILON / 2 ? 0 : xRadius,\n                        yRadius: yRadius < EPSILON / 2 ? 0 : yRadius,\n                        zRadius: zRadius < EPSILON / 2 ? 0 : zRadius,\n                    };\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n                    const handles = [pos1Index, pos2Index];\n                    const { scale, unit, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                    const aspect = getCalibratedAspect(image);\n                    const area = Math.abs(Math.PI *\n                        (worldWidth / scale / 2) *\n                        (worldHeight / aspect / scale / 2));\n                    const pixelUnitsOptions = {\n                        isPreScaled: isViewportPreScaled(viewport, targetId),\n                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                    };\n                    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                    let pointsInShape;\n                    if (voxelManager) {\n                        pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                            isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\n                            boundsIJK,\n                            imageData,\n                            returnPoints: this.configuration.storePointData,\n                        });\n                    }\n                    const stats = this.configuration.statsCalculator.getStatistics();\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean: stats.mean?.value,\n                        max: stats.max?.value,\n                        min: stats.min?.value,\n                        stdDev: stats.stdDev?.value,\n                        statsArray: stats.array,\n                        pointsInShape,\n                        isEmptyArea,\n                        areaUnit,\n                        modalityUnit,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(EllipticalROITool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    _pointInEllipseCanvas(ellipse, location) {\n        const { xRadius, yRadius, center, angle } = ellipse;\n        const rotLocation = vec2.rotate(vec2.create(), location, center, -angle);\n        if (xRadius <= 0.0 || yRadius <= 0.0) {\n            return false;\n        }\n        const normalized = [rotLocation[0] - center[0], rotLocation[1] - center[1]];\n        const inEllipse = (normalized[0] * normalized[0]) / (xRadius * xRadius) +\n            (normalized[1] * normalized[1]) / (yRadius * yRadius) <=\n            1.0;\n        return inEllipse;\n    }\n    _getCanvasEllipseCenter(ellipseCanvasPoints) {\n        const [bottom, top, left, right] = ellipseCanvasPoints;\n        const topLeft = [left[0], top[1]];\n        const bottomRight = [right[0], bottom[1]];\n        return [\n            (topLeft[0] + bottomRight[0]) / 2,\n            (topLeft[1] + bottomRight[1]) / 2,\n        ];\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, stdDev, max, isEmptyArea, areaUnit, modalityUnit, min } = cachedVolumeStats;\n    const textLines = [];\n    if (csUtils.isNumber(area)) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (csUtils.isNumber(mean)) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(min)) {\n        textLines.push(`Min: ${csUtils.roundNumber(min)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(stdDev)) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default EllipticalROITool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, EPSILON, } from '@cornerstonejs/core';\nimport { getCalibratedAspect, getCalibratedLengthUnitsAndScale, } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { getCanvasCircleCorners, getCanvasCircleRadius, } from '../../utilities/math/circle';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { vec2, vec3 } from 'gl-matrix';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass CircleROITool extends AnnotationTool {\n    static { this.toolName = 'CircleROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            storePointData: false,\n            centerPointRadius: 0,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n            simplified: true,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            this.isDrawing = true;\n            let points;\n            if (this.configuration.simplified) {\n                points = [[...worldPos], [...worldPos]];\n            }\n            else {\n                points = [\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                ];\n            }\n            const annotation = this.createAnnotation(evt, points);\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { points } = annotation.data.handles;\n            const canvasHandles = points.map((p) => viewport.worldToCanvas(p));\n            const canvasCenter = canvasHandles[0];\n            const radius = getCanvasCircleRadius([canvasCenter, canvasHandles[1]]);\n            const radiusPoint = getCanvasCircleRadius([canvasCenter, canvasCoords]);\n            return Math.abs(radiusPoint - radius) < proximity / 2;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const { world: worldPos, canvas: currentCanvasPoints } = currentPoints;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            const centerWorld = data.handles.points[0];\n            const centerCanvas = viewport.worldToCanvas(centerWorld);\n            if (this.configuration.simplified) {\n                data.handles.points[1] = worldPos;\n            }\n            else {\n                const radiusCanvas = vec2.distance(centerCanvas, currentCanvasPoints);\n                data.handles.points[0] = [...centerWorld];\n                data.handles.points[1] = canvasToWorld([\n                    centerCanvas[0],\n                    centerCanvas[1] - radiusCanvas,\n                ]);\n                data.handles.points[2] = canvasToWorld([\n                    centerCanvas[0],\n                    centerCanvas[1] + radiusCanvas,\n                ]);\n                data.handles.points[3] = canvasToWorld([\n                    centerCanvas[0] - radiusCanvas,\n                    centerCanvas[1],\n                ]);\n                data.handles.points[4] = canvasToWorld([\n                    centerCanvas[0] + radiusCanvas,\n                    centerCanvas[1],\n                ]);\n            }\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n            const { annotation, handleIndex } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const { currentPoints, deltaPoints } = eventDetail;\n            if (handleIndex === 0) {\n                const worldPosDelta = deltaPoints.world;\n                points.forEach((point) => {\n                    vec3.add(point, point, worldPosDelta);\n                });\n            }\n            else {\n                const centerWorld = points[0];\n                const centerCanvas = worldToCanvas(centerWorld);\n                const currentCanvasPoint = currentPoints.canvas;\n                const newRadiusCanvas = vec2.distance(centerCanvas, currentCanvasPoint);\n                points[1] = canvasToWorld([\n                    centerCanvas[0],\n                    centerCanvas[1] - newRadiusCanvas,\n                ]);\n                points[2] = canvasToWorld([\n                    centerCanvas[0],\n                    centerCanvas[1] + newRadiusCanvas,\n                ]);\n                points[3] = canvasToWorld([\n                    centerCanvas[0] - newRadiusCanvas,\n                    centerCanvas[1],\n                ]);\n                points[4] = canvasToWorld([\n                    centerCanvas[0] + newRadiusCanvas,\n                    centerCanvas[1],\n                ]);\n            }\n            annotation.invalidated = true;\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                annotation.highlighted = false;\n                annotation.data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                const radius = getCanvasCircleRadius([center, canvasCoordinates[1]]);\n                const canvasCorners = getCanvasCircleCorners([\n                    center,\n                    canvasCoordinates[1],\n                ]);\n                const { centerPointRadius } = this.configuration;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                        radius: null,\n                        radiusUnit: null,\n                        perimeter: null,\n                    };\n                    this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    if (this.configuration.simplified) {\n                        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                    }\n                    else {\n                        activeHandleCanvasCoords = canvasCoordinates;\n                    }\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, showHandlesAlways ? canvasCoordinates : activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-circle`;\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                if (centerPointRadius > 0) {\n                    if (radius > 3 * centerPointRadius) {\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                if (this.configuration.calculateStats) {\n                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                    if (!options.visibility) {\n                        data.handles.textBox = {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        };\n                        continue;\n                    }\n                    const textLines = this.configuration.getTextLines(data, targetId);\n                    if (!textLines || textLines.length === 0) {\n                        continue;\n                    }\n                    let canvasTextBoxCoords;\n                    if (!data.handles.textBox.hasMoved) {\n                        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                        data.handles.textBox.worldPosition =\n                            viewport.canvasToWorld(canvasTextBoxCoords);\n                    }\n                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                    const textBoxUID = '1';\n                    const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, [center, canvasCoordinates[1]], {}, options);\n                    const { x: left, y: top, width, height } = boundingBox;\n                    data.handles.textBox.worldBoundingBox = {\n                        topLeft: viewport.canvasToWorld([left, top]),\n                        topRight: viewport.canvasToWorld([left + width, top]),\n                        bottomLeft: viewport.canvasToWorld([left, top + height]),\n                        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                    };\n                }\n            }\n            return renderStatus;\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            const { element } = viewport;\n            const wasInvalidated = annotation.invalidated;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const canvasCenter = canvasCoordinates[0];\n            const canvasTop = canvasCoordinates[1];\n            const { viewPlaneNormal, viewUp } = viewport.getCamera();\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasCircleCorners([canvasCenter, canvasTop]));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const pos2Index = transformWorldToIndex(imageData, worldPos2);\n                pos2Index[0] = Math.floor(pos2Index[0]);\n                pos2Index[1] = Math.floor(pos2Index[1]);\n                pos2Index[2] = Math.floor(pos2Index[2]);\n                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n                    const iMin = Math.min(pos1Index[0], pos2Index[0]);\n                    const iMax = Math.max(pos1Index[0], pos2Index[0]);\n                    const jMin = Math.min(pos1Index[1], pos2Index[1]);\n                    const jMax = Math.max(pos1Index[1], pos2Index[1]);\n                    const kMin = Math.min(pos1Index[2], pos2Index[2]);\n                    const kMax = Math.max(pos1Index[2], pos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const center = points[0];\n                    const xRadius = Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2;\n                    const yRadius = Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2;\n                    const zRadius = Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2;\n                    const ellipseObj = {\n                        center,\n                        xRadius: xRadius < EPSILON / 2 ? 0 : xRadius,\n                        yRadius: yRadius < EPSILON / 2 ? 0 : yRadius,\n                        zRadius: zRadius < EPSILON / 2 ? 0 : zRadius,\n                    };\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const isEmptyArea = worldWidth === 0 && worldHeight === 0;\n                    const handles = [pos1Index, pos2Index];\n                    const { scale, unit, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                    const aspect = getCalibratedAspect(image);\n                    const area = Math.abs(Math.PI *\n                        (worldWidth / scale / 2) *\n                        (worldHeight / aspect / scale / 2));\n                    const pixelUnitsOptions = {\n                        isPreScaled: isViewportPreScaled(viewport, targetId),\n                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                    };\n                    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                    let pointsInShape;\n                    if (voxelManager) {\n                        pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                            isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS, { fast: true }),\n                            boundsIJK,\n                            imageData,\n                            returnPoints: this.configuration.storePointData,\n                        });\n                    }\n                    const stats = this.configuration.statsCalculator.getStatistics();\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean: stats.mean?.value,\n                        max: stats.max?.value,\n                        min: stats.min?.value,\n                        pointsInShape,\n                        stdDev: stats.stdDev?.value,\n                        statsArray: stats.array,\n                        isEmptyArea,\n                        areaUnit,\n                        radius: worldWidth / 2 / scale,\n                        radiusUnit: unit,\n                        perimeter: (2 * Math.PI * (worldWidth / 2)) / scale,\n                        modalityUnit,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            annotation.invalidated = false;\n            if (wasInvalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(CircleROITool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { radius, radiusUnit, area, mean, stdDev, max, min, isEmptyArea, areaUnit, modalityUnit, } = cachedVolumeStats;\n    const textLines = [];\n    if (csUtils.isNumber(radius)) {\n        const radiusLine = isEmptyArea\n            ? `Radius: Oblique not supported`\n            : `Radius: ${csUtils.roundNumber(radius)} ${radiusUnit}`;\n        textLines.push(radiusLine);\n    }\n    if (csUtils.isNumber(area)) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (csUtils.isNumber(mean)) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(min)) {\n        textLines.push(`Min: ${csUtils.roundNumber(min)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(stdDev)) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default CircleROITool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted } from '../../stateManagement/annotation/helpers/state';\nimport { drawCircle as drawCircleSvg, drawLine } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getCanvasCircleRadius } from '../../utilities/math/circle';\nimport { vec3 } from 'gl-matrix';\nconst CROSSHAIR_SIZE = 5;\nclass ETDRSGridTool extends AnnotationTool {\n    static { this.toolName = 'ETDRSGrid'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            degrees: [45, 135, 225, 315],\n            diameters: [10, 30, 60],\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                },\n                data: {\n                    label: '',\n                    handles: {\n                        points: [[...worldPos]],\n                    },\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const center = viewport.worldToCanvas(points[0]);\n            const radius = getCanvasCircleRadius([center, canvasCoords]);\n            if (Math.abs(radius) < proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            hideElementCursor(element);\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            data.handles.points = [\n                canvasToWorld(currentCanvasPoints),\n                canvasToWorld(currentCanvasPoints),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            const { deltaPoints } = eventDetail;\n            const worldPosDelta = deltaPoints.world;\n            const points = data.handles.points;\n            points.forEach((point) => {\n                point[0] += worldPosDelta[0];\n                point[1] += worldPosDelta[1];\n                point[2] += worldPosDelta[2];\n            });\n            annotation.invalidated = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._dragHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { canvasToWorld, worldToCanvas } = enabledElement.viewport;\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => worldToCanvas(p));\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const dXCanvas = currentCanvasPoints[0] - canvasCoordinates[0][0];\n            const dYCanvas = currentCanvasPoints[1] - canvasCoordinates[0][1];\n            const canvasCenter = currentCanvasPoints;\n            const canvasEnd = [\n                canvasCoordinates[1][0] + dXCanvas,\n                canvasCoordinates[1][1] + dYCanvas,\n            ];\n            points[0] = canvasToWorld(canvasCenter);\n            points[1] = canvasToWorld(canvasEnd);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                const { renderingEngine } = getEnabledElement(element);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles } = data;\n                const { points } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                let lineUID = `${annotationUID}-crosshair-vertical`;\n                let start = [center[0], center[1] + CROSSHAIR_SIZE];\n                let end = [center[0], center[1] - CROSSHAIR_SIZE];\n                drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                });\n                lineUID = `${annotationUID}-crosshair-horizontal`;\n                start = [center[0] + CROSSHAIR_SIZE, center[1]];\n                end = [center[0] - CROSSHAIR_SIZE, center[1]];\n                drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                });\n                const diametersCanvas = this.configuration.diameters.map((diameter) => this.worldMeasureToCanvas(diameter, viewport));\n                for (let i = 0; i < diametersCanvas.length; i++) {\n                    const dataId = `${annotationUID}-circle-${i}`;\n                    const circleUID = `${annotationUID}-circle-${i}`;\n                    drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, diametersCanvas[i] / 2, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    }, dataId);\n                }\n                const degreesRad = (x) => (x * Math.PI) / 180;\n                const angleRadians = this.configuration.degrees.map((degree) => degreesRad(degree));\n                for (let i = 0; i < angleRadians.length; i++) {\n                    const lineUID = `${annotationUID}-line-${i}`;\n                    const start = [\n                        (Math.cos(angleRadians[i]) * diametersCanvas[0]) / 2 + center[0],\n                        (Math.sin(angleRadians[i]) * diametersCanvas[0]) / 2 + center[1],\n                    ];\n                    const end = [\n                        (Math.cos(angleRadians[i]) * diametersCanvas[2]) / 2 + center[0],\n                        (Math.sin(angleRadians[i]) * diametersCanvas[2]) / 2 + center[1],\n                    ];\n                    drawLine(svgDrawingHelper, annotationUID, lineUID, start, end, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                renderStatus = true;\n            }\n            return renderStatus;\n        };\n    }\n    worldMeasureToCanvas(measurement, viewport) {\n        const p1 = viewport.canvasToWorld([\n            viewport.canvas.width / 2,\n            viewport.canvas.height / 2,\n        ]);\n        const { viewUp } = viewport.getCamera();\n        const p2 = vec3.scaleAndAdd(vec3.create(), p1, viewUp, measurement);\n        const p1Canvas = viewport.worldToCanvas(p1);\n        const p2Canvas = viewport.worldToCanvas(p2);\n        const distance = Math.sqrt(Math.pow(p2Canvas[0] - p1Canvas[0], 2) +\n            Math.pow(p2Canvas[1] - p1Canvas[1], 2));\n        return distance;\n    }\n}\nexport default ETDRSGridTool;\n","import { getEnabledElement, eventTarget, triggerEvent, utilities, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { addAnnotation, getChildAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { drawHandles as drawHandlesSvg, drawPolyline as drawPolylineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events, MouseBindings, KeyboardBindings, ChangeTypes, } from '../../enums';\nimport * as math from '../../utilities/math';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport { CardinalSpline } from './splines/CardinalSpline';\nimport { LinearSpline } from './splines/LinearSpline';\nimport { CatmullRomSpline } from './splines/CatmullRomSpline';\nimport { BSpline } from './splines/BSpline';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities';\nimport { convertContourSegmentationAnnotation } from '../../utilities/contourSegmentation';\nconst SPLINE_MIN_POINTS = 3;\nconst SPLINE_CLICK_CLOSE_CURVE_DIST = 10;\nconst DEFAULT_SPLINE_CONFIG = {\n    resolution: 20,\n    controlPointAdditionDistance: 6,\n    controlPointDeletionDistance: 6,\n    showControlPointsConnectors: false,\n    controlPointAdditionEnabled: true,\n    controlPointDeletionEnabled: true,\n};\nvar SplineTypesEnum;\n(function (SplineTypesEnum) {\n    SplineTypesEnum[\"Cardinal\"] = \"CARDINAL\";\n    SplineTypesEnum[\"Linear\"] = \"LINEAR\";\n    SplineTypesEnum[\"CatmullRom\"] = \"CATMULLROM\";\n    SplineTypesEnum[\"BSpline\"] = \"BSPLINE\";\n})(SplineTypesEnum || (SplineTypesEnum = {}));\nvar SplineToolActions;\n(function (SplineToolActions) {\n    SplineToolActions[\"AddControlPoint\"] = \"addControlPoint\";\n    SplineToolActions[\"DeleteControlPoint\"] = \"deleteControlPoint\";\n})(SplineToolActions || (SplineToolActions = {}));\nconst splineToolNames = [\n    'CatmullRomSplineROI',\n    'LinearSplineROI',\n    'BSplineROI',\n    'CardinalSplineROI',\n];\nclass SplineROITool extends ContourSegmentationBaseTool {\n    static { this.toolName = 'SplineROI'; }\n    static { this.SplineTypes = SplineTypesEnum; }\n    static { this.Actions = SplineToolActions; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            calculateStats: true,\n            simplifiedSpline: false,\n            getTextLines: defaultGetTextLines,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            spline: {\n                configuration: {\n                    [SplineTypesEnum.Cardinal]: {\n                        Class: CardinalSpline,\n                        scale: 0.5,\n                    },\n                    [SplineTypesEnum.CatmullRom]: {\n                        Class: CatmullRomSpline,\n                    },\n                    [SplineTypesEnum.Linear]: {\n                        Class: LinearSpline,\n                    },\n                    [SplineTypesEnum.BSpline]: {\n                        Class: BSpline,\n                        controlPointAdditionEnabled: false,\n                        controlPointDeletionEnabled: false,\n                        showControlPointsConnectors: true,\n                    },\n                },\n                type: SplineTypesEnum.CatmullRom,\n                drawPreviewEnabled: true,\n                enableTwoPointPreview: false,\n                lastControlPointDeletionKeys: ['Backspace', 'Delete'],\n            },\n            actions: {\n                [SplineToolActions.AddControlPoint]: {\n                    method: 'addControlPointCallback',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Primary,\n                            modifierKey: KeyboardBindings.Shift,\n                        },\n                    ],\n                },\n                [SplineToolActions.DeleteControlPoint]: {\n                    method: 'deleteControlPointCallback',\n                    bindings: [\n                        {\n                            mouseButton: MouseBindings.Primary,\n                            modifierKey: KeyboardBindings.Ctrl,\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.splineToolNames = [\n            'CatmullRomSplineROI',\n            'LinearSplineROI',\n            'BSplineROI',\n            'CardinalSplineROI',\n        ];\n        this.isHandleOutsideImage = false;\n        this.fireChangeOnUpdate = null;\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const { instance: spline } = annotation.data.spline;\n            return spline.isPointNearCurve(canvasCoords, proximity);\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;\n            const { data } = annotation;\n            annotation.autoGenerated = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            const enabledElement = getEnabledElement(element);\n            const image = this.getTargetImageData(this.getTargetId(enabledElement.viewport));\n            const { imageData, dimensions } = image;\n            this.isHandleOutsideImage = data.handles.points\n                .map((p) => utilities.transformWorldToIndex(imageData, p))\n                .some((index) => !utilities.indexWithinDimensions(index, dimensions));\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            const changeType = newAnnotation\n                ? ChangeTypes.Completed\n                : ChangeTypes.HandlesUpdated;\n            if (!this.fireChangeOnUpdate) {\n                this.fireChangeOnUpdate = {\n                    annotationUID: annotation.annotationUID,\n                    changeType,\n                    contourHoleProcessingEnabled,\n                };\n            }\n            else {\n                this.fireChangeOnUpdate.annotationUID = annotation.annotationUID;\n                this.fireChangeOnUpdate.changeType = changeType;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._keyDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const key = eventDetail.key ?? '';\n            const { lastControlPointDeletionKeys } = this.configuration.spline;\n            const deleteLastPoint = lastControlPointDeletionKeys.includes(key);\n            if (!deleteLastPoint) {\n                return;\n            }\n            const { annotation } = this.editData;\n            const { data } = annotation;\n            if (data.handles.points.length === SPLINE_MIN_POINTS) {\n                this.cancel(element);\n                return;\n            }\n            else {\n                const controlPointIndex = data.handles.points.length - 1;\n                this._deleteControlPointByIndex(element, annotation, controlPointIndex);\n            }\n            evt.preventDefault();\n        };\n        this._mouseMoveCallback = (evt) => {\n            const { drawPreviewEnabled } = this.configuration.spline;\n            if (!drawPreviewEnabled) {\n                return;\n            }\n            const { element } = evt.detail;\n            const { renderingEngine } = getEnabledElement(element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData.lastCanvasPoint = evt.detail.currentPoints.canvas;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._mouseDownCallback = (evt) => {\n            const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n            const { annotation, viewportIdsToRender } = this.editData;\n            const { data } = annotation;\n            if (data.contour.closed) {\n                return;\n            }\n            this.doneEditMemo();\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const { canvas: canvasPoint, world: worldPoint } = currentPoints;\n            let closeContour = data.handles.points.length >= 2 && doubleClick;\n            let addNewPoint = true;\n            if (data.handles.points.length) {\n                this.createMemo(element, annotation, {\n                    newAnnotation: data.handles.points.length === 1,\n                });\n            }\n            if (data.handles.points.length >= 3) {\n                this.createMemo(element, annotation);\n                const { instance: spline } = data.spline;\n                const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);\n                if (closestControlPoint?.index === 0) {\n                    addNewPoint = false;\n                    closeContour = true;\n                }\n            }\n            if (addNewPoint) {\n                data.handles.points.push(worldPoint);\n            }\n            data.contour.closed = data.contour.closed || closeContour;\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (data.contour.closed) {\n                this._endCallback(evt);\n            }\n            evt.preventDefault();\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                this.moveAnnotation(annotation, worldPosDelta);\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.triggerAnnotationCompleted = (annotation, contourHoleProcessingEnabled) => {\n            const eventType = Events.ANNOTATION_COMPLETED;\n            const eventDetail = {\n                annotation,\n                changeType: ChangeTypes.Completed,\n                contourHoleProcessingEnabled,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this.triggerAnnotationModified = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated) => {\n            const { viewportId, renderingEngineId } = enabledElement;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n                changeType,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this.triggerChangeEvent = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated, contourHoleProcessingEnabled) => {\n            if (changeType === ChangeTypes.Completed) {\n                this.triggerAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n            }\n            else {\n                this.triggerAnnotationModified(annotation, enabledElement, changeType);\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.KEY_DOWN, this._keyDownCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.addEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.KEY_DOWN, this._keyDownCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.removeEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {\n            const data = annotation.data;\n            const targetId = this.getTargetId(viewport);\n            if (!data.spline.instance.closed || !textboxStyle.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = 'textBox';\n            const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        this.addControlPointCallback = (evt, annotation) => {\n            const { data } = annotation;\n            const splineType = data.spline.type;\n            const splineConfig = this._getSplineConfig(splineType);\n            const maxDist = splineConfig.controlPointAdditionDistance;\n            if (splineConfig.controlPointAdditionEnabled === false) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { instance: spline } = data.spline;\n            const canvasPos = evt.detail.currentPoints.canvas;\n            const closestPointInfo = spline.getClosestPoint(canvasPos);\n            if (closestPointInfo.distance > maxDist) {\n                return;\n            }\n            const { index, point: canvasPoint } = spline.addControlPointAtU(closestPointInfo.uValue);\n            data.handles.points.splice(index, 0, canvasToWorld(canvasPoint));\n            annotation.invalidated = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.deleteControlPointCallback = (evt, annotation) => {\n            const splineType = annotation.data.spline.type;\n            const splineConfig = this._getSplineConfig(splineType);\n            const maxDist = splineConfig.controlPointDeletionDistance;\n            if (splineConfig.controlPointDeletionEnabled === false) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const { canvas: canvasPos } = currentPoints;\n            const { instance: spline } = annotation.data.spline;\n            const closestControlPoint = spline.getClosestControlPointWithinDistance(canvasPos, maxDist);\n            if (!closestControlPoint) {\n                return;\n            }\n            this._deleteControlPointByIndex(element, annotation, closestControlPoint.index);\n        };\n        this._calculateCachedStats = (annotation, element) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            if (!data.contour.closed) {\n                return;\n            }\n            const enabledElement = getEnabledElement(element);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            const { cachedStats } = data;\n            const { polyline: points } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasPoint = canvasCoordinates[0];\n                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n                const deltaXPoint = viewport.canvasToWorld([\n                    canvasPoint[0] + 1,\n                    canvasPoint[1],\n                ]);\n                const deltaYPoint = viewport.canvasToWorld([\n                    canvasPoint[0],\n                    canvasPoint[1] + 1,\n                ]);\n                const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n                const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n                const { imageData } = image;\n                const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, () => {\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(canvasCoordinates);\n                    const topLeftBBWorld = viewport.canvasToWorld([\n                        canvasMinX,\n                        canvasMinY,\n                    ]);\n                    const topLeftBBIndex = utilities.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = utilities.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                let area = math.polyline.getArea(canvasCoordinates) / scale / scale;\n                area *= deltaInX * deltaInY;\n                cachedStats[targetId] = {\n                    Modality: metadata.Modality,\n                    area,\n                    areaUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                this.triggerAnnotationModified(annotation, enabledElement, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n        this.annotationCompletedBinded = this.annotationCompleted.bind(this);\n    }\n    annotationCompleted(evt) {\n        const { sourceAnnotation: annotation } = evt.detail;\n        if (!this.splineToolNames.includes(annotation?.metadata?.toolName) ||\n            !this.configuration.simplifiedSpline ||\n            !this.isContourSegmentationTool()) {\n            return;\n        }\n        convertContourSegmentationAnnotation(annotation);\n    }\n    initializeListeners() {\n        eventTarget.addEventListener(Events.ANNOTATION_COMPLETED, this.annotationCompletedBinded);\n    }\n    removeListeners() {\n        eventTarget.removeEventListener(Events.ANNOTATION_COMPLETED, this.annotationCompletedBinded);\n    }\n    onSetToolEnabled() {\n        this.initializeListeners();\n    }\n    onSetToolActive() {\n        this.initializeListeners();\n    }\n    onSetToolDisabled() {\n        this.removeListeners();\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const { canvas: canvasPos } = currentPoints;\n        const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n            this.configuration.contourHoleAdditionModifierKey;\n        const annotation = this.createAnnotation(evt);\n        this.isDrawing = true;\n        this.addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n            lastCanvasPoint: canvasPos,\n            contourHoleProcessingEnabled,\n        };\n        this._activateDraw(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    cancel(element) {\n        if (!this.isDrawing) {\n            return;\n        }\n        this.isDrawing = false;\n        this._deactivateDraw(element);\n        this._deactivateModify(element);\n        const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n        if (newAnnotation) {\n            removeAnnotation(annotation.annotationUID);\n        }\n        super.cancelAnnotation(annotation);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        this.editData = null;\n        return annotation.annotationUID;\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, targetId, svgDrawingHelper, annotationStyle } = renderContext;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { element } = viewport;\n        const annotation = renderContext.annotation;\n        const { annotationUID, data, highlighted } = annotation;\n        const { handles } = data;\n        const { points: controlPoints, activeHandleIndex } = handles;\n        const newAnnotation = this.editData?.newAnnotation;\n        const { lineWidth, lineDash, color, locked: annotationLocked, } = annotationStyle;\n        const canvasCoordinates = controlPoints.map((p) => worldToCanvas(p));\n        const { drawPreviewEnabled } = this.configuration.spline;\n        const splineType = annotation.data.spline.type;\n        const splineConfig = this._getSplineConfig(splineType);\n        const spline = annotation.data.spline.instance;\n        const childAnnotations = getChildAnnotations(annotation);\n        const missingAnnotation = childAnnotations.findIndex((it) => !it);\n        if (missingAnnotation !== -1) {\n            throw new Error(`Can't find annotation for child ${annotation.childAnnotationUIDs.join()}`);\n        }\n        const splineAnnotationsGroup = [annotation, ...childAnnotations].filter((annotation) => this._isSplineROIAnnotation(annotation));\n        splineAnnotationsGroup.forEach((annotation) => {\n            const spline = this._updateSplineInstance(element, annotation);\n            const splinePolylineCanvas = spline.getPolylinePoints();\n            this.updateContourPolyline(annotation, {\n                points: splinePolylineCanvas,\n                closed: data.contour.closed,\n                targetWindingDirection: ContourWindingDirection.Clockwise,\n            }, viewport, { updateWindingDirection: data.contour.closed });\n        });\n        super.renderAnnotationInstance(renderContext);\n        if (!data.cachedStats[targetId] ||\n            data.cachedStats[targetId].areaUnit == null) {\n            data.cachedStats[targetId] = {\n                Modality: null,\n                area: null,\n                areaUnit: null,\n            };\n            this._calculateCachedStats(annotation, element);\n        }\n        else if (annotation.invalidated) {\n            this._throttledCalculateCachedStats(annotation, element);\n        }\n        let activeHandleCanvasCoords;\n        if (!annotationLocked && !this.editData && activeHandleIndex !== null) {\n            activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n        }\n        if (activeHandleCanvasCoords || newAnnotation || highlighted) {\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                color,\n                lineWidth,\n                handleRadius: '3',\n            });\n        }\n        if (drawPreviewEnabled &&\n            spline.numControlPoints >= 1 &&\n            this.editData?.lastCanvasPoint &&\n            !spline.closed) {\n            const { lastCanvasPoint } = this.editData;\n            const { enableTwoPointPreview } = this.configuration.spline;\n            if (spline.numControlPoints === 1 && enableTwoPointPreview) {\n                const firstPoint = canvasCoordinates[0];\n                const previewPolylinePoints = [firstPoint, lastCanvasPoint];\n                drawPolylineSvg(svgDrawingHelper, annotationUID, 'previewSplineChange', previewPolylinePoints, {\n                    color: '#9EA0CA',\n                    lineDash: lineDash,\n                    lineWidth: 1,\n                });\n            }\n            else if (spline.numControlPoints > 1) {\n                const previewPolylinePoints = spline.getPreviewPolylinePoints(lastCanvasPoint, SPLINE_CLICK_CLOSE_CURVE_DIST);\n                drawPolylineSvg(svgDrawingHelper, annotationUID, 'previewSplineChange', previewPolylinePoints, {\n                    color: '#9EA0CA',\n                    lineDash: lineDash,\n                    lineWidth: 1,\n                });\n            }\n        }\n        if (splineConfig.showControlPointsConnectors) {\n            const controlPointsConnectors = [...canvasCoordinates];\n            if (spline.closed) {\n                controlPointsConnectors.push(canvasCoordinates[0]);\n            }\n            drawPolylineSvg(svgDrawingHelper, annotationUID, 'controlPointsConnectors', controlPointsConnectors, {\n                color: 'rgba(255, 255, 255, 0.5)',\n                lineWidth: 1,\n            });\n        }\n        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);\n        if (this.fireChangeOnUpdate?.annotationUID === annotationUID) {\n            this.triggerChangeEvent(annotation, enabledElement, this.fireChangeOnUpdate.changeType, this.fireChangeOnUpdate.contourHoleProcessingEnabled);\n            this.fireChangeOnUpdate = null;\n        }\n        annotation.invalidated = false;\n        return true;\n    }\n    createInterpolatedSplineControl(annotation) {\n        if (annotation.data.handles.points?.length) {\n            return;\n        }\n        const { polyline } = annotation.data.contour;\n        if (!polyline || !polyline.length) {\n            return;\n        }\n        annotation.data.handles.points = [];\n        const { points } = annotation.data.handles;\n        const increment = Math.max(10, Math.floor(polyline.length / 20));\n        for (let i = 0; i < polyline.length - increment; i += increment) {\n            points.push(polyline[i]);\n        }\n        points.push(polyline[polyline.length - 1]);\n    }\n    isSplineAnnotation(annotation) {\n        return splineToolNames.includes(annotation?.metadata?.toolName);\n    }\n    createSplineObjectFromType(annotation, splineType) {\n        const splineConfig = this._getSplineConfig(splineType);\n        const spline = new splineConfig.Class();\n        annotation.data.spline = {\n            type: splineConfig.type,\n            instance: spline,\n            resolution: splineConfig.resolution,\n        };\n    }\n    createAnnotation(evt) {\n        const contourAnnotation = super.createAnnotation(evt);\n        const { world: worldPos } = evt.detail.currentPoints;\n        const { type: splineType } = this.configuration.spline;\n        const splineConfig = this._getSplineConfig(splineType);\n        const spline = new splineConfig.Class();\n        const createSpline = () => ({\n            type: splineConfig.type,\n            instance: spline,\n            resolution: splineConfig.resolution,\n        });\n        let onInterpolationComplete;\n        if (this.configuration.interpolation?.enabled) {\n            onInterpolationComplete = (annotation) => {\n                annotation.data.spline ||= createSpline();\n                this.createInterpolatedSplineControl(annotation);\n            };\n        }\n        return utilities.deepMerge(contourAnnotation, {\n            data: {\n                handles: {\n                    points: [[...worldPos]],\n                },\n                spline: createSpline(),\n                cachedStats: {},\n            },\n            onInterpolationComplete,\n        });\n    }\n    _deleteControlPointByIndex(element, annotation, controlPointIndex) {\n        const enabledElement = getEnabledElement(element);\n        const { points: controlPoints } = annotation.data.handles;\n        if (controlPoints.length === 3) {\n            removeAnnotation(annotation.annotationUID);\n        }\n        else {\n            controlPoints.splice(controlPointIndex, 1);\n        }\n        const { renderingEngine } = enabledElement;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        annotation.invalidated = true;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    }\n    _isSplineROIAnnotation(annotation) {\n        return !!annotation.data?.spline;\n    }\n    _getSplineConfig(type) {\n        const { configuration: config } = this;\n        const splineConfigs = config.spline.configuration;\n        return Object.assign({ type }, DEFAULT_SPLINE_CONFIG, splineConfigs[type]);\n    }\n    _updateSplineInstance(element, annotation) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { data } = annotation;\n        const { type: splineType, instance: spline } = annotation.data.spline;\n        const splineConfig = this._getSplineConfig(splineType);\n        const worldPoints = data.handles.points;\n        const canvasPoints = worldPoints.map(worldToCanvas);\n        const resolution = splineConfig.resolution !== undefined\n            ? parseInt(splineConfig.resolution)\n            : undefined;\n        const scale = splineConfig.scale !== undefined\n            ? parseFloat(splineConfig.scale)\n            : undefined;\n        spline.setControlPoints(canvasPoints);\n        spline.closed = !!data.contour.closed;\n        if (!spline.fixedResolution &&\n            resolution !== undefined &&\n            spline.resolution !== resolution) {\n            spline.resolution = resolution;\n            annotation.invalidated = true;\n        }\n        if (spline instanceof CardinalSpline &&\n            !spline.fixedScale &&\n            scale !== undefined &&\n            spline.scale !== scale) {\n            spline.scale = scale;\n            annotation.invalidated = true;\n        }\n        return spline;\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        if (points.length < SPLINE_MIN_POINTS) {\n            console.warn('Spline requires at least 3 control points');\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, viewUp, instance, viewport, } = this.hydrateBase(SplineROITool, enabledElement, points, options);\n        const splineType = options?.splineType || SplineTypesEnum.CatmullRom;\n        const splineConfig = instance._getSplineConfig(splineType);\n        const SplineClass = splineConfig.Class;\n        const splineInstance = new SplineClass();\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n                label: '',\n                cachedStats: {},\n                spline: {\n                    type: splineType,\n                    instance: splineInstance,\n                },\n                contour: {\n                    closed: true,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: true,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, isEmptyArea, areaUnit } = cachedVolumeStats;\n    const textLines = [];\n    if (area) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${utilities.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    return textLines;\n}\nexport default SplineROITool;\n","import { eventTarget, utilities } from '@cornerstonejs/core';\nimport SplineROITool from './SplineROITool';\nimport { Events } from '../../enums';\nimport { convertContourSegmentationAnnotation } from '../../utilities/contourSegmentation';\nclass SplineContourSegmentationTool extends SplineROITool {\n    static { this.toolName = 'SplineContourSegmentationTool'; }\n    constructor(toolProps) {\n        const initialProps = utilities.deepMerge({\n            configuration: {\n                calculateStats: false,\n            },\n        }, toolProps);\n        super(initialProps);\n        this.annotationCutMergeCompletedBinded =\n            this.annotationCutMergeCompleted.bind(this);\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    initializeListeners() {\n        eventTarget.addEventListener(Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, this.annotationCutMergeCompletedBinded);\n    }\n    removeListeners() {\n        eventTarget.removeEventListener(Events.ANNOTATION_CUT_MERGE_PROCESS_COMPLETED, this.annotationCutMergeCompletedBinded);\n    }\n    annotationCutMergeCompleted(evt) {\n        const { sourceAnnotation: annotation } = evt.detail;\n        if (this.toolName !== annotation?.metadata?.toolName ||\n            !this.splineToolNames.includes(annotation?.metadata?.toolName) ||\n            !this.configuration.simplifiedSpline) {\n            return;\n        }\n        convertContourSegmentationAnnotation(annotation);\n    }\n}\nexport default SplineContourSegmentationTool;\n","import { vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, VolumeViewport, utilities, triggerEvent, eventTarget, } from '@cornerstonejs/core';\nimport { removeAnnotation } from '../../stateManagement/annotation/annotationState';\nimport { drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { Events, KeyboardBindings, ChangeTypes } from '../../enums';\nimport getMouseModifierKey from '../../eventDispatchers/shared/getMouseModifier';\nimport * as math from '../../utilities/math';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport findHandlePolylineIndex from '../../utilities/contours/findHandlePolylineIndex';\nimport { ContourWindingDirection } from '../../types/ContourAnnotation';\nimport { triggerAnnotationModified, triggerContourAnnotationCompleted, } from '../../stateManagement/annotation/helpers/state';\nimport { LivewireScissors } from '../../utilities/livewire/LivewireScissors';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getCalibratedLengthUnitsAndScale, throttle } from '../../utilities';\nconst CLICK_CLOSE_CURVE_SQR_DIST = 10 ** 2;\nclass LivewireContourTool extends ContourSegmentationBaseTool {\n    static { this.toolName = 'LivewireContour'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            getTextLines: defaultGetTextLines,\n            calculateStats: true,\n            preventHandleOutsideImage: false,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            snapHandleNearby: 2,\n            interpolation: {\n                enabled: false,\n                nearestEdge: 2,\n                showInterpolationPolyline: false,\n            },\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            actions: {\n                cancelInProgress: {\n                    method: 'cancelInProgress',\n                    bindings: [\n                        {\n                            key: 'Escape',\n                        },\n                    ],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const proximitySquared = proximity * proximity;\n            const canvasPoints = annotation.data.contour.polyline.map((p) => viewport.worldToCanvas(p));\n            let startPoint = canvasPoints[canvasPoints.length - 1];\n            for (let i = 0; i < canvasPoints.length; i++) {\n                const endPoint = canvasPoints[i];\n                const distanceToPointSquared = math.lineSegment.distanceToPointSquared(startPoint, endPoint, canvasCoords);\n                if (distanceToPointSquared <= proximitySquared) {\n                    return true;\n                }\n                startPoint = endPoint;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            this._activateModify(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                const { points } = data.handles;\n                handleIndex = points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt, clearAnnotation = false) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, contourHoleProcessingEnabled, } = this.editData;\n            const { data } = annotation;\n            this.doneEditMemo();\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            const enabledElement = getEnabledElement(element);\n            if ((this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) ||\n                clearAnnotation) {\n                removeAnnotation(annotation.annotationUID);\n                this.clearEditData();\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                return;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            const changeType = newAnnotation\n                ? ChangeTypes.Completed\n                : ChangeTypes.HandlesUpdated;\n            this.triggerChangeEvent(annotation, enabledElement, changeType, contourHoleProcessingEnabled);\n            this.clearEditData();\n        };\n        this.triggerChangeEvent = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated, contourHoleProcessingEnabled = false) => {\n            if (changeType === ChangeTypes.Completed) {\n                triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n            }\n            else {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, changeType);\n            }\n        };\n        this._mouseDownCallback = (evt) => {\n            const doubleClick = evt.type === Events.MOUSE_DOUBLE_CLICK;\n            const { annotation, viewportIdsToRender, worldToSlice, sliceToWorld, newAnnotation, } = this.editData;\n            if (this.editData.closed) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const { canvas: canvasPos, world: worldPosOriginal } = currentPoints;\n            let worldPos = worldPosOriginal;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const controlPoints = this.editData.currentPath.getControlPoints();\n            let closePath = controlPoints.length >= 2 && doubleClick;\n            this.doneEditMemo();\n            this.createMemo(element, annotation, {\n                newAnnotation: newAnnotation && controlPoints.length === 1,\n            });\n            if (controlPoints.length >= 2) {\n                const closestHandlePoint = {\n                    index: -1,\n                    distSquared: Infinity,\n                };\n                for (let i = 0, len = controlPoints.length; i < len; i++) {\n                    const controlPoint = controlPoints[i];\n                    const worldControlPoint = sliceToWorld(controlPoint);\n                    const canvasControlPoint = viewport.worldToCanvas(worldControlPoint);\n                    const distSquared = math.point.distanceToPointSquared(canvasPos, canvasControlPoint);\n                    if (distSquared <= CLICK_CLOSE_CURVE_SQR_DIST &&\n                        distSquared < closestHandlePoint.distSquared) {\n                        closestHandlePoint.distSquared = distSquared;\n                        closestHandlePoint.index = i;\n                    }\n                }\n                if (closestHandlePoint.index === 0) {\n                    closePath = true;\n                }\n            }\n            const { snapHandleNearby } = this.configuration;\n            if (snapHandleNearby && !this.editData.closed) {\n                const currentPath = new LivewirePath();\n                const snapPoint = this.scissors.findMinNearby(worldToSlice(worldPosOriginal), 1);\n                const pathPoints = this.scissors.findPathToPoint(snapPoint);\n                currentPath.addPoints(pathPoints);\n                currentPath.prependPath(this.editData.confirmedPath);\n                worldPos = sliceToWorld(snapPoint);\n                this.editData.currentPath = currentPath;\n            }\n            this.editData.closed = this.editData.closed || closePath;\n            this.editData.confirmedPath = this.editData.currentPath;\n            const lastPoint = this.editData.currentPath.getLastPoint();\n            this.editData.confirmedPath.addControlPoint(lastPoint);\n            annotation.data.handles.points.push(sliceToWorld(lastPoint));\n            this.scissors.startSearch(worldToSlice(worldPos));\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (this.editData.closed) {\n                this.updateAnnotation(this.editData.confirmedPath);\n                this._endCallback(evt);\n            }\n            evt.preventDefault();\n        };\n        this._mouseMoveCallback = (evt) => {\n            const { element, currentPoints } = evt.detail;\n            const { world: worldPos, canvas: canvasPos } = currentPoints;\n            const { renderingEngine } = getEnabledElement(element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData.lastCanvasPoint = canvasPos;\n            const { width: imgWidth, height: imgHeight } = this.scissors;\n            const { worldToSlice } = this.editData;\n            const slicePoint = worldToSlice(worldPos);\n            if (slicePoint[0] < 0 ||\n                slicePoint[1] < 0 ||\n                slicePoint[0] >= imgWidth ||\n                slicePoint[1] >= imgHeight) {\n                return;\n            }\n            const pathPoints = this.scissors.findPathToPoint(slicePoint);\n            const currentPath = new LivewirePath();\n            currentPath.addPoints(pathPoints);\n            currentPath.prependPath(this.editData.confirmedPath);\n            this.editData.currentPath = currentPath;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, movingTextBox, handleIndex, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                console.warn('Drag annotation not implemented');\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                this.editHandle(worldPos, element, annotation, handleIndex);\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateDraw(element);\n            this._deactivateModify(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            if (newAnnotation) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            this.scissors = null;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.addEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_MOVE, this._mouseMoveCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.removeEventListener(Events.MOUSE_DOUBLE_CLICK, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._mouseDownCallback);\n        };\n        this._calculateCachedStats = (annotation, element) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const data = annotation.data;\n            if (!data.contour.closed) {\n                return;\n            }\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            const { cachedStats } = data;\n            const { polyline: points } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const canvasPoint = canvasCoordinates[0];\n                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n                const deltaXPoint = viewport.canvasToWorld([\n                    canvasPoint[0] + 1,\n                    canvasPoint[1],\n                ]);\n                const deltaYPoint = viewport.canvasToWorld([\n                    canvasPoint[0],\n                    canvasPoint[1] + 1,\n                ]);\n                const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n                const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n                const { imageData } = image;\n                const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, () => {\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(canvasCoordinates);\n                    const topLeftBBWorld = viewport.canvasToWorld([\n                        canvasMinX,\n                        canvasMinY,\n                    ]);\n                    const topLeftBBIndex = utilities.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = utilities.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                let area = math.polyline.getArea(canvasCoordinates) / scale / scale;\n                area *= deltaInX * deltaInY;\n                cachedStats[targetId] = {\n                    Modality: metadata.Modality,\n                    area,\n                    areaUnit: areaUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                this.triggerAnnotationModified(annotation, enabledElement, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._renderStats = (annotation, viewport, svgDrawingHelper, textboxStyle) => {\n            const data = annotation.data;\n            const targetId = this.getTargetId(viewport);\n            if (!data.contour.closed || !textboxStyle.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = 'textBox';\n            const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, textboxStyle);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        this.triggerAnnotationModified = (annotation, enabledElement, changeType = ChangeTypes.StatsUpdated) => {\n            const { viewportId, renderingEngineId } = enabledElement;\n            const eventType = Events.ANNOTATION_MODIFIED;\n            const eventDetail = {\n                annotation,\n                viewportId,\n                renderingEngineId,\n                changeType,\n            };\n            triggerEvent(eventTarget, eventType, eventDetail);\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    setupBaseEditData(worldPos, element, annotation, nextPos, contourHoleProcessingEnabled) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        this.isDrawing = true;\n        const viewportImageData = viewport.getImageData();\n        const { imageData: vtkImageData } = viewportImageData;\n        let worldToSlice;\n        let sliceToWorld;\n        let width;\n        let height;\n        let scalarData;\n        if (!(viewport instanceof VolumeViewport)) {\n            width = viewportImageData.dimensions[0];\n            height = viewportImageData.dimensions[1];\n            worldToSlice = (point) => {\n                const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n                return [ijkPoint[0], ijkPoint[1]];\n            };\n            sliceToWorld = (point) => csUtils.transformIndexToWorld(vtkImageData, [point[0], point[1], 0]);\n            scalarData = viewportImageData.scalarData;\n        }\n        else if (viewport instanceof VolumeViewport) {\n            const sliceImageData = csUtils.getCurrentVolumeViewportSlice(viewport);\n            const { sliceToIndexMatrix, indexToSliceMatrix } = sliceImageData;\n            worldToSlice = (point) => {\n                const ijkPoint = csUtils.transformWorldToIndex(vtkImageData, point);\n                const slicePoint = vec3.transformMat4([0, 0, 0], ijkPoint, indexToSliceMatrix);\n                return [slicePoint[0], slicePoint[1]];\n            };\n            sliceToWorld = (point) => {\n                const ijkPoint = vec3.transformMat4([0, 0, 0], [point[0], point[1], 0], sliceToIndexMatrix);\n                return csUtils.transformIndexToWorld(vtkImageData, ijkPoint);\n            };\n            scalarData = sliceImageData.scalarData;\n            width = sliceImageData.width;\n            height = sliceImageData.height;\n        }\n        else {\n            throw new Error('Viewport not supported');\n        }\n        scalarData = csUtils.convertToGrayscale(scalarData, width, height);\n        const { voiRange } = viewport.getProperties();\n        const startPos = worldToSlice(worldPos);\n        this.scissors = LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);\n        if (nextPos) {\n            this.scissorsNext = LivewireScissors.createInstanceFromRawPixelData(scalarData, width, height, voiRange);\n            this.scissorsNext.startSearch(worldToSlice(nextPos));\n        }\n        this.scissors.startSearch(startPos);\n        const newAnnotation = !nextPos;\n        const confirmedPath = new LivewirePath();\n        const currentPath = new LivewirePath();\n        const currentPathNext = newAnnotation ? undefined : new LivewirePath();\n        confirmedPath.addPoint(startPos);\n        confirmedPath.addControlPoint(startPos);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        const lastCanvasPoint = viewport.worldToCanvas(worldPos);\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            newAnnotation,\n            hasMoved: false,\n            lastCanvasPoint,\n            confirmedPath,\n            currentPath,\n            confirmedPathNext: currentPathNext,\n            closed: false,\n            handleIndex: this.editData?.handleIndex ?? annotation.handles?.activeHandleIndex,\n            worldToSlice,\n            sliceToWorld,\n            contourHoleProcessingEnabled,\n        };\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const { world: worldPos } = currentPoints;\n        const annotation = this.createAnnotation(evt);\n        const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n            this.configuration.contourHoleAdditionModifierKey;\n        this.setupBaseEditData(worldPos, element, annotation, undefined, contourHoleProcessingEnabled);\n        this.addAnnotation(annotation, element);\n        this._activateDraw(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(this.editData.viewportIdsToRender);\n        return annotation;\n    }\n    clearEditData() {\n        this.editData = null;\n        this.scissors = null;\n        this.scissorsNext = null;\n        this.isDrawing = false;\n    }\n    editHandle(worldPos, element, annotation, handleIndex) {\n        const { data } = annotation;\n        const { points: handlePoints } = data.handles;\n        const { length: numHandles } = handlePoints;\n        const previousHandle = handlePoints[(handleIndex - 1 + numHandles) % numHandles];\n        const nextHandle = handlePoints[(handleIndex + 1) % numHandles];\n        if (!this.editData?.confirmedPathNext) {\n            this.setupBaseEditData(previousHandle, element, annotation, nextHandle);\n            const { polyline } = data.contour;\n            const confirmedPath = new LivewirePath();\n            const confirmedPathNext = new LivewirePath();\n            const { worldToSlice } = this.editData;\n            const previousIndex = findHandlePolylineIndex(annotation, handleIndex - 1);\n            const nextIndex = findHandlePolylineIndex(annotation, handleIndex + 1);\n            if (nextIndex === -1 || previousIndex === -1) {\n                throw new Error(`Can't find handle index ${nextIndex === -1 && nextHandle} ${previousIndex === -1 && previousHandle}`);\n            }\n            if (handleIndex === 0) {\n                confirmedPathNext.addPoints(polyline.slice(nextIndex + 1, previousIndex).map(worldToSlice));\n            }\n            else {\n                confirmedPath.addPoints(polyline.slice(0, previousIndex + 1).map(worldToSlice));\n                confirmedPathNext.addPoints(polyline.slice(nextIndex, polyline.length).map(worldToSlice));\n            }\n            this.editData.confirmedPath = confirmedPath;\n            this.editData.confirmedPathNext = confirmedPathNext;\n        }\n        const { editData, scissors } = this;\n        const { worldToSlice, sliceToWorld } = editData;\n        const { activeHandleIndex } = data.handles;\n        if (activeHandleIndex === null || activeHandleIndex === undefined) {\n            data.handles.activeHandleIndex = handleIndex;\n        }\n        else if (activeHandleIndex !== handleIndex) {\n            throw new Error(`Trying to edit a different handle than the one currently being edited ${handleIndex}!==${data.handles.activeHandleIndex}`);\n        }\n        const slicePos = worldToSlice(worldPos);\n        if (slicePos[0] < 0 ||\n            slicePos[0] >= scissors.width ||\n            slicePos[1] < 0 ||\n            slicePos[1] >= scissors.height) {\n            return;\n        }\n        handlePoints[handleIndex] = sliceToWorld(slicePos);\n        const pathPointsLeft = scissors.findPathToPoint(slicePos);\n        const pathPointsRight = this.scissorsNext.findPathToPoint(slicePos);\n        const currentPath = new LivewirePath();\n        currentPath.prependPath(editData.confirmedPath);\n        if (handleIndex !== 0) {\n            currentPath.addPoints(pathPointsLeft);\n        }\n        currentPath.addPoints(pathPointsRight.reverse());\n        currentPath.appendPath(editData.confirmedPathNext);\n        if (handleIndex === 0) {\n            currentPath.addPoints(pathPointsLeft);\n        }\n        editData.currentPath = currentPath;\n        annotation.invalidated = true;\n        editData.hasMoved = true;\n        editData.closed = true;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        this.updateAnnotation(this.editData?.currentPath);\n        return super.renderAnnotation(enabledElement, svgDrawingHelper);\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    createAnnotation(evt) {\n        const contourSegmentationAnnotation = super.createAnnotation(evt);\n        const { world: worldPos } = evt.detail.currentPoints;\n        const annotation = csUtils.deepMerge(contourSegmentationAnnotation, {\n            data: {\n                handles: {\n                    points: [[...worldPos]],\n                },\n            },\n        });\n        return annotation;\n    }\n    cancelInProgress(element, config, evt) {\n        if (!this.editData) {\n            this.undo();\n            return;\n        }\n        this._endCallback(evt, true);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { annotation, enabledElement, svgDrawingHelper, annotationStyle, targetId, } = renderContext;\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const { worldToCanvas } = viewport;\n        const { annotationUID, data, highlighted } = annotation;\n        const { handles } = data;\n        const newAnnotation = this.editData?.newAnnotation;\n        const { lineWidth, lineDash, color } = annotationStyle;\n        if (highlighted ||\n            (newAnnotation &&\n                annotation.annotationUID === this.editData?.annotation?.annotationUID)) {\n            const handleGroupUID = '0';\n            const canvasHandles = handles.points.map(worldToCanvas);\n            drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasHandles, {\n                color,\n                lineDash,\n                lineWidth,\n            });\n        }\n        super.renderAnnotationInstance(renderContext);\n        if (!data.cachedStats[targetId] ||\n            data.cachedStats[targetId]?.areaUnit === null) {\n            data.cachedStats[targetId] = {\n                Modality: null,\n                area: null,\n                areaUnit: null,\n            };\n            this._calculateCachedStats(annotation, element);\n        }\n        else if (annotation.invalidated) {\n            this._throttledCalculateCachedStats(annotation, element);\n        }\n        this._renderStats(annotation, viewport, svgDrawingHelper, annotationStyle.textbox);\n        return true;\n    }\n    updateAnnotation(livewirePath) {\n        if (!this.editData || !livewirePath) {\n            return;\n        }\n        const { annotation, sliceToWorld, worldToSlice, closed, newAnnotation } = this.editData;\n        let { pointArray: imagePoints } = livewirePath;\n        if (imagePoints.length > 1) {\n            imagePoints = [...imagePoints, imagePoints[0]];\n        }\n        const targetWindingDirection = newAnnotation && closed ? ContourWindingDirection.Clockwise : undefined;\n        this.updateContourPolyline(annotation, {\n            points: imagePoints,\n            closed,\n            targetWindingDirection,\n        }, {\n            canvasToWorld: sliceToWorld,\n            worldToCanvas: worldToSlice,\n        });\n    }\n}\nexport default LivewireContourTool;\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, areaUnit } = cachedVolumeStats;\n    const textLines = [];\n    if (area) {\n        const areaLine = `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    return textLines;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport LivewireContourTool from './LivewireContourTool';\nimport { LivewirePath } from '../../utilities/livewire/LiveWirePath';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { ChangeTypes } from '../../enums';\nimport { drawPolyline as drawPolylineSvg } from '../../drawingSvg';\nimport AnnotationToPointData from '../../utilities/contours/AnnotationToPointData';\nclass LivewireContourSegmentationTool extends LivewireContourTool {\n    static { this.toolName = 'LivewireContourSegmentationTool'; }\n    updateInterpolatedAnnotation(annotation, enabledElement) {\n        if (this.editData ||\n            !annotation.invalidated ||\n            !annotation.data.handles.interpolationSources) {\n            return;\n        }\n        annotation.data.contour.originalPolyline = annotation.data.contour.polyline;\n        queueMicrotask(() => {\n            if (!annotation.data.handles.interpolationSources) {\n                return;\n            }\n            const { points } = annotation.data.handles;\n            const { element } = enabledElement.viewport;\n            this.setupBaseEditData(points[0], element, annotation);\n            const { length: count } = points;\n            const { scissors } = this;\n            const { nearestEdge, repeatInterpolation } = this.configuration.interpolation;\n            annotation.data.handles.originalPoints = points;\n            const { worldToSlice, sliceToWorld } = this.editData;\n            const handleSmoothing = [];\n            if (nearestEdge) {\n                let lastPoint = worldToSlice(points[points.length - 1]);\n                points.forEach((point, hIndex) => {\n                    const testPoint = worldToSlice(point);\n                    lastPoint = testPoint;\n                    handleSmoothing.push(testPoint);\n                    scissors.startSearch(lastPoint);\n                    scissors.findPathToPoint(testPoint);\n                    scissors.findPathToPoint(worldToSlice(points[(hIndex + 3) % points.length]));\n                    const minPoint = scissors.findMinNearby(testPoint, nearestEdge);\n                    if (!csUtils.isEqual(testPoint, minPoint)) {\n                        handleSmoothing[hIndex] = minPoint;\n                        lastPoint = minPoint;\n                        points[hIndex] = sliceToWorld(minPoint);\n                    }\n                });\n            }\n            const acceptedPath = new LivewirePath();\n            for (let i = 0; i < count; i++) {\n                scissors.startSearch(worldToSlice(points[i]));\n                const path = scissors.findPathToPoint(worldToSlice(points[(i + 1) % count]));\n                acceptedPath.addPoints(path);\n            }\n            this.updateAnnotation(acceptedPath);\n            this.scissors = null;\n            this.scissorsNext = null;\n            this.editData = null;\n            annotation.data.handles.interpolationSources = null;\n            if (repeatInterpolation) {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, ChangeTypes.InterpolationUpdated);\n            }\n        });\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        const { annotationUID } = annotation;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const { showInterpolationPolyline } = this.configuration.interpolation || {};\n        this.updateInterpolatedAnnotation?.(annotation, enabledElement);\n        const { originalPolyline } = annotation.data.contour;\n        const rendered = super.renderAnnotationInstance(renderContext);\n        if (showInterpolationPolyline &&\n            originalPolyline &&\n            annotation.autoGenerated) {\n            const polylineCanvasPoints = originalPolyline.map(worldToCanvas);\n            polylineCanvasPoints.push(polylineCanvasPoints[0]);\n            drawPolylineSvg(svgDrawingHelper, annotationUID, 'interpolationContour-0', polylineCanvasPoints, {\n                color: '#70ffff',\n                lineWidth: 1,\n                fillOpacity: 0,\n            });\n        }\n        return rendered;\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    static {\n        AnnotationToPointData.register(this);\n    }\n}\nexport default LivewireContourSegmentationTool;\n","import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawArrow as drawArrowSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { setAnnotationLabel } from '../../utilities';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nclass ArrowAnnotateTool extends AnnotationTool {\n    static { this.toolName = 'ArrowAnnotate'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            getTextCallback,\n            changeTextCallback,\n            preventHandleOutsideImage: false,\n            arrowFirst: true,\n            arrowHeadStyle: 'legacy',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            this.startGroupRecording();\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const { arrowFirst } = this.configuration;\n            const annotation = this.createAnnotation(evt, [[...worldPos], [...worldPos]], {\n                data: {\n                    handles: {\n                        arrowFirst,\n                    },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved, movingTextBox, } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            if (newAnnotation) {\n                this.configuration.getTextCallback((label) => {\n                    if (!label) {\n                        removeAnnotation(annotation.annotationUID);\n                        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                        this.editData = null;\n                        this.isDrawing = false;\n                        return;\n                    }\n                    annotation.data.label = label;\n                    triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n                    triggerAnnotationCompleted(annotation);\n                    this.createMemo(element, annotation, { newAnnotation: !!this.memo });\n                    setAnnotationLabel(annotation, element, label);\n                    this.endGroupRecording();\n                    this.doneEditMemo();\n                    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                });\n            }\n            else if (!movingTextBox) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n            this.doneEditMemo();\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.touchTapCallback = (evt) => {\n            if (evt.detail.taps == 2) {\n                this.doubleClickCallback(evt);\n            }\n        };\n        this.doubleClickCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            let annotations = getAnnotations(this.getToolName(), element);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return;\n            }\n            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));\n            if (!clickedAnnotation) {\n                return;\n            }\n            const annotation = clickedAnnotation;\n            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));\n            this.editData = null;\n            this.isDrawing = false;\n            evt.stopImmediatePropagation();\n            evt.preventDefault();\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { handles, label } = data;\n                const { points, activeHandleIndex } = handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, markerSize } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineWidth,\n                    });\n                }\n                const arrowUID = '1';\n                if (this.configuration.arrowFirst) {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[1], canvasCoordinates[0], {\n                        color,\n                        width: lineWidth,\n                        lineDash: lineDash,\n                        viaMarker: this.configuration.arrowHeadStyle !== 'legacy',\n                        markerSize,\n                    });\n                }\n                else {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasCoordinates[0], canvasCoordinates[1], {\n                        color,\n                        width: lineWidth,\n                        lineDash: lineDash,\n                        viaMarker: this.configuration.arrowHeadStyle !== 'legacy',\n                        markerSize,\n                    });\n                }\n                renderStatus = true;\n                if (!label) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, [label], textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n    }\n    static { this.hydrate = (viewportId, points, label, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(ArrowAnnotateTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = this.createAnnotation({\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                label: label || '',\n                handles: {\n                    points,\n                },\n            },\n            autoGenerated: false,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        });\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _doneChangingTextCallback(element, annotation, updatedLabel) {\n        annotation.data.label = updatedLabel;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        triggerAnnotationModified(annotation, element);\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nexport default ArrowAnnotateTool;\n","import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawPath as drawPathSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nclass AngleTool extends AnnotationTool {\n    static { this.toolName = 'Angle'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            showAngleArc: false,\n            arcOffset: 5,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.angleStartedNotYetCompleted) {\n                return;\n            }\n            this.angleStartedNotYetCompleted = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2, point3] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line1 = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            if (!point3) {\n                return false;\n            }\n            const canvasPoint3 = viewport.worldToCanvas(point3);\n            const line2 = {\n                start: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n                end: {\n                    x: canvasPoint3[0],\n                    y: canvasPoint3[1],\n                },\n            };\n            const distanceToPoint2 = lineSegment.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint2 <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            if (this.angleStartedNotYetCompleted && data.handles.points.length === 2) {\n                this.editData.handleIndex = 2;\n                return;\n            }\n            this.angleStartedNotYetCompleted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                this.angleStartedNotYetCompleted = false;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, angleArcLineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].angle == null) {\n                    data.cachedStats[targetId] = {\n                        angle: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotation.annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                let lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                renderStatus = true;\n                if (canvasCoordinates.length !== 3) {\n                    return renderStatus;\n                }\n                lineUID = '2';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], canvasCoordinates[2], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                if (this.configuration.showAngleArc) {\n                    const center = canvasCoordinates[1];\n                    const offset = this.configuration.arcOffset;\n                    const radius = Math.min(lineSegment.distanceToPoint([center[0], center[1]], [canvasCoordinates[0][0], canvasCoordinates[0][1]], [canvasCoordinates[2][0], canvasCoordinates[2][1]]), lineSegment.distanceToPoint([center[0], center[1]], [canvasCoordinates[2][0], canvasCoordinates[2][1]], [canvasCoordinates[0][0], canvasCoordinates[0][1]])) / offset;\n                    const anglePoints = [];\n                    let startAngle = Math.atan2(canvasCoordinates[0][1] - center[1], canvasCoordinates[0][0] - center[0]);\n                    let endAngle = Math.atan2(canvasCoordinates[2][1] - center[1], canvasCoordinates[2][0] - center[0]);\n                    if (endAngle < startAngle) {\n                        endAngle += 2 * Math.PI;\n                    }\n                    const angleDifference = endAngle - startAngle;\n                    if (angleDifference > Math.PI) {\n                        const temp = startAngle;\n                        startAngle = endAngle;\n                        endAngle = temp + 2 * Math.PI;\n                    }\n                    const segments = 32;\n                    for (let i = 0; i <= segments; i++) {\n                        const angle = startAngle + (i / segments) * (endAngle - startAngle);\n                        anglePoints.push([\n                            center[0] + radius * Math.cos(angle),\n                            center[1] + radius * Math.sin(angle),\n                        ]);\n                    }\n                    drawPathSvg(svgDrawingHelper, annotationUID, '3', anglePoints, {\n                        color: color,\n                        width: lineWidth,\n                        lineDash: angleArcLineDash,\n                    });\n                }\n                if (!data.cachedStats[targetId]?.angle) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(AngleTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        if (data.handles.points.length !== 3) {\n            return;\n        }\n        const worldPos1 = data.handles.points[0];\n        const worldPos2 = data.handles.points[1];\n        const worldPos3 = data.handles.points[2];\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const angle = angleBetweenLines([worldPos1, worldPos2], [worldPos2, worldPos3]);\n            const { dimensions, imageData } = this.getTargetImageData(targetId);\n            this.isHandleOutsideImage = [worldPos1, worldPos2, worldPos3]\n                .map((worldPos) => csUtils.transformWorldToIndex(imageData, worldPos))\n                .some((index) => !csUtils.indexWithinDimensions(index, dimensions));\n            cachedStats[targetId] = {\n                angle: isNaN(angle) ? 'Incomplete Angle' : angle,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { angle } = cachedVolumeStats;\n    if (angle === undefined) {\n        return;\n    }\n    if (isNaN(angle)) {\n        return [`${angle}`];\n    }\n    const textLines = [\n        `${csUtils.roundNumber(angle)} ${String.fromCharCode(176)}`,\n    ];\n    return textLines;\n}\nexport default AngleTool;\n","import { vec3 } from 'gl-matrix';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../utilities/math/line';\nimport angleBetweenLines from '../../utilities/math/angle/angleBetweenLines';\nimport { midPoint2 } from '../../utilities/math/midPoint';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawTextBox as drawTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nclass CobbAngleTool extends AnnotationTool {\n    static { this.toolName = 'CobbAngle'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            showArcLines: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.angleStartedNotYetCompleted) {\n                return;\n            }\n            this.angleStartedNotYetCompleted = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { distanceToPoint, distanceToPoint2 } = this.distanceToLines({\n                viewport,\n                points: data.handles.points,\n                canvasCoords,\n                proximity,\n            });\n            if (distanceToPoint <= proximity || distanceToPoint2 <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType, canvasCoords, proximity = 6) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { isNearFirstLine, isNearSecondLine } = this.distanceToLines({\n                viewport,\n                points: annotation.data.handles.points,\n                canvasCoords,\n                proximity,\n            });\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n                isNearFirstLine,\n                isNearSecondLine,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            if (this.angleStartedNotYetCompleted && data.handles.points.length < 4) {\n                resetElementCursor(element);\n                this.editData.handleIndex = data.handles.points.length;\n                return;\n            }\n            this.angleStartedNotYetCompleted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._mouseDownCallback = (evt) => {\n            const { annotation, handleIndex } = this.editData;\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { data } = annotation;\n            if (handleIndex === 1) {\n                data.handles.points[1] = worldPos;\n                this.editData.hasMoved =\n                    data.handles.points[1][0] !== data.handles.points[0][0] ||\n                        data.handles.points[1][1] !== data.handles.points[0][0];\n                return;\n            }\n            if (handleIndex === 3) {\n                data.handles.points[3] = worldPos;\n                this.editData.hasMoved =\n                    data.handles.points[3][0] !== data.handles.points[2][0] ||\n                        data.handles.points[3][1] !== data.handles.points[2][0];\n                this.angleStartedNotYetCompleted = false;\n                return;\n            }\n            this.editData.hasMoved = false;\n            hideElementCursor(element);\n            data.handles.points[2] = data.handles.points[3] = worldPos;\n            this.editData.handleIndex = data.handles.points.length - 1;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, isNearFirstLine, isNearSecondLine, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined &&\n                (isNearFirstLine || isNearSecondLine)) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                if (isNearFirstLine) {\n                    const firstLinePoints = [points[0], points[1]];\n                    firstLinePoints.forEach((point) => {\n                        point[0] += worldPosDelta[0];\n                        point[1] += worldPosDelta[1];\n                        point[2] += worldPosDelta[2];\n                    });\n                }\n                else if (isNearSecondLine) {\n                    const secondLinePoints = [points[2], points[3]];\n                    secondLinePoints.forEach((point) => {\n                        point[0] += worldPosDelta[0];\n                        point[1] += worldPosDelta[1];\n                        point[2] += worldPosDelta[2];\n                    });\n                }\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (!this.isDrawing) {\n                return;\n            }\n            this.isDrawing = false;\n            this._deactivateDraw(element);\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            if (data.handles.points.length < 4) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.angleStartedNotYetCompleted = false;\n            return annotation.annotationUID;\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DOWN, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_START, this._mouseDownCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].angle == null) {\n                    data.cachedStats[targetId] = {\n                        angle: null,\n                        arc1Angle: null,\n                        arc2Angle: null,\n                        points: {\n                            world: {\n                                arc1Start: null,\n                                arc1End: null,\n                                arc2Start: null,\n                                arc2End: null,\n                                arc1Angle: null,\n                                arc2Angle: null,\n                            },\n                            canvas: {\n                                arc1Start: null,\n                                arc1End: null,\n                                arc2Start: null,\n                                arc2End: null,\n                                arc1Angle: null,\n                                arc2Angle: null,\n                            },\n                        },\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color,\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const firstLine = [canvasCoordinates[0], canvasCoordinates[1]];\n                const secondLine = [canvasCoordinates[2], canvasCoordinates[3]];\n                let lineUID = 'line1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, firstLine[0], firstLine[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                renderStatus = true;\n                if (canvasCoordinates.length < 4) {\n                    return renderStatus;\n                }\n                lineUID = 'line2';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, secondLine[0], secondLine[1], {\n                    color,\n                    width: lineWidth,\n                    lineDash,\n                });\n                lineUID = 'linkLine';\n                const mid1 = midPoint2(firstLine[0], firstLine[1]);\n                const mid2 = midPoint2(secondLine[0], secondLine[1]);\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, mid1, mid2, {\n                    color,\n                    lineWidth: '1',\n                    lineDash: '1,4',\n                });\n                const { arc1Start, arc1End, arc2End, arc2Start } = data.cachedStats[targetId].points.canvas;\n                const { arc1Angle, arc2Angle } = data.cachedStats[targetId];\n                if (this.configuration.showArcLines) {\n                    lineUID = 'arc1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, arc1Start, arc1End, {\n                        color,\n                        lineWidth: '1',\n                    });\n                    lineUID = 'arc2';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, arc2Start, arc2End, {\n                        color,\n                        lineWidth: '1',\n                    });\n                }\n                if (!data.cachedStats[targetId]?.angle) {\n                    continue;\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = 'cobbAngleText';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n                if (this.configuration.showArcLines) {\n                    const arc1TextBoxUID = 'arcAngle1';\n                    const arc1TextLine = [\n                        `${arc1Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n                    ];\n                    const arch1TextPosCanvas = midPoint2(arc1Start, arc1End);\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, arc1TextBoxUID, arc1TextLine, arch1TextPosCanvas, {\n                        ...options,\n                        padding: 3,\n                    });\n                    const arc2TextBoxUID = 'arcAngle2';\n                    const arc2TextLine = [\n                        `${arc2Angle.toFixed(2)} ${String.fromCharCode(176)}`,\n                    ];\n                    const arch2TextPosCanvas = midPoint2(arc2Start, arc2End);\n                    drawTextBoxSvg(svgDrawingHelper, annotationUID, arc2TextBoxUID, arc2TextLine, arch2TextPosCanvas, {\n                        ...options,\n                        padding: 3,\n                    });\n                }\n            }\n            return renderStatus;\n        };\n        this.distanceToLines = ({ viewport, points, canvasCoords, proximity }) => {\n            const [point1, point2, point3, point4] = points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const canvasPoint3 = viewport.worldToCanvas(point3);\n            const canvasPoint4 = viewport.worldToCanvas(point4);\n            const line1 = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const line2 = {\n                start: {\n                    x: canvasPoint3[0],\n                    y: canvasPoint3[1],\n                },\n                end: {\n                    x: canvasPoint4[0],\n                    y: canvasPoint4[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line1.start.x, line1.start.y], [line1.end.x, line1.end.y], [canvasCoords[0], canvasCoords[1]]);\n            const distanceToPoint2 = lineSegment.distanceToPoint([line2.start.x, line2.start.y], [line2.end.x, line2.end.y], [canvasCoords[0], canvasCoords[1]]);\n            let isNearFirstLine = false;\n            let isNearSecondLine = false;\n            if (distanceToPoint <= proximity) {\n                isNearFirstLine = true;\n            }\n            else if (distanceToPoint2 <= proximity) {\n                isNearSecondLine = true;\n            }\n            return {\n                distanceToPoint,\n                distanceToPoint2,\n                isNearFirstLine,\n                isNearSecondLine,\n            };\n        };\n        this.getArcsStartEndPoints = ({ firstLine, secondLine, mid1, mid2, }) => {\n            const linkLine = [mid1, mid2];\n            const arc1Angle = angleBetweenLines(firstLine, linkLine);\n            const arc2Angle = angleBetweenLines(secondLine, linkLine);\n            const arc1Side = arc1Angle > 90 ? 1 : 0;\n            const arc2Side = arc2Angle > 90 ? 0 : 1;\n            const midLinkLine = midPoint2(linkLine[0], linkLine[1]);\n            const linkLineLength = Math.sqrt((linkLine[1][0] - linkLine[0][0]) ** 2 +\n                (linkLine[1][1] - linkLine[0][1]) ** 2);\n            const ratio = 0.1;\n            const midFirstLine = midPoint2(firstLine[0], firstLine[1]);\n            const midSecondLine = midPoint2(secondLine[0], secondLine[1]);\n            const directionVectorStartArc1 = [\n                firstLine[arc1Side][0] - midFirstLine[0],\n                firstLine[arc1Side][1] - midFirstLine[1],\n            ];\n            const magnitudeStartArc1 = Math.sqrt(directionVectorStartArc1[0] ** 2 + directionVectorStartArc1[1] ** 2);\n            const normalizedDirectionStartArc1 = [\n                directionVectorStartArc1[0] / magnitudeStartArc1,\n                directionVectorStartArc1[1] / magnitudeStartArc1,\n            ];\n            const arc1Start = [\n                midFirstLine[0] +\n                    normalizedDirectionStartArc1[0] * linkLineLength * ratio,\n                midFirstLine[1] +\n                    normalizedDirectionStartArc1[1] * linkLineLength * ratio,\n            ];\n            const directionVectorEndArc1 = [\n                midLinkLine[0] - mid1[0],\n                midLinkLine[1] - mid1[1],\n            ];\n            const magnitudeEndArc1 = Math.sqrt(directionVectorEndArc1[0] ** 2 + directionVectorEndArc1[1] ** 2);\n            const normalizedDirectionEndArc1 = [\n                directionVectorEndArc1[0] / magnitudeEndArc1,\n                directionVectorEndArc1[1] / magnitudeEndArc1,\n            ];\n            const arc1End = [\n                mid1[0] + normalizedDirectionEndArc1[0] * linkLineLength * ratio,\n                mid1[1] + normalizedDirectionEndArc1[1] * linkLineLength * ratio,\n            ];\n            const directionVectorStartArc2 = [\n                secondLine[arc2Side][0] - midSecondLine[0],\n                secondLine[arc2Side][1] - midSecondLine[1],\n            ];\n            const magnitudeStartArc2 = Math.sqrt(directionVectorStartArc2[0] ** 2 + directionVectorStartArc2[1] ** 2);\n            const normalizedDirectionStartArc2 = [\n                directionVectorStartArc2[0] / magnitudeStartArc2,\n                directionVectorStartArc2[1] / magnitudeStartArc2,\n            ];\n            const arc2Start = [\n                midSecondLine[0] +\n                    normalizedDirectionStartArc2[0] * linkLineLength * ratio,\n                midSecondLine[1] +\n                    normalizedDirectionStartArc2[1] * linkLineLength * ratio,\n            ];\n            const directionVectorEndArc2 = [\n                midLinkLine[0] - mid2[0],\n                midLinkLine[1] - mid2[1],\n            ];\n            const magnitudeEndArc2 = Math.sqrt(directionVectorEndArc2[0] ** 2 + directionVectorEndArc2[1] ** 2);\n            const normalizedDirectionEndArc2 = [\n                directionVectorEndArc2[0] / magnitudeEndArc2,\n                directionVectorEndArc2[1] / magnitudeEndArc2,\n            ];\n            const arc2End = [\n                mid2[0] + normalizedDirectionEndArc2[0] * linkLineLength * ratio,\n                mid2[1] + normalizedDirectionEndArc2[1] * linkLineLength * ratio,\n            ];\n            return {\n                arc1Start,\n                arc1End,\n                arc2Start,\n                arc2End,\n                arc1Angle: arc1Angle > 90 ? 180 - arc1Angle : arc1Angle,\n                arc2Angle: arc2Angle > 90 ? 180 - arc2Angle : arc2Angle,\n            };\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 25, { trailing: true });\n    }\n    handleSelectedCallback(evt, annotation, handle, interactionType = 'mouse') {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        if (data.handles.points.length !== 4) {\n            return;\n        }\n        const seg1 = [null, null];\n        const seg2 = [null, null];\n        let minDist = Number.MAX_VALUE;\n        for (let i = 0; i < 2; i += 1) {\n            for (let j = 2; j < 4; j += 1) {\n                const dist = vec3.distance(data.handles.points[i], data.handles.points[j]);\n                if (dist < minDist) {\n                    minDist = dist;\n                    seg1[1] = data.handles.points[i];\n                    seg1[0] = data.handles.points[(i + 1) % 2];\n                    seg2[0] = data.handles.points[j];\n                    seg2[1] = data.handles.points[2 + ((j - 1) % 2)];\n                }\n            }\n        }\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        const canvasPoints = data.handles.points.map((p) => viewport.worldToCanvas(p));\n        const firstLine = [canvasPoints[0], canvasPoints[1]];\n        const secondLine = [canvasPoints[2], canvasPoints[3]];\n        const mid1 = midPoint2(firstLine[0], firstLine[1]);\n        const mid2 = midPoint2(secondLine[0], secondLine[1]);\n        const { arc1Start, arc1End, arc2End, arc2Start, arc1Angle, arc2Angle } = this.getArcsStartEndPoints({\n            firstLine,\n            secondLine,\n            mid1,\n            mid2,\n        });\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            cachedStats[targetId] = {\n                angle: angleBetweenLines(seg1, seg2),\n                arc1Angle,\n                arc2Angle,\n                points: {\n                    canvas: {\n                        arc1Start,\n                        arc1End,\n                        arc2End,\n                        arc2Start,\n                    },\n                    world: {\n                        arc1Start: viewport.canvasToWorld(arc1Start),\n                        arc1End: viewport.canvasToWorld(arc1End),\n                        arc2End: viewport.canvasToWorld(arc2End),\n                        arc2Start: viewport.canvasToWorld(arc2Start),\n                    },\n                },\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { angle } = cachedVolumeStats;\n    if (angle === undefined) {\n        return;\n    }\n    const textLines = [`${angle.toFixed(2)} ${String.fromCharCode(176)}`];\n    return textLines;\n}\nexport default CobbAngleTool;\n","import { ChangeTypes, Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils, StackViewport, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawHandle as drawHandleSvg, drawLine as drawLineSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { distanceToPoint } from '../../utilities/math/point';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { getCalibratedProbeUnitsAndValue } from '../../utilities/getCalibratedUnits';\nimport { lineSegment } from '../../utilities/math';\nconst { transformWorldToIndex } = csUtils;\nclass UltrasoundDirectionalTool extends AnnotationTool {\n    static { this.toolName = 'UltrasoundDirectionalTool'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            shadow: true,\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            displayBothAxesDistances: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            if (this.startedDrawing) {\n                return;\n            }\n            this.startedDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            if (!(viewport instanceof StackViewport)) {\n                throw new Error('UltrasoundDirectionalTool can only be used on a StackViewport');\n            }\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const annotation = (this.createAnnotation(evt, [\n                [...worldPos],\n                [...worldPos],\n            ]));\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            if (this.startedDrawing && data.handles.points.length === 1) {\n                this.editData.handleIndex = 1;\n                return;\n            }\n            this.startedDrawing = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox } = this.editData;\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                data.handles.points[handleIndex] = [...worldPos];\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                this.startedDrawing = false;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].xValues == null) {\n                    data.cachedStats[targetId] = {\n                        xValues: [0, 0],\n                        yValues: [0, 0],\n                        isHorizontal: false,\n                        units: [''],\n                        isUnitless: false,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let handleGroupUID = '0';\n                drawHandleSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[0], {\n                    color,\n                }, 0);\n                renderStatus = true;\n                if (canvasCoordinates.length !== 2) {\n                    return renderStatus;\n                }\n                handleGroupUID = '1';\n                drawHandleSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates[1], {\n                    color,\n                }, 1);\n                const isUnitless = data.cachedStats[targetId].isUnitless;\n                if (!isUnitless) {\n                    const canvasPoint1 = canvasCoordinates[0];\n                    const canvasPoint2 = canvasCoordinates[1];\n                    const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n                    const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n                    const isHorizontal = data.cachedStats[targetId].isHorizontal;\n                    let projectedPointCanvas = [0, 0];\n                    if (isHorizontal) {\n                        projectedPointCanvas = [\n                            canvasPoint1[0] + canvasDeltaX,\n                            canvasPoint1[1],\n                        ];\n                    }\n                    else {\n                        projectedPointCanvas = [\n                            canvasPoint1[0],\n                            canvasPoint1[1] + canvasDeltaY,\n                        ];\n                    }\n                    let dataId = `${annotationUID}-line-1`;\n                    let lineUID = '1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], projectedPointCanvas, {\n                        color,\n                        width: 1,\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                    dataId = `${annotationUID}-line-2`;\n                    lineUID = '2';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[1], projectedPointCanvas, {\n                        color,\n                        width: 1,\n                        lineDash: [1, 1],\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                }\n                else {\n                    const dataId = `${annotationUID}-line-1`;\n                    const lineUID = '1';\n                    drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                        color,\n                        width: 1,\n                        shadow: this.configuration.shadow,\n                    }, dataId);\n                }\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId, this.configuration);\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = canvasCoordinates[1];\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    toolSelectedCallback(evt, annotation, interactionType, canvasCoords) {\n        return;\n    }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        this.editData = {\n            handleIndex,\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    _calculateCachedStats(annotation, renderingEngine, enabledElement) {\n        const data = annotation.data;\n        const { element } = enabledElement.viewport;\n        if (data.handles.points.length !== 2) {\n            return;\n        }\n        const { cachedStats } = data;\n        const targetIds = Object.keys(cachedStats);\n        for (let i = 0; i < targetIds.length; i++) {\n            const targetId = targetIds[i];\n            const image = this.getTargetImageData(targetId);\n            if (!image) {\n                continue;\n            }\n            const { imageData } = image;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[1];\n            const imageIndex1 = transformWorldToIndex(imageData, worldPos1);\n            const imageIndex2 = transformWorldToIndex(imageData, worldPos2);\n            const { values: values1, units: units1 } = getCalibratedProbeUnitsAndValue(image, [imageIndex1]);\n            const { values: values2, units: units2 } = getCalibratedProbeUnitsAndValue(image, [imageIndex2]);\n            let xValues, yValues, units, isHorizontal;\n            let isUnitless = false;\n            if (units1[0] !== units2[0] ||\n                units1[1] !== units2[1] ||\n                (units1[0] === 'raw' && units2[0] === 'raw')) {\n                const value = distanceToPoint(worldPos1, worldPos2);\n                xValues = [value, 0];\n                yValues = [value, 0];\n                units = ['px'];\n                isUnitless = true;\n            }\n            else {\n                const canvasPoint1 = enabledElement.viewport.worldToCanvas(worldPos1);\n                const canvasPoint2 = enabledElement.viewport.worldToCanvas(worldPos2);\n                const canvasDeltaY = canvasPoint2[1] - canvasPoint1[1];\n                const canvasDeltaX = canvasPoint2[0] - canvasPoint1[0];\n                isHorizontal = Math.abs(canvasDeltaX) > Math.abs(canvasDeltaY);\n                xValues = [values1[0], values2[0]];\n                yValues = [values1[1], values2[1]];\n                units = [units1[0], units1[1]];\n            }\n            cachedStats[targetId] = {\n                xValues,\n                yValues,\n                isHorizontal,\n                units,\n                isUnitless,\n            };\n        }\n        const invalidated = annotation.invalidated;\n        annotation.invalidated = false;\n        if (invalidated) {\n            triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n        }\n        return cachedStats;\n    }\n}\nfunction defaultGetTextLines(data, targetId, configuration) {\n    const cachedStats = data.cachedStats[targetId];\n    const { xValues, yValues, units, isUnitless, isHorizontal } = cachedStats;\n    if (isUnitless) {\n        return [`${csUtils.roundNumber(xValues[0])} px`];\n    }\n    if (configuration.displayBothAxesDistances) {\n        const dist1 = Math.abs(xValues[1] - xValues[0]);\n        const dist2 = Math.abs(yValues[1] - yValues[0]);\n        return [\n            `${csUtils.roundNumber(dist1)} ${units[0]}`,\n            `${csUtils.roundNumber(dist2)} ${units[1]}`,\n        ];\n    }\n    if (isHorizontal) {\n        const dist = Math.abs(xValues[1] - xValues[0]);\n        return [`${csUtils.roundNumber(dist)} ${units[0]}`];\n    }\n    else {\n        const dist = Math.abs(yValues[1] - yValues[0]);\n        return [`${csUtils.roundNumber(dist)} ${units[1]}`];\n    }\n}\nexport default UltrasoundDirectionalTool;\n","import { Events, ChangeTypes } from '../../../enums';\nimport { getEnabledElement, utilities, metaData, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../../stateManagement/annotation/helpers/state';\nimport * as lineSegment from '../../../utilities/math/line';\nimport { drawHandles as drawHandlesSvg, drawLine as drawLineSvg, drawFan as drawFanSvg, } from '../../../drawingSvg';\nimport { state } from '../../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { angleFromCenter, calculateInnerFanPercentage, clipInterval, intervalFromPoints, mergeIntervals, subtractIntervals, } from '../../../utilities/math/fan/fanUtils';\nimport { calculateFanGeometry } from './utils/fanExtraction';\nconst { transformIndexToWorld } = utilities;\nclass UltrasoundPleuraBLineTool extends AnnotationTool {\n    static { this.toolName = 'UltrasoundPleuraBLineTool'; }\n    static { this.USPleuraBLineAnnotationType = {\n        BLINE: 'bLine',\n        PLEURA: 'pleura',\n    }; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n            center: null,\n            innerRadius: null,\n            outerRadius: null,\n            startAngle: null,\n            endAngle: null,\n            bLineColor: 'rgb(60, 255, 60)',\n            pleuraColor: 'rgb(0, 4, 255)',\n            drawDepthGuide: true,\n            depth_ratio: 0.5,\n            depthGuideColor: 'rgb(0, 255, 255)',\n            depthGuideThickness: 4,\n            depthGuideDashLength: 20,\n            depthGuideDashGap: 16,\n            depthGuideOpacity: 0.2,\n            fanOpacity: 0.1,\n            showFanAnnotations: true,\n            updatePercentageCallback: null,\n            actions: {\n                undo: {\n                    method: 'undo',\n                    bindings: [{ key: 'z' }],\n                },\n                redo: {\n                    method: 'redo',\n                    bindings: [{ key: 'y' }],\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.pleuraAnnotations = [];\n        this.bLineAnnotations = [];\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            hideElementCursor(element);\n            this.isDrawing = true;\n            const { viewPlaneNormal, viewUp, position: cameraPosition, } = viewport.getCamera();\n            const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    ...viewport.getViewReference({ points: [worldPos] }),\n                    toolName: this.getToolName(),\n                    referencedImageId,\n                    viewUp,\n                    cameraPosition,\n                },\n                data: {\n                    handles: {\n                        points: [[...worldPos], [...worldPos]],\n                        activeHandleIndex: null,\n                    },\n                    annotationType: this.getActiveAnnotationType(),\n                    label: '',\n                },\n            };\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 1,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const [point1, point2] = data.handles.points;\n            const canvasPoint1 = viewport.worldToCanvas(point1);\n            const canvasPoint2 = viewport.worldToCanvas(point2);\n            const line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            const distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.doneEditMemo();\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { viewport } = getEnabledElement(element) || {};\n            if (!viewport) {\n                return;\n            }\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                const allPointsInsideShape = points.every((point) => {\n                    const newPoint = [\n                        point[0] + worldPosDelta[0],\n                        point[1] + worldPosDelta[1],\n                        point[2] + worldPosDelta[2],\n                    ];\n                    return this.isInsideFanShape(viewport, newPoint);\n                });\n                if (allPointsInsideShape) {\n                    points.forEach((point) => {\n                        point[0] += worldPosDelta[0];\n                        point[1] += worldPosDelta[1];\n                        point[2] += worldPosDelta[2];\n                    });\n                    annotation.invalidated = true;\n                }\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const worldPos = currentPoints.world;\n                if (this.isInsideFanShape(viewport, worldPos)) {\n                    data.handles.points[handleIndex] = [...worldPos];\n                    annotation.invalidated = true;\n                }\n            }\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            if (!this.getFanShapeGeometryParameters(viewport)) {\n                return;\n            }\n            const { imageData } = viewport.getImageData() || {};\n            if (!imageData) {\n                return renderStatus;\n            }\n            if (this.configuration.drawDepthGuide) {\n                this.drawDepthGuide(svgDrawingHelper, viewport);\n            }\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            const fanCenter = viewport.worldToCanvas(transformIndexToWorld(imageData, this.configuration.center));\n            const indexToCanvasRatio = this.getIndexToCanvasRatio(viewport);\n            const innerRadius = this.configuration.innerRadius * indexToCanvasRatio;\n            const outerRadius = this.configuration.outerRadius * indexToCanvasRatio;\n            const currentImageId = viewport.getCurrentImageId();\n            const unMergedPleuraIntervals = annotations\n                .filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA &&\n                annotation.metadata.referencedImageId === currentImageId)\n                .map((annotation) => {\n                const canvasCoordinates = annotation.data.handles.points.map((p) => viewport.worldToCanvas(p));\n                const interval = intervalFromPoints(fanCenter, canvasCoordinates);\n                return interval;\n            });\n            const mergedPleuraIntervals = mergeIntervals(unMergedPleuraIntervals);\n            const pleuraIntervalsDisplayed = [];\n            const bLineIntervalsDisplayed = [];\n            const drawAnnotation = (annotation) => {\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    return;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, canvasCoordinates, {\n                        color: this.getColorForLineType(annotation),\n                        fill: this.getColorForLineType(annotation),\n                        lineDash,\n                        lineWidth,\n                    });\n                }\n                const dataId = `${annotationUID}-line`;\n                const lineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color: this.getColorForLineType(annotation),\n                    width: lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId);\n                if (this.configuration.showFanAnnotations) {\n                    const lineInterval = intervalFromPoints(fanCenter, canvasCoordinates);\n                    let fanNumber = 0;\n                    if (annotation.data.annotationType ===\n                        UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {\n                        const uncoveredIntervals = subtractIntervals(bLineIntervalsDisplayed, lineInterval);\n                        uncoveredIntervals.forEach((interval) => {\n                            const clippedIntervals = clipInterval(interval, mergedPleuraIntervals);\n                            clippedIntervals.forEach((clippedInterval) => {\n                                fanNumber++;\n                                const fanIndex = fanNumber;\n                                const fanDataId = `${annotationUID}-fan-${fanIndex}`;\n                                const fanUID = `2-${fanIndex}`;\n                                drawFanSvg(svgDrawingHelper, annotationUID, fanUID, fanCenter, innerRadius, outerRadius, clippedInterval[0], clippedInterval[1], {\n                                    color: 'transparent',\n                                    fill: this.getColorForLineType(annotation),\n                                    fillOpacity: this.configuration.fanOpacity,\n                                    width: lineWidth,\n                                    lineDash,\n                                    shadow,\n                                }, fanDataId, 10);\n                                bLineIntervalsDisplayed.push(clippedInterval);\n                            });\n                        });\n                    }\n                    else if (annotation.data.annotationType ===\n                        UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {\n                        const uncoveredIntervals = subtractIntervals(pleuraIntervalsDisplayed, lineInterval);\n                        uncoveredIntervals.forEach((interval, index) => {\n                            fanNumber++;\n                            const fanIndex = fanNumber;\n                            const fanDataId = `${annotationUID}-fan-${fanIndex}`;\n                            const fanUID = `2-${fanIndex}`;\n                            drawFanSvg(svgDrawingHelper, annotationUID, fanUID, fanCenter, innerRadius, outerRadius, interval[0], interval[1], {\n                                color: 'transparent',\n                                fill: this.getColorForLineType(annotation),\n                                fillOpacity: this.configuration.fanOpacity,\n                                width: lineWidth,\n                                lineDash,\n                                shadow,\n                            }, fanDataId, 5);\n                            pleuraIntervalsDisplayed.push(interval);\n                        });\n                    }\n                }\n            };\n            const pleuraAnnotationsToDraw = annotations.filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA &&\n                annotation.metadata.referencedImageId === currentImageId);\n            pleuraAnnotationsToDraw.forEach((annotation) => {\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                drawAnnotation(annotation);\n            });\n            const bLineAnnotationsToDraw = annotations.filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE &&\n                annotation.metadata.referencedImageId === currentImageId);\n            bLineAnnotationsToDraw.forEach((annotation) => {\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                drawAnnotation(annotation);\n            });\n            renderStatus = true;\n            if (this.configuration.updatePercentageCallback && viewport) {\n                this.configuration.updatePercentageCallback(this.calculateBLinePleuraPercentage(viewport));\n            }\n            return renderStatus;\n        };\n        this.activeAnnotationType =\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE;\n    }\n    static filterAnnotations(element, filterFunction = () => true) {\n        const annotations = getAnnotations(UltrasoundPleuraBLineTool.toolName, element);\n        if (!annotations?.length) {\n            return [];\n        }\n        const filteredAnnotations = annotations.filter((annotation) => {\n            const currentImageId = annotation.metadata.referencedImageId;\n            return filterFunction(currentImageId);\n        });\n        return filteredAnnotations;\n    }\n    static countAnnotations(element, filterFunction = () => true) {\n        const annotations = getAnnotations(UltrasoundPleuraBLineTool.toolName, element);\n        const { viewport } = getEnabledElement(element);\n        const imageIds = viewport.getImageIds();\n        const getImageIdIndex = (imageId) => {\n            const index = imageIds.findIndex((id) => id === imageId);\n            if (index === -1) {\n                return 0;\n            }\n            return index;\n        };\n        if (!annotations?.length) {\n            return;\n        }\n        const annotationMapping = new Map();\n        annotations.forEach((annotation) => {\n            const currentImageId = annotation.metadata.referencedImageId;\n            if (!filterFunction(currentImageId)) {\n                return;\n            }\n            const { annotationType } = annotation.data;\n            let counts;\n            if (annotationMapping.has(currentImageId)) {\n                counts = annotationMapping.get(currentImageId);\n            }\n            else {\n                counts = {\n                    frame: getImageIdIndex(currentImageId),\n                    bLine: 0,\n                    pleura: 0,\n                };\n            }\n            if (annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {\n                counts.pleura++;\n            }\n            else if (annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {\n                counts.bLine++;\n            }\n            annotationMapping.set(currentImageId, counts);\n        });\n        return annotationMapping;\n    }\n    static deleteAnnotations(element, filterFunction = () => false) {\n        const annotations = getAnnotations(UltrasoundPleuraBLineTool.toolName, element);\n        if (!annotations?.length) {\n            return;\n        }\n        annotations.forEach((annotation) => {\n            if (!filterFunction(annotation.metadata.referencedImageId)) {\n                return;\n            }\n            removeAnnotation(annotation.annotationUID);\n        });\n    }\n    setActiveAnnotationType(type) {\n        this.activeAnnotationType = type;\n    }\n    getActiveAnnotationType() {\n        return this.activeAnnotationType;\n    }\n    deleteLastAnnotationType(element, type) {\n        let annotationList;\n        const annotations = getAnnotations(UltrasoundPleuraBLineTool.toolName, element);\n        if (type === UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {\n            annotationList = annotations.filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA);\n        }\n        else if (type === UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {\n            annotationList = annotations.filter((annotation) => annotation.data.annotationType ===\n                UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE);\n        }\n        if (annotationList?.length > 0) {\n            const annotation = annotationList.pop();\n            removeAnnotation(annotation.annotationUID);\n        }\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(UltrasoundPleuraBLineTool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                },\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n    handleSelectedCallback(evt, annotation, handle) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const { data } = annotation;\n        annotation.highlighted = true;\n        let movingTextBox = false;\n        let handleIndex;\n        if (handle.worldPosition) {\n            movingTextBox = true;\n        }\n        else {\n            handleIndex = data.handles.points.findIndex((p) => p === handle);\n        }\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex,\n            movingTextBox,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    isInsideFanShape(viewport, point) {\n        if (!this.getFanShapeGeometryParameters(viewport)) {\n            return false;\n        }\n        const { imageData } = viewport.getImageData() || {};\n        if (imageData) {\n            const fanCenter = viewport.worldToCanvas(imageData.indexToWorld(this.configuration.center));\n            const canvasCoordinates = viewport.worldToCanvas(point);\n            const angle = angleFromCenter(fanCenter, canvasCoordinates);\n            return (angle >= this.configuration.startAngle &&\n                angle <= this.configuration.endAngle);\n        }\n    }\n    updateFanGeometryConfiguration(fanGeometry) {\n        if (!fanGeometry) {\n            return;\n        }\n        if (this.isFanShapeGeometryParametersValid(fanGeometry)) {\n            this.configuration.center = [\n                fanGeometry.center[0],\n                fanGeometry.center[1],\n                0,\n            ];\n        }\n        this.configuration.innerRadius = fanGeometry.innerRadius;\n        this.configuration.outerRadius = fanGeometry.outerRadius;\n        this.configuration.startAngle = fanGeometry.startAngle;\n        this.configuration.endAngle = fanGeometry.endAngle;\n    }\n    deriveFanGeometryFromViewport(viewport) {\n        const imageId = viewport.getCurrentImageId();\n        const { fanGeometry } = calculateFanGeometry(imageId) || {};\n        if (fanGeometry) {\n            this.updateFanGeometryConfiguration(fanGeometry);\n        }\n    }\n    isFanShapeGeometryParametersValid(fanGeometry) {\n        if (!fanGeometry) {\n            fanGeometry = this.configuration;\n        }\n        return (fanGeometry?.center &&\n            fanGeometry?.innerRadius > 0 &&\n            fanGeometry?.outerRadius &&\n            fanGeometry?.startAngle > 0 &&\n            fanGeometry?.startAngle < 360 &&\n            fanGeometry?.endAngle > 0 &&\n            fanGeometry?.endAngle < 360);\n    }\n    getFanShapeGeometryParameters(viewport) {\n        if (this.isFanShapeGeometryParametersValid()) {\n            return true;\n        }\n        if (!this.isFanShapeGeometryParametersValid()) {\n            const imageId = viewport.getCurrentImageId();\n            const fanGeometry = metaData.get('ultrasoundFanShapeGeometry', imageId);\n            this.updateFanGeometryConfiguration(fanGeometry);\n        }\n        if (!this.isFanShapeGeometryParametersValid()) {\n            this.deriveFanGeometryFromViewport(viewport);\n        }\n        return this.isFanShapeGeometryParametersValid();\n    }\n    calculateBLinePleuraPercentage(viewport) {\n        if (!this.getFanShapeGeometryParameters(viewport)) {\n            return;\n        }\n        const { imageData } = viewport.getImageData() || {};\n        if (!imageData) {\n            return;\n        }\n        const { element } = viewport;\n        const fanCenter = viewport.worldToCanvas(imageData.indexToWorld(this.configuration.center));\n        const currentImageId = viewport.getCurrentImageId();\n        const annotations = getAnnotations(this.getToolName(), element) || [];\n        const pleuraIntervals = annotations\n            .filter((annotation) => annotation.data.annotationType ===\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA &&\n            annotation.metadata.referencedImageId === currentImageId)\n            .map((annotation) => {\n            const canvasCoordinates = annotation.data.handles.points.map((p) => viewport.worldToCanvas(p));\n            return canvasCoordinates;\n        });\n        const bLineIntervals = annotations\n            .filter((annotation) => annotation.data.annotationType ===\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE &&\n            annotation.metadata.referencedImageId === currentImageId)\n            .map((annotation) => {\n            const canvasCoordinates = annotation.data.handles.points.map((p) => viewport.worldToCanvas(p));\n            return canvasCoordinates;\n        });\n        return calculateInnerFanPercentage(fanCenter, pleuraIntervals, bLineIntervals);\n    }\n    getColorForLineType(annotation) {\n        const { annotationType } = annotation.data;\n        const { bLineColor, pleuraColor } = this.configuration;\n        if (annotationType ===\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.BLINE) {\n            return bLineColor;\n        }\n        if (annotationType ===\n            UltrasoundPleuraBLineTool.USPleuraBLineAnnotationType.PLEURA) {\n            return pleuraColor;\n        }\n        return bLineColor;\n    }\n    getIndexToCanvasRatio(viewport) {\n        const { imageData } = viewport.getImageData() || {};\n        const v1 = viewport.worldToCanvas(imageData.indexToWorld([1, 0, 0]));\n        const v2 = viewport.worldToCanvas(imageData.indexToWorld([2, 0, 0]));\n        const diffVector = [v2[0] - v1[0], v2[1] - v1[1]];\n        const vectorSize = Math.sqrt(diffVector[0] * diffVector[0] + diffVector[1] * diffVector[1]);\n        return vectorSize;\n    }\n    drawDepthGuide(svgDrawingHelper, viewport) {\n        if (!this.getFanShapeGeometryParameters(viewport)) {\n            return;\n        }\n        const { imageData } = viewport.getImageData() || {};\n        if (!imageData) {\n            return;\n        }\n        const radToDegree = (rad) => (rad * 180) / Math.PI;\n        const degreeToRad = (degree) => (degree * Math.PI) / 180;\n        const indexToCanvas = (point) => {\n            return viewport.worldToCanvas(transformIndexToWorld(imageData, point));\n        };\n        const depth_radius = this.configuration.innerRadius +\n            this.configuration.depth_ratio *\n                (this.configuration.outerRadius - this.configuration.innerRadius);\n        const theta_start = this.configuration.startAngle;\n        const theta_end = this.configuration.endAngle;\n        const theta_range = theta_end - theta_start;\n        const arc_length = degreeToRad(theta_range) * depth_radius;\n        let num_dashes = Math.round(arc_length /\n            (this.configuration.depthGuideDashLength +\n                this.configuration.depthGuideDashGap));\n        if (num_dashes <= 0) {\n            num_dashes = Math.max(15, Math.round(theta_range / 5));\n        }\n        const theta_step = theta_range / num_dashes;\n        for (let i = 0; i < num_dashes; i++) {\n            const theta1 = degreeToRad(theta_start + i * theta_step);\n            const theta2 = degreeToRad(theta_start +\n                i * theta_step +\n                radToDegree(this.configuration.depthGuideDashLength) / depth_radius);\n            const start_point = [\n                this.configuration.center[0] + depth_radius * Math.cos(theta1),\n                this.configuration.center[1] + depth_radius * Math.sin(theta1),\n                0,\n            ];\n            const end_point = [\n                this.configuration.center[0] + depth_radius * Math.cos(theta2),\n                this.configuration.center[1] + depth_radius * Math.sin(theta2),\n                0,\n            ];\n            drawLineSvg(svgDrawingHelper, viewport.id, `depthGuide-${i}`, indexToCanvas(start_point), indexToCanvas(end_point), {\n                color: this.configuration.depthGuideColor,\n                lineWidth: this.configuration.depthGuideThickness,\n                strokeOpacity: this.configuration.depthGuideOpacity,\n            });\n        }\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (utilities.indexWithinDimensions(index1, dimensions) &&\n            utilities.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    return [''];\n}\nexport default UltrasoundPleuraBLineTool;\n","import { Events } from '../../enums';\nimport { getEnabledElement, utilities as csUtils } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawArrow as drawArrowSvg, drawHandles as drawHandlesSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nclass KeyImageTool extends AnnotationTool {\n    static { this.toolName = 'KeyImage'; }\n    static { this.dataSeries = {\n        data: {\n            seriesLevel: true,\n        },\n    }; }\n    static { this.dataPoint = {\n        data: {\n            isPoint: true,\n        },\n    }; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            getTextCallback,\n            changeTextCallback,\n            canvasPosition: [10, 10],\n            canvasSize: 10,\n            handleRadius: '6',\n            seriesLevel: false,\n            isPoint: false,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element, currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const worldPos = currentPoints.world;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: { points: [[...worldPos]] },\n                    seriesLevel: this.configuration.seriesLevel,\n                    isPoint: this.configuration.isPoint,\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            this.configuration.getTextCallback((label) => {\n                if (!label) {\n                    removeAnnotation(annotation.annotationUID);\n                    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                    this.isDrawing = false;\n                    return;\n                }\n                annotation.data.label = label;\n                triggerAnnotationCompleted(annotation);\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            });\n            this.createMemo(element, annotation, { newAnnotation: true });\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            if (!data?.isPoint) {\n                return false;\n            }\n            const { canvasPosition, canvasSize } = this.configuration;\n            if (!canvasPosition?.length) {\n                return false;\n            }\n            if (Math.abs(canvasCoords[0] - canvasPosition[0] + canvasSize / 2) <=\n                canvasSize / 2 &&\n                Math.abs(canvasCoords[1] - canvasPosition[1] + canvasSize / 2) <=\n                    canvasSize / 2) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            annotation.highlighted = true;\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { viewportId, renderingEngine } = getEnabledElement(element);\n            this.eventDispatchDetail = {\n                viewportId,\n                renderingEngineId: renderingEngine.id,\n            };\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            if (newAnnotation) {\n                this.createMemo(element, annotation, { newAnnotation });\n            }\n            this.editData = null;\n            this.isDrawing = false;\n            this.doneEditMemo();\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this.doubleClickCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            let annotations = getAnnotations(this.getToolName(), element);\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return;\n            }\n            const clickedAnnotation = annotations.find((annotation) => this.isPointNearTool(element, annotation, eventDetail.currentPoints.canvas, 6));\n            if (!clickedAnnotation) {\n                return;\n            }\n            const annotation = clickedAnnotation;\n            this.createMemo(element, annotation);\n            this.configuration.changeTextCallback(clickedAnnotation, evt.detail, this._doneChangingTextCallback.bind(this, element, annotation));\n            this.isDrawing = false;\n            this.doneEditMemo();\n            evt.stopImmediatePropagation();\n            evt.preventDefault();\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            this.createMemo(element, annotation, { newAnnotation });\n            data.handles.points[0] = [...worldPos];\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const { canvasPosition, canvasSize } = this.configuration;\n                const arrowUID = '1';\n                if (data?.isPoint) {\n                    const point = data.handles.points[0];\n                    const canvasCoordinates = viewport.worldToCanvas(point);\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, arrowUID, [canvasCoordinates], {\n                        color,\n                        lineWidth,\n                        handleRadius: this.configuration.handleRadius,\n                    });\n                }\n                else if (canvasPosition?.length) {\n                    drawArrowSvg(svgDrawingHelper, annotationUID, arrowUID, canvasPosition.map((it) => it + canvasSize), canvasPosition, {\n                        color,\n                        width: 1,\n                    });\n                }\n                renderStatus = true;\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n            }\n            return renderStatus;\n        };\n    }\n    handleSelectedCallback(evt, annotation) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        annotation.highlighted = true;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n        };\n        this._activateModify(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        evt.preventDefault();\n    }\n    static setPoint(annotation, isPoint = !annotation.data.isPoint, element) {\n        annotation.data.isPoint = isPoint;\n        triggerAnnotationModified(annotation, element);\n    }\n    _doneChangingTextCallback(element, annotation, updatedText) {\n        annotation.data.label = updatedText;\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        triggerAnnotationModified(annotation, element);\n    }\n    cancel(element) {\n        if (this.isDrawing) {\n            this.isDrawing = false;\n            this._deactivateModify(element);\n            resetElementCursor(element);\n            const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n            const { data } = annotation;\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            return annotation.annotationUID;\n        }\n    }\n    _isInsideVolume(index1, index2, dimensions) {\n        return (csUtils.indexWithinDimensions(index1, dimensions) &&\n            csUtils.indexWithinDimensions(index2, dimensions));\n    }\n}\nfunction getTextCallback(doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nfunction changeTextCallback(data, eventData, doneChangingTextCallback) {\n    return doneChangingTextCallback(prompt('Enter your annotation:'));\n}\nexport default KeyImageTool;\n","import { BaseTool, AnnotationTool } from './base';\nimport { getAnnotations, getAnnotation, removeAnnotation, } from '../stateManagement/annotation/annotationState';\nimport { setAnnotationSelected } from '../stateManagement/annotation/annotationSelection';\nimport { getToolGroupForViewport } from '../store/ToolGroupManager';\nclass AnnotationEraserTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            return this._deleteNearbyAnnotations(evt, 'mouse');\n        };\n        this.preTouchStartCallback = (evt) => {\n            return this._deleteNearbyAnnotations(evt, 'touch');\n        };\n    }\n    _deleteNearbyAnnotations(evt, interactionType) {\n        const { renderingEngineId, viewportId, element, currentPoints } = evt.detail;\n        const toolGroup = getToolGroupForViewport(viewportId, renderingEngineId);\n        if (!toolGroup) {\n            return false;\n        }\n        const tools = toolGroup._toolInstances;\n        const annotationsToRemove = [];\n        for (const toolName in tools) {\n            const toolInstance = tools[toolName];\n            if (typeof toolInstance.isPointNearTool !== 'function' ||\n                typeof toolInstance.filterInteractableAnnotationsForElement !==\n                    'function') {\n                continue;\n            }\n            const annotations = getAnnotations(toolName, element);\n            const interactableAnnotations = toolInstance.filterInteractableAnnotationsForElement(element, annotations);\n            if (!interactableAnnotations) {\n                continue;\n            }\n            for (const annotation of interactableAnnotations) {\n                if (toolInstance.isPointNearTool(element, annotation, currentPoints.canvas, 10, interactionType)) {\n                    annotationsToRemove.push(annotation.annotationUID);\n                }\n            }\n        }\n        for (const annotationUID of annotationsToRemove) {\n            setAnnotationSelected(annotationUID);\n            const annotation = getAnnotation(annotationUID);\n            AnnotationTool.createAnnotationMemo(element, annotation, {\n                deleting: true,\n            });\n            removeAnnotation(annotationUID);\n        }\n        evt.preventDefault();\n        return true;\n    }\n}\nAnnotationEraserTool.toolName = 'Eraser';\nexport default AnnotationEraserTool;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, getRenderingEngine, } from '@cornerstonejs/core';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { Events } from '../../enums';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { growCut } from '../../utilities/segmentation';\nimport GrowCutBaseTool from '../base/GrowCutBaseTool';\nclass RegionSegmentTool extends GrowCutBaseTool {\n    static { this.toolName = 'RegionSegment'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            isPartialVolume: true,\n            positiveSeedVariance: 0.5,\n            negativeSeedVariance: 0.9,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const { world: currentWorldPoint } = currentPoints;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.growCutData.circleBorderPoint = currentWorldPoint;\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._endCallback = async (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.runGrowCut();\n            this._deactivateDraw(element);\n            this.growCutData = null;\n            resetElementCursor(element);\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    async preMouseDownCallback(evt) {\n        const eventData = evt.detail;\n        const { element, currentPoints } = eventData;\n        const { world: worldPoint } = currentPoints;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        await super.preMouseDownCallback(evt);\n        Object.assign(this.growCutData, {\n            circleCenterPoint: worldPoint,\n            circleBorderPoint: worldPoint,\n        });\n        this._activateDraw(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        return true;\n    }\n    async getGrowCutLabelmap(growCutData) {\n        const { segmentation: { referencedVolumeId }, renderingEngineId, viewportId, circleCenterPoint, circleBorderPoint, options, } = growCutData;\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n        const viewport = renderingEngine.getViewport(viewportId);\n        const worldCircleRadius = vec3.len(vec3.sub(vec3.create(), circleCenterPoint, circleBorderPoint));\n        const sphereInfo = {\n            center: circleCenterPoint,\n            radius: worldCircleRadius,\n        };\n        return growCut.runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options);\n    }\n    _activateDraw(element) {\n        element.addEventListener(Events.MOUSE_UP, this._endCallback);\n        element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n        element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this.growCutData) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const { segmentation: segmentationData, circleCenterPoint, circleBorderPoint, } = this.growCutData;\n        const canvasCenterPoint = viewport.worldToCanvas(circleCenterPoint);\n        const canvasBorderPoint = viewport.worldToCanvas(circleBorderPoint);\n        const vecCenterToBorder = vec2.sub(vec2.create(), canvasBorderPoint, canvasCenterPoint);\n        const circleRadius = vec2.len(vecCenterToBorder);\n        if (csUtils.isEqual(circleRadius, 0)) {\n            return;\n        }\n        const annotationUID = 'growcut';\n        const circleUID = '0';\n        const { color } = this.getSegmentStyle({\n            segmentationId: segmentationData.segmentationId,\n            segmentIndex: segmentationData.segmentIndex,\n            viewportId: viewport.id,\n        });\n        drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, canvasCenterPoint, circleRadius, {\n            color,\n        });\n    }\n}\nexport default RegionSegmentTool;\n","import { cache, utilities as csUtils, getEnabledElement, } from '@cornerstonejs/core';\nimport { growCut } from '../../utilities/segmentation';\nimport GrowCutBaseTool from '../base/GrowCutBaseTool';\nimport { calculateGrowCutSeeds } from '../../utilities/segmentation/growCut/runOneClickGrowCut';\nimport { ToolModes } from '../../enums';\nclass RegionSegmentPlusTool extends GrowCutBaseTool {\n    static { this.toolName = 'RegionSegmentPlus'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            isPartialVolume: false,\n            positiveSeedVariance: 0.4,\n            negativeSeedVariance: 0.9,\n            subVolumePaddingPercentage: 0.1,\n            islandRemoval: {\n                enabled: false,\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseTimer = null;\n        this.allowedToProceed = false;\n    }\n    mouseMoveCallback(evt) {\n        if (this.mode !== ToolModes.Active) {\n            return;\n        }\n        const eventData = evt.detail;\n        const { currentPoints, element } = eventData;\n        const { world: worldPoint } = currentPoints;\n        element.style.cursor = 'default';\n        if (this.mouseTimer !== null) {\n            window.clearTimeout(this.mouseTimer);\n            this.mouseTimer = null;\n        }\n        this.mouseTimer = window.setTimeout(() => {\n            this.onMouseStable(evt, worldPoint, element);\n        }, this.configuration.mouseStabilityDelay || 500);\n    }\n    async onMouseStable(evt, worldPoint, element) {\n        await super.preMouseDownCallback(evt);\n        const refVolume = cache.getVolume(this.growCutData.segmentation.referencedVolumeId);\n        const seeds = calculateGrowCutSeeds(refVolume, worldPoint, {}) || {\n            positiveSeedIndices: new Set(),\n            negativeSeedIndices: new Set(),\n        };\n        const { positiveSeedIndices, negativeSeedIndices } = seeds;\n        let cursor;\n        if (positiveSeedIndices.size / negativeSeedIndices.size > 20 ||\n            negativeSeedIndices.size < 30) {\n            cursor = 'not-allowed';\n            this.allowedToProceed = false;\n        }\n        else {\n            cursor = 'copy';\n            this.allowedToProceed = true;\n        }\n        const enabledElement = getEnabledElement(element);\n        if (element) {\n            element.style.cursor = cursor;\n            requestAnimationFrame(() => {\n                if (element.style.cursor !== cursor) {\n                    element.style.cursor = cursor;\n                }\n            });\n        }\n        if (this.allowedToProceed) {\n            this.seeds = seeds;\n        }\n        if (enabledElement && enabledElement.viewport) {\n            enabledElement.viewport.render();\n        }\n    }\n    async preMouseDownCallback(evt) {\n        if (!this.allowedToProceed) {\n            return false;\n        }\n        const eventData = evt.detail;\n        const { currentPoints, element } = eventData;\n        const enabledElement = getEnabledElement(element);\n        if (enabledElement) {\n            element.style.cursor = 'wait';\n            requestAnimationFrame(() => {\n                if (element.style.cursor !== 'wait') {\n                    element.style.cursor = 'wait';\n                }\n            });\n        }\n        const { world: worldPoint } = currentPoints;\n        await super.preMouseDownCallback(evt);\n        this.growCutData = csUtils.deepMerge(this.growCutData, {\n            worldPoint,\n            islandRemoval: {\n                worldIslandPoints: [worldPoint],\n            },\n        });\n        this.growCutData.worldPoint = worldPoint;\n        this.growCutData.islandRemoval = {\n            worldIslandPoints: [worldPoint],\n        };\n        await this.runGrowCut();\n        if (element) {\n            element.style.cursor = 'default';\n        }\n        return true;\n    }\n    getRemoveIslandData(growCutData) {\n        const { worldPoint } = growCutData;\n        return {\n            worldIslandPoints: [worldPoint],\n        };\n    }\n    async getGrowCutLabelmap(growCutData) {\n        const { segmentation: { referencedVolumeId }, worldPoint, options, } = growCutData;\n        const { subVolumePaddingPercentage } = this.configuration;\n        const mergedOptions = {\n            ...options,\n            subVolumePaddingPercentage,\n            seeds: this.seeds,\n        };\n        return growCut.runOneClickGrowCut({\n            referencedVolumeId,\n            worldPosition: worldPoint,\n            options: mergedOptions,\n        });\n    }\n}\nexport default RegionSegmentPlusTool;\n","import { vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, cache, getRenderingEngine, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport { drawPolyline as drawPolylineSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport { Events } from '../../enums';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { growCut } from '../../utilities/segmentation';\nimport GrowCutBaseTool from '../base/GrowCutBaseTool';\nconst NEGATIVE_PIXEL_RANGE = [-Infinity, -995];\nconst POSITIVE_PIXEL_RANGE = [0, 1900];\nconst ISLAND_PIXEL_RANGE = [1000, 1900];\nconst { transformWorldToIndex, transformIndexToWorld } = csUtils;\nclass WholeBodySegmentTool extends GrowCutBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            isPartialVolume: true,\n            positivePixelRange: POSITIVE_PIXEL_RANGE,\n            negativePixelRange: NEGATIVE_PIXEL_RANGE,\n            islandRemoval: {\n                enabled: true,\n                islandPixelRange: ISLAND_PIXEL_RANGE,\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const { world: currentWorldPoint } = currentPoints;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const linePoints = this._getHorizontalLineWorldPoints(enabledElement, currentWorldPoint);\n            this.growCutData.horizontalLines[1] = linePoints;\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._endCallback = async (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            await this.runGrowCut();\n            this._deactivateDraw(element);\n            this.growCutData = null;\n            resetElementCursor(element);\n            triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    async preMouseDownCallback(evt) {\n        const eventData = evt.detail;\n        const { element, currentPoints } = eventData;\n        const { world: worldPoint } = currentPoints;\n        const enabledElement = getEnabledElement(element);\n        const { viewport, renderingEngine } = enabledElement;\n        const linePoints = this._getHorizontalLineWorldPoints(enabledElement, worldPoint);\n        await super.preMouseDownCallback(evt);\n        this.growCutData.horizontalLines = [linePoints, linePoints];\n        this._activateDraw(element);\n        hideElementCursor(element);\n        triggerAnnotationRenderForViewportUIDs([viewport.id]);\n        return true;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this.growCutData) {\n            return;\n        }\n        const { segmentation: segmentationData, horizontalLines } = this.growCutData;\n        if (horizontalLines.length !== 2) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const { segmentationId, segmentIndex } = segmentationData;\n        const [line1, line2] = horizontalLines;\n        const [worldLine1P1, worldLine1P2] = line1;\n        const [worldLine2P1, worldLine2P2] = line2;\n        const canvasPoints = [\n            worldLine1P1,\n            worldLine1P2,\n            worldLine2P2,\n            worldLine2P1,\n        ].map((worldPoint) => viewport.worldToCanvas(worldPoint));\n        const annotationUID = 'growCutRect';\n        const squareGroupUID = '0';\n        const { color, fillColor, lineWidth, fillOpacity, lineDash } = this.getSegmentStyle({\n            segmentationId,\n            segmentIndex,\n            viewportId: viewport.id,\n        });\n        drawPolylineSvg(svgDrawingHelper, annotationUID, squareGroupUID, canvasPoints, {\n            color,\n            fillColor,\n            fillOpacity,\n            lineWidth,\n            lineDash,\n            closePath: true,\n        });\n    }\n    async getGrowCutLabelmap(growCutData) {\n        const { segmentation: { segmentIndex, referencedVolumeId }, renderingEngineId, viewportId, horizontalLines, } = growCutData;\n        const renderingEngine = getRenderingEngine(renderingEngineId);\n        const viewport = renderingEngine.getViewport(viewportId);\n        const [line1, line2] = horizontalLines;\n        const worldSquarePoints = [line1[0], line1[1], line2[1], line2[0]];\n        const referencedVolume = cache.getVolume(referencedVolumeId);\n        const { topLeft: worldTopLeft, bottomRight: worldBottomRight } = this._getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints);\n        const ijkTopLeft = transformWorldToIndex(referencedVolume.imageData, worldTopLeft);\n        const ijkBottomRight = transformWorldToIndex(referencedVolume.imageData, worldBottomRight);\n        const boundingBoxInfo = {\n            boundingBox: {\n                ijkTopLeft,\n                ijkBottomRight,\n            },\n        };\n        const config = this.configuration;\n        const options = {\n            positiveSeedValue: segmentIndex,\n            negativeSeedValue: 255,\n            negativePixelRange: config.negativePixelRange,\n            positivePixelRange: config.positivePixelRange,\n        };\n        return growCut.runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options);\n    }\n    getRemoveIslandData() {\n        const { segmentation: { segmentIndex, referencedVolumeId, labelmapVolumeId }, } = this.growCutData;\n        const referencedVolume = cache.getVolume(referencedVolumeId);\n        const labelmapVolume = cache.getVolume(labelmapVolumeId);\n        const referencedVolumeData = referencedVolume.voxelManager.getCompleteScalarDataArray();\n        const labelmapData = labelmapVolume.voxelManager.getCompleteScalarDataArray();\n        const { islandPixelRange } = this.configuration.islandRemoval;\n        const islandPointIndexes = [];\n        for (let i = 0, len = labelmapData.length; i < len; i++) {\n            if (labelmapData[i] !== segmentIndex) {\n                continue;\n            }\n            const pixelValue = referencedVolumeData[i];\n            if (pixelValue >= islandPixelRange[0] &&\n                pixelValue <= islandPixelRange[1]) {\n                islandPointIndexes.push(i);\n            }\n        }\n        return {\n            islandPointIndexes,\n        };\n    }\n    _activateDraw(element) {\n        element.addEventListener(Events.MOUSE_UP, this._endCallback);\n        element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n        element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n    }\n    _projectWorldPointAcrossSlices(viewport, worldEdgePoint, vecDirection) {\n        const volume = this._getViewportVolume(viewport);\n        const { dimensions } = volume;\n        const ijkPoint = transformWorldToIndex(volume.imageData, worldEdgePoint);\n        const axis = vecDirection.findIndex((n) => csUtils.isEqual(Math.abs(n), 1));\n        if (axis === -1) {\n            throw new Error('Non-orthogonal direction vector');\n        }\n        const ijkLineP1 = [...ijkPoint];\n        const ijkLineP2 = [...ijkPoint];\n        ijkLineP1[axis] = 0;\n        ijkLineP2[axis] = dimensions[axis] - 1;\n        return [ijkLineP1, ijkLineP2];\n    }\n    _getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldEdgePoint) {\n        const { viewPlaneNormal } = viewport.getCamera();\n        return this._projectWorldPointAcrossSlices(viewport, worldEdgePoint, viewPlaneNormal);\n    }\n    _getWorldCuboidCornerPoints(viewport, worldSquarePoints) {\n        const cuboidPoints = [];\n        const volume = this._getViewportVolume(viewport);\n        worldSquarePoints.forEach((worldSquarePoint) => {\n            const ijkEdgePoints = this._getCuboidIJKEdgePointsFromProjectedWorldPoint(viewport, worldSquarePoint);\n            const worldEdgePoints = ijkEdgePoints.map((ijkPoint) => transformIndexToWorld(volume.imageData, ijkPoint));\n            cuboidPoints.push(...worldEdgePoints);\n        });\n        return cuboidPoints;\n    }\n    _getWorldBoundingBoxFromProjectedSquare(viewport, worldSquarePoints) {\n        const worldCuboidPoints = this._getWorldCuboidCornerPoints(viewport, worldSquarePoints);\n        const topLeft = [...worldCuboidPoints[0]];\n        const bottomRight = [...worldCuboidPoints[0]];\n        worldCuboidPoints.forEach((worldPoint) => {\n            vec3.min(topLeft, topLeft, worldPoint);\n            vec3.max(bottomRight, bottomRight, worldPoint);\n        });\n        return { topLeft, bottomRight };\n    }\n    _getViewportVolume(viewport) {\n        if (!(viewport instanceof BaseVolumeViewport)) {\n            throw new Error('Viewport is not a BaseVolumeViewport');\n        }\n        const volumeId = viewport.getAllVolumeIds()[0];\n        return cache.getVolume(volumeId);\n    }\n    _getHorizontalLineIJKPoints(enabledElement, worldPoint) {\n        const { viewport } = enabledElement;\n        const volume = this._getViewportVolume(viewport);\n        const { dimensions } = volume;\n        const ijkPoint = transformWorldToIndex(volume.imageData, worldPoint);\n        const { viewUp, viewPlaneNormal } = viewport.getCamera();\n        const vecRow = vec3.cross(vec3.create(), viewUp, viewPlaneNormal);\n        const axis = vecRow.findIndex((n) => csUtils.isEqual(Math.abs(n), 1));\n        const ijkLineP1 = [...ijkPoint];\n        const ijkLineP2 = [...ijkPoint];\n        ijkLineP1[axis] = 0;\n        ijkLineP2[axis] = dimensions[axis] - 1;\n        return [ijkLineP1, ijkLineP2];\n    }\n    _getHorizontalLineWorldPoints(enabledElement, worldPoint) {\n        const { viewport } = enabledElement;\n        const volume = this._getViewportVolume(viewport);\n        const [ijkPoint1, ijkPoint2] = this._getHorizontalLineIJKPoints(enabledElement, worldPoint);\n        const worldPoint1 = transformIndexToWorld(volume.imageData, ijkPoint1);\n        const worldPoint2 = transformIndexToWorld(volume.imageData, ijkPoint2);\n        return [worldPoint1, worldPoint2];\n    }\n}\nWholeBodySegmentTool.toolName = 'WholeBodySegment';\nexport default WholeBodySegmentTool;\n","import { BaseVolumeViewport, cache, getEnabledElement, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { fillInsideRectangle } from './strategies/fillRectangle';\nimport { eraseInsideRectangle } from './strategies/eraseRectangle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawRect as drawRectSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { config as segmentationConfig, segmentLocking, segmentIndex as segmentIndexController, activeSegmentation, } from '../../stateManagement/segmentation';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, } from '../../stateManagement/segmentation/segmentationState';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nclass RectangleScissorsTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideRectangle,\n                ERASE_INSIDE: eraseInsideRectangle,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeLabelmapSegmentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeLabelmapSegmentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeLabelmapSegmentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            const { representationData } = getSegmentation(segmentationId);\n            const labelmapData = representationData[SegmentationRepresentations.Labelmap];\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                },\n            };\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = labelmapData;\n                const segmentation = cache.getVolume(volumeId);\n                this.editData = {\n                    ...this.editData,\n                    volumeId,\n                    referencedVolumeId: segmentation.referencedVolumeId,\n                };\n            }\n            else {\n                const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                this.editData = {\n                    ...this.editData,\n                    imageId: segmentationImageId,\n                };\n            }\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex } = this.editData;\n            const { data } = annotation;\n            const { currentPoints } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n            const worldPos = currentPoints.world;\n            const { points } = data.handles;\n            points[handleIndex] = [...worldPos];\n            let bottomLeftCanvas;\n            let bottomRightCanvas;\n            let topLeftCanvas;\n            let topRightCanvas;\n            let bottomLeftWorld;\n            let bottomRightWorld;\n            let topLeftWorld;\n            let topRightWorld;\n            switch (handleIndex) {\n                case 0:\n                case 3:\n                    bottomLeftCanvas = worldToCanvas(points[0]);\n                    topRightCanvas = worldToCanvas(points[3]);\n                    bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                    topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                    bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                    topLeftWorld = canvasToWorld(topLeftCanvas);\n                    points[1] = bottomRightWorld;\n                    points[2] = topLeftWorld;\n                    break;\n                case 1:\n                case 2:\n                    bottomRightCanvas = worldToCanvas(points[1]);\n                    topLeftCanvas = worldToCanvas(points[2]);\n                    bottomLeftCanvas = [\n                        topLeftCanvas[0],\n                        bottomRightCanvas[1],\n                    ];\n                    topRightCanvas = [bottomRightCanvas[0], topLeftCanvas[1]];\n                    bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                    topRightWorld = canvasToWorld(topRightCanvas);\n                    points[0] = bottomLeftWorld;\n                    points[3] = topRightWorld;\n                    break;\n            }\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n                createMemo: this.createMemo.bind(this),\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n            this.doneEditMemo();\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const rectangleUID = '0';\n            drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nRectangleScissorsTool.toolName = 'RectangleScissor';\nexport default RectangleScissorsTool;\n","import { BaseVolumeViewport, cache, getEnabledElement, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { fillInsideCircle } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { Events } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { segmentLocking, activeSegmentation, segmentIndex as segmentIndexController, config as segmentationConfig, } from '../../stateManagement/segmentation';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, } from '../../stateManagement/segmentation/segmentationState';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nclass CircleScissorsTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideCircle,\n                ERASE_INSIDE: eraseInsideCircle,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeLabelmapSegmentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeLabelmapSegmentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeLabelmapSegmentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            const { representationData } = getSegmentation(segmentationId);\n            const labelmapData = representationData.Labelmap;\n            if (!labelmapData) {\n                throw new Error('No labelmap data found for the active segmentation, create one before using scissors tool');\n            }\n            const annotation = {\n                invalidated: true,\n                highlighted: true,\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    isDrawing: true,\n                    cachedStats: {},\n                },\n            };\n            const viewportIdsToRender = [viewport.id];\n            this.editData = {\n                annotation,\n                centerCanvas: canvasPos,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = labelmapData;\n                const segmentation = cache.getVolume(volumeId);\n                this.editData = {\n                    ...this.editData,\n                    volumeId,\n                    referencedVolumeId: segmentation.referencedVolumeId,\n                };\n            }\n            else {\n                const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                this.editData = {\n                    ...this.editData,\n                    imageId: segmentationImageId,\n                };\n            }\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const radius = Math.sqrt(dX * dX + dY * dY);\n            const bottomCanvas = [\n                centerCanvas[0],\n                centerCanvas[1] + radius,\n            ];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];\n            const leftCanvas = [\n                centerCanvas[0] - radius,\n                centerCanvas[1],\n            ];\n            const rightCanvas = [\n                centerCanvas[0] + radius,\n                centerCanvas[1],\n            ];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            const { viewPlaneNormal, viewUp } = annotation.metadata;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n                viewPlaneNormal,\n                viewUp,\n                createMemo: this.createMemo.bind(this),\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n            this.doneEditMemo();\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { viewportIdsToRender } = this.editData;\n            if (!viewportIdsToRender.includes(viewport.id)) {\n                return renderStatus;\n            }\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const bottom = canvasCoordinates[0];\n            const top = canvasCoordinates[1];\n            const center = [\n                Math.floor((bottom[0] + top[0]) / 2),\n                Math.floor((bottom[1] + top[1]) / 2),\n            ];\n            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const circleUID = '0';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nCircleScissorsTool.toolName = 'CircleScissor';\nexport default CircleScissorsTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { fillInsideSphere } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { config as segmentationConfig, segmentLocking, segmentIndex as segmentIndexController, activeSegmentation, } from '../../stateManagement/segmentation';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nclass SphereScissorsTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE: fillInsideSphere,\n                ERASE_INSIDE: eraseInsideSphere,\n            },\n            defaultStrategy: 'FILL_INSIDE',\n            activeStrategy: 'FILL_INSIDE',\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            if (this.isDrawing === true) {\n                return;\n            }\n            this.doneEditMemo();\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const canvasPos = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeSegmentationRepresentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeSegmentationRepresentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const segmentColor = segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n            this.isDrawing = true;\n            const annotation = {\n                metadata: {\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    referencedImageId: '',\n                    toolName: this.getToolName(),\n                    segmentColor,\n                },\n                data: {\n                    invalidated: true,\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {},\n                    highlighted: true,\n                },\n            };\n            const viewportIdsToRender = [viewport.id];\n            this.editData = {\n                annotation,\n                centerCanvas: canvasPos,\n                segmentIndex,\n                segmentationId,\n                segmentsLocked,\n                segmentColor,\n                toolGroupId: this.toolGroupId,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n                volumeId: null,\n                referencedVolumeId: null,\n                imageId: null,\n            };\n            const { representationData } = getSegmentation(segmentationId);\n            const editData = this.getEditData({\n                viewport,\n                representationData,\n                segmentsLocked,\n                segmentationId,\n            });\n            this.editData = {\n                ...this.editData,\n                ...editData,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return true;\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { currentPoints } = eventDetail;\n            const currentCanvasPoints = currentPoints.canvas;\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine, viewport } = enabledElement;\n            const { canvasToWorld } = viewport;\n            const { annotation, viewportIdsToRender, centerCanvas } = this.editData;\n            const { data } = annotation;\n            const dX = Math.abs(currentCanvasPoints[0] - centerCanvas[0]);\n            const dY = Math.abs(currentCanvasPoints[1] - centerCanvas[1]);\n            const radius = Math.sqrt(dX * dX + dY * dY);\n            const bottomCanvas = [\n                centerCanvas[0],\n                centerCanvas[1] + radius,\n            ];\n            const topCanvas = [centerCanvas[0], centerCanvas[1] - radius];\n            const leftCanvas = [\n                centerCanvas[0] - radius,\n                centerCanvas[1],\n            ];\n            const rightCanvas = [\n                centerCanvas[0] + radius,\n                centerCanvas[1],\n            ];\n            data.handles.points = [\n                canvasToWorld(bottomCanvas),\n                canvasToWorld(topCanvas),\n                canvasToWorld(leftCanvas),\n                canvasToWorld(rightCanvas),\n            ];\n            annotation.invalidated = true;\n            this.editData.hasMoved = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, newAnnotation, hasMoved, segmentIndex, segmentsLocked, } = this.editData;\n            const { data } = annotation;\n            const { viewPlaneNormal, viewUp } = annotation.metadata;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const operationData = {\n                ...this.editData,\n                points: data.handles.points,\n                segmentIndex,\n                segmentsLocked,\n                viewPlaneNormal,\n                viewUp,\n                createMemo: this.createMemo.bind(this),\n            };\n            this.editData = null;\n            this.isDrawing = false;\n            this.applyActiveStrategy(enabledElement, operationData);\n            this.doneEditMemo();\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            if (!this.editData) {\n                return renderStatus;\n            }\n            const { viewport } = enabledElement;\n            const { viewportIdsToRender } = this.editData;\n            if (!viewportIdsToRender.includes(viewport.id)) {\n                return renderStatus;\n            }\n            const { annotation } = this.editData;\n            const toolMetadata = annotation.metadata;\n            const annotationUID = annotation.annotationUID;\n            const data = annotation.data;\n            const { points } = data.handles;\n            const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n            const bottom = canvasCoordinates[0];\n            const top = canvasCoordinates[1];\n            const center = [\n                Math.floor((bottom[0] + top[0]) / 2),\n                Math.floor((bottom[1] + top[1]) / 2),\n            ];\n            const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n            const color = `rgb(${toolMetadata.segmentColor.slice(0, 3)})`;\n            if (!viewport.getRenderingEngine()) {\n                console.warn('Rendering Engine has been destroyed');\n                return renderStatus;\n            }\n            const circleUID = '0';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                color,\n            });\n            renderStatus = true;\n            return renderStatus;\n        };\n    }\n}\nSphereScissorsTool.toolName = 'SphereScissor';\nexport default SphereScissorsTool;\n","import { StackViewport, cache, getEnabledElement, utilities as csUtils, utilities as coreUtils, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { addAnnotation, removeAnnotation, getAnnotations, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { drawCircle as drawCircleSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport throttle from '../../utilities/throttle';\nimport debounce from '../../utilities/debounce';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { hideElementCursor, resetElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport CircleROITool from '../annotation/CircleROITool';\nimport { getCanvasCircleCorners, getCanvasCircleRadius, } from '../../utilities/math/circle';\nimport { getCalibratedLengthUnitsAndScale, getCalibratedAspect, } from '../../utilities/getCalibratedUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { pointInEllipse } from '../../utilities/math/ellipse';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { filterAnnotationsWithinSamePlane } from '../../utilities/planar';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nconst { transformWorldToIndex } = csUtils;\nclass CircleROIStartEndThresholdTool extends CircleROITool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            simplified: true,\n            storePointData: false,\n            numSlicesToPropagate: 10,\n            calculatePointsInsideVolume: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n            showTextBox: false,\n            throttleTimeout: 100,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isHandleOutsideImage = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport, renderingEngine } = enabledElement;\n            this.isDrawing = true;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal, viewUp } = camera;\n            let referencedImageId, imageVolume, volumeId;\n            if (viewport instanceof StackViewport) {\n                throw new Error('Stack Viewport Not implemented');\n            }\n            else {\n                const targetId = this.getTargetId(viewport);\n                volumeId = csUtils.getVolumeId(targetId);\n                imageVolume = cache.getVolume(volumeId);\n                referencedImageId = csUtils.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n            }\n            const spacingInNormal = csUtils.getSpacingInNormalDirection(imageVolume, viewPlaneNormal);\n            const startCoord = this._getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal);\n            const endCoord = this._getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal);\n            const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n            let points;\n            if (this.configuration.simplified) {\n                points = [[...worldPos], [...worldPos]];\n            }\n            else {\n                points = [\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                    [...worldPos],\n                ];\n            }\n            const annotation = {\n                highlighted: true,\n                invalidated: true,\n                metadata: {\n                    toolName: this.getToolName(),\n                    viewPlaneNormal: [...viewPlaneNormal],\n                    viewUp: [...viewUp],\n                    FrameOfReferenceUID,\n                    referencedImageId,\n                    volumeId,\n                    spacingInNormal,\n                    enabledElement,\n                },\n                data: {\n                    label: '',\n                    startCoordinate: startCoord,\n                    endCoordinate: endCoord,\n                    handles: {\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                        points,\n                        activeHandleIndex: null,\n                    },\n                    cachedStats: {\n                        pointsInVolume: [],\n                        projectionPoints: [],\n                        statistics: [],\n                    },\n                    labelmapUID: null,\n                },\n            };\n            this._computeProjectionPoints(annotation, imageVolume);\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            annotation.highlighted = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { metadata } = annotation;\n            const { enabledElement } = metadata;\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            const targetId = this.getTargetId(enabledElement.viewport);\n            const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n            this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            else {\n                triggerAnnotationModified(annotation, element);\n            }\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            let annotations = getAnnotations(this.getToolName(), viewport.element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = filterAnnotationsWithinSamePlane(annotations, viewport.getCamera());\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data, metadata } = annotation;\n                const { startCoordinate, endCoordinate } = data;\n                const { points, activeHandleIndex } = data.handles;\n                const { enabledElement: annotationEnabledElement } = metadata;\n                styleSpecifier.annotationUID = annotationUID;\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const center = canvasCoordinates[0];\n                const radius = getCanvasCircleRadius([\n                    canvasCoordinates[0],\n                    canvasCoordinates[1],\n                ]);\n                const { centerPointRadius } = this.configuration;\n                const canvasCorners = getCanvasCircleCorners([\n                    canvasCoordinates[0],\n                    canvasCoordinates[1],\n                ]);\n                const focalPoint = viewport.getCamera().focalPoint;\n                const viewplaneNormal = viewport.getCamera().viewPlaneNormal;\n                let tempStartCoordinate = startCoordinate;\n                let tempEndCoordinate = endCoordinate;\n                if (Array.isArray(startCoordinate)) {\n                    tempStartCoordinate = this._getCoordinateForViewplaneNormal(tempStartCoordinate, viewplaneNormal);\n                    data.startCoordinate = tempStartCoordinate;\n                }\n                if (Array.isArray(endCoordinate)) {\n                    tempEndCoordinate = this._getCoordinateForViewplaneNormal(tempEndCoordinate, viewplaneNormal);\n                    data.endCoordinate = tempEndCoordinate;\n                }\n                const roundedStartCoordinate = coreUtils.roundToPrecision(data.startCoordinate);\n                const roundedEndCoordinate = coreUtils.roundToPrecision(data.endCoordinate);\n                const cameraCoordinate = this._getCoordinateForViewplaneNormal(focalPoint, viewplaneNormal);\n                const roundedCameraCoordinate = coreUtils.roundToPrecision(cameraCoordinate);\n                if (roundedCameraCoordinate <\n                    Math.min(roundedStartCoordinate, roundedEndCoordinate) ||\n                    roundedCameraCoordinate >\n                        Math.max(roundedStartCoordinate, roundedEndCoordinate)) {\n                    continue;\n                }\n                const middleCoordinate = coreUtils.roundToPrecision((data.startCoordinate + data.endCoordinate) / 2);\n                let isMiddleSlice = false;\n                if (roundedCameraCoordinate === middleCoordinate) {\n                    isMiddleSlice = true;\n                }\n                data.handles.points[0][this._getIndexOfCoordinatesForViewplaneNormal(viewplaneNormal)] = middleCoordinate;\n                const iteratorVolumeIDs = annotationEnabledElement.viewport?.volumeIds.values();\n                for (const volumeId of iteratorVolumeIDs) {\n                    if (annotation.invalidated &&\n                        annotation.metadata.volumeId === volumeId) {\n                        this._throttledCalculateCachedStats(annotation, annotationEnabledElement);\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null &&\n                    isMiddleSlice) {\n                    if (this.configuration.simplified) {\n                        activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                    }\n                    else {\n                        activeHandleCanvasCoords = canvasCoordinates;\n                    }\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                let lineWidthToUse = lineWidth;\n                let lineDashToUse = lineDash;\n                if (isMiddleSlice) {\n                    lineWidthToUse = lineWidth;\n                    lineDashToUse = [];\n                }\n                else {\n                    lineDashToUse = [5, 5];\n                }\n                const circleUID = '0';\n                drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n                    color,\n                    lineDash: lineDashToUse,\n                    lineWidth: lineWidthToUse,\n                });\n                if (centerPointRadius > 0) {\n                    if (radius > 3 * centerPointRadius) {\n                        drawCircleSvg(svgDrawingHelper, annotationUID, `${circleUID}-center`, center, centerPointRadius, {\n                            color,\n                            lineDash,\n                            lineWidth,\n                        });\n                    }\n                }\n                renderStatus = true;\n                if (this.configuration.showTextBox) {\n                    const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                    if (!options.visibility) {\n                        data.handles.textBox = {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        };\n                        continue;\n                    }\n                    const textLines = this.configuration.getTextLines(data, { metadata });\n                    if (!textLines || textLines.length === 0) {\n                        continue;\n                    }\n                    let canvasTextBoxCoords;\n                    if (!data.handles.textBox.hasMoved) {\n                        canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCorners);\n                        data.handles.textBox.worldPosition =\n                            viewport.canvasToWorld(canvasTextBoxCoords);\n                    }\n                    const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                    const textBoxUID = '1';\n                    const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, [canvasCoordinates[0], canvasCoordinates[1]], {}, options);\n                    const { x: left, y: top, width, height } = boundingBox;\n                    data.handles.textBox.worldBoundingBox = {\n                        topLeft: viewport.canvasToWorld([left, top]),\n                        topRight: viewport.canvasToWorld([left + width, top]),\n                        bottomLeft: viewport.canvasToWorld([left, top + height]),\n                        bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                    };\n                }\n            }\n            return renderStatus;\n        };\n        if (this.configuration.calculatePointsInsideVolume) {\n            this._throttledCalculateCachedStats = throttle(this._calculateCachedStatsTool, this.configuration.throttleTimeout, { trailing: true });\n        }\n        else {\n            this._throttledCalculateCachedStats = debounce(this._calculateCachedStatsTool, this.configuration.throttleTimeout);\n        }\n    }\n    _computeProjectionPoints(annotation, imageVolume) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, spacingInNormal } = metadata;\n        const { startCoordinate, endCoordinate } = data;\n        const { points } = data.handles;\n        const projectionAxisIndex = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n        const startWorld = vec3.clone(points[0]);\n        startWorld[projectionAxisIndex] = startCoordinate;\n        const endWorld = vec3.clone(points[0]);\n        endWorld[projectionAxisIndex] = endCoordinate;\n        const direction = vec3.create();\n        vec3.subtract(direction, endWorld, startWorld);\n        const distance = vec3.length(direction);\n        if (distance === 0) {\n            const handlesOnStartPlane = points.map((p) => {\n                const newPoint = vec3.clone(p);\n                newPoint[projectionAxisIndex] = startCoordinate;\n                return Array.from(newPoint);\n            });\n            data.cachedStats.projectionPoints = [handlesOnStartPlane];\n            return;\n        }\n        vec3.normalize(direction, direction);\n        const handlesToStart = csUtils.deepClone(points);\n        handlesToStart[0][projectionAxisIndex] = startCoordinate;\n        handlesToStart[1][projectionAxisIndex] = startCoordinate;\n        const newProjectionPoints = [];\n        for (let dist = 0; dist <= distance + 1e-6; dist += spacingInNormal) {\n            newProjectionPoints.push(handlesToStart.map((point) => {\n                const newPoint = vec3.create();\n                vec3.scaleAndAdd(newPoint, point, direction, dist);\n                return Array.from(newPoint);\n            }));\n        }\n        data.cachedStats.projectionPoints = newProjectionPoints;\n    }\n    _computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement) {\n        const { data, metadata } = annotation;\n        const { viewPlaneNormal, viewUp } = metadata;\n        const { viewport } = enabledElement;\n        const projectionPoints = data.cachedStats.projectionPoints;\n        const pointsInsideVolume = [[]];\n        const image = this.getTargetImageData(targetId);\n        const canvasCoordinates = data.handles.points.map((p) => viewport.worldToCanvas(p));\n        const baseTopLeftCanvas = getCanvasCircleCorners([\n            canvasCoordinates[0],\n            canvasCoordinates[1],\n        ])[0];\n        const baseBottomRightCanvas = getCanvasCircleCorners([\n            canvasCoordinates[0],\n            canvasCoordinates[1],\n        ])[1];\n        const basePos1 = viewport.canvasToWorld(baseTopLeftCanvas);\n        const basePos2 = viewport.canvasToWorld(baseBottomRightCanvas);\n        const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, basePos1, basePos2);\n        const measureInfo = getCalibratedLengthUnitsAndScale(image, data.handles.points);\n        const aspect = getCalibratedAspect(image);\n        const area = Math.abs(Math.PI *\n            (worldWidth / measureInfo.scale / 2) *\n            (worldHeight / aspect / measureInfo.scale / 2));\n        const modalityUnitOptions = {\n            isPreScaled: isViewportPreScaled(viewport, targetId),\n            isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n        };\n        const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);\n        for (let i = 0; i < projectionPoints.length; i++) {\n            if (!imageVolume) {\n                continue;\n            }\n            const centerWorld = projectionPoints[i][0];\n            const currentCanvasCoordinates = projectionPoints[i].map((p) => viewport.worldToCanvas(p));\n            const [topLeftCanvas, bottomRightCanvas] = (getCanvasCircleCorners([\n                currentCanvasCoordinates[0],\n                currentCanvasCoordinates[1],\n            ]));\n            const topLeftWorld = viewport.canvasToWorld(topLeftCanvas);\n            const bottomRightWorld = viewport.canvasToWorld(bottomRightCanvas);\n            const worldPos1 = topLeftWorld;\n            const worldPos2 = bottomRightWorld;\n            const { dimensions, imageData, voxelManager } = imageVolume;\n            const worldPos1Index = transformWorldToIndex(imageData, worldPos1);\n            const worldProjectionPointIndex = transformWorldToIndex(imageData, centerWorld);\n            const indexOfProjection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n            worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n            worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n            worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n            worldPos1Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            const worldPos2Index = transformWorldToIndex(imageData, worldPos2);\n            worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n            worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n            worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n            worldPos2Index[indexOfProjection] =\n                worldProjectionPointIndex[indexOfProjection];\n            if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                const boundsIJK = [\n                    [iMin, iMax],\n                    [jMin, jMax],\n                    [kMin, kMax],\n                ];\n                const center = centerWorld;\n                const ellipseObj = {\n                    center,\n                    xRadius: Math.abs(topLeftWorld[0] - bottomRightWorld[0]) / 2,\n                    yRadius: Math.abs(topLeftWorld[1] - bottomRightWorld[1]) / 2,\n                    zRadius: Math.abs(topLeftWorld[2] - bottomRightWorld[2]) / 2,\n                };\n                const pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                    isInObject: (pointLPS) => pointInEllipse(ellipseObj, pointLPS),\n                    boundsIJK,\n                    imageData,\n                    returnPoints: this.configuration.storePointData,\n                });\n                pointsInsideVolume.push(pointsInShape);\n            }\n        }\n        const stats = this.configuration.statsCalculator.getStatistics();\n        data.cachedStats.pointsInVolume = pointsInsideVolume;\n        data.cachedStats.statistics = {\n            Modality: metadata.Modality,\n            area,\n            mean: stats.mean?.value,\n            stdDev: stats.stdDev?.value,\n            max: stats.max?.value,\n            statsArray: stats.array,\n            areaUnit: measureInfo.areaUnit,\n            modalityUnit,\n        };\n    }\n    _calculateCachedStatsTool(annotation, enabledElement) {\n        const data = annotation.data;\n        const { viewport } = enabledElement;\n        const { cachedStats } = data;\n        const targetId = this.getTargetId(viewport);\n        const imageVolume = cache.getVolume(targetId.split(/volumeId:|\\?/)[1]);\n        this._computeProjectionPoints(annotation, imageVolume);\n        this._computePointsInsideVolume(annotation, imageVolume, targetId, enabledElement);\n        annotation.invalidated = false;\n        triggerAnnotationModified(annotation, viewport.element);\n        return cachedStats;\n    }\n    _getStartCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {\n        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n        const numSlicesToPropagateFromStart = Math.round(numSlicesToPropagate / 2);\n        const startPos = vec3.create();\n        vec3.scaleAndAdd(startPos, worldPos, viewPlaneNormal, numSlicesToPropagateFromStart * -spacingInNormal);\n        const startCoord = this._getCoordinateForViewplaneNormal(startPos, viewPlaneNormal);\n        return startCoord;\n    }\n    _getEndCoordinate(worldPos, spacingInNormal, viewPlaneNormal) {\n        const numSlicesToPropagate = this.configuration.numSlicesToPropagate;\n        const numSlicesToPropagateToEnd = numSlicesToPropagate - Math.round(numSlicesToPropagate / 2);\n        const endPos = vec3.create();\n        vec3.scaleAndAdd(endPos, worldPos, viewPlaneNormal, numSlicesToPropagateToEnd * spacingInNormal);\n        const endCoord = this._getCoordinateForViewplaneNormal(endPos, viewPlaneNormal);\n        return endCoord;\n    }\n    _getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal) {\n        const viewplaneNormalAbs = [\n            Math.abs(viewPlaneNormal[0]),\n            Math.abs(viewPlaneNormal[1]),\n            Math.abs(viewPlaneNormal[2]),\n        ];\n        const indexOfDirection = viewplaneNormalAbs.indexOf(Math.max(...viewplaneNormalAbs));\n        return indexOfDirection;\n    }\n    _getCoordinateForViewplaneNormal(pos, viewPlaneNormal) {\n        const indexOfDirection = this._getIndexOfCoordinatesForViewplaneNormal(viewPlaneNormal);\n        return pos[indexOfDirection];\n    }\n}\nfunction defaultGetTextLines(data, _context = {}) {\n    const cachedVolumeStats = data.cachedStats.statistics;\n    const { area, mean, max, stdDev, areaUnit, modalityUnit } = cachedVolumeStats;\n    if (mean === undefined) {\n        return;\n    }\n    const textLines = [];\n    textLines.push(`Area: ${csUtils.roundNumber(area)} ${areaUnit}`);\n    textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    return textLines;\n}\nCircleROIStartEndThresholdTool.toolName = 'CircleROIStartEndThreshold';\nexport default CircleROIStartEndThresholdTool;\n","import { cache, getEnabledElement, utilities as csUtils, BaseVolumeViewport, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { segmentLocking, activeSegmentation, segmentIndex as segmentIndexController, } from '../../stateManagement/segmentation';\nimport floodFill from '../../utilities/segmentation/floodFill';\nimport { getCurrentLabelmapImageIdForViewport, getSegmentation, } from '../../stateManagement/segmentation/segmentationState';\nconst { transformWorldToIndex, isEqual } = csUtils;\nclass PaintFillTool extends BaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n    }) {\n        super(toolProps, defaultToolProps);\n        this.preMouseDownCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const camera = viewport.getCamera();\n            const { viewPlaneNormal } = camera;\n            const activeSegmentationRepresentation = activeSegmentation.getActiveSegmentation(viewport.id);\n            if (!activeSegmentationRepresentation) {\n                throw new Error('No active segmentation detected, create one before using scissors tool');\n            }\n            const { segmentationId } = activeSegmentationRepresentation;\n            const segmentIndex = segmentIndexController.getActiveSegmentIndex(segmentationId);\n            const segmentsLocked = segmentLocking.getLockedSegmentIndices(segmentationId);\n            const { representationData } = getSegmentation(segmentationId);\n            let dimensions;\n            let direction;\n            let index;\n            let voxelManager;\n            this.doneEditMemo();\n            if (viewport instanceof BaseVolumeViewport) {\n                const { volumeId } = representationData[SegmentationRepresentations.Labelmap];\n                const segmentation = cache.getVolume(volumeId);\n                ({ dimensions, direction } = segmentation);\n                voxelManager = segmentation.voxelManager;\n                index = transformWorldToIndex(segmentation.imageData, worldPos);\n            }\n            else {\n                const currentSegmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n                if (!currentSegmentationImageId) {\n                    throw new Error('No active segmentation imageId detected, create one before using scissors tool');\n                }\n                const { imageData } = viewport.getImageData();\n                dimensions = imageData.getDimensions();\n                direction = imageData.getDirection();\n                const image = cache.getImage(currentSegmentationImageId);\n                voxelManager = image.voxelManager;\n                index = transformWorldToIndex(imageData, worldPos);\n            }\n            const fixedDimension = this.getFixedDimension(viewPlaneNormal, direction);\n            if (fixedDimension === undefined) {\n                console.warn('Oblique paint fill not yet supported');\n                return;\n            }\n            const { floodFillGetter, getLabelValue, getScalarDataPositionFromPlane, inPlaneSeedPoint, fixedDimensionValue, } = this.generateHelpers(voxelManager, dimensions, index, fixedDimension);\n            if (index[0] < 0 ||\n                index[0] >= dimensions[0] ||\n                index[1] < 0 ||\n                index[1] >= dimensions[1] ||\n                index[2] < 0 ||\n                index[2] >= dimensions[2]) {\n                return;\n            }\n            const clickedLabelValue = getLabelValue(index[0], index[1], index[2]);\n            if (segmentsLocked.includes(clickedLabelValue)) {\n                return;\n            }\n            const floodFillResult = floodFill(floodFillGetter, inPlaneSeedPoint);\n            const { flooded } = floodFillResult;\n            flooded.forEach((index) => {\n                const scalarDataIndex = getScalarDataPositionFromPlane(index[0], index[1]);\n                voxelManager.setAtIndex(scalarDataIndex, segmentIndex);\n            });\n            const framesModified = this.getFramesModified(fixedDimension, fixedDimensionValue, floodFillResult);\n            triggerSegmentationDataModified(segmentationId, framesModified);\n            return true;\n        };\n        this.getFramesModified = (fixedDimension, fixedDimensionValue, floodFillResult) => {\n            const { flooded: boundaries } = floodFillResult;\n            if (fixedDimension === 2) {\n                return [fixedDimensionValue];\n            }\n            let minJ = Infinity;\n            let maxJ = -Infinity;\n            for (let b = 0; b < boundaries.length; b++) {\n                const j = boundaries[b][1];\n                if (j < minJ) {\n                    minJ = j;\n                }\n                if (j > maxJ) {\n                    maxJ = j;\n                }\n            }\n            const framesModified = [];\n            for (let frame = minJ; frame <= maxJ; frame++) {\n                framesModified.push(frame);\n            }\n            return framesModified;\n        };\n        this.generateHelpers = (voxelManager, dimensions, seedIndex3D, fixedDimension = 2) => {\n            let fixedDimensionValue;\n            let inPlaneSeedPoint;\n            switch (fixedDimension) {\n                case 0:\n                    fixedDimensionValue = seedIndex3D[0];\n                    inPlaneSeedPoint = [seedIndex3D[1], seedIndex3D[2]];\n                    break;\n                case 1:\n                    fixedDimensionValue = seedIndex3D[1];\n                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[2]];\n                    break;\n                case 2:\n                    fixedDimensionValue = seedIndex3D[2];\n                    inPlaneSeedPoint = [seedIndex3D[0], seedIndex3D[1]];\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            const getScalarDataPosition = (x, y, z) => {\n                return voxelManager.toIndex([x, y, z]);\n            };\n            const getLabelValue = (x, y, z) => {\n                return voxelManager.getAtIJK(x, y, z);\n            };\n            const floodFillGetter = this.generateFloodFillGetter(dimensions, fixedDimension, fixedDimensionValue, getLabelValue);\n            const getScalarDataPositionFromPlane = this.generateGetScalarDataPositionFromPlane(getScalarDataPosition, fixedDimension, fixedDimensionValue);\n            return {\n                getScalarDataPositionFromPlane,\n                getLabelValue,\n                floodFillGetter,\n                inPlaneSeedPoint,\n                fixedDimensionValue,\n            };\n        };\n        this.generateFloodFillGetter = (dimensions, fixedDimension, fixedDimensionValue, getLabelValue) => {\n            let floodFillGetter;\n            switch (fixedDimension) {\n                case 0:\n                    floodFillGetter = (y, z) => {\n                        if (y >= dimensions[1] || y < 0 || z >= dimensions[2] || z < 0) {\n                            return;\n                        }\n                        return getLabelValue(fixedDimensionValue, y, z);\n                    };\n                    break;\n                case 1:\n                    floodFillGetter = (x, z) => {\n                        if (x >= dimensions[0] || x < 0 || z >= dimensions[2] || z < 0) {\n                            return;\n                        }\n                        return getLabelValue(x, fixedDimensionValue, z);\n                    };\n                    break;\n                case 2:\n                    floodFillGetter = (x, y) => {\n                        if (x >= dimensions[0] || x < 0 || y >= dimensions[1] || y < 0) {\n                            return;\n                        }\n                        return getLabelValue(x, y, fixedDimensionValue);\n                    };\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            return floodFillGetter;\n        };\n        this.generateGetScalarDataPositionFromPlane = (getScalarDataPosition, fixedDimension, fixedDimensionValue) => {\n            let getScalarDataPositionFromPlane;\n            switch (fixedDimension) {\n                case 0:\n                    getScalarDataPositionFromPlane = (y, z) => {\n                        return getScalarDataPosition(fixedDimensionValue, y, z);\n                    };\n                    break;\n                case 1:\n                    getScalarDataPositionFromPlane = (x, z) => {\n                        return getScalarDataPosition(x, fixedDimensionValue, z);\n                    };\n                    break;\n                case 2:\n                    getScalarDataPositionFromPlane = (x, y) => {\n                        return getScalarDataPosition(x, y, fixedDimensionValue);\n                    };\n                    break;\n                default:\n                    throw new Error(`Invalid fixedDimension: ${fixedDimension}`);\n            }\n            return getScalarDataPositionFromPlane;\n        };\n    }\n    getFixedDimension(viewPlaneNormal, direction) {\n        const xDirection = direction.slice(0, 3);\n        const yDirection = direction.slice(3, 6);\n        const zDirection = direction.slice(6, 9);\n        const absoluteOfViewPlaneNormal = [\n            Math.abs(viewPlaneNormal[0]),\n            Math.abs(viewPlaneNormal[1]),\n            Math.abs(viewPlaneNormal[2]),\n        ];\n        const absoluteOfXDirection = [\n            Math.abs(xDirection[0]),\n            Math.abs(xDirection[1]),\n            Math.abs(xDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfXDirection)) {\n            return 0;\n        }\n        const absoluteOfYDirection = [\n            Math.abs(yDirection[0]),\n            Math.abs(yDirection[1]),\n            Math.abs(yDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfYDirection)) {\n            return 1;\n        }\n        const absoluteOfZDirection = [\n            Math.abs(zDirection[0]),\n            Math.abs(zDirection[1]),\n            Math.abs(zDirection[2]),\n        ];\n        if (isEqual(absoluteOfViewPlaneNormal, absoluteOfZDirection)) {\n            return 2;\n        }\n    }\n}\nPaintFillTool.toolName = 'PaintFill';\nexport default PaintFillTool;\n","import vtkOrientationMarkerWidget from '@kitware/vtk.js/Interaction/Widgets/OrientationMarkerWidget';\nimport vtkAnnotatedCubeActor from '@kitware/vtk.js/Rendering/Core/AnnotatedCubeActor';\nimport vtkAxesActor from '@kitware/vtk.js/Rendering/Core/AxesActor';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkXMLPolyDataReader from '@kitware/vtk.js/IO/XML/XMLPolyDataReader';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport { BaseTool } from './base';\nimport { Enums, eventTarget, getEnabledElementByIds, getRenderingEngines, } from '@cornerstonejs/core';\nimport { filterViewportsWithToolEnabled } from '../utilities/viewportFilters';\nimport { getToolGroup } from '../store/ToolGroupManager';\nimport { Events } from '../enums';\nvar OverlayMarkerType;\n(function (OverlayMarkerType) {\n    OverlayMarkerType[OverlayMarkerType[\"ANNOTATED_CUBE\"] = 1] = \"ANNOTATED_CUBE\";\n    OverlayMarkerType[OverlayMarkerType[\"AXES\"] = 2] = \"AXES\";\n    OverlayMarkerType[OverlayMarkerType[\"CUSTOM\"] = 3] = \"CUSTOM\";\n})(OverlayMarkerType || (OverlayMarkerType = {}));\nclass OrientationMarkerTool extends BaseTool {\n    static { this.CUBE = 1; }\n    static { this.AXIS = 2; }\n    static { this.VTPFILE = 3; }\n    static { this.OVERLAY_MARKER_TYPES = OverlayMarkerType; }\n    constructor(toolProps = {}, defaultToolProps = {\n        configuration: {\n            orientationWidget: {\n                enabled: true,\n                viewportCorner: vtkOrientationMarkerWidget.Corners.BOTTOM_RIGHT,\n                viewportSize: 0.15,\n                minPixelSize: 100,\n                maxPixelSize: 300,\n            },\n            overlayMarkerType: OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE,\n            overlayConfiguration: {\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.ANNOTATED_CUBE]: {\n                    faceProperties: {\n                        xPlus: { text: 'L', faceColor: '#ffff00', faceRotation: 90 },\n                        xMinus: { text: 'R', faceColor: '#ffff00', faceRotation: 270 },\n                        yPlus: {\n                            text: 'P',\n                            faceColor: '#00ffff',\n                            fontColor: 'white',\n                            faceRotation: 180,\n                        },\n                        yMinus: { text: 'A', faceColor: '#00ffff', fontColor: 'white' },\n                        zPlus: { text: 'S' },\n                        zMinus: { text: 'I' },\n                    },\n                    defaultStyle: {\n                        fontStyle: 'bold',\n                        fontFamily: 'Arial',\n                        fontColor: 'black',\n                        fontSizeScale: (res) => res / 2,\n                        faceColor: '#0000ff',\n                        edgeThickness: 0.1,\n                        edgeColor: 'black',\n                        resolution: 400,\n                    },\n                },\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.AXES]: {},\n                [OrientationMarkerTool.OVERLAY_MARKER_TYPES.CUSTOM]: {\n                    polyDataURL: 'https://raw.githubusercontent.com/Slicer/Slicer/80ad0a04dacf134754459557bf2638c63f3d1d1b/Base/Logic/Resources/OrientationMarkers/Human.vtp',\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._resizeObservers = new Map();\n        this.onSetToolEnabled = () => {\n            this.initViewports();\n            this._subscribeToViewportEvents();\n        };\n        this.onSetToolActive = () => {\n            this.initViewports();\n            this._subscribeToViewportEvents();\n        };\n        this.onSetToolDisabled = () => {\n            this.cleanUpData();\n            this._unsubscribeToViewportNewVolumeSet();\n        };\n        this._getViewportsInfo = () => {\n            const viewports = getToolGroup(this.toolGroupId).viewportsInfo;\n            return viewports;\n        };\n        this.resize = (viewportId) => {\n            const orientationMarker = this.orientationMarkers[viewportId];\n            if (!orientationMarker) {\n                return;\n            }\n            const { orientationWidget } = orientationMarker;\n            orientationWidget.updateViewport();\n        };\n        this.orientationMarkers = {};\n        this.updatingOrientationMarker = {};\n    }\n    _unsubscribeToViewportNewVolumeSet() {\n        const unsubscribe = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n                const { element } = viewport;\n                element.removeEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));\n                const resizeObserver = this._resizeObservers.get(viewportId);\n                resizeObserver.unobserve(element);\n            });\n        };\n        eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\n            if (evt.detail.toolGroupId !== this.toolGroupId) {\n                return;\n            }\n            unsubscribe();\n            this.initViewports();\n        });\n    }\n    _subscribeToViewportEvents() {\n        const subscribeToElementResize = () => {\n            const viewportsInfo = this._getViewportsInfo();\n            viewportsInfo.forEach(({ viewportId, renderingEngineId }) => {\n                const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n                const { element } = viewport;\n                this.initViewports();\n                element.addEventListener(Enums.Events.VOLUME_VIEWPORT_NEW_VOLUME, this.initViewports.bind(this));\n                const resizeObserver = new ResizeObserver(() => {\n                    setTimeout(() => {\n                        const element = getEnabledElementByIds(viewportId, renderingEngineId);\n                        if (!element) {\n                            return;\n                        }\n                        const { viewport } = element;\n                        this.resize(viewportId);\n                        viewport.render();\n                    }, 100);\n                });\n                resizeObserver.observe(element);\n                this._resizeObservers.set(viewportId, resizeObserver);\n            });\n        };\n        subscribeToElementResize();\n        eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, (evt) => {\n            if (evt.detail.toolGroupId !== this.toolGroupId) {\n                return;\n            }\n            subscribeToElementResize();\n            this.initViewports();\n        });\n    }\n    cleanUpData() {\n        const renderingEngines = getRenderingEngines();\n        const renderingEngine = renderingEngines[0];\n        const viewports = renderingEngine.getViewports();\n        viewports.forEach((viewport) => {\n            const orientationMarker = this.orientationMarkers[viewport.id];\n            if (!orientationMarker) {\n                return;\n            }\n            const { actor, orientationWidget } = orientationMarker;\n            orientationWidget?.setEnabled(false);\n            orientationWidget?.delete();\n            actor?.delete();\n            const renderWindow = viewport\n                .getRenderingEngine()\n                .getOffscreenMultiRenderWindow(viewport.id)\n                .getRenderWindow();\n            renderWindow.render();\n            viewport.getRenderingEngine().render();\n            delete this.orientationMarkers[viewport.id];\n        });\n    }\n    initViewports() {\n        const renderingEngines = getRenderingEngines();\n        const renderingEngine = renderingEngines[0];\n        if (!renderingEngine) {\n            return;\n        }\n        let viewports = renderingEngine.getViewports();\n        viewports = filterViewportsWithToolEnabled(viewports, this.getToolName());\n        viewports.forEach((viewport) => {\n            const widget = viewport.getWidget(this.getToolName());\n            if (!widget || widget.isDeleted()) {\n                this.addAxisActorInViewport(viewport);\n            }\n        });\n    }\n    async addAxisActorInViewport(viewport) {\n        const viewportId = viewport.id;\n        if (!this.updatingOrientationMarker[viewportId]) {\n            this.updatingOrientationMarker[viewportId] = true;\n            const type = this.configuration.overlayMarkerType;\n            const overlayConfiguration = this.configuration.overlayConfiguration[type];\n            if (this.orientationMarkers[viewportId]) {\n                const { actor, orientationWidget } = this.orientationMarkers[viewportId];\n                viewport.getRenderer().removeActor(actor);\n                orientationWidget.setEnabled(false);\n            }\n            let actor;\n            if (type === 1) {\n                actor = this.createAnnotationCube(overlayConfiguration);\n            }\n            else if (type === 2) {\n                actor = vtkAxesActor.newInstance();\n            }\n            else if (type === 3) {\n                actor = await this.createCustomActor();\n            }\n            const renderer = viewport.getRenderer();\n            const renderWindow = viewport\n                .getRenderingEngine()\n                .getOffscreenMultiRenderWindow(viewportId)\n                .getRenderWindow();\n            const { enabled, viewportCorner, viewportSize, minPixelSize, maxPixelSize, } = this.configuration.orientationWidget;\n            const orientationWidget = vtkOrientationMarkerWidget.newInstance({\n                actor,\n                interactor: renderWindow.getInteractor(),\n                parentRenderer: renderer,\n            });\n            orientationWidget.setEnabled(enabled);\n            orientationWidget.setViewportCorner(viewportCorner);\n            orientationWidget.setViewportSize(viewportSize);\n            orientationWidget.setMinPixelSize(minPixelSize);\n            orientationWidget.setMaxPixelSize(maxPixelSize);\n            orientationWidget.updateMarkerOrientation();\n            this.orientationMarkers[viewportId] = {\n                orientationWidget,\n                actor,\n            };\n            viewport.addWidget(this.getToolName(), orientationWidget);\n            renderWindow.render();\n            viewport.getRenderingEngine().render();\n            this.updatingOrientationMarker[viewportId] = false;\n        }\n    }\n    async createCustomActor() {\n        const url = this.configuration.overlayConfiguration[OverlayMarkerType.CUSTOM]\n            .polyDataURL;\n        const response = await fetch(url);\n        const arrayBuffer = await response.arrayBuffer();\n        const vtpReader = vtkXMLPolyDataReader.newInstance();\n        vtpReader.parseAsArrayBuffer(arrayBuffer);\n        vtpReader.update();\n        const polyData = vtkPolyData.newInstance();\n        polyData.shallowCopy(vtpReader.getOutputData());\n        polyData.getPointData().setActiveScalars('Color');\n        const mapper = vtkMapper.newInstance();\n        mapper.setInputData(polyData);\n        mapper.setColorModeToDirectScalars();\n        const actor = vtkActor.newInstance();\n        actor.setMapper(mapper);\n        actor.rotateZ(180);\n        return actor;\n    }\n    createAnnotationCube(overlayConfiguration) {\n        const actor = vtkAnnotatedCubeActor.newInstance();\n        actor.setDefaultStyle({ ...overlayConfiguration.defaultStyle });\n        actor.setXPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.xPlus,\n        });\n        actor.setXMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.xMinus,\n        });\n        actor.setYPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.yPlus,\n        });\n        actor.setYMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.yMinus,\n        });\n        actor.setZPlusFaceProperty({\n            ...overlayConfiguration.faceProperties.zPlus,\n        });\n        actor.setZMinusFaceProperty({\n            ...overlayConfiguration.faceProperties.zMinus,\n        });\n        return actor;\n    }\n    async createAnnotatedCubeActor() {\n        const axes = vtkAnnotatedCubeActor.newInstance();\n        const { faceProperties, defaultStyle } = this.configuration.annotatedCube;\n        axes.setDefaultStyle(defaultStyle);\n        Object.keys(faceProperties).forEach((key) => {\n            const methodName = `set${key.charAt(0).toUpperCase() + key.slice(1)}FaceProperty`;\n            axes[methodName](faceProperties[key]);\n        });\n        return axes;\n    }\n}\nOrientationMarkerTool.toolName = 'OrientationMarker';\nexport default OrientationMarkerTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/activeSegmentation';\nimport { setActiveSegmentIndex } from '../../stateManagement/segmentation/segmentIndex';\nimport { getHoveredContourSegmentationAnnotation, getSegmentIndexAtLabelmapBorder, getSegmentIndexAtWorldPoint, } from '../../utilities/segmentation';\nimport { state } from '../../store/state';\nimport { ToolModes } from '../../enums';\nclass SegmentSelectTool extends BaseTool {\n    static { this.SelectMode = {\n        Inside: 'Inside',\n        Border: 'Border',\n    }; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            hoverTimeout: 100,\n            mode: SegmentSelectTool.SelectMode.Border,\n            searchRadius: 6,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode !== ToolModes.Active) {\n                return;\n            }\n            if (this.hoverTimer) {\n                clearTimeout(this.hoverTimer);\n            }\n            this.hoverTimer = setTimeout(() => {\n                this._setActiveSegment(evt);\n                this.hoverTimer = null;\n            }, this.configuration.hoverTimeout);\n            return true;\n        };\n        this.onSetToolEnabled = () => {\n            this.onSetToolActive();\n        };\n        this.onSetToolActive = () => {\n            this.hoverTimer = null;\n        };\n        this.onSetToolDisabled = () => {\n            this.hoverTimer = null;\n        };\n        this.hoverTimer = null;\n    }\n    _setActiveSegment(evt = {}) {\n        if (state.isInteractingWithTool) {\n            return;\n        }\n        const { element, currentPoints } = evt.detail;\n        const worldPoint = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const activeSegmentation = getActiveSegmentation(viewport.id);\n        if (!activeSegmentation) {\n            return;\n        }\n        this._setActiveSegmentForType(activeSegmentation, worldPoint, viewport);\n    }\n    _setActiveSegmentForType(activeSegmentation, worldPoint, viewport) {\n        const imageDataInfo = viewport.getImageData();\n        if (!imageDataInfo) {\n            return;\n        }\n        const { segmentationId, representationData } = activeSegmentation;\n        let hoveredSegmentIndex;\n        if (this.configuration.mode === SegmentSelectTool.SelectMode.Inside) {\n            hoveredSegmentIndex = getSegmentIndexAtWorldPoint(segmentationId, worldPoint, {\n                viewport,\n            });\n        }\n        else {\n            if (representationData.Labelmap) {\n                hoveredSegmentIndex = getSegmentIndexAtLabelmapBorder(segmentationId, worldPoint, {\n                    viewport,\n                    searchRadius: this.configuration.searchRadius,\n                });\n            }\n            else if (representationData.Contour) {\n                hoveredSegmentIndex =\n                    getHoveredContourSegmentationAnnotation(segmentationId);\n            }\n            else if (representationData.Surface) {\n            }\n        }\n        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {\n            return;\n        }\n        setActiveSegmentIndex(segmentationId, hoveredSegmentIndex);\n        const renderingEngine = viewport.getRenderingEngine();\n        const viewportIds = renderingEngine.getViewports().map((v) => v.id);\n        triggerSegmentationModified(segmentationId);\n        triggerAnnotationRenderForViewportIds(viewportIds);\n    }\n}\nSegmentSelectTool.toolName = 'SegmentSelectTool';\nexport default SegmentSelectTool;\n","import { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, utilities, } from '@cornerstonejs/core';\nimport { addAnnotation, getAllAnnotations, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { drawLine as drawLineSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { hideElementCursor } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport BidirectionalTool from '../annotation/BidirectionalTool';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nclass SegmentBidirectionalTool extends BidirectionalTool {\n    static { this.toolName = 'SegmentBidirectional'; }\n    constructor(toolProps = {}) {\n        super(toolProps);\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = true;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const viewportId = viewport.id;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { segmentIndex, segmentationId } = annotation.metadata;\n                const { lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const colorArray = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n                const color = `rgb(${colorArray.slice(0, 3).join(',')})`;\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        width: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId1 = `${annotationUID}-line-1`;\n                const dataId2 = `${annotationUID}-line-2`;\n                const lineUID = '0';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId1);\n                const secondLineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {\n                    color,\n                    lineWidth,\n                    lineDash,\n                    shadow,\n                }, dataId2);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                options.color = color;\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const worldPos = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        this.isDrawing = true;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const referencedImageId = this.getReferencedImageId(viewport, worldPos, viewPlaneNormal, viewUp);\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const annotation = {\n            highlighted: true,\n            invalidated: true,\n            metadata: {\n                toolName: this.getToolName(),\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...viewport.getViewReference({ points: [worldPos] }),\n            },\n            data: {\n                handles: {\n                    points: [\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                        [...worldPos],\n                    ],\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n        };\n        addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex: 1,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n        };\n        this._activateDraw(element);\n        hideElementCursor(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    static { this.hydrate = (viewportId, axis, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const existingAnnotations = getAllAnnotations();\n        const toolAnnotations = existingAnnotations.filter((annotation) => annotation.metadata.toolName === 'SegmentBidirectional');\n        const existingAnnotation = toolAnnotations.find((annotation) => {\n            const { metadata } = annotation;\n            if (metadata.segmentIndex === options?.segmentIndex &&\n                metadata.segmentationId === options?.segmentationId) {\n                return true;\n            }\n            return false;\n        });\n        if (existingAnnotation) {\n            removeAnnotation(existingAnnotation.annotationUID);\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, } = this.hydrateBase(SegmentBidirectionalTool, enabledElement, axis[0], options);\n        const [majorAxis, minorAxis] = axis;\n        const [major0, major1] = majorAxis;\n        const [minor0, minor1] = minorAxis;\n        const points = [major0, major1, minor0, minor1];\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                },\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                segmentIndex: options?.segmentIndex,\n                segmentationId: options?.segmentationId,\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n        return annotation;\n    }; }\n}\nexport default SegmentBidirectionalTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { config as segmentationConfig } from '../../stateManagement/segmentation';\nimport { BaseTool } from '../base';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/activeSegmentation';\nimport { getSegmentIndexAtWorldPoint } from '../../utilities/segmentation';\nimport { state } from '../../store/state';\nimport { drawTextBox as drawTextBoxSvg } from '../../drawingSvg';\nclass SegmentLabelTool extends BaseTool {\n    constructor(toolProps = {\n        data: {\n            handles: {\n                textBox: {\n                    worldPosition: [0, 0, 0],\n                    worldBoundingBox: {\n                        topLeft: [0, 0, 0],\n                        topRight: [0, 0, 0],\n                        bottomLeft: [0, 0, 0],\n                        bottomRight: [0, 0, 0],\n                    },\n                },\n            },\n        },\n    }, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            hoverTimeout: 100,\n            searchRadius: 6,\n            color: null,\n            background: null,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.mouseMoveCallback = (evt) => {\n            if (this.hoverTimer) {\n                clearTimeout(this.hoverTimer);\n            }\n            this.hoverTimer = setTimeout(() => {\n                this._setHoveredSegment(evt);\n                this.hoverTimer = null;\n            }, this.configuration.hoverTimeout);\n            return true;\n        };\n        this.onSetToolEnabled = () => {\n            this.onSetToolActive();\n        };\n        this.onSetToolActive = () => {\n            this.hoverTimer = null;\n        };\n        this.onSetToolDisabled = () => {\n            this.hoverTimer = null;\n        };\n        this.data = toolProps.data ?? {\n            handles: {\n                textBox: {\n                    worldPosition: [0, 0, 0],\n                    worldBoundingBox: {\n                        topLeft: [0, 0, 0],\n                        topRight: [0, 0, 0],\n                        bottomLeft: [0, 0, 0],\n                        bottomRight: [0, 0, 0],\n                    },\n                },\n            },\n        };\n        this.hoverTimer = null;\n    }\n    _setHoveredSegment(evt = {}) {\n        if (state.isInteractingWithTool) {\n            return;\n        }\n        const { element, currentPoints } = evt.detail;\n        const worldPoint = currentPoints.world;\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const activeSegmentation = getActiveSegmentation(viewport.id);\n        if (!activeSegmentation) {\n            return;\n        }\n        this._setHoveredSegmentForType(activeSegmentation, worldPoint, viewport);\n    }\n    _setHoveredSegmentForType(activeSegmentation, worldPoint, viewport) {\n        const imageDataInfo = viewport.getImageData();\n        if (!imageDataInfo) {\n            return;\n        }\n        const { segmentationId } = activeSegmentation;\n        const hoveredSegmentIndex = getSegmentIndexAtWorldPoint(segmentationId, worldPoint, {\n            viewport,\n        });\n        const segment = activeSegmentation.segments[hoveredSegmentIndex];\n        const color = this.configuration.color ??\n            segmentationConfig.color.getSegmentIndexColor(viewport.id, segmentationId, hoveredSegmentIndex);\n        const label = segment?.label;\n        const canvasCoordinates = viewport.worldToCanvas(worldPoint);\n        this._editData = {\n            hoveredSegmentIndex,\n            hoveredSegmentLabel: label,\n            canvasCoordinates,\n            color,\n        };\n        if (!hoveredSegmentIndex || hoveredSegmentIndex === 0) {\n            return;\n        }\n        const renderingEngine = viewport.getRenderingEngine();\n        const viewportIds = renderingEngine.getViewports().map((v) => v.id);\n        triggerSegmentationModified(segmentationId);\n        triggerAnnotationRenderForViewportIds(viewportIds);\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this._editData) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const { hoveredSegmentIndex, hoveredSegmentLabel, canvasCoordinates, color, } = this._editData;\n        if (!hoveredSegmentIndex) {\n            return;\n        }\n        const offset = -15;\n        const textBoxPosition = [\n            canvasCoordinates[0] + offset,\n            canvasCoordinates[1] + offset,\n        ];\n        const boundingBox = drawTextBoxSvg(svgDrawingHelper, 'segmentSelectLabelAnnotation', 'segmentSelectLabelTextBox', [hoveredSegmentLabel ?? '(unnamed segment)'], textBoxPosition, {\n            color: `rgba(${color[0]}, ${color[1]}, ${color[2]}, ${color[3]})`,\n            background: this.configuration.background ?? undefined,\n        });\n        const left = canvasCoordinates[0];\n        const top = canvasCoordinates[1];\n        const { width, height } = boundingBox;\n        this.data.handles.textBox.worldBoundingBox = {\n            topLeft: viewport.canvasToWorld([left, top]),\n            topRight: viewport.canvasToWorld([left + width, top]),\n            bottomLeft: viewport.canvasToWorld([left, top + height]),\n            bottomRight: viewport.canvasToWorld([left + width, top + height]),\n        };\n    }\n}\nSegmentLabelTool.toolName = 'SegmentLabelTool';\nexport default SegmentLabelTool;\n","import { Events, SegmentationRepresentations } from '../../enums';\nimport { eventTarget, utilities, getRenderingEngine, } from '@cornerstonejs/core';\nimport PlanarFreehandContourSegmentationTool from '../annotation/PlanarFreehandContourSegmentationTool';\nimport BrushTool from './BrushTool';\nimport * as segmentation from '../../stateManagement/segmentation';\nimport { getSegmentationRepresentationsBySegmentationId } from '../../stateManagement/segmentation/getSegmentationRepresentation';\nclass LabelMapEditWithContourTool extends PlanarFreehandContourSegmentationTool {\n    static { this.toolName = 'LabelMapEditWithContour'; }\n    static { this.annotationsToViewportMap = new Map(); }\n    static { this.viewportIdsChecked = []; }\n    constructor(toolProps = {}) {\n        const initialProps = utilities.deepMerge({\n            configuration: {\n                calculateStats: false,\n                allowOpenContours: false,\n            },\n        }, toolProps);\n        super(initialProps);\n        this.onViewportAddedToToolGroupBinded =\n            this.onViewportAddedToToolGroup.bind(this);\n        this.onSegmentationModifiedBinded = this.onSegmentationModified.bind(this);\n    }\n    initializeListeners() {\n        LabelMapEditWithContourTool.annotationsToViewportMap.clear();\n        LabelMapEditWithContourTool.viewportIdsChecked = [];\n        eventTarget.addEventListener(Events.ANNOTATION_MODIFIED, this.annotationModified);\n        eventTarget.addEventListener(Events.ANNOTATION_COMPLETED, this.annotationCompleted);\n        eventTarget.addEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this.onViewportAddedToToolGroupBinded);\n        eventTarget.addEventListener(Events.SEGMENTATION_MODIFIED, this.onSegmentationModifiedBinded);\n        eventTarget.addEventListener(Events.SEGMENTATION_REPRESENTATION_MODIFIED, this.onSegmentationModifiedBinded);\n    }\n    cleanUpListeners() {\n        LabelMapEditWithContourTool.annotationsToViewportMap.clear();\n        LabelMapEditWithContourTool.viewportIdsChecked = [];\n        eventTarget.removeEventListener(Events.ANNOTATION_MODIFIED, this.annotationModified);\n        eventTarget.removeEventListener(Events.ANNOTATION_COMPLETED, this.annotationCompleted);\n        eventTarget.removeEventListener(Events.TOOLGROUP_VIEWPORT_ADDED, this.onViewportAddedToToolGroup.bind(this));\n        eventTarget.removeEventListener(Events.SEGMENTATION_MODIFIED, this.onSegmentationModified.bind(this));\n        eventTarget.removeEventListener(Events.SEGMENTATION_REPRESENTATION_MODIFIED, this.onSegmentationModified.bind(this));\n    }\n    async checkContourSegmentation(viewportId) {\n        if (LabelMapEditWithContourTool.viewportIdsChecked.includes(viewportId)) {\n            return;\n        }\n        const activeSeg = segmentation.getActiveSegmentation(viewportId);\n        if (!activeSeg) {\n            console.log('No active segmentation detected');\n            return false;\n        }\n        const segmentationId = activeSeg.segmentationId;\n        if (!activeSeg.representationData.Contour) {\n            LabelMapEditWithContourTool.viewportIdsChecked.push(viewportId);\n            await segmentation.addContourRepresentationToViewport(viewportId, [\n                {\n                    segmentationId,\n                    type: SegmentationRepresentations.Contour,\n                },\n            ]);\n            segmentation.addRepresentationData({\n                segmentationId,\n                type: SegmentationRepresentations.Contour,\n                data: {},\n            });\n        }\n        else {\n            LabelMapEditWithContourTool.viewportIdsChecked.push(viewportId);\n        }\n        return true;\n    }\n    onViewportAddedToToolGroup(evt) {\n        const { toolGroupId, viewportId } = evt.detail;\n        if (toolGroupId !== this.toolGroupId) {\n            return;\n        }\n        this.checkContourSegmentation(viewportId);\n    }\n    onSegmentationModified(evt) {\n        const { segmentationId } = evt.detail || {};\n        if (!segmentationId) {\n            return;\n        }\n        const representations = getSegmentationRepresentationsBySegmentationId(segmentationId);\n        if (!representations) {\n            return;\n        }\n        representations.forEach(async ({ viewportId }) => await this.checkContourSegmentation(viewportId));\n    }\n    onSetToolEnabled() {\n        this.initializeListeners();\n    }\n    onSetToolActive() {\n        this.initializeListeners();\n    }\n    onSetToolDisabled() {\n        this.cleanUpListeners();\n    }\n    annotationModified(evt) {\n        const { annotation, renderingEngineId, viewportId } = evt.detail;\n        const viewport = getRenderingEngine(renderingEngineId)?.getViewport(viewportId);\n        if (!viewport) {\n            return;\n        }\n        LabelMapEditWithContourTool.annotationsToViewportMap.set(annotation.annotationUID, viewport);\n    }\n    annotationCompleted(evt) {\n        const { annotation } = evt.detail;\n        const { polyline } = annotation.data?.contour || {};\n        if (annotation?.metadata?.toolName !== LabelMapEditWithContourTool.toolName) {\n            return;\n        }\n        if (!polyline) {\n            return;\n        }\n        if (LabelMapEditWithContourTool.annotationsToViewportMap.has(annotation.annotationUID)) {\n            const viewport = LabelMapEditWithContourTool.annotationsToViewportMap.get(annotation.annotationUID);\n            if (polyline.length > 3) {\n                BrushTool.viewportContoursToLabelmap(viewport);\n            }\n        }\n    }\n}\nexport default LabelMapEditWithContourTool;\n","import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement, triggerEvent, eventTarget, utilities as csUtils, cache, } from '@cornerstonejs/core';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { drawHandles as drawHandlesSvg, drawRedactionRect as drawRedactionRectSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport getWorldWidthAndHeightFromTwoPoints from '../../utilities/planar/getWorldWidthAndHeightFromTwoPoints';\nclass VideoRedactionTool extends AnnotationTool {\n    static { this.toolName = 'VideoRedaction'; }\n    constructor(toolConfiguration = {}) {\n        super(toolConfiguration, {\n            supportedInteractionTypes: ['Mouse', 'Touch'],\n            configuration: { shadow: true, preventHandleOutsideImage: false },\n        });\n        this.addNewAnnotation = (evt) => {\n            const eventData = evt.detail;\n            const { currentPoints, element } = eventData;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                    },\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n                handleIndex: 3,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            return annotation;\n        };\n        this.getHandleNearImagePoint = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            for (let i = 0; i < points.length; i++) {\n                const point = points[i];\n                const toolDataCanvasCoordinate = viewport.worldToCanvas(point);\n                const near = vec2.distance(canvasCoords, toolDataCanvasCoordinate) < proximity;\n                if (near === true) {\n                    data.handles.activeHandleIndex = i;\n                    return point;\n                }\n            }\n            data.handles.activeHandleIndex = null;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasPoint1 = viewport.worldToCanvas(points[0]);\n            const canvasPoint2 = viewport.worldToCanvas(points[3]);\n            const rect = this._getRectangleImageCoordinates([\n                canvasPoint1,\n                canvasPoint2,\n            ]);\n            const point = [canvasCoords[0], canvasCoords[1]];\n            const { left, top, width, height } = rect;\n            const distanceToPoint = rectangle.distanceToPoint([left, top, width, height], point);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n        };\n        this.toolSelectedCallback = (evt, annotation, interactionType = 'mouse') => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { data } = annotation;\n            data.active = true;\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle, interactionType = 'mouse') => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { data } = annotation;\n            data.active = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportUIDsToRender = getViewportIdsWithToolToRender(element, this.getToolName(), false);\n            this.editData = {\n                annotation,\n                viewportUIDsToRender,\n                handleIndex,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { annotation, viewportUIDsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            data.active = false;\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const { annotation, viewportUIDsToRender, handleIndex, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (handleIndex === undefined) {\n                const { deltaPoints } = eventData;\n                const worldPosDelta = deltaPoints.world;\n                const { points } = data.handles;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                data.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventData;\n                const enabledElement = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n                const worldPos = currentPoints.world;\n                const { points } = data.handles;\n                points[handleIndex] = [...worldPos];\n                let bottomLeftCanvas;\n                let bottomRightCanvas;\n                let topLeftCanvas;\n                let topRightCanvas;\n                let bottomLeftWorld;\n                let bottomRightWorld;\n                let topLeftWorld;\n                let topRightWorld;\n                switch (handleIndex) {\n                    case 0:\n                    case 3:\n                        bottomLeftCanvas = worldToCanvas(points[0]);\n                        topRightCanvas = worldToCanvas(points[3]);\n                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                        topLeftWorld = canvasToWorld(topLeftCanvas);\n                        points[1] = bottomRightWorld;\n                        points[2] = topLeftWorld;\n                        break;\n                    case 1:\n                    case 2:\n                        bottomRightCanvas = worldToCanvas(points[1]);\n                        topLeftCanvas = worldToCanvas(points[2]);\n                        bottomLeftCanvas = [\n                            topLeftCanvas[0],\n                            bottomRightCanvas[1],\n                        ];\n                        topRightCanvas = [\n                            bottomRightCanvas[0],\n                            topLeftCanvas[1],\n                        ];\n                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                        topRightWorld = canvasToWorld(topRightCanvas);\n                        points[0] = bottomLeftWorld;\n                        points[3] = topRightWorld;\n                        break;\n                }\n                data.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            const renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID } = annotation;\n                const data = annotation.data;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const lineWidth = this.getStyle('lineWidth', styleSpecifier, annotation);\n                const lineDash = this.getStyle('lineDash', styleSpecifier, annotation);\n                const color = this.getStyle('color', styleSpecifier, annotation);\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return;\n                }\n                let activeHandleCanvasCoords;\n                if (!this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                if (activeHandleCanvasCoords) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const rectangleUID = '0';\n                drawRedactionRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates[0], canvasCoordinates[3], {\n                    color: 'black',\n                    lineDash,\n                    lineWidth,\n                });\n            }\n        };\n        this._getRectangleImageCoordinates = (points) => {\n            const [point0, point1] = points;\n            return {\n                left: Math.min(point0[0], point1[0]),\n                top: Math.min(point0[1], point1[1]),\n                width: Math.abs(point0[0] - point1[0]),\n                height: Math.abs(point0[1] - point1[1]),\n            };\n        };\n        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { viewportUID, renderingEngineUID, sceneUID } = enabledElement;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetUIDs = Object.keys(cachedStats);\n            for (let i = 0; i < targetUIDs.length; i++) {\n                const targetUID = targetUIDs[i];\n                const { imageVolume } = this._getImageVolumeFromTargetUID(targetUID, renderingEngine);\n                const { dimensions, scalarData, vtkImageData: imageData, metadata, } = imageVolume;\n                const worldPos1Index = vec3.fromValues(0, 0, 0);\n                const worldPos2Index = vec3.fromValues(0, 0, 0);\n                imageData.worldToIndexVec3(worldPos1, worldPos1Index);\n                worldPos1Index[0] = Math.floor(worldPos1Index[0]);\n                worldPos1Index[1] = Math.floor(worldPos1Index[1]);\n                worldPos1Index[2] = Math.floor(worldPos1Index[2]);\n                imageData.worldToIndexVec3(worldPos2, worldPos2Index);\n                worldPos2Index[0] = Math.floor(worldPos2Index[0]);\n                worldPos2Index[1] = Math.floor(worldPos2Index[1]);\n                worldPos2Index[2] = Math.floor(worldPos2Index[2]);\n                if (this._isInsideVolume(worldPos1Index, worldPos2Index, dimensions)) {\n                    this.isHandleOutsideImage = false;\n                    const iMin = Math.min(worldPos1Index[0], worldPos2Index[0]);\n                    const iMax = Math.max(worldPos1Index[0], worldPos2Index[0]);\n                    const jMin = Math.min(worldPos1Index[1], worldPos2Index[1]);\n                    const jMax = Math.max(worldPos1Index[1], worldPos2Index[1]);\n                    const kMin = Math.min(worldPos1Index[2], worldPos2Index[2]);\n                    const kMax = Math.max(worldPos1Index[2], worldPos2Index[2]);\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const area = worldWidth * worldHeight;\n                    let count = 0;\n                    let mean = 0;\n                    let stdDev = 0;\n                    const yMultiple = dimensions[0];\n                    const zMultiple = dimensions[0] * dimensions[1];\n                    for (let k = kMin; k <= kMax; k++) {\n                        for (let j = jMin; j <= jMax; j++) {\n                            for (let i = iMin; i <= iMax; i++) {\n                                const value = scalarData[k * zMultiple + j * yMultiple + i];\n                                count++;\n                                mean += value;\n                            }\n                        }\n                    }\n                    mean /= count;\n                    for (let k = kMin; k <= kMax; k++) {\n                        for (let j = jMin; j <= jMax; j++) {\n                            for (let i = iMin; i <= iMax; i++) {\n                                const value = scalarData[k * zMultiple + j * yMultiple + i];\n                                const valueMinusMean = value - mean;\n                                stdDev += valueMinusMean * valueMinusMean;\n                            }\n                        }\n                    }\n                    stdDev /= count;\n                    stdDev = Math.sqrt(stdDev);\n                    cachedStats[targetUID] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean,\n                        stdDev,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetUID] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                const eventType = Events.ANNOTATION_MODIFIED;\n                const eventDetail = {\n                    annotation,\n                    viewportUID,\n                    renderingEngineUID,\n                    sceneUID: sceneUID,\n                    changeType: ChangeTypes.StatsUpdated,\n                };\n                triggerEvent(eventTarget, eventType, eventDetail);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._getTargetVolumeUID = (scene) => {\n            if (this.configuration.volumeUID) {\n                return this.configuration.volumeUID;\n            }\n            const volumeActors = scene.getVolumeActors();\n            if (!volumeActors && !volumeActors.length) {\n                return;\n            }\n            return volumeActors[0].uid;\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    cancel(element) {\n        if (!this.isDrawing) {\n            return;\n        }\n        this.isDrawing = false;\n        this._deactivateDraw(element);\n        this._deactivateModify(element);\n        resetElementCursor(element);\n        const { annotation, viewportUIDsToRender } = this.editData;\n        const { data } = annotation;\n        data.active = false;\n        data.handles.activeHandleIndex = null;\n        triggerAnnotationRenderForViewportIds(viewportUIDsToRender);\n        this.editData = null;\n        return annotation.annotationUID;\n    }\n    _getImageVolumeFromTargetUID(targetUID, renderingEngine) {\n        let imageVolume, viewport;\n        if (targetUID.startsWith('stackTarget')) {\n            const coloneIndex = targetUID.indexOf(':');\n            const viewportUID = targetUID.substring(coloneIndex + 1);\n            const viewport = renderingEngine.getViewport(viewportUID);\n            imageVolume = viewport.getImageData();\n        }\n        else {\n            imageVolume = cache.getVolume(targetUID);\n        }\n        return { imageVolume, viewport };\n    }\n    _getTargetStackUID(viewport) {\n        return `stackTarget:${viewport.uid}`;\n    }\n}\nexport default VideoRedactionTool;\n","import { m as macro } from '../../macros2.js';\nimport vtkPolyData from '../../Common/DataModel/PolyData.js';\n\nconst Dir = {\n  Forward: 1,\n  Backward: -1\n};\nconst visited = new Set();\nfunction vtkContourLoopExtraction(publicAPI, model) {\n  publicAPI.requestData = (inData, outData) => {\n    const [input] = inData;\n    if (!outData[0]) {\n      outData[0] = vtkPolyData.newInstance();\n    }\n    const [output] = outData;\n    publicAPI.extractContours(input, output);\n    output.modified();\n  };\n  publicAPI.traverseLoop = (pd, dir, startLineId, startPtId, loopPoints) => {\n    let lineId = startLineId;\n    let lastPtId = startPtId;\n    let terminated = false;\n    let numInserted = 0;\n    while (!terminated) {\n      const {\n        cellPointIds\n      } = pd.getCellPoints(lineId);\n      if (!cellPointIds) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      lastPtId = cellPointIds[0] !== lastPtId ? cellPointIds[0] : cellPointIds[1];\n      numInserted++;\n\n      // parametric point value\n      const t = dir * numInserted;\n      loopPoints.push({\n        t,\n        ptId: lastPtId\n      });\n      const lineCell = pd.getPointCells(lastPtId);\n      if (lineCell.length !== 2 || lastPtId === startPtId) {\n        // looped\n        return lastPtId;\n      }\n      if (lineCell.length === 2) {\n        // continue along loop\n        lineId = lineCell[0] !== lineId ? lineCell[0] : lineCell[1];\n        visited.add(lineId);\n      } else {\n        // empty or invalid cell\n        terminated = true;\n      }\n    }\n    return lastPtId;\n  };\n  publicAPI.extractContours = (input, output) => {\n    const loops = [];\n    visited.clear();\n    const inLines = input.getLines();\n    output.getPoints().setData(Float32Array.from(input.getPoints().getData()));\n\n    // TODO skip if cached input mtime hasn't changed.\n    // iterate over input lines\n    for (let li = 0; li < inLines.getNumberOfCells(); li++) {\n      if (visited.has(li)) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      const {\n        cellPointIds\n      } = input.getCellPoints(li);\n      if (!cellPointIds) {\n        // eslint-disable-next-line no-continue\n        continue;\n      }\n      visited.add(li);\n      const startPtId = cellPointIds[0];\n      const loopPoints = [];\n      loopPoints.push({\n        t: 0,\n        ptId: startPtId\n      });\n      const endPtId = publicAPI.traverseLoop(input, Dir.Forward, li, startPtId, loopPoints);\n      if (startPtId !== endPtId) {\n        // didn't find a loop. Go other direction to see where we end up\n        publicAPI.traverseLoop(input, Dir.Backward, li, startPtId, loopPoints);\n        loopPoints.sort((a, b) => a.t < b.t ? -1 : 1);\n        // make closed contour\n        if (loopPoints.length && loopPoints[0].ptId !== loopPoints[loopPoints.length - 1]?.ptId) {\n          loopPoints.push({\n            ...loopPoints[loopPoints.length - 1]\n          });\n        }\n      }\n      if (loopPoints.length) {\n        loops.push(loopPoints);\n      }\n    }\n\n    // clear output lines\n    const outLines = output.getLines();\n    outLines.resize(0);\n    loops.forEach(loop => {\n      outLines.insertNextCell(loop.map(pt => pt.ptId));\n    });\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n  macro.obj(publicAPI, model);\n  macro.algo(publicAPI, model, 1, 1);\n  vtkContourLoopExtraction(publicAPI);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkContourLoopExtraction');\n\n// ----------------------------------------------------------------------------\n\nvar index = {\n  newInstance,\n  extend\n};\n\nexport { index as default, extend, newInstance };\n","import { expose } from 'comlink';\nimport { utilities } from '@cornerstonejs/core';\nimport { utilities as ToolsUtilities } from '@cornerstonejs/tools';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkPlane from '@kitware/vtk.js/Common/DataModel/Plane';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkContourLoopExtraction from '@kitware/vtk.js/Filters/General/ContourLoopExtraction';\nimport vtkCutter from '@kitware/vtk.js/Filters/Core/Cutter';\nconst { math: { polyline: { containsPoint, getAABB, projectTo2D }, }, geometricSurfaceUtils: { checkStandardBasis, rotatePoints }, boundingBox: { getBoundingBoxAroundShapeWorld }, planar: { isPlaneIntersectingAABB }, } = ToolsUtilities;\nasync function peerImport(moduleId) {\n    try {\n        if (moduleId === '@icr/polyseg-wasm') {\n            return import('@icr/polyseg-wasm');\n        }\n    }\n    catch (error) {\n        console.warn('Error importing module:', error);\n        return null;\n    }\n}\nconst polySegConverters = {\n    polySeg: null,\n    polySegInitializing: false,\n    polySegInitializingPromise: null,\n    async initializePolySeg(progressCallback) {\n        let ICRPolySeg;\n        try {\n            ICRPolySeg = (await peerImport('@icr/polyseg-wasm')).default;\n        }\n        catch (error) {\n            console.error(error);\n            console.debug(\"Warning: '@icr/polyseg-wasm' module not found. Please install it separately.\");\n            return;\n        }\n        if (this.polySegInitializing) {\n            await this.polySegInitializingPromise;\n            return;\n        }\n        if (this.polySeg?.instance) {\n            return;\n        }\n        this.polySegInitializing = true;\n        this.polySegInitializingPromise = new Promise((resolve) => {\n            this.polySeg = new ICRPolySeg();\n            this.polySeg\n                .initialize({\n                updateProgress: progressCallback,\n            })\n                .then(() => {\n                this.polySegInitializing = false;\n                resolve();\n            });\n        });\n        await this.polySegInitializingPromise;\n    },\n    async convertContourToSurface(args, ...callbacks) {\n        const { polylines, numPointsArray } = args;\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const results = await this.polySeg.instance.convertContourRoiToSurface(polylines, numPointsArray);\n        return results;\n    },\n    async convertLabelmapToSurface(args, ...callbacks) {\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const results = this.polySeg.instance.convertLabelmapToSurface(args.scalarData, args.dimensions, args.spacing, args.direction, args.origin, [args.segmentIndex]);\n        const rotationInfo = checkStandardBasis(args.direction);\n        if (!rotationInfo.isStandard) {\n            const rotatedPoints = rotatePoints(rotationInfo.rotationMatrix, args.origin, results.points);\n            results.points = [...rotatedPoints];\n        }\n        return results;\n    },\n    async convertContourToVolumeLabelmap(args, ...callbacks) {\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const { segmentIndices, scalarData, annotationUIDsInSegmentMap, dimensions, origin, direction, spacing, } = args;\n        const segmentationVoxelManager = utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData,\n        });\n        const imageData = vtkImageData.newInstance();\n        imageData.setDimensions(dimensions);\n        imageData.setOrigin(origin);\n        imageData.setDirection(direction);\n        imageData.setSpacing(spacing);\n        const scalarArray = vtkDataArray.newInstance({\n            name: 'Pixels',\n            numberOfComponents: 1,\n            values: scalarData,\n        });\n        imageData.getPointData().setScalars(scalarArray);\n        imageData.modified();\n        for (const index of segmentIndices) {\n            const annotations = annotationUIDsInSegmentMap.get(index);\n            for (const annotation of annotations) {\n                if (!annotation.polyline) {\n                    continue;\n                }\n                const { polyline, holesPolyline } = annotation;\n                const bounds = getBoundingBoxAroundShapeWorld(polyline);\n                const [iMin, jMin, kMin] = utilities.transformWorldToIndex(imageData, [\n                    bounds[0][0],\n                    bounds[1][0],\n                    bounds[2][0],\n                ]);\n                const [iMax, jMax, kMax] = utilities.transformWorldToIndex(imageData, [\n                    bounds[0][1],\n                    bounds[1][1],\n                    bounds[2][1],\n                ]);\n                const { projectedPolyline, sharedDimensionIndex } = projectTo2D(polyline);\n                const holes = holesPolyline?.map((hole) => {\n                    const { projectedPolyline: projectedHole } = projectTo2D(hole);\n                    return projectedHole;\n                });\n                const firstDim = (sharedDimensionIndex + 1) % 3;\n                const secondDim = (sharedDimensionIndex + 2) % 3;\n                const voxels = utilities.VoxelManager.createScalarVolumeVoxelManager({\n                    dimensions,\n                    scalarData,\n                });\n                voxels.forEach(({ pointIJK }) => {\n                    segmentationVoxelManager.setAtIJKPoint(pointIJK, index);\n                }, {\n                    imageData,\n                    isInObject: (pointLPS) => {\n                        const point2D = [pointLPS[firstDim], pointLPS[secondDim]];\n                        const isInside = containsPoint(projectedPolyline, point2D, {\n                            holes,\n                        });\n                        return isInside;\n                    },\n                    boundsIJK: [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ],\n                });\n            }\n        }\n        return segmentationVoxelManager.scalarData;\n    },\n    async convertContourToStackLabelmap(args, ...callbacks) {\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const { segmentationsInfo, annotationUIDsInSegmentMap, segmentIndices } = args;\n        const segmentationVoxelManagers = new Map();\n        segmentationsInfo.forEach((segmentationInfo, referencedImageId) => {\n            const { dimensions, scalarData, direction, spacing, origin } = segmentationInfo;\n            const manager = utilities.VoxelManager.createScalarVolumeVoxelManager({\n                dimensions,\n                scalarData,\n            });\n            const imageData = vtkImageData.newInstance();\n            imageData.setDimensions(dimensions);\n            imageData.setOrigin(origin);\n            imageData.setDirection(direction);\n            imageData.setSpacing(spacing);\n            const scalarArray = vtkDataArray.newInstance({\n                name: 'Pixels',\n                numberOfComponents: 1,\n                values: scalarData,\n            });\n            imageData.getPointData().setScalars(scalarArray);\n            imageData.modified();\n            segmentationVoxelManagers.set(referencedImageId, { manager, imageData });\n        });\n        for (const index of segmentIndices) {\n            const annotations = annotationUIDsInSegmentMap.get(index);\n            for (const annotation of annotations) {\n                if (!annotation.polyline) {\n                    continue;\n                }\n                const { polyline, holesPolyline, referencedImageId } = annotation;\n                const bounds = getBoundingBoxAroundShapeWorld(polyline);\n                const { manager: segmentationVoxelManager, imageData } = segmentationVoxelManagers.get(referencedImageId);\n                const [iMin, jMin, kMin] = utilities.transformWorldToIndex(imageData, [\n                    bounds[0][0],\n                    bounds[1][0],\n                    bounds[2][0],\n                ]);\n                const [iMax, jMax, kMax] = utilities.transformWorldToIndex(imageData, [\n                    bounds[0][1],\n                    bounds[1][1],\n                    bounds[2][1],\n                ]);\n                const { projectedPolyline, sharedDimensionIndex } = projectTo2D(polyline);\n                const holes = holesPolyline?.map((hole) => {\n                    const { projectedPolyline: projectedHole } = projectTo2D(hole);\n                    return projectedHole;\n                });\n                const firstDim = (sharedDimensionIndex + 1) % 3;\n                const secondDim = (sharedDimensionIndex + 2) % 3;\n                const voxels = utilities.VoxelManager.createImageVoxelManager({\n                    width: imageData.getDimensions()[0],\n                    height: imageData.getDimensions()[1],\n                    scalarData: imageData.getPointData().getScalars().getData(),\n                });\n                voxels.forEach(({ pointIJK }) => {\n                    segmentationVoxelManager.setAtIJKPoint(pointIJK, index);\n                }, {\n                    imageData,\n                    isInObject: (pointLPS) => {\n                        const point2D = [pointLPS[firstDim], pointLPS[secondDim]];\n                        const isInside = containsPoint(projectedPolyline, point2D, {\n                            holes,\n                        });\n                        return isInside;\n                    },\n                    boundsIJK: [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ],\n                });\n            }\n        }\n        segmentationsInfo.forEach((segmentationInfo, referencedImageId) => {\n            const { manager: segmentationVoxelManager } = segmentationVoxelManagers.get(referencedImageId);\n            segmentationInfo.scalarData = segmentationVoxelManager.scalarData;\n        });\n        return segmentationsInfo;\n    },\n    async convertSurfaceToVolumeLabelmap(args, ...callbacks) {\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const results = this.polySeg.instance.convertSurfaceToLabelmap(args.points, args.polys, args.dimensions, args.spacing, args.direction, args.origin);\n        return results;\n    },\n    async convertSurfacesToVolumeLabelmap(args, ...callbacks) {\n        const [progressCallback] = callbacks;\n        await this.initializePolySeg(progressCallback);\n        const { segmentsInfo } = args;\n        const promises = Array.from(segmentsInfo.keys()).map((segmentIndex) => {\n            const { points, polys } = segmentsInfo.get(segmentIndex);\n            const result = this.polySeg.instance.convertSurfaceToLabelmap(points, polys, args.dimensions, args.spacing, args.direction, args.origin);\n            return {\n                ...result,\n                segmentIndex,\n            };\n        });\n        const results = await Promise.all(promises);\n        const targetImageData = vtkImageData.newInstance();\n        targetImageData.setDimensions(args.dimensions);\n        targetImageData.setOrigin(args.origin);\n        targetImageData.setSpacing(args.spacing);\n        targetImageData.setDirection(args.direction);\n        const totalSize = args.dimensions[0] * args.dimensions[1] * args.dimensions[2];\n        const scalarArray = vtkDataArray.newInstance({\n            name: 'Pixels',\n            numberOfComponents: 1,\n            values: new Uint8Array(totalSize),\n        });\n        targetImageData.getPointData().setScalars(scalarArray);\n        targetImageData.modified();\n        const { dimensions } = args;\n        const scalarData = targetImageData.getPointData().getScalars().getData();\n        const segmentationVoxelManager = utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData,\n        });\n        const outputVolumesInfo = results.map((result) => {\n            const { data, dimensions, direction, origin, spacing } = result;\n            const volume = vtkImageData.newInstance();\n            volume.setDimensions(dimensions);\n            volume.setOrigin(origin);\n            volume.setSpacing(spacing);\n            volume.setDirection(direction);\n            const scalarArray = vtkDataArray.newInstance({\n                name: 'Pixels',\n                numberOfComponents: 1,\n                values: data,\n            });\n            volume.getPointData().setScalars(scalarArray);\n            volume.modified();\n            const voxelManager = utilities.VoxelManager.createScalarVolumeVoxelManager({\n                dimensions,\n                scalarData: data,\n            });\n            const extent = volume.getExtent();\n            return {\n                volume,\n                voxelManager,\n                extent,\n                scalarData: data,\n                segmentIndex: result.segmentIndex,\n            };\n        });\n        const voxels = utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions: targetImageData.getDimensions(),\n            scalarData: targetImageData.getPointData().getScalars().getData(),\n        });\n        voxels.forEach(({ pointIJK, pointLPS }) => {\n            try {\n                for (const volumeInfo of outputVolumesInfo) {\n                    const { volume, extent, voxelManager, segmentIndex } = volumeInfo;\n                    const index = volume.worldToIndex(pointLPS);\n                    if (index[0] < extent[0] ||\n                        index[0] > extent[1] ||\n                        index[1] < extent[2] ||\n                        index[1] > extent[3] ||\n                        index[2] < extent[4] ||\n                        index[2] > extent[5]) {\n                        continue;\n                    }\n                    const roundedIndex = index.map(Math.round);\n                    const value = voxelManager.getAtIJK(...roundedIndex);\n                    if (value > 0) {\n                        segmentationVoxelManager.setAtIJKPoint(pointIJK, segmentIndex);\n                        break;\n                    }\n                }\n            }\n            catch (error) {\n            }\n        }, { imageData: targetImageData });\n        return segmentationVoxelManager.scalarData;\n    },\n    getSurfacesAABBs({ surfacesInfo }) {\n        const aabbs = new Map();\n        for (const { points, id } of surfacesInfo) {\n            const aabb = getAABB(points, { numDimensions: 3 });\n            aabbs.set(id, aabb);\n        }\n        return aabbs;\n    },\n    cutSurfacesIntoPlanes({ planesInfo, surfacesInfo, surfacesAABB = new Map() }, progressCallback, updateCacheCallback) {\n        const numberOfPlanes = planesInfo.length;\n        const cutter = vtkCutter.newInstance();\n        const plane1 = vtkPlane.newInstance();\n        cutter.setCutFunction(plane1);\n        const surfacePolyData = vtkPolyData.newInstance();\n        try {\n            for (const [index, planeInfo] of planesInfo.entries()) {\n                const { sliceIndex, planes } = planeInfo;\n                const polyDataResults = new Map();\n                for (const polyDataInfo of surfacesInfo) {\n                    const { points, polys, id, segmentIndex } = polyDataInfo;\n                    const aabb3 = surfacesAABB.get(id) || getAABB(points, { numDimensions: 3 });\n                    if (!surfacesAABB.has(id)) {\n                        surfacesAABB.set(id, aabb3);\n                    }\n                    const { minX, minY, minZ, maxX, maxY, maxZ } = aabb3;\n                    const { origin, normal } = planes[0];\n                    if (!isPlaneIntersectingAABB(origin, normal, minX, minY, minZ, maxX, maxY, maxZ)) {\n                        continue;\n                    }\n                    surfacePolyData.getPoints().setData(points, 3);\n                    surfacePolyData.getPolys().setData(polys);\n                    surfacePolyData.modified();\n                    cutter.setInputData(surfacePolyData);\n                    plane1.setOrigin(origin);\n                    plane1.setNormal(normal);\n                    try {\n                        cutter.update();\n                    }\n                    catch (e) {\n                        console.warn('Error during clipping', e);\n                        continue;\n                    }\n                    const polyData = cutter.getOutputData();\n                    if (!polyData ||\n                        !polyData.getPoints() ||\n                        polyData.getPoints().getNumberOfPoints() === 0) {\n                        continue;\n                    }\n                    const cutterOutput = polyData;\n                    cutterOutput.buildLinks();\n                    const loopExtraction = vtkContourLoopExtraction.newInstance();\n                    loopExtraction.setInputData(cutterOutput);\n                    try {\n                        loopExtraction.update();\n                        const loopOutput = loopExtraction.getOutputData();\n                        if (loopOutput &&\n                            loopOutput.getPoints() &&\n                            loopOutput.getLines() &&\n                            loopOutput.getPoints().getNumberOfPoints() > 0 &&\n                            loopOutput.getLines().getNumberOfCells() > 0) {\n                            polyDataResults.set(segmentIndex, {\n                                points: loopOutput.getPoints().getData(),\n                                lines: loopOutput.getLines().getData(),\n                                numberOfCells: loopOutput.getLines().getNumberOfCells(),\n                                segmentIndex,\n                            });\n                        }\n                    }\n                    catch (loopError) {\n                        console.warn('Error during loop extraction:', loopError);\n                        continue;\n                    }\n                }\n                progressCallback({ progress: (index + 1) / numberOfPlanes });\n                updateCacheCallback({ sliceIndex, polyDataResults });\n            }\n        }\n        catch (e) {\n            console.warn('Error during processing', e);\n        }\n        finally {\n            surfacesInfo = null;\n            plane1.delete();\n        }\n    },\n};\nexpose(polySegConverters);\n","const CORNERSTONE_COLOR_LUT = [\n    [0, 0, 0, 0],\n    [221, 84, 84, 255],\n    [77, 228, 121, 255],\n    [166, 70, 235, 255],\n    [189, 180, 116, 255],\n    [109, 182, 196, 255],\n    [204, 101, 157, 255],\n    [123, 211, 94, 255],\n    [93, 87, 218, 255],\n    [225, 128, 80, 255],\n    [73, 232, 172, 255],\n    [181, 119, 186, 255],\n    [176, 193, 112, 255],\n    [105, 153, 200, 255],\n    [208, 97, 120, 255],\n    [90, 215, 101, 255],\n    [135, 83, 222, 255],\n    [229, 178, 76, 255],\n    [122, 183, 181, 255],\n    [190, 115, 171, 255],\n    [149, 197, 108, 255],\n    [100, 118, 205, 255],\n    [212, 108, 93, 255],\n    [86, 219, 141, 255],\n    [183, 79, 226, 255],\n    [233, 233, 72, 255],\n    [118, 167, 187, 255],\n    [194, 111, 146, 255],\n    [116, 201, 104, 255],\n    [115, 96, 209, 255],\n    [216, 147, 89, 255],\n    [82, 223, 188, 255],\n    [230, 75, 224, 255],\n    [163, 184, 121, 255],\n    [114, 143, 191, 255],\n    [198, 107, 114, 255],\n    [99, 206, 122, 255],\n    [153, 92, 213, 255],\n    [220, 192, 85, 255],\n    [78, 215, 227, 255],\n    [234, 71, 173, 255],\n    [141, 188, 117, 255],\n    [110, 113, 195, 255],\n    [202, 128, 103, 255],\n    [95, 210, 157, 255],\n    [195, 88, 217, 255],\n    [206, 224, 81, 255],\n    [74, 166, 231, 255],\n    [185, 120, 139, 255],\n    [113, 192, 113, 255],\n    [133, 106, 199, 255],\n    [207, 162, 98, 255],\n    [91, 214, 198, 255],\n    [221, 84, 198, 255],\n    [159, 228, 77, 255],\n    [70, 111, 235, 255],\n    [189, 119, 116, 255],\n    [109, 196, 138, 255],\n    [165, 101, 204, 255],\n    [211, 201, 94, 255],\n    [87, 191, 218, 255],\n    [225, 80, 153, 255],\n    [106, 232, 73, 255],\n    [124, 119, 186, 255],\n    [193, 142, 112, 255],\n    [105, 200, 168, 255],\n    [203, 97, 208, 255],\n    [184, 215, 90, 255],\n    [83, 147, 222, 255],\n    [229, 76, 101, 255],\n    [122, 183, 130, 255],\n    [146, 115, 190, 255],\n    [197, 171, 108, 255],\n    [100, 205, 205, 255],\n    [212, 93, 177, 255],\n    [141, 219, 86, 255],\n    [79, 97, 226, 255],\n    [233, 99, 72, 255],\n    [118, 187, 150, 255],\n    [173, 111, 194, 255],\n    [197, 201, 104, 255],\n    [96, 171, 209, 255],\n    [216, 89, 137, 255],\n    [94, 223, 82, 255],\n    [107, 75, 230, 255],\n    [184, 153, 121, 255],\n    [114, 191, 175, 255],\n    [198, 107, 191, 255],\n    [166, 206, 99, 255],\n    [92, 132, 213, 255],\n    [220, 85, 91, 255],\n    [78, 227, 115, 255],\n    [159, 71, 234, 255],\n    [188, 176, 117, 255],\n    [110, 185, 195, 255],\n    [202, 103, 161, 255],\n    [129, 210, 95, 255],\n    [88, 88, 217, 255],\n    [224, 123, 81, 255],\n    [74, 231, 166, 255],\n    [177, 120, 185, 255],\n    [179, 192, 113, 255],\n    [106, 156, 199, 255],\n    [207, 98, 125, 255],\n    [91, 214, 96, 255],\n    [130, 84, 221, 255],\n    [228, 171, 77, 255],\n    [70, 235, 221, 255],\n    [189, 116, 174, 255],\n    [153, 196, 109, 255],\n    [101, 123, 204, 255],\n    [211, 104, 94, 255],\n    [87, 218, 136, 255],\n    [177, 80, 225, 255],\n    [232, 225, 73, 255],\n    [119, 169, 186, 255],\n    [193, 112, 149, 255],\n    [121, 200, 105, 255],\n    [111, 97, 208, 255],\n    [215, 142, 90, 255],\n    [83, 222, 181, 255],\n    [229, 76, 229, 255],\n    [165, 183, 122, 255],\n    [115, 146, 190, 255],\n    [197, 108, 119, 255],\n    [100, 205, 118, 255],\n    [148, 93, 212, 255],\n    [219, 186, 86, 255],\n    [79, 220, 226, 255],\n    [233, 72, 179, 255],\n    [144, 187, 118, 255],\n    [111, 118, 194, 255],\n    [201, 124, 104, 255],\n    [96, 209, 153, 255],\n    [189, 89, 216, 255],\n    [211, 223, 82, 255],\n    [75, 172, 230, 255],\n    [184, 121, 142, 255],\n    [117, 191, 114, 255],\n    [130, 107, 198, 255],\n    [206, 157, 99, 255],\n    [92, 213, 193, 255],\n    [220, 85, 203, 255],\n    [165, 227, 78, 255],\n    [71, 118, 234, 255],\n    [188, 117, 117, 255],\n    [110, 195, 135, 255],\n    [161, 103, 202, 255],\n    [210, 195, 95, 255],\n    [88, 195, 217, 255],\n    [224, 81, 158, 255],\n    [113, 231, 74, 255],\n    [123, 120, 185, 255],\n    [192, 139, 113, 255],\n    [106, 199, 164, 255],\n    [198, 98, 207, 255],\n    [188, 214, 91, 255],\n    [84, 153, 221, 255],\n    [228, 77, 108, 255],\n    [70, 235, 84, 255],\n    [143, 116, 189, 255],\n    [196, 167, 109, 255],\n    [101, 204, 199, 255],\n    [211, 94, 182, 255],\n    [147, 218, 87, 255],\n    [80, 104, 225, 255],\n    [232, 93, 73, 255],\n    [119, 186, 147, 255],\n    [170, 112, 193, 255],\n    [200, 200, 105, 255],\n    [97, 175, 208, 255],\n    [215, 90, 142, 255],\n    [100, 222, 83, 255],\n    [101, 76, 229, 255],\n    [183, 150, 122, 255],\n    [115, 190, 171, 255],\n    [197, 108, 194, 255],\n    [170, 205, 100, 255],\n    [93, 138, 212, 255],\n    [219, 86, 97, 255],\n    [79, 226, 110, 255],\n    [153, 72, 233, 255],\n    [187, 173, 118, 255],\n    [111, 187, 194, 255],\n    [201, 104, 165, 255],\n    [134, 209, 96, 255],\n    [89, 95, 216, 255],\n    [223, 117, 82, 255],\n    [75, 230, 159, 255],\n    [174, 121, 184, 255],\n    [182, 191, 114, 255],\n    [107, 160, 198, 255],\n    [206, 99, 130, 255],\n    [92, 213, 92, 255],\n    [124, 85, 220, 255],\n    [227, 165, 78, 255],\n    [71, 234, 214, 255],\n    [188, 117, 176, 255],\n    [156, 195, 110, 255],\n    [103, 128, 202, 255],\n    [210, 100, 95, 255],\n    [88, 217, 131, 255],\n    [170, 81, 224, 255],\n    [231, 218, 74, 255],\n    [120, 172, 185, 255],\n    [192, 113, 153, 255],\n    [125, 199, 106, 255],\n    [107, 98, 207, 255],\n    [214, 137, 91, 255],\n    [84, 221, 175, 255],\n    [222, 77, 228, 255],\n    [194, 235, 70, 255],\n    [116, 149, 189, 255],\n    [196, 109, 123, 255],\n    [101, 204, 114, 255],\n    [143, 94, 211, 255],\n    [218, 180, 87, 255],\n    [80, 225, 225, 255],\n    [232, 73, 186, 255],\n    [147, 186, 119, 255],\n    [112, 122, 193, 255],\n    [200, 121, 105, 255],\n    [97, 208, 148, 255],\n    [184, 90, 215, 255],\n    [216, 222, 83, 255],\n    [76, 178, 229, 255],\n    [183, 122, 145, 255],\n    [121, 190, 115, 255],\n    [126, 108, 197, 255],\n    [205, 153, 100, 255],\n    [93, 212, 187, 255],\n    [219, 86, 208, 255],\n    [171, 226, 79, 255],\n    [72, 126, 233, 255],\n    [187, 118, 121, 255],\n    [111, 194, 132, 255],\n    [157, 104, 201, 255],\n    [209, 190, 96, 255],\n    [89, 200, 216, 255],\n    [223, 82, 164, 255],\n    [120, 230, 75, 255],\n    [121, 121, 184, 255],\n    [191, 136, 114, 255],\n    [107, 198, 160, 255],\n    [192, 99, 206, 255],\n    [193, 213, 92, 255],\n    [85, 158, 220, 255],\n    [227, 78, 115, 255],\n    [71, 234, 78, 255],\n    [141, 117, 188, 255],\n    [195, 163, 110, 255],\n    [103, 202, 194, 255],\n    [210, 95, 186, 255],\n    [153, 217, 88, 255],\n    [81, 111, 224, 255],\n];\nexport default CORNERSTONE_COLOR_LUT;\n","import { state } from '../store/state';\nimport { getEnabledElement } from '@cornerstonejs/core';\nconst VIEWPORT_ELEMENT = 'viewport-element';\nfunction getSvgDrawingHelper(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewportId, renderingEngineId } = enabledElement;\n    const canvasHash = `${viewportId}:${renderingEngineId}`;\n    const svgLayerElement = _getSvgLayer(element);\n    Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n        state.svgNodeCache[canvasHash][cacheKey].touched = false;\n    });\n    return {\n        svgLayerElement: svgLayerElement,\n        svgNodeCacheForCanvas: state.svgNodeCache,\n        getSvgNode: getSvgNode.bind(this, canvasHash),\n        appendNode: appendNode.bind(this, svgLayerElement, canvasHash),\n        setNodeTouched: setNodeTouched.bind(this, canvasHash),\n        clearUntouched: clearUntouched.bind(this, svgLayerElement, canvasHash),\n    };\n}\nfunction _getSvgLayer(element) {\n    const viewportElement = `.${VIEWPORT_ELEMENT}`;\n    const internalDivElement = element.querySelector(viewportElement);\n    const svgLayer = internalDivElement?.querySelector(':scope > .svg-layer');\n    return svgLayer;\n}\nfunction getSvgNode(canvasHash, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    if (state.svgNodeCache[canvasHash][cacheKey]) {\n        return state.svgNodeCache[canvasHash][cacheKey].domRef;\n    }\n}\nfunction appendNode(svgLayerElement, canvasHash, svgNode, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return null;\n    }\n    state.svgNodeCache[canvasHash][cacheKey] = {\n        touched: true,\n        domRef: svgNode,\n    };\n    svgLayerElement.appendChild(svgNode);\n}\nfunction setNodeTouched(canvasHash, cacheKey) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    if (state.svgNodeCache[canvasHash][cacheKey]) {\n        state.svgNodeCache[canvasHash][cacheKey].touched = true;\n    }\n}\nfunction clearUntouched(svgLayerElement, canvasHash) {\n    if (!state.svgNodeCache[canvasHash]) {\n        return;\n    }\n    Object.keys(state.svgNodeCache[canvasHash]).forEach((cacheKey) => {\n        const cacheEntry = state.svgNodeCache[canvasHash][cacheKey];\n        if (!cacheEntry.touched && cacheEntry.domRef) {\n            svgLayerElement.removeChild(cacheEntry.domRef);\n            delete state.svgNodeCache[canvasHash][cacheKey];\n        }\n    });\n}\nexport default getSvgDrawingHelper;\n","import getSvgDrawingHelper from './getSvgDrawingHelper';\nfunction draw(element, fn) {\n    const svgDrawingHelper = getSvgDrawingHelper(element);\n    fn(svgDrawingHelper);\n    svgDrawingHelper.clearUntouched();\n}\nexport default draw;\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nfunction drawCircle(svgDrawingHelper, annotationUID, circleUID, center, radius, options = {}, dataId = '') {\n    const { color, fill, width, lineWidth, lineDash, fillOpacity, strokeOpacity, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        fill: 'transparent',\n        width: '2',\n        lineDash: undefined,\n        lineWidth: undefined,\n        strokeOpacity: 1,\n        fillOpacity: 1,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'circle', circleUID);\n    const existingCircleElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const attributes = {\n        cx: `${center[0]}`,\n        cy: `${center[1]}`,\n        r: `${radius}`,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n        'fill-opacity': fillOpacity,\n        'stroke-opacity': strokeOpacity,\n    };\n    if (existingCircleElement) {\n        setAttributesIfNecessary(attributes, existingCircleElement);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newCircleElement = document.createElementNS(svgns, 'circle');\n        if (dataId !== '') {\n            newCircleElement.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, newCircleElement);\n        svgDrawingHelper.appendNode(newCircleElement, svgNodeHash);\n    }\n}\nexport default drawCircle;\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nfunction drawEllipseByCoordinates(svgDrawingHelper, annotationUID, ellipseUID, canvasCoordinates, options = {}, dataId = '') {\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'ellipse', ellipseUID);\n    const existingEllipse = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const [bottom, top, left, right] = canvasCoordinates;\n    const w = Math.hypot(left[0] - right[0], left[1] - right[1]);\n    const h = Math.hypot(top[0] - bottom[0], top[1] - bottom[1]);\n    const angle = (Math.atan2(left[1] - right[1], left[0] - right[0]) * 180) / Math.PI;\n    const center = [(left[0] + right[0]) / 2, (top[1] + bottom[1]) / 2];\n    const radiusX = w / 2;\n    const radiusY = h / 2;\n    const attributes = {\n        cx: `${center[0]}`,\n        cy: `${center[1]}`,\n        rx: `${radiusX}`,\n        ry: `${radiusY}`,\n        stroke: color,\n        fill: 'transparent',\n        transform: `rotate(${angle} ${center[0]} ${center[1]})`,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingEllipse) {\n        setAttributesIfNecessary(attributes, existingEllipse);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgEllipseElement = document.createElementNS(svgns, 'ellipse');\n        if (dataId !== '') {\n            svgEllipseElement.setAttribute('data-id', dataId);\n        }\n        setNewAttributesIfValid(attributes, svgEllipseElement);\n        svgDrawingHelper.appendNode(svgEllipseElement, svgNodeHash);\n    }\n}\nexport default drawEllipseByCoordinates;\n","import drawHandle from './drawHandle';\nfunction drawHandles(svgDrawingHelper, annotationUID, handleGroupUID, handlePoints, options = {}) {\n    handlePoints.forEach((handle, i) => {\n        drawHandle(svgDrawingHelper, annotationUID, handleGroupUID, handle, options, i);\n    });\n}\nexport default drawHandles;\n","import drawLine from './drawLine';\nimport findClosestPoint from '../utilities/math/vec2/findClosestPoint';\nfunction drawLink(svgDrawingHelper, annotationUID, linkUID, annotationAnchorPoints, refPoint, boundingBox, options = {}) {\n    const start = annotationAnchorPoints.length > 0\n        ? findClosestPoint(annotationAnchorPoints, refPoint)\n        : refPoint;\n    const boundingBoxPoints = _boundingBoxPoints(boundingBox);\n    const end = findClosestPoint(boundingBoxPoints, start);\n    const mergedOptions = Object.assign({\n        color: 'rgb(255, 255, 0)',\n        lineWidth: '1',\n        lineDash: '2,3',\n    }, options);\n    drawLine(svgDrawingHelper, annotationUID, `link-${linkUID}`, start, end, mergedOptions);\n}\nfunction _boundingBoxPoints(boundingBox) {\n    const { x: left, y: top, height, width } = boundingBox;\n    const halfWidth = width / 2;\n    const halfHeight = height / 2;\n    const topMiddle = [left + halfWidth, top];\n    const leftMiddle = [left, top + halfHeight];\n    const bottomMiddle = [left + halfWidth, top + height];\n    const rightMiddle = [left + width, top + halfHeight];\n    return [topMiddle, leftMiddle, bottomMiddle, rightMiddle];\n}\nexport default drawLink;\n","import drawTextBox from './drawTextBox';\nimport drawLink from './drawLink';\nfunction drawLinkedTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, annotationAnchorPoints, textBox, options = {}) {\n    const mergedOptions = Object.assign({\n        handleRadius: '6',\n        centering: {\n            x: false,\n            y: true,\n        },\n    }, options);\n    const canvasBoundingBox = drawTextBox(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, mergedOptions);\n    drawLink(svgDrawingHelper, annotationUID, textBoxUID, annotationAnchorPoints, textBoxPosition, canvasBoundingBox, mergedOptions);\n    return canvasBoundingBox;\n}\nexport default drawLinkedTextBox;\n","import _getHash from './_getHash';\nimport drawRectByCoordinates from './drawRectByCoordinates';\nexport default function drawRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}, dataId = '') {\n    const topLeft = [start[0], start[1]];\n    const topRight = [end[0], start[1]];\n    const bottomLeft = [start[0], end[1]];\n    const bottomRight = [end[0], end[1]];\n    drawRectByCoordinates(svgDrawingHelper, annotationUID, rectangleUID, [topLeft, topRight, bottomLeft, bottomRight], options, dataId);\n}\n","import drawLine from './drawLine';\nexport default function drawHeight(svgDrawingHelper, annotationUID, heightUID, start, end, options = {}) {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { color, width, lineWidth, lineDash } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const midX = end[0] + (start[0] - end[0]) / 2;\n    const endfirstLine = [midX, start[1]];\n    const endsecondLine = [midX, end[1]];\n    const firstLine = {\n        start: start,\n        end: endfirstLine,\n    };\n    const secondLine = {\n        start: endfirstLine,\n        end: endsecondLine,\n    };\n    const threeLine = {\n        start: endsecondLine,\n        end: end,\n    };\n    drawLine(svgDrawingHelper, annotationUID, '1', firstLine.start, firstLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '2', secondLine.start, secondLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '3', threeLine.start, threeLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n}\n","import _getHash from './_getHash';\nimport setAttributesIfNecessary from './setAttributesIfNecessary';\nimport setNewAttributesIfValid from './setNewAttributesIfValid';\nfunction drawFan(svgDrawingHelper, annotationUID, fanUID, center, innerRadius, outerRadius, startAngle, endAngle, options = {}, dataId = '', zIndex) {\n    const { color, fill, width, lineWidth, lineDash, fillOpacity, strokeOpacity, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        fill: 'transparent',\n        width: '2',\n        lineDash: undefined,\n        lineWidth: undefined,\n        strokeOpacity: 1,\n        fillOpacity: 1,\n    }, options);\n    const strokeWidth = lineWidth || width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'fan', fanUID);\n    const existingFanElement = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const startRad = (startAngle * Math.PI) / 180;\n    const endRad = (endAngle * Math.PI) / 180;\n    const centerX = center[0];\n    const centerY = center[1];\n    const outerStartX = centerX + outerRadius * Math.cos(startRad);\n    const outerStartY = centerY + outerRadius * Math.sin(startRad);\n    const outerEndX = centerX + outerRadius * Math.cos(endRad);\n    const outerEndY = centerY + outerRadius * Math.sin(endRad);\n    const innerStartX = centerX + innerRadius * Math.cos(startRad);\n    const innerStartY = centerY + innerRadius * Math.sin(startRad);\n    const innerEndX = centerX + innerRadius * Math.cos(endRad);\n    const innerEndY = centerY + innerRadius * Math.sin(endRad);\n    const largeArcFlag = endAngle - startAngle <= 180 ? 0 : 1;\n    let pathData = `M ${outerStartX} ${outerStartY}`;\n    pathData += ` A ${outerRadius} ${outerRadius} 0 ${largeArcFlag} 1 ${outerEndX} ${outerEndY}`;\n    pathData += ` L ${innerEndX} ${innerEndY}`;\n    pathData += ` A ${innerRadius} ${innerRadius} 0 ${largeArcFlag} 0 ${innerStartX} ${innerStartY}`;\n    pathData += ` Z`;\n    const attributes = {\n        d: pathData,\n        stroke: color,\n        fill,\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n        'fill-opacity': fillOpacity,\n        'stroke-opacity': strokeOpacity,\n        'mix-blend-mode': 'normal',\n    };\n    if (existingFanElement) {\n        setAttributesIfNecessary(attributes, existingFanElement);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const newFanElement = document.createElementNS(svgns, 'path');\n        if (dataId !== '') {\n            newFanElement.setAttribute('data-id', dataId);\n        }\n        if (zIndex !== undefined) {\n            newFanElement.style.zIndex = zIndex.toString();\n        }\n        setNewAttributesIfValid(attributes, newFanElement);\n        svgDrawingHelper.appendNode(newFanElement, svgNodeHash);\n    }\n}\nexport default drawFan;\n","import drawLine from './drawLine';\nconst svgns = 'http://www.w3.org/2000/svg';\nexport default function drawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {\n    if (isNaN(start[0]) || isNaN(start[1]) || isNaN(end[0]) || isNaN(end[1])) {\n        return;\n    }\n    const { viaMarker = false, color = 'rgb(0, 255, 0)', markerSize = 10, } = options;\n    if (!viaMarker) {\n        legacyDrawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options);\n        return;\n    }\n    const layerId = svgDrawingHelper.svgLayerElement.id;\n    const markerBaseId = `arrow-${annotationUID}`;\n    const markerFullId = `${markerBaseId}-${layerId}`;\n    const defs = svgDrawingHelper.svgLayerElement.querySelector('defs');\n    let arrowMarker = defs.querySelector(`#${markerFullId}`);\n    if (!arrowMarker) {\n        arrowMarker = document.createElementNS(svgns, 'marker');\n        arrowMarker.setAttribute('id', markerFullId);\n        arrowMarker.setAttribute('viewBox', '0 0 10 10');\n        arrowMarker.setAttribute('refX', '8');\n        arrowMarker.setAttribute('refY', '5');\n        arrowMarker.setAttribute('markerWidth', `${markerSize}`);\n        arrowMarker.setAttribute('markerHeight', `${markerSize}`);\n        arrowMarker.setAttribute('orient', 'auto');\n        const arrowPath = document.createElementNS(svgns, 'path');\n        arrowPath.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');\n        arrowPath.setAttribute('fill', color);\n        arrowMarker.appendChild(arrowPath);\n        defs.appendChild(arrowMarker);\n    }\n    else {\n        arrowMarker.setAttribute('markerWidth', `${markerSize}`);\n        arrowMarker.setAttribute('markerHeight', `${markerSize}`);\n        const arrowPath = arrowMarker.querySelector('path');\n        if (arrowPath) {\n            arrowPath.setAttribute('fill', color);\n        }\n    }\n    options.markerEndId = markerFullId;\n    drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, options);\n}\nfunction legacyDrawArrow(svgDrawingHelper, annotationUID, arrowUID, start, end, options = {}) {\n    const { color = 'rgb(0, 255, 0)', width = 2, lineWidth, lineDash } = options;\n    const headLength = 10;\n    const angle = Math.atan2(end[1] - start[1], end[0] - start[0]);\n    const firstLine = {\n        start: [\n            end[0] - headLength * Math.cos(angle - Math.PI / 7),\n            end[1] - headLength * Math.sin(angle - Math.PI / 7),\n        ],\n        end: end,\n    };\n    const secondLine = {\n        start: [\n            end[0] - headLength * Math.cos(angle + Math.PI / 7),\n            end[1] - headLength * Math.sin(angle + Math.PI / 7),\n        ],\n        end: end,\n    };\n    drawLine(svgDrawingHelper, annotationUID, arrowUID, start, end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '2', firstLine.start, firstLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n    drawLine(svgDrawingHelper, annotationUID, '3', secondLine.start, secondLine.end, {\n        color,\n        width,\n        lineWidth,\n        lineDash,\n    });\n}\n","import _getHash from './_getHash';\nimport _setAttributesIfNecessary from './setAttributesIfNecessary';\nimport _setNewAttributesIfValid from './setNewAttributesIfValid';\nexport default function drawRedactionRect(svgDrawingHelper, annotationUID, rectangleUID, start, end, options = {}) {\n    const { color, width: _width, lineWidth, lineDash, } = Object.assign({\n        color: 'rgb(0, 255, 0)',\n        width: '2',\n        lineWidth: undefined,\n        lineDash: undefined,\n    }, options);\n    const strokeWidth = lineWidth || _width;\n    const svgns = 'http://www.w3.org/2000/svg';\n    const svgNodeHash = _getHash(annotationUID, 'rect', rectangleUID);\n    const existingRect = svgDrawingHelper.getSvgNode(svgNodeHash);\n    const tlhc = [Math.min(start[0], end[0]), Math.min(start[1], end[1])];\n    const width = Math.abs(start[0] - end[0]);\n    const height = Math.abs(start[1] - end[1]);\n    const attributes = {\n        x: `${tlhc[0]}`,\n        y: `${tlhc[1]}`,\n        width: `${width}`,\n        height: `${height}`,\n        stroke: color,\n        fill: 'black',\n        'stroke-width': strokeWidth,\n        'stroke-dasharray': lineDash,\n    };\n    if (existingRect) {\n        _setAttributesIfNecessary(attributes, existingRect);\n        svgDrawingHelper.setNodeTouched(svgNodeHash);\n    }\n    else {\n        const svgRectElement = document.createElementNS(svgns, 'rect');\n        _setNewAttributesIfValid(attributes, svgRectElement);\n        svgDrawingHelper.appendNode(svgRectElement, svgNodeHash);\n    }\n}\n","var ChangeTypes;\n(function (ChangeTypes) {\n    ChangeTypes[\"Interaction\"] = \"Interaction\";\n    ChangeTypes[\"HandlesUpdated\"] = \"HandlesUpdated\";\n    ChangeTypes[\"StatsUpdated\"] = \"StatsUpdated\";\n    ChangeTypes[\"InitialSetup\"] = \"InitialSetup\";\n    ChangeTypes[\"Completed\"] = \"Completed\";\n    ChangeTypes[\"InterpolationUpdated\"] = \"InterpolationUpdated\";\n    ChangeTypes[\"History\"] = \"History\";\n    ChangeTypes[\"MetadataReferenceModified\"] = \"MetadataReferenceModified\";\n    ChangeTypes[\"LabelChange\"] = \"LabelChange\";\n})(ChangeTypes || (ChangeTypes = {}));\nexport default ChangeTypes;\n","var Swipe;\n(function (Swipe) {\n    Swipe[\"UP\"] = \"UP\";\n    Swipe[\"DOWN\"] = \"DOWN\";\n    Swipe[\"LEFT\"] = \"LEFT\";\n    Swipe[\"RIGHT\"] = \"RIGHT\";\n})(Swipe || (Swipe = {}));\nexport { Swipe };\n","import vtkDataArray from '@kitware/vtk.js/Common/Core/DataArray';\nimport vtkImageData from '@kitware/vtk.js/Common/DataModel/ImageData';\nimport { BaseVolumeViewport, getEnabledElement, Enums, getEnabledElementByIds, cache, utilities, } from '@cornerstonejs/core';\nimport { triggerSegmentationRender } from '../../stateManagement/segmentation/SegmentationRenderingEngine';\nimport { updateLabelmapSegmentationImageReferences } from '../../stateManagement/segmentation/updateLabelmapSegmentationImageReferences';\nimport { getCurrentLabelmapImageIdsForViewport } from '../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { SegmentationRepresentations } from '../../enums';\nimport { getLabelmapActorEntries } from '../../stateManagement/segmentation/helpers/getSegmentationActor';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/getSegmentationRepresentation';\nconst enable = function (element) {\n    if (!element) {\n        return;\n    }\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    if (viewport instanceof BaseVolumeViewport) {\n        return;\n    }\n    element.addEventListener(Enums.Events.PRE_STACK_NEW_IMAGE, _imageChangeEventListener);\n    element.addEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n};\nconst disable = function (element) {\n    element.removeEventListener(Enums.Events.PRE_STACK_NEW_IMAGE, _imageChangeEventListener);\n    element.removeEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n};\nconst perViewportManualTriggers = new Map();\nfunction _imageChangeEventListener(evt) {\n    const eventData = evt.detail;\n    const { viewportId, renderingEngineId } = eventData;\n    const { viewport } = getEnabledElementByIds(viewportId, renderingEngineId);\n    const representations = getSegmentationRepresentations(viewportId);\n    if (!representations?.length) {\n        return;\n    }\n    const labelmapRepresentations = representations.filter((representation) => representation.type === SegmentationRepresentations.Labelmap);\n    const actors = viewport.getActors();\n    labelmapRepresentations.forEach((representation) => {\n        const { segmentationId } = representation;\n        updateLabelmapSegmentationImageReferences(viewportId, segmentationId);\n    });\n    const labelmapActors = labelmapRepresentations\n        .flatMap((representation) => {\n        return getLabelmapActorEntries(viewportId, representation.segmentationId);\n    })\n        .filter((actor) => actor !== undefined);\n    if (!labelmapActors.length) {\n        return;\n    }\n    labelmapActors.forEach((actor) => {\n        const validActor = labelmapRepresentations.find((representation) => {\n            const derivedImageIds = getCurrentLabelmapImageIdsForViewport(viewportId, representation.segmentationId);\n            return derivedImageIds?.includes(actor.referencedId);\n        });\n        if (!validActor) {\n            viewport.removeActors([actor.uid]);\n        }\n    });\n    labelmapRepresentations.forEach((representation) => {\n        const { segmentationId } = representation;\n        const currentImageId = viewport.getCurrentImageId();\n        const derivedImageIds = getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId);\n        if (!derivedImageIds) {\n            return;\n        }\n        let shouldTriggerSegmentationRender = false;\n        const updateSegmentationActor = (derivedImageId) => {\n            const derivedImage = cache.getImage(derivedImageId);\n            if (!derivedImage) {\n                console.warn('No derived image found in the cache for segmentation representation', representation);\n                return;\n            }\n            const segmentationActorInput = actors.find((actor) => actor.referencedId === derivedImageId);\n            if (!segmentationActorInput) {\n                const { dimensions, spacing, direction } = viewport.getImageDataMetadata(derivedImage);\n                const currentImage = cache.getImage(currentImageId) ||\n                    {\n                        imageId: currentImageId,\n                    };\n                const { origin: currentOrigin } = viewport.getImageDataMetadata(currentImage);\n                const originToUse = currentOrigin;\n                const constructor = derivedImage.voxelManager.getConstructor();\n                const newPixelData = derivedImage.voxelManager.getScalarData();\n                const scalarArray = vtkDataArray.newInstance({\n                    name: 'Pixels',\n                    numberOfComponents: 1,\n                    values: new constructor(newPixelData),\n                });\n                const imageData = vtkImageData.newInstance();\n                imageData.setDimensions(dimensions[0], dimensions[1], 1);\n                imageData.setSpacing(spacing);\n                imageData.setDirection(direction);\n                imageData.setOrigin(originToUse);\n                imageData.getPointData().setScalars(scalarArray);\n                imageData.modified();\n                viewport.addImages([\n                    {\n                        imageId: derivedImageId,\n                        representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}-${derivedImage.imageId}`,\n                        callback: ({ imageActor }) => {\n                            imageActor.getMapper().setInputData(imageData);\n                        },\n                    },\n                ]);\n                shouldTriggerSegmentationRender = true;\n                return;\n            }\n            else {\n                const segmentationImageData = segmentationActorInput.actor\n                    .getMapper()\n                    .getInputData();\n                if (segmentationImageData.setDerivedImage) {\n                    segmentationImageData.setDerivedImage(derivedImage);\n                }\n                else {\n                    utilities.updateVTKImageDataWithCornerstoneImage(segmentationImageData, derivedImage);\n                }\n            }\n        };\n        derivedImageIds.forEach(updateSegmentationActor);\n        if (shouldTriggerSegmentationRender) {\n            triggerSegmentationRender(viewportId);\n        }\n        viewport.render();\n        if (evt.type === Enums.Events.IMAGE_RENDERED) {\n            viewport.element.removeEventListener(Enums.Events.IMAGE_RENDERED, _imageChangeEventListener);\n        }\n    });\n}\nexport default {\n    enable,\n    disable,\n};\n","import { triggerEvent, eventTarget, Enums, getRenderingEngines, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations, Events as csToolsEvents, } from '../../enums';\nimport Representations from '../../enums/SegmentationRepresentations';\nimport { getSegmentation } from './getSegmentation';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nimport surfaceDisplay from '../../tools/displayTools/Surface/surfaceDisplay';\nimport contourDisplay from '../../tools/displayTools/Contour/contourDisplay';\nimport labelmapDisplay from '../../tools/displayTools/Labelmap/labelmapDisplay';\nimport { addTool } from '../../store/addTool';\nimport { state } from '../../store/state';\nimport PlanarFreehandContourSegmentationTool from '../../tools/annotation/PlanarFreehandContourSegmentationTool';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport { addDefaultSegmentationListener } from './segmentationEventManager';\nconst renderers = {\n    [Representations.Labelmap]: labelmapDisplay,\n    [Representations.Contour]: contourDisplay,\n    [Representations.Surface]: surfaceDisplay,\n};\nconst planarContourToolName = PlanarFreehandContourSegmentationTool.toolName;\nclass SegmentationRenderingEngine {\n    constructor() {\n        this._needsRender = new Set();\n        this._pendingRenderQueue = [];\n        this._animationFrameSet = false;\n        this._animationFrameHandle = null;\n        this._getAllViewports = () => {\n            const renderingEngine = getRenderingEngines();\n            return renderingEngine.flatMap((renderingEngine) => renderingEngine.getViewports());\n        };\n        this._renderFlaggedSegmentations = () => {\n            this._throwIfDestroyed();\n            const viewportIds = Array.from(this._needsRender);\n            viewportIds.forEach((viewportId) => {\n                this._triggerRender(viewportId);\n            });\n            this._needsRender.clear();\n            this._animationFrameSet = false;\n            this._animationFrameHandle = null;\n            if (this._pendingRenderQueue.length > 0) {\n                const nextViewportIds = this._pendingRenderQueue.shift();\n                if (nextViewportIds && nextViewportIds.length > 0) {\n                    this._setViewportsToBeRenderedNextFrame(nextViewportIds);\n                }\n            }\n        };\n    }\n    renderSegmentationsForViewport(viewportId) {\n        const viewportIds = viewportId\n            ? [viewportId]\n            : this._getViewportIdsForSegmentation();\n        this._setViewportsToBeRenderedNextFrame(viewportIds);\n    }\n    renderSegmentation(segmentationId) {\n        const viewportIds = this._getViewportIdsForSegmentation(segmentationId);\n        this._setViewportsToBeRenderedNextFrame(viewportIds);\n    }\n    _getViewportIdsForSegmentation(segmentationId) {\n        const viewports = this._getAllViewports();\n        const viewportIds = [];\n        for (const viewport of viewports) {\n            const viewportId = viewport.id;\n            if (segmentationId) {\n                const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n                if (segmentationRepresentations?.length > 0) {\n                    viewportIds.push(viewportId);\n                }\n            }\n            else {\n                const segmentationRepresentations = getSegmentationRepresentations(viewportId);\n                if (segmentationRepresentations?.length > 0) {\n                    viewportIds.push(viewportId);\n                }\n            }\n        }\n        return viewportIds;\n    }\n    _throwIfDestroyed() {\n        if (this.hasBeenDestroyed) {\n            throw new Error('this.destroy() has been manually called to free up memory, can not longer use this instance. Instead make a new one.');\n        }\n    }\n    _setViewportsToBeRenderedNextFrame(viewportIds) {\n        if (this._animationFrameSet) {\n            this._pendingRenderQueue.push(viewportIds);\n            return;\n        }\n        viewportIds.forEach((viewportId) => {\n            this._needsRender.add(viewportId);\n        });\n        this._render();\n    }\n    _render() {\n        if (this._needsRender.size > 0 && this._animationFrameSet === false) {\n            this._animationFrameHandle = window.requestAnimationFrame(this._renderFlaggedSegmentations);\n            this._animationFrameSet = true;\n        }\n    }\n    _triggerRender(viewportId) {\n        const segmentationRepresentations = getSegmentationRepresentations(viewportId);\n        if (!segmentationRepresentations?.length) {\n            return;\n        }\n        const { viewport } = getEnabledElementByViewportId(viewportId) || {};\n        if (!viewport) {\n            return;\n        }\n        const segmentationRenderList = segmentationRepresentations.map((representation) => {\n            if (representation.type === SegmentationRepresentations.Contour) {\n                this._addPlanarFreeHandToolIfAbsent(viewport);\n            }\n            const display = renderers[representation.type];\n            const segmentation = getSegmentation(representation.segmentationId);\n            const existingRepresentation = segmentation.representationData[representation.type] !== undefined;\n            try {\n                display.render(viewport, representation).then(() => {\n                    if (!existingRepresentation) {\n                        addDefaultSegmentationListener(viewport, representation.segmentationId, representation.type);\n                    }\n                });\n            }\n            catch (error) {\n                console.error(error);\n            }\n            return Promise.resolve({\n                segmentationId: representation.segmentationId,\n                type: representation.type,\n            });\n        });\n        Promise.allSettled(segmentationRenderList).then((results) => {\n            const segmentationDetails = results\n                .filter((r) => r.status === 'fulfilled')\n                .map((r) => r.value);\n            function onSegmentationRender(evt) {\n                const { element, viewportId } = evt.detail;\n                element.removeEventListener(Enums.Events.IMAGE_RENDERED, onSegmentationRender);\n                segmentationDetails.forEach((detail) => {\n                    const eventDetail = {\n                        viewportId,\n                        segmentationId: detail.segmentationId,\n                        type: detail.type,\n                    };\n                    triggerEvent(eventTarget, csToolsEvents.SEGMENTATION_RENDERED, {\n                        ...eventDetail,\n                    });\n                });\n            }\n            const element = viewport.element;\n            element.addEventListener(Enums.Events.IMAGE_RENDERED, onSegmentationRender);\n            viewport.render();\n        });\n    }\n    _addPlanarFreeHandToolIfAbsent(viewport) {\n        if (!(planarContourToolName in state.tools)) {\n            addTool(PlanarFreehandContourSegmentationTool);\n        }\n        const toolGroup = getToolGroupForViewport(viewport.id);\n        if (!toolGroup.hasTool(planarContourToolName)) {\n            toolGroup.addTool(planarContourToolName);\n            toolGroup.setToolPassive(planarContourToolName);\n        }\n    }\n}\nfunction triggerSegmentationRender(viewportId) {\n    segmentationRenderingEngine.renderSegmentationsForViewport(viewportId);\n}\nfunction triggerSegmentationRenderBySegmentationId(segmentationId) {\n    segmentationRenderingEngine.renderSegmentation(segmentationId);\n}\nconst segmentationRenderingEngine = new SegmentationRenderingEngine();\nexport { triggerSegmentationRender, triggerSegmentationRenderBySegmentationId, segmentationRenderingEngine, };\n","import { BaseVolumeViewport, cache, utilities as csUtils, getEnabledElementByViewportId, volumeLoader, } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport vtkColorTransferFunction from '@kitware/vtk.js/Rendering/Core/ColorTransferFunction';\nimport vtkPiecewiseFunction from '@kitware/vtk.js/Common/DataModel/PiecewiseFunction';\nimport { triggerSegmentationModified, triggerSegmentationRemoved, triggerSegmentationRepresentationModified, triggerSegmentationRepresentationRemoved, } from './triggerSegmentationEvents';\nimport { segmentationStyle } from './SegmentationStyle';\nimport { triggerSegmentationAdded } from './events/triggerSegmentationAdded';\nconst initialDefaultState = {\n    colorLUT: [],\n    segmentations: [],\n    viewportSegRepresentations: {},\n};\nexport default class SegmentationStateManager {\n    constructor(uid) {\n        this._stackLabelmapImageIdReferenceMap = new Map();\n        this._labelmapImageIdReferenceMap = new Map();\n        uid ||= csUtils.uuidv4();\n        this.state = Object.freeze(csUtils.deepClone(initialDefaultState));\n        this.uid = uid;\n    }\n    getState() {\n        return this.state;\n    }\n    updateState(updater) {\n        const newState = csUtils.deepClone(this.state);\n        updater(newState);\n        this.state = Object.freeze(newState);\n    }\n    getColorLUT(lutIndex) {\n        return this.state.colorLUT[lutIndex];\n    }\n    getNextColorLUTIndex() {\n        return this.state.colorLUT.length;\n    }\n    resetState() {\n        this._stackLabelmapImageIdReferenceMap.clear();\n        this._labelmapImageIdReferenceMap.clear();\n        this.state = Object.freeze(csUtils.deepClone(initialDefaultState));\n    }\n    getSegmentation(segmentationId) {\n        return this.state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n    }\n    updateSegmentation(segmentationId, payload) {\n        this.updateState((draftState) => {\n            const segmentation = draftState.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n            if (!segmentation) {\n                console.warn(`Segmentation with id ${segmentationId} not found. Update aborted.`);\n                return;\n            }\n            Object.assign(segmentation, payload);\n        });\n        triggerSegmentationModified(segmentationId);\n    }\n    addSegmentation(segmentation) {\n        if (this.getSegmentation(segmentation.segmentationId)) {\n            throw new Error(`Segmentation with id ${segmentation.segmentationId} already exists`);\n        }\n        this.updateState((state) => {\n            const newSegmentation = csUtils.deepClone(segmentation);\n            if (newSegmentation.representationData.Labelmap &&\n                'volumeId' in newSegmentation.representationData.Labelmap &&\n                !('imageIds' in newSegmentation.representationData.Labelmap)) {\n                const imageIds = this.getLabelmapImageIds(newSegmentation.representationData);\n                newSegmentation.representationData\n                    .Labelmap.imageIds = imageIds;\n            }\n            state.segmentations.push(newSegmentation);\n        });\n        triggerSegmentationAdded(segmentation.segmentationId);\n    }\n    removeSegmentation(segmentationId) {\n        this.updateState((state) => {\n            const filteredSegmentations = state.segmentations.filter((segmentation) => segmentation.segmentationId !== segmentationId);\n            state.segmentations.splice(0, state.segmentations.length, ...filteredSegmentations);\n        });\n        triggerSegmentationRemoved(segmentationId);\n    }\n    addSegmentationRepresentation(viewportId, segmentationId, type, renderingConfig) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const existingRepresentations = this.getSegmentationRepresentations(viewportId, {\n            type: type,\n            segmentationId,\n        });\n        if (existingRepresentations.length > 0) {\n            console.debug('A segmentation representation of type', type, 'already exists in viewport', viewportId, 'for segmentation', segmentationId);\n            return;\n        }\n        this.updateState((state) => {\n            if (!state.viewportSegRepresentations[viewportId]) {\n                state.viewportSegRepresentations[viewportId] = [];\n                segmentationStyle.setRenderInactiveSegmentations(viewportId, true);\n            }\n            if (type !== SegmentationRepresentations.Labelmap) {\n                this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig);\n            }\n            else {\n                this.addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig);\n            }\n        });\n        triggerSegmentationRepresentationModified(viewportId, segmentationId, type);\n    }\n    addDefaultSegmentationRepresentation(state, viewportId, segmentationId, type, renderingConfig) {\n        const segmentation = state.segmentations.find((segmentation) => segmentation.segmentationId === segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const segmentReps = {};\n        Object.keys(segmentation.segments).forEach((segmentIndex) => {\n            segmentReps[Number(segmentIndex)] = {\n                visible: true,\n            };\n        });\n        state.viewportSegRepresentations[viewportId].push({\n            segmentationId,\n            type,\n            active: true,\n            visible: true,\n            colorLUTIndex: renderingConfig?.colorLUTIndex || 0,\n            segments: segmentReps,\n            config: {\n                ...getDefaultRenderingConfig(type),\n                ...renderingConfig,\n            },\n        });\n        this._setActiveSegmentation(state, viewportId, segmentationId);\n    }\n    addLabelmapRepresentation(state, viewportId, segmentationId, renderingConfig = getDefaultRenderingConfig(SegmentationRepresentations.Labelmap)) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, SegmentationRepresentations.Labelmap, renderingConfig);\n        }\n        this.processLabelmapRepresentationAddition(viewportId, segmentationId);\n        this.addDefaultSegmentationRepresentation(state, viewportId, segmentationId, SegmentationRepresentations.Labelmap, renderingConfig);\n    }\n    async processLabelmapRepresentationAddition(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        const volumeViewport = enabledElement.viewport instanceof BaseVolumeViewport;\n        const { representationData } = segmentation;\n        const isBaseVolumeSegmentation = 'volumeId' in representationData.Labelmap;\n        const viewport = enabledElement.viewport;\n        if (!volumeViewport && !isBaseVolumeSegmentation) {\n            !this.updateLabelmapSegmentationImageReferences(viewportId, segmentation.segmentationId);\n        }\n    }\n    _updateLabelmapSegmentationReferences(segmentationId, viewport, labelmapImageIds, updateCallback) {\n        const referenceImageId = viewport.getCurrentImageId();\n        let viewableLabelmapImageIdFound = false;\n        for (const labelmapImageId of labelmapImageIds) {\n            const viewableImageId = viewport.isReferenceViewable({ referencedImageId: labelmapImageId }, { asOverlay: true });\n            if (viewableImageId) {\n                viewableLabelmapImageIdFound = true;\n                this._stackLabelmapImageIdReferenceMap\n                    .get(segmentationId)\n                    .set(referenceImageId, labelmapImageId);\n                this._updateLabelmapImageIdReferenceMap({\n                    segmentationId,\n                    referenceImageId,\n                    labelmapImageId,\n                });\n            }\n        }\n        if (updateCallback) {\n            updateCallback(viewport, segmentationId, labelmapImageIds);\n        }\n        return viewableLabelmapImageIdFound\n            ? this._stackLabelmapImageIdReferenceMap\n                .get(segmentationId)\n                .get(referenceImageId)\n            : undefined;\n    }\n    updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return;\n        }\n        const labelmapImageIds = this.getLabelmapImageIds(representationData);\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        const stackViewport = enabledElement.viewport;\n        return this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, null);\n    }\n    _updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            this._stackLabelmapImageIdReferenceMap.set(segmentationId, new Map());\n        }\n        const { representationData } = segmentation;\n        if (!representationData.Labelmap) {\n            return;\n        }\n        const labelmapImageIds = this.getLabelmapImageIds(representationData);\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        const stackViewport = enabledElement.viewport;\n        this._updateLabelmapSegmentationReferences(segmentationId, stackViewport, labelmapImageIds, (stackViewport, segmentationId, labelmapImageIds) => {\n            const imageIds = stackViewport.getImageIds();\n            imageIds.forEach((referenceImageId, index) => {\n                for (const labelmapImageId of labelmapImageIds) {\n                    const viewableImageId = stackViewport.isReferenceViewable({ referencedImageId: labelmapImageId, sliceIndex: index }, { asOverlay: true, withNavigation: true });\n                    if (viewableImageId) {\n                        this._stackLabelmapImageIdReferenceMap\n                            .get(segmentationId)\n                            .set(referenceImageId, labelmapImageId);\n                        this._updateLabelmapImageIdReferenceMap({\n                            segmentationId,\n                            referenceImageId,\n                            labelmapImageId,\n                        });\n                    }\n                }\n            });\n        });\n    }\n    getLabelmapImageIds(representationData) {\n        const labelmapData = representationData.Labelmap;\n        let labelmapImageIds;\n        if (labelmapData.imageIds) {\n            labelmapImageIds = labelmapData\n                .imageIds;\n        }\n        else if (!labelmapImageIds &&\n            labelmapData.volumeId) {\n            const volumeId = labelmapData\n                .volumeId;\n            const volume = cache.getVolume(volumeId);\n            labelmapImageIds = volume.imageIds;\n        }\n        return labelmapImageIds;\n    }\n    getLabelmapImageIdsForImageId(imageId, segmentationId) {\n        const key = this._generateMapKey({\n            segmentationId,\n            referenceImageId: imageId,\n        });\n        return this._labelmapImageIdReferenceMap.get(key);\n    }\n    getCurrentLabelmapImageIdsForViewport(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const stackViewport = enabledElement.viewport;\n        const referenceImageId = stackViewport.getCurrentImageId();\n        return this.getLabelmapImageIdsForImageId(referenceImageId, segmentationId);\n    }\n    getCurrentLabelmapImageIdForViewport(viewportId, segmentationId) {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        if (!this._stackLabelmapImageIdReferenceMap.has(segmentationId)) {\n            return;\n        }\n        const stackViewport = enabledElement.viewport;\n        const currentImageId = stackViewport.getCurrentImageId();\n        const imageIdReferenceMap = this._stackLabelmapImageIdReferenceMap.get(segmentationId);\n        return imageIdReferenceMap.get(currentImageId);\n    }\n    getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {\n        const segmentation = this.getSegmentation(segmentationId);\n        if (!segmentation) {\n            return [];\n        }\n        this._updateAllLabelmapSegmentationImageReferences(viewportId, segmentationId);\n        const { viewport } = getEnabledElementByViewportId(viewportId);\n        const imageIds = viewport.getImageIds();\n        const associatedReferenceImageAndLabelmapImageIds = this._stackLabelmapImageIdReferenceMap.get(segmentationId);\n        return imageIds.map((imageId) => {\n            return associatedReferenceImageAndLabelmapImageIds.get(imageId);\n        });\n    }\n    removeSegmentationRepresentationsInternal(viewportId, specifier) {\n        const removedRepresentations = [];\n        this.updateState((state) => {\n            if (!state.viewportSegRepresentations[viewportId]) {\n                return;\n            }\n            const currentRepresentations = state.viewportSegRepresentations[viewportId];\n            let activeRepresentationRemoved = false;\n            if (!specifier ||\n                Object.values(specifier).every((value) => value === undefined)) {\n                removedRepresentations.push(...currentRepresentations);\n                delete state.viewportSegRepresentations[viewportId];\n            }\n            else {\n                const { segmentationId, type } = specifier;\n                state.viewportSegRepresentations[viewportId] =\n                    currentRepresentations.filter((representation) => {\n                        const shouldRemove = (segmentationId &&\n                            type &&\n                            representation.segmentationId === segmentationId &&\n                            representation.type === type) ||\n                            (segmentationId &&\n                                !type &&\n                                representation.segmentationId === segmentationId) ||\n                            (!segmentationId && type && representation.type === type);\n                        if (shouldRemove) {\n                            removedRepresentations.push(representation);\n                            if (representation.active) {\n                                activeRepresentationRemoved = true;\n                            }\n                        }\n                        return !shouldRemove;\n                    });\n                if (state.viewportSegRepresentations[viewportId].length === 0) {\n                    delete state.viewportSegRepresentations[viewportId];\n                }\n                else if (activeRepresentationRemoved) {\n                    state.viewportSegRepresentations[viewportId][0].active = true;\n                }\n            }\n        });\n        return removedRepresentations;\n    }\n    removeSegmentationRepresentations(viewportId, specifier) {\n        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);\n        removedRepresentations.forEach((representation) => {\n            triggerSegmentationRepresentationRemoved(viewportId, representation.segmentationId, representation.type);\n        });\n        const remainingRepresentations = this.getSegmentationRepresentations(viewportId);\n        if (remainingRepresentations.length > 0 &&\n            remainingRepresentations[0].active) {\n            triggerSegmentationRepresentationModified(viewportId, remainingRepresentations[0].segmentationId, remainingRepresentations[0].type);\n        }\n        return removedRepresentations;\n    }\n    removeSegmentationRepresentation(viewportId, specifier, suppressEvent) {\n        const removedRepresentations = this.removeSegmentationRepresentationsInternal(viewportId, specifier);\n        if (!suppressEvent) {\n            removedRepresentations.forEach(({ segmentationId, type }) => {\n                triggerSegmentationRepresentationRemoved(viewportId, segmentationId, type);\n            });\n        }\n        return removedRepresentations;\n    }\n    _updateLabelmapImageIdReferenceMap({ segmentationId, referenceImageId, labelmapImageId, }) {\n        const key = this._generateMapKey({ segmentationId, referenceImageId });\n        if (!this._labelmapImageIdReferenceMap.has(key)) {\n            this._labelmapImageIdReferenceMap.set(key, [labelmapImageId]);\n            return;\n        }\n        const currentValues = this._labelmapImageIdReferenceMap.get(key);\n        const newValues = Array.from(new Set([...currentValues, labelmapImageId]));\n        this._labelmapImageIdReferenceMap.set(key, newValues);\n    }\n    _setActiveSegmentation(state, viewportId, segmentationId) {\n        const viewport = state.viewportSegRepresentations[viewportId];\n        if (!viewport) {\n            return;\n        }\n        viewport.forEach((value) => {\n            value.active = value.segmentationId === segmentationId;\n        });\n    }\n    setActiveSegmentation(viewportId, segmentationId) {\n        this.updateState((state) => {\n            const viewport = state.viewportSegRepresentations[viewportId];\n            if (!viewport) {\n                return;\n            }\n            viewport.forEach((value) => {\n                value.active = value.segmentationId === segmentationId;\n            });\n        });\n        triggerSegmentationRepresentationModified(viewportId, segmentationId);\n    }\n    getActiveSegmentation(viewportId) {\n        if (!this.state.viewportSegRepresentations[viewportId]) {\n            return;\n        }\n        const activeSegRep = this.state.viewportSegRepresentations[viewportId].find((segRep) => segRep.active);\n        if (!activeSegRep) {\n            return;\n        }\n        return this.getSegmentation(activeSegRep.segmentationId);\n    }\n    getSegmentationRepresentations(viewportId, specifier = {}) {\n        const viewportRepresentations = this.state.viewportSegRepresentations[viewportId];\n        if (!viewportRepresentations) {\n            return [];\n        }\n        if (!specifier.type && !specifier.segmentationId) {\n            return viewportRepresentations;\n        }\n        return viewportRepresentations.filter((representation) => {\n            const typeMatch = specifier.type\n                ? representation.type === specifier.type\n                : true;\n            const idMatch = specifier.segmentationId\n                ? representation.segmentationId === specifier.segmentationId\n                : true;\n            return typeMatch && idMatch;\n        });\n    }\n    getSegmentationRepresentation(viewportId, specifier) {\n        return this.getSegmentationRepresentations(viewportId, specifier)[0];\n    }\n    getSegmentationRepresentationVisibility(viewportId, specifier) {\n        const viewportRepresentation = this.getSegmentationRepresentation(viewportId, specifier);\n        return viewportRepresentation?.visible;\n    }\n    setSegmentationRepresentationVisibility(viewportId, specifier, visible) {\n        this.updateState((state) => {\n            const viewportRepresentations = this.getSegmentationRepresentations(viewportId, specifier);\n            if (!viewportRepresentations) {\n                return;\n            }\n            viewportRepresentations.forEach((representation) => {\n                representation.visible = visible;\n                Object.entries(representation.segments).forEach(([segmentIndex, segment]) => {\n                    segment.visible = visible;\n                });\n            });\n        });\n        triggerSegmentationRepresentationModified(viewportId, specifier.segmentationId, specifier.type);\n    }\n    addColorLUT(colorLUT, lutIndex) {\n        this.updateState((state) => {\n            if (state.colorLUT[lutIndex]) {\n                console.warn('Color LUT table already exists, overwriting');\n            }\n            state.colorLUT[lutIndex] = csUtils.deepClone(colorLUT);\n        });\n    }\n    removeColorLUT(colorLUTIndex) {\n        this.updateState((state) => {\n            delete state.colorLUT[colorLUTIndex];\n        });\n    }\n    _getStackIdForImageIds(imageIds) {\n        return imageIds\n            .map((imageId) => imageId.slice(-Math.round(imageId.length * 0.15)))\n            .join('_');\n    }\n    getAllViewportSegmentationRepresentations() {\n        return Object.entries(this.state.viewportSegRepresentations).map(([viewportId, representations]) => ({\n            viewportId,\n            representations,\n        }));\n    }\n    getSegmentationRepresentationsBySegmentationId(segmentationId) {\n        const result = [];\n        Object.entries(this.state.viewportSegRepresentations).forEach(([viewportId, viewportReps]) => {\n            const filteredReps = viewportReps.filter((representation) => representation.segmentationId === segmentationId);\n            if (filteredReps.length > 0) {\n                result.push({ viewportId, representations: filteredReps });\n            }\n        });\n        return result;\n    }\n    _generateMapKey({ segmentationId, referenceImageId }) {\n        return `${segmentationId}-${referenceImageId}`;\n    }\n}\nasync function internalComputeVolumeLabelmapFromStack({ imageIds, options, }) {\n    const segmentationImageIds = imageIds;\n    const volumeId = options?.volumeId || csUtils.uuidv4();\n    await volumeLoader.createAndCacheVolumeFromImages(volumeId, segmentationImageIds);\n    return { volumeId };\n}\nasync function internalConvertStackToVolumeLabelmap({ segmentationId, options, }) {\n    const segmentation = defaultSegmentationStateManager.getSegmentation(segmentationId);\n    const data = segmentation.representationData\n        .Labelmap;\n    const { volumeId } = await internalComputeVolumeLabelmapFromStack({\n        imageIds: data.imageIds,\n        options,\n    });\n    segmentation.representationData.Labelmap.volumeId = volumeId;\n}\nfunction getDefaultRenderingConfig(type) {\n    const cfun = vtkColorTransferFunction.newInstance();\n    const ofun = vtkPiecewiseFunction.newInstance();\n    ofun.addPoint(0, 0);\n    if (type === SegmentationRepresentations.Labelmap) {\n        return {\n            cfun,\n            ofun,\n        };\n    }\n    else {\n        return {};\n    }\n}\nconst defaultSegmentationStateManager = new SegmentationStateManager('DEFAULT');\nexport { internalConvertStackToVolumeLabelmap, internalComputeVolumeLabelmapFromStack, defaultSegmentationStateManager, };\n","import getDefaultContourConfig from '../../tools/displayTools/Contour/contourConfig';\nimport getDefaultLabelmapConfig from '../../tools/displayTools/Labelmap/labelmapConfig';\nimport * as Enums from '../../enums';\nimport { utilities } from '@cornerstonejs/core';\nclass SegmentationStyle {\n    constructor() {\n        this.config = {\n            global: {},\n            segmentations: {},\n            viewportsStyle: {},\n        };\n    }\n    setStyle(specifier, styles, merge = true) {\n        const { viewportId, segmentationId, type, segmentIndex } = specifier;\n        const currentStyles = this.getStyle(specifier);\n        const mergedStyles = merge ? { ...currentStyles, ...styles } : styles;\n        let updatedStyles;\n        if (!viewportId && !segmentationId) {\n            updatedStyles = mergedStyles;\n        }\n        else if (merge) {\n            updatedStyles = this.copyActiveToInactiveIfNotProvided(mergedStyles, type);\n        }\n        else {\n            updatedStyles = mergedStyles;\n        }\n        if (!type) {\n            throw new Error('Type is required to set a style');\n        }\n        if (viewportId) {\n            if (!this.config.viewportsStyle[viewportId]) {\n                this.config.viewportsStyle[viewportId] = {\n                    renderInactiveSegmentations: false,\n                    representations: {},\n                };\n            }\n            const representations = this.config.viewportsStyle[viewportId].representations;\n            if (segmentationId) {\n                if (!representations[segmentationId]) {\n                    representations[segmentationId] = {};\n                }\n                if (!representations[segmentationId][type]) {\n                    representations[segmentationId][type] = {};\n                }\n                const repConfig = representations[segmentationId][type];\n                if (segmentIndex !== undefined) {\n                    if (!repConfig.perSegment) {\n                        repConfig.perSegment = {};\n                    }\n                    repConfig.perSegment[segmentIndex] = updatedStyles;\n                }\n                else {\n                    repConfig.allSegments = updatedStyles;\n                }\n            }\n            else {\n                const ALL_SEGMENTATIONS_KEY = '__allSegmentations__';\n                if (!representations[ALL_SEGMENTATIONS_KEY]) {\n                    representations[ALL_SEGMENTATIONS_KEY] = {};\n                }\n                if (!representations[ALL_SEGMENTATIONS_KEY][type]) {\n                    representations[ALL_SEGMENTATIONS_KEY][type] = {};\n                }\n                representations[ALL_SEGMENTATIONS_KEY][type].allSegments =\n                    updatedStyles;\n            }\n        }\n        else if (segmentationId) {\n            if (!this.config.segmentations[segmentationId]) {\n                this.config.segmentations[segmentationId] = {};\n            }\n            if (!this.config.segmentations[segmentationId][type]) {\n                this.config.segmentations[segmentationId][type] = {};\n            }\n            const segConfig = this.config.segmentations[segmentationId][type];\n            if (segmentIndex !== undefined) {\n                if (!segConfig.perSegment) {\n                    segConfig.perSegment = {};\n                }\n                segConfig.perSegment[segmentIndex] = updatedStyles;\n            }\n            else {\n                segConfig.allSegments = updatedStyles;\n            }\n        }\n        else {\n            this.config.global[type] = updatedStyles;\n        }\n    }\n    copyActiveToInactiveIfNotProvided(styles, type) {\n        const processedStyles = { ...styles };\n        if (type === Enums.SegmentationRepresentations.Labelmap) {\n            const labelmapStyles = processedStyles;\n            labelmapStyles.renderOutlineInactive ??= labelmapStyles.renderOutline;\n            labelmapStyles.outlineWidthInactive ??= labelmapStyles.outlineWidth;\n            labelmapStyles.renderFillInactive ??= labelmapStyles.renderFill;\n            labelmapStyles.fillAlphaInactive ??= labelmapStyles.fillAlpha;\n            labelmapStyles.outlineOpacityInactive ??= labelmapStyles.outlineOpacity;\n        }\n        else if (type === Enums.SegmentationRepresentations.Contour) {\n            const contourStyles = processedStyles;\n            contourStyles.outlineWidthInactive ??= contourStyles.outlineWidth;\n            contourStyles.outlineOpacityInactive ??= contourStyles.outlineOpacity;\n            contourStyles.outlineDashInactive ??= contourStyles.outlineDash;\n            contourStyles.renderOutlineInactive ??= contourStyles.renderOutline;\n            contourStyles.renderFillInactive ??= contourStyles.renderFill;\n            contourStyles.fillAlphaInactive ??= contourStyles.fillAlpha;\n        }\n        return processedStyles;\n    }\n    getStyle(specifier) {\n        const { viewportId, segmentationId, type, segmentIndex } = specifier;\n        let combinedStyle = this.getDefaultStyle(type);\n        let renderInactiveSegmentations = false;\n        if (this.config.global[type]) {\n            combinedStyle = {\n                ...combinedStyle,\n                ...this.config.global[type],\n            };\n        }\n        if (this.config.segmentations[segmentationId]?.[type]) {\n            combinedStyle = {\n                ...combinedStyle,\n                ...this.config.segmentations[segmentationId][type].allSegments,\n            };\n            if (segmentIndex !== undefined &&\n                this.config.segmentations[segmentationId][type].perSegment?.[segmentIndex]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.segmentations[segmentationId][type].perSegment[segmentIndex],\n                };\n            }\n        }\n        if (viewportId && this.config.viewportsStyle[viewportId]) {\n            renderInactiveSegmentations =\n                this.config.viewportsStyle[viewportId].renderInactiveSegmentations;\n            const allSegmentationsKey = '__allSegmentations__';\n            if (this.config.viewportsStyle[viewportId].representations[allSegmentationsKey]?.[type]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.viewportsStyle[viewportId].representations[allSegmentationsKey][type].allSegments,\n                };\n            }\n            if (segmentationId &&\n                this.config.viewportsStyle[viewportId].representations[segmentationId]?.[type]) {\n                combinedStyle = {\n                    ...combinedStyle,\n                    ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].allSegments,\n                };\n                if (segmentIndex !== undefined &&\n                    this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment?.[segmentIndex]) {\n                    combinedStyle = {\n                        ...combinedStyle,\n                        ...this.config.viewportsStyle[viewportId].representations[segmentationId][type].perSegment[segmentIndex],\n                    };\n                }\n            }\n        }\n        return combinedStyle;\n    }\n    getRenderInactiveSegmentations(viewportId) {\n        return this.config.viewportsStyle[viewportId]?.renderInactiveSegmentations;\n    }\n    setRenderInactiveSegmentations(viewportId, renderInactiveSegmentations) {\n        if (!this.config.viewportsStyle[viewportId]) {\n            this.config.viewportsStyle[viewportId] = {\n                renderInactiveSegmentations: false,\n                representations: {},\n            };\n        }\n        this.config.viewportsStyle[viewportId].renderInactiveSegmentations =\n            renderInactiveSegmentations;\n    }\n    getDefaultStyle(type) {\n        switch (type) {\n            case Enums.SegmentationRepresentations.Labelmap:\n                return getDefaultLabelmapConfig();\n            case Enums.SegmentationRepresentations.Contour:\n                return getDefaultContourConfig();\n            case Enums.SegmentationRepresentations.Surface:\n                return {};\n            default:\n                throw new Error(`Unknown representation type: ${type}`);\n        }\n    }\n    clearSegmentationStyle(segmentationId) {\n        if (this.config.segmentations[segmentationId]) {\n            delete this.config.segmentations[segmentationId];\n        }\n    }\n    clearAllSegmentationStyles() {\n        this.config.segmentations = {};\n    }\n    clearViewportStyle(viewportId) {\n        if (this.config.viewportsStyle[viewportId]) {\n            delete this.config.viewportsStyle[viewportId];\n        }\n    }\n    clearAllViewportStyles() {\n        for (const viewportId in this.config.viewportsStyle) {\n            const viewportStyle = this.config.viewportsStyle[viewportId];\n            const renderInactiveSegmentations = viewportStyle.renderInactiveSegmentations;\n            this.config.viewportsStyle[viewportId] = {\n                renderInactiveSegmentations,\n                representations: {},\n            };\n        }\n    }\n    resetToGlobalStyle() {\n        this.clearAllSegmentationStyles();\n        this.clearAllViewportStyles();\n    }\n    hasCustomStyle(specifier) {\n        const { type } = specifier;\n        const style = this.getStyle(specifier);\n        const defaultStyle = this.getDefaultStyle(type);\n        return !utilities.deepEqual(style, defaultStyle);\n    }\n}\nconst segmentationStyle = new SegmentationStyle();\nexport { segmentationStyle };\n","import { getActiveSegmentation as _getActiveSegmentation } from './getActiveSegmentation';\nimport { setActiveSegmentation as _setActiveSegmentation } from './setActiveSegmentation';\nfunction getActiveSegmentation(viewportId) {\n    return _getActiveSegmentation(viewportId);\n}\nfunction setActiveSegmentation(viewportId, segmentationId) {\n    _setActiveSegmentation(viewportId, segmentationId);\n}\nexport { getActiveSegmentation, setActiveSegmentation, };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function setActiveSegmentation(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationStateManager.setActiveSegmentation(viewportId, segmentationId);\n}\n","import { utilities } from '@cornerstonejs/core';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { getNextColorLUTIndex } from './getNextColorLUTIndex';\nimport CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\nexport function addColorLUT(colorLUT, index) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const indexToUse = index ?? getNextColorLUTIndex();\n    let colorLUTToUse = [...colorLUT];\n    if (!utilities.isEqual(colorLUTToUse[0], [0, 0, 0, 0])) {\n        console.warn('addColorLUT: [0, 0, 0, 0] color is not provided for the background color (segmentIndex =0), automatically adding it');\n        colorLUTToUse = [[0, 0, 0, 0], ...colorLUTToUse];\n    }\n    colorLUTToUse = colorLUTToUse.map((color) => {\n        if (color.length === 3) {\n            return [color[0], color[1], color[2], 255];\n        }\n        return color;\n    });\n    if (colorLUTToUse.length < 255) {\n        const missingColorLUTs = CORNERSTONE_COLOR_LUT.slice(colorLUTToUse.length);\n        colorLUTToUse = [...colorLUTToUse, ...missingColorLUTs];\n    }\n    segmentationStateManager.addColorLUT(colorLUTToUse, indexToUse);\n    return indexToUse;\n}\n","import { SegmentationRepresentations } from '../../enums';\nimport { internalAddSegmentationRepresentation } from './internalAddSegmentationRepresentation';\nexport function addSegmentationRepresentations(viewportId, segmentationInputArray) {\n    segmentationInputArray.map((segmentationInput) => {\n        return internalAddSegmentationRepresentation(viewportId, segmentationInput);\n    });\n}\nfunction addContourRepresentationToViewport(viewportId, contourInputArray) {\n    return addSegmentationRepresentations(viewportId, contourInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Contour,\n    })));\n}\nfunction addContourRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addContourRepresentationToViewport(viewportId, inputArray);\n    }\n    return results;\n}\nfunction addLabelmapRepresentationToViewport(viewportId, labelmapInputArray) {\n    return addSegmentationRepresentations(viewportId, labelmapInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Labelmap,\n    })));\n}\nfunction addLabelmapRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addLabelmapRepresentationToViewport(viewportId, inputArray.map((input) => ({\n            ...input,\n            type: SegmentationRepresentations.Labelmap,\n        })));\n    }\n}\nfunction addSurfaceRepresentationToViewport(viewportId, surfaceInputArray) {\n    return addSegmentationRepresentations(viewportId, surfaceInputArray.map((input) => ({\n        ...input,\n        type: SegmentationRepresentations.Surface,\n    })));\n}\nfunction addSurfaceRepresentationToViewportMap(viewportInputMap) {\n    const results = {};\n    for (const [viewportId, inputArray] of Object.entries(viewportInputMap)) {\n        results[viewportId] = addSurfaceRepresentationToViewport(viewportId, inputArray);\n    }\n    return results;\n}\nexport { addContourRepresentationToViewport, addLabelmapRepresentationToViewport, addSurfaceRepresentationToViewport, addContourRepresentationToViewportMap, addLabelmapRepresentationToViewportMap, addSurfaceRepresentationToViewportMap, };\n","import { SegmentationRepresentations } from '../../../enums';\nimport { cache } from '@cornerstonejs/core';\nfunction normalizeSegmentationInput(segmentationInput) {\n    const { segmentationId, representation, config } = segmentationInput;\n    const { type, data: inputData } = representation;\n    const data = inputData ? { ...inputData } : {};\n    if (!data) {\n        throw new Error('Segmentation representation data may not be undefined');\n    }\n    if (type === SegmentationRepresentations.Contour) {\n        normalizeContourData(data);\n    }\n    const normalizedSegments = normalizeSegments(config?.segments, type, data);\n    delete config?.segments;\n    return {\n        segmentationId,\n        label: config?.label ?? null,\n        cachedStats: config?.cachedStats ?? {},\n        segments: normalizedSegments,\n        representationData: {\n            [type]: {\n                ...data,\n            },\n        },\n    };\n}\nfunction normalizeContourData(contourData) {\n    contourData.geometryIds = contourData.geometryIds ?? [];\n    contourData.annotationUIDsMap = contourData.annotationUIDsMap ?? new Map();\n}\nfunction normalizeSegments(segmentsConfig, type, data) {\n    const normalizedSegments = {};\n    if (segmentsConfig) {\n        Object.entries(segmentsConfig).forEach(([segmentIndex, segment]) => {\n            const { label, locked, cachedStats, active, ...rest } = segment;\n            const normalizedSegment = {\n                segmentIndex: Number(segmentIndex),\n                label: label ?? `Segment ${segmentIndex}`,\n                locked: locked ?? false,\n                cachedStats: cachedStats ?? {},\n                active: active ?? false,\n                ...rest,\n            };\n            normalizedSegments[segmentIndex] = normalizedSegment;\n        });\n    }\n    else if (type === SegmentationRepresentations.Contour) {\n        normalizeContourSegments(normalizedSegments, data);\n    }\n    else if (type === SegmentationRepresentations.Surface) {\n        normalizeSurfaceSegments(normalizedSegments, data);\n    }\n    else {\n        normalizedSegments[1] = createDefaultSegment();\n    }\n    return normalizedSegments;\n}\nfunction normalizeContourSegments(normalizedSegments, contourData) {\n    const { geometryIds } = contourData;\n    geometryIds?.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (geometry?.data) {\n            const { segmentIndex } = geometry.data;\n            normalizedSegments[segmentIndex] = { segmentIndex };\n        }\n    });\n}\nfunction normalizeSurfaceSegments(normalizedSegments, surfaceData) {\n    const { geometryIds } = surfaceData;\n    geometryIds?.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (geometry?.data) {\n            const { segmentIndex } = geometry.data;\n            normalizedSegments[segmentIndex] = { segmentIndex };\n        }\n    });\n}\nfunction createDefaultSegment() {\n    return {\n        segmentIndex: 1,\n        label: 'Segment 1',\n        locked: false,\n        cachedStats: {},\n        active: true,\n    };\n}\nexport default normalizeSegmentationInput;\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport normalizeSegmentationInput from './helpers/normalizeSegmentationInput';\nexport function addSegmentations(segmentationInputArray, suppressEvents) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationInputArray.forEach((segmentationInput) => {\n        const segmentation = normalizeSegmentationInput(segmentationInput);\n        segmentationStateManager.addSegmentation(segmentation);\n        if (!suppressEvents) {\n            triggerSegmentationModified(segmentation.segmentationId);\n        }\n    });\n}\nexport default addSegmentations;\n","import { addColorLUT as _addColorLUT } from '../addColorLUT';\nimport { getColorLUT as _getColorLUT } from '../getColorLUT';\nimport { getSegmentationRepresentations } from '../getSegmentationRepresentation';\nimport { triggerSegmentationRepresentationModified } from '../triggerSegmentationEvents';\nfunction addColorLUT(colorLUT, colorLUTIndex) {\n    if (!colorLUT) {\n        throw new Error('addColorLUT: colorLUT is required');\n    }\n    return _addColorLUT(colorLUT, colorLUTIndex);\n}\nfunction setColorLUT(viewportId, segmentationId, colorLUTsIndex) {\n    if (!_getColorLUT(colorLUTsIndex)) {\n        throw new Error(`setColorLUT: could not find colorLUT with index ${colorLUTsIndex}`);\n    }\n    const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n    if (!segmentationRepresentations) {\n        throw new Error(`viewport specific state for viewport ${viewportId} does not exist`);\n    }\n    segmentationRepresentations.forEach((segmentationRepresentation) => {\n        segmentationRepresentation.colorLUTIndex = colorLUTsIndex;\n    });\n    triggerSegmentationRepresentationModified(viewportId, segmentationId);\n}\nfunction getSegmentIndexColor(viewportId, segmentationId, segmentIndex) {\n    const representations = getSegmentationRepresentations(viewportId, {\n        segmentationId,\n    });\n    if (!representations || representations.length === 0) {\n        return null;\n    }\n    const representation = representations[0];\n    const { colorLUTIndex } = representation;\n    const colorLUT = _getColorLUT(colorLUTIndex);\n    let colorValue = colorLUT[segmentIndex];\n    if (!colorValue) {\n        if (typeof segmentIndex !== 'number') {\n            console.warn(`Can't create colour for LUT index ${segmentIndex}`);\n            return null;\n        }\n        colorValue = colorLUT[segmentIndex] = [0, 0, 0, 0];\n    }\n    return colorValue;\n}\nfunction setSegmentIndexColor(viewportId, segmentationId, segmentIndex, color) {\n    const colorReference = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n    for (let i = 0; i < color.length; i++) {\n        colorReference[i] = color[i];\n    }\n    triggerSegmentationRepresentationModified(viewportId, segmentationId);\n}\nexport { getSegmentIndexColor, addColorLUT, setColorLUT, setSegmentIndexColor };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nimport { setSegmentationDirty } from '../../../utilities/segmentation/utilities';\nexport function triggerSegmentationDataModified(segmentationId, modifiedSlicesToUse, segmentIndex) {\n    const eventDetail = {\n        segmentationId,\n        modifiedSlicesToUse,\n        segmentIndex,\n    };\n    setSegmentationDirty(segmentationId);\n    triggerEvent(eventTarget, Events.SEGMENTATION_DATA_MODIFIED, eventDetail);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getActiveSegmentation(viewportId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getActiveSegmentation(viewportId);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getNextColorLUTIndex() {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getNextColorLUTIndex();\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentationRepresentations(viewportId, specifier = {}) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);\n}\nexport function getSegmentationRepresentation(viewportId, specifier) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    if (!specifier.segmentationId || !specifier.type) {\n        throw new Error('getSegmentationRepresentation: No segmentationId or type provided, you need to provide at least one of them');\n    }\n    const representations = segmentationStateManager.getSegmentationRepresentations(viewportId, specifier);\n    return representations?.[0];\n}\nexport function getSegmentationRepresentationsBySegmentationId(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentationsBySegmentationId(segmentationId);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentationRepresentationVisibility(viewportId, specifier) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentationRepresentationVisibility(viewportId, specifier);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentations() {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const state = segmentationStateManager.getState();\n    return state.segmentations;\n}\n","import { getSegmentation } from './getSegmentation';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getViewportSegmentations(viewportId, type) {\n    const viewportRepresentations = getViewportSegmentationRepresentations(viewportId);\n    const segmentations = viewportRepresentations.map((representation) => {\n        if (type && representation.type === type) {\n            return getSegmentation(representation.segmentationId);\n        }\n        return getSegmentation(representation.segmentationId);\n    });\n    const filteredSegmentations = segmentations.filter((segmentation) => segmentation !== undefined);\n    return filteredSegmentations;\n}\nexport function getViewportSegmentationRepresentations(viewportId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const state = segmentationStateManager.getState();\n    const viewportRepresentations = state.viewportSegRepresentations[viewportId];\n    return viewportRepresentations;\n}\n","import { cache } from '@cornerstonejs/core';\nimport { getSegmentation } from '../getSegmentation';\nimport { updateStackSegmentationState } from '../helpers/updateStackSegmentationState';\nexport async function computeStackLabelmapFromVolume({ volumeId, }) {\n    const segmentationVolume = cache.getVolume(volumeId);\n    return { imageIds: segmentationVolume.imageIds };\n}\nexport function convertVolumeToStackLabelmap({ segmentationId, options, }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    const { volumeId } = segmentation.representationData\n        .Labelmap;\n    const segmentationVolume = cache.getVolume(volumeId);\n    return updateStackSegmentationState({\n        segmentationId,\n        viewportId: options.viewportId,\n        imageIds: segmentationVolume.imageIds,\n        options,\n    });\n}\n","import { internalComputeVolumeLabelmapFromStack } from '../SegmentationStateManager';\nexport async function computeVolumeLabelmapFromStack(args) {\n    return internalComputeVolumeLabelmapFromStack(args);\n}\n","import { removeContourRepresentation, removeLabelmapRepresentation, removeSegmentationRepresentation, removeSurfaceRepresentation, removeSegmentationRepresentations, removeAllSegmentationRepresentations, } from './removeSegmentationRepresentations';\nimport { addContourRepresentationToViewport, addContourRepresentationToViewportMap, addSurfaceRepresentationToViewport, addSurfaceRepresentationToViewportMap, addLabelmapRepresentationToViewport, addLabelmapRepresentationToViewportMap, addSegmentationRepresentations, } from './addSegmentationRepresentationsToViewport';\nimport { addSegmentations } from './addSegmentations';\nimport addRepresentationData from './internalAddRepresentationData';\nimport { updateSegmentations } from './updateSegmentations';\nimport * as activeSegmentation from './activeSegmentation';\nimport * as segmentLocking from './segmentLocking';\nimport * as state from './segmentationState';\nimport * as config from './config';\nimport * as segmentIndex from './segmentIndex';\nimport * as triggerSegmentationEvents from './triggerSegmentationEvents';\nimport * as utilities from './utilities';\nimport { convertStackToVolumeLabelmap } from './helpers/convertStackToVolumeLabelmap';\nimport { computeVolumeLabelmapFromStack } from './helpers/computeVolumeLabelmapFromStack';\nimport { clearSegmentValue } from './helpers/clearSegmentValue';\nimport { convertVolumeToStackLabelmap } from './helpers/computeStackLabelmapFromVolume';\nimport { removeSegment } from './removeSegment';\nimport { getLabelmapImageIds } from './getLabelmapImageIds';\nimport * as strategies from './../../tools/segmentation/strategies';\nimport { removeAllSegmentations, removeSegmentation, } from './removeSegmentation';\nimport { segmentationStyle } from './SegmentationStyle';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { getCurrentLabelmapImageIdsForViewport, getLabelmapImageIdsForImageId, } from './getCurrentLabelmapImageIdForViewport';\nimport { getActiveSegmentation } from './getActiveSegmentation';\nimport { addSegmentationListener, addDefaultSegmentationListener, removeSegmentationListener, removeAllSegmentationListeners, } from './segmentationEventManager';\nconst helpers = {\n    clearSegmentValue,\n    convertStackToVolumeLabelmap,\n    computeVolumeLabelmapFromStack,\n    convertVolumeToStackLabelmap,\n};\nexport { removeSegmentationRepresentation, removeContourRepresentation, removeLabelmapRepresentation, removeSurfaceRepresentation, removeAllSegmentations, removeSegmentation, removeSegmentationRepresentations, addLabelmapRepresentationToViewport, addLabelmapRepresentationToViewportMap, addSegmentationRepresentations, removeAllSegmentationRepresentations, addContourRepresentationToViewport, addContourRepresentationToViewportMap, addSurfaceRepresentationToViewport, addSurfaceRepresentationToViewportMap, addSegmentations, updateSegmentations, addSegmentationListener, addDefaultSegmentationListener, removeSegmentationListener, removeAllSegmentationListeners, state, activeSegmentation, segmentLocking, config, segmentIndex, triggerSegmentationEvents, utilities, helpers, removeSegment, getLabelmapImageIds, addRepresentationData, strategies, segmentationStyle, defaultSegmentationStateManager, getCurrentLabelmapImageIdsForViewport, getLabelmapImageIdsForImageId, getActiveSegmentation, };\n","import { getSegmentation } from './getSegmentation';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nfunction internalAddRepresentationData({ segmentationId, type, data, }) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`Segmentation ${segmentationId} not found`);\n    }\n    if (segmentation.representationData[type]) {\n        console.warn(`Representation data of type ${type} already exists for segmentation ${segmentationId}, overwriting it.`);\n    }\n    switch (type) {\n        case SegmentationRepresentations.Labelmap:\n            if (data) {\n                segmentation.representationData[type] =\n                    data;\n            }\n            break;\n        case SegmentationRepresentations.Contour:\n            if (data) {\n                segmentation.representationData[type] = data;\n            }\n            break;\n        case SegmentationRepresentations.Surface:\n            if (data) {\n                segmentation.representationData[type] = data;\n            }\n            break;\n        default:\n            throw new Error(`Invalid representation type ${type}`);\n    }\n}\nexport default internalAddRepresentationData;\n","import { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport CORNERSTONE_COLOR_LUT from '../../constants/COLOR_LUT';\nimport { triggerAnnotationRenderForViewportIds } from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationModified, triggerSegmentationDataModified, } from './triggerSegmentationEvents';\nimport { addColorLUT } from './addColorLUT';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { addDefaultSegmentationListener } from './segmentationEventManager';\nimport { getActiveSegmentIndex, setActiveSegmentIndex } from './segmentIndex';\nfunction internalAddSegmentationRepresentation(viewportId, representationInput) {\n    const { segmentationId, config } = representationInput;\n    const renderingConfig = {\n        colorLUTIndex: getColorLUTIndex(config),\n        ...config,\n    };\n    defaultSegmentationStateManager.addSegmentationRepresentation(viewportId, segmentationId, representationInput.type, renderingConfig);\n    const { viewport } = getEnabledElementByViewportId(viewportId) || {};\n    if (viewport) {\n        addDefaultSegmentationListener(viewport, segmentationId, representationInput.type);\n    }\n    if (!getActiveSegmentIndex(segmentationId)) {\n        let firstSegmentIndex = 1;\n        const segmentation = defaultSegmentationStateManager.getSegmentation(segmentationId);\n        if (segmentation) {\n            const segmentKeys = Object.keys(segmentation.segments);\n            if (segmentKeys.length > 0) {\n                firstSegmentIndex = segmentKeys.map((k) => Number(k)).sort()[0];\n            }\n            setActiveSegmentIndex(segmentationId, firstSegmentIndex);\n        }\n    }\n    if (representationInput.type === SegmentationRepresentations.Contour) {\n        triggerAnnotationRenderForViewportIds([viewportId]);\n    }\n    if (representationInput.type === SegmentationRepresentations.Surface) {\n        triggerSegmentationDataModified(segmentationId);\n    }\n    triggerSegmentationModified(segmentationId);\n}\nfunction getColorLUTIndex(config) {\n    const { colorLUTOrIndex } = config || {};\n    if (colorLUTOrIndex === undefined) {\n        const index = addColorLUT(JSON.parse(JSON.stringify(CORNERSTONE_COLOR_LUT)));\n        return index;\n    }\n    if (typeof colorLUTOrIndex === 'number') {\n        return colorLUTOrIndex;\n    }\n    if (Array.isArray(colorLUTOrIndex) &&\n        colorLUTOrIndex.every((item) => Array.isArray(item) && item.length === 4)) {\n        const index = addColorLUT(colorLUTOrIndex);\n        return index;\n    }\n    const index = addColorLUT(JSON.parse(JSON.stringify(CORNERSTONE_COLOR_LUT)));\n    return index;\n}\nexport { internalAddSegmentationRepresentation };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { triggerSegmentationRemoved } from './triggerSegmentationEvents';\nimport { removeSegmentationRepresentations } from './removeSegmentationRepresentations';\nexport function removeSegmentation(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const viewportsWithSegmentation = segmentationStateManager\n        .getAllViewportSegmentationRepresentations()\n        .filter(({ representations }) => representations.some((rep) => rep.segmentationId === segmentationId))\n        .map(({ viewportId }) => viewportId);\n    viewportsWithSegmentation.forEach((viewportId) => {\n        removeSegmentationRepresentations(viewportId, { segmentationId });\n    });\n    segmentationStateManager.removeSegmentation(segmentationId);\n    triggerSegmentationRemoved(segmentationId);\n}\nexport function removeAllSegmentations() {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    const segmentations = segmentationStateManager.getState().segmentations;\n    const segmentationIds = segmentations.map((segmentation) => segmentation.segmentationId);\n    segmentationIds.forEach((segmentationId) => {\n        removeSegmentation(segmentationId);\n    });\n    segmentationStateManager.resetState();\n}\n","import SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport labelmapDisplay from '../../tools/displayTools/Labelmap/labelmapDisplay';\nimport contourDisplay from '../../tools/displayTools/Contour/contourDisplay';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nimport { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nimport { surfaceDisplay } from '../../tools/displayTools/Surface';\nimport { removeSegmentationListener } from './segmentationEventManager';\nfunction removeSegmentationRepresentation(viewportId, specifier, immediate) {\n    return _removeSegmentationRepresentations(viewportId, specifier, immediate);\n}\nfunction removeSegmentationRepresentations(viewportId, specifier, immediate) {\n    return _removeSegmentationRepresentations(viewportId, specifier, immediate);\n}\nfunction _removeSegmentationRepresentations(viewportId, specifier, immediate) {\n    const { segmentationId, type } = specifier;\n    _removeRepresentationObject(viewportId, segmentationId, type, immediate);\n    return defaultSegmentationStateManager.removeSegmentationRepresentations(viewportId, {\n        segmentationId,\n        type,\n    });\n}\nfunction removeAllSegmentationRepresentations() {\n    const state = defaultSegmentationStateManager.getAllViewportSegmentationRepresentations();\n    state.forEach(({ viewportId, representations }) => {\n        representations.forEach(({ segmentationId, type }) => {\n            removeSegmentationRepresentation(viewportId, {\n                segmentationId,\n                type,\n            });\n        });\n    });\n    defaultSegmentationStateManager.resetState();\n}\nfunction removeLabelmapRepresentation(viewportId, segmentationId, immediate) {\n    removeSegmentationRepresentation(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Labelmap,\n    }, immediate);\n}\nfunction removeContourRepresentation(viewportId, segmentationId, immediate) {\n    removeSegmentationRepresentation(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n    }, immediate);\n}\nfunction removeSurfaceRepresentation(viewportId, segmentationId, immediate) {\n    removeSegmentationRepresentation(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Surface,\n    }, immediate);\n}\nfunction _removeRepresentationObject(viewportId, segmentationId, type, immediate) {\n    const representations = getSegmentationRepresentations(viewportId, {\n        segmentationId,\n        type,\n    });\n    representations.forEach((representation) => {\n        if (representation.type === SegmentationRepresentations.Labelmap) {\n            labelmapDisplay.removeRepresentation(viewportId, representation.segmentationId, immediate);\n        }\n        else if (representation.type === SegmentationRepresentations.Contour) {\n            contourDisplay.removeRepresentation(viewportId, representation.segmentationId, immediate);\n        }\n        else if (representation.type === SegmentationRepresentations.Surface) {\n            surfaceDisplay.removeRepresentation(viewportId, representation.segmentationId, immediate);\n        }\n        removeSegmentationListener(representation.segmentationId, representation.type);\n    });\n    const { viewport } = getEnabledElementByViewportId(viewportId) || {};\n    if (viewport) {\n        viewport.render();\n    }\n}\nexport { removeSegmentationRepresentation, removeSegmentationRepresentations, removeAllSegmentationRepresentations, removeLabelmapRepresentation, removeContourRepresentation, removeSurfaceRepresentation, };\n","import { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport { invalidateBrushCursor } from '../../utilities/segmentation/invalidateBrushCursor';\nimport { getSegmentation } from './getSegmentation';\nimport { getViewportIdsWithSegmentation } from './getViewportIdsWithSegmentation';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport { getActiveSegmentIndex } from './getActiveSegmentIndex';\nimport { getSegmentationRepresentations } from './getSegmentationRepresentation';\nfunction setActiveSegmentIndex(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (typeof segmentIndex === 'string') {\n        console.warn('segmentIndex is a string, converting to number');\n        segmentIndex = Number(segmentIndex);\n    }\n    Object.values(segmentation.segments).forEach((segment) => {\n        segment.active = false;\n    });\n    if (!segmentation.segments[segmentIndex]) {\n        segmentation.segments[segmentIndex] = {\n            segmentIndex,\n            label: '',\n            locked: false,\n            cachedStats: {},\n            active: false,\n        };\n    }\n    if (segmentation.segments[segmentIndex].active !== true) {\n        segmentation.segments[segmentIndex].active = true;\n        triggerSegmentationModified(segmentationId);\n    }\n    const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n    viewportIds.forEach((viewportId) => {\n        const representations = getSegmentationRepresentations(viewportId, {\n            segmentationId,\n        });\n        representations.forEach((representation) => {\n            if (!representation.segments[segmentIndex]) {\n                representation.segments[segmentIndex] = {\n                    visible: true,\n                };\n            }\n        });\n    });\n    viewportIds.forEach((viewportId) => {\n        const toolGroup = getToolGroupForViewport(viewportId);\n        invalidateBrushCursor(toolGroup.id);\n    });\n}\nexport { setActiveSegmentIndex, getActiveSegmentIndex };\n","import { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { setAnnotationLocked } from '../annotation/annotationLocking';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport { getAnnotationsUIDMapFromSegmentation } from './utilities';\nfunction _setContourSegmentationSegmentAnnotationsLocked(segmentation, segmentIndex, locked) {\n    const annotationUIDsMap = getAnnotationsUIDMapFromSegmentation(segmentation.segmentationId);\n    if (!annotationUIDsMap) {\n        return;\n    }\n    const annotationUIDs = annotationUIDsMap.get(segmentIndex);\n    if (!annotationUIDs) {\n        return;\n    }\n    annotationUIDs.forEach((annotationUID) => {\n        setAnnotationLocked(annotationUID, locked);\n    });\n}\nfunction isSegmentIndexLocked(segmentationId, segmentIndex) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    return segments[segmentIndex].locked;\n}\nfunction setSegmentIndexLocked(segmentationId, segmentIndex, locked = true) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    segments[segmentIndex].locked = locked;\n    if (segmentation?.representationData?.Contour) {\n        _setContourSegmentationSegmentAnnotationsLocked(segmentation, segmentIndex, locked);\n    }\n    triggerSegmentationModified(segmentationId);\n}\nfunction getLockedSegmentIndices(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        throw new Error(`No segmentation state found for ${segmentationId}`);\n    }\n    const { segments } = segmentation;\n    const lockedSegmentIndices = Object.keys(segments).filter((segmentIndex) => segments[segmentIndex].locked);\n    return lockedSegmentIndices.map((segmentIndex) => parseInt(segmentIndex));\n}\nexport { isSegmentIndexLocked, setSegmentIndexLocked, getLockedSegmentIndices };\n","import { eventTarget } from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../enums';\nimport { triggerSegmentationModified } from './triggerSegmentationEvents';\nimport debounce from '../../utilities/debounce';\nimport surfaceDisplay from '../../tools/displayTools/Surface/surfaceDisplay';\nimport contourDisplay from '../../tools/displayTools/Contour/contourDisplay';\nimport labelmapDisplay from '../../tools/displayTools/Labelmap/labelmapDisplay';\nimport { getSegmentation } from './getSegmentation';\nconst renderers = {\n    [SegmentationRepresentations.Labelmap]: labelmapDisplay,\n    [SegmentationRepresentations.Contour]: contourDisplay,\n    [SegmentationRepresentations.Surface]: surfaceDisplay,\n};\nconst segmentationListeners = new Map();\nexport function addDefaultSegmentationListener(viewport, segmentationId, representationType) {\n    const updateFunction = renderers[representationType].getUpdateFunction(viewport);\n    if (updateFunction) {\n        addSegmentationListener(segmentationId, representationType, updateFunction);\n    }\n}\nfunction addSegmentationListener(segmentationId, representationType, updateFunction) {\n    if (!segmentationListeners.has(segmentationId)) {\n        segmentationListeners.set(segmentationId, new Map());\n    }\n    const listenerMap = segmentationListeners.get(segmentationId);\n    if (listenerMap.has(representationType)) {\n        removeSegmentationListener(segmentationId, representationType);\n    }\n    const listener = createDebouncedSegmentationListener(segmentationId, representationType, updateFunction);\n    eventTarget.addEventListener(Events.SEGMENTATION_DATA_MODIFIED, listener);\n    listenerMap.set(representationType, listener);\n}\nfunction removeSegmentationListener(segmentationId, representationType) {\n    const listenerMap = segmentationListeners.get(segmentationId);\n    if (!listenerMap) {\n        return;\n    }\n    const listener = listenerMap.get(representationType);\n    if (!listener) {\n        return;\n    }\n    eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, listener);\n    listenerMap.delete(representationType);\n}\nfunction removeAllSegmentationListeners(segmentationId) {\n    const listenerMap = segmentationListeners.get(segmentationId);\n    if (!listenerMap) {\n        return;\n    }\n    for (const listener of listenerMap.values()) {\n        eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, listener);\n    }\n    segmentationListeners.delete(segmentationId);\n}\nfunction createDebouncedSegmentationListener(segmentationId, representationType, updateFunction) {\n    const debouncedHandler = debounce((event) => {\n        const eventSegmentationId = event.detail?.segmentationId;\n        const segmentation = getSegmentation(eventSegmentationId);\n        if (eventSegmentationId === segmentationId &&\n            !!segmentation?.representationData?.[representationType]) {\n            updateFunction(segmentationId);\n            triggerSegmentationModified(segmentationId);\n        }\n    }, 300);\n    return ((event) => {\n        debouncedHandler(event);\n    });\n}\nexport { addSegmentationListener, removeSegmentationListener, removeAllSegmentationListeners, };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function removeColorLUT(colorLUTIndex) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    segmentationStateManager.removeColorLUT(colorLUTIndex);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getStackSegmentationImageIdsForViewport(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getStackSegmentationImageIdsForViewport(viewportId, segmentationId);\n}\n","import { getSegmentation } from './getSegmentation';\nimport { getSegmentations } from './getSegmentations';\nimport { addSegmentations } from './addSegmentations';\nimport { removeAllSegmentations, removeSegmentation, } from './removeSegmentation';\nimport { removeLabelmapRepresentation, removeContourRepresentation, removeSurfaceRepresentation, removeSegmentationRepresentation, removeAllSegmentationRepresentations, } from './removeSegmentationRepresentations';\nimport { addColorLUT } from './addColorLUT';\nimport { getColorLUT } from './getColorLUT';\nimport { getNextColorLUTIndex } from './getNextColorLUTIndex';\nimport { removeColorLUT } from './removeColorLUT';\nimport { getViewportSegmentations, getViewportSegmentationRepresentations, } from './getViewportSegmentations';\nimport { getViewportIdsWithSegmentation } from './getViewportIdsWithSegmentation';\nimport { getCurrentLabelmapImageIdForViewport, getCurrentLabelmapImageIdsForViewport, } from './getCurrentLabelmapImageIdForViewport';\nimport { updateLabelmapSegmentationImageReferences } from './updateLabelmapSegmentationImageReferences';\nimport { getStackSegmentationImageIdsForViewport } from './getStackSegmentationImageIdsForViewport';\nimport { getSegmentationRepresentation, getSegmentationRepresentations, getSegmentationRepresentationsBySegmentationId, } from './getSegmentationRepresentation';\nimport { defaultSegmentationStateManager } from './SegmentationStateManager';\nfunction destroy() {\n    defaultSegmentationStateManager.resetState();\n}\nexport { getColorLUT, getCurrentLabelmapImageIdForViewport, getCurrentLabelmapImageIdsForViewport, getNextColorLUTIndex, getSegmentation, getSegmentations, getStackSegmentationImageIdsForViewport, getViewportIdsWithSegmentation, getSegmentationRepresentation, getSegmentationRepresentations, getViewportSegmentationRepresentations, removeColorLUT, getViewportSegmentations, removeSegmentation, removeLabelmapRepresentation, removeContourRepresentation, removeSurfaceRepresentation, removeSegmentationRepresentation, removeAllSegmentationRepresentations, removeAllSegmentations, addColorLUT, addSegmentations, updateLabelmapSegmentationImageReferences, getSegmentationRepresentationsBySegmentationId, destroy, };\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function updateLabelmapSegmentationImageReferences(viewportId, segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.updateLabelmapSegmentationImageReferences(viewportId, segmentationId);\n}\n","import { getSegmentation } from '../getSegmentation';\nexport function getAnnotationsUIDMapFromSegmentation(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    if (!segmentation) {\n        return;\n    }\n    const contourRepresentationData = segmentation.representationData\n        ?.Contour;\n    if (!contourRepresentationData) {\n        return;\n    }\n    const { annotationUIDsMap } = contourRepresentationData;\n    if (!annotationUIDsMap) {\n        return;\n    }\n    return annotationUIDsMap;\n}\n","import { getRenderingEngines } from '@cornerstonejs/core';\nimport { state } from '../state';\nfunction getToolGroupForViewport(viewportId, renderingEngineId) {\n    if (!renderingEngineId) {\n        renderingEngineId = getRenderingEngines().find((re) => re.getViewports().find((vp) => vp.id === viewportId))?.id;\n    }\n    const toolGroupFilteredByIds = state.toolGroups.filter((tg) => tg.viewportsInfo.some((vp) => vp.renderingEngineId === renderingEngineId &&\n        (!vp.viewportId || vp.viewportId === viewportId)));\n    if (!toolGroupFilteredByIds.length) {\n        return;\n    }\n    if (toolGroupFilteredByIds.length > 1) {\n        throw new Error(`Multiple tool groups found for renderingEngineId: ${renderingEngineId} and viewportId: ${viewportId}. You should only\n      have one tool group per viewport in a renderingEngine.`);\n    }\n    return toolGroupFilteredByIds[0];\n}\nexport default getToolGroupForViewport;\n","let svgNodeCache = {};\nexport function resetSvgNodeCache() {\n    svgNodeCache = {};\n}\nexport default svgNodeCache;\n","import { vec2, vec3 } from 'gl-matrix';\nimport { getEnabledElement, utilities as csUtils, getEnabledElementByViewportId, utilities, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport { AnnotationTool } from '../base';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawLine as drawLineSvg, drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as lineSegment from '../../utilities/math/line';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass BidirectionalTool extends AnnotationTool {\n    static { this.toolName = 'Bidirectional'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            preventHandleOutsideImage: false,\n            getTextLines: defaultGetTextLines,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            let canvasPoint1 = viewport.worldToCanvas(points[0]);\n            let canvasPoint2 = viewport.worldToCanvas(points[1]);\n            let line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            let distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            canvasPoint1 = viewport.worldToCanvas(points[2]);\n            canvasPoint2 = viewport.worldToCanvas(points[3]);\n            line = {\n                start: {\n                    x: canvasPoint1[0],\n                    y: canvasPoint1[1],\n                },\n                end: {\n                    x: canvasPoint2[0],\n                    y: canvasPoint2[1],\n                },\n            };\n            distanceToPoint = lineSegment.distanceToPoint([line.start.x, line.start.y], [line.end.x, line.end.y], [canvasCoords[0], canvasCoords[1]]);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            hideElementCursor(element);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const data = annotation.data;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            hideElementCursor(element);\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            this.doneEditMemo();\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            const { renderingEngine } = getEnabledElement(element);\n            if (this.editData.handleIndex !== undefined) {\n                const { points } = data.handles;\n                const firstLineSegmentLength = vec3.distance(points[0], points[1]);\n                const secondLineSegmentLength = vec3.distance(points[2], points[3]);\n                if (secondLineSegmentLength > firstLineSegmentLength) {\n                    const longAxis = [[...points[2]], [...points[3]]];\n                    const shortAxisPoint0 = [...points[0]];\n                    const shortAxisPoint1 = [...points[1]];\n                    const longAxisVector = vec2.create();\n                    vec2.set(longAxisVector, longAxis[1][0] - longAxis[0][0], longAxis[1][1] - longAxis[1][0]);\n                    const counterClockWisePerpendicularToLongAxis = vec2.create();\n                    vec2.set(counterClockWisePerpendicularToLongAxis, -longAxisVector[1], longAxisVector[0]);\n                    const currentShortAxisVector = vec2.create();\n                    vec2.set(currentShortAxisVector, shortAxisPoint1[0] - shortAxisPoint0[0], shortAxisPoint1[1] - shortAxisPoint0[0]);\n                    let shortAxis;\n                    if (vec2.dot(currentShortAxisVector, counterClockWisePerpendicularToLongAxis) > 0) {\n                        shortAxis = [shortAxisPoint0, shortAxisPoint1];\n                    }\n                    else {\n                        shortAxis = [shortAxisPoint1, shortAxisPoint0];\n                    }\n                    data.handles.points = [\n                        longAxis[0],\n                        longAxis[1],\n                        shortAxis[0],\n                        shortAxis[1],\n                    ];\n                }\n            }\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n            this.editData = null;\n            this.isDrawing = false;\n        };\n        this._dragDrawCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { worldToCanvas } = viewport;\n            const { annotation, viewportIdsToRender, handleIndex, newAnnotation } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            data.handles.points[handleIndex] = [...worldPos];\n            const canvasCoordPoints = data.handles.points.map(worldToCanvas);\n            const canvasCoords = {\n                longLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[0][0],\n                        y: canvasCoordPoints[0][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[1][0],\n                        y: canvasCoordPoints[1][1],\n                    },\n                },\n                shortLineSegment: {\n                    start: {\n                        x: canvasCoordPoints[2][0],\n                        y: canvasCoordPoints[2][1],\n                    },\n                    end: {\n                        x: canvasCoordPoints[3][0],\n                        y: canvasCoordPoints[3][1],\n                    },\n                },\n            };\n            const dist = vec2.distance(canvasCoordPoints[0], canvasCoordPoints[1]);\n            const shortAxisDistFromCenter = dist / 3;\n            const dx = canvasCoords.longLineSegment.start.x - canvasCoords.longLineSegment.end.x;\n            const dy = canvasCoords.longLineSegment.start.y - canvasCoords.longLineSegment.end.y;\n            const length = Math.sqrt(dx * dx + dy * dy);\n            const vectorX = dx / length;\n            const vectorY = dy / length;\n            const xMid = (canvasCoords.longLineSegment.start.x +\n                canvasCoords.longLineSegment.end.x) /\n                2;\n            const yMid = (canvasCoords.longLineSegment.start.y +\n                canvasCoords.longLineSegment.end.y) /\n                2;\n            const startX = xMid + shortAxisDistFromCenter * vectorY;\n            const startY = yMid - shortAxisDistFromCenter * vectorX;\n            const endX = xMid - shortAxisDistFromCenter * vectorY;\n            const endY = yMid + shortAxisDistFromCenter * vectorX;\n            data.handles.points[2] = viewport.canvasToWorld([startX, startY]);\n            data.handles.points[3] = viewport.canvasToWorld([endX, endY]);\n            annotation.invalidated = true;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            this.editData.hasMoved = true;\n        };\n        this._dragModifyCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const points = data.handles.points;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                this._dragModifyHandle(evt);\n                annotation.invalidated = true;\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this._dragModifyHandle = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { annotation, handleIndex: movingHandleIndex } = this.editData;\n            const { data } = annotation;\n            const worldPos = currentPoints.world;\n            const canvasCoordHandlesCurrent = [\n                viewport.worldToCanvas(data.handles.points[0]),\n                viewport.worldToCanvas(data.handles.points[1]),\n                viewport.worldToCanvas(data.handles.points[2]),\n                viewport.worldToCanvas(data.handles.points[3]),\n            ];\n            const firstLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[0][0],\n                    y: canvasCoordHandlesCurrent[0][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[1][0],\n                    y: canvasCoordHandlesCurrent[1][1],\n                },\n            };\n            const secondLineSegment = {\n                start: {\n                    x: canvasCoordHandlesCurrent[2][0],\n                    y: canvasCoordHandlesCurrent[2][1],\n                },\n                end: {\n                    x: canvasCoordHandlesCurrent[3][0],\n                    y: canvasCoordHandlesCurrent[3][1],\n                },\n            };\n            const proposedPoint = [...worldPos];\n            const proposedCanvasCoord = viewport.worldToCanvas(proposedPoint);\n            if (movingHandleIndex === 0 || movingHandleIndex === 1) {\n                const fixedHandleIndex = movingHandleIndex === 0 ? 1 : 0;\n                const fixedHandleCanvasCoord = canvasCoordHandlesCurrent[fixedHandleIndex];\n                const fixedHandleToProposedCoordVec = vec2.set(vec2.create(), proposedCanvasCoord[0] - fixedHandleCanvasCoord[0], proposedCanvasCoord[1] - fixedHandleCanvasCoord[1]);\n                const fixedHandleToOldCoordVec = vec2.set(vec2.create(), canvasCoordHandlesCurrent[movingHandleIndex][0] -\n                    fixedHandleCanvasCoord[0], canvasCoordHandlesCurrent[movingHandleIndex][1] -\n                    fixedHandleCanvasCoord[1]);\n                vec2.normalize(fixedHandleToProposedCoordVec, fixedHandleToProposedCoordVec);\n                vec2.normalize(fixedHandleToOldCoordVec, fixedHandleToOldCoordVec);\n                const proposedFirstLineSegment = {\n                    start: {\n                        x: fixedHandleCanvasCoord[0],\n                        y: fixedHandleCanvasCoord[1],\n                    },\n                    end: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                };\n                if (this._movingLongAxisWouldPutItThroughShortAxis(proposedFirstLineSegment, secondLineSegment)) {\n                    return;\n                }\n                const centerOfRotation = fixedHandleCanvasCoord;\n                const angle = this._getSignedAngle(fixedHandleToOldCoordVec, fixedHandleToProposedCoordVec);\n                let firstPointX = canvasCoordHandlesCurrent[2][0];\n                let firstPointY = canvasCoordHandlesCurrent[2][1];\n                let secondPointX = canvasCoordHandlesCurrent[3][0];\n                let secondPointY = canvasCoordHandlesCurrent[3][1];\n                firstPointX -= centerOfRotation[0];\n                firstPointY -= centerOfRotation[1];\n                secondPointX -= centerOfRotation[0];\n                secondPointY -= centerOfRotation[1];\n                const rotatedFirstPoint = firstPointX * Math.cos(angle) - firstPointY * Math.sin(angle);\n                const rotatedFirstPointY = firstPointX * Math.sin(angle) + firstPointY * Math.cos(angle);\n                const rotatedSecondPoint = secondPointX * Math.cos(angle) - secondPointY * Math.sin(angle);\n                const rotatedSecondPointY = secondPointX * Math.sin(angle) + secondPointY * Math.cos(angle);\n                firstPointX = rotatedFirstPoint + centerOfRotation[0];\n                firstPointY = rotatedFirstPointY + centerOfRotation[1];\n                secondPointX = rotatedSecondPoint + centerOfRotation[0];\n                secondPointY = rotatedSecondPointY + centerOfRotation[1];\n                const newFirstPoint = viewport.canvasToWorld([firstPointX, firstPointY]);\n                const newSecondPoint = viewport.canvasToWorld([\n                    secondPointX,\n                    secondPointY,\n                ]);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n                data.handles.points[2] = newFirstPoint;\n                data.handles.points[3] = newSecondPoint;\n            }\n            else {\n                const translateHandleIndex = movingHandleIndex === 2 ? 3 : 2;\n                const canvasCoordsCurrent = {\n                    longLineSegment: {\n                        start: firstLineSegment.start,\n                        end: firstLineSegment.end,\n                    },\n                    shortLineSegment: {\n                        start: secondLineSegment.start,\n                        end: secondLineSegment.end,\n                    },\n                };\n                const longLineSegmentVec = vec2.subtract(vec2.create(), [\n                    canvasCoordsCurrent.longLineSegment.end.x,\n                    canvasCoordsCurrent.longLineSegment.end.y,\n                ], [\n                    canvasCoordsCurrent.longLineSegment.start.x,\n                    canvasCoordsCurrent.longLineSegment.start.y,\n                ]);\n                const longLineSegmentVecNormalized = vec2.normalize(vec2.create(), longLineSegmentVec);\n                const proposedToCurrentVec = vec2.subtract(vec2.create(), [proposedCanvasCoord[0], proposedCanvasCoord[1]], [\n                    canvasCoordHandlesCurrent[movingHandleIndex][0],\n                    canvasCoordHandlesCurrent[movingHandleIndex][1],\n                ]);\n                const movementLength = vec2.length(proposedToCurrentVec);\n                const angle = this._getSignedAngle(longLineSegmentVecNormalized, proposedToCurrentVec);\n                const movementAlongLineSegmentLength = Math.cos(angle) * movementLength;\n                const newTranslatedPoint = vec2.scaleAndAdd(vec2.create(), [\n                    canvasCoordHandlesCurrent[translateHandleIndex][0],\n                    canvasCoordHandlesCurrent[translateHandleIndex][1],\n                ], longLineSegmentVecNormalized, movementAlongLineSegmentLength);\n                if (this._movingLongAxisWouldPutItThroughShortAxis({\n                    start: {\n                        x: proposedCanvasCoord[0],\n                        y: proposedCanvasCoord[1],\n                    },\n                    end: {\n                        x: newTranslatedPoint[0],\n                        y: newTranslatedPoint[1],\n                    },\n                }, {\n                    start: {\n                        x: canvasCoordsCurrent.longLineSegment.start.x,\n                        y: canvasCoordsCurrent.longLineSegment.start.y,\n                    },\n                    end: {\n                        x: canvasCoordsCurrent.longLineSegment.end.x,\n                        y: canvasCoordsCurrent.longLineSegment.end.y,\n                    },\n                })) {\n                    return;\n                }\n                const intersectionPoint = lineSegment.intersectLine([proposedCanvasCoord[0], proposedCanvasCoord[1]], [newTranslatedPoint[0], newTranslatedPoint[1]], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n                if (!intersectionPoint) {\n                    return;\n                }\n                data.handles.points[translateHandleIndex] = viewport.canvasToWorld(newTranslatedPoint);\n                data.handles.points[movingHandleIndex] = proposedPoint;\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragDrawCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragDrawCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragModifyCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = true;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash, shadow } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].unit == null) {\n                    data.cachedStats[targetId] = {\n                        length: null,\n                        width: null,\n                        unit: null,\n                    };\n                    this._calculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, renderingEngine, enabledElement);\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, showHandlesAlways ? canvasCoordinates : activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId1 = `${annotationUID}-line-1`;\n                const dataId2 = `${annotationUID}-line-2`;\n                const lineUID = '0';\n                drawLineSvg(svgDrawingHelper, annotationUID, lineUID, canvasCoordinates[0], canvasCoordinates[1], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId1);\n                const secondLineUID = '1';\n                drawLineSvg(svgDrawingHelper, annotationUID, secondLineUID, canvasCoordinates[2], canvasCoordinates[3], {\n                    color,\n                    lineDash,\n                    lineWidth,\n                    shadow,\n                }, dataId2);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                let canvasTextBoxCoords;\n                if (!data.handles.textBox.hasMoved) {\n                    canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._movingLongAxisWouldPutItThroughShortAxis = (firstLineSegment, secondLineSegment) => {\n            const vectorInSecondLineDirection = vec2.create();\n            vec2.set(vectorInSecondLineDirection, secondLineSegment.end.x - secondLineSegment.start.x, secondLineSegment.end.y - secondLineSegment.start.y);\n            vec2.normalize(vectorInSecondLineDirection, vectorInSecondLineDirection);\n            const extendedSecondLineSegment = {\n                start: {\n                    x: secondLineSegment.start.x - vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.start.y - vectorInSecondLineDirection[1] * 10,\n                },\n                end: {\n                    x: secondLineSegment.end.x + vectorInSecondLineDirection[0] * 10,\n                    y: secondLineSegment.end.y + vectorInSecondLineDirection[1] * 10,\n                },\n            };\n            const proposedIntersectionPoint = lineSegment.intersectLine([extendedSecondLineSegment.start.x, extendedSecondLineSegment.start.y], [extendedSecondLineSegment.end.x, extendedSecondLineSegment.end.y], [firstLineSegment.start.x, firstLineSegment.start.y], [firstLineSegment.end.x, firstLineSegment.end.y]);\n            const wouldPutThroughShortAxis = !proposedIntersectionPoint;\n            return wouldPutThroughShortAxis;\n        };\n        this._calculateCachedStats = (annotation, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { element } = enabledElement.viewport;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[1];\n            const worldPos3 = data.handles.points[2];\n            const worldPos4 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, dimensions } = image;\n                const index1 = transformWorldToIndex(imageData, worldPos1);\n                const index2 = transformWorldToIndex(imageData, worldPos2);\n                const index3 = transformWorldToIndex(imageData, worldPos3);\n                const index4 = transformWorldToIndex(imageData, worldPos4);\n                const handles1 = [index1, index2];\n                const handles2 = [index3, index4];\n                const { scale: scale1, unit: units1 } = getCalibratedLengthUnitsAndScale(image, handles1);\n                const { scale: scale2, unit: units2 } = getCalibratedLengthUnitsAndScale(image, handles2);\n                const dist1 = this._calculateLength(worldPos1, worldPos2) / scale1;\n                const dist2 = this._calculateLength(worldPos3, worldPos4) / scale2;\n                const length = dist1 > dist2 ? dist1 : dist2;\n                const width = dist1 > dist2 ? dist2 : dist1;\n                const unit = dist1 > dist2 ? units1 : units2;\n                const widthUnit = dist1 > dist2 ? units2 : units1;\n                this._isInsideVolume(index1, index2, index3, index4, dimensions)\n                    ? (this.isHandleOutsideImage = false)\n                    : (this.isHandleOutsideImage = true);\n                cachedStats[targetId] = {\n                    length,\n                    width,\n                    unit,\n                    widthUnit,\n                };\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, index3, index4, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions) &&\n                csUtils.indexWithinDimensions(index3, dimensions) &&\n                csUtils.indexWithinDimensions(index4, dimensions));\n        };\n        this._getSignedAngle = (vector1, vector2) => {\n            return Math.atan2(vector1[0] * vector2[1] - vector1[1] * vector2[0], vector1[0] * vector2[0] + vector1[1] * vector2[1]);\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    addNewAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { currentPoints, element } = eventDetail;\n        const worldPos = currentPoints.world;\n        this.isDrawing = true;\n        const annotation = this.createAnnotation(evt, [\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n            [...worldPos],\n        ]);\n        addAnnotation(annotation, element);\n        const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n        this.editData = {\n            annotation,\n            viewportIdsToRender,\n            handleIndex: 1,\n            movingTextBox: false,\n            newAnnotation: true,\n            hasMoved: false,\n        };\n        this._activateDraw(element);\n        hideElementCursor(element);\n        evt.preventDefault();\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        return annotation;\n    }\n    static { this.hydrate = (viewportId, axis, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(BidirectionalTool, enabledElement, axis[0], options);\n        const [majorAxis, minorAxis] = axis;\n        const [major0, major1] = majorAxis;\n        const [minor0, minor1] = minorAxis;\n        const points = [major0, major1, minor0, minor1];\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || utilities.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                    textBox: {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    },\n                },\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n        return annotation;\n    }; }\n    _calculateLength(pos1, pos2) {\n        const dx = pos1[0] - pos2[0];\n        const dy = pos1[1] - pos2[1];\n        const dz = pos1[2] - pos2[2];\n        return Math.sqrt(dx * dx + dy * dy + dz * dz);\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const { cachedStats, label } = data;\n    const { length, width, unit } = cachedStats[targetId];\n    const textLines = [];\n    if (label) {\n        textLines.push(label);\n    }\n    if (length === undefined) {\n        return textLines;\n    }\n    textLines.push(`L: ${csUtils.roundNumber(length)} ${unit || unit}`, `W: ${csUtils.roundNumber(width)} ${unit}`);\n    return textLines;\n}\nexport default BidirectionalTool;\n","import { utilities } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport PlanarFreehandROITool from './PlanarFreehandROITool';\nimport AnnotationToPointData from '../../utilities/contours/AnnotationToPointData';\nexport class PlanarFreehandContourSegmentationTool extends PlanarFreehandROITool {\n    static { this.toolName = 'PlanarFreehandContourSegmentationTool'; }\n    constructor(toolProps) {\n        const initialProps = utilities.deepMerge({\n            configuration: {\n                calculateStats: false,\n                allowOpenContours: false,\n            },\n        }, toolProps);\n        super(initialProps);\n    }\n    static {\n        AnnotationToPointData.register(this);\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    renderAnnotationInstance(renderContext) {\n        const annotation = renderContext.annotation;\n        const { invalidated } = annotation;\n        const renderResult = super.renderAnnotationInstance(renderContext);\n        if (invalidated) {\n            const { segmentationId } = annotation.data.segmentation;\n            triggerSegmentationDataModified(segmentationId);\n        }\n        return renderResult;\n    }\n}\nexport default PlanarFreehandContourSegmentationTool;\n","import { CONSTANTS, getEnabledElement, VolumeViewport, utilities as csUtils, metaData, } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport * as math from '../../utilities/math';\nimport { polyline } from '../../utilities/math';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport throttle from '../../utilities/throttle';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport registerDrawLoop from './planarFreehandROITool/drawLoop';\nimport registerEditLoopCommon from './planarFreehandROITool/editLoopCommon';\nimport registerClosedContourEditLoop from './planarFreehandROITool/closedContourEditLoop';\nimport registerOpenContourEditLoop from './planarFreehandROITool/openContourEditLoop';\nimport registerOpenContourEndEditLoop from './planarFreehandROITool/openContourEndEditLoop';\nimport registerRenderMethods from './planarFreehandROITool/renderMethods';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport { drawLinkedTextBox } from '../../drawingSvg';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport { getLineSegmentIntersectionsCoordinates } from '../../utilities/math/polyline';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport calculatePerimeter from '../../utilities/contours/calculatePerimeter';\nimport ContourSegmentationBaseTool from '../base/ContourSegmentationBaseTool';\nimport { KeyboardBindings, ChangeTypes } from '../../enums';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nconst { pointCanProjectOnLine } = polyline;\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nclass PlanarFreehandROITool extends ContourSegmentationBaseTool {\n    static { this.toolName = 'PlanarFreehandROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            storePointData: false,\n            shadow: true,\n            preventHandleOutsideImage: false,\n            contourHoleAdditionModifierKey: KeyboardBindings.Shift,\n            alwaysRenderOpenContourHandles: {\n                enabled: false,\n                radius: 2,\n            },\n            allowOpenContours: true,\n            closeContourProximity: 10,\n            checkCanvasEditFallbackProximity: 6,\n            makeClockWise: true,\n            subPixelResolution: 4,\n            smoothing: {\n                smoothOnAdd: false,\n                smoothOnEdit: false,\n                knotsRatioPercentageOnAdd: 40,\n                knotsRatioPercentageOnEdit: 40,\n            },\n            interpolation: {\n                enabled: false,\n                onInterpolationComplete: null,\n            },\n            decimate: {\n                enabled: false,\n                epsilon: 0.1,\n            },\n            displayOnePointAsCrosshairs: false,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.isDrawing = false;\n        this.isEditingClosed = false;\n        this.isEditingOpen = false;\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const annotation = this.createAnnotation(evt);\n            this.addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.activateDraw(evt, annotation, viewportIdsToRender);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle);\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            if (annotation.data.contour.closed) {\n                this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n            }\n            else {\n                this.activateOpenContourEdit(evt, annotation, viewportIdsToRender);\n            }\n            evt.preventDefault();\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { polyline: points } = annotation.data.contour;\n            let previousPoint = viewport.worldToCanvas(points[0]);\n            for (let i = 1; i < points.length; i++) {\n                const p1 = previousPoint;\n                const p2 = viewport.worldToCanvas(points[i]);\n                const canProject = pointCanProjectOnLine(canvasCoords, p1, p2, proximity);\n                if (canProject) {\n                    return true;\n                }\n                previousPoint = p2;\n            }\n            if (!annotation.data.contour.closed) {\n                return false;\n            }\n            const pStart = viewport.worldToCanvas(points[0]);\n            const pEnd = viewport.worldToCanvas(points[points.length - 1]);\n            return pointCanProjectOnLine(canvasCoords, pStart, pEnd, proximity);\n        };\n        this.cancel = (element) => {\n            const isDrawing = this.isDrawing;\n            const isEditingOpen = this.isEditingOpen;\n            const isEditingClosed = this.isEditingClosed;\n            if (isDrawing) {\n                this.cancelDrawing(element);\n            }\n            else if (isEditingOpen) {\n                this.cancelOpenContourEdit(element);\n            }\n            else if (isEditingClosed) {\n                this.cancelClosedContourEdit(element);\n            }\n        };\n        this._calculateCachedStats = (annotation, viewport, renderingEngine, enabledElement) => {\n            const { data } = annotation;\n            const { cachedStats } = data;\n            const { polyline: points, closed } = data.contour;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { imageData, metadata } = image;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                const modalityUnitOptions = {\n                    isPreScaled: isViewportPreScaled(viewport, targetId),\n                    isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                };\n                const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, modalityUnitOptions);\n                const calibratedScale = getCalibratedLengthUnitsAndScale(image, () => {\n                    const polyline = data.contour.polyline;\n                    const numPoints = polyline.length;\n                    const projectedPolyline = new Array(numPoints);\n                    for (let i = 0; i < numPoints; i++) {\n                        projectedPolyline[i] = viewport.worldToCanvas(polyline[i]);\n                    }\n                    const { maxX: canvasMaxX, maxY: canvasMaxY, minX: canvasMinX, minY: canvasMinY, } = math.polyline.getAABB(projectedPolyline);\n                    const topLeftBBWorld = viewport.canvasToWorld([canvasMinX, canvasMinY]);\n                    const topLeftBBIndex = csUtils.transformWorldToIndex(imageData, topLeftBBWorld);\n                    const bottomRightBBWorld = viewport.canvasToWorld([\n                        canvasMaxX,\n                        canvasMaxY,\n                    ]);\n                    const bottomRightBBIndex = csUtils.transformWorldToIndex(imageData, bottomRightBBWorld);\n                    return [topLeftBBIndex, bottomRightBBIndex];\n                });\n                const canvasPoint = canvasCoordinates[0];\n                const originalWorldPoint = viewport.canvasToWorld(canvasPoint);\n                const deltaXPoint = viewport.canvasToWorld([\n                    canvasPoint[0] + 1,\n                    canvasPoint[1],\n                ]);\n                const deltaYPoint = viewport.canvasToWorld([\n                    canvasPoint[0],\n                    canvasPoint[1] + 1,\n                ]);\n                const deltaInX = vec3.distance(originalWorldPoint, deltaXPoint);\n                const deltaInY = vec3.distance(originalWorldPoint, deltaYPoint);\n                if (closed) {\n                    this.updateClosedCachedStats({\n                        targetId,\n                        viewport,\n                        canvasCoordinates,\n                        points,\n                        imageData,\n                        metadata,\n                        cachedStats,\n                        modalityUnit,\n                        calibratedScale,\n                        deltaInX,\n                        deltaInY,\n                    });\n                }\n                else {\n                    this.updateOpenCachedStats({\n                        metadata,\n                        targetId,\n                        cachedStats,\n                        modalityUnit,\n                        calibratedScale,\n                        points,\n                    });\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, enabledElement.viewport.element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._renderStats = (annotation, viewport, enabledElement, svgDrawingHelper) => {\n            const { data } = annotation;\n            const targetId = this.getTargetId(viewport);\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n                annotationUID: annotation.annotationUID,\n            };\n            const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n            if (!options.visibility) {\n                return;\n            }\n            const textLines = this.configuration.getTextLines(data, targetId);\n            if (!textLines || textLines.length === 0) {\n                return;\n            }\n            const canvasCoordinates = data.contour.polyline.map((p) => viewport.worldToCanvas(p));\n            if (!data.handles.textBox.hasMoved) {\n                const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                data.handles.textBox.worldPosition =\n                    viewport.canvasToWorld(canvasTextBoxCoords);\n            }\n            const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n            const textBoxUID = '1';\n            const boundingBox = drawLinkedTextBox(svgDrawingHelper, annotation.annotationUID ?? '', textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n            const { x: left, y: top, width, height } = boundingBox;\n            data.handles.textBox.worldBoundingBox = {\n                topLeft: viewport.canvasToWorld([left, top]),\n                topRight: viewport.canvasToWorld([left + width, top]),\n                bottomLeft: viewport.canvasToWorld([left, top + height]),\n                bottomRight: viewport.canvasToWorld([left + width, top + height]),\n            };\n        };\n        registerDrawLoop(this);\n        registerEditLoopCommon(this);\n        registerClosedContourEditLoop(this);\n        registerOpenContourEditLoop(this);\n        registerOpenContourEndEditLoop(this);\n        registerRenderMethods(this);\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!annotations || !annotations.length) {\n            return;\n        }\n        const baseFilteredAnnotations = super.filterInteractableAnnotationsForElement(element, annotations);\n        if (!baseFilteredAnnotations || !baseFilteredAnnotations.length) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        let annotationsToDisplay;\n        if (viewport instanceof VolumeViewport) {\n            const camera = viewport.getCamera();\n            const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n            annotationsToDisplay = this.filterAnnotationsWithinSlice(baseFilteredAnnotations, camera, spacingInNormalDirection);\n        }\n        else {\n            annotationsToDisplay = filterAnnotationsForDisplay(viewport, annotations);\n        }\n        return annotationsToDisplay;\n    }\n    filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {\n        const { viewPlaneNormal } = camera;\n        const annotationsWithParallelNormals = annotations.filter((td) => {\n            let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n            if (!td.metadata.referencedImageId &&\n                !annotationViewPlaneNormal &&\n                td.metadata.FrameOfReferenceUID) {\n                for (const point of td.data.contour.polyline) {\n                    const vector = vec3.sub(vec3.create(), point, camera.focalPoint);\n                    const dotProduct = vec3.dot(vector, camera.viewPlaneNormal);\n                    if (!csUtils.isEqual(dotProduct, 0)) {\n                        return false;\n                    }\n                }\n                td.metadata.viewPlaneNormal = camera.viewPlaneNormal;\n                td.metadata.cameraFocalPoint = camera.focalPoint;\n                return true;\n            }\n            if (!annotationViewPlaneNormal) {\n                const { referencedImageId } = td.metadata;\n                const { imageOrientationPatient } = metaData.get('imagePlaneModule', referencedImageId);\n                const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n                const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n                annotationViewPlaneNormal = vec3.create();\n                vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n                td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n            }\n            const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n                PARALLEL_THRESHOLD;\n            return annotationViewPlaneNormal && isParallel;\n        });\n        if (!annotationsWithParallelNormals.length) {\n            return [];\n        }\n        const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n        const { focalPoint } = camera;\n        const annotationsWithinSlice = [];\n        for (const annotation of annotationsWithParallelNormals) {\n            const data = annotation.data;\n            const point = data.contour.polyline[0];\n            if (!annotation.isVisible) {\n                continue;\n            }\n            const dir = vec3.create();\n            vec3.sub(dir, focalPoint, point);\n            const dot = vec3.dot(dir, viewPlaneNormal);\n            if (Math.abs(dot) < halfSpacingInNormalDirection) {\n                annotationsWithinSlice.push(annotation);\n            }\n        }\n        return annotationsWithinSlice;\n    }\n    isContourSegmentationTool() {\n        return false;\n    }\n    createAnnotation(evt) {\n        const worldPos = evt.detail.currentPoints.world;\n        const contourAnnotation = super.createAnnotation(evt);\n        const onInterpolationComplete = (annotation) => {\n            annotation.data.handles.points.length = 0;\n        };\n        const annotation = csUtils.deepMerge(contourAnnotation, {\n            data: {\n                contour: {\n                    polyline: [[...worldPos]],\n                },\n                label: '',\n                cachedStats: {},\n            },\n            onInterpolationComplete,\n        });\n        return annotation;\n    }\n    getAnnotationStyle(context) {\n        return super.getAnnotationStyle(context);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, targetId, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        let renderStatus = false;\n        const { viewport, renderingEngine } = enabledElement;\n        const isDrawing = this.isDrawing;\n        const isEditingOpen = this.isEditingOpen;\n        const isEditingClosed = this.isEditingClosed;\n        if (!(isDrawing || isEditingOpen || isEditingClosed)) {\n            if (this.configuration.displayOnePointAsCrosshairs &&\n                annotation.data.contour.polyline.length === 1) {\n                this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);\n            }\n            else {\n                this.renderContour(enabledElement, svgDrawingHelper, annotation);\n            }\n        }\n        else {\n            const activeAnnotationUID = this.commonData.annotation.annotationUID;\n            if (annotation.annotationUID === activeAnnotationUID) {\n                if (isDrawing) {\n                    this.renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation);\n                }\n                else if (isEditingClosed) {\n                    this.renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                }\n                else if (isEditingOpen) {\n                    this.renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation);\n                }\n                else {\n                    throw new Error(`Unknown ${this.getToolName()} annotation rendering state`);\n                }\n            }\n            else {\n                if (this.configuration.displayOnePointAsCrosshairs &&\n                    annotation.data.contour.polyline.length === 1) {\n                    this.renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation);\n                }\n                else {\n                    this.renderContour(enabledElement, svgDrawingHelper, annotation);\n                }\n            }\n            renderStatus = true;\n        }\n        if (!this.configuration.calculateStats) {\n            return;\n        }\n        if (annotation.invalidated) {\n            this._calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement);\n        }\n        this._renderStats(annotation, viewport, enabledElement, svgDrawingHelper);\n        return renderStatus;\n    }\n    _calculateStatsIfActive(annotation, targetId, viewport, renderingEngine, enabledElement) {\n        const activeAnnotationUID = this.commonData?.annotation.annotationUID;\n        if (annotation.annotationUID === activeAnnotationUID &&\n            !this.commonData?.movingTextBox) {\n            return;\n        }\n        if (!this.commonData?.movingTextBox) {\n            const { data } = annotation;\n            if (!data.cachedStats[targetId]?.unit) {\n                data.cachedStats[targetId] = {\n                    Modality: null,\n                    area: null,\n                    max: null,\n                    mean: null,\n                    stdDev: null,\n                    areaUnit: null,\n                    unit: null,\n                };\n                this._calculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n            }\n            else if (annotation.invalidated) {\n                this._throttledCalculateCachedStats(annotation, viewport, renderingEngine, enabledElement);\n            }\n        }\n    }\n    updateClosedCachedStats({ viewport, points, imageData, metadata, cachedStats, targetId, modalityUnit, canvasCoordinates, calibratedScale, deltaInX, deltaInY, }) {\n        const { scale, areaUnit, unit } = calibratedScale;\n        const { voxelManager } = viewport.getImageData();\n        const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[0]);\n        worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n        worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n        worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n        let iMin = worldPosIndex[0];\n        let iMax = worldPosIndex[0];\n        let jMin = worldPosIndex[1];\n        let jMax = worldPosIndex[1];\n        let kMin = worldPosIndex[2];\n        let kMax = worldPosIndex[2];\n        for (let j = 1; j < points.length; j++) {\n            const worldPosIndex = csUtils.transformWorldToIndex(imageData, points[j]);\n            worldPosIndex[0] = Math.floor(worldPosIndex[0]);\n            worldPosIndex[1] = Math.floor(worldPosIndex[1]);\n            worldPosIndex[2] = Math.floor(worldPosIndex[2]);\n            iMin = Math.min(iMin, worldPosIndex[0]);\n            iMax = Math.max(iMax, worldPosIndex[0]);\n            jMin = Math.min(jMin, worldPosIndex[1]);\n            jMax = Math.max(jMax, worldPosIndex[1]);\n            kMin = Math.min(kMin, worldPosIndex[2]);\n            kMax = Math.max(kMax, worldPosIndex[2]);\n        }\n        const worldPosIndex2 = csUtils.transformWorldToIndex(imageData, points[1]);\n        worldPosIndex2[0] = Math.floor(worldPosIndex2[0]);\n        worldPosIndex2[1] = Math.floor(worldPosIndex2[1]);\n        worldPosIndex2[2] = Math.floor(worldPosIndex2[2]);\n        let area = polyline.getArea(canvasCoordinates) / scale / scale;\n        area *= deltaInX * deltaInY;\n        const perimeter = calculatePerimeter(points, closed) / scale;\n        const iDelta = 0.01 * (iMax - iMin);\n        const jDelta = 0.01 * (jMax - jMin);\n        const kDelta = 0.01 * (kMax - kMin);\n        iMin = Math.floor(iMin - iDelta);\n        iMax = Math.ceil(iMax + iDelta);\n        jMin = Math.floor(jMin - jDelta);\n        jMax = Math.ceil(jMax + jDelta);\n        kMin = Math.floor(kMin - kDelta);\n        kMax = Math.ceil(kMax + kDelta);\n        const boundsIJK = [\n            [iMin, iMax],\n            [jMin, jMax],\n            [kMin, kMax],\n        ];\n        const worldPosEnd = imageData.indexToWorld([iMax, jMax, kMax]);\n        const canvasPosEnd = viewport.worldToCanvas(worldPosEnd);\n        let curRow = 0;\n        let intersections = [];\n        let intersectionCounter = 0;\n        let pointsInShape;\n        if (voxelManager) {\n            pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                imageData,\n                isInObject: (pointLPS, _pointIJK) => {\n                    let result = true;\n                    const point = viewport.worldToCanvas(pointLPS);\n                    if (point[1] != curRow) {\n                        intersectionCounter = 0;\n                        curRow = point[1];\n                        intersections = getLineSegmentIntersectionsCoordinates(canvasCoordinates, point, [canvasPosEnd[0], point[1]]);\n                        intersections.sort((function (index) {\n                            return function (a, b) {\n                                return a[index] === b[index]\n                                    ? 0\n                                    : a[index] < b[index]\n                                        ? -1\n                                        : 1;\n                            };\n                        })(0));\n                    }\n                    if (intersections.length && point[0] > intersections[0][0]) {\n                        intersections.shift();\n                        intersectionCounter++;\n                    }\n                    if (intersectionCounter % 2 === 0) {\n                        result = false;\n                    }\n                    return result;\n                },\n                boundsIJK,\n                returnPoints: this.configuration.storePointData,\n            });\n        }\n        const stats = this.configuration.statsCalculator.getStatistics();\n        cachedStats[targetId] = {\n            Modality: metadata.Modality,\n            area,\n            perimeter,\n            mean: stats.mean?.value,\n            max: stats.max?.value,\n            min: stats.min?.value,\n            stdDev: stats.stdDev?.value,\n            statsArray: stats.array,\n            pointsInShape: pointsInShape,\n            areaUnit,\n            modalityUnit,\n            unit,\n        };\n    }\n    updateOpenCachedStats({ targetId, metadata, cachedStats, modalityUnit, calibratedScale, points, }) {\n        const { scale, unit } = calibratedScale;\n        const length = calculatePerimeter(points, closed) / scale;\n        cachedStats[targetId] = {\n            Modality: metadata.Modality,\n            length,\n            modalityUnit,\n            unit,\n        };\n    }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, stdDev, length, perimeter, max, min, isEmptyArea, unit, areaUnit, modalityUnit, } = cachedVolumeStats || {};\n    const textLines = [];\n    if (csUtils.isNumber(area)) {\n        const areaLine = isEmptyArea\n            ? `Area: Oblique not supported`\n            : `Area: ${csUtils.roundNumber(area)} ${areaUnit}`;\n        textLines.push(areaLine);\n    }\n    if (csUtils.isNumber(mean)) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(min)) {\n        textLines.push(`Min: ${csUtils.roundNumber(min)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(stdDev)) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(perimeter)) {\n        textLines.push(`Perimeter: ${csUtils.roundNumber(perimeter)} ${unit}`);\n    }\n    if (csUtils.isNumber(length)) {\n        textLines.push(`${csUtils.roundNumber(length)} ${unit}`);\n    }\n    return textLines;\n}\nexport default PlanarFreehandROITool;\n","import { AnnotationTool } from '../base';\nimport { getEnabledElement, VolumeViewport, utilities as csUtils, getEnabledElementByViewportId, } from '@cornerstonejs/core';\nimport { getCalibratedLengthUnitsAndScale } from '../../utilities/getCalibratedUnits';\nimport throttle from '../../utilities/throttle';\nimport { addAnnotation, getAnnotations, removeAnnotation, } from '../../stateManagement';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { triggerAnnotationCompleted, triggerAnnotationModified, } from '../../stateManagement/annotation/helpers/state';\nimport { drawHandles as drawHandlesSvg, drawLinkedTextBox as drawLinkedTextBoxSvg, drawRectByCoordinates as drawRectSvg, } from '../../drawingSvg';\nimport { state } from '../../store/state';\nimport { ChangeTypes, Events } from '../../enums';\nimport { getViewportIdsWithToolToRender } from '../../utilities/viewportFilters';\nimport * as rectangle from '../../utilities/math/rectangle';\nimport { getTextBoxCoordsCanvas } from '../../utilities/drawing';\nimport getWorldWidthAndHeightFromCorners from '../../utilities/planar/getWorldWidthAndHeightFromCorners';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportIds from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport { getPixelValueUnits } from '../../utilities/getPixelValueUnits';\nimport { isViewportPreScaled } from '../../utilities/viewport/isViewportPreScaled';\nimport { BasicStatsCalculator } from '../../utilities/math/basic';\nimport { getStyleProperty } from '../../stateManagement/annotation/config/helpers';\nconst { transformWorldToIndex } = csUtils;\nclass RectangleROITool extends AnnotationTool {\n    static { this.toolName = 'RectangleROI'; }\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            storePointData: false,\n            shadow: true,\n            preventHandleOutsideImage: false,\n            calculateStats: true,\n            getTextLines: defaultGetTextLines,\n            statsCalculator: BasicStatsCalculator,\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this.addNewAnnotation = (evt) => {\n            const eventDetail = evt.detail;\n            const { currentPoints, element } = eventDetail;\n            const worldPos = currentPoints.world;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.isDrawing = true;\n            const annotation = (this.constructor).createAnnotationForViewport(viewport, {\n                data: {\n                    handles: {\n                        points: [\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                            [...worldPos],\n                        ],\n                        textBox: {\n                            hasMoved: false,\n                            worldPosition: [0, 0, 0],\n                            worldBoundingBox: {\n                                topLeft: [0, 0, 0],\n                                topRight: [0, 0, 0],\n                                bottomLeft: [0, 0, 0],\n                                bottomRight: [0, 0, 0],\n                            },\n                        },\n                    },\n                    cachedStats: {},\n                },\n            });\n            addAnnotation(annotation, element);\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex: 3,\n                movingTextBox: false,\n                newAnnotation: true,\n                hasMoved: false,\n            };\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            return annotation;\n        };\n        this.isPointNearTool = (element, annotation, canvasCoords, proximity) => {\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            const { data } = annotation;\n            const { points } = data.handles;\n            const canvasPoint1 = viewport.worldToCanvas(points[0]);\n            const canvasPoint2 = viewport.worldToCanvas(points[3]);\n            const rect = this._getRectangleImageCoordinates([\n                canvasPoint1,\n                canvasPoint2,\n            ]);\n            const point = [canvasCoords[0], canvasCoords[1]];\n            const { left, top, width, height } = rect;\n            const distanceToPoint = rectangle.distanceToPoint([left, top, width, height], point);\n            if (distanceToPoint <= proximity) {\n                return true;\n            }\n            return false;\n        };\n        this.toolSelectedCallback = (evt, annotation) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            annotation.highlighted = true;\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                movingTextBox: false,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this.handleSelectedCallback = (evt, annotation, handle) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { data } = annotation;\n            annotation.highlighted = true;\n            let movingTextBox = false;\n            let handleIndex;\n            if (handle.worldPosition) {\n                movingTextBox = true;\n            }\n            else {\n                handleIndex = data.handles.points.findIndex((p) => p === handle);\n            }\n            const viewportIdsToRender = getViewportIdsWithToolToRender(element, this.getToolName());\n            this.editData = {\n                annotation,\n                viewportIdsToRender,\n                handleIndex,\n                movingTextBox,\n            };\n            this._activateModify(element);\n            hideElementCursor(element);\n            const enabledElement = getEnabledElement(element);\n            const { renderingEngine } = enabledElement;\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            evt.preventDefault();\n        };\n        this._endCallback = (evt) => {\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, newAnnotation, hasMoved } = this.editData;\n            const { data } = annotation;\n            if (newAnnotation && !hasMoved) {\n                return;\n            }\n            data.handles.activeHandleIndex = null;\n            this._deactivateModify(element);\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.doneEditMemo();\n            this.editData = null;\n            this.isDrawing = false;\n            if (this.isHandleOutsideImage &&\n                this.configuration.preventHandleOutsideImage) {\n                removeAnnotation(annotation.annotationUID);\n            }\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (newAnnotation) {\n                triggerAnnotationCompleted(annotation);\n            }\n        };\n        this._dragCallback = (evt) => {\n            this.isDrawing = true;\n            const eventDetail = evt.detail;\n            const { element } = eventDetail;\n            const { annotation, viewportIdsToRender, handleIndex, movingTextBox, newAnnotation, } = this.editData;\n            this.createMemo(element, annotation, { newAnnotation });\n            const { data } = annotation;\n            if (movingTextBox) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { textBox } = data.handles;\n                const { worldPosition } = textBox;\n                worldPosition[0] += worldPosDelta[0];\n                worldPosition[1] += worldPosDelta[1];\n                worldPosition[2] += worldPosDelta[2];\n                textBox.hasMoved = true;\n            }\n            else if (handleIndex === undefined) {\n                const { deltaPoints } = eventDetail;\n                const worldPosDelta = deltaPoints.world;\n                const { points } = data.handles;\n                points.forEach((point) => {\n                    point[0] += worldPosDelta[0];\n                    point[1] += worldPosDelta[1];\n                    point[2] += worldPosDelta[2];\n                });\n                annotation.invalidated = true;\n            }\n            else {\n                const { currentPoints } = eventDetail;\n                const enabledElement = getEnabledElement(element);\n                const { worldToCanvas, canvasToWorld } = enabledElement.viewport;\n                const worldPos = currentPoints.world;\n                const { points } = data.handles;\n                points[handleIndex] = [...worldPos];\n                let bottomLeftCanvas;\n                let bottomRightCanvas;\n                let topLeftCanvas;\n                let topRightCanvas;\n                let bottomLeftWorld;\n                let bottomRightWorld;\n                let topLeftWorld;\n                let topRightWorld;\n                switch (handleIndex) {\n                    case 0:\n                    case 3:\n                        bottomLeftCanvas = worldToCanvas(points[0]);\n                        topRightCanvas = worldToCanvas(points[3]);\n                        bottomRightCanvas = [topRightCanvas[0], bottomLeftCanvas[1]];\n                        topLeftCanvas = [bottomLeftCanvas[0], topRightCanvas[1]];\n                        bottomRightWorld = canvasToWorld(bottomRightCanvas);\n                        topLeftWorld = canvasToWorld(topLeftCanvas);\n                        points[1] = bottomRightWorld;\n                        points[2] = topLeftWorld;\n                        break;\n                    case 1:\n                    case 2:\n                        bottomRightCanvas = worldToCanvas(points[1]);\n                        topLeftCanvas = worldToCanvas(points[2]);\n                        bottomLeftCanvas = [\n                            topLeftCanvas[0],\n                            bottomRightCanvas[1],\n                        ];\n                        topRightCanvas = [\n                            bottomRightCanvas[0],\n                            topLeftCanvas[1],\n                        ];\n                        bottomLeftWorld = canvasToWorld(bottomLeftCanvas);\n                        topRightWorld = canvasToWorld(topRightCanvas);\n                        points[0] = bottomLeftWorld;\n                        points[3] = topRightWorld;\n                        break;\n                }\n                annotation.invalidated = true;\n            }\n            this.editData.hasMoved = true;\n            const enabledElement = getEnabledElement(element);\n            triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n            if (annotation.invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n            }\n        };\n        this.cancel = (element) => {\n            if (this.isDrawing) {\n                this.isDrawing = false;\n                this._deactivateDraw(element);\n                this._deactivateModify(element);\n                resetElementCursor(element);\n                const { annotation, viewportIdsToRender, newAnnotation } = this.editData;\n                const { data } = annotation;\n                annotation.highlighted = false;\n                data.handles.activeHandleIndex = null;\n                triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n                if (newAnnotation) {\n                    triggerAnnotationCompleted(annotation);\n                }\n                this.editData = null;\n                return annotation.annotationUID;\n            }\n        };\n        this._activateDraw = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_MOVE, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._activateModify = (element) => {\n            state.isInteractingWithTool = true;\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.addEventListener(Events.TOUCH_END, this._endCallback);\n            element.addEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.addEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this._deactivateModify = (element) => {\n            state.isInteractingWithTool = false;\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n            element.removeEventListener(Events.TOUCH_END, this._endCallback);\n            element.removeEventListener(Events.TOUCH_DRAG, this._dragCallback);\n            element.removeEventListener(Events.TOUCH_TAP, this._endCallback);\n        };\n        this.renderAnnotation = (enabledElement, svgDrawingHelper) => {\n            let renderStatus = false;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            let annotations = getAnnotations(this.getToolName(), element);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n            if (!annotations?.length) {\n                return renderStatus;\n            }\n            const targetId = this.getTargetId(viewport);\n            const renderingEngine = viewport.getRenderingEngine();\n            const styleSpecifier = {\n                toolGroupId: this.toolGroupId,\n                toolName: this.getToolName(),\n                viewportId: enabledElement.viewport.id,\n            };\n            for (let i = 0; i < annotations.length; i++) {\n                const annotation = annotations[i];\n                const { annotationUID, data } = annotation;\n                const { points, activeHandleIndex } = data.handles;\n                const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n                styleSpecifier.annotationUID = annotationUID;\n                const { color, lineWidth, lineDash } = this.getAnnotationStyle({\n                    annotation,\n                    styleSpecifier,\n                });\n                const { viewPlaneNormal, viewUp } = viewport.getCamera();\n                if (!data.cachedStats[targetId] ||\n                    data.cachedStats[targetId].areaUnit == null) {\n                    data.cachedStats[targetId] = {\n                        Modality: null,\n                        area: null,\n                        max: null,\n                        mean: null,\n                        stdDev: null,\n                        areaUnit: null,\n                    };\n                    this._calculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);\n                }\n                else if (annotation.invalidated) {\n                    this._throttledCalculateCachedStats(annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement);\n                    if (viewport instanceof VolumeViewport) {\n                        const { referencedImageId } = annotation.metadata;\n                        for (const targetId in data.cachedStats) {\n                            if (targetId.startsWith('imageId')) {\n                                const viewports = renderingEngine.getStackViewports();\n                                const invalidatedStack = viewports.find((vp) => {\n                                    const referencedImageURI = csUtils.imageIdToURI(referencedImageId);\n                                    const hasImageURI = vp.hasImageURI(referencedImageURI);\n                                    const currentImageURI = csUtils.imageIdToURI(vp.getCurrentImageId());\n                                    return hasImageURI && currentImageURI !== referencedImageURI;\n                                });\n                                if (invalidatedStack) {\n                                    delete data.cachedStats[targetId];\n                                }\n                            }\n                        }\n                    }\n                }\n                if (!viewport.getRenderingEngine()) {\n                    console.warn('Rendering Engine has been destroyed');\n                    return renderStatus;\n                }\n                let activeHandleCanvasCoords;\n                if (!isAnnotationVisible(annotationUID)) {\n                    continue;\n                }\n                if (!isAnnotationLocked(annotationUID) &&\n                    !this.editData &&\n                    activeHandleIndex !== null &&\n                    activeHandleIndex !== undefined) {\n                    activeHandleCanvasCoords = [canvasCoordinates[activeHandleIndex]];\n                }\n                const showHandlesAlways = Boolean(getStyleProperty('showHandlesAlways', {}));\n                if (activeHandleCanvasCoords || showHandlesAlways) {\n                    const handleGroupUID = '0';\n                    drawHandlesSvg(svgDrawingHelper, annotationUID, handleGroupUID, showHandlesAlways ? canvasCoordinates : activeHandleCanvasCoords, {\n                        color,\n                    });\n                }\n                const dataId = `${annotationUID}-rect`;\n                const rectangleUID = '0';\n                drawRectSvg(svgDrawingHelper, annotationUID, rectangleUID, canvasCoordinates, {\n                    color,\n                    lineDash,\n                    lineWidth,\n                }, dataId);\n                renderStatus = true;\n                const options = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n                if (!options.visibility) {\n                    data.handles.textBox = {\n                        hasMoved: false,\n                        worldPosition: [0, 0, 0],\n                        worldBoundingBox: {\n                            topLeft: [0, 0, 0],\n                            topRight: [0, 0, 0],\n                            bottomLeft: [0, 0, 0],\n                            bottomRight: [0, 0, 0],\n                        },\n                    };\n                    continue;\n                }\n                const textLines = this.configuration.getTextLines(data, targetId);\n                if (!textLines || textLines.length === 0) {\n                    continue;\n                }\n                if (!data.handles.textBox.hasMoved) {\n                    const canvasTextBoxCoords = getTextBoxCoordsCanvas(canvasCoordinates);\n                    data.handles.textBox.worldPosition =\n                        viewport.canvasToWorld(canvasTextBoxCoords);\n                }\n                const textBoxPosition = viewport.worldToCanvas(data.handles.textBox.worldPosition);\n                const textBoxUID = '1';\n                const boundingBox = drawLinkedTextBoxSvg(svgDrawingHelper, annotationUID, textBoxUID, textLines, textBoxPosition, canvasCoordinates, {}, options);\n                const { x: left, y: top, width, height } = boundingBox;\n                data.handles.textBox.worldBoundingBox = {\n                    topLeft: viewport.canvasToWorld([left, top]),\n                    topRight: viewport.canvasToWorld([left + width, top]),\n                    bottomLeft: viewport.canvasToWorld([left, top + height]),\n                    bottomRight: viewport.canvasToWorld([left + width, top + height]),\n                };\n            }\n            return renderStatus;\n        };\n        this._getRectangleImageCoordinates = (points) => {\n            const [point0, point1] = points;\n            return {\n                left: Math.min(point0[0], point1[0]),\n                top: Math.min(point0[1], point1[1]),\n                width: Math.abs(point0[0] - point1[0]),\n                height: Math.abs(point0[1] - point1[1]),\n            };\n        };\n        this._calculateCachedStats = (annotation, viewPlaneNormal, viewUp, renderingEngine, enabledElement) => {\n            if (!this.configuration.calculateStats) {\n                return;\n            }\n            const { data } = annotation;\n            const { viewport } = enabledElement;\n            const { element } = viewport;\n            const worldPos1 = data.handles.points[0];\n            const worldPos2 = data.handles.points[3];\n            const { cachedStats } = data;\n            const targetIds = Object.keys(cachedStats);\n            for (let i = 0; i < targetIds.length; i++) {\n                const targetId = targetIds[i];\n                const image = this.getTargetImageData(targetId);\n                if (!image) {\n                    continue;\n                }\n                const { dimensions, imageData, metadata, voxelManager } = image;\n                const pos1Index = transformWorldToIndex(imageData, worldPos1);\n                pos1Index[0] = Math.floor(pos1Index[0]);\n                pos1Index[1] = Math.floor(pos1Index[1]);\n                pos1Index[2] = Math.floor(pos1Index[2]);\n                const pos2Index = transformWorldToIndex(imageData, worldPos2);\n                pos2Index[0] = Math.floor(pos2Index[0]);\n                pos2Index[1] = Math.floor(pos2Index[1]);\n                pos2Index[2] = Math.floor(pos2Index[2]);\n                if (this._isInsideVolume(pos1Index, pos2Index, dimensions)) {\n                    this.isHandleOutsideImage = false;\n                    const iMin = Math.min(pos1Index[0], pos2Index[0]);\n                    const iMax = Math.max(pos1Index[0], pos2Index[0]);\n                    const jMin = Math.min(pos1Index[1], pos2Index[1]);\n                    const jMax = Math.max(pos1Index[1], pos2Index[1]);\n                    const kMin = Math.min(pos1Index[2], pos2Index[2]);\n                    const kMax = Math.max(pos1Index[2], pos2Index[2]);\n                    const boundsIJK = [\n                        [iMin, iMax],\n                        [jMin, jMax],\n                        [kMin, kMax],\n                    ];\n                    const { worldWidth, worldHeight } = getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, worldPos1, worldPos2);\n                    const handles = [pos1Index, pos2Index];\n                    const { scale, areaUnit } = getCalibratedLengthUnitsAndScale(image, handles);\n                    const area = Math.abs(worldWidth * worldHeight) / (scale * scale);\n                    const pixelUnitsOptions = {\n                        isPreScaled: isViewportPreScaled(viewport, targetId),\n                        isSuvScaled: this.isSuvScaled(viewport, targetId, annotation.metadata.referencedImageId),\n                    };\n                    const modalityUnit = getPixelValueUnits(metadata.Modality, annotation.metadata.referencedImageId, pixelUnitsOptions);\n                    let pointsInShape;\n                    if (voxelManager) {\n                        pointsInShape = voxelManager.forEach(this.configuration.statsCalculator.statsCallback, {\n                            boundsIJK,\n                            imageData,\n                            returnPoints: this.configuration.storePointData,\n                        });\n                    }\n                    const stats = this.configuration.statsCalculator.getStatistics();\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                        area,\n                        mean: stats.mean?.value,\n                        stdDev: stats.stdDev?.value,\n                        max: stats.max?.value,\n                        min: stats.min?.value,\n                        statsArray: stats.array,\n                        pointsInShape: pointsInShape,\n                        areaUnit,\n                        modalityUnit,\n                    };\n                }\n                else {\n                    this.isHandleOutsideImage = true;\n                    cachedStats[targetId] = {\n                        Modality: metadata.Modality,\n                    };\n                }\n            }\n            const invalidated = annotation.invalidated;\n            annotation.invalidated = false;\n            if (invalidated) {\n                triggerAnnotationModified(annotation, element, ChangeTypes.StatsUpdated);\n            }\n            return cachedStats;\n        };\n        this._isInsideVolume = (index1, index2, dimensions) => {\n            return (csUtils.indexWithinDimensions(index1, dimensions) &&\n                csUtils.indexWithinDimensions(index2, dimensions));\n        };\n        this._throttledCalculateCachedStats = throttle(this._calculateCachedStats, 100, { trailing: true });\n    }\n    static { this.hydrate = (viewportId, points, options) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            return;\n        }\n        const { FrameOfReferenceUID, referencedImageId, viewPlaneNormal, instance, viewport, } = this.hydrateBase(RectangleROITool, enabledElement, points, options);\n        const { toolInstance, ...serializableOptions } = options || {};\n        const annotation = {\n            annotationUID: options?.annotationUID || csUtils.uuidv4(),\n            data: {\n                handles: {\n                    points,\n                    activeHandleIndex: null,\n                },\n                label: '',\n                cachedStats: {},\n            },\n            highlighted: false,\n            autoGenerated: false,\n            invalidated: false,\n            isLocked: false,\n            isVisible: true,\n            metadata: {\n                toolName: instance.getToolName(),\n                viewPlaneNormal,\n                FrameOfReferenceUID,\n                referencedImageId,\n                ...serializableOptions,\n            },\n        };\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationRenderForViewportIds([viewport.id]);\n    }; }\n}\nfunction defaultGetTextLines(data, targetId) {\n    const cachedVolumeStats = data.cachedStats[targetId];\n    const { area, mean, max, stdDev, areaUnit, modalityUnit, min } = cachedVolumeStats;\n    if (mean === undefined || mean === null) {\n        return;\n    }\n    const textLines = [];\n    if (csUtils.isNumber(area)) {\n        textLines.push(`Area: ${csUtils.roundNumber(area)} ${areaUnit}`);\n    }\n    if (csUtils.isNumber(mean)) {\n        textLines.push(`Mean: ${csUtils.roundNumber(mean)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(max)) {\n        textLines.push(`Max: ${csUtils.roundNumber(max)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(min)) {\n        textLines.push(`Min: ${csUtils.roundNumber(min)} ${modalityUnit}`);\n    }\n    if (csUtils.isNumber(stdDev)) {\n        textLines.push(`Std Dev: ${csUtils.roundNumber(stdDev)} ${modalityUnit}`);\n    }\n    return textLines;\n}\nexport default RectangleROITool;\n","import { getEnabledElement, eventTarget } from '@cornerstonejs/core';\nimport { vec3, vec2 } from 'gl-matrix';\nimport { Events, ToolModes, StrategyCallbacks } from '../../enums';\nimport { fillInsideSphere, thresholdInsideSphere, thresholdInsideSphereIsland, } from './strategies/fillSphere';\nimport { eraseInsideSphere } from './strategies/eraseSphere';\nimport { thresholdInsideCircle, fillInsideCircle, } from './strategies/fillCircle';\nimport { eraseInsideCircle } from './strategies/eraseCircle';\nimport { drawCircle as drawCircleSvg } from '../../drawingSvg';\nimport { resetElementCursor, hideElementCursor, } from '../../cursors/elementCursor';\nimport triggerAnnotationRenderForViewportUIDs from '../../utilities/triggerAnnotationRenderForViewportIds';\nimport LabelmapBaseTool from './LabelmapBaseTool';\nimport { getStrategyData } from './strategies/utils/getStrategyData';\nclass BrushTool extends LabelmapBaseTool {\n    constructor(toolProps = {}, defaultToolProps = {\n        supportedInteractionTypes: ['Mouse', 'Touch'],\n        configuration: {\n            strategies: {\n                FILL_INSIDE_CIRCLE: fillInsideCircle,\n                ERASE_INSIDE_CIRCLE: eraseInsideCircle,\n                FILL_INSIDE_SPHERE: fillInsideSphere,\n                ERASE_INSIDE_SPHERE: eraseInsideSphere,\n                THRESHOLD_INSIDE_CIRCLE: thresholdInsideCircle,\n                THRESHOLD_INSIDE_SPHERE: thresholdInsideSphere,\n                THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL: thresholdInsideSphereIsland,\n            },\n            defaultStrategy: 'FILL_INSIDE_CIRCLE',\n            activeStrategy: 'FILL_INSIDE_CIRCLE',\n            brushSize: 25,\n            useCenterSegmentIndex: false,\n            preview: {\n                enabled: false,\n                previewColors: {\n                    0: [255, 255, 255, 128],\n                },\n                previewTimeMs: 250,\n                previewMoveDistance: 8,\n                dragMoveDistance: 4,\n                dragTimeMs: 500,\n            },\n            actions: {\n                [StrategyCallbacks.AcceptPreview]: {\n                    method: StrategyCallbacks.AcceptPreview,\n                    bindings: [\n                        {\n                            key: 'Enter',\n                        },\n                    ],\n                },\n                [StrategyCallbacks.RejectPreview]: {\n                    method: StrategyCallbacks.RejectPreview,\n                    bindings: [\n                        {\n                            key: 'Escape',\n                        },\n                    ],\n                },\n                [StrategyCallbacks.Interpolate]: {\n                    method: StrategyCallbacks.Interpolate,\n                    bindings: [\n                        {\n                            key: 'i',\n                        },\n                    ],\n                    configuration: {\n                        useBallStructuringElement: true,\n                        noUseDistanceTransform: true,\n                        noUseExtrapolation: true,\n                    },\n                },\n                interpolateExtrapolation: {\n                    method: StrategyCallbacks.Interpolate,\n                    bindings: [\n                        {\n                            key: 'e',\n                        },\n                    ],\n                    configuration: {},\n                },\n            },\n        },\n    }) {\n        super(toolProps, defaultToolProps);\n        this._lastDragInfo = null;\n        this.onSetToolPassive = (evt) => {\n            this.disableCursor();\n        };\n        this.onSetToolEnabled = () => {\n            this.disableCursor();\n        };\n        this.onSetToolDisabled = (evt) => {\n            this.disableCursor();\n        };\n        this.preMouseDownCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this._editData = this.createEditData(element);\n            this._activateDraw(element);\n            hideElementCursor(element);\n            evt.preventDefault();\n            this._previewData.isDrag = false;\n            this._previewData.timerStart = Date.now();\n            const canvasPoint = vec2.clone(currentPoints.canvas);\n            const worldPoint = viewport.canvasToWorld([\n                canvasPoint[0],\n                canvasPoint[1],\n            ]);\n            this._lastDragInfo = {\n                canvas: canvasPoint,\n                world: vec3.clone(worldPoint),\n            };\n            const hoverData = this._hoverData || this.createHoverData(element);\n            triggerAnnotationRenderForViewportUIDs(hoverData.viewportIdsToRender);\n            const operationData = this.getOperationData(element);\n            this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.OnInteractionStart);\n            return true;\n        };\n        this.mouseMoveCallback = (evt) => {\n            if (this.mode === ToolModes.Active) {\n                this.updateCursor(evt);\n                if (!this.configuration.preview.enabled) {\n                    return;\n                }\n                const { previewTimeMs, previewMoveDistance, dragMoveDistance } = this.configuration.preview;\n                const { currentPoints, element } = evt.detail;\n                const { canvas } = currentPoints;\n                const { startPoint, timer, timerStart, isDrag } = this._previewData;\n                if (isDrag) {\n                    return;\n                }\n                const delta = vec2.distance(canvas, startPoint);\n                const time = Date.now() - timerStart;\n                if (delta > previewMoveDistance ||\n                    (time > previewTimeMs && delta > dragMoveDistance)) {\n                    if (timer) {\n                        window.clearTimeout(timer);\n                        this._previewData.timer = null;\n                    }\n                    if (!isDrag) {\n                        this.rejectPreview(element);\n                    }\n                }\n                if (!this._previewData.timer) {\n                    const timer = window.setTimeout(this.previewCallback, 250);\n                    Object.assign(this._previewData, {\n                        timerStart: Date.now(),\n                        timer,\n                        startPoint: canvas,\n                        element,\n                    });\n                }\n            }\n        };\n        this.previewCallback = () => {\n            if (this._previewData.isDrag) {\n                this._previewData.timer = null;\n                return;\n            }\n            this._previewData.timer = null;\n            const operationData = this.getOperationData(this._previewData.element);\n            const enabledElement = getEnabledElement(this._previewData.element);\n            if (!enabledElement) {\n                return;\n            }\n            const { viewport } = enabledElement;\n            const activeStrategy = this.configuration.activeStrategy;\n            const strategyData = getStrategyData({\n                operationData,\n                viewport,\n                strategy: activeStrategy,\n            });\n            if (!operationData) {\n                return;\n            }\n            const memo = this.createMemo(operationData.segmentationId, strategyData.segmentationVoxelManager);\n            this._previewData.preview = this.applyActiveStrategyCallback(getEnabledElement(this._previewData.element), {\n                ...operationData,\n                ...strategyData,\n                memo,\n            }, StrategyCallbacks.Preview);\n        };\n        this._dragCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element, currentPoints } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const { viewport } = enabledElement;\n            this.updateCursor(evt);\n            const { viewportIdsToRender } = this._hoverData;\n            triggerAnnotationRenderForViewportUIDs(viewportIdsToRender);\n            const delta = vec2.distance(currentPoints.canvas, this._previewData.startPoint);\n            const { dragTimeMs, dragMoveDistance } = this.configuration.preview;\n            if (!this._previewData.isDrag &&\n                Date.now() - this._previewData.timerStart < dragTimeMs &&\n                delta < dragMoveDistance) {\n                return;\n            }\n            if (this._previewData.timer) {\n                window.clearTimeout(this._previewData.timer);\n                this._previewData.timer = null;\n            }\n            if (!this._lastDragInfo) {\n                const startCanvas = this._previewData.startPoint;\n                const startWorld = viewport.canvasToWorld([\n                    startCanvas[0],\n                    startCanvas[1],\n                ]);\n                this._lastDragInfo = {\n                    canvas: vec2.clone(startCanvas),\n                    world: vec3.clone(startWorld),\n                };\n            }\n            const currentCanvas = currentPoints.canvas;\n            const currentWorld = viewport.canvasToWorld([\n                currentCanvas[0],\n                currentCanvas[1],\n            ]);\n            this._hoverData = this.createHoverData(element, currentCanvas);\n            this._calculateCursor(element, currentCanvas);\n            const operationData = this.getOperationData(element);\n            operationData.strokePointsWorld = [\n                vec3.clone(this._lastDragInfo.world),\n                vec3.clone(currentWorld),\n            ];\n            this._previewData.preview = this.applyActiveStrategy(enabledElement, operationData);\n            const currentCanvasClone = vec2.clone(currentCanvas);\n            this._lastDragInfo = {\n                canvas: currentCanvasClone,\n                world: vec3.clone(currentWorld),\n            };\n            this._previewData.element = element;\n            this._previewData.timerStart = Date.now() + dragTimeMs;\n            this._previewData.isDrag = true;\n            this._previewData.startPoint = currentCanvasClone;\n        };\n        this._endCallback = (evt) => {\n            const eventData = evt.detail;\n            const { element } = eventData;\n            const enabledElement = getEnabledElement(element);\n            const operationData = this.getOperationData(element);\n            if (!this._previewData.preview && !this._previewData.isDrag) {\n                this.applyActiveStrategy(enabledElement, operationData);\n            }\n            this.doneEditMemo();\n            this._deactivateDraw(element);\n            resetElementCursor(element);\n            this.updateCursor(evt);\n            this._editData = null;\n            this._lastDragInfo = null;\n            this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.OnInteractionEnd);\n            if (!this._previewData.isDrag) {\n                this.acceptPreview(element);\n            }\n        };\n        this._activateDraw = (element) => {\n            element.addEventListener(Events.MOUSE_UP, this._endCallback);\n            element.addEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.addEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n        this._deactivateDraw = (element) => {\n            element.removeEventListener(Events.MOUSE_UP, this._endCallback);\n            element.removeEventListener(Events.MOUSE_DRAG, this._dragCallback);\n            element.removeEventListener(Events.MOUSE_CLICK, this._endCallback);\n        };\n    }\n    disableCursor() {\n        this._hoverData = undefined;\n        this.rejectPreview();\n    }\n    updateCursor(evt) {\n        const eventData = evt.detail;\n        const { element } = eventData;\n        const { currentPoints } = eventData;\n        const centerCanvas = currentPoints.canvas;\n        this._hoverData = this.createHoverData(element, centerCanvas);\n        this._calculateCursor(element, centerCanvas);\n        if (!this._hoverData) {\n            return;\n        }\n        triggerAnnotationRenderForViewportUIDs(this._hoverData.viewportIdsToRender);\n    }\n    _calculateCursor(element, centerCanvas) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { canvasToWorld } = viewport;\n        const camera = viewport.getCamera();\n        const { brushSize } = this.configuration;\n        const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n        const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n        const viewRight = vec3.create();\n        vec3.cross(viewRight, viewUp, viewPlaneNormal);\n        const centerCursorInWorld = canvasToWorld([\n            centerCanvas[0],\n            centerCanvas[1],\n        ]);\n        const bottomCursorInWorld = vec3.create();\n        const topCursorInWorld = vec3.create();\n        const leftCursorInWorld = vec3.create();\n        const rightCursorInWorld = vec3.create();\n        for (let i = 0; i <= 2; i++) {\n            bottomCursorInWorld[i] = centerCursorInWorld[i] - viewUp[i] * brushSize;\n            topCursorInWorld[i] = centerCursorInWorld[i] + viewUp[i] * brushSize;\n            leftCursorInWorld[i] = centerCursorInWorld[i] - viewRight[i] * brushSize;\n            rightCursorInWorld[i] = centerCursorInWorld[i] + viewRight[i] * brushSize;\n        }\n        if (!this._hoverData) {\n            return;\n        }\n        const { brushCursor } = this._hoverData;\n        const { data } = brushCursor;\n        if (data.handles === undefined) {\n            data.handles = {};\n        }\n        data.handles.points = [\n            bottomCursorInWorld,\n            topCursorInWorld,\n            leftCursorInWorld,\n            rightCursorInWorld,\n        ];\n        const activeStrategy = this.configuration.activeStrategy;\n        const strategy = this.configuration.strategies[activeStrategy];\n        if (typeof strategy?.computeInnerCircleRadius === 'function') {\n            strategy.computeInnerCircleRadius({\n                configuration: this.configuration,\n                viewport,\n            });\n        }\n        data.invalidated = false;\n    }\n    getStatistics(element, segmentIndices) {\n        if (!element) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const stats = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.GetStatistics, segmentIndices);\n        return stats;\n    }\n    rejectPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        this.doneEditMemo();\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.RejectPreview);\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    acceptPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        super.acceptPreview(element);\n    }\n    interpolate(element, config) {\n        if (!element) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        this._previewData.preview = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.Interpolate, config.configuration);\n        this._previewData.isDrag = true;\n    }\n    invalidateBrushCursor() {\n        if (this._hoverData === undefined) {\n            return;\n        }\n        const { data } = this._hoverData.brushCursor;\n        const { viewport } = this._hoverData;\n        data.invalidated = true;\n        const { segmentColor } = this.getActiveSegmentationData(viewport) || {};\n        this._hoverData.brushCursor.metadata.segmentColor = segmentColor;\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        if (!this._hoverData) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const viewportIdsToRender = this._hoverData.viewportIdsToRender;\n        if (!viewportIdsToRender.includes(viewport.id)) {\n            return;\n        }\n        const brushCursor = this._hoverData.brushCursor;\n        if (brushCursor.data.invalidated === true) {\n            const { centerCanvas } = this._hoverData;\n            const { element } = viewport;\n            this._calculateCursor(element, centerCanvas);\n        }\n        const toolMetadata = brushCursor.metadata;\n        if (!toolMetadata) {\n            return;\n        }\n        const annotationUID = toolMetadata.brushCursorUID;\n        const data = brushCursor.data;\n        const { points } = data.handles;\n        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n        const bottom = canvasCoordinates[0];\n        const top = canvasCoordinates[1];\n        const center = [\n            Math.floor((bottom[0] + top[0]) / 2),\n            Math.floor((bottom[1] + top[1]) / 2),\n        ];\n        const radius = Math.abs(bottom[1] - Math.floor((bottom[1] + top[1]) / 2));\n        const color = `rgb(${toolMetadata.segmentColor?.slice(0, 3) || [0, 0, 0]})`;\n        if (!viewport.getRenderingEngine()) {\n            console.warn('Rendering Engine has been destroyed');\n            return;\n        }\n        const circleUID = '0';\n        drawCircleSvg(svgDrawingHelper, annotationUID, circleUID, center, radius, {\n            color,\n            lineDash: this.centerSegmentIndexInfo.segmentIndex === 0 ? [1, 2] : null,\n        });\n        const { dynamicRadiusInCanvas } = this.configuration?.threshold || {\n            dynamicRadiusInCanvas: 0,\n        };\n        if (dynamicRadiusInCanvas) {\n            const circleUID1 = '1';\n            drawCircleSvg(svgDrawingHelper, annotationUID, circleUID1, center, dynamicRadiusInCanvas, {\n                color,\n            });\n        }\n    }\n}\nBrushTool.toolName = 'Brush';\nexport default BrushTool;\n","import { getEnabledElement, cache, utilities as csUtils, Enums, eventTarget, BaseVolumeViewport, StackViewport, } from '@cornerstonejs/core';\nimport { BaseTool } from '../base';\nimport SegmentationRepresentations from '../../enums/SegmentationRepresentations';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getLockedSegmentIndices } from '../../stateManagement/segmentation/segmentLocking';\nimport { getSegmentation } from '../../stateManagement/segmentation/getSegmentation';\nimport { getCurrentLabelmapImageIdForViewport } from '../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { StrategyCallbacks } from '../../enums';\nimport * as LabelmapMemo from '../../utilities/segmentation/createLabelmapMemo';\nimport { getAllAnnotations, removeAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { filterAnnotationsForDisplay } from '../../utilities/planar';\nimport { isPointInsidePolyline3D } from '../../utilities/math/polyline';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { fillInsideCircle } from './strategies';\nexport default class LabelmapBaseTool extends BaseTool {\n    static { this.previewData = {\n        preview: null,\n        element: null,\n        timerStart: 0,\n        timer: null,\n        startPoint: [NaN, NaN],\n        isDrag: false,\n    }; }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        this.memoMap = new Map();\n        this.acceptedMemoIds = new Map();\n        this.centerSegmentIndexInfo = {\n            segmentIndex: null,\n            hasSegmentIndex: false,\n            hasPreviewIndex: false,\n            changedIndices: [],\n        };\n    }\n    _historyRedoHandler(evt) {\n        const { id, operationType } = evt.detail;\n        if (operationType !== 'labelmap') {\n            return;\n        }\n        if (this.acceptedMemoIds.has(id)) {\n            this._hoverData = null;\n            const memoData = this.acceptedMemoIds.get(id);\n            const element = memoData?.element;\n            const operationData = this.getOperationData(element);\n            operationData.segmentIndex = memoData?.segmentIndex;\n            if (element) {\n                this.applyActiveStrategyCallback(getEnabledElement(element), operationData, StrategyCallbacks.AcceptPreview);\n            }\n        }\n        this._previewData.isDrag = true;\n    }\n    get _previewData() {\n        return LabelmapBaseTool.previewData;\n    }\n    hasPreviewData() {\n        return !!this._previewData.preview;\n    }\n    shouldResolvePreviewRequests() {\n        return ((this.mode === 'Active' || this.mode === 'Enabled') &&\n            this.hasPreviewData());\n    }\n    createMemo(segmentationId, segmentationVoxelManager) {\n        const voxelManagerId = segmentationVoxelManager.id;\n        if (this.memo &&\n            this.memo.segmentationVoxelManager === segmentationVoxelManager) {\n            return this.memo;\n        }\n        let memo = this.memoMap.get(voxelManagerId);\n        if (!memo) {\n            memo = LabelmapMemo.createLabelmapMemo(segmentationId, segmentationVoxelManager);\n            this.memoMap.set(voxelManagerId, memo);\n        }\n        else {\n            if (memo.redoVoxelManager) {\n                memo = LabelmapMemo.createLabelmapMemo(segmentationId, segmentationVoxelManager);\n                this.memoMap.set(voxelManagerId, memo);\n            }\n        }\n        this.memo = memo;\n        return memo;\n    }\n    createEditData(element) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const activeSegmentation = getActiveSegmentation(viewport.id);\n        if (!activeSegmentation) {\n            const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n                detail: {\n                    type: 'Segmentation',\n                    message: 'No active segmentation detected, create a segmentation representation before using the brush tool',\n                },\n                cancelable: true,\n            });\n            eventTarget.dispatchEvent(event);\n            return null;\n        }\n        const { segmentationId } = activeSegmentation;\n        const segmentsLocked = getLockedSegmentIndices(segmentationId);\n        const { representationData } = getSegmentation(segmentationId);\n        const editData = this.getEditData({\n            viewport,\n            representationData,\n            segmentsLocked,\n            segmentationId,\n        });\n        return editData;\n    }\n    getEditData({ viewport, representationData, segmentsLocked, segmentationId, }) {\n        if (viewport instanceof BaseVolumeViewport) {\n            const { volumeId } = representationData[SegmentationRepresentations.Labelmap];\n            const actors = viewport.getActors();\n            const isStackViewport = viewport instanceof StackViewport;\n            if (isStackViewport) {\n                const event = new CustomEvent(Enums.Events.ERROR_EVENT, {\n                    detail: {\n                        type: 'Segmentation',\n                        message: 'Cannot perform brush operation on the selected viewport',\n                    },\n                    cancelable: true,\n                });\n                eventTarget.dispatchEvent(event);\n                return null;\n            }\n            const volumes = actors.map((actorEntry) => cache.getVolume(actorEntry.referencedId));\n            const segmentationVolume = cache.getVolume(volumeId);\n            const referencedVolumeIdToThreshold = volumes.find((volume) => csUtils.isEqual(volume.dimensions, segmentationVolume.dimensions))?.volumeId || volumes[0]?.volumeId;\n            return {\n                volumeId,\n                referencedVolumeId: this.configuration.threshold?.volumeId ??\n                    referencedVolumeIdToThreshold,\n                segmentsLocked,\n            };\n        }\n        else {\n            const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n            if (!segmentationImageId) {\n                return;\n            }\n            return {\n                imageId: segmentationImageId,\n                segmentsLocked,\n            };\n        }\n    }\n    createHoverData(element, centerCanvas) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const camera = viewport.getCamera();\n        const { viewPlaneNormal, viewUp } = camera;\n        const viewportIdsToRender = [viewport.id];\n        const { segmentIndex, segmentationId, segmentColor } = this.getActiveSegmentationData(viewport) || {};\n        const brushCursor = {\n            metadata: {\n                viewPlaneNormal: [...viewPlaneNormal],\n                viewUp: [...viewUp],\n                FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                referencedImageId: '',\n                toolName: this.getToolName(),\n                segmentColor,\n            },\n            data: {},\n        };\n        return {\n            brushCursor,\n            centerCanvas,\n            segmentIndex,\n            viewport,\n            segmentationId,\n            segmentColor,\n            viewportIdsToRender,\n        };\n    }\n    getActiveSegmentationData(viewport) {\n        const viewportId = viewport.id;\n        const activeRepresentation = getActiveSegmentation(viewportId);\n        if (!activeRepresentation) {\n            return;\n        }\n        const { segmentationId } = activeRepresentation;\n        const segmentIndex = getActiveSegmentIndex(segmentationId);\n        if (!segmentIndex) {\n            return;\n        }\n        const segmentColor = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n        return {\n            segmentIndex,\n            segmentationId,\n            segmentColor,\n        };\n    }\n    getOperationData(element) {\n        const editData = this._editData || this.createEditData(element);\n        const { segmentIndex, segmentationId, brushCursor } = this._hoverData || this.createHoverData(element);\n        const { data, metadata = {} } = brushCursor || {};\n        const { viewPlaneNormal, viewUp } = metadata;\n        const configColor = this.configuration.preview?.previewColors?.[segmentIndex];\n        const { viewport } = getEnabledElement(element);\n        const segmentColor = getSegmentIndexColor(viewport.id, segmentationId, segmentIndex);\n        if (!configColor && !segmentColor) {\n            return;\n        }\n        let previewColor = null, previewSegmentIndex = null;\n        if (this.configuration.preview?.enabled) {\n            previewColor = configColor || lightenColor(...segmentColor);\n            previewSegmentIndex = 255;\n        }\n        const operationData = {\n            ...editData,\n            points: data?.handles?.points,\n            segmentIndex,\n            viewPlaneNormal,\n            previewOnHover: !this._previewData.isDrag,\n            toolGroupId: this.toolGroupId,\n            segmentationId,\n            viewUp,\n            centerSegmentIndexInfo: this.centerSegmentIndexInfo,\n            activeStrategy: this.configuration.activeStrategy,\n            configuration: this.configuration,\n            previewColor,\n            previewSegmentIndex,\n            createMemo: this.createMemo.bind(this),\n        };\n        return operationData;\n    }\n    addPreview(element = this._previewData.element, options) {\n        const { _previewData } = this;\n        const acceptReject = options?.acceptReject;\n        if (acceptReject === true) {\n            this.acceptPreview(element);\n        }\n        else if (acceptReject === false) {\n            this.rejectPreview(element);\n        }\n        const enabledElement = getEnabledElement(element);\n        const results = this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.AddPreview);\n        _previewData.isDrag = true;\n        if (results?.modified) {\n            _previewData.preview = results;\n            _previewData.element = element;\n        }\n        return results;\n    }\n    rejectPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        this.doneEditMemo();\n        const enabledElement = getEnabledElement(element);\n        this.applyActiveStrategyCallback(enabledElement, this.getOperationData(element), StrategyCallbacks.RejectPreview);\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    acceptPreview(element = this._previewData.element) {\n        if (!element) {\n            return;\n        }\n        const operationData = this.getOperationData(element);\n        if (this.memo && this.memo.id) {\n            this.acceptedMemoIds.set(this.memo.id, {\n                element,\n                segmentIndex: operationData.segmentIndex,\n            });\n        }\n        const enabledElement = getEnabledElement(element);\n        this.applyActiveStrategyCallback(enabledElement, operationData, StrategyCallbacks.AcceptPreview);\n        this.doneEditMemo();\n        this._previewData.preview = null;\n        this._previewData.isDrag = false;\n    }\n    static viewportContoursToLabelmap(viewport, options) {\n        const removeContours = options?.removeContours ?? true;\n        const annotations = getAllAnnotations();\n        const viewAnnotations = filterAnnotationsForDisplay(viewport, annotations);\n        if (!viewAnnotations?.length) {\n            return;\n        }\n        const contourAnnotations = viewAnnotations.filter((annotation) => annotation.data.contour?.polyline?.length);\n        if (!contourAnnotations.length) {\n            return;\n        }\n        const brushInstance = new LabelmapBaseTool({}, {\n            configuration: {\n                strategies: {\n                    FILL_INSIDE_CIRCLE: fillInsideCircle,\n                },\n                activeStrategy: 'FILL_INSIDE_CIRCLE',\n            },\n        });\n        const preview = brushInstance.addPreview(viewport.element);\n        const { memo, segmentationId } = preview;\n        const previewVoxels = memo?.voxelManager;\n        const segmentationVoxels = previewVoxels.sourceVoxelManager || previewVoxels;\n        const { dimensions } = previewVoxels;\n        const imageData = viewport\n            .getDefaultActor()\n            .actor.getMapper()\n            .getInputData();\n        for (const annotation of contourAnnotations) {\n            const boundsIJK = [\n                [Infinity, -Infinity],\n                [Infinity, -Infinity],\n                [Infinity, -Infinity],\n            ];\n            const { polyline } = annotation.data.contour;\n            for (const point of polyline) {\n                const indexPoint = imageData.worldToIndex(point);\n                indexPoint.forEach((v, idx) => {\n                    boundsIJK[idx][0] = Math.min(boundsIJK[idx][0], v);\n                    boundsIJK[idx][1] = Math.max(boundsIJK[idx][1], v);\n                });\n            }\n            boundsIJK.forEach((bound, idx) => {\n                bound[0] = Math.round(Math.max(0, bound[0]));\n                bound[1] = Math.round(Math.min(dimensions[idx] - 1, bound[1]));\n            });\n            const activeIndex = getActiveSegmentIndex(segmentationId);\n            const startPoint = annotation.data.handles?.[0] || polyline[0];\n            const startIndex = imageData.worldToIndex(startPoint).map(Math.round);\n            const startValue = segmentationVoxels.getAtIJKPoint(startIndex) || 0;\n            let hasZeroIndex = false;\n            let hasPositiveIndex = false;\n            for (const polyPoint of polyline) {\n                const polyIndex = imageData.worldToIndex(polyPoint).map(Math.round);\n                const polyValue = segmentationVoxels.getAtIJKPoint(polyIndex);\n                if (polyValue === startValue) {\n                    hasZeroIndex = true;\n                }\n                else if (polyValue >= 0) {\n                    hasPositiveIndex = true;\n                }\n            }\n            const hasBoth = hasZeroIndex && hasPositiveIndex;\n            const segmentIndex = hasBoth\n                ? startValue\n                : startValue === 0\n                    ? activeIndex\n                    : 0;\n            for (let i = boundsIJK[0][0]; i <= boundsIJK[0][1]; i++) {\n                for (let j = boundsIJK[1][0]; j <= boundsIJK[1][1]; j++) {\n                    for (let k = boundsIJK[2][0]; k <= boundsIJK[2][1]; k++) {\n                        const worldPoint = imageData.indexToWorld([i, j, k]);\n                        const isContained = isPointInsidePolyline3D(worldPoint, polyline);\n                        if (isContained) {\n                            previewVoxels.setAtIJK(i, j, k, segmentIndex);\n                        }\n                    }\n                }\n            }\n            if (removeContours) {\n                removeAnnotation(annotation.annotationUID);\n            }\n        }\n        const slices = previewVoxels.getArrayOfModifiedSlices();\n        triggerSegmentationDataModified(segmentationId, slices);\n    }\n}\nfunction lightenColor(r, g, b, a, factor = 0.4) {\n    return [\n        Math.round(r + (255 - r) * factor),\n        Math.round(g + (255 - g) * factor),\n        Math.round(b + (255 - b) * factor),\n        a,\n    ];\n}\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../../../utilities/boundingBox';\nimport BrushStrategy from './BrushStrategy';\nimport { StrategyCallbacks } from '../../../enums';\nimport compositions from './compositions';\nimport { pointInSphere } from '../../../utilities/math/sphere';\nconst { transformWorldToIndex, transformIndexToWorld, isEqual } = csUtils;\nexport function getEllipseCornersFromCanvasCoordinates(canvasCoordinates) {\n    const [bottom, top, left, right] = canvasCoordinates;\n    const topLeft = [left[0], top[1]];\n    const bottomRight = [right[0], bottom[1]];\n    const bottomLeft = [left[0], bottom[1]];\n    const topRight = [right[0], top[1]];\n    return [topLeft, bottomRight, bottomLeft, topRight];\n}\nfunction createCircleCornersForCenter(center, viewUp, viewRight, radius) {\n    const centerVec = vec3.fromValues(center[0], center[1], center[2]);\n    const top = vec3.create();\n    vec3.scaleAndAdd(top, centerVec, viewUp, radius);\n    const bottom = vec3.create();\n    vec3.scaleAndAdd(bottom, centerVec, viewUp, -radius);\n    const right = vec3.create();\n    vec3.scaleAndAdd(right, centerVec, viewRight, radius);\n    const left = vec3.create();\n    vec3.scaleAndAdd(left, centerVec, viewRight, -radius);\n    return [\n        bottom,\n        top,\n        left,\n        right,\n    ];\n}\nfunction createStrokePredicate(centers, radius) {\n    if (!centers.length || radius <= 0) {\n        return null;\n    }\n    const radiusSquared = radius * radius;\n    const centerVecs = centers.map((point) => [point[0], point[1], point[2]]);\n    const segments = [];\n    for (let i = 1; i < centerVecs.length; i++) {\n        const start = centerVecs[i - 1];\n        const end = centerVecs[i];\n        const dx = end[0] - start[0];\n        const dy = end[1] - start[1];\n        const dz = end[2] - start[2];\n        const lengthSquared = dx * dx + dy * dy + dz * dz;\n        segments.push({ start, vector: [dx, dy, dz], lengthSquared });\n    }\n    return (worldPoint) => {\n        if (!worldPoint) {\n            return false;\n        }\n        for (const centerVec of centerVecs) {\n            const dx = worldPoint[0] - centerVec[0];\n            const dy = worldPoint[1] - centerVec[1];\n            const dz = worldPoint[2] - centerVec[2];\n            if (dx * dx + dy * dy + dz * dz <= radiusSquared) {\n                return true;\n            }\n        }\n        for (const { start, vector, lengthSquared } of segments) {\n            if (lengthSquared === 0) {\n                const dx = worldPoint[0] - start[0];\n                const dy = worldPoint[1] - start[1];\n                const dz = worldPoint[2] - start[2];\n                if (dx * dx + dy * dy + dz * dz <= radiusSquared) {\n                    return true;\n                }\n                continue;\n            }\n            const dx = worldPoint[0] - start[0];\n            const dy = worldPoint[1] - start[1];\n            const dz = worldPoint[2] - start[2];\n            const dot = dx * vector[0] + dy * vector[1] + dz * vector[2];\n            const t = Math.max(0, Math.min(1, dot / lengthSquared));\n            const projX = start[0] + vector[0] * t;\n            const projY = start[1] + vector[1] * t;\n            const projZ = start[2] + vector[2] * t;\n            const distX = worldPoint[0] - projX;\n            const distY = worldPoint[1] - projY;\n            const distZ = worldPoint[2] - projZ;\n            if (distX * distX + distY * distY + distZ * distZ <= radiusSquared) {\n                return true;\n            }\n        }\n        return false;\n    };\n}\nconst initializeCircle = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, viewport, segmentationImageData, viewUp, viewPlaneNormal, } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.create();\n        if (points.length >= 2) {\n            vec3.add(center, points[0], points[1]);\n            vec3.scale(center, center, 0.5);\n        }\n        else {\n            vec3.copy(center, points[0]);\n        }\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const brushRadius = points.length >= 2 ? vec3.distance(points[0], points[1]) / 2 : 0;\n        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n        const corners = getEllipseCornersFromCanvasCoordinates(canvasCoordinates);\n        const cornersInWorld = corners.map((corner) => viewport.canvasToWorld(corner));\n        const normalizedViewUp = vec3.fromValues(viewUp[0], viewUp[1], viewUp[2]);\n        vec3.normalize(normalizedViewUp, normalizedViewUp);\n        const normalizedPlaneNormal = vec3.fromValues(viewPlaneNormal[0], viewPlaneNormal[1], viewPlaneNormal[2]);\n        vec3.normalize(normalizedPlaneNormal, normalizedPlaneNormal);\n        const viewRight = vec3.create();\n        vec3.cross(viewRight, normalizedViewUp, normalizedPlaneNormal);\n        vec3.normalize(viewRight, viewRight);\n        const strokeCentersSource = operationData.strokePointsWorld &&\n            operationData.strokePointsWorld.length > 0\n            ? operationData.strokePointsWorld\n            : [operationData.centerWorld];\n        const strokeCenters = strokeCentersSource.map((point) => vec3.clone(point));\n        const strokeCornersWorld = strokeCenters.flatMap((centerPoint) => createCircleCornersForCenter(centerPoint, normalizedViewUp, viewRight, brushRadius));\n        const circleCornersIJK = strokeCornersWorld.map((world) => transformWorldToIndex(segmentationImageData, world));\n        const boundsIJK = getBoundingBoxAroundShapeIJK(circleCornersIJK, segmentationImageData.getDimensions());\n        operationData.strokePointsWorld = strokeCenters;\n        operationData.isInObject = createPointInEllipse(cornersInWorld, {\n            strokePointsWorld: strokeCenters,\n            segmentationImageData,\n            radius: brushRadius,\n        });\n        operationData.isInObjectBoundsIJK = boundsIJK;\n    },\n};\nfunction createPointInEllipse(cornersInWorld = [], options = {}) {\n    if (!cornersInWorld || cornersInWorld.length !== 4) {\n        throw new Error('createPointInEllipse: cornersInWorld must have 4 points');\n    }\n    const [topLeft, bottomRight, bottomLeft, topRight] = cornersInWorld;\n    const center = vec3.create();\n    vec3.add(center, topLeft, bottomRight);\n    vec3.scale(center, center, 0.5);\n    const majorAxisVec = vec3.create();\n    vec3.subtract(majorAxisVec, topRight, topLeft);\n    const xRadius = vec3.length(majorAxisVec) / 2;\n    vec3.normalize(majorAxisVec, majorAxisVec);\n    const minorAxisVec = vec3.create();\n    vec3.subtract(minorAxisVec, bottomLeft, topLeft);\n    const yRadius = vec3.length(minorAxisVec) / 2;\n    vec3.normalize(minorAxisVec, minorAxisVec);\n    const normal = vec3.create();\n    vec3.cross(normal, majorAxisVec, minorAxisVec);\n    vec3.normalize(normal, normal);\n    const radiusForStroke = options.radius ?? Math.max(xRadius, yRadius);\n    const strokePredicate = createStrokePredicate(options.strokePointsWorld || [], radiusForStroke);\n    if (isEqual(xRadius, yRadius)) {\n        const radius = xRadius;\n        const sphereObj = {\n            center,\n            radius,\n            radius2: radius * radius,\n        };\n        return (pointLPS, pointIJK) => {\n            let worldPoint = pointLPS;\n            if (!worldPoint && pointIJK && options.segmentationImageData) {\n                worldPoint = transformIndexToWorld(options.segmentationImageData, pointIJK);\n            }\n            if (!worldPoint) {\n                return false;\n            }\n            if (strokePredicate?.(worldPoint)) {\n                return true;\n            }\n            return pointInSphere(sphereObj, worldPoint);\n        };\n    }\n    return (pointLPS, pointIJK) => {\n        let worldPoint = pointLPS;\n        if (!worldPoint && pointIJK && options.segmentationImageData) {\n            worldPoint = transformIndexToWorld(options.segmentationImageData, pointIJK);\n        }\n        if (!worldPoint) {\n            return false;\n        }\n        if (strokePredicate?.(worldPoint)) {\n            return true;\n        }\n        const pointVec = vec3.create();\n        vec3.subtract(pointVec, worldPoint, center);\n        const distToPlane = vec3.dot(pointVec, normal);\n        const proj = vec3.create();\n        vec3.scaleAndAdd(proj, pointVec, normal, -distToPlane);\n        const fromTopLeft = vec3.create();\n        const centerToTopLeft = vec3.create();\n        vec3.subtract(centerToTopLeft, center, topLeft);\n        vec3.subtract(fromTopLeft, proj, centerToTopLeft);\n        const x = vec3.dot(fromTopLeft, majorAxisVec);\n        const y = vec3.dot(fromTopLeft, minorAxisVec);\n        return (x * x) / (xRadius * xRadius) + (y * y) / (yRadius * yRadius) <= 1;\n    };\n}\nconst CIRCLE_STRATEGY = new BrushStrategy('Circle', compositions.regionFill, compositions.setValue, initializeCircle, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics);\nconst CIRCLE_THRESHOLD_STRATEGY = new BrushStrategy('CircleThreshold', compositions.regionFill, compositions.setValue, initializeCircle, compositions.determineSegmentIndex, compositions.dynamicThreshold, compositions.threshold, compositions.preview, compositions.islandRemoval, compositions.labelmapStatistics);\nconst fillInsideCircle = CIRCLE_STRATEGY.strategyFunction;\nconst thresholdInsideCircle = CIRCLE_THRESHOLD_STRATEGY.strategyFunction;\nexport function fillOutsideCircle() {\n    throw new Error('Not yet implemented');\n}\nexport { CIRCLE_STRATEGY, CIRCLE_THRESHOLD_STRATEGY, fillInsideCircle, thresholdInsideCircle, createPointInEllipse, createPointInEllipse as createEllipseInPoint, };\n","import { vec3 } from 'gl-matrix';\nimport { utilities as csUtils, StackViewport } from '@cornerstonejs/core';\nimport { getBoundingBoxAroundShapeIJK } from '../../../utilities/boundingBox';\nimport BrushStrategy from './BrushStrategy';\nimport { StrategyCallbacks } from '../../../enums';\nimport compositions from './compositions';\nconst { transformWorldToIndex } = csUtils;\nconst initializeRectangle = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, viewport, segmentationImageData, } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.fromValues(0, 0, 0);\n        points.forEach((point) => {\n            vec3.add(center, center, point);\n        });\n        vec3.scale(center, center, 1 / points.length);\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const { boundsIJK, pointInShapeFn } = createPointInRectangle(viewport, points, segmentationImageData);\n        operationData.isInObject = pointInShapeFn;\n        operationData.isInObjectBoundsIJK = boundsIJK;\n    },\n};\nfunction createPointInRectangle(viewport, points, segmentationImageData) {\n    let rectangleCornersIJK = points.map((world) => {\n        return transformWorldToIndex(segmentationImageData, world);\n    });\n    rectangleCornersIJK = rectangleCornersIJK.map((point) => {\n        return point.map((coord) => {\n            return Math.round(coord);\n        });\n    });\n    const boundsIJK = getBoundingBoxAroundShapeIJK(rectangleCornersIJK, segmentationImageData.getDimensions());\n    const [p0, p1, p2, p3] = points;\n    const axisU = vec3.create();\n    const axisV = vec3.create();\n    vec3.subtract(axisU, p1, p0);\n    vec3.subtract(axisV, p3, p0);\n    const uLen = vec3.length(axisU);\n    const vLen = vec3.length(axisV);\n    vec3.normalize(axisU, axisU);\n    vec3.normalize(axisV, axisV);\n    const normal = vec3.create();\n    vec3.cross(normal, axisU, axisV);\n    vec3.normalize(normal, normal);\n    const direction = segmentationImageData.getDirection();\n    const spacing = segmentationImageData.getSpacing();\n    const { viewPlaneNormal } = viewport.getCamera();\n    const EPS = csUtils.getSpacingInNormalDirection({\n        direction,\n        spacing,\n    }, viewPlaneNormal);\n    const pointInShapeFn = (pointLPS) => {\n        const v = vec3.create();\n        vec3.subtract(v, pointLPS, p0);\n        const u = vec3.dot(v, axisU);\n        const vproj = vec3.dot(v, axisV);\n        const d = Math.abs(vec3.dot(v, normal));\n        return (u >= -EPS &&\n            u <= uLen + EPS &&\n            vproj >= -EPS &&\n            vproj <= vLen + EPS &&\n            d <= EPS);\n    };\n    return { boundsIJK, pointInShapeFn };\n}\nconst RECTANGLE_STRATEGY = new BrushStrategy('Rectangle', compositions.regionFill, compositions.setValue, initializeRectangle, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics);\nconst RECTANGLE_THRESHOLD_STRATEGY = new BrushStrategy('RectangleThreshold', compositions.regionFill, compositions.setValue, initializeRectangle, compositions.determineSegmentIndex, compositions.dynamicThreshold, compositions.threshold, compositions.preview, compositions.islandRemoval, compositions.labelmapStatistics);\nconst fillInsideRectangle = RECTANGLE_STRATEGY.strategyFunction;\nconst thresholdInsideRectangle = RECTANGLE_THRESHOLD_STRATEGY.strategyFunction;\nexport { RECTANGLE_STRATEGY, RECTANGLE_THRESHOLD_STRATEGY, fillInsideRectangle, thresholdInsideRectangle, };\n","import { utilities, BaseVolumeViewport, StackViewport, cache, metaData, } from '@cornerstonejs/core';\nimport { addAnnotation } from '../stateManagement/annotation/annotationState';\nimport { vec3 } from 'gl-matrix';\nfunction annotationHydration(viewport, toolName, worldPoints, options) {\n    const viewReference = viewport.getViewReference();\n    const { viewPlaneNormal, FrameOfReferenceUID } = viewReference;\n    const annotation = {\n        annotationUID: options?.annotationUID || utilities.uuidv4(),\n        data: {\n            handles: {\n                points: worldPoints,\n            },\n        },\n        highlighted: false,\n        autoGenerated: false,\n        invalidated: false,\n        isLocked: false,\n        isVisible: true,\n        metadata: {\n            toolName,\n            viewPlaneNormal,\n            FrameOfReferenceUID,\n            referencedImageId: getReferencedImageId(viewport, worldPoints[0], viewPlaneNormal),\n            ...options,\n        },\n    };\n    addAnnotation(annotation, viewport.element);\n    return annotation;\n}\nfunction getReferencedImageId(viewport, worldPos, viewPlaneNormal) {\n    let referencedImageId;\n    if (viewport instanceof StackViewport) {\n        referencedImageId = getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal);\n    }\n    else if (viewport instanceof BaseVolumeViewport) {\n        const targetId = getTargetId(viewport);\n        const volumeId = utilities.getVolumeId(targetId);\n        const imageVolume = cache.getVolume(volumeId);\n        referencedImageId = utilities.getClosestImageId(imageVolume, worldPos, viewPlaneNormal);\n    }\n    else {\n        throw new Error('getReferencedImageId: viewport must be a StackViewport or BaseVolumeViewport');\n    }\n    return referencedImageId;\n}\nfunction getTargetId(viewport) {\n    const targetId = viewport.getViewReferenceId?.();\n    if (targetId) {\n        return targetId;\n    }\n    if (viewport instanceof BaseVolumeViewport) {\n        return `volumeId:${getTargetVolumeId(viewport)}`;\n    }\n    throw new Error('getTargetId: viewport must have a getTargetId method');\n}\nfunction getTargetVolumeId(viewport) {\n    const actorEntries = viewport.getActors();\n    if (!actorEntries) {\n        return;\n    }\n    return actorEntries.find((actorEntry) => actorEntry.actor.getClassName() === 'vtkVolume')?.uid;\n}\nfunction getClosestImageIdForStackViewport(viewport, worldPos, viewPlaneNormal) {\n    const imageIds = viewport.getImageIds();\n    if (!imageIds || !imageIds.length) {\n        return;\n    }\n    const distanceImagePairs = imageIds.map((imageId) => {\n        const { imagePositionPatient } = metaData.get('imagePlaneModule', imageId);\n        const distance = calculateDistanceToImage(worldPos, imagePositionPatient, viewPlaneNormal);\n        return { imageId, distance };\n    });\n    distanceImagePairs.sort((a, b) => a.distance - b.distance);\n    return distanceImagePairs[0].imageId;\n}\nfunction calculateDistanceToImage(worldPos, ImagePositionPatient, viewPlaneNormal) {\n    const dir = vec3.create();\n    vec3.sub(dir, worldPos, ImagePositionPatient);\n    const dot = vec3.dot(dir, viewPlaneNormal);\n    return Math.abs(dot);\n}\nexport { annotationHydration, getClosestImageIdForStackViewport };\n","function extend2DBoundingBoxInViewAxis(boundsIJK, numSlicesToProject) {\n    const sliceNormalIndex = boundsIJK.findIndex(([min, max]) => min === max);\n    if (sliceNormalIndex === -1) {\n        throw new Error('3D bounding boxes not supported in an oblique plane');\n    }\n    boundsIJK[sliceNormalIndex][0] -= numSlicesToProject;\n    boundsIJK[sliceNormalIndex][1] += numSlicesToProject;\n    return boundsIJK;\n}\nexport default extend2DBoundingBoxInViewAxis;\n","import { CONSTANTS } from '@cornerstonejs/core';\nconst { EPSILON } = CONSTANTS;\nfunction calculateBoundingBox(points, dimensions, isWorld = false) {\n    let xMin = Infinity;\n    let xMax = isWorld ? -Infinity : 0;\n    let yMin = Infinity;\n    let yMax = isWorld ? -Infinity : 0;\n    let zMin = Infinity;\n    let zMax = isWorld ? -Infinity : 0;\n    const is3D = points[0]?.length === 3;\n    for (let i = 0; i < points.length; i++) {\n        const p = points[i];\n        xMin = Math.min(p[0], xMin);\n        xMax = Math.max(p[0], xMax);\n        yMin = Math.min(p[1], yMin);\n        yMax = Math.max(p[1], yMax);\n        if (is3D) {\n            zMin = Math.min(p[2] ?? zMin, zMin);\n            zMax = Math.max(p[2] ?? zMax, zMax);\n        }\n    }\n    if (dimensions) {\n        xMin = Math.max(isWorld ? dimensions[0] + EPSILON : 0, xMin);\n        xMax = Math.min(isWorld ? dimensions[0] - EPSILON : dimensions[0] - 1, xMax);\n        yMin = Math.max(isWorld ? dimensions[1] + EPSILON : 0, yMin);\n        yMax = Math.min(isWorld ? dimensions[1] - EPSILON : dimensions[1] - 1, yMax);\n        if (is3D && dimensions.length === 3) {\n            zMin = Math.max(isWorld ? dimensions[2] + EPSILON : 0, zMin);\n            zMax = Math.min(isWorld ? dimensions[2] - EPSILON : dimensions[2] - 1, zMax);\n        }\n    }\n    else if (!isWorld) {\n        xMin = Math.max(0, xMin);\n        xMax = Math.min(Infinity, xMax);\n        yMin = Math.max(0, yMin);\n        yMax = Math.min(Infinity, yMax);\n        if (is3D) {\n            zMin = Math.max(0, zMin);\n            zMax = Math.min(Infinity, zMax);\n        }\n    }\n    return is3D\n        ? [\n            [xMin, xMax],\n            [yMin, yMax],\n            [zMin, zMax],\n        ]\n        : [[xMin, xMax], [yMin, yMax], null];\n}\nexport function getBoundingBoxAroundShapeIJK(points, dimensions) {\n    return calculateBoundingBox(points, dimensions, false);\n}\nexport function getBoundingBoxAroundShapeWorld(points, clipBounds) {\n    return calculateBoundingBox(points, clipBounds, true);\n}\n","import { utilities } from '@cornerstonejs/core';\nimport { addAnnotation, removeAnnotation } from '../../stateManagement';\nimport { removeContourSegmentationAnnotation } from './removeContourSegmentationAnnotation';\nimport { addContourSegmentationAnnotation } from './addContourSegmentationAnnotation';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nconst DEFAULT_CONTOUR_SEG_TOOL_NAME = 'PlanarFreehandContourSegmentationTool';\nexport default function convertContourSegmentationAnnotation(annotation) {\n    const { polyline } = annotation.data?.contour || {};\n    if (!polyline || polyline.length < 3) {\n        console.warn('Skipping creation of new annotation due to invalid polyline:', polyline);\n        return;\n    }\n    removeAnnotation(annotation.annotationUID);\n    removeContourSegmentationAnnotation(annotation);\n    const startPointWorld = polyline[0];\n    const endPointWorld = polyline[polyline.length - 1];\n    const newAnnotation = {\n        metadata: {\n            ...annotation.metadata,\n            toolName: DEFAULT_CONTOUR_SEG_TOOL_NAME,\n            originalToolName: annotation.metadata.originalToolName || annotation.metadata.toolName,\n        },\n        data: {\n            cachedStats: {},\n            handles: {\n                points: [startPointWorld, endPointWorld],\n                textBox: annotation.data.handles.textBox\n                    ? { ...annotation.data.handles.textBox }\n                    : undefined,\n            },\n            contour: {\n                ...annotation.data.contour,\n            },\n            spline: annotation.data.spline,\n            segmentation: {\n                ...annotation.data.segmentation,\n            },\n        },\n        annotationUID: utilities.uuidv4(),\n        highlighted: true,\n        invalidated: true,\n        isLocked: false,\n        isVisible: undefined,\n        interpolationUID: annotation.interpolationUID,\n        interpolationCompleted: annotation.interpolationCompleted,\n    };\n    addAnnotation(newAnnotation, annotation.metadata.FrameOfReferenceUID);\n    addContourSegmentationAnnotation(newAnnotation);\n    triggerAnnotationModified(newAnnotation);\n    return newAnnotation;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nconst { isEqual } = csUtils;\nexport default function findHandlePolylineIndex(annotation, handleIndex) {\n    const { polyline } = annotation.data.contour;\n    const { points } = annotation.data.handles;\n    const { length } = points;\n    if (handleIndex === length) {\n        return polyline.length;\n    }\n    if (handleIndex < 0) {\n        handleIndex = (handleIndex + length) % length;\n    }\n    if (handleIndex === 0) {\n        return 0;\n    }\n    const handle = points[handleIndex];\n    const index = polyline.findIndex((point) => isEqual(handle, point));\n    if (index !== -1) {\n        return index;\n    }\n    let closestDistance = Infinity;\n    return polyline.reduce((closestIndex, point, testIndex) => {\n        const distance = vec3.squaredDistance(point, handle);\n        if (distance < closestDistance) {\n            closestDistance = distance;\n            return testIndex;\n        }\n        return closestIndex;\n    }, -1);\n}\n","import isObject from './isObject';\nfunction debounce(func, wait, options) {\n    let lastArgs, lastThis, maxWait, result, timerId, lastCallTime;\n    let lastInvokeTime = 0;\n    let leading = false;\n    let maxing = false;\n    let trailing = true;\n    const useRAF = !wait && wait !== 0 && typeof window.requestAnimationFrame === 'function';\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n    wait = Number(wait) || 0;\n    if (isObject(options)) {\n        leading = Boolean(options.leading);\n        maxing = 'maxWait' in options;\n        maxWait = maxing ? Math.max(Number(options.maxWait) || 0, wait) : maxWait;\n        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n    }\n    function invokeFunc(time) {\n        const args = lastArgs;\n        const thisArg = lastThis;\n        lastArgs = lastThis = undefined;\n        lastInvokeTime = time;\n        result = func.apply(thisArg, args);\n        return result;\n    }\n    function startTimer(pendingFunc, wait) {\n        if (useRAF) {\n            return window.requestAnimationFrame(pendingFunc);\n        }\n        return setTimeout(pendingFunc, wait);\n    }\n    function cancelTimer(id) {\n        if (useRAF) {\n            return window.cancelAnimationFrame(id);\n        }\n        clearTimeout(id);\n    }\n    function leadingEdge(time) {\n        lastInvokeTime = time;\n        timerId = startTimer(timerExpired, wait);\n        return leading ? invokeFunc(time) : result;\n    }\n    function remainingWait(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        const timeWaiting = wait - timeSinceLastCall;\n        return maxing\n            ? Math.min(timeWaiting, maxWait - timeSinceLastInvoke)\n            : timeWaiting;\n    }\n    function shouldInvoke(time) {\n        const timeSinceLastCall = time - lastCallTime;\n        const timeSinceLastInvoke = time - lastInvokeTime;\n        return (lastCallTime === undefined ||\n            timeSinceLastCall >= wait ||\n            timeSinceLastCall < 0 ||\n            (maxing && timeSinceLastInvoke >= maxWait));\n    }\n    function timerExpired() {\n        const time = Date.now();\n        if (shouldInvoke(time)) {\n            return trailingEdge(time);\n        }\n        timerId = startTimer(timerExpired, remainingWait(time));\n    }\n    function trailingEdge(time) {\n        timerId = undefined;\n        if (trailing && lastArgs) {\n            return invokeFunc(time);\n        }\n        lastArgs = lastThis = undefined;\n        return result;\n    }\n    function cancel() {\n        if (timerId !== undefined) {\n            cancelTimer(timerId);\n        }\n        lastInvokeTime = 0;\n        lastArgs = lastCallTime = lastThis = timerId = undefined;\n    }\n    function flush() {\n        return timerId === undefined ? result : trailingEdge(Date.now());\n    }\n    function pending() {\n        return timerId !== undefined;\n    }\n    function debounced(...args) {\n        const time = Date.now();\n        const isInvoking = shouldInvoke(time);\n        lastArgs = args;\n        lastThis = this;\n        lastCallTime = time;\n        if (isInvoking) {\n            if (timerId === undefined) {\n                return leadingEdge(lastCallTime);\n            }\n            if (maxing) {\n                timerId = startTimer(timerExpired, wait);\n                return invokeFunc(lastCallTime);\n            }\n        }\n        if (timerId === undefined) {\n            timerId = startTimer(timerExpired, wait);\n        }\n        return result;\n    }\n    debounced.cancel = cancel;\n    debounced.flush = flush;\n    debounced.pending = pending;\n    return debounced;\n}\nexport default debounce;\n","export default function getTextBoxCoordsCanvas(annotationCanvasPoints) {\n    const corners = _determineCorners(annotationCanvasPoints);\n    const centerY = (corners.top[1] + corners.bottom[1]) / 2;\n    const textBoxCanvas = [corners.right[0], centerY];\n    return textBoxCanvas;\n}\nfunction _determineCorners(canvasPoints) {\n    const handlesLeftToRight = [canvasPoints[0], canvasPoints[1]].sort(_compareX);\n    const handlesTopToBottom = [canvasPoints[0], canvasPoints[1]].sort(_compareY);\n    const right = handlesLeftToRight[handlesLeftToRight.length - 1];\n    const top = handlesTopToBottom[0];\n    const bottom = handlesTopToBottom[handlesTopToBottom.length - 1];\n    return {\n        top,\n        bottom,\n        right,\n    };\n    function _compareX(a, b) {\n        return a[0] < b[0] ? -1 : 1;\n    }\n    function _compareY(a, b) {\n        return a[1] < b[1] ? -1 : 1;\n    }\n}\n","import { Enums, utilities } from '@cornerstonejs/core';\nconst { CalibrationTypes } = Enums;\nconst PIXEL_UNITS = 'px';\nconst VOXEL_UNITS = 'voxels';\nconst SUPPORTED_REGION_DATA_TYPES = [\n    1,\n    2,\n    3,\n    4,\n];\nconst SUPPORTED_LENGTH_VARIANT = [\n    '3,3',\n    '4,7',\n];\nconst SUPPORTED_PROBE_VARIANT = [\n    '4,3',\n    '4,7',\n];\nconst UNIT_MAPPING = {\n    0: 'px',\n    1: 'percent',\n    2: 'dB',\n    3: 'cm',\n    4: 'seconds',\n    5: 'hertz',\n    6: 'dB/seconds',\n    7: 'cm/sec',\n    8: 'cm\\xb2',\n    9: 'cm\\xb2/s',\n    0xc: 'degrees',\n};\nconst EPS = 1e-3;\nconst SQUARE = '\\xb2';\nconst getCalibratedLengthUnitsAndScale = (image, handles) => {\n    const { calibration, hasPixelSpacing } = image;\n    let unit = hasPixelSpacing ? 'mm' : PIXEL_UNITS;\n    const volumeUnit = hasPixelSpacing ? 'mm\\xb3' : VOXEL_UNITS;\n    let areaUnit = unit + SQUARE;\n    let scale = 1;\n    let calibrationType = '';\n    if (!calibration ||\n        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {\n        return { unit, areaUnit, scale, volumeUnit };\n    }\n    if (calibration.type === CalibrationTypes.UNCALIBRATED) {\n        return {\n            unit: PIXEL_UNITS,\n            areaUnit: PIXEL_UNITS + SQUARE,\n            scale,\n            volumeUnit: VOXEL_UNITS,\n        };\n    }\n    if (calibration.sequenceOfUltrasoundRegions) {\n        let imageIndex1, imageIndex2;\n        if (Array.isArray(handles) && handles.length === 2) {\n            [imageIndex1, imageIndex2] = handles;\n        }\n        else if (typeof handles === 'function') {\n            const points = handles();\n            imageIndex1 = points[0];\n            imageIndex2 = points[1];\n        }\n        let regions = calibration.sequenceOfUltrasoundRegions.filter((region) => imageIndex1[0] >= region.regionLocationMinX0 &&\n            imageIndex1[0] <= region.regionLocationMaxX1 &&\n            imageIndex1[1] >= region.regionLocationMinY0 &&\n            imageIndex1[1] <= region.regionLocationMaxY1 &&\n            imageIndex2[0] >= region.regionLocationMinX0 &&\n            imageIndex2[0] <= region.regionLocationMaxX1 &&\n            imageIndex2[1] >= region.regionLocationMinY0 &&\n            imageIndex2[1] <= region.regionLocationMaxY1);\n        if (!regions?.length) {\n            return { unit, areaUnit, scale, volumeUnit };\n        }\n        regions = regions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n            SUPPORTED_LENGTH_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));\n        if (!regions.length) {\n            return {\n                unit: PIXEL_UNITS,\n                areaUnit: PIXEL_UNITS + SQUARE,\n                scale,\n                volumeUnit: VOXEL_UNITS,\n            };\n        }\n        const region = regions[0];\n        const physicalDeltaX = Math.abs(region.physicalDeltaX);\n        const physicalDeltaY = Math.abs(region.physicalDeltaY);\n        const isSamePhysicalDelta = utilities.isEqual(physicalDeltaX, physicalDeltaY, EPS);\n        if (isSamePhysicalDelta) {\n            scale = 1 / physicalDeltaX;\n            calibrationType = 'US Region';\n            unit = UNIT_MAPPING[region.physicalUnitsXDirection] || 'unknown';\n            areaUnit = unit + SQUARE;\n        }\n        else {\n            return {\n                unit: PIXEL_UNITS,\n                areaUnit: PIXEL_UNITS + SQUARE,\n                scale,\n                volumeUnit: VOXEL_UNITS,\n            };\n        }\n    }\n    else if (calibration.scale) {\n        scale = calibration.scale;\n    }\n    const types = [\n        CalibrationTypes.ERMF,\n        CalibrationTypes.USER,\n        CalibrationTypes.ERROR,\n        CalibrationTypes.PROJECTION,\n        CalibrationTypes.CALIBRATED,\n        CalibrationTypes.UNKNOWN,\n    ];\n    if (types.includes(calibration?.type)) {\n        calibrationType = calibration.type;\n    }\n    return {\n        unit: unit + (calibrationType ? ` ${calibrationType}` : ''),\n        areaUnit: areaUnit + (calibrationType ? ` ${calibrationType}` : ''),\n        scale,\n        volumeUnit: volumeUnit + (calibrationType ? ` ${calibrationType}` : ''),\n    };\n};\nconst getCalibratedProbeUnitsAndValue = (image, handles) => {\n    const [imageIndex] = handles;\n    const { calibration } = image;\n    let units = ['raw'];\n    let values = [null];\n    let calibrationType = '';\n    if (!calibration ||\n        (!calibration.type && !calibration.sequenceOfUltrasoundRegions)) {\n        return { units, values };\n    }\n    if (calibration.sequenceOfUltrasoundRegions) {\n        const supportedRegionsMetadata = calibration.sequenceOfUltrasoundRegions.filter((region) => SUPPORTED_REGION_DATA_TYPES.includes(region.regionDataType) &&\n            SUPPORTED_PROBE_VARIANT.includes(`${region.physicalUnitsXDirection},${region.physicalUnitsYDirection}`));\n        if (!supportedRegionsMetadata?.length) {\n            return { units, values };\n        }\n        const region = supportedRegionsMetadata.find((region) => imageIndex[0] >= region.regionLocationMinX0 &&\n            imageIndex[0] <= region.regionLocationMaxX1 &&\n            imageIndex[1] >= region.regionLocationMinY0 &&\n            imageIndex[1] <= region.regionLocationMaxY1);\n        if (!region) {\n            return { units, values };\n        }\n        const { referencePixelX0 = 0, referencePixelY0 = 0 } = region;\n        const { physicalDeltaX, physicalDeltaY } = region;\n        const yValue = (imageIndex[1] - region.regionLocationMinY0 - referencePixelY0) *\n            physicalDeltaY;\n        const xValue = (imageIndex[0] - region.regionLocationMinX0 - referencePixelX0) *\n            physicalDeltaX;\n        calibrationType = 'US Region';\n        values = [xValue, yValue];\n        units = [\n            UNIT_MAPPING[region.physicalUnitsXDirection],\n            UNIT_MAPPING[region.physicalUnitsYDirection],\n        ];\n    }\n    return {\n        units,\n        values,\n        calibrationType,\n    };\n};\nconst getCalibratedAspect = (image) => image.calibration?.aspect || 1;\nexport { getCalibratedLengthUnitsAndScale, getCalibratedAspect, getCalibratedProbeUnitsAndValue, };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport { getBoundingBoxAroundShapeIJK } from './boundingBox';\nconst { transformWorldToIndex } = csUtils;\nfunction _getSphereBoundsInfo(circlePoints, imageData, directionVectors) {\n    const [bottom, top] = circlePoints;\n    const centerWorld = vec3.fromValues((bottom[0] + top[0]) / 2, (bottom[1] + top[1]) / 2, (bottom[2] + top[2]) / 2);\n    const radiusWorld = vec3.distance(bottom, top) / 2;\n    const { boundsIJK, topLeftWorld, bottomRightWorld } = _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld);\n    return {\n        boundsIJK,\n        centerWorld: centerWorld,\n        radiusWorld,\n        topLeftWorld: topLeftWorld,\n        bottomRightWorld: bottomRightWorld,\n    };\n}\nfunction getSphereBoundsInfo(circlePoints, imageData) {\n    const direction = imageData.getDirection();\n    const rowCosine = vec3.fromValues(direction[0], direction[1], direction[2]);\n    const columnCosine = vec3.fromValues(direction[3], direction[4], direction[5]);\n    const scanAxis = vec3.fromValues(direction[6], direction[7], direction[8]);\n    const viewPlaneNormal = vec3.negate(vec3.create(), scanAxis);\n    const directionVectors = {\n        row: rowCosine,\n        column: columnCosine,\n        normal: viewPlaneNormal,\n    };\n    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);\n}\nfunction getSphereBoundsInfoFromViewport(circlePoints, imageData, viewport) {\n    if (!viewport) {\n        throw new Error('viewport is required in order to calculate the sphere bounds');\n    }\n    const camera = viewport.getCamera();\n    const viewUp = vec3.fromValues(camera.viewUp[0], camera.viewUp[1], camera.viewUp[2]);\n    const viewPlaneNormal = vec3.fromValues(camera.viewPlaneNormal[0], camera.viewPlaneNormal[1], camera.viewPlaneNormal[2]);\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const directionVectors = {\n        row: viewRight,\n        normal: viewPlaneNormal,\n        column: vec3.negate(vec3.create(), viewUp),\n    };\n    return _getSphereBoundsInfo(circlePoints, imageData, directionVectors);\n}\nfunction _computeBoundsIJK(imageData, directionVectors, circlePoints, centerWorld, radiusWorld) {\n    const dimensions = imageData.getDimensions();\n    const { row: rowCosine, column: columnCosine, normal: vecNormal, } = directionVectors;\n    const topLeftWorld = vec3.create();\n    const bottomRightWorld = vec3.create();\n    vec3.scaleAndAdd(topLeftWorld, centerWorld, vecNormal, radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, centerWorld, vecNormal, -radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, columnCosine, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, columnCosine, radiusWorld);\n    vec3.scaleAndAdd(topLeftWorld, topLeftWorld, rowCosine, -radiusWorld);\n    vec3.scaleAndAdd(bottomRightWorld, bottomRightWorld, rowCosine, radiusWorld);\n    const topLeftIJK = transformWorldToIndex(imageData, topLeftWorld);\n    const bottomRightIJK = transformWorldToIndex(imageData, bottomRightWorld);\n    const pointsIJK = circlePoints.map((p) => transformWorldToIndex(imageData, p));\n    const boundsIJK = getBoundingBoxAroundShapeIJK([topLeftIJK, bottomRightIJK, ...pointsIJK], dimensions);\n    return { boundsIJK, topLeftWorld, bottomRightWorld };\n}\nexport { getSphereBoundsInfo, getSphereBoundsInfoFromViewport };\n","import getViewportsForAnnotation from './getViewportsForAnnotation';\nexport default function getViewportForAnnotation(annotation) {\n    const viewports = getViewportsForAnnotation(annotation);\n    if (!viewports?.length) {\n        return undefined;\n    }\n    const viewport = viewports.find((viewport) => viewport\n        .getImageIds()\n        .some((imageId) => imageId === annotation.metadata.referencedImageId));\n    return viewport ?? viewports[0];\n}\n","function isObject(value) {\n    const type = typeof value;\n    return value !== null && (type === 'object' || type === 'function');\n}\nexport default isObject;\n","export default function pointInSphere(sphere, pointLPS) {\n    const { center, radius } = sphere;\n    const radius2 = sphere.radius2 || radius * radius;\n    return ((pointLPS[0] - center[0]) * (pointLPS[0] - center[0]) +\n        (pointLPS[1] - center[1]) * (pointLPS[1] - center[1]) +\n        (pointLPS[2] - center[2]) * (pointLPS[2] - center[2]) <=\n        radius2);\n}\n","import { InstanceVolumetricCalculator } from './VolumetricCalculator';\nexport default class SegmentStatsCalculator {\n    static { this.calculators = new Map(); }\n    static { this.indices = []; }\n    static { this.mode = 'collective'; }\n    static statsInit(options) {\n        const { storePointData, indices, mode } = options;\n        this.mode = mode;\n        this.indices = indices;\n        this.calculators.clear();\n        if (this.mode === 'individual') {\n            indices.forEach((index) => {\n                this.calculators.set(index, new InstanceVolumetricCalculator({ storePointData }));\n            });\n        }\n        else {\n            this.calculators.set(indices, new InstanceVolumetricCalculator({ storePointData }));\n        }\n    }\n    static statsCallback(data) {\n        const { segmentIndex, ...statsData } = data;\n        if (!segmentIndex) {\n            throw new Error('Segment index is required for stats calculation');\n        }\n        const calculator = this.mode === 'individual'\n            ? this.calculators.get(segmentIndex)\n            : this.calculators.get(this.indices);\n        if (!calculator) {\n            throw new Error(`No calculator found for segment ${segmentIndex}`);\n        }\n        calculator.statsCallback(statsData);\n    }\n    static getStatistics(options) {\n        if (this.mode === 'individual') {\n            const result = {};\n            this.calculators.forEach((calculator, segmentIndex) => {\n                result[segmentIndex] = calculator.getStatistics(options);\n            });\n            return result;\n        }\n        const calculator = this.calculators.get(this.indices);\n        return calculator.getStatistics(options);\n    }\n}\n","function floodFill(getter, seed, options = {}) {\n    const onFlood = options.onFlood;\n    const onBoundary = options.onBoundary;\n    const equals = options.equals;\n    const filter = options.filter;\n    const diagonals = options.diagonals || false;\n    const startNode = get(seed);\n    const permutations = prunedPermutations();\n    const stack = [];\n    const flooded = [];\n    const visits = new Set();\n    const bounds = options.bounds;\n    stack.push({ currentArgs: seed });\n    while (stack.length > 0) {\n        flood(stack.pop());\n    }\n    return {\n        flooded,\n    };\n    function flood(job) {\n        const getArgs = job.currentArgs;\n        const prevArgs = job.previousArgs;\n        if (visited(getArgs)) {\n            return;\n        }\n        markAsVisited(getArgs);\n        if (member(getArgs)) {\n            markAsFlooded(getArgs);\n            pushAdjacent(getArgs);\n        }\n        else {\n            markAsBoundary(prevArgs);\n        }\n    }\n    function visited(key) {\n        const [x, y, z = 0] = key;\n        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n        return visits.has(iKey);\n    }\n    function markAsVisited(key) {\n        const [x, y, z = 0] = key;\n        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n        visits.add(iKey);\n    }\n    function member(getArgs) {\n        const node = get(getArgs);\n        return equals ? equals(node, startNode) : node === startNode;\n    }\n    function markAsFlooded(getArgs) {\n        flooded.push(getArgs);\n        if (onFlood) {\n            onFlood(...getArgs);\n        }\n    }\n    function markAsBoundary(prevArgs) {\n        const [x, y, z = 0] = prevArgs;\n        const iKey = x + 32768 + 65536 * (y + 32768 + 65536 * (z + 32768));\n        bounds?.set(iKey, prevArgs);\n        if (onBoundary) {\n            onBoundary(...prevArgs);\n        }\n    }\n    function pushAdjacent(getArgs) {\n        for (let i = 0; i < permutations.length; i += 1) {\n            const perm = permutations[i];\n            const nextArgs = getArgs.slice(0);\n            for (let j = 0; j < getArgs.length; j += 1) {\n                nextArgs[j] += perm[j];\n            }\n            if (filter?.(nextArgs) === false) {\n                continue;\n            }\n            if (visited(nextArgs)) {\n                continue;\n            }\n            stack.push({\n                currentArgs: nextArgs,\n                previousArgs: getArgs,\n            });\n        }\n    }\n    function get(getArgs) {\n        return getter(...getArgs);\n    }\n    function prunedPermutations() {\n        const permutations = permute(seed.length);\n        return permutations.filter(function (perm) {\n            const count = countNonZeroes(perm);\n            return count !== 0 && (count === 1 || diagonals);\n        });\n    }\n    function permute(length) {\n        const perms = [];\n        const permutation = function (string) {\n            return string.split('').map(function (c) {\n                return parseInt(c, 10) - 1;\n            });\n        };\n        for (let i = 0; i < Math.pow(3, length); i += 1) {\n            const string = lpad(i.toString(3), '0', length);\n            perms.push(permutation(string));\n        }\n        return perms;\n    }\n}\nfunction countNonZeroes(array) {\n    let count = 0;\n    for (let i = 0; i < array.length; i += 1) {\n        if (array[i] !== 0) {\n            count += 1;\n        }\n    }\n    return count;\n}\nfunction lpad(string, character, length) {\n    const array = new Array(length + 1);\n    const pad = array.join(character);\n    return (pad + string).slice(-length);\n}\nexport default floodFill;\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport BrushTool from '../../tools/segmentation/BrushTool';\nexport function getBrushToolInstances(toolGroupId, toolName) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return [];\n    }\n    const toolInstances = toolGroup._toolInstances;\n    if (!Object.keys(toolInstances).length) {\n        return [];\n    }\n    if (toolName && toolInstances[toolName]) {\n        return [toolInstances[toolName]];\n    }\n    const brushBasedToolInstances = Object.values(toolInstances).filter((toolInstance) => toolInstance instanceof BrushTool);\n    return brushBasedToolInstances;\n}\n","import { getAnnotation } from '../../stateManagement';\nimport { getSegmentation } from '../../stateManagement/segmentation/segmentationState';\nexport function getHoveredContourSegmentationAnnotation(segmentationId) {\n    const segmentation = getSegmentation(segmentationId);\n    const { annotationUIDsMap } = segmentation.representationData.Contour;\n    for (const [segmentIndex, annotationUIDs] of annotationUIDsMap.entries()) {\n        const highlightedAnnotationUID = Array.from(annotationUIDs).find((annotationUID) => getAnnotation(annotationUID).highlighted);\n        if (highlightedAnnotationUID) {\n            return segmentIndex;\n        }\n    }\n    return undefined;\n}\n","import { BaseVolumeViewport, cache, utilities } from '@cornerstonejs/core';\nimport { getSegmentation, getCurrentLabelmapImageIdForViewport, } from '../../stateManagement/segmentation/segmentationState';\nimport { getLabelmapActorEntry } from '../../stateManagement/segmentation/helpers';\nexport function getSegmentIndexAtLabelmapBorder(segmentationId, worldPoint, { viewport, searchRadius }) {\n    const segmentation = getSegmentation(segmentationId);\n    const labelmapData = segmentation.representationData.Labelmap;\n    if (viewport instanceof BaseVolumeViewport) {\n        const { volumeId } = labelmapData;\n        const segmentationVolume = cache.getVolume(volumeId);\n        if (!segmentationVolume) {\n            return;\n        }\n        const voxelManager = segmentationVolume.voxelManager;\n        const imageData = segmentationVolume.imageData;\n        const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n        const segmentIndex = voxelManager.getAtIJK(indexIJK[0], indexIJK[1], indexIJK[2]);\n        const canvasPoint = viewport.worldToCanvas(worldPoint);\n        const onEdge = isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius);\n        return onEdge ? segmentIndex : undefined;\n    }\n    const segmentationImageId = getCurrentLabelmapImageIdForViewport(viewport.id, segmentationId);\n    const image = cache.getImage(segmentationImageId);\n    if (!image) {\n        return;\n    }\n    const segmentationActorEntry = getLabelmapActorEntry(viewport.id, segmentationId);\n    const imageData = segmentationActorEntry?.actor.getMapper().getInputData();\n    const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n    const dimensions = imageData.getDimensions();\n    const voxelManager = (imageData.voxelManager ||\n        utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData: imageData.getPointData().getScalars().getData(),\n        }));\n    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);\n    const onEdge = isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex);\n    return onEdge ? segmentIndex : undefined;\n}\nfunction isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius = 1) {\n    const neighborRange = Array.from({ length: 2 * searchRadius + 1 }, (_, i) => i - searchRadius);\n    for (const deltaI of neighborRange) {\n        for (const deltaJ of neighborRange) {\n            for (const deltaK of neighborRange) {\n                if (deltaI === 0 && deltaJ === 0 && deltaK === 0) {\n                    continue;\n                }\n                const neighborIndex = getNeighborIndex(deltaI, deltaJ, deltaK);\n                if (neighborIndex !== undefined && segmentIndex !== neighborIndex) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\nfunction isSegmentOnEdgeIJK(indexIJK, dimensions, voxelManager, segmentIndex, searchRadius) {\n    const getNeighborIndex = (deltaI, deltaJ, deltaK) => {\n        const neighborIJK = [\n            indexIJK[0] + deltaI,\n            indexIJK[1] + deltaJ,\n            indexIJK[2] + deltaK,\n        ];\n        return voxelManager.getAtIJK(neighborIJK[0], neighborIJK[1], neighborIJK[2]);\n    };\n    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\nfunction isSegmentOnEdgeCanvas(canvasPoint, segmentIndex, viewport, imageData, searchRadius) {\n    const getNeighborIndex = (deltaI, deltaJ) => {\n        const neighborCanvas = [canvasPoint[0] + deltaI, canvasPoint[1] + deltaJ];\n        const worldPoint = viewport.canvasToWorld(neighborCanvas);\n        const voxelManager = imageData.get('voxelManager').voxelManager;\n        const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n        return voxelManager.getAtIJK(indexIJK[0], indexIJK[1], indexIJK[2]);\n    };\n    return isSegmentOnEdge(getNeighborIndex, segmentIndex, searchRadius);\n}\n","import { BaseVolumeViewport, cache, utilities } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport { getSegmentation, getCurrentLabelmapImageIdsForViewport, } from '../../stateManagement/segmentation/segmentationState';\nimport { getAnnotation } from '../../stateManagement';\nimport { isPointInsidePolyline3D } from '../math/polyline';\nimport { getLabelmapActorEntry } from '../../stateManagement/segmentation/helpers/getSegmentationActor';\nexport function getSegmentIndexAtWorldPoint(segmentationId, worldPoint, options = {}) {\n    const segmentation = getSegmentation(segmentationId);\n    const representationData = segmentation.representationData;\n    const desiredRepresentation = options?.representationType ?? Object.keys(representationData)[0];\n    if (!desiredRepresentation) {\n        throw new Error(`Segmentation ${segmentationId} does not have any representations`);\n    }\n    switch (desiredRepresentation) {\n        case SegmentationRepresentations.Labelmap:\n            return getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, options);\n        case SegmentationRepresentations.Contour:\n            return getSegmentIndexAtWorldForContour(segmentation, worldPoint, options);\n        default:\n            return;\n    }\n}\nexport function getSegmentIndexAtWorldForLabelmap(segmentation, worldPoint, { viewport }) {\n    const labelmapData = segmentation.representationData.Labelmap;\n    if (viewport instanceof BaseVolumeViewport) {\n        const { volumeId } = labelmapData;\n        const segmentationVolume = cache.getVolume(volumeId);\n        if (!segmentationVolume) {\n            return;\n        }\n        const segmentIndex = segmentationVolume.imageData.getScalarValueFromWorld(worldPoint);\n        return segmentIndex;\n    }\n    const segmentationImageIds = getCurrentLabelmapImageIdsForViewport(viewport.id, segmentation.segmentationId);\n    if (segmentationImageIds.length > 1) {\n        console.warn('Segment selection for labelmaps with multiple imageIds in stack viewports is not supported yet.');\n        return;\n    }\n    const segmentationImageId = segmentationImageIds[0];\n    const image = cache.getImage(segmentationImageId);\n    if (!image) {\n        return;\n    }\n    const segmentationActorEntry = getLabelmapActorEntry(viewport.id, segmentation.segmentationId);\n    const imageData = segmentationActorEntry?.actor.getMapper().getInputData();\n    const indexIJK = utilities.transformWorldToIndex(imageData, worldPoint);\n    const dimensions = imageData.getDimensions();\n    const voxelManager = (imageData.voxelManager ||\n        utilities.VoxelManager.createScalarVolumeVoxelManager({\n            dimensions,\n            scalarData: imageData.getPointData().getScalars().getData(),\n        }));\n    const segmentIndex = voxelManager.getAtIJKPoint(indexIJK);\n    return segmentIndex;\n}\nexport function getSegmentIndexAtWorldForContour(segmentation, worldPoint, { viewport }) {\n    const contourData = segmentation.representationData.Contour;\n    const segmentIndices = Array.from(contourData.annotationUIDsMap.keys());\n    const { viewPlaneNormal } = viewport.getCamera();\n    for (const segmentIndex of segmentIndices) {\n        const annotationsSet = contourData.annotationUIDsMap.get(segmentIndex);\n        if (!annotationsSet) {\n            continue;\n        }\n        for (const annotationUID of annotationsSet) {\n            const annotation = getAnnotation(annotationUID);\n            if (!annotation) {\n                continue;\n            }\n            const { polyline } = annotation.data.contour;\n            if (!utilities.isEqual(viewPlaneNormal, annotation.metadata.viewPlaneNormal)) {\n                continue;\n            }\n            if (isPointInsidePolyline3D(worldPoint, polyline)) {\n                return Number(segmentIndex);\n            }\n        }\n    }\n}\n","const shader = `\nconst MAX_STRENGTH = 65535f;\n\n// Workgroup size - X*Y*Z must be multiple of 32 for better performance\noverride workGroupSizeX = 1u;\noverride workGroupSizeY = 1u;\noverride workGroupSizeZ = 1u;\n\n// Compare the current voxel to neighbors using a 9x9x9 window\noverride windowSize = 9i;\n\nstruct Params {\n  size: vec3u,\n  iteration: u32,\n}\n\n// New structure to track bounds of modified voxels\nstruct Bounds {\n  minX: atomic<i32>,\n  minY: atomic<i32>,\n  minZ: atomic<i32>,\n  maxX: atomic<i32>,\n  maxY: atomic<i32>,\n  maxZ: atomic<i32>,\n}\n\n@group(0) @binding(0) var<uniform> params: Params;\n@group(0) @binding(1) var<storage> volumePixelData: array<f32>;\n@group(0) @binding(2) var<storage, read_write> labelmap: array<u32>;\n@group(0) @binding(3) var<storage, read_write> strengthData: array<f32>;\n@group(0) @binding(4) var<storage> prevLabelmap: array<u32>;\n@group(0) @binding(5) var<storage> prevStrengthData: array<f32>;\n@group(0) @binding(6) var<storage, read_write> updatedVoxelsCounter: array<atomic<u32>>;\n@group(0) @binding(7) var<storage, read_write> modifiedBounds: Bounds;\n\nfn getPixelIndex(ijkPos: vec3u) -> u32 {\n  let numPixelsPerSlice = params.size.x * params.size.y;\n  return ijkPos.x + ijkPos.y * params.size.x + ijkPos.z * numPixelsPerSlice;\n}\n\nfn updateBounds(position: vec3i) {\n  // Atomically update min bounds (use min operation)\n  let oldMinX = atomicMin(&modifiedBounds.minX, position.x);\n  let oldMinY = atomicMin(&modifiedBounds.minY, position.y);\n  let oldMinZ = atomicMin(&modifiedBounds.minZ, position.z);\n\n  // Atomically update max bounds (use max operation)\n  let oldMaxX = atomicMax(&modifiedBounds.maxX, position.x);\n  let oldMaxY = atomicMax(&modifiedBounds.maxY, position.y);\n  let oldMaxZ = atomicMax(&modifiedBounds.maxZ, position.z);\n}\n\n@compute @workgroup_size(workGroupSizeX, workGroupSizeY, workGroupSizeZ)\nfn main(\n  @builtin(global_invocation_id) globalId: vec3u,\n) {\n  // Make sure it will not get out of bounds for volume with sizes that\n  // are not multiple of workGroupSize\n  if (\n    globalId.x >= params.size.x ||\n    globalId.y >= params.size.y ||\n    globalId.z >= params.size.z\n  ) {\n    return;\n  }\n\n  // Initialize bounds for the first iteration\n  if (params.iteration == 0 && globalId.x == 0 && globalId.y == 0 && globalId.z == 0) {\n    // Initialize to opposite extremes to ensure any update will improve the bounds\n    atomicStore(&modifiedBounds.minX, i32(params.size.x));\n    atomicStore(&modifiedBounds.minY, i32(params.size.y));\n    atomicStore(&modifiedBounds.minZ, i32(params.size.z));\n    atomicStore(&modifiedBounds.maxX, -1);\n    atomicStore(&modifiedBounds.maxY, -1);\n    atomicStore(&modifiedBounds.maxZ, -1);\n  }\n\n  let currentCoord = vec3i(globalId);\n  let currentPixelIndex = getPixelIndex(globalId);\n\n  let numPixels = arrayLength(&volumePixelData);\n  let currentPixelValue = volumePixelData[currentPixelIndex];\n\n  if (params.iteration == 0) {\n    // All non-zero initial labels are given maximum strength\n    strengthData[currentPixelIndex] = select(MAX_STRENGTH, 0., labelmap[currentPixelIndex] == 0);\n\n    // Update bounds for non-zero initial labels\n    if (labelmap[currentPixelIndex] != 0) {\n      updateBounds(currentCoord);\n    }\n    return;\n  }\n\n  // It should at least copy the values from previous state\n  var newLabel = prevLabelmap[currentPixelIndex];\n  var newStrength = prevStrengthData[currentPixelIndex];\n\n  let window = i32(ceil(f32(windowSize - 1) * .5));\n  let minWindow = -1i * window;\n  let maxWindow = 1i * window;\n\n  for (var k = minWindow; k <= maxWindow; k++) {\n    for (var j = minWindow; j <= maxWindow; j++) {\n      for (var i = minWindow; i <= maxWindow; i++) {\n        // Skip current voxel\n        if (i == 0 && j == 0 && k == 0) {\n          continue;\n        }\n\n        let neighborCoord = currentCoord + vec3i(i, j, k);\n\n        //  Boundary conditions. Do not grow outside of the volume\n        if (\n          neighborCoord.x < 0i || neighborCoord.x >= i32(params.size.x) ||\n          neighborCoord.y < 0i || neighborCoord.y >= i32(params.size.y) ||\n          neighborCoord.z < 0i || neighborCoord.z >= i32(params.size.z)\n        ) {\n          continue;\n        }\n\n        let neighborIndex = getPixelIndex(vec3u(neighborCoord));\n        let neighborPixelValue = volumePixelData[neighborIndex];\n        let prevNeighborStrength = prevStrengthData[neighborIndex];\n        let strengthCost = abs(neighborPixelValue - currentPixelValue);\n        let takeoverStrength = prevNeighborStrength - strengthCost;\n\n        if (takeoverStrength > newStrength) {\n          newLabel = prevLabelmap[neighborIndex];\n          newStrength = takeoverStrength;\n        }\n      }\n    }\n  }\n\n  if (labelmap[currentPixelIndex] != newLabel) {\n    atomicAdd(&updatedVoxelsCounter[params.iteration], 1u);\n\n    // Update bounds for modified voxels\n    updateBounds(currentCoord);\n  }\n\n  labelmap[currentPixelIndex] = newLabel;\n  strengthData[currentPixelIndex] = newStrength;\n}\n`;\nexport default shader;\n","import { cache } from '@cornerstonejs/core';\nimport shaderCode from './growCutShader';\nconst GB = 1024 * 1024 * 1024;\nconst WEBGPU_MEMORY_LIMIT = 1.99 * GB;\nconst DEFAULT_GROWCUT_OPTIONS = {\n    windowSize: 3,\n    maxProcessingTime: 30000,\n    inspection: {\n        numCyclesInterval: 5,\n        numCyclesBelowThreshold: 3,\n        threshold: 1e-4,\n    },\n};\nasync function runGrowCut(referenceVolumeId, labelmapVolumeId, options = DEFAULT_GROWCUT_OPTIONS) {\n    const workGroupSize = [8, 8, 4];\n    const { windowSize, maxProcessingTime } = Object.assign({}, DEFAULT_GROWCUT_OPTIONS, options);\n    const inspection = Object.assign({}, DEFAULT_GROWCUT_OPTIONS.inspection, options.inspection);\n    const volume = cache.getVolume(referenceVolumeId);\n    const labelmap = cache.getVolume(labelmapVolumeId);\n    const [columns, rows, numSlices] = volume.dimensions;\n    if (labelmap.dimensions[0] !== columns ||\n        labelmap.dimensions[1] !== rows ||\n        labelmap.dimensions[2] !== numSlices) {\n        throw new Error('Volume and labelmap must have the same size');\n    }\n    let numIterations = Math.floor(Math.sqrt(rows ** 2 + columns ** 2 + numSlices ** 2) / 2);\n    numIterations = Math.min(numIterations, 500);\n    const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();\n    let volumePixelData = volume.voxelManager.getCompleteScalarDataArray();\n    if (!(volumePixelData instanceof Float32Array)) {\n        volumePixelData = new Float32Array(volumePixelData);\n    }\n    const requiredLimits = {\n        maxStorageBufferBindingSize: WEBGPU_MEMORY_LIMIT,\n        maxBufferSize: WEBGPU_MEMORY_LIMIT,\n    };\n    const adapter = await navigator.gpu?.requestAdapter();\n    const device = await adapter.requestDevice({ requiredLimits });\n    const BUFFER_SIZE = volumePixelData.byteLength;\n    const UPDATED_VOXELS_COUNTER_BUFFER_SIZE = numIterations * Uint32Array.BYTES_PER_ELEMENT;\n    const BOUNDS_BUFFER_SIZE = 6 * Int32Array.BYTES_PER_ELEMENT;\n    const shaderModule = device.createShaderModule({\n        code: shaderCode,\n    });\n    const numIterationIndex = 3;\n    const paramsArrayValues = new Uint32Array([\n        columns,\n        rows,\n        numSlices,\n        0,\n    ]);\n    const gpuParamsBuffer = device.createBuffer({\n        size: paramsArrayValues.byteLength,\n        usage: GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST,\n    });\n    const gpuVolumePixelDataBuffer = device.createBuffer({\n        size: BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST,\n    });\n    device.queue.writeBuffer(gpuVolumePixelDataBuffer, 0, volumePixelData);\n    const gpuLabelmapBuffers = [0, 1].map(() => device.createBuffer({\n        size: BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE |\n            GPUBufferUsage.COPY_SRC |\n            GPUBufferUsage.COPY_DST,\n    }));\n    device.queue.writeBuffer(gpuLabelmapBuffers[0], 0, new Uint32Array(labelmapData));\n    const gpuStrengthBuffers = [0, 1].map(() => {\n        const strengthBuffer = device.createBuffer({\n            size: BUFFER_SIZE,\n            usage: GPUBufferUsage.STORAGE |\n                GPUBufferUsage.COPY_SRC |\n                GPUBufferUsage.COPY_DST,\n        });\n        return strengthBuffer;\n    });\n    const gpuCounterBuffer = device.createBuffer({\n        size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE |\n            GPUBufferUsage.COPY_SRC |\n            GPUBufferUsage.COPY_DST,\n    });\n    const gpuBoundsBuffer = device.createBuffer({\n        size: BOUNDS_BUFFER_SIZE,\n        usage: GPUBufferUsage.STORAGE |\n            GPUBufferUsage.COPY_SRC |\n            GPUBufferUsage.COPY_DST,\n    });\n    const initialBounds = new Int32Array([\n        columns,\n        rows,\n        numSlices,\n        -1,\n        -1,\n        -1,\n    ]);\n    device.queue.writeBuffer(gpuBoundsBuffer, 0, initialBounds);\n    const bindGroupLayout = device.createBindGroupLayout({\n        entries: [\n            {\n                binding: 0,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'uniform',\n                },\n            },\n            {\n                binding: 1,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'read-only-storage',\n                },\n            },\n            {\n                binding: 2,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n            {\n                binding: 3,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n            {\n                binding: 4,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'read-only-storage',\n                },\n            },\n            {\n                binding: 5,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'read-only-storage',\n                },\n            },\n            {\n                binding: 6,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n            {\n                binding: 7,\n                visibility: GPUShaderStage.COMPUTE,\n                buffer: {\n                    type: 'storage',\n                },\n            },\n        ],\n    });\n    const bindGroups = [0, 1].map((i) => {\n        const outputLabelmapBuffer = gpuLabelmapBuffers[i];\n        const outputStrengthBuffer = gpuStrengthBuffers[i];\n        const previouLabelmapBuffer = gpuLabelmapBuffers[(i + 1) % 2];\n        const previousStrengthBuffer = gpuStrengthBuffers[(i + 1) % 2];\n        return device.createBindGroup({\n            layout: bindGroupLayout,\n            entries: [\n                {\n                    binding: 0,\n                    resource: {\n                        buffer: gpuParamsBuffer,\n                    },\n                },\n                {\n                    binding: 1,\n                    resource: {\n                        buffer: gpuVolumePixelDataBuffer,\n                    },\n                },\n                {\n                    binding: 2,\n                    resource: {\n                        buffer: outputLabelmapBuffer,\n                    },\n                },\n                {\n                    binding: 3,\n                    resource: {\n                        buffer: outputStrengthBuffer,\n                    },\n                },\n                {\n                    binding: 4,\n                    resource: {\n                        buffer: previouLabelmapBuffer,\n                    },\n                },\n                {\n                    binding: 5,\n                    resource: {\n                        buffer: previousStrengthBuffer,\n                    },\n                },\n                {\n                    binding: 6,\n                    resource: {\n                        buffer: gpuCounterBuffer,\n                    },\n                },\n                {\n                    binding: 7,\n                    resource: {\n                        buffer: gpuBoundsBuffer,\n                    },\n                },\n            ],\n        });\n    });\n    const pipeline = device.createComputePipeline({\n        layout: device.createPipelineLayout({\n            bindGroupLayouts: [bindGroupLayout],\n        }),\n        compute: {\n            module: shaderModule,\n            entryPoint: 'main',\n            constants: {\n                workGroupSizeX: workGroupSize[0],\n                workGroupSizeY: workGroupSize[1],\n                workGroupSizeZ: workGroupSize[2],\n                windowSize,\n            },\n        },\n    });\n    const numWorkGroups = [\n        Math.ceil(columns / workGroupSize[0]),\n        Math.ceil(rows / workGroupSize[1]),\n        Math.ceil(numSlices / workGroupSize[2]),\n    ];\n    const gpuUpdatedVoxelsCounterStagingBuffer = device.createBuffer({\n        size: UPDATED_VOXELS_COUNTER_BUFFER_SIZE,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    const limitProcessingTime = maxProcessingTime\n        ? performance.now() + maxProcessingTime\n        : 0;\n    let currentInspectionNumCyclesInterval = inspection.numCyclesInterval;\n    let belowThresholdCounter = 0;\n    for (let i = 0; i < numIterations; i++) {\n        paramsArrayValues[numIterationIndex] = i;\n        device.queue.writeBuffer(gpuParamsBuffer, 0, paramsArrayValues);\n        const commandEncoder = device.createCommandEncoder();\n        const passEncoder = commandEncoder.beginComputePass();\n        passEncoder.setPipeline(pipeline);\n        passEncoder.setBindGroup(0, bindGroups[i % 2]);\n        passEncoder.dispatchWorkgroups(numWorkGroups[0], numWorkGroups[1], numWorkGroups[2]);\n        passEncoder.end();\n        commandEncoder.copyBufferToBuffer(gpuCounterBuffer, i * Uint32Array.BYTES_PER_ELEMENT, gpuUpdatedVoxelsCounterStagingBuffer, i * Uint32Array.BYTES_PER_ELEMENT, Uint32Array.BYTES_PER_ELEMENT);\n        device.queue.submit([commandEncoder.finish()]);\n        const inspect = i > 0 && !(i % currentInspectionNumCyclesInterval);\n        if (inspect) {\n            await gpuUpdatedVoxelsCounterStagingBuffer.mapAsync(GPUMapMode.READ, 0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);\n            const updatedVoxelsCounterResultBuffer = gpuUpdatedVoxelsCounterStagingBuffer.getMappedRange(0, UPDATED_VOXELS_COUNTER_BUFFER_SIZE);\n            const updatedVoxelsCounterBufferData = new Uint32Array(updatedVoxelsCounterResultBuffer.slice(0));\n            const updatedVoxelsRatio = updatedVoxelsCounterBufferData[i] / volumePixelData.length;\n            gpuUpdatedVoxelsCounterStagingBuffer.unmap();\n            if (i >= 1 && updatedVoxelsRatio < inspection.threshold) {\n                currentInspectionNumCyclesInterval = 1;\n                belowThresholdCounter++;\n                if (belowThresholdCounter === inspection.numCyclesBelowThreshold) {\n                    break;\n                }\n            }\n            else {\n                currentInspectionNumCyclesInterval = inspection.numCyclesInterval;\n            }\n        }\n        if (limitProcessingTime && performance.now() > limitProcessingTime) {\n            console.warn(`Exceeded processing time limit (${maxProcessingTime})ms`);\n            break;\n        }\n    }\n    const commandEncoder = device.createCommandEncoder();\n    const outputLabelmapBufferIndex = (numIterations + 1) % 2;\n    const labelmapStagingBuffer = device.createBuffer({\n        size: BUFFER_SIZE,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    const boundsStagingBuffer = device.createBuffer({\n        size: BOUNDS_BUFFER_SIZE,\n        usage: GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST,\n    });\n    commandEncoder.copyBufferToBuffer(gpuLabelmapBuffers[outputLabelmapBufferIndex], 0, labelmapStagingBuffer, 0, BUFFER_SIZE);\n    commandEncoder.copyBufferToBuffer(gpuBoundsBuffer, 0, boundsStagingBuffer, 0, BOUNDS_BUFFER_SIZE);\n    device.queue.submit([commandEncoder.finish()]);\n    await labelmapStagingBuffer.mapAsync(GPUMapMode.READ, 0, BUFFER_SIZE);\n    const labelmapResultBuffer = labelmapStagingBuffer.getMappedRange(0, BUFFER_SIZE);\n    const labelmapResult = new Uint32Array(labelmapResultBuffer);\n    labelmapData.set(labelmapResult);\n    labelmapStagingBuffer.unmap();\n    await boundsStagingBuffer.mapAsync(GPUMapMode.READ, 0, BOUNDS_BUFFER_SIZE);\n    const boundsResultBuffer = boundsStagingBuffer.getMappedRange(0, BOUNDS_BUFFER_SIZE);\n    const boundsResult = new Int32Array(boundsResultBuffer.slice(0));\n    boundsStagingBuffer.unmap();\n    const minX = boundsResult[0];\n    const minY = boundsResult[1];\n    const minZ = boundsResult[2];\n    const maxX = boundsResult[3];\n    const maxY = boundsResult[4];\n    const maxZ = boundsResult[5];\n    labelmap.voxelManager.setCompleteScalarDataArray(labelmapData);\n    labelmap.voxelManager.clearBounds();\n    labelmap.voxelManager.setBounds([\n        [minX, maxX],\n        [minY, maxY],\n        [minZ, maxZ],\n    ]);\n}\nexport { runGrowCut as default, runGrowCut as run };\n","import { volumeLoader, utilities as csUtils } from '@cornerstonejs/core';\nimport { run } from './runGrowCut';\nconst POSITIVE_SEED_VALUE = 254;\nconst NEGATIVE_SEED_VALUE = 255;\nconst NEGATIVE_PIXEL_RANGE = [-Infinity, -995];\nconst POSITIVE_PIXEL_RANGE = [0, 1900];\nfunction _setNegativeSeedValues(subVolume, labelmap, options) {\n    const { negativeSeedValue = NEGATIVE_SEED_VALUE, negativePixelRange = NEGATIVE_PIXEL_RANGE, } = options;\n    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const [width, height, numSlices] = labelmap.dimensions;\n    const middleSliceIndex = Math.floor(numSlices / 2);\n    const visited = new Array(width * height).fill(false);\n    const sliceOffset = middleSliceIndex * width * height;\n    const bfs = (startX, startY) => {\n        const queue = [[startX, startY]];\n        while (queue.length) {\n            const [x, y] = queue.shift();\n            const slicePixelIndex = y * width + x;\n            if (x < 0 ||\n                x >= width ||\n                y < 0 ||\n                y >= height ||\n                visited[slicePixelIndex]) {\n                continue;\n            }\n            visited[slicePixelIndex] = true;\n            const volumeVoxelIndex = sliceOffset + slicePixelIndex;\n            const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];\n            if (volumeVoxelValue < negativePixelRange[0] ||\n                volumeVoxelValue > negativePixelRange[1]) {\n                continue;\n            }\n            labelmap.voxelManager.setAtIndex(volumeVoxelIndex, negativeSeedValue);\n            queue.push([x - 1, y]);\n            queue.push([x + 1, y]);\n            queue.push([x, y - 1]);\n            queue.push([x, y + 1]);\n        }\n    };\n    const scanLine = (startX, limitX, incX, y) => {\n        for (let x = startX; x !== limitX; x += incX) {\n            const slicePixelIndex = y * width + x;\n            const volumeVoxelIndex = sliceOffset + slicePixelIndex;\n            const volumeVoxelValue = subVolPixelData[volumeVoxelIndex];\n            if (volumeVoxelValue < negativePixelRange[0] ||\n                volumeVoxelValue > negativePixelRange[1]) {\n                break;\n            }\n            if (!visited[slicePixelIndex]) {\n                bfs(x, y);\n            }\n        }\n    };\n    for (let y = 0; y < height; y++) {\n        scanLine(0, width - 1, 1, y);\n        scanLine(width - 1, 0, -1, y);\n    }\n}\nfunction _setPositiveSeedValues(subVolume, labelmap, options) {\n    const { positiveSeedValue = POSITIVE_SEED_VALUE, positivePixelRange = POSITIVE_PIXEL_RANGE, } = options;\n    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const labelmapData = labelmap.voxelManager.getCompleteScalarDataArray();\n    const [width, height, numSlices] = labelmap.dimensions;\n    const middleSliceIndex = Math.floor(numSlices / 2);\n    const startSliceIndex = Math.max(middleSliceIndex - 3, 0);\n    const stopSliceIndex = Math.max(startSliceIndex + 5, numSlices);\n    const pixelsPerSlice = width * height;\n    for (let z = startSliceIndex; z < stopSliceIndex; z++) {\n        const zOffset = z * pixelsPerSlice;\n        for (let y = 0; y < height; y++) {\n            const yOffset = y * width;\n            for (let x = 0; x < width; x++) {\n                const index = zOffset + yOffset + x;\n                const pixelValue = subVolPixelData[index];\n                const isPositiveValue = pixelValue >= positivePixelRange[0] &&\n                    pixelValue <= positivePixelRange[1];\n                if (isPositiveValue) {\n                    labelmap.voxelManager.setAtIndex(index, positiveSeedValue);\n                }\n            }\n        }\n    }\n}\nasync function _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options) {\n    const labelmap = volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);\n    _setPositiveSeedValues(subVolume, labelmap, options);\n    _setNegativeSeedValues(subVolume, labelmap, options);\n    return labelmap;\n}\nasync function runGrowCutForBoundingBox(referencedVolumeId, boundingBoxInfo, options) {\n    const { boundingBox } = boundingBoxInfo;\n    const { ijkTopLeft, ijkBottomRight } = boundingBox;\n    const subVolumeBoundsIJK = {\n        minX: ijkTopLeft[0],\n        maxX: ijkBottomRight[0],\n        minY: ijkTopLeft[1],\n        maxY: ijkBottomRight[1],\n        minZ: ijkTopLeft[2],\n        maxZ: ijkBottomRight[2],\n    };\n    const subVolume = csUtils.createSubVolume(referencedVolumeId, subVolumeBoundsIJK, {\n        targetBuffer: {\n            type: 'Float32Array',\n        },\n    });\n    const labelmap = await _createAndCacheSegmentationSubVolumeForBoundingBox(subVolume, options);\n    await run(subVolume.volumeId, labelmap.volumeId);\n    return labelmap;\n}\nexport { runGrowCutForBoundingBox as default, runGrowCutForBoundingBox };\n","import { quat, vec3 } from 'gl-matrix';\nimport { utilities as csUtils, cache, volumeLoader } from '@cornerstonejs/core';\nimport { run } from './runGrowCut';\nimport { getSphereBoundsInfo } from '../../getSphereBoundsInfo';\nconst { transformWorldToIndex } = csUtils;\nconst POSITIVE_SEED_VALUE = 254;\nconst NEGATIVE_SEED_VALUE = 255;\nconst POSITIVE_SEED_VARIANCE = 0.1;\nconst NEGATIVE_SEED_VARIANCE = 0.8;\nfunction _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo) {\n    const { topLeftWorld, bottomRightWorld } = sphereBoundsInfo;\n    const topLeftIJK = transformWorldToIndex(referencedVolume.imageData, topLeftWorld);\n    const bottomRightIJK = transformWorldToIndex(referencedVolume.imageData, bottomRightWorld);\n    return {\n        ...sphereBoundsInfo,\n        topLeftIJK,\n        bottomRightIJK,\n    };\n}\nfunction _getSphereBoundsInfo(referencedVolume, sphereInfo) {\n    const direction = referencedVolume.imageData.getDirection();\n    const vecColumn = vec3.fromValues(direction[3], direction[4], direction[5]);\n    const { center: sphereCenterPoint, radius: sphereRadius } = sphereInfo;\n    const refVolImageData = referencedVolume.imageData;\n    const topCirclePoint = vec3.scaleAndAdd(vec3.create(), sphereCenterPoint, vecColumn, -sphereRadius);\n    const bottomCirclePoint = vec3.scaleAndAdd(vec3.create(), sphereCenterPoint, vecColumn, sphereRadius);\n    const sphereBoundsInfo = getSphereBoundsInfo([bottomCirclePoint, topCirclePoint], refVolImageData);\n    return _getGrowCutSphereBoundsInfo(referencedVolume, sphereBoundsInfo);\n}\nfunction _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport) {\n    const refVolImageData = referencedVolume.imageData;\n    const camera = viewport.getCamera();\n    const { ijkVecRowDir, ijkVecColDir } = csUtils.getVolumeDirectionVectors(refVolImageData, camera);\n    const obliqueView = [ijkVecRowDir, ijkVecColDir].some((vec) => !csUtils.isEqual(Math.abs(vec[0]), 1) &&\n        !csUtils.isEqual(Math.abs(vec[1]), 1) &&\n        !csUtils.isEqual(Math.abs(vec[2]), 1));\n    if (obliqueView) {\n        console.warn('Oblique view is not supported!');\n        return;\n    }\n    const { boundsIJK: sphereBoundsIJK } = _getSphereBoundsInfo(referencedVolume, sphereInfo);\n    const subVolumeBoundsIJK = {\n        minX: sphereBoundsIJK[0][0],\n        maxX: sphereBoundsIJK[0][1] + 1,\n        minY: sphereBoundsIJK[1][0],\n        maxY: sphereBoundsIJK[1][1] + 1,\n        minZ: sphereBoundsIJK[2][0],\n        maxZ: sphereBoundsIJK[2][1] + 1,\n    };\n    return csUtils.createSubVolume(referencedVolume.volumeId, subVolumeBoundsIJK, {\n        targetBuffer: {\n            type: 'Float32Array',\n        },\n    });\n}\nfunction _setPositiveSeedValues(referencedVolume, labelmap, sphereInfo, options) {\n    const refVolumePixelData = referencedVolume.voxelManager.getCompleteScalarDataArray();\n    const worldStartPos = sphereInfo.center;\n    const [width, height, numSlices] = referencedVolume.dimensions;\n    const numPixelsPerSlice = width * height;\n    const ijkStartPosition = transformWorldToIndex(referencedVolume.imageData, worldStartPos);\n    const referencePixelValue = refVolumePixelData[ijkStartPosition[2] * numPixelsPerSlice +\n        ijkStartPosition[1] * width +\n        ijkStartPosition[0]];\n    const positiveSeedValue = options.positiveSeedValue ?? POSITIVE_SEED_VALUE;\n    const positiveSeedVariance = options.positiveSeedVariance ?? POSITIVE_SEED_VARIANCE;\n    const positiveSeedVarianceValue = Math.abs(referencePixelValue * positiveSeedVariance);\n    const minPositivePixelValue = referencePixelValue - positiveSeedVarianceValue;\n    const maxPositivePixelValue = referencePixelValue + positiveSeedVarianceValue;\n    const neighborsCoordDelta = [\n        [-1, 0, 0],\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n        [0, 0, 1],\n    ];\n    const startVoxelIndex = ijkStartPosition[2] * numPixelsPerSlice +\n        ijkStartPosition[1] * width +\n        ijkStartPosition[0];\n    labelmap.voxelManager.setAtIndex(startVoxelIndex, positiveSeedValue);\n    const queue = [ijkStartPosition];\n    while (queue.length) {\n        const ijkVoxel = queue.shift();\n        const [x, y, z] = ijkVoxel;\n        for (let i = 0, len = neighborsCoordDelta.length; i < len; i++) {\n            const neighborCoordDelta = neighborsCoordDelta[i];\n            const nx = x + neighborCoordDelta[0];\n            const ny = y + neighborCoordDelta[1];\n            const nz = z + neighborCoordDelta[2];\n            if (nx < 0 ||\n                nx >= width ||\n                ny < 0 ||\n                ny >= height ||\n                nz < 0 ||\n                nz >= numSlices) {\n                continue;\n            }\n            const neighborVoxelIndex = nz * numPixelsPerSlice + ny * width + nx;\n            const neighborPixelValue = refVolumePixelData[neighborVoxelIndex];\n            const neighborLabelmapValue = labelmap.voxelManager.getAtIndex(neighborVoxelIndex);\n            if (neighborLabelmapValue === positiveSeedValue ||\n                neighborPixelValue < minPositivePixelValue ||\n                neighborPixelValue > maxPositivePixelValue) {\n                continue;\n            }\n            labelmap.voxelManager.setAtIndex(neighborVoxelIndex, positiveSeedValue);\n            queue.push([nx, ny, nz]);\n        }\n    }\n}\nfunction _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options) {\n    const subVolPixelData = subVolume.voxelManager.getCompleteScalarDataArray();\n    const [columns, rows, numSlices] = labelmap.dimensions;\n    const numPixelsPerSlice = columns * rows;\n    const { worldVecRowDir, worldVecSliceDir } = csUtils.getVolumeDirectionVectors(labelmap.imageData, viewport.getCamera());\n    const ijkSphereCenter = transformWorldToIndex(subVolume.imageData, sphereInfo.center);\n    const referencePixelValue = subVolPixelData[ijkSphereCenter[2] * columns * rows +\n        ijkSphereCenter[1] * columns +\n        ijkSphereCenter[0]];\n    const negativeSeedVariance = options.negativeSeedVariance ?? NEGATIVE_SEED_VARIANCE;\n    const negativeSeedValue = options?.negativeSeedValue ?? NEGATIVE_SEED_VALUE;\n    const negativeSeedVarianceValue = Math.abs(referencePixelValue * negativeSeedVariance);\n    const minNegativePixelValue = referencePixelValue - negativeSeedVarianceValue;\n    const maxNegativePixelValue = referencePixelValue + negativeSeedVarianceValue;\n    const numCirclePoints = 360;\n    const rotationAngle = (2 * Math.PI) / numCirclePoints;\n    const worldQuat = quat.setAxisAngle(quat.create(), worldVecSliceDir, rotationAngle);\n    const vecRotation = vec3.clone(worldVecRowDir);\n    for (let i = 0; i < numCirclePoints; i++) {\n        const worldCircleBorderPoint = vec3.scaleAndAdd(vec3.create(), sphereInfo.center, vecRotation, sphereInfo.radius);\n        const ijkCircleBorderPoint = transformWorldToIndex(labelmap.imageData, worldCircleBorderPoint);\n        const [x, y, z] = ijkCircleBorderPoint;\n        vec3.transformQuat(vecRotation, vecRotation, worldQuat);\n        if (x < 0 ||\n            x >= columns ||\n            y < 0 ||\n            y >= rows ||\n            z < 0 ||\n            z >= numSlices) {\n            continue;\n        }\n        const offset = x + y * columns + z * numPixelsPerSlice;\n        const pixelValue = subVolPixelData[offset];\n        if (pixelValue < minNegativePixelValue ||\n            pixelValue > maxNegativePixelValue) {\n            labelmap.voxelManager.setAtIndex(offset, negativeSeedValue);\n        }\n    }\n}\nasync function _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options) {\n    const labelmap = await volumeLoader.createAndCacheDerivedLabelmapVolume(subVolume.volumeId);\n    _setPositiveSeedValues(subVolume, labelmap, sphereInfo, options);\n    _setNegativeSeedValues(subVolume, labelmap, sphereInfo, viewport, options);\n    return labelmap;\n}\nasync function runGrowCutForSphere(referencedVolumeId, sphereInfo, viewport, options) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    const subVolume = _createSubVolumeFromSphere(referencedVolume, sphereInfo, viewport);\n    const labelmap = await _createAndCacheSegmentationSubVolumeForSphere(subVolume, sphereInfo, viewport, options);\n    await run(subVolume.volumeId, labelmap.volumeId);\n    return labelmap;\n}\nexport { runGrowCutForSphere as default, runGrowCutForSphere };\n","import { utilities as csUtils, cache, volumeLoader } from '@cornerstonejs/core';\nimport { run } from './runGrowCut';\nimport { POSITIVE_SEED_LABEL, NEGATIVE_SEED_LABEL, DEFAULT_NEIGHBORHOOD_RADIUS, DEFAULT_POSITIVE_STD_DEV_MULTIPLIER, DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER, DEFAULT_NEGATIVE_SEED_MARGIN, DEFAULT_NEGATIVE_SEEDS_COUNT, MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER, } from './constants';\nconst { transformWorldToIndex } = csUtils;\nconst MAX_POSITIVE_SEEDS = 100000;\nfunction calculateGrowCutSeeds(referencedVolume, worldPosition, options) {\n    const { dimensions, imageData: refImageData } = referencedVolume;\n    const [width, height, numSlices] = dimensions;\n    const referenceVolumeVoxelManager = referencedVolume.voxelManager;\n    const scalarData = referenceVolumeVoxelManager.getCompleteScalarDataArray();\n    const numPixelsPerSlice = width * height;\n    const neighborhoodRadius = options?.initialNeighborhoodRadius ?? DEFAULT_NEIGHBORHOOD_RADIUS;\n    const positiveK = options?.positiveStdDevMultiplier ?? DEFAULT_POSITIVE_STD_DEV_MULTIPLIER;\n    const negativeK = options?.negativeStdDevMultiplier ?? DEFAULT_NEGATIVE_STD_DEV_MULTIPLIER;\n    const negativeSeedMargin = options?.negativeSeedMargin ?? DEFAULT_NEGATIVE_SEED_MARGIN;\n    const negativeSeedsTargetPatches = options?.negativeSeedsTargetPatches ?? DEFAULT_NEGATIVE_SEEDS_COUNT;\n    const ijkStart = transformWorldToIndex(refImageData, worldPosition).map(Math.round);\n    const startIndex = referenceVolumeVoxelManager.toIndex(ijkStart);\n    if (ijkStart[0] < 0 ||\n        ijkStart[0] >= width ||\n        ijkStart[1] < 0 ||\n        ijkStart[1] >= height ||\n        ijkStart[2] < 0 ||\n        ijkStart[2] >= numSlices) {\n        console.warn('Click position is outside volume bounds.');\n        return null;\n    }\n    const initialStats = csUtils.calculateNeighborhoodStats(scalarData, dimensions, ijkStart, neighborhoodRadius);\n    if (initialStats.count === 0) {\n        initialStats.mean = scalarData[startIndex];\n        initialStats.stdDev = 0;\n    }\n    const positiveIntensityMin = initialStats.mean - positiveK * initialStats.stdDev;\n    const positiveIntensityMax = initialStats.mean + positiveK * initialStats.stdDev;\n    const neighborsCoordDelta = [\n        [-1, 0, 0],\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n        [0, 0, 1],\n    ];\n    let minX = Infinity, minY = Infinity, minZ = Infinity;\n    let maxX = -Infinity, maxY = -Infinity, maxZ = -Infinity;\n    const positiveSeedIndices = new Set();\n    const queue = [];\n    const startValue = scalarData[startIndex];\n    if (startValue >= positiveIntensityMin &&\n        startValue <= positiveIntensityMax) {\n        positiveSeedIndices.add(startIndex);\n        queue.push(ijkStart);\n        minX = maxX = ijkStart[0];\n        minY = maxY = ijkStart[1];\n        minZ = maxZ = ijkStart[2];\n    }\n    else {\n        console.warn('Clicked voxel intensity is outside the calculated positive range. No positive seeds generated.');\n        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };\n    }\n    let currentQueueIndex = 0;\n    while (currentQueueIndex < queue.length &&\n        positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {\n        const [x, y, z] = queue[currentQueueIndex++];\n        minX = Math.min(x, minX);\n        minY = Math.min(y, minY);\n        minZ = Math.min(z, minZ);\n        maxX = Math.max(x, maxX);\n        maxY = Math.max(y, maxY);\n        maxZ = Math.max(z, maxZ);\n        for (let i = 0; i < neighborsCoordDelta.length; i++) {\n            const [dx, dy, dz] = neighborsCoordDelta[i];\n            const nx = x + dx;\n            const ny = y + dy;\n            const nz = z + dz;\n            if (nx < 0 ||\n                nx >= width ||\n                ny < 0 ||\n                ny >= height ||\n                nz < 0 ||\n                nz >= numSlices) {\n                continue;\n            }\n            const neighborIndex = nz * numPixelsPerSlice + ny * width + nx;\n            if (positiveSeedIndices.has(neighborIndex)) {\n                continue;\n            }\n            const neighborValue = scalarData[neighborIndex];\n            if (neighborValue >= positiveIntensityMin &&\n                neighborValue <= positiveIntensityMax) {\n                positiveSeedIndices.add(neighborIndex);\n                if (positiveSeedIndices.size < MAX_POSITIVE_SEEDS) {\n                    queue.push([nx, ny, nz]);\n                }\n            }\n        }\n    }\n    if (positiveSeedIndices.size >= MAX_POSITIVE_SEEDS) {\n        console.debug(`Reached maximum number of positive seeds (${MAX_POSITIVE_SEEDS}). Stopping BFS.`);\n    }\n    if (positiveSeedIndices.size === 0) {\n        console.warn('No positive seeds found after BFS.');\n        return { positiveSeedIndices: new Set(), negativeSeedIndices: new Set() };\n    }\n    let positiveSum = 0;\n    let positiveSumSq = 0;\n    positiveSeedIndices.forEach((index) => {\n        const value = scalarData[index];\n        positiveSum += value;\n        positiveSumSq += value * value;\n    });\n    const positiveCount = positiveSeedIndices.size;\n    const positiveMean = positiveSum / positiveCount;\n    const positiveVariance = positiveSumSq / positiveCount - positiveMean * positiveMean;\n    const positiveStdDev = Math.sqrt(Math.max(0, positiveVariance));\n    const negativeDiffThreshold = negativeK * positiveStdDev;\n    const minXm = Math.max(0, minX - negativeSeedMargin);\n    const minYm = Math.max(0, minY - negativeSeedMargin);\n    const minZm = Math.max(0, minZ - negativeSeedMargin);\n    const maxXm = Math.min(width - 1, maxX + negativeSeedMargin);\n    const maxYm = Math.min(height - 1, maxY + negativeSeedMargin);\n    const maxZm = Math.min(numSlices - 1, maxZ + negativeSeedMargin);\n    const negativeSeedIndices = new Set();\n    let attempts = 0;\n    let patchesAdded = 0;\n    const maxAttempts = negativeSeedsTargetPatches * MAX_NEGATIVE_SEED_ATTEMPTS_MULTIPLIER;\n    while (patchesAdded < negativeSeedsTargetPatches && attempts < maxAttempts) {\n        attempts++;\n        const rx = Math.floor(Math.random() * (maxXm - minXm + 1) + minXm);\n        const ry = Math.floor(Math.random() * (maxYm - minYm + 1) + minYm);\n        const rz = Math.floor(Math.random() * (maxZm - minZm + 1) + minZm);\n        const centerIndex = rz * numPixelsPerSlice + ry * width + rx;\n        if (positiveSeedIndices.has(centerIndex) ||\n            negativeSeedIndices.has(centerIndex)) {\n            continue;\n        }\n        const centerValue = scalarData[centerIndex];\n        if (Math.abs(centerValue - positiveMean) > negativeDiffThreshold) {\n            let patchContributed = false;\n            for (let dy = -1; dy <= 1; dy++) {\n                const ny = ry + dy;\n                if (ny < 0 || ny >= height) {\n                    continue;\n                }\n                for (let dx = -1; dx <= 1; dx++) {\n                    const nx = rx + dx;\n                    if (nx < 0 || nx >= width) {\n                        continue;\n                    }\n                    const neighborIndex = rz * numPixelsPerSlice + ny * width + nx;\n                    if (positiveSeedIndices.has(neighborIndex) ||\n                        negativeSeedIndices.has(neighborIndex)) {\n                        continue;\n                    }\n                    negativeSeedIndices.add(neighborIndex);\n                    patchContributed = true;\n                }\n            }\n            if (patchContributed) {\n                patchesAdded++;\n            }\n        }\n    }\n    if (negativeSeedIndices.size === 0) {\n        console.warn('Could not find any negative seeds. GrowCut might fail or produce poor results.');\n    }\n    console.debug('positiveSeedIndices', positiveSeedIndices.size);\n    console.debug('negativeSeedIndices', negativeSeedIndices.size);\n    return { positiveSeedIndices, negativeSeedIndices };\n}\nasync function runOneClickGrowCut({ referencedVolumeId, worldPosition, options, }) {\n    const referencedVolume = cache.getVolume(referencedVolumeId);\n    const labelmap = volumeLoader.createAndCacheDerivedLabelmapVolume(referencedVolumeId);\n    labelmap.voxelManager.forEach(({ index, value }) => {\n        if (value !== 0) {\n            labelmap.voxelManager.setAtIndex(index, 0);\n        }\n    });\n    const seeds = options.seeds ??\n        calculateGrowCutSeeds(referencedVolume, worldPosition, options);\n    const positiveSeedLabel = options?.positiveSeedValue ?? POSITIVE_SEED_LABEL;\n    const negativeSeedLabel = options?.negativeSeedValue ?? NEGATIVE_SEED_LABEL;\n    if (!seeds) {\n        return null;\n    }\n    const { positiveSeedIndices, negativeSeedIndices } = seeds;\n    if (positiveSeedIndices.size < 10 ||\n        positiveSeedIndices.size > MAX_POSITIVE_SEEDS ||\n        negativeSeedIndices.size < 10) {\n        console.warn('Not enough seeds found. GrowCut might fail or produce poor results.');\n        return labelmap;\n    }\n    positiveSeedIndices.forEach((index) => {\n        labelmap.voxelManager.setAtIndex(index, positiveSeedLabel);\n    });\n    negativeSeedIndices.forEach((index) => {\n        labelmap.voxelManager.setAtIndex(index, negativeSeedLabel);\n    });\n    await run(referencedVolumeId, labelmap.volumeId, options);\n    return labelmap;\n}\nexport { runOneClickGrowCut as default, runOneClickGrowCut, calculateGrowCutSeeds, };\n","import { getToolGroup } from '../../store/ToolGroupManager';\nimport triggerAnnotationRenderForViewportIds from '../triggerAnnotationRenderForViewportIds';\nimport { getBrushToolInstances } from './getBrushToolInstances';\nexport function invalidateBrushCursor(toolGroupId) {\n    const toolGroup = getToolGroup(toolGroupId);\n    if (toolGroup === undefined) {\n        return;\n    }\n    const brushBasedToolInstances = getBrushToolInstances(toolGroupId);\n    brushBasedToolInstances.forEach((tool) => {\n        tool.invalidateBrushCursor();\n    });\n    const viewportsInfo = toolGroup.getViewportsInfo();\n    const viewportsInfoArray = Object.keys(viewportsInfo).map((key) => viewportsInfo[key]);\n    if (!viewportsInfoArray.length) {\n        return;\n    }\n    const viewportIds = toolGroup.getViewportIds();\n    triggerAnnotationRenderForViewportIds(viewportIds);\n}\n","import debounce from './debounce';\nimport isObject from './isObject';\nfunction throttle(func, wait, options) {\n    let leading = true;\n    let trailing = true;\n    if (typeof func !== 'function') {\n        throw new TypeError('Expected a function');\n    }\n    if (isObject(options)) {\n        leading = 'leading' in options ? Boolean(options.leading) : leading;\n        trailing = 'trailing' in options ? Boolean(options.trailing) : trailing;\n    }\n    return debounce(func, wait, {\n        leading,\n        trailing,\n        maxWait: wait,\n    });\n}\nexport default throttle;\n","function getDeltaPoints(currentPoints, lastPoints) {\n    const curr = getMeanPoints(currentPoints);\n    const last = getMeanPoints(lastPoints);\n    return {\n        page: _subtractPoints2D(curr.page, last.page),\n        client: _subtractPoints2D(curr.client, last.client),\n        canvas: _subtractPoints2D(curr.canvas, last.canvas),\n        world: _subtractPoints3D(curr.world, last.world),\n    };\n}\nfunction getDeltaDistance(currentPoints, lastPoints) {\n    const curr = getMeanPoints(currentPoints);\n    const last = getMeanPoints(lastPoints);\n    return {\n        page: _getDistance2D(curr.page, last.page),\n        client: _getDistance2D(curr.client, last.client),\n        canvas: _getDistance2D(curr.canvas, last.canvas),\n        world: _getDistance3D(curr.world, last.world),\n    };\n}\nfunction getDeltaRotation(currentPoints, lastPoints) {\n}\nfunction getDeltaDistanceBetweenIPoints(currentPoints, lastPoints) {\n    const currentDistance = _getMeanDistanceBetweenAllIPoints(currentPoints);\n    const lastDistance = _getMeanDistanceBetweenAllIPoints(lastPoints);\n    const deltaDistance = {\n        page: currentDistance.page - lastDistance.page,\n        client: currentDistance.client - lastDistance.client,\n        canvas: currentDistance.canvas - lastDistance.canvas,\n        world: currentDistance.world - lastDistance.world,\n    };\n    return deltaDistance;\n}\nfunction copyPointsList(points) {\n    return JSON.parse(JSON.stringify(points));\n}\nfunction copyPoints(points) {\n    return JSON.parse(JSON.stringify(points));\n}\nfunction getMeanPoints(points) {\n    return points.reduce((prev, curr) => {\n        return {\n            page: [\n                prev.page[0] + curr.page[0] / points.length,\n                prev.page[1] + curr.page[1] / points.length,\n            ],\n            client: [\n                prev.client[0] + curr.client[0] / points.length,\n                prev.client[1] + curr.client[1] / points.length,\n            ],\n            canvas: [\n                prev.canvas[0] + curr.canvas[0] / points.length,\n                prev.canvas[1] + curr.canvas[1] / points.length,\n            ],\n            world: [\n                prev.world[0] + curr.world[0] / points.length,\n                prev.world[1] + curr.world[1] / points.length,\n                prev.world[2] + curr.world[2] / points.length,\n            ],\n        };\n    }, {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n    });\n}\nfunction getMeanTouchPoints(points) {\n    return points.reduce((prev, curr) => {\n        return {\n            page: [\n                prev.page[0] + curr.page[0] / points.length,\n                prev.page[1] + curr.page[1] / points.length,\n            ],\n            client: [\n                prev.client[0] + curr.client[0] / points.length,\n                prev.client[1] + curr.client[1] / points.length,\n            ],\n            canvas: [\n                prev.canvas[0] + curr.canvas[0] / points.length,\n                prev.canvas[1] + curr.canvas[1] / points.length,\n            ],\n            world: [\n                prev.world[0] + curr.world[0] / points.length,\n                prev.world[1] + curr.world[1] / points.length,\n                prev.world[2] + curr.world[2] / points.length,\n            ],\n            touch: {\n                identifier: null,\n                radiusX: prev.touch.radiusX + curr.touch.radiusX / points.length,\n                radiusY: prev.touch.radiusY + curr.touch.radiusY / points.length,\n                force: prev.touch.force + curr.touch.force / points.length,\n                rotationAngle: prev.touch.rotationAngle + curr.touch.rotationAngle / points.length,\n            },\n        };\n    }, {\n        page: [0, 0],\n        client: [0, 0],\n        canvas: [0, 0],\n        world: [0, 0, 0],\n        touch: {\n            identifier: null,\n            radiusX: 0,\n            radiusY: 0,\n            force: 0,\n            rotationAngle: 0,\n        },\n    });\n}\nfunction _subtractPoints2D(point0, point1) {\n    return [point0[0] - point1[0], point0[1] - point1[1]];\n}\nfunction _subtractPoints3D(point0, point1) {\n    return [point0[0] - point1[0], point0[1] - point1[1], point0[2] - point1[2]];\n}\nfunction _getMeanDistanceBetweenAllIPoints(points) {\n    const pairedDistance = [];\n    for (let i = 0; i < points.length; i++) {\n        for (let j = 0; j < points.length; j++) {\n            if (i < j) {\n                pairedDistance.push({\n                    page: _getDistance2D(points[i].page, points[j].page),\n                    client: _getDistance2D(points[i].client, points[j].client),\n                    canvas: _getDistance2D(points[i].canvas, points[j].canvas),\n                    world: _getDistance3D(points[i].world, points[j].world),\n                });\n            }\n        }\n    }\n    return pairedDistance.reduce((prev, curr) => {\n        return {\n            page: prev.page + curr.page / pairedDistance.length,\n            client: prev.client + curr.client / pairedDistance.length,\n            canvas: prev.canvas + curr.canvas / pairedDistance.length,\n            world: prev.world + curr.world / pairedDistance.length,\n        };\n    }, {\n        page: 0,\n        client: 0,\n        canvas: 0,\n        world: 0,\n    });\n}\nfunction _getDistance2D(point0, point1) {\n    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) + Math.pow(point0[1] - point1[1], 2));\n}\nfunction _getDistance3D(point0, point1) {\n    return Math.sqrt(Math.pow(point0[0] - point1[0], 2) +\n        Math.pow(point0[1] - point1[1], 2) +\n        Math.pow(point0[2] - point1[2], 2));\n}\nexport { getMeanPoints, getMeanTouchPoints, copyPoints, copyPointsList, getDeltaDistanceBetweenIPoints, getDeltaPoints, getDeltaDistance, getDeltaRotation, };\n","import { getRenderingEngine } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nimport { getToolGroup } from '../store/ToolGroupManager';\nexport function triggerAnnotationRenderForToolGroupIds(toolGroupIds) {\n    toolGroupIds.forEach((toolGroupId) => {\n        const toolGroup = getToolGroup(toolGroupId);\n        if (!toolGroup) {\n            console.warn(`ToolGroup not available for ${toolGroupId}`);\n            return;\n        }\n        const viewportsInfo = toolGroup.getViewportsInfo();\n        viewportsInfo.forEach((viewportInfo) => {\n            const { renderingEngineId, viewportId } = viewportInfo;\n            const renderingEngine = getRenderingEngine(renderingEngineId);\n            if (!renderingEngine) {\n                console.warn(`RenderingEngine not available for ${renderingEngineId}`);\n                return;\n            }\n            const viewport = renderingEngine.getViewport(viewportId);\n            triggerAnnotationRender(viewport.element);\n        });\n    });\n}\nexport default triggerAnnotationRenderForToolGroupIds;\n","import { getEnabledElementByViewportId } from '@cornerstonejs/core';\nimport triggerAnnotationRender from './triggerAnnotationRender';\nexport function triggerAnnotationRenderForViewportIds(viewportIdsToRender) {\n    if (!viewportIdsToRender.length) {\n        return;\n    }\n    viewportIdsToRender.forEach((viewportId) => {\n        const enabledElement = getEnabledElementByViewportId(viewportId);\n        if (!enabledElement) {\n            console.warn(`Viewport not available for ${viewportId}`);\n            return;\n        }\n        const { viewport } = enabledElement;\n        if (!viewport) {\n            console.warn(`Viewport not available for ${viewportId}`);\n            return;\n        }\n        const element = viewport.element;\n        triggerAnnotationRender(element);\n    });\n}\nexport default triggerAnnotationRenderForViewportIds;\n","import { cache, StackViewport, BaseVolumeViewport, utilities, } from '@cornerstonejs/core';\nfunction isViewportPreScaled(viewport, targetId) {\n    if (viewport instanceof BaseVolumeViewport) {\n        const volumeId = utilities.getVolumeId(targetId);\n        const volume = cache.getVolume(volumeId);\n        return !!volume?.scaling && Object.keys(volume.scaling).length > 0;\n    }\n    else if (viewport instanceof StackViewport) {\n        const { preScale } = viewport.getImageData() || {};\n        return !!preScale?.scaled;\n    }\n    else {\n        return false;\n    }\n}\nexport { isViewportPreScaled };\n","export var ColorbarRangeTextPosition;\n(function (ColorbarRangeTextPosition) {\n    ColorbarRangeTextPosition[\"Top\"] = \"top\";\n    ColorbarRangeTextPosition[\"Left\"] = \"left\";\n    ColorbarRangeTextPosition[\"Bottom\"] = \"bottom\";\n    ColorbarRangeTextPosition[\"Right\"] = \"right\";\n})(ColorbarRangeTextPosition || (ColorbarRangeTextPosition = {}));\n","const AttributeTypes = {\n  SCALARS: 0,\n  VECTORS: 1,\n  NORMALS: 2,\n  TCOORDS: 3,\n  TENSORS: 4,\n  GLOBALIDS: 5,\n  PEDIGREEIDS: 6,\n  EDGEFLAG: 7,\n  NUM_ATTRIBUTES: 8\n};\nconst AttributeLimitTypes = {\n  MAX: 0,\n  EXACT: 1,\n  NOLIMIT: 2\n};\nconst CellGhostTypes = {\n  DUPLICATECELL: 1,\n  // the cell is present on multiple processors\n  HIGHCONNECTIVITYCELL: 2,\n  // the cell has more neighbors than in a regular mesh\n  LOWCONNECTIVITYCELL: 4,\n  // the cell has less neighbors than in a regular mesh\n  REFINEDCELL: 8,\n  // other cells are present that refines it.\n  EXTERIORCELL: 16,\n  // the cell is on the exterior of the data set\n  HIDDENCELL: 32 // the cell is needed to maintain connectivity, but the data values should be ignored.\n};\n\nconst PointGhostTypes = {\n  DUPLICATEPOINT: 1,\n  // the cell is present on multiple processors\n  HIDDENPOINT: 2 // the point is needed to maintain connectivity, but the data values should be ignored.\n};\n\nconst AttributeCopyOperations = {\n  COPYTUPLE: 0,\n  INTERPOLATE: 1,\n  PASSDATA: 2,\n  ALLCOPY: 3 // all of the above\n};\n\nconst ghostArrayName = 'vtkGhostType';\nconst DesiredOutputPrecision = {\n  DEFAULT: 0,\n  // use the point type that does not truncate any data\n  SINGLE: 1,\n  // use Float32Array\n  DOUBLE: 2 // use Float64Array\n};\n\nvar Constants = {\n  AttributeCopyOperations,\n  AttributeLimitTypes,\n  AttributeTypes,\n  CellGhostTypes,\n  DesiredOutputPrecision,\n  PointGhostTypes,\n  ghostArrayName\n};\n\nexport { AttributeCopyOperations, AttributeLimitTypes, AttributeTypes, CellGhostTypes, DesiredOutputPrecision, PointGhostTypes, Constants as default, ghostArrayName };\n","import { m as macro } from '../../macros2.js';\nimport { b as roundVector, c as clampVector } from '../Core/Math/index.js';\nimport vtkBoundingBox from './BoundingBox.js';\nimport vtkDataSet from './DataSet.js';\nimport vtkStructuredData from './StructuredData.js';\nimport { StructuredType } from './StructuredData/Constants.js';\nimport { mat3, mat4, vec3 } from 'gl-matrix';\n\nconst {\n  vtkErrorMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// vtkImageData methods\n// ----------------------------------------------------------------------------\n\nfunction vtkImageData(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkImageData');\n  publicAPI.setExtent = function () {\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return false;\n    }\n    for (var _len = arguments.length, inExtent = new Array(_len), _key = 0; _key < _len; _key++) {\n      inExtent[_key] = arguments[_key];\n    }\n    const extentArray = inExtent.length === 1 ? inExtent[0] : inExtent;\n    if (extentArray.length !== 6) {\n      return false;\n    }\n    const changeDetected = model.extent.some((item, index) => item !== extentArray[index]);\n    if (changeDetected) {\n      model.extent = extentArray.slice();\n      model.dataDescription = vtkStructuredData.getDataDescriptionFromExtent(model.extent);\n      publicAPI.modified();\n    }\n    return changeDetected;\n  };\n  publicAPI.setDimensions = function () {\n    let i;\n    let j;\n    let k;\n    if (model.deleted) {\n      vtkErrorMacro('instance deleted - cannot call any method');\n      return;\n    }\n    if (arguments.length === 1) {\n      const array = arguments.length <= 0 ? undefined : arguments[0];\n      i = array[0];\n      j = array[1];\n      k = array[2];\n    } else if (arguments.length === 3) {\n      i = arguments.length <= 0 ? undefined : arguments[0];\n      j = arguments.length <= 1 ? undefined : arguments[1];\n      k = arguments.length <= 2 ? undefined : arguments[2];\n    } else {\n      vtkErrorMacro('Bad dimension specification');\n      return;\n    }\n    publicAPI.setExtent(0, i - 1, 0, j - 1, 0, k - 1);\n  };\n  publicAPI.getDimensions = () => [model.extent[1] - model.extent[0] + 1, model.extent[3] - model.extent[2] + 1, model.extent[5] - model.extent[4] + 1];\n  publicAPI.getNumberOfCells = () => {\n    const dims = publicAPI.getDimensions();\n    let nCells = 1;\n    for (let i = 0; i < 3; i++) {\n      if (dims[i] === 0) {\n        return 0;\n      }\n      if (dims[i] > 1) {\n        nCells *= dims[i] - 1;\n      }\n    }\n    return nCells;\n  };\n  publicAPI.getNumberOfPoints = () => {\n    const dims = publicAPI.getDimensions();\n    return dims[0] * dims[1] * dims[2];\n  };\n  publicAPI.getPoint = index => {\n    const dims = publicAPI.getDimensions();\n    if (dims[0] === 0 || dims[1] === 0 || dims[2] === 0) {\n      vtkErrorMacro('Requesting a point from an empty image.');\n      return null;\n    }\n    const ijk = new Float64Array(3);\n    switch (model.dataDescription) {\n      case StructuredType.EMPTY:\n        return null;\n      case StructuredType.SINGLE_POINT:\n        break;\n      case StructuredType.X_LINE:\n        ijk[0] = index;\n        break;\n      case StructuredType.Y_LINE:\n        ijk[1] = index;\n        break;\n      case StructuredType.Z_LINE:\n        ijk[2] = index;\n        break;\n      case StructuredType.XY_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0];\n        break;\n      case StructuredType.YZ_PLANE:\n        ijk[1] = index % dims[1];\n        ijk[2] = index / dims[1];\n        break;\n      case StructuredType.XZ_PLANE:\n        ijk[0] = index % dims[0];\n        ijk[2] = index / dims[0];\n        break;\n      case StructuredType.XYZ_GRID:\n        ijk[0] = index % dims[0];\n        ijk[1] = index / dims[0] % dims[1];\n        ijk[2] = index / (dims[0] * dims[1]);\n        break;\n      default:\n        vtkErrorMacro('Invalid dataDescription');\n        break;\n    }\n    const coords = [0, 0, 0];\n    publicAPI.indexToWorld(ijk, coords);\n    return coords;\n  };\n\n  // vtkCell *GetCell(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCell(vtkIdType cellId, vtkGenericCell *cell) VTK_OVERRIDE;\n  // void GetCellBounds(vtkIdType cellId, double bounds[6]) VTK_OVERRIDE;\n  // virtual vtkIdType FindPoint(double x, double y, double z)\n  // {\n  //   return this->vtkDataSet::FindPoint(x, y, z);\n  // }\n  // vtkIdType FindPoint(double x[3]) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkIdType cellId, double tol2,\n  //   int& subId, double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkIdType FindCell(\n  //   double x[3], vtkCell *cell, vtkGenericCell *gencell,\n  //   vtkIdType cellId, double tol2, int& subId,\n  //   double pcoords[3], double *weights) VTK_OVERRIDE;\n  // vtkCell *FindAndGetCell(double x[3], vtkCell *cell, vtkIdType cellId,\n  //                                 double tol2, int& subId, double pcoords[3],\n  //                                 double *weights) VTK_OVERRIDE;\n  // int GetCellType(vtkIdType cellId) VTK_OVERRIDE;\n  // void GetCellPoints(vtkIdType cellId, vtkIdList *ptIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetCellPoints(cellId,ptIds,this->DataDescription,\n  //                                     this->GetDimensions());}\n  // void GetPointCells(vtkIdType ptId, vtkIdList *cellIds) VTK_OVERRIDE\n  //   {vtkStructuredData::GetPointCells(ptId,cellIds,this->GetDimensions());}\n  // void ComputeBounds() VTK_OVERRIDE;\n  // int GetMaxCellSize() VTK_OVERRIDE {return 8;}; //voxel is the largest\n\n  publicAPI.getBounds = () => publicAPI.extentToBounds(publicAPI.getSpatialExtent());\n  publicAPI.extentToBounds = ex => vtkBoundingBox.transformBounds(ex, model.indexToWorld);\n  publicAPI.getSpatialExtent = () => vtkBoundingBox.inflate([...model.extent], 0.5);\n\n  // Internal, shouldn't need to call this manually.\n  publicAPI.computeTransforms = () => {\n    mat4.fromTranslation(model.indexToWorld, model.origin);\n    model.indexToWorld[0] = model.direction[0];\n    model.indexToWorld[1] = model.direction[1];\n    model.indexToWorld[2] = model.direction[2];\n    model.indexToWorld[4] = model.direction[3];\n    model.indexToWorld[5] = model.direction[4];\n    model.indexToWorld[6] = model.direction[5];\n    model.indexToWorld[8] = model.direction[6];\n    model.indexToWorld[9] = model.direction[7];\n    model.indexToWorld[10] = model.direction[8];\n    mat4.scale(model.indexToWorld, model.indexToWorld, model.spacing);\n    mat4.invert(model.worldToIndex, model.indexToWorld);\n  };\n  publicAPI.indexToWorld = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.indexToWorld);\n    return aout;\n  };\n  publicAPI.indexToWorldVec3 = publicAPI.indexToWorld;\n  publicAPI.worldToIndex = function (ain) {\n    let aout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    vec3.transformMat4(aout, ain, model.worldToIndex);\n    return aout;\n  };\n  publicAPI.worldToIndexVec3 = publicAPI.worldToIndex;\n  publicAPI.indexToWorldBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.indexToWorld, bout);\n  };\n  publicAPI.worldToIndexBounds = function (bin) {\n    let bout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    return vtkBoundingBox.transformBounds(bin, model.worldToIndex, bout);\n  };\n\n  // Make sure the transform is correct\n  publicAPI.onModified(publicAPI.computeTransforms);\n  publicAPI.computeTransforms();\n  publicAPI.getCenter = () => vtkBoundingBox.getCenter(publicAPI.getBounds());\n  publicAPI.computeHistogram = function (worldBounds) {\n    let voxelFunction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const bounds = [0, 0, 0, 0, 0, 0];\n    publicAPI.worldToIndexBounds(worldBounds, bounds);\n    const point1 = [0, 0, 0];\n    const point2 = [0, 0, 0];\n    vtkBoundingBox.computeCornerPoints(bounds, point1, point2);\n    roundVector(point1, point1);\n    roundVector(point2, point2);\n    const dimensions = publicAPI.getDimensions();\n    clampVector(point1, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point1);\n    clampVector(point2, [0, 0, 0], [dimensions[0] - 1, dimensions[1] - 1, dimensions[2] - 1], point2);\n    const yStride = dimensions[0];\n    const zStride = dimensions[0] * dimensions[1];\n    const pixels = publicAPI.getPointData().getScalars().getData();\n    let maximum = -Infinity;\n    let minimum = Infinity;\n    let sumOfSquares = 0;\n    let isum = 0;\n    let inum = 0;\n    for (let z = point1[2]; z <= point2[2]; z++) {\n      for (let y = point1[1]; y <= point2[1]; y++) {\n        let index = point1[0] + y * yStride + z * zStride;\n        for (let x = point1[0]; x <= point2[0]; x++) {\n          if (!voxelFunction || voxelFunction([x, y, z], bounds)) {\n            const pixel = pixels[index];\n            if (pixel > maximum) maximum = pixel;\n            if (pixel < minimum) minimum = pixel;\n            sumOfSquares += pixel * pixel;\n            isum += pixel;\n            inum += 1;\n          }\n          ++index;\n        }\n      }\n    }\n    const average = inum > 0 ? isum / inum : 0;\n    const variance = inum ? Math.abs(sumOfSquares / inum - average * average) : 0;\n    const sigma = Math.sqrt(variance);\n    return {\n      minimum,\n      maximum,\n      average,\n      variance,\n      sigma,\n      count: inum\n    };\n  };\n\n  // TODO: use the unimplemented `vtkDataSetAttributes` for scalar length, that is currently also a TODO (GetNumberOfComponents).\n  // Scalar data could be tuples for color information?\n  publicAPI.computeIncrements = function (extent) {\n    let numberOfComponents = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const increments = [];\n    let incr = numberOfComponents;\n\n    // Calculate array increment offsets\n    // similar to c++ vtkImageData::ComputeIncrements\n    for (let idx = 0; idx < 3; ++idx) {\n      increments[idx] = incr;\n      incr *= extent[idx * 2 + 1] - extent[idx * 2] + 1;\n    }\n    return increments;\n  };\n\n  /**\n   * @param {Number[]} index the localized `[i,j,k]` pixel array position. Float values will be rounded.\n   * @return {Number} the corresponding flattened index in the scalar array\n   */\n  publicAPI.computeOffsetIndex = _ref => {\n    let [i, j, k] = _ref;\n    const extent = publicAPI.getExtent();\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    const increments = publicAPI.computeIncrements(extent, numberOfComponents);\n    // Use the array increments to find the pixel index\n    // similar to c++ vtkImageData::GetArrayPointer\n    // Math.floor to catch \"practically 0\" e^-15 scenarios.\n    return Math.floor((Math.round(i) - extent[0]) * increments[0] + (Math.round(j) - extent[2]) * increments[1] + (Math.round(k) - extent[4]) * increments[2]);\n  };\n\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @return {Number|NaN} the corresponding pixel's index in the scalar array\n   */\n  publicAPI.getOffsetIndexFromWorld = xyz => {\n    const extent = publicAPI.getExtent();\n    const index = publicAPI.worldToIndex(xyz);\n\n    // Confirm indexed i,j,k coords are within the bounds of the volume\n    for (let idx = 0; idx < 3; ++idx) {\n      if (index[idx] < extent[idx * 2] || index[idx] > extent[idx * 2 + 1]) {\n        vtkErrorMacro(`GetScalarPointer: Pixel ${index} is not in memory. Current extent = ${extent}`);\n        return NaN;\n      }\n    }\n\n    // Assumed the index here is within 0 <-> scalarData.length, but doesn't hurt to check upstream\n    return publicAPI.computeOffsetIndex(index);\n  };\n  /**\n   * @param {Number[]} xyz the [x,y,z] Array in world coordinates\n   * @param {Number?} comp the scalar component index for multi-component scalars\n   * @return {Number|NaN} the corresponding pixel's scalar value\n   */\n  publicAPI.getScalarValueFromWorld = function (xyz) {\n    let comp = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const numberOfComponents = publicAPI.getPointData().getScalars().getNumberOfComponents();\n    if (comp < 0 || comp >= numberOfComponents) {\n      vtkErrorMacro(`GetScalarPointer: Scalar Component ${comp} is not within bounds. Current Scalar numberOfComponents: ${numberOfComponents}`);\n      return NaN;\n    }\n    const offsetIndex = publicAPI.getOffsetIndexFromWorld(xyz);\n    if (Number.isNaN(offsetIndex)) {\n      // VTK Error Macro will have been tripped already, no need to do it again,\n      return offsetIndex;\n    }\n    return publicAPI.getPointData().getScalars().getComponent(offsetIndex, comp);\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  direction: null,\n  // a mat3\n  indexToWorld: null,\n  // a mat4\n  worldToIndex: null,\n  // a mat4\n  spacing: [1.0, 1.0, 1.0],\n  origin: [0.0, 0.0, 0.0],\n  extent: [0, -1, 0, -1, 0, -1],\n  dataDescription: StructuredType.EMPTY\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkDataSet.extend(publicAPI, model, initialValues);\n  if (!model.direction) {\n    model.direction = mat3.identity(new Float64Array(9));\n  } else if (Array.isArray(model.direction)) {\n    model.direction = new Float64Array(model.direction.slice(0, 9));\n  }\n  model.indexToWorld = new Float64Array(16);\n  model.worldToIndex = new Float64Array(16);\n\n  // Set/Get methods\n  macro.get(publicAPI, model, ['indexToWorld', 'worldToIndex']);\n  macro.setGetArray(publicAPI, model, ['origin', 'spacing'], 3);\n  macro.setGetArray(publicAPI, model, ['direction'], 9);\n  macro.getArray(publicAPI, model, ['extent'], 6);\n\n  // Object specific methods\n  vtkImageData(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkImageData');\n\n// ----------------------------------------------------------------------------\n\nvar vtkImageData$1 = {\n  newInstance,\n  extend\n};\n\nexport { vtkImageData$1 as default, extend, newInstance };\n","import { m as macro } from '../../macros2.js';\nimport { h as hsv2rgb, i as isNan, K as floor, L as isInf, M as rgb2hsv, N as rgb2lab, O as lab2rgb } from '../../Common/Core/Math/index.js';\nimport vtkScalarsToColors from '../../Common/Core/ScalarsToColors.js';\nimport Constants from './ColorTransferFunction/Constants.js';\n\nconst {\n  ColorSpace,\n  Scale\n} = Constants;\nconst {\n  ScalarMappingTarget\n} = vtkScalarsToColors;\nconst {\n  vtkDebugMacro,\n  vtkErrorMacro,\n  vtkWarningMacro\n} = macro;\n\n// ----------------------------------------------------------------------------\n// Global methods\n// ----------------------------------------------------------------------------\n/* eslint-disable no-continue                                                */\n\n// Convert to and from a special polar version of CIELAB (useful for creating\n// continuous diverging color maps).\nfunction vtkColorTransferFunctionLabToMsh(lab, msh) {\n  const L = lab[0];\n  const a = lab[1];\n  const b = lab[2];\n  const M = Math.sqrt(L * L + a * a + b * b);\n  const s = M > 0.001 ? Math.acos(L / M) : 0.0;\n  const h = s > 0.001 ? Math.atan2(b, a) : 0.0;\n  msh[0] = M;\n  msh[1] = s;\n  msh[2] = h;\n}\nfunction vtkColorTransferFunctionMshToLab(msh, lab) {\n  const M = msh[0];\n  const s = msh[1];\n  const h = msh[2];\n  lab[0] = M * Math.cos(s);\n  lab[1] = M * Math.sin(s) * Math.cos(h);\n  lab[2] = M * Math.sin(s) * Math.sin(h);\n}\n\n// For the case when interpolating from a saturated color to an unsaturated\n// color, find a hue for the unsaturated color that makes sense.\nfunction vtkColorTransferFunctionAdjustHue(msh, unsatM) {\n  if (msh[0] >= unsatM - 0.1) {\n    // The best we can do is hold hue constant.\n    return msh[2];\n  }\n\n  // This equation is designed to make the perceptual change of the\n  // interpolation to be close to constant.\n  const hueSpin = msh[1] * Math.sqrt(unsatM * unsatM - msh[0] * msh[0]) / (msh[0] * Math.sin(msh[1]));\n  // Spin hue away from 0 except in purple hues.\n  if (msh[2] > -0.3 * Math.PI) {\n    return msh[2] + hueSpin;\n  }\n  return msh[2] - hueSpin;\n}\nfunction vtkColorTransferFunctionAngleDiff(a1, a2) {\n  let adiff = a1 - a2;\n  if (adiff < 0.0) {\n    adiff = -adiff;\n  }\n  while (adiff >= 2.0 * Math.PI) {\n    adiff -= 2.0 * Math.PI;\n  }\n  if (adiff > Math.PI) {\n    adiff = 2.0 * Math.PI - adiff;\n  }\n  return adiff;\n}\n\n// Interpolate a diverging color map.\nfunction vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, result) {\n  const lab1 = [];\n  const lab2 = [];\n  rgb2lab(rgb1, lab1);\n  rgb2lab(rgb2, lab2);\n  const msh1 = [];\n  const msh2 = [];\n  vtkColorTransferFunctionLabToMsh(lab1, msh1);\n  vtkColorTransferFunctionLabToMsh(lab2, msh2);\n\n  // If the endpoints are distinct saturated colors, then place white in between\n  // them.\n  let localS = s;\n  if (msh1[1] > 0.05 && msh2[1] > 0.05 && vtkColorTransferFunctionAngleDiff(msh1[2], msh2[2]) > 0.33 * Math.PI) {\n    // Insert the white midpoint by setting one end to white and adjusting the\n    // scalar value.\n    let Mmid = Math.max(msh1[0], msh2[0]);\n    Mmid = Math.max(88.0, Mmid);\n    if (s < 0.5) {\n      msh2[0] = Mmid;\n      msh2[1] = 0.0;\n      msh2[2] = 0.0;\n      localS *= 2.0;\n    } else {\n      msh1[0] = Mmid;\n      msh1[1] = 0.0;\n      msh1[2] = 0.0;\n      localS = 2.0 * localS - 1.0;\n    }\n  }\n\n  // If one color has no saturation, then its hue value is invalid.  In this\n  // case, we want to set it to something logical so that the interpolation of\n  // hue makes sense.\n  if (msh1[1] < 0.05 && msh2[1] > 0.05) {\n    msh1[2] = vtkColorTransferFunctionAdjustHue(msh2, msh1[0]);\n  } else if (msh2[1] < 0.05 && msh1[1] > 0.05) {\n    msh2[2] = vtkColorTransferFunctionAdjustHue(msh1, msh2[0]);\n  }\n  const mshTmp = [];\n  mshTmp[0] = (1 - localS) * msh1[0] + localS * msh2[0];\n  mshTmp[1] = (1 - localS) * msh1[1] + localS * msh2[1];\n  mshTmp[2] = (1 - localS) * msh1[2] + localS * msh2[2];\n\n  // Now convert back to RGB\n  const labTmp = [];\n  vtkColorTransferFunctionMshToLab(mshTmp, labTmp);\n  lab2rgb(labTmp, result);\n}\n\n// ----------------------------------------------------------------------------\n// vtkColorTransferFunction methods\n// ----------------------------------------------------------------------------\n\nfunction vtkColorTransferFunction(publicAPI, model) {\n  // Set our className\n  model.classHierarchy.push('vtkColorTransferFunction');\n\n  // Return the number of points which specify this function\n  publicAPI.getSize = () => model.nodes.length;\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n  publicAPI.addRGBPoint = (x, r, g, b) => publicAPI.addRGBPointLong(x, r, g, b, 0.5, 0.0);\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in RGB\n  publicAPI.addRGBPointLong = function (x, r, g, b) {\n    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    // Error check\n    if (midpoint < 0.0 || midpoint > 1.0) {\n      vtkErrorMacro('Midpoint outside range [0.0, 1.0]');\n      return -1;\n    }\n    if (sharpness < 0.0 || sharpness > 1.0) {\n      vtkErrorMacro('Sharpness outside range [0.0, 1.0]');\n      return -1;\n    }\n\n    // remove any node already at this X location\n    if (!model.allowDuplicateScalars) {\n      publicAPI.removePoint(x);\n    }\n\n    // Create the new node\n    const node = {\n      x,\n      r,\n      g,\n      b,\n      midpoint,\n      sharpness\n    };\n\n    // Add it, then sort to get everything in order\n    model.nodes.push(node);\n    publicAPI.sortAndUpdateRange();\n\n    // We need to find the index of the node we just added in order\n    // to return this value\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n\n    // If we didn't find it, something went horribly wrong so\n    // return -1\n    if (i < model.nodes.length) {\n      return i;\n    }\n    return -1;\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n  publicAPI.addHSVPoint = (x, h, s, v) => publicAPI.addHSVPointLong(x, h, s, v, 0.5, 0.0);\n\n  //----------------------------------------------------------------------------\n  // Add a point defined in HSV\n  publicAPI.addHSVPointLong = function (x, h, s, v) {\n    let midpoint = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.5;\n    let sharpness = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0.0;\n    const rgb = [];\n    const hsv = [h, s, v];\n    hsv2rgb(hsv, rgb);\n    return publicAPI.addRGBPoint(x, rgb[0], rgb[1], rgb[2], midpoint, sharpness);\n  };\n\n  //----------------------------------------------------------------------------\n  // Set nodes directly\n  publicAPI.setNodes = nodes => {\n    if (model.nodes !== nodes) {\n      const before = JSON.stringify(model.nodes);\n      model.nodes = nodes;\n      const after = JSON.stringify(model.nodes);\n      if (publicAPI.sortAndUpdateRange() || before !== after) {\n        publicAPI.modified();\n        return true;\n      }\n    }\n    return false;\n  };\n\n  //----------------------------------------------------------------------------\n  // Sort the vector in increasing order, then fill in\n  // the Range\n  publicAPI.sortAndUpdateRange = () => {\n    const before = JSON.stringify(model.nodes);\n    model.nodes.sort((a, b) => a.x - b.x);\n    const after = JSON.stringify(model.nodes);\n    const modifiedInvoked = publicAPI.updateRange();\n    // If range is updated, Modified() has been called, don't call it again.\n    if (!modifiedInvoked && before !== after) {\n      publicAPI.modified();\n      return true;\n    }\n    return modifiedInvoked;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.updateRange = () => {\n    const oldRange = [2];\n    oldRange[0] = model.mappingRange[0];\n    oldRange[1] = model.mappingRange[1];\n    const size = model.nodes.length;\n    if (size) {\n      model.mappingRange[0] = model.nodes[0].x;\n      model.mappingRange[1] = model.nodes[size - 1].x;\n    } else {\n      model.mappingRange[0] = 0;\n      model.mappingRange[1] = 0;\n    }\n\n    // If the range is the same, then no need to call Modified()\n    if (oldRange[0] === model.mappingRange[0] && oldRange[1] === model.mappingRange[1]) {\n      return false;\n    }\n    publicAPI.modified();\n    return true;\n  };\n\n  //----------------------------------------------------------------------------\n  // Remove a point\n  publicAPI.removePoint = x => {\n    // First find the node since we need to know its\n    // index as our return value\n    let i = 0;\n    for (; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === x) {\n        break;\n      }\n    }\n    const retVal = i;\n\n    // If the node doesn't exist, we return -1\n    if (i >= model.nodes.length) {\n      return -1;\n    }\n\n    // If the first or last point has been removed, then we update the range\n    // No need to sort here as the order of points hasn't changed.\n    let modifiedInvoked = false;\n    model.nodes.splice(i, 1);\n    if (i === 0 || i === model.nodes.length) {\n      modifiedInvoked = publicAPI.updateRange();\n    }\n    if (!modifiedInvoked) {\n      publicAPI.modified();\n    }\n    return retVal;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.movePoint = (oldX, newX) => {\n    if (oldX === newX) {\n      // Nothing to do.\n      return;\n    }\n    publicAPI.removePoint(newX);\n    for (let i = 0; i < model.nodes.length; i++) {\n      if (model.nodes[i].x === oldX) {\n        model.nodes[i].x = newX;\n        publicAPI.sortAndUpdateRange();\n        break;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  // Remove all points\n  publicAPI.removeAllPoints = () => {\n    model.nodes = [];\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a line defined in RGB\n  publicAPI.addRGBSegment = (x1, r1, g1, b1, x2, r2, g2, b2) => {\n    // First, find all points in this range and remove them\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= x1 && model.nodes[i].x <= x2) {\n        model.nodes.splice(i, 1);\n      } else {\n        i++;\n      }\n    }\n\n    // Now add the points\n    publicAPI.addRGBPointLong(x1, r1, g1, b1, 0.5, 0.0);\n    publicAPI.addRGBPointLong(x2, r2, g2, b2, 0.5, 0.0);\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  // Add a line defined in HSV\n  publicAPI.addHSVSegment = (x1, h1, s1, v1, x2, h2, s2, v2) => {\n    const hsv1 = [h1, s1, v1];\n    const hsv2 = [h2, s2, v2];\n    const rgb1 = [];\n    const rgb2 = [];\n    hsv2rgb(hsv1, rgb1);\n    hsv2rgb(hsv2, rgb2);\n    publicAPI.addRGBSegment(x1, rgb1[0], rgb1[1], rgb1[2], x2, rgb2[0], rgb2[1], rgb2[2]);\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the RGBA color evaluated at the specified location\n  publicAPI.mapValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return [Math.floor(255.0 * rgb[0] + 0.5), Math.floor(255.0 * rgb[1] + 0.5), Math.floor(255.0 * rgb[2] + 0.5), 255];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the RGB color evaluated at the specified location\n  publicAPI.getColor = (x, rgb) => {\n    if (model.indexedLookup) {\n      const numNodes = publicAPI.getSize();\n      // todo\n      const idx = publicAPI.getAnnotatedValueIndexInternal(x);\n      if (idx < 0 || numNodes === 0) {\n        const nanColor = publicAPI.getNanColorByReference();\n        rgb[0] = nanColor[0];\n        rgb[1] = nanColor[1];\n        rgb[2] = nanColor[2];\n      } else {\n        const nodeVal = [];\n        publicAPI.getNodeValue(idx % numNodes, nodeVal);\n        // nodeVal[0] is the x value. nodeVal[1...3] is rgb.\n        rgb[0] = nodeVal[1];\n        rgb[1] = nodeVal[2];\n        rgb[2] = nodeVal[3];\n      }\n      return;\n    }\n    publicAPI.getTable(x, x, 1, rgb);\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the red color evaluated at the specified location\n  publicAPI.getRedValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[0];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the green color evaluated at the specified location\n  publicAPI.getGreenValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[1];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns the blue color evaluated at the specified location\n  publicAPI.getBlueValue = x => {\n    const rgb = [];\n    publicAPI.getColor(x, rgb);\n    return rgb[2];\n  };\n\n  //----------------------------------------------------------------------------\n  // Returns a table of RGB colors at regular intervals along the function\n  publicAPI.getTable = (xStart_, xEnd_, size, table) => {\n    // To handle BigInt limitation\n    const xStart = Number(xStart_);\n    const xEnd = Number(xEnd_);\n\n    // Special case: If either the start or end is a NaN, then all any\n    // interpolation done on them is also a NaN.  Therefore, fill the table with\n    // the NaN color.\n    if (isNan(xStart) || isNan(xEnd)) {\n      for (let i = 0; i < size; i++) {\n        table[i * 3 + 0] = model.nanColor[0];\n        table[i * 3 + 1] = model.nanColor[1];\n        table[i * 3 + 2] = model.nanColor[2];\n      }\n      return;\n    }\n    let idx = 0;\n    const numNodes = model.nodes.length;\n\n    // Need to keep track of the last value so that\n    // we can fill in table locations past this with\n    // this value if Clamping is On.\n    let lastR = 0.0;\n    let lastG = 0.0;\n    let lastB = 0.0;\n    if (numNodes !== 0) {\n      lastR = model.nodes[numNodes - 1].r;\n      lastG = model.nodes[numNodes - 1].g;\n      lastB = model.nodes[numNodes - 1].b;\n    }\n    let x = 0.0;\n    let x1 = 0.0;\n    let x2 = 0.0;\n    const rgb1 = [0.0, 0.0, 0.0];\n    const rgb2 = [0.0, 0.0, 0.0];\n    let midpoint = 0.0;\n    let sharpness = 0.0;\n    const tmpVec = [];\n\n    // If the scale is logarithmic, make sure the range is valid.\n    let usingLogScale = model.scale === Scale.LOG10;\n    if (usingLogScale) {\n      // Note: This requires range[0] <= range[1].\n      usingLogScale = model.mappingRange[0] > 0.0;\n    }\n    let logStart = 0.0;\n    let logEnd = 0.0;\n    let logX = 0.0;\n    if (usingLogScale) {\n      logStart = Math.log10(xStart);\n      logEnd = Math.log10(xEnd);\n    }\n\n    // For each table entry\n    for (let i = 0; i < size; i++) {\n      // Find our location in the table\n      const tidx = 3 * i;\n\n      // Find our X location. If we are taking only 1 sample, make\n      // it halfway between start and end (usually start and end will\n      // be the same in this case)\n      if (size > 1) {\n        if (usingLogScale) {\n          logX = logStart + i / (size - 1.0) * (logEnd - logStart);\n          x = 10.0 ** logX;\n        } else {\n          x = xStart + i / (size - 1.0) * (xEnd - xStart);\n        }\n      } else if (usingLogScale) {\n        logX = 0.5 * (logStart + logEnd);\n        x = 10.0 ** logX;\n      } else {\n        x = 0.5 * (xStart + xEnd);\n      }\n\n      // Linearly map x from mappingRange to [0, numberOfValues-1],\n      // discretize (round down to the closest integer),\n      // then map back to mappingRange\n      if (model.discretize) {\n        const range = model.mappingRange;\n        if (x >= range[0] && x <= range[1]) {\n          const numberOfValues = model.numberOfValues;\n          const deltaRange = range[1] - range[0];\n          if (numberOfValues <= 1) {\n            x = range[0] + deltaRange / 2.0;\n          } else {\n            // normalize x\n            const xn = (x - range[0]) / deltaRange;\n            // discretize\n            const discretizeIndex = floor(numberOfValues * xn);\n            // get discretized x\n            x = range[0] + discretizeIndex / (numberOfValues - 1) * deltaRange;\n          }\n        }\n      }\n\n      // Do we need to move to the next node?\n      while (idx < numNodes && x > model.nodes[idx].x) {\n        idx++;\n        // If we are at a valid point index, fill in\n        // the value at this node, and the one before (the\n        // two that surround our current sample location)\n        // idx cannot be 0 since we just incremented it.\n        if (idx < numNodes) {\n          x1 = model.nodes[idx - 1].x;\n          x2 = model.nodes[idx].x;\n          if (usingLogScale) {\n            x1 = Math.log10(x1);\n            x2 = Math.log10(x2);\n          }\n          rgb1[0] = model.nodes[idx - 1].r;\n          rgb2[0] = model.nodes[idx].r;\n          rgb1[1] = model.nodes[idx - 1].g;\n          rgb2[1] = model.nodes[idx].g;\n          rgb1[2] = model.nodes[idx - 1].b;\n          rgb2[2] = model.nodes[idx].b;\n\n          // We only need the previous midpoint and sharpness\n          // since these control this region\n          midpoint = model.nodes[idx - 1].midpoint;\n          sharpness = model.nodes[idx - 1].sharpness;\n\n          // Move midpoint away from extreme ends of range to avoid\n          // degenerate math\n          if (midpoint < 0.00001) {\n            midpoint = 0.00001;\n          }\n          if (midpoint > 0.99999) {\n            midpoint = 0.99999;\n          }\n        }\n      }\n\n      // Are we at or past the end? If so, just use the last value\n      if (x > model.mappingRange[1]) {\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseAboveRangeColor()) {\n            table[tidx] = model.aboveRangeColor[0];\n            table[tidx + 1] = model.aboveRangeColor[1];\n            table[tidx + 2] = model.aboveRangeColor[2];\n          } else {\n            table[tidx] = lastR;\n            table[tidx + 1] = lastG;\n            table[tidx + 2] = lastB;\n          }\n        }\n      } else if (x < model.mappingRange[0] || isInf(x) && x < 0) {\n        // we are before the first node? If so, duplicate this node's values.\n        // We have to deal with -inf here\n        table[tidx] = 0.0;\n        table[tidx + 1] = 0.0;\n        table[tidx + 2] = 0.0;\n        if (model.clamping) {\n          if (publicAPI.getUseBelowRangeColor()) {\n            table[tidx] = model.belowRangeColor[0];\n            table[tidx + 1] = model.belowRangeColor[1];\n            table[tidx + 2] = model.belowRangeColor[2];\n          } else if (numNodes > 0) {\n            table[tidx] = model.nodes[0].r;\n            table[tidx + 1] = model.nodes[0].g;\n            table[tidx + 2] = model.nodes[0].b;\n          }\n        }\n      } else if (idx === 0 && (Math.abs(x - xStart) < 1e-6 || model.discretize)) {\n        if (numNodes > 0) {\n          table[tidx] = model.nodes[0].r;\n          table[tidx + 1] = model.nodes[0].g;\n          table[tidx + 2] = model.nodes[0].b;\n        } else {\n          table[tidx] = 0.0;\n          table[tidx + 1] = 0.0;\n          table[tidx + 2] = 0.0;\n        }\n      } else {\n        // OK, we are between two nodes - interpolate\n        // Our first attempt at a normalized location [0,1] -\n        // we will be modifying this based on midpoint and\n        // sharpness to get the curve shape we want and to have\n        // it pass through (y1+y2)/2 at the midpoint.\n        let s = 0.0;\n        if (usingLogScale) {\n          s = (logX - x1) / (x2 - x1);\n        } else {\n          s = (x - x1) / (x2 - x1);\n        }\n\n        // Readjust based on the midpoint - linear adjustment\n        if (s < midpoint) {\n          s = 0.5 * s / midpoint;\n        } else {\n          s = 0.5 + 0.5 * (s - midpoint) / (1.0 - midpoint);\n        }\n\n        // override for sharpness > 0.99\n        // In this case we just want piecewise constant\n        if (sharpness > 0.99) {\n          // Use the first value since we are below the midpoint\n          if (s < 0.5) {\n            table[tidx] = rgb1[0];\n            table[tidx + 1] = rgb1[1];\n            table[tidx + 2] = rgb1[2];\n            continue;\n          } else {\n            // Use the second value at or above the midpoint\n            table[tidx] = rgb2[0];\n            table[tidx + 1] = rgb2[1];\n            table[tidx + 2] = rgb2[2];\n            continue;\n          }\n        }\n\n        // Override for sharpness < 0.01\n        // In this case we want piecewise linear\n        if (sharpness < 0.01) {\n          // Simple linear interpolation\n          if (model.colorSpace === ColorSpace.RGB) {\n            table[tidx] = (1 - s) * rgb1[0] + s * rgb2[0];\n            table[tidx + 1] = (1 - s) * rgb1[1] + s * rgb2[1];\n            table[tidx + 2] = (1 - s) * rgb1[2] + s * rgb2[2];\n          } else if (model.colorSpace === ColorSpace.HSV) {\n            const hsv1 = [];\n            const hsv2 = [];\n            rgb2hsv(rgb1, hsv1);\n            rgb2hsv(rgb2, hsv2);\n            if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n              if (hsv1[0] > hsv2[0]) {\n                hsv1[0] -= 1.0;\n              } else {\n                hsv2[0] -= 1.0;\n              }\n            }\n            const hsvTmp = [];\n            hsvTmp[0] = (1.0 - s) * hsv1[0] + s * hsv2[0];\n            if (hsvTmp[0] < 0.0) {\n              hsvTmp[0] += 1.0;\n            }\n            hsvTmp[1] = (1.0 - s) * hsv1[1] + s * hsv2[1];\n            hsvTmp[2] = (1.0 - s) * hsv1[2] + s * hsv2[2];\n\n            // Now convert this back to RGB\n            hsv2rgb(hsvTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.LAB) {\n            const lab1 = [];\n            const lab2 = [];\n            rgb2lab(rgb1, lab1);\n            rgb2lab(rgb2, lab2);\n            const labTmp = [];\n            labTmp[0] = (1 - s) * lab1[0] + s * lab2[0];\n            labTmp[1] = (1 - s) * lab1[1] + s * lab2[1];\n            labTmp[2] = (1 - s) * lab1[2] + s * lab2[2];\n\n            // Now convert back to RGB\n            lab2rgb(labTmp, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else if (model.colorSpace === ColorSpace.DIVERGING) {\n            vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n            table[tidx] = tmpVec[0];\n            table[tidx + 1] = tmpVec[1];\n            table[tidx + 2] = tmpVec[2];\n          } else {\n            vtkErrorMacro('ColorSpace set to invalid value.', model.colorSpace);\n          }\n          continue;\n        }\n\n        // We have a sharpness between [0.01, 0.99] - we will\n        // used a modified hermite curve interpolation where we\n        // derive the slope based on the sharpness, and we compress\n        // the curve non-linearly based on the sharpness\n\n        // First, we will adjust our position based on sharpness in\n        // order to make the curve sharper (closer to piecewise constant)\n        if (s < 0.5) {\n          s = 0.5 * (s * 2.0) ** (1.0 + 10.0 * sharpness);\n        } else if (s > 0.5) {\n          s = 1.0 - 0.5 * ((1.0 - s) * 2) ** (1 + 10.0 * sharpness);\n        }\n\n        // Compute some coefficients we will need for the hermite curve\n        const ss = s * s;\n        const sss = ss * s;\n        const h1 = 2.0 * sss - 3 * ss + 1;\n        const h2 = -2 * sss + 3 * ss;\n        const h3 = sss - 2 * ss + s;\n        const h4 = sss - ss;\n        let slope;\n        let t;\n        if (model.colorSpace === ColorSpace.RGB) {\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = rgb2[j] - rgb1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            table[tidx + j] = h1 * rgb1[j] + h2 * rgb2[j] + h3 * t + h4 * t;\n          }\n        } else if (model.colorSpace === ColorSpace.HSV) {\n          const hsv1 = [];\n          const hsv2 = [];\n          rgb2hsv(rgb1, hsv1);\n          rgb2hsv(rgb2, hsv2);\n          if (model.hSVWrap && (hsv1[0] - hsv2[0] > 0.5 || hsv2[0] - hsv1[0] > 0.5)) {\n            if (hsv1[0] > hsv2[0]) {\n              hsv1[0] -= 1.0;\n            } else {\n              hsv2[0] -= 1.0;\n            }\n          }\n          const hsvTmp = [];\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = hsv2[j] - hsv1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            hsvTmp[j] = h1 * hsv1[j] + h2 * hsv2[j] + h3 * t + h4 * t;\n            if (j === 0 && hsvTmp[j] < 0.0) {\n              hsvTmp[j] += 1.0;\n            }\n          }\n          // Now convert this back to RGB\n          hsv2rgb(hsvTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.LAB) {\n          const lab1 = [];\n          const lab2 = [];\n          rgb2lab(rgb1, lab1);\n          rgb2lab(rgb2, lab2);\n          const labTmp = [];\n          for (let j = 0; j < 3; j++) {\n            // Use one slope for both end points\n            slope = lab2[j] - lab1[j];\n            t = (1.0 - sharpness) * slope;\n\n            // Compute the value\n            labTmp[j] = h1 * lab1[j] + h2 * lab2[j] + h3 * t + h4 * t;\n          }\n          // Now convert this back to RGB\n          lab2rgb(labTmp, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else if (model.colorSpace === ColorSpace.DIVERGING) {\n          // I have not implemented proper interpolation by a hermite curve for\n          // the diverging color map, but I cannot think of a good use case for\n          // that anyway.\n          vtkColorTransferFunctionInterpolateDiverging(s, rgb1, rgb2, tmpVec);\n          table[tidx] = tmpVec[0];\n          table[tidx + 1] = tmpVec[1];\n          table[tidx + 2] = tmpVec[2];\n        } else {\n          vtkErrorMacro('ColorSpace set to invalid value.');\n        }\n\n        // Final error check to make sure we don't go outside [0,1]\n        for (let j = 0; j < 3; j++) {\n          table[tidx + j] = table[tidx + j] < 0.0 ? 0.0 : table[tidx + j];\n          table[tidx + j] = table[tidx + j] > 1.0 ? 1.0 : table[tidx + j];\n        }\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getUint8Table = function (xStart, xEnd, size) {\n    let withAlpha = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    if (publicAPI.getMTime() <= model.buildTime && model.tableSize === size && model.tableWithAlpha !== withAlpha) {\n      return model.table;\n    }\n    if (model.nodes.length === 0) {\n      vtkErrorMacro('Attempting to lookup a value with no points in the function');\n      return model.table;\n    }\n    const nbChannels = withAlpha ? 4 : 3;\n    if (model.tableSize !== size || model.tableWithAlpha !== withAlpha) {\n      model.table = new Uint8Array(size * nbChannels);\n      model.tableSize = size;\n      model.tableWithAlpha = withAlpha;\n    }\n    const tmpTable = [];\n    publicAPI.getTable(xStart, xEnd, size, tmpTable);\n    for (let i = 0; i < size; i++) {\n      model.table[i * nbChannels + 0] = Math.floor(tmpTable[i * 3 + 0] * 255.0 + 0.5);\n      model.table[i * nbChannels + 1] = Math.floor(tmpTable[i * 3 + 1] * 255.0 + 0.5);\n      model.table[i * nbChannels + 2] = Math.floor(tmpTable[i * 3 + 2] * 255.0 + 0.5);\n      if (withAlpha) {\n        model.table[i * nbChannels + 3] = 255;\n      }\n    }\n    model.buildTime.modified();\n    return model.table;\n  };\n  publicAPI.buildFunctionFromArray = array => {\n    publicAPI.removeAllPoints();\n    const numComponents = array.getNumberOfComponents();\n    for (let i = 0; i < array.getNumberOfTuples(); i++) {\n      switch (numComponents) {\n        case 3:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n        case 4:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: 0.5,\n              sharpness: 0.0\n            });\n            break;\n          }\n        case 5:\n          {\n            model.nodes.push({\n              x: i,\n              r: array.getComponent(i, 0),\n              g: array.getComponent(i, 1),\n              b: array.getComponent(i, 2),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n        case 6:\n          {\n            model.nodes.push({\n              x: array.getComponent(i, 0),\n              r: array.getComponent(i, 1),\n              g: array.getComponent(i, 2),\n              b: array.getComponent(i, 3),\n              midpoint: array.getComponent(i, 4),\n              sharpness: array.getComponent(i, 5)\n            });\n            break;\n          }\n      }\n    }\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.buildFunctionFromTable = (xStart, xEnd, size, table) => {\n    let inc = 0.0;\n    publicAPI.removeAllPoints();\n    if (size > 1) {\n      inc = (xEnd - xStart) / (size - 1.0);\n    }\n    for (let i = 0; i < size; i++) {\n      const node = {\n        x: xStart + inc * i,\n        r: table[i * 3],\n        g: table[i * 3 + 1],\n        b: table[i * 3 + 2],\n        sharpness: 0.0,\n        midpoint: 0.5\n      };\n      model.nodes.push(node);\n    }\n    publicAPI.sortAndUpdateRange();\n  };\n\n  //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n  publicAPI.getNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    val[0] = model.nodes[index].x;\n    val[1] = model.nodes[index].r;\n    val[2] = model.nodes[index].g;\n    val[3] = model.nodes[index].b;\n    val[4] = model.nodes[index].midpoint;\n    val[5] = model.nodes[index].sharpness;\n    return 1;\n  };\n\n  //----------------------------------------------------------------------------\n  // For a specified index value, get the node parameters\n  publicAPI.setNodeValue = (index, val) => {\n    if (index < 0 || index >= model.nodes.length) {\n      vtkErrorMacro('Index out of range!');\n      return -1;\n    }\n    const oldX = model.nodes[index].x;\n    model.nodes[index].x = val[0];\n    model.nodes[index].r = val[1];\n    model.nodes[index].g = val[2];\n    model.nodes[index].b = val[3];\n    model.nodes[index].midpoint = val[4];\n    model.nodes[index].sharpness = val[5];\n    if (oldX !== val[0]) {\n      // The point has been moved, the order of points or the range might have\n      // been modified.\n      publicAPI.sortAndUpdateRange();\n      // No need to call Modified() here because SortAndUpdateRange() has done it\n      // already.\n    } else {\n      publicAPI.modified();\n    }\n    return 1;\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getNumberOfAvailableColors = () => {\n    if (model.indexedLookup && publicAPI.getSize()) {\n      return publicAPI.getSize();\n    }\n    if (model.tableSize) {\n      // Not sure if this is correct since it is only set if\n      // \"const unsigned char *::GetTable(double xStart, double xEnd,int size)\"\n      // has been called.\n      return model.tableSize;\n    }\n    const nNodes = model.nodes?.length ?? 0;\n    // The minimum is 4094 colors so that it fills in the 4096 texels texture in `mapScalarsToTexture`\n    return Math.max(4094, nNodes);\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.getIndexedColor = (idx, rgba) => {\n    const n = publicAPI.getSize();\n    if (n > 0 && idx >= 0) {\n      const nodeValue = [];\n      publicAPI.getNodeValue(idx % n, nodeValue);\n      for (let j = 0; j < 3; ++j) {\n        rgba[j] = nodeValue[j + 1];\n      }\n      rgba[3] = 1.0; // NodeColor is RGB-only.\n      return;\n    }\n    const nanColor = publicAPI.getNanColorByReference();\n    rgba[0] = nanColor[0];\n    rgba[1] = nanColor[1];\n    rgba[2] = nanColor[2];\n    rgba[3] = 1.0; // NanColor is RGB-only.\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.fillFromDataPointer = (nb, ptr) => {\n    if (nb <= 0 || !ptr) {\n      return;\n    }\n    publicAPI.removeAllPoints();\n    for (let i = 0; i < nb; i++) {\n      publicAPI.addRGBPoint(ptr[i * 4], ptr[i * 4 + 1], ptr[i * 4 + 2], ptr[i * 4 + 3]);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.setMappingRange = (min, max) => {\n    const range = [min, max];\n    const originalRange = publicAPI.getRange();\n    if (originalRange[1] === range[1] && originalRange[0] === range[0]) {\n      return;\n    }\n    if (range[1] === range[0]) {\n      vtkErrorMacro('attempt to set zero width color range');\n      return;\n    }\n    const scale = (range[1] - range[0]) / (originalRange[1] - originalRange[0]);\n    const shift = range[0] - originalRange[0] * scale;\n    for (let i = 0; i < model.nodes.length; ++i) {\n      model.nodes[i].x = model.nodes[i].x * scale + shift;\n    }\n    model.mappingRange[0] = range[0];\n    model.mappingRange[1] = range[1];\n    publicAPI.modified();\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.adjustRange = range => {\n    const functionRange = publicAPI.getRange();\n\n    // Make sure we have points at each end of the range\n    const rgb = [];\n    if (functionRange[0] < range[0]) {\n      publicAPI.getColor(range[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[0], rgb);\n      publicAPI.addRGBPoint(range[0], rgb[0], rgb[1], rgb[2]);\n    }\n    if (functionRange[1] > range[1]) {\n      publicAPI.getColor(range[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    } else {\n      publicAPI.getColor(functionRange[1], rgb);\n      publicAPI.addRGBPoint(range[1], rgb[0], rgb[1], rgb[2]);\n    }\n\n    // Remove all points out-of-range\n    publicAPI.sortAndUpdateRange();\n    for (let i = 0; i < model.nodes.length;) {\n      if (model.nodes[i].x >= range[0] && model.nodes[i].x <= range[1]) {\n        model.nodes.splice(i, 1);\n      } else {\n        ++i;\n      }\n    }\n    return 1;\n  };\n\n  //--------------------------------------------------------------------------\n  publicAPI.estimateMinNumberOfSamples = (x1, x2) => {\n    const d = publicAPI.findMinimumXDistance();\n    return Math.ceil((x2 - x1) / d);\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.findMinimumXDistance = () => {\n    if (model.nodes.length < 2) {\n      return -1.0;\n    }\n    let distance = Number.MAX_VALUE;\n    for (let i = 0; i < model.nodes.length - 1; i++) {\n      const currentDist = model.nodes[i + 1].x - model.nodes[i].x;\n      if (currentDist < distance) {\n        distance = currentDist;\n      }\n    }\n    return distance;\n  };\n  publicAPI.mapScalarsThroughTable = (input, output, outFormat, inputOffset) => {\n    if (publicAPI.getSize() === 0) {\n      vtkDebugMacro('Transfer Function Has No Points!');\n      return;\n    }\n    if (model.indexedLookup) {\n      publicAPI.mapDataIndexed(input, output, outFormat, inputOffset);\n    } else {\n      publicAPI.mapData(input, output, outFormat, inputOffset);\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.mapData = (input, output, outFormat, inputOffset) => {\n    if (publicAPI.getSize() === 0) {\n      vtkWarningMacro('Transfer Function Has No Points!');\n      return;\n    }\n    const alpha = Math.floor(publicAPI.getAlpha() * 255.0 + 0.5);\n    const length = input.getNumberOfTuples();\n    const inIncr = input.getNumberOfComponents();\n    const outputV = output.getData();\n    const inputV = input.getData();\n    const rgb = [];\n    if (outFormat === ScalarMappingTarget.RGBA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 4] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 4 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 4 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n        outputV[i * 4 + 3] = alpha;\n      }\n    }\n    if (outFormat === ScalarMappingTarget.RGB) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 3] = Math.floor(rgb[0] * 255.0 + 0.5);\n        outputV[i * 3 + 1] = Math.floor(rgb[1] * 255.0 + 0.5);\n        outputV[i * 3 + 2] = Math.floor(rgb[2] * 255.0 + 0.5);\n      }\n    }\n    if (outFormat === ScalarMappingTarget.LUMINANCE) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n      }\n    }\n    if (outFormat === ScalarMappingTarget.LUMINANCE_ALPHA) {\n      for (let i = 0; i < length; i++) {\n        const x = inputV[i * inIncr + inputOffset];\n        publicAPI.getColor(x, rgb);\n        outputV[i * 2] = Math.floor(rgb[0] * 76.5 + rgb[1] * 150.45 + rgb[2] * 28.05 + 0.5);\n        outputV[i * 2 + 1] = alpha;\n      }\n    }\n  };\n\n  //----------------------------------------------------------------------------\n  publicAPI.applyColorMap = colorMap => {\n    const oldColorSpace = JSON.stringify(model.colorSpace);\n    if (colorMap.ColorSpace) {\n      model.colorSpace = ColorSpace[colorMap.ColorSpace.toUpperCase()];\n      if (model.colorSpace === undefined) {\n        vtkErrorMacro(`ColorSpace ${colorMap.ColorSpace} not supported, using RGB instead`);\n        model.colorSpace = ColorSpace.RGB;\n      }\n    }\n    let isModified = oldColorSpace !== JSON.stringify(model.colorSpace);\n    const oldNanColor = isModified || JSON.stringify(model.nanColor);\n    if (colorMap.NanColor) {\n      model.nanColor = [].concat(colorMap.NanColor);\n      while (model.nanColor.length < 4) {\n        model.nanColor.push(1.0);\n      }\n    }\n    isModified = isModified || oldNanColor !== JSON.stringify(model.nanColor);\n    const oldNodes = isModified || JSON.stringify(model.nodes);\n    if (colorMap.RGBPoints) {\n      const size = colorMap.RGBPoints.length;\n      model.nodes = [];\n      const midpoint = 0.5;\n      const sharpness = 0.0;\n      for (let i = 0; i < size; i += 4) {\n        model.nodes.push({\n          x: colorMap.RGBPoints[i],\n          r: colorMap.RGBPoints[i + 1],\n          g: colorMap.RGBPoints[i + 2],\n          b: colorMap.RGBPoints[i + 3],\n          midpoint,\n          sharpness\n        });\n      }\n    }\n    const modifiedInvoked = publicAPI.sortAndUpdateRange();\n    const callModified = !modifiedInvoked && (isModified || oldNodes !== JSON.stringify(model.nodes));\n    if (callModified) publicAPI.modified();\n    return modifiedInvoked || callModified;\n  };\n}\n\n// ----------------------------------------------------------------------------\n// Object factory\n// ----------------------------------------------------------------------------\n\nconst DEFAULT_VALUES = {\n  clamping: true,\n  colorSpace: ColorSpace.RGB,\n  hSVWrap: true,\n  scale: Scale.LINEAR,\n  nanColor: null,\n  belowRangeColor: null,\n  aboveRangeColor: null,\n  useAboveRangeColor: false,\n  useBelowRangeColor: false,\n  allowDuplicateScalars: false,\n  table: null,\n  tableSize: 0,\n  buildTime: null,\n  nodes: null,\n  discretize: false,\n  numberOfValues: 256\n};\n\n// ----------------------------------------------------------------------------\n\nfunction extend(publicAPI, model) {\n  let initialValues = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  Object.assign(model, DEFAULT_VALUES, initialValues);\n\n  // Inheritance\n  vtkScalarsToColors.extend(publicAPI, model, initialValues);\n\n  // Internal objects initialization\n  model.table = [];\n  model.nodes = [];\n  model.nanColor = [0.5, 0.0, 0.0, 1.0];\n  model.belowRangeColor = [0.0, 0.0, 0.0, 1.0];\n  model.aboveRangeColor = [1.0, 1.0, 1.0, 1.0];\n  model.buildTime = {};\n  macro.obj(model.buildTime);\n\n  // Create get-only macros\n  macro.get(publicAPI, model, ['buildTime', 'mappingRange']);\n\n  // Create get-set macros\n  macro.setGet(publicAPI, model, ['useAboveRangeColor', 'useBelowRangeColor', 'discretize', 'numberOfValues', {\n    type: 'enum',\n    name: 'colorSpace',\n    enum: ColorSpace\n  }, {\n    type: 'enum',\n    name: 'scale',\n    enum: Scale\n  }]);\n  macro.setArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor'], 4);\n\n  // Create get macros for array\n  macro.getArray(publicAPI, model, ['nanColor', 'belowRangeColor', 'aboveRangeColor']);\n\n  // For more macro methods, see \"Sources/macros.js\"\n\n  // Object specific methods\n  vtkColorTransferFunction(publicAPI, model);\n}\n\n// ----------------------------------------------------------------------------\n\nconst newInstance = macro.newInstance(extend, 'vtkColorTransferFunction');\n\n// ----------------------------------------------------------------------------\n\nvar vtkColorTransferFunction$1 = {\n  newInstance,\n  extend,\n  ...Constants\n};\n\nexport { vtkColorTransferFunction$1 as default, extend, newInstance };\n","import * as glMatrix from \"./common.js\";\n/**\n * 3 Dimensional Vector\n * @module vec3\n */\n\n/**\n * Creates a new, empty vec3\n *\n * @returns {vec3} a new 3D vector\n */\n\nexport function create() {\n  var out = new glMatrix.ARRAY_TYPE(3);\n\n  if (glMatrix.ARRAY_TYPE != Float32Array) {\n    out[0] = 0;\n    out[1] = 0;\n    out[2] = 0;\n  }\n\n  return out;\n}\n/**\n * Creates a new vec3 initialized with values from an existing vector\n *\n * @param {ReadonlyVec3} a vector to clone\n * @returns {vec3} a new 3D vector\n */\n\nexport function clone(a) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Calculates the length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate length of\n * @returns {Number} length of a\n */\n\nexport function length(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Creates a new vec3 initialized with the given values\n *\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} a new 3D vector\n */\n\nexport function fromValues(x, y, z) {\n  var out = new glMatrix.ARRAY_TYPE(3);\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Copy the values from one vec3 to another\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the source vector\n * @returns {vec3} out\n */\n\nexport function copy(out, a) {\n  out[0] = a[0];\n  out[1] = a[1];\n  out[2] = a[2];\n  return out;\n}\n/**\n * Set the components of a vec3 to the given values\n *\n * @param {vec3} out the receiving vector\n * @param {Number} x X component\n * @param {Number} y Y component\n * @param {Number} z Z component\n * @returns {vec3} out\n */\n\nexport function set(out, x, y, z) {\n  out[0] = x;\n  out[1] = y;\n  out[2] = z;\n  return out;\n}\n/**\n * Adds two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function add(out, a, b) {\n  out[0] = a[0] + b[0];\n  out[1] = a[1] + b[1];\n  out[2] = a[2] + b[2];\n  return out;\n}\n/**\n * Subtracts vector b from vector a\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function subtract(out, a, b) {\n  out[0] = a[0] - b[0];\n  out[1] = a[1] - b[1];\n  out[2] = a[2] - b[2];\n  return out;\n}\n/**\n * Multiplies two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function multiply(out, a, b) {\n  out[0] = a[0] * b[0];\n  out[1] = a[1] * b[1];\n  out[2] = a[2] * b[2];\n  return out;\n}\n/**\n * Divides two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function divide(out, a, b) {\n  out[0] = a[0] / b[0];\n  out[1] = a[1] / b[1];\n  out[2] = a[2] / b[2];\n  return out;\n}\n/**\n * Math.ceil the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to ceil\n * @returns {vec3} out\n */\n\nexport function ceil(out, a) {\n  out[0] = Math.ceil(a[0]);\n  out[1] = Math.ceil(a[1]);\n  out[2] = Math.ceil(a[2]);\n  return out;\n}\n/**\n * Math.floor the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to floor\n * @returns {vec3} out\n */\n\nexport function floor(out, a) {\n  out[0] = Math.floor(a[0]);\n  out[1] = Math.floor(a[1]);\n  out[2] = Math.floor(a[2]);\n  return out;\n}\n/**\n * Returns the minimum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function min(out, a, b) {\n  out[0] = Math.min(a[0], b[0]);\n  out[1] = Math.min(a[1], b[1]);\n  out[2] = Math.min(a[2], b[2]);\n  return out;\n}\n/**\n * Returns the maximum of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function max(out, a, b) {\n  out[0] = Math.max(a[0], b[0]);\n  out[1] = Math.max(a[1], b[1]);\n  out[2] = Math.max(a[2], b[2]);\n  return out;\n}\n/**\n * Math.round the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to round\n * @returns {vec3} out\n */\n\nexport function round(out, a) {\n  out[0] = Math.round(a[0]);\n  out[1] = Math.round(a[1]);\n  out[2] = Math.round(a[2]);\n  return out;\n}\n/**\n * Scales a vec3 by a scalar number\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to scale\n * @param {Number} b amount to scale the vector by\n * @returns {vec3} out\n */\n\nexport function scale(out, a, b) {\n  out[0] = a[0] * b;\n  out[1] = a[1] * b;\n  out[2] = a[2] * b;\n  return out;\n}\n/**\n * Adds two vec3's after scaling the second operand by a scalar value\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} scale the amount to scale b by before adding\n * @returns {vec3} out\n */\n\nexport function scaleAndAdd(out, a, b, scale) {\n  out[0] = a[0] + b[0] * scale;\n  out[1] = a[1] + b[1] * scale;\n  out[2] = a[2] + b[2] * scale;\n  return out;\n}\n/**\n * Calculates the euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} distance between a and b\n */\n\nexport function distance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return Math.hypot(x, y, z);\n}\n/**\n * Calculates the squared euclidian distance between two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} squared distance between a and b\n */\n\nexport function squaredDistance(a, b) {\n  var x = b[0] - a[0];\n  var y = b[1] - a[1];\n  var z = b[2] - a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Calculates the squared length of a vec3\n *\n * @param {ReadonlyVec3} a vector to calculate squared length of\n * @returns {Number} squared length of a\n */\n\nexport function squaredLength(a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  return x * x + y * y + z * z;\n}\n/**\n * Negates the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to negate\n * @returns {vec3} out\n */\n\nexport function negate(out, a) {\n  out[0] = -a[0];\n  out[1] = -a[1];\n  out[2] = -a[2];\n  return out;\n}\n/**\n * Returns the inverse of the components of a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to invert\n * @returns {vec3} out\n */\n\nexport function inverse(out, a) {\n  out[0] = 1.0 / a[0];\n  out[1] = 1.0 / a[1];\n  out[2] = 1.0 / a[2];\n  return out;\n}\n/**\n * Normalize a vec3\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a vector to normalize\n * @returns {vec3} out\n */\n\nexport function normalize(out, a) {\n  var x = a[0];\n  var y = a[1];\n  var z = a[2];\n  var len = x * x + y * y + z * z;\n\n  if (len > 0) {\n    //TODO: evaluate use of glm_invsqrt here?\n    len = 1 / Math.sqrt(len);\n  }\n\n  out[0] = a[0] * len;\n  out[1] = a[1] * len;\n  out[2] = a[2] * len;\n  return out;\n}\n/**\n * Calculates the dot product of two vec3's\n *\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {Number} dot product of a and b\n */\n\nexport function dot(a, b) {\n  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n}\n/**\n * Computes the cross product of two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @returns {vec3} out\n */\n\nexport function cross(out, a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2];\n  var bx = b[0],\n      by = b[1],\n      bz = b[2];\n  out[0] = ay * bz - az * by;\n  out[1] = az * bx - ax * bz;\n  out[2] = ax * by - ay * bx;\n  return out;\n}\n/**\n * Performs a linear interpolation between two vec3's\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function lerp(out, a, b, t) {\n  var ax = a[0];\n  var ay = a[1];\n  var az = a[2];\n  out[0] = ax + t * (b[0] - ax);\n  out[1] = ay + t * (b[1] - ay);\n  out[2] = az + t * (b[2] - az);\n  return out;\n}\n/**\n * Performs a hermite interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function hermite(out, a, b, c, d, t) {\n  var factorTimes2 = t * t;\n  var factor1 = factorTimes2 * (2 * t - 3) + 1;\n  var factor2 = factorTimes2 * (t - 2) + t;\n  var factor3 = factorTimes2 * (t - 1);\n  var factor4 = factorTimes2 * (3 - 2 * t);\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Performs a bezier interpolation with two control points\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the first operand\n * @param {ReadonlyVec3} b the second operand\n * @param {ReadonlyVec3} c the third operand\n * @param {ReadonlyVec3} d the fourth operand\n * @param {Number} t interpolation amount, in the range [0-1], between the two inputs\n * @returns {vec3} out\n */\n\nexport function bezier(out, a, b, c, d, t) {\n  var inverseFactor = 1 - t;\n  var inverseFactorTimesTwo = inverseFactor * inverseFactor;\n  var factorTimes2 = t * t;\n  var factor1 = inverseFactorTimesTwo * inverseFactor;\n  var factor2 = 3 * t * inverseFactorTimesTwo;\n  var factor3 = 3 * factorTimes2 * inverseFactor;\n  var factor4 = factorTimes2 * t;\n  out[0] = a[0] * factor1 + b[0] * factor2 + c[0] * factor3 + d[0] * factor4;\n  out[1] = a[1] * factor1 + b[1] * factor2 + c[1] * factor3 + d[1] * factor4;\n  out[2] = a[2] * factor1 + b[2] * factor2 + c[2] * factor3 + d[2] * factor4;\n  return out;\n}\n/**\n * Generates a random vector with the given scale\n *\n * @param {vec3} out the receiving vector\n * @param {Number} [scale] Length of the resulting vector. If ommitted, a unit vector will be returned\n * @returns {vec3} out\n */\n\nexport function random(out, scale) {\n  scale = scale || 1.0;\n  var r = glMatrix.RANDOM() * 2.0 * Math.PI;\n  var z = glMatrix.RANDOM() * 2.0 - 1.0;\n  var zScale = Math.sqrt(1.0 - z * z) * scale;\n  out[0] = Math.cos(r) * zScale;\n  out[1] = Math.sin(r) * zScale;\n  out[2] = z * scale;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat4.\n * 4th vector component is implicitly '1'\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat4} m matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat4(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  var w = m[3] * x + m[7] * y + m[11] * z + m[15];\n  w = w || 1.0;\n  out[0] = (m[0] * x + m[4] * y + m[8] * z + m[12]) / w;\n  out[1] = (m[1] * x + m[5] * y + m[9] * z + m[13]) / w;\n  out[2] = (m[2] * x + m[6] * y + m[10] * z + m[14]) / w;\n  return out;\n}\n/**\n * Transforms the vec3 with a mat3.\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyMat3} m the 3x3 matrix to transform with\n * @returns {vec3} out\n */\n\nexport function transformMat3(out, a, m) {\n  var x = a[0],\n      y = a[1],\n      z = a[2];\n  out[0] = x * m[0] + y * m[3] + z * m[6];\n  out[1] = x * m[1] + y * m[4] + z * m[7];\n  out[2] = x * m[2] + y * m[5] + z * m[8];\n  return out;\n}\n/**\n * Transforms the vec3 with a quat\n * Can also be used for dual quaternions. (Multiply it with the real part)\n *\n * @param {vec3} out the receiving vector\n * @param {ReadonlyVec3} a the vector to transform\n * @param {ReadonlyQuat} q quaternion to transform with\n * @returns {vec3} out\n */\n\nexport function transformQuat(out, a, q) {\n  // benchmarks: https://jsperf.com/quaternion-transform-vec3-implementations-fixed\n  var qx = q[0],\n      qy = q[1],\n      qz = q[2],\n      qw = q[3];\n  var x = a[0],\n      y = a[1],\n      z = a[2]; // var qvec = [qx, qy, qz];\n  // var uv = vec3.cross([], qvec, a);\n\n  var uvx = qy * z - qz * y,\n      uvy = qz * x - qx * z,\n      uvz = qx * y - qy * x; // var uuv = vec3.cross([], qvec, uv);\n\n  var uuvx = qy * uvz - qz * uvy,\n      uuvy = qz * uvx - qx * uvz,\n      uuvz = qx * uvy - qy * uvx; // vec3.scale(uv, uv, 2 * w);\n\n  var w2 = qw * 2;\n  uvx *= w2;\n  uvy *= w2;\n  uvz *= w2; // vec3.scale(uuv, uuv, 2);\n\n  uuvx *= 2;\n  uuvy *= 2;\n  uuvz *= 2; // return vec3.add(out, a, vec3.add(out, uv, uuv));\n\n  out[0] = x + uvx + uuvx;\n  out[1] = y + uvy + uuvy;\n  out[2] = z + uvz + uuvz;\n  return out;\n}\n/**\n * Rotate a 3D vector around the x-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateX(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0];\n  r[1] = p[1] * Math.cos(rad) - p[2] * Math.sin(rad);\n  r[2] = p[1] * Math.sin(rad) + p[2] * Math.cos(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the y-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateY(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[2] * Math.sin(rad) + p[0] * Math.cos(rad);\n  r[1] = p[1];\n  r[2] = p[2] * Math.cos(rad) - p[0] * Math.sin(rad); //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Rotate a 3D vector around the z-axis\n * @param {vec3} out The receiving vec3\n * @param {ReadonlyVec3} a The vec3 point to rotate\n * @param {ReadonlyVec3} b The origin of the rotation\n * @param {Number} rad The angle of rotation in radians\n * @returns {vec3} out\n */\n\nexport function rotateZ(out, a, b, rad) {\n  var p = [],\n      r = []; //Translate point to the origin\n\n  p[0] = a[0] - b[0];\n  p[1] = a[1] - b[1];\n  p[2] = a[2] - b[2]; //perform rotation\n\n  r[0] = p[0] * Math.cos(rad) - p[1] * Math.sin(rad);\n  r[1] = p[0] * Math.sin(rad) + p[1] * Math.cos(rad);\n  r[2] = p[2]; //translate to correct position\n\n  out[0] = r[0] + b[0];\n  out[1] = r[1] + b[1];\n  out[2] = r[2] + b[2];\n  return out;\n}\n/**\n * Get the angle between two 3D vectors\n * @param {ReadonlyVec3} a The first operand\n * @param {ReadonlyVec3} b The second operand\n * @returns {Number} The angle in radians\n */\n\nexport function angle(a, b) {\n  var ax = a[0],\n      ay = a[1],\n      az = a[2],\n      bx = b[0],\n      by = b[1],\n      bz = b[2],\n      mag1 = Math.sqrt(ax * ax + ay * ay + az * az),\n      mag2 = Math.sqrt(bx * bx + by * by + bz * bz),\n      mag = mag1 * mag2,\n      cosine = mag && dot(a, b) / mag;\n  return Math.acos(Math.min(Math.max(cosine, -1), 1));\n}\n/**\n * Set the components of a vec3 to zero\n *\n * @param {vec3} out the receiving vector\n * @returns {vec3} out\n */\n\nexport function zero(out) {\n  out[0] = 0.0;\n  out[1] = 0.0;\n  out[2] = 0.0;\n  return out;\n}\n/**\n * Returns a string representation of a vector\n *\n * @param {ReadonlyVec3} a vector to represent as a string\n * @returns {String} string representation of the vector\n */\n\nexport function str(a) {\n  return \"vec3(\" + a[0] + \", \" + a[1] + \", \" + a[2] + \")\";\n}\n/**\n * Returns whether or not the vectors have exactly the same elements in the same position (when compared with ===)\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function exactEquals(a, b) {\n  return a[0] === b[0] && a[1] === b[1] && a[2] === b[2];\n}\n/**\n * Returns whether or not the vectors have approximately the same elements in the same position.\n *\n * @param {ReadonlyVec3} a The first vector.\n * @param {ReadonlyVec3} b The second vector.\n * @returns {Boolean} True if the vectors are equal, false otherwise.\n */\n\nexport function equals(a, b) {\n  var a0 = a[0],\n      a1 = a[1],\n      a2 = a[2];\n  var b0 = b[0],\n      b1 = b[1],\n      b2 = b[2];\n  return Math.abs(a0 - b0) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a0), Math.abs(b0)) && Math.abs(a1 - b1) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a1), Math.abs(b1)) && Math.abs(a2 - b2) <= glMatrix.EPSILON * Math.max(1.0, Math.abs(a2), Math.abs(b2));\n}\n/**\n * Alias for {@link vec3.subtract}\n * @function\n */\n\nexport var sub = subtract;\n/**\n * Alias for {@link vec3.multiply}\n * @function\n */\n\nexport var mul = multiply;\n/**\n * Alias for {@link vec3.divide}\n * @function\n */\n\nexport var div = divide;\n/**\n * Alias for {@link vec3.distance}\n * @function\n */\n\nexport var dist = distance;\n/**\n * Alias for {@link vec3.squaredDistance}\n * @function\n */\n\nexport var sqrDist = squaredDistance;\n/**\n * Alias for {@link vec3.length}\n * @function\n */\n\nexport var len = length;\n/**\n * Alias for {@link vec3.squaredLength}\n * @function\n */\n\nexport var sqrLen = squaredLength;\n/**\n * Perform some operation over an array of vec3s.\n *\n * @param {Array} a the array of vectors to iterate over\n * @param {Number} stride Number of elements between the start of each vec3. If 0 assumes tightly packed\n * @param {Number} offset Number of elements to skip at the beginning of the array\n * @param {Number} count Number of vec3s to iterate over. If 0 iterates over entire array\n * @param {Function} fn Function to call for each vector in the array\n * @param {Object} [arg] additional argument to pass to fn\n * @returns {Array} a\n * @function\n */\n\nexport var forEach = function () {\n  var vec = create();\n  return function (a, stride, offset, count, fn, arg) {\n    var i, l;\n\n    if (!stride) {\n      stride = 3;\n    }\n\n    if (!offset) {\n      offset = 0;\n    }\n\n    if (count) {\n      l = Math.min(count * stride + offset, a.length);\n    } else {\n      l = a.length;\n    }\n\n    for (i = offset; i < l; i += stride) {\n      vec[0] = a[i];\n      vec[1] = a[i + 1];\n      vec[2] = a[i + 2];\n      fn(vec, vec, arg);\n      a[i] = vec[0];\n      a[i + 1] = vec[1];\n      a[i + 2] = vec[2];\n    }\n\n    return a;\n  };\n}();","import ascending from \"./ascending.js\";\nimport descending from \"./descending.js\";\n\nexport default function bisector(f) {\n  let compare1, compare2, delta;\n\n  // If an accessor is specified, promote it to a comparator. In this case we\n  // can test whether the search value is (self-) comparable. We cant do this\n  // for a comparator (except for specific, known comparators) because we cant\n  // tell if the comparator is symmetric, and an asymmetric comparator cant be\n  // used to test whether a single value is comparable.\n  if (f.length !== 2) {\n    compare1 = ascending;\n    compare2 = (d, x) => ascending(f(d), x);\n    delta = (d, x) => f(d) - x;\n  } else {\n    compare1 = f === ascending || f === descending ? f : zero;\n    compare2 = f;\n    delta = f;\n  }\n\n  function left(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) < 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function right(a, x, lo = 0, hi = a.length) {\n    if (lo < hi) {\n      if (compare1(x, x) !== 0) return hi;\n      do {\n        const mid = (lo + hi) >>> 1;\n        if (compare2(a[mid], x) <= 0) lo = mid + 1;\n        else hi = mid;\n      } while (lo < hi);\n    }\n    return lo;\n  }\n\n  function center(a, x, lo = 0, hi = a.length) {\n    const i = left(a, x, lo, hi - 1);\n    return i > lo && delta(a[i - 1], x) > -delta(a[i], x) ? i - 1 : i;\n  }\n\n  return {left, center, right};\n}\n\nfunction zero() {\n  return 0;\n}\n","import transpose from \"./transpose.js\";\n\nexport default function zip() {\n  return transpose(arguments);\n}\n","export default x => () => x;\n","export default function(a, b) {\n  return a = +a, b = +b, function(t) {\n    return a * (1 - t) + b * t;\n  };\n}\n","export default function(interpolator, n) {\n  var samples = new Array(n);\n  for (var i = 0; i < n; ++i) samples[i] = interpolator(i / (n - 1));\n  return samples;\n}\n","export default function(a, b) {\n  return a = +a, b = +b, function(t) {\n    return Math.round(a * (1 - t) + b * t);\n  };\n}\n"],"names":["enabledElement","invalidated","image","canvas","start","stats","lastGetPixelDataTime","lastStoredPixelDataToCanvasImageDataTime","lastPutImageDataTime","lastRenderTime","lastLutGenerateTime","render","viewport","colormap","color","renderTimeInMs","invalid","needsRedraw","scale","transform","displayedArea","translate","width","height","angle","rotation","rotate","Math","PI","widthScale","heightScale","brhc","x","tlhc","y","presentationSizeMode","rowPixelSpacing","columnPixelSpacing","verticalScale","horizontalScale","min","translation","undefined","hflip","vflip","modality","Error","scaleFactor","voi","isPreScaled","windowWidth","windowCenter","Array","isArray","invert","pixelReplication","modalityLUT","voiLUT","columns","rows","GenerateImageType","DEFAULT_SETTINGS","Symbol","RUNTIME_SETTINGS","OBJECT_SETTINGS_MAP","DICTIONARY","Settings","constructor","base","dictionary","Object","create","seal","defineProperty","this","value","set","key","get","unset","name","endsWith","deleteCount","namespace","slice","deleteAll","length","prototype","hasOwnProperty","call","startsWith","forEach","callback","iterate","extend","import","root","isPlainObject","keys","dump","context","deepSet","assert","subject","getRuntimeSettings","getDefaultSettings","subfield","defaultSettings","settingObj","setting","split","runtimeSettings","getObjectSettings","from","settings","objectSettingsMap","WeakMap","extendRuntimeSettings","references","last","current","previous","indexOf","isValidKey","prefix","record","failCount","has","add","field","delete","setAll","WeakSet","getPrototypeOf","separator","subKey","subContext","subContextValue","imageLoaders","unknownImageLoader","loadImageFromImageLoader","imageId","options","cachedImageLoadObject","getImageLoadObject","handleImageLoadPromise","promise","scheme","loader","imageLoadObject","imagePromise","Promise","resolve","then","voxelManager","numberOfComponents","createImageVoxelManager","scalarData","getPixelData","getScalarData","imageFrame","pixelData","ensureVoxelManager","IMAGE_LOADED","catch","error","errorDetails","IMAGE_LOAD_FAILED","loadImage","priority","requestType","loadAndCacheImage","putImageLoadObject","loadAndCacheImages","imageIds","map","createAndCacheDerivedImage","referencedImageId","skipCreateBuffer","onCacheAdd","voxelRepresentation","imagePlaneModule","TypedArrayConstructor","targetBuffer","type","imageScalarData","derivedImageId","referencedImagePlaneMetadata","metadata","referencedImageGeneralSeriesMetadata","instanceNumber","imagePixelModule","bitsAllocated","bitsStored","highBit","samplesPerPixel","pixelRepresentation","localImage","createAndCacheLocalImage","dimensions","spacing","origin","imagePositionPatient","direction","imageOrientationPatient","frameOfReferenceUID","putImageSync","createAndCacheDerivedImages","referencedImageIds","derivedImageIds","index","newOptions","getDerivedImageId","push","rowCosines","columnCosines","pixelSpacing","scalarDataToUse","Uint8Array","Float32Array","Uint16Array","Int16Array","photometricInterpretation","id","RLE","createRLEImageVoxelManager","minPixelValue","maxPixelValue","i","intercept","dataType","slope","getCanvas","rgba","FrameOfReferenceUID","sizeInBytes","byteLength","cancelLoadImage","filterRequests","additionalDetails","cancelFn","cancelLoadImages","cancelLoadAll","requestPool","getRequestPool","requests","requestDetails","pop","volumeId","loadObject","getVolumeLoadObject","cancel","clearRequestStack","registerImageLoader","imageLoader","registerUnknownImageLoader","oldImageLoader","unregisterAllImageLoaders","createAndCacheDerivedLabelmapImages","createAndCacheDerivedLabelmapImage","FrameRange","frameRangeExtractor","imageIdToFrames","match","range","it","Number","imageIdToFrameEnd","imageIdToFrameStart","framesToString","String","framesToImageId","newRangeString","replace","PointsManager","configuration","_dimensions","_length","_byteSize","growSize","initialSize","itemLength","array","ArrayBuffer","data","func","getPoint","dimensionLength","offset","subarray","getPointArray","grow","additionalSize","newSize","newArray","newData","reverse","midLength","floor","indexStart","indexEnd","dimension","valueStart","getTypedArray","point","f","mapData","points","p","toXYZ","xyz","z","fromXYZ","create3","subselect","count","selected","max","newPoints","create2","ProgressiveIterator","as","iterator","v","e","reject","reason","done","nextValue","waiting","rejectReason","getRecent","asyncIterator","errorCallback","console","warn","generate","processFunction","bind","nextPromise","donePromise","getNextPromise","getDonePromise","ADJACENT_ALL","ADJACENT_SINGLE_PLANE","ADJACENT_IN","ADJACENT_OUT","RLEVoxelMap","copyMap","destination","source","row","structuredClone","depth","Map","jMultiple","kMultiple","numComps","pixelDataConstructor","updateScalarData","fill","rle","end","j","getRLE","defaultValue","getRun","k","runIndex","rleIndex","findIndex","rle1","rle0","oldValue","rleInsert","isAfter","insertIndex","rlePrev","rleNext","splice","nextnext","ArrayType","Uint8ClampedArray","frameSize","toIJK","toIndex","newRle","iEnd","rowModified","baseIndex","rowToUse","forEachRow","clear","rowOffset","comp","floodFill","stack","replaceValue","flood","sourceValue","sum","planar","diagonals","singlePlane","childOptions","top","adjacents","findAdjacents","filter","adjacent","fillFrom","getter","boundsIJK","item","adjacentsDelta","leftRle","rightRle","delta","delta1","delta2","testJ","testK","testRle","newAdjacentDelta","isImageActor","actorEntry","actorIsA","actorType","actorToCheck","actor","isA","applyPreset","preset","colorTransferArray","colorTransfer","parseFloat","shiftRange","Infinity","center","getShiftRange","cfun","normColorTransferValuePoints","r","g","b","rescaled","removeAllPoints","addRGBPoint","applyPointsToRGBFunction","getProperty","setRGBTransferFunction","scalarOpacityArray","scalarOpacity","ofun","normPoints","opacity","pwf","addPoint","applyPointsToPiecewiseFunction","property","setScalarOpacity","gradientMinValue","gradientMinOpacity","gradientMaxValue","gradientMaxOpacity","gradientOpacity","setUseGradientOpacity","setGradientOpacityMinimumValue","setGradientOpacityMinimumOpacity","setGradientOpacityMaximumValue","setGradientOpacityMaximumOpacity","interpolation","setInterpolationTypeToFastLinear","setShade","shade","ambient","diffuse","specular","specularPower","setAmbient","setDiffuse","setSpecular","setSpecularPower","renderingEngineAndViewportIds","renderingEnginesArray","renderingEngine","viewports","viewportIds","getRenderingEngineAndViewportsContainingVolume","hasBeenDestroyed","renderViewports","getImagePlaneModule","newImagePlaneModule","MetadataModules","IMAGE_PLANE","buildMetadata","voiLUTFunction","imageIdScalingFactor","calibration","CALIBRATION","voiLUTFunctionEnum","values","VOILUTFunctionType","includes","LINEAR","getValidVOILUTFunction","scalingFactor","calculateSpacingBetweenImageIds","referenceImagePositionPatient","rowCosineVec","colCosineVec","scanAxisNormal","refIppVec","getDistance","positionVector","ippVec","prefetchedImageIds","metadataForMiddleImage","middleIppVec","distanceBetweenFirstAndMiddleImages","abs","distanceImagePairs","distance","sort","a","numImages","sliceThickness","spacingBetweenSlices","strictZSpacingForVolumeViewport","rendering","isNaN","debug","clamp","_colormaps","registerColormap","Name","getColormap","getColormapNames","findMatchingColormap","rgbPoints","colormapsVTK","rgbPresetNames","presetName","getPresetByName","colormapsCS3D","colormapName","matchedColormap","concat","find","RGBPoints","presetRGBPoints","opacityPoints","getScalarOpacity","getDataPointer","setColorMapTransferFunctionForVolumeActor","volumeInfo","volumeActor","threshold","colorRange","getMapper","setSampleDistance","presetToUse","applyColorMap","setMappingRange","updateOpacityWithThreshold","updateOpacity","newOpacity","getThresholdValue","updateThreshold","newThreshold","getMaxOpacity","meta","getInputData","getRange","thresholdValue","opacityFunction","dataArray","y1","x2","y2","maxOpacity","createLinearRGBTransferFunction","voiRange","lower","upper","createSigmoidRGBTransferFunction","approximationNodes","table","_","flatMap","buildFunctionFromArray","decimate","list","interleave","interleaveIndices","deepClone","obj","clonedObj","fnv1aHash","str","hash","charCodeAt","toString","log","coreLog","getLogger","getClosestImageId","imageVolume","worldPos","viewPlaneNormal","ignoreSpacing","kVector","dotProduct","EPSILON","halfSpacingInNormalDirection","closestImageId","minDistance","dir","getImageDataMetadata","xSpacing","ySpacing","xVoxels","yVoxels","zSpacing","_getNumCompsFromPhotometricInterpretation","numVoxels","camera","getCamera","spacingInNormalDirection","focalPoint","getActors","referencedId","uid","sliceRange","numberOfSlices","round","imageIndex","getScalingParameters","modalityLutModule","generalSeriesModule","scalingParameters","rescaleSlope","rescaleIntercept","scalingModules","suvbw","suvbsa","suvlbm","doseGridScaling","DoseGridScaling","doseSummation","DoseSummation","doseType","DoseType","doseUnit","DoseUnit","SMALL_EPSILON","isOne","isUnit","off","isOrthonormal","getSliceRange","imageData","corners","getDirection","dx","dy","dz","getDimensions","indexToWorld","buildFromDegree","identity","rotateFromDirections","pt","apply","transformedFocalPoint","currentSlice","minX","maxX","getSpacingInNormalDirection","iVector","jVector","dotProducts","projectedSpacing","EPSILON_PART","isPrimaryVolume","volume","getVolumeLoaderSchemes","starts","substring","getTargetVolumeAndSpacingInNormalDir","targetId","useSlabThickness","volumeActors","actorUID","imageVolumes","va","getVolume","iv","targetVolumeId","imageVolumeIndex","getSpacingInNormal","smallest","hasPrimaryVolume","slabThickness","getProperties","renderingEngines","targetViewports","filteredViewports","getVolumeViewports","vp","hasVolumeId","getVoiFromSigmoidRGBTransferFunction","cfunRange","getTable","cfunDomain","logy1","x1","logy2","ww","wc","getVolumeActorCorners","bounds","extentToBounds","getExtent","getVolumeId","getActor","numScrollSteps","floatingStepNumber","currentStepIndex","sliceRangeInfo","hasFloatScalingParameters","some","isInteger","hasNaNValues","input","imageIdToURI","colonIndex","retrieveConfigurationState","IMAGE_RETRIEVE_CONFIGURATION","imageRetrieveMetadataProvider","payload","clone","restore","state","queries","query","addProvider","EventListenerPhases","TargetEventListeners","target","_eventListeners","_children","_target","isEmpty","size","addEventListener","dotIndex","namespaceToken","childElementEventListener","_addEventListener","removeEventListener","_removeEventListener","reset","entries","child","_unregisterAllEvents","listenersMap","listenerPhase","capture","Capture","Bubble","registeredPhases","None","callbackItem","newListenerPhase","_unregisterAllListeners","listener","eventPhases","currentPhase","useCapture","MultiTargetEventListenerManager","_targetsEventListeners","eventListeners","targetEventListeners","scaleRGBTransferFunction","rgbTransferFunction","getSize","nodeValue1","getNodeValue","setNodeValue","getMinMax","storedPixelData","storedPixel","numPixels","LAST_RUNTIME_ID","GLOBAL_CONTEXT","DEFAULT_MAX","DEFAULT_SEPARATOR","getRuntimeId","symbol","idComponents","carry","n","getNextRuntimeId","join","imageURI","isOpposite","v1","v2","tolerance","indexWithinDimensions","targetViewport","renderingEngineId","getRenderingEngine","sameVolumesViewports","targetActors","vpActors","every","vpActor","preScale","scaled","renderToCanvasGPU","imageOrVolume","viewportOptions","displayArea","imageArea","HTMLCanvasElement","isVolume","viewportId","element","document","createElement","devicePixelRatio","window","originalWidth","originalHeight","style","visibility","position","body","appendChild","uniqueId","setAttribute","temporaryCanvas","getOrCreateCanvas","TiledRenderingEngine","getViewport","viewportInput","ViewportType","ORTHOGRAPHIC","STACK","defaultOptions","suppressEvents","enableElement","elementRendered","viewReference","onImageRendered","eventDetail","useViewRef","setViewReference","getContext","drawImage","canvasToWorld","topRight","bottomLeft","rightVector","downVector","Events","IMAGE_RENDERED","setTimeout","disableElement","querySelectorAll","remove","thicknessMm","setVolumes","renderImageObject","resetCamera","setProperties","renderToCanvasCPU","_renderingEngineId","_viewportOptions","getDefaultViewport","renderingTools","calculateTransform","drawImageSync","loadImageToCanvas","RequestType","Thumbnail","useCPURendering","thumbnail","imageAspect","baseViewportOptions","renderFn","successCallback","metaData","useRGBA","cache","imageLoadPoolManager","addRequest","imageIdIndex","asArray","HistoryMemo","label","redoAvailable","undoAvailable","ring","isRecordingGrouped","_size","canUndo","canRedo","undo","items","subitem","restoreMemo","dispatchHistoryEvent","isUndo","undoIf","condition","eventTarget","dispatchEvent","CustomEvent","detail","operationType","memo","redo","newPosition","initializeGroupItem","startGroupRecording","rollbackUnusedGroupItem","endGroupRecording","lastItem","pushGrouped","lastMemo","createMemo","DefaultHistoryMemo","worldCoords","newOrigin","sub","imageToWorldCoords","imageCoords","imageCoordsInWorld","getViewportsWithImageURI","getViewports","hasImageURI","getClosestStackImageIndexForPoint","minimalDistance","getImageIds","currentImageIdIndex","getCurrentImageIdIndex","planeMetadata","targetImagePlane","rowVec","colVec","planeNormal","getPlaneMetadata","plane","planeEquation","planeDistanceToPoint","closestStack","higherImageIds","lowerImageIds","calculateMinimalDistanceForStackViewport","getCurrentVolumeViewportSlice","canvasWidth","canvasHeight","sliceToIndexMatrix","indexToSliceMatrix","getSliceViewInfo","ijkOriginPoint","transformCanvasToIJK","ijkRowPoint","ijkColPoint","ijkRowVec","ijkColVec","ijkSliceVec","maxIJKRowVec","maxIJKColVec","getImageData","sliceViewInfo","getSliceData","spatialRegistrationMetadataProvider","viewportId1","viewportId2","entryId","entryIdReverse","viewport1","viewport2","imageId1","getSliceIndex","imageId2","imagePlaneModule1","imagePlaneModule2","iop2","imagePositionPatient1","imagePositionPatient2","mat","getViewportImageCornersInWorld","ratio","topRightCanvas","bottomRightCanvas","bottomLeftCanvas","topLeftWorld","topRightWorld","bottomRightWorld","bottomLeftWorld","topLeftImage","worldToIndex","topRightImage","bottomRightImage","bottomLeftImage","topLeftImageWorld","_isInBounds","topRightImageWorld","bottomRightImageWorld","bottomLeftImageWorld","_getStackViewportImageCorners","imageCoord","getEnabledElement","StackViewport","getCornerstoneImage","isValidVolume","imageId0","seriesInstanceUID","usingDefaultValues","baseMetadata","validVolume","isEqual","videoUIDs","Set","isVideoTransferSyntax","uidOrUids","async","convertStackToVolumeViewport","uuidv4","getUnknownVolumeLoaderSchema","prevViewPresentation","getViewPresentation","prevViewReference","getViewReference","background","orientation","createAndCacheVolume","load","volumeViewport","volumeViewportNewVolumeHandler","VOLUME_VIEWPORT_NEW_VOLUME","setViewPresentation","convertVolumeToStackViewport","ImageVolume","prevView","stackViewport","setStack","roundToPrecision","roundNumber","precision","absValue","fixedPrecision","toFixed","convertToGrayscale","isRGBA","isRGB","newScalarData","destOffset","increment","getRandomSampleFromArray","clonedArray","shuffleArray","random","componentToHex","c","hex","rgbToHex","hexToRgb","result","exec","parseInt","deepEqual","obj1","obj2","JSON","stringify","test4DTag","IPPGroups","value_getter","frame_groups","first_frame_value_set","positions","frame_value_set","frames","frame_value","setEquals","getTagValue","tag","getPhilipsPrivateBValue","InlineBinary","value_bytes","atob","ary_buf","dv","DataView","setUint8","getSiemensPrivateBValue","getGEPrivateBValue","set_a","set_b","getPetFrameReferenceTime","moduleInfo","positionGroups","ippMetadata","reduce","rv","frame_count","getIPPGroups","imageIdGroups","splittingTag","tags","fncList2","timePoints","isDynamicVolume","scaleArray","arrayLength","clip","val","low","high","scrollSlabs","getVolumeViewportScrollInfo","newFocalPoint","snapFocalPointToSlice","setCamera","desiredStepIndex","VolumeScrollEventDetail","currentImageId","getCurrentImageId","triggerEvent","VOLUME_VIEWPORT_SCROLL_OUT_OF_BOUNDS","VOLUME_VIEWPORT_SCROLL","scrollVolume","eventData","STACK_SCROLL_OUT_OF_BOUNDS","scroll","debounceLoading","loop","jumpToSlice","currentImageIndex","getTargetImageIdIndex","getNumberOfSlices","_getImageSliceData","imageIndexToJump","lastSliceIndex","_getImageIndexToJump","createSubVolume","referencedVolumeId","referencedVolume","refVolumeDim","minY","maxY","minZ","maxZ","ijkTopLeft","boundingBoxOriginWorld","transformIndexToWorld","subVolumeOptions","subVolume","createLocalVolume","subVolumeData","getCompleteScalarDataArray","subVolumeSliceSize","refVolumeSliceSize","refVolumeData","rowStartWorld","refVolumeRowStartIJK","transformWorldToIndex","refVolumeRowStartOffset","rowData","subVolumeLineStartOffset","setCompleteScalarDataArray","getVolumeDirectionVectors","viewUp","ijkOrigin","worldVecColDir","worldVecSliceDir","worldVecRowDir","ijkVecColDir","ijkVecSliceDir","ijkVecRowDir","calculateNeighborhoodStats","centerIjk","radius","numSlices","numPixelsPerSlice","sumSq","cx","cy","cz","centerIndex","mean","stdDev","variance","sqrt","projectionRadiographSOPClassUIDs","alreadySeenWarn","getPixelSpacingInformation","instance","PixelSpacing","SOPClassUID","SequenceOfUltrasoundRegions","isArrayOfSequences","PhysicalDeltaX","PhysicalDeltaY","calculateUSPixelSpacing","ImagerPixelSpacing","EstimatedRadiographicMagnificationFactor","PixelSpacingCalibrationType","PixelSpacingCalibrationDescription","isProjection","CalibrationTypes","UNKNOWN","ERMF","SeriesInstanceUID","PROJECTION","CALIBRATED","calculateRadiographicPixelSpacing","NOT_APPLICABLE","getViewportModality","Modality","_getViewportModality","invertRgbTransferFunction","areNumbersEqualWithTolerance","num1","num2","isNumberType","isNumberArrayLike","arr1","arr2","areArraysEqual","negative","isEqualNegative","isEqualAbs","isNumber","isFinite","loglevel","getRootLogger","logger","names","cs3dLog","toolsLog","loaderLog","aiLog","examplesLog","dicomConsistencyLog","imageConsistencyLog","makeVolumeMetadata","voiLut","voiLutModule","BitsAllocated","BitsStored","SamplesPerPixel","HighBit","PhotometricInterpretation","PixelRepresentation","ImageOrientationPatient","Columns","Rows","VOILUTFunction","linePlaneIntersection","p0","p1","x0","y0","z0","z1","A","B","C","D","t","normal","normalized","threePlaneIntersection","firstPlane","secondPlane","thirdPlane","A1","B1","C1","D1","A2","B2","C2","D2","A3","B3","C3","D3","m0","m1","m2","m3","signed","numerator","sign","isPointOnPlane","pointInShapeCallback","pointInShapeFn","returnPoints","scalars","getPointData","getScalars","getData","defaultBoundsIJK","pointsInShape","iMin","iMax","jMin","jMax","kMin","kMax","pointIJK","xMultiple","yMultiple","zMultiple","indexK","indexJK","pointLPS","iterateOverPointsInShape","iterateOverPointsInShapeVoxelManager","getAtIndex","deltaFrames","posDiffFromFocalPoint","steps","frameIndex","newSlicePosFromMin","sortImageIdsAndGetSpacing","usingWadoUri","sortedImageIds","getTransferFunctionNodes","transferFunction","setTransferFunctionNodes","nodes","node","canvasPoint","vtkImageData","worldPoint","voxelPos","transformWorldToIndexContinuous","ORTHOGONAL_TEST_VALUE","updatePlaneRestriction","reference","planeRestriction","inPlaneVector1","inPlaneVector2","testVector","updateVTKImageDataWithCornerstoneImage","sourceImageData","newPixelData","modified","toWindowLevel","toLowHighRange","SAMPLED_SIGMOID","LINEAR_EXACT","Active","Passive","Enabled","ToolModes","CAMERA_MODIFIED","Enums","STACK_NEW_IMAGE","VOLUME_NEW_IMAGE","calibratedPixelSpacingMetadataProvider","utilities","ViewportStatus","sumOverDimensionGroups","dimensionGroups","getScalarDataLength","resultArray","dimensionGroupNumber","getDimensionGroupScalarData","SUM","AVERAGE","SUBTRACT","idx","idx3","getPolyDataPointIndexes","polyData","linesData","getLines","lineSegments","segmentSize","segment","contours","findStartingPoint","startPoint","contour","nextPoint","getPolyDataPoints","contoursIndexes","rawPointsData","getPoints","contourIndexes","ColorbarRangeTextPosition","Right","Widget","extractWindowLevelRegionToolData","VolumeViewport","extractImageDataVolume","extractImageDataStack","setAnnotationLabel","annotation","updatedLabel","triggerAnnotationModified","ChangeTypes","LabelChange","calculateFanShapeCorners","imageBuffer","hull","roughContour","rough","slack","next","walk","to","i2","i3","P2","P3","pathA","pathB","globalYmin","upperPath","topY","arcPts","P1","best","P4","pickPoints","refined","edgeBuf","opts","maxDist","directions","snapQuadrant","xmin","xmax","ymin","ymax","xi","yi","xAlign","yAlign","refineCornersDirectional","step","angleRad","atan2","getImage","calculateFanGeometry","buffer","totalPixels","channelCount","mask","isForeground","labels","currentLabel","regionSizes","px","py","pixelCount","onFlood","largestLabel","isBorder","nx","ny","outer","dirs","prev","dx0","dy0","startDir","d","nextPt","bdx","bdy","segmentLargestUSOutlineFromBuffer","simplified","math","polyline","convexHull","generateConvexHullFromContour","fanGeometry","params","centerResult","intersectLine","startAngle","endAngle","tempAngle","d1","hypot","d4","d2","d3","innerRadius","outerRadius","deriveFanGeometry","props","_controlPoints","_invalidated","_resolution","resolution","_fixedResolution","fixedResolution","_closed","closed","controlPoints","numControlPoints","aabb","_update","_aabb","hasTangentPoints","addControlPoint","addControlPoints","addControlPointAtU","u","lineSegment","_getLineSegmentAt","endPoint","curveSegmentIndex","curveSegment","_curveSegments","controlPointPos","deleteControlPointByIndex","minControlPoints","clearControlPoints","setControlPoints","updateControlPoint","newControlPoint","getControlPoints","controlPoint","getClosestControlPoint","minSquaredDist","closestPointIndex","len","squaredDist","getClosestControlPointWithinDistance","closestControlPoint","getClosestPoint","curveSegmentsDistInfo","_getCurveSegmmentsDistanceSquaredInfo","closestPoint","csA","csB","distanceSquared","minDistCurveSegment","minDistLineSegment","closestPointCurveSegmentIndex","minDistSquared","curveSegmentDistInfo","lineSegPoint","lineSegDistSquared","distanceToPointSquaredInfo","uValue","previousLineSegmentsLength","distanceToPoint","getClosestPointOnControlPointLines","linePoints","getPolylinePoints","_convertCurveSegmentsToPolyline","getPreviewPolylinePoints","controlPointPreview","closeDistance","closeSpline","previewCurveSegments","getPreviewCurveSegments","isPointNearCurve","curveSegments","_getCurveSegmmentsWithinDistance","maxDistSquared","distanceToPointSquared","containsPoint","closingCurveSegment","_getClosingCurveSegmentWithStraightLineSegment","numIntersections","curveSegAABB","lineSegmentAABB","p2","isVerticalLine","xIntersection","getSplineCurves","curveSegLength","polylinePoints","curveSegIndex","lineSegIndex","curveSegmentsDistanceSquared","curveSegmentsDistance","curveSegmentsWithinRange","curveSegmentDistSquared","pointLength","lengthEnd","startControlPoint","endControlPoint","closingLineSegment","CubicSpline","previewNumCurveSegments","_getNumCurveSegments","startCurveSegIndex","endCurveSegIndex","transformMatrix","getTransformMatrix","_getCurveSegment","numCurveSegments","previousCurveSegmentsLength","_getPoint","uInt","p3","_getCurveSegmentPoints","tt","ttt","tValues","qValues","p0Index","p2Index","p3Index","mirror","_getLineSegments","numLineSegments","inc","maxU","curveSegmentLength","lineSegAABB","lineSegLength","TRANSFORM_MATRIX","BSpline","CardinalSpline","super","_scale","_fixedScale","fixedScale","s","s2","CatmullRomSpline","LinearSpline","PanTool","toolProps","defaultToolProps","supportedInteractionTypes","limitToViewport","touchDragCallback","evt","_dragCallback","mouseDragCallback","_checkImageInViewport","deltaPointsCanvas","viewportRight","viewportBottom","defaultActor","getDefaultActor","renderer","getRenderer","getBounds","computeVisiblePropBounds","imageLeft","imageTop","worldToCanvas","imageRight","imageBottom","getZoom","deltaPoints","deltaPointsWorld","world","updatedPosition","updatedFocalPoint","toolName","TrackballRotateTool","rotateIncrementDegrees","rotateSampleDistanceFactor","_resizeObservers","_hasResolutionChanged","preMouseDownCallback","mapper","originalSampleDistance","getSampleDistance","cleanUp","once","_getViewportsInfo","getToolGroup","toolGroupId","viewportsInfo","onSetToolActive","subscribeToElementResize","getEnabledElementByIds","resizeObserver","ResizeObserver","viewPresentation","observe","_viewportAddedListener","TOOLGROUP_VIEWPORT_ADDED","onSetToolDisabled","disconnect","rotateCamera","centerWorld","axis","vtkCamera","getVtkActiveCamera","getViewUp","getFocalPoint","getPosition","newViewUp","currentPoints","lastPoints","currentPointsCanvas","lastPointsCanvas","clientWidth","clientHeight","normalizedPosition","normalizedPreviousPosition","radsq","op","oe","opsq","oesq","lop","loe","nop","noe","dot","angleX","acos","upVec","atV","rightV","forwardV","angleY","PLANEINDEX","SPHEREINDEX","XMIN","XMAX","YMIN","YMAX","ZMIN","ZMAX","XMIN_YMIN_ZMIN","XMIN_YMIN_ZMAX","XMIN_YMAX_ZMIN","XMIN_YMAX_ZMAX","XMAX_YMIN_ZMIN","XMAX_YMIN_ZMAX","XMAX_YMAX_ZMIN","XMAX_YMAX_ZMAX","VolumeCroppingTool","showCornerSpheres","showHandles","showClippingPlanes","mobile","enabled","initialCropFactor","sphereColors","SAGITTAL","CORONAL","AXIAL","CORNERS","sphereRadius","grabSpherePixelDistance","originalClippingPlanes","draggingSphereIndex","toolCenter","cornerDragOffset","faceDragOffset","sphereStates","edgeLines","onSetToolConfiguration","onSetToolEnabled","onCameraModified","currentTarget","_updateClippingPlanes","mouseCanvas","sphereCanvas","pow","cursor","sphereState","mouseWorld","isCorner","axisIdx","viewport3D","_updateCornerSpheres","_updateFaceSpheresFromCorners","_updateClippingPlanesFromFaceSpheres","_onMouseMoveSphere","_getViewportAndWorldCoords","newCorner","_calculateNewCornerPosition","_updateSpherePosition","axisFlags","_parseCornerKey","_updateRelatedCorners","newValue","sphereSource","setCenter","_updateCornerSpheresFromFaces","_triggerToolChangedEvent","_onControlToolChange","_getViewport","isMin","handleType","toolCenterMin","toolCenterMax","normals","planeIndices","sphereIndices","axes","orientationAxes","getOrigin","newCenter","viewportOrientation","sphereActor","setColor","clippingPlanes","getClippingPlanes","setOrigin","VOLUMECROPPING_TOOL_CHANGED","_initialize3DViewports","worldBounds","cropFactor","xRange","yRange","zRange","xMin","xMax","yMin","yMax","zMin","zMax","planes","planeXmin","planeXmax","planeYmin","planeYmax","planeZmin","planeZmax","originalPlanes","getNormal","sphereXminPoint","sphereXmaxPoint","sphereYminPoint","sphereYmaxPoint","sphereZminPoint","sphereZmaxPoint","adaptiveRadius","_calculateAdaptiveSphereRadius","_addSphere","cornerKeys","key1","key2","state1","state2","_addLine3DBetweenPoints","addClippingPlane","VOLUMECROPPINGCONTROL_TOOL_CHANGED","_handleCornerSphereMovement","_updateAfterCornerMovement","_handleFaceSphereMovement","_updateAfterFaceMovement","cornerKey","isXMin","isXMax","isYMin","isYMax","isZMin","isZMax","draggedSphere","_shouldUpdateCorner","_updateCornerCoordinates","_onNewVolume","_rotateCamera","setHandlesVisible","setClippingPlanesVisible","_unsubscribeToViewportNewVolumeSet","_subscribeToViewportNewVolumeSet","visible","_updateHandlesVisibility","getHandlesVisible","getClippingPlanesVisible","normalizedCenter","_missingActorWarned","matrix","getMatrix","removeAllClippingPlanes","rot","normalMatrix","transformedOrigins","transformedNormals","oVec","o","nVec","planeInstance","setVisibility","point1","point2","setNumberOfPoints","setPoint","lines","setPoints","setLines","setInputData","setMapper","setLineWidth","setOpacity","setInterpolationToFlat","addActor","setRadius","sphereMapper","setInputConnection","getOutputPort","diagonal","sphereRadiusScale","minRadius","minSphereRadius","maxRadius","maxSphereRadius","pos","corner","xs","ys","zs","RENDERING_DEFAULTS","CONSTANTS","defaultReferenceLineColor","defaultReferenceLineControllable","OPERATION","VolumeCroppingControlTool","viewportIndicators","viewportIndicatorsConfig","extendReferenceLines","lineColors","lineWidth","lineWidthActive","_virtualAnnotations","initializeViewport","_updateToolCentersFromViewport","annotations","_getAnnotations","filterInteractableAnnotationsForElement","removeAnnotation","annotationUID","_getOrientationFromNormal","highlighted","cameraPosition","cameraFocalPoint","getToolName","handles","activeOperation","activeViewportIds","referenceLines","addAnnotation","resetCroppingSpheres","viewportInfo","resetPan","resetZoom","resetToCenter","resetRotation","resetSlabThickness","_computeToolCenter","computeToolCenter","orientationIds","presentOrientations","Boolean","missingOrientation","presentNormals","presentCenters","presentViewportInfos","vpInfo","virtualNormal","virtualCenter","virtualAnnotation","isVirtual","presentOrientation","presentCenter","canonicalNormals","virtualAnnotations","triggerAnnotationRenderForViewportIds","isPointNearTool","canvasCoords","proximity","_pointNearTool","toolSelectedCallback","interactionType","_activateModify","hideElementCursor","preventDefault","onResetCamera","mouseMoveCallback","filteredToolAnnotations","imageNeedsUpdate","isAnnotationLocked","near","filtered","renderAnnotation","svgDrawingHelper","lineIntersection2D","q1","q2","s1_x","s1_y","s2_x","s2_y","denom","renderStatus","viewportAnnotation","canvasDiagonalLength","otherViewportAnnotations","volumeCroppingCenterCanvasMin","volumeCroppingCenterCanvasMax","canvasBox","otherViewport","otherCamera","otherCanvasDiagonalLength","otherCanvasCenter","otherViewportCenterWorld","realViewports","vp1","vp2","normal1","normal2","otherViewportControllable","_getReferenceLineControllable","pointWorld0","pointCanvas0","otherViewportCenterCanvas","canvasUnitVectorFromCenter","canvasVectorFromCenterLong","refLinesCenterMin","refLinePointMinOne","refLinePointMinTwo","liangBarksyClip","refLinesCenterMax","refLinePointMaxOne","refLinePointMaxTwo","viewportColor","_getReferenceLineColor","line","lineIndex","intersections","otherLine","intersection","with","annotationForViewport","toUpperCase","idUpper","colorArr","unknown","viewportControllable","selectedViewportId","activeLineWidth","lineUID","drawLine","sortedIntersections","lineDash","referenceColorCoordinates","xOffset","yOffset","circleRadius","circleUID","drawCircle","getAnnotations","toolGroupAnnotations","_onSphereMoved","_syncWithVolumeCroppingTool","newMin","newMax","setToolCenter","_getAnnotationsForViewportsWithDifferentCameras","viewportsWithDifferentCameras","cameraOfTarget","_filterViewportWithSameOrientation","referenceAnnotation","linkedViewportAnnotations","otherViewportsAnnotationsWithSameCameraDirection","otherViewPlaneNormal","isInteractingWithTool","MOUSE_UP","_endCallback","MOUSE_DRAG","MOUSE_CLICK","TOUCH_END","TOUCH_DRAG","TOUCH_TAP","_deactivateModify","editData","resetElementCursor","viewportIdsToRender","getViewportIdsWithToolToRender","VOLUME_3D","activeType","getReferenceLineColor","getReferenceLineControllable","getSpacing","maxCropFactor","cropStart","cropEnd","onSetToolInactive","anyAnnotationExists","canonical","tol","addNewAnnotation","filteredAnnotations","viewportIdArray","handleSelectedCallback","handle","_applyDeltaShiftToSelectedViewportCameras","viewportsAnnotationsToUpdate","_applyDeltaShiftToViewportCamera","dotProd","projectedDelta","start1","end1","WindowLevelTool","_getImageDynamicRangeFromMiddleSlice","middleSliceIndex","frameLength","bytesPerVoxel","frame","_getMinMax","newRange","viewportsContainingVolumeUID","properties","scaling","getPTScaledNewRange","getNewRange","multiplier","_getMultiplierFromDynamicRange","wwDelta","wcDelta","voiLutFunction","imageDynamicRange","calculatedDynamicRange","getMiddleSliceData","acc","pixel","metadataDynamicRange","calculatedRange","_getImageDynamicRangeFromViewport","imageDataRange","voxel","WindowLevelRegionTool","minWindowWidth","isDrawing","getReferencedImageId","getFrameOfReferenceUID","cachedStats","_activateDraw","_deactivateDraw","triggerAnnotationCompleted","applyWindowLevelRegion","topLeftCanvas","MOUSE_MOVE","styleSpecifier","canvasCoordinates","getAnnotationStyle","dataId","rectangleUID","drawRect","startCanvas","endCanvas","left","pixelLuminanceData","luminance","spIndex","column","red","green","blue","minMaxMean","pixelLuminance","globalMin","globalMax","spv","StackScrollTool","debounceIfNotLoaded","deltaY","mouseWheelCallback","_scroll","_scrollDrag","deltaPointY","pixelsPerImage","_getPixelPerImage","imageIdIndexOffset","wheel","BaseVolumeViewport","offsetHeight","PlanarRotateTool","setAngle","startPoints","currentPointWorld","startPointWorld","centerCanvas","angleBetweenLines","cross","rotAngle","rotMat","rotatedViewUp","ZoomTool","zoomToCenter","minZoomScale","maxZoomScale","pinchToZoom","pan","initialMousePosWorld","dirVec","preTouchStartCallback","_dragParallelProjection","pinch","deltaDistance","parallelScale","parallelScaleToSet","focalPointToSet","positionToSet","distanceToCanvasCenter","cappedParallelScale","thresholdExceeded","imageWidth","imageHeight","canvasAspect","insetImageMultiplier","getConfiguration","useLegacyCameraFOV","scaledImageWidth","scaledImageHeight","minParallelScaleRequired","minScaleInWorld","maxScaleInWorld","_dragPerspectiveProjection","zoomScale","directionOfProjection","tmp","_pinchCallback","_zoom","currentPointsList","parallelProjection","_panCallback","eventDetails","eventName","MOUSE_WHEEL","page","client","MIPJumpToClickTool","targetViewportIds","mouseClickCallback","maxIntensity","brightestPoint","getPointInLineOfSightWithCriteria","intensity","foundToolGroup","getToolGroupForViewport","jumpToWorld","defaultReferenceLineDraggableRotatable","defaultReferenceLineSlabThicknessControlsOn","CrosshairsTool","shadow","autoPan","panSize","handleRadius","enableHDPIHandles","referenceLinesCenterGapRadius","referenceLinesCenterGapRatio","filterActorUIDsToSetSlabThickness","slabThicknessBlendMode","MAXIMUM_INTENSITY_BLEND","centerPoint","rotationPoints","slabThicknessPoints","resetCrosshairs","firstViewport","secondViewport","thirdViewport","normal3","point3","jumpWorld","_jump","viewportDraggableRotatable","_getReferenceLineDraggableRotatable","currentCamera","oldCameraPosition","deltaCameraPosition","oldCameraFocalPoint","deltaCameraFocalPoint","isRotation","cameraModifiedInPlane","CROSSHAIR_TOOL_CENTER_CHANGED","getViewportIds","_autoPanViewportIfNecessary","previousActiveOperation","previousActiveViewportIds","getHandleNearImagePoint","_areViewportIdArraysEqual","viewportUIDSpecificCrosshairs","canvasMinDimensionLength","crosshairCenterCanvas","_filterAnnotationsByUniqueViewportOrientations","otherViewportDraggableRotatable","otherViewportSlabThicknessControlsOn","_getReferenceLineSlabThicknessControlsOn","pointWorld1","canvasVectorFromCenterMid","canvasVectorFromCenterShort","canvasVectorFromCenterStart","mobileConfig","centerGap","refLinePointOne","refLinePointTwo","refLinePointThree","refLinePointFour","refLinesCenter","rotHandleOne","rotHandleTwo","stHandlesCenterCanvas","stHandlesCenterWorld","worldUnitVectorFromCenter","worldUnitOrthoVectorFromCenter","slabThicknessValue","getSlabThickness","worldOrthoVectorFromCenter","worldVerticalRefPoint","canvasVerticalRefPoint","canvasOrthoVectorFromCenter","stLinePointOne","stLinePointTwo","stLinePointThree","stLinePointFour","stHandleOne","stHandleTwo","stHandleThree","stHandleFour","newRtpoints","newStpoints","viewportSlabThicknessControlsOn","lineActive","rotHandlesActive","rotationHandles","rotHandleWorldOne","rotHandleWorldTwo","slabThicknessHandlesActive","slabThicknessHandles","slabThicknessHandleWorldOne","slabThicknessHandleWorldTwo","slabThicknessHandleWorldThree","slabThicknessHandleWorldFour","handleUID","drawHandles","defaultColor","defaultSize","maxAllowedSize","centerPointColor","centerPointSize","viewportIdArrayOne","viewportIdArrayTwo","itemFound","otherLinkedViewportAnnotationsFromSameScene","otherViewportsAnnotationsWithUniqueCameras","cameraFound","jj","cameraOfStocked","otherNonLinkedViewportAnnotationsFromSameScene","_checkIfViewportsRenderingSameScene","volumeIds","getAllVolumeIds","otherVolumeIds","sameScene","dir1","dir2","finalPointCanvas","originalPointCanvas","_isClockWise","rotationAxis","buildFromRadian","otherViewportsIds","referenceAnnotations","viewportsIds","mod","currentPoint","currentCenter","otherViewportRotationPoints","dotProdDirection","projectedDirection","normalizedProjectedDirection","normalizedProjectedDelta","MINIMUM_SLAB_THICKNESS","_pointNearReferenceLine","getToolInstance","setSlabThickness","lineViewport","lineSegment1","distanceToPoint1","lineSegment2","distanceToPoint2","getReferenceLineDraggableRotatable","getReferenceLineSlabThicknessControlsOn","onSetToolPassive","scrollDelta","_getRotationHandleNearImagePoint","_getSlabThicknessHandleNearImagePoint","toolCenterCanvas","visiblePointCanvas","visiblePointWorld","actorUIDs","blendModeToUse","COMPOSITE","setBlendMode","annotationCanvasCoordinate","stPointLineCanvas1","stPointLineCanvas2","stPointLineCanvas1Start","stPointLineCanvas2Start","MAGNIFY_VIEWPORT_ID","MagnifyTool","magnifySize","magnifyWidth","magnifyHeight","_hasBeenRemoved","_getReferencedImageId","_createMagnificationViewport","viewportProperties","originalViewportRotation","canvasPos","magnifyToolElement","querySelector","magnifyElement","classList","display","magnifyViewport","_cancelCallback","stopPropagation","_dragEndCallback","viewportElement","removeChild","getTargetId","csEvents","isSegmentation","representationUID","AdvancedMagnifyToolActions","PARALLEL_THRESHOLD","AdvancedMagnifyTool","Actions","magnifyingGlass","zoomFactor","zoomFactorList","padding","actions","showZoomFactorsList","method","bindings","mouseButton","MouseBindings","Secondary","modifierKey","KeyboardBindings","Shift","config","canvasHandlePoints","_getCanvasHandlePoints","magnifyViewportId","sourceViewportId","isCanvasAnnotation","activeHandleIndex","magnifyViewportManager","createViewport","sourceEnabledElement","annotationPoints","canvasDelta","dispose","getAllAnnotations","canvasTop","canvasBottom","canvasLeft","radiusPoint","getCanvasCircleRadius","handleIndex","newAnnotation","_dragDrawCallback","hasMoved","_dragModifyCallback","_dragHandle","canvasCenter","currentCanvasPoints","newRadius","newCanvasHandlePoints","getStyle","activeHandleCanvasCoords","isAnnotationVisible","handleGroupUID","update","canvasCenterPos","canvasRadius","AdvancedMagnifyViewportManager","getInstance","currentZoomFactor","dropdown","_getZoomFactorsListDropdown","newZoomFactor","parentElement","assign","focus","onChangeCallback","keyCode","which","toLowerCase","option","title","defaultSelected","sourceViewport","sourceElement","AdvancedMagnifyViewport","_addSourceElementEventListener","_magnifyViewportsMap","magnifyViewportInfo","_annotationRemovedCallback","destroyViewport","_newStackImageCallback","magnifyViewportsMapEntries","_getMagnifyViewportsMapEntriesBySourceViewportId","getEnabledElementByViewportId","stackActorReInitialized","_reset","_newVolumeImageCallback","currentViewPlaneNormal","worldImagePlanePoint","vecHandleToImagePlane","worldDist","worldDelta","_initialize","_singleton","_removeEventListeners","_destroyViewports","magnifyViewportMapEntry","_removeSourceElementEventListener","newEnabledElement","_addEventListeners","ANNOTATION_REMOVED","newStackHandler","VIEWPORT_NEW_IMAGE_SET","newVolumeHandler","_enabledElement","_sourceToolGroup","_magnifyToolGroup","_isViewportReady","_radius","_resized","_canAutoPan","_viewportId","_sourceEnabledElement","_autoPan","_browserMouseDownCallback","_browserMouseUpCallback","_handleToolModeChanged","_mouseDragCallback","_resizeViewportAsync","debounce","_resizeViewport","_syncViewports","parentNode","magnifyToolGroup","mode","toolBindingsOptions","setToolActive","setToolPassive","setToolEnabled","Disabled","setToolDisabled","_inheritBorderRadius","borderRadius","_createViewportNode","overflow","boxSizing","_convertZoomFactorToParallelScale","offsetWidth","_isStackViewport","_isVolumeViewport","_cloneToolGroups","sourceActors","magnifyToolGroupId","sourceToolGroup","toolInstance","addViewport","addSegmentationRepresentations","segmentationId","SegmentationRepresentations","Labelmap","_cloneStack","_cloneVolumes","volumeInputArray","_cloneViewport","sourceViewportOptions","toolGroups","_cancelMouseEventCallback","closest","canvasCurrent","magnifyRadius","dist","panDist","canvasDeltaPos","newCanvasPosition","currentWorldPos","newWorldPos","worldDeltaPos","autoPanCallbackData","currentPosition","_addBrowserEventListeners","_removeBrowserEventListeners","TOOL_MODE_CHANGED","sourceCanvas","_syncViewportsCameras","_syncStackViewports","setImageIdIndex","sourceProperties","resize","ReferenceLines","AnnotationDisplayTool","enforceSameFrameOfReference","showFullDimension","_init","getRenderingEngines","filterViewportsWithToolEnabled","sourceViewportCanvasCornersInWorld","topLeft","bottomRight","sourceViewPlaneNormal","isParallel","targetViewportPlane","pointSet1","pointSet2","pointSetToUse","topBottomVec","topRightVec","newNormal","isPerpendicular","lineStartWorld","lineEndWorld","handleFullDimension","vec1","vec2","targetImage","getTargetImageData","topLeftImageCoord","topRightImageCoord","bottomRightImageCoord","bottomLeftImageCoord","lineStartImageCoord","lineEndImageCoord","intersectInfiniteLines","isInBound","err","line1Start","line1End","line2Start","line2End","x3","y3","x4","y4","a1","b1","c1","a2","b2","c2","OverlayGridTool","sourceImageIds","pointSets","calculateImageIdPointSets","viewportData","imageIdNormal","getImageIdNormal","targetData","initializeViewportData","pointSetsToUse","lineStartsWorld","lineEndsWorld","SegmentationIntersectionTool","actorsWorldPointsMap","calculateSurfaceSegmentationIntersectionsForViewport","calculateSurfaceSegmentationIntersections","actorEntries","cacheId","getCacheId","clippingFilter","actorWorldPointMap","polyLineIdx","worldPointsSet","canvasPoints","fillColor","fillOpacity","closePath","polyLineUID","drawPath","actorWorldPointsMap","getOutputData","colorArray","colorComponentToString","component","componentString","colorToString","getColor","decimals","pointToString","ReferenceCursors","preventHandleOutsideImage","displayThreshold","positionSync","disableCursor","isHandleOutsideImage","_elementWithCursor","_currentCursorWorldPosition","_currentCanvasPosition","_disableCursorEnabled","getActiveAnnotation","createInitialAnnotation","updateAnnotationPosition","textBox","worldPosition","worldBoundingBox","previousCamera","oldFocalPoint","cameraNormal","isElementWithCursor","updateViewportImage","lineWidthBase","crosshairUIDs","right","centerSpace","lineLength","currentMousePosition","closestIndex","currentDistance","normalizedViewPlane","scaledPlaneNormal","renderViewport","viewportsWithAnnotations","ScaleOverlayTool","scaleLocation","enabledElements","viewportCanvasCornersInWorld","thisAnnotation","computeScaleSize","worldWidthViewport","worldHeightViewport","location","scaleSizes","currentScaleSize","scaleSize","computeEndScaleTicks","locationTickOffset","bottom","endTick1","endTick2","computeInnerScaleTicks","leftTick","rightTick","canvasScaleSize","tickIds","tickUIDs","tickCoordinates","numberSmallTicks","tickSpacing","locationOffset","computeWorldScaleCoordinates","pointSet","worldCoordinates","midpointLocation","midpoint","computeCanvasScaleCoordinates","canvasSize","vscaleBounds","hscaleBounds","scaleCanvasCoordinates","worldDistanceOnCanvas","computeScaleBounds","horizontalReduction","verticalReduction","hReduction","vReduction","locationBounds","canvasBounds","scaleTicks","scaleId","leftTickId","rightTickId","locationTextOffest","textCanvasCoordinates","textBoxLines","_getTextLines","drawTextBox","fontFamily","fontSize","scaleSizeDisplayValue","scaleSizeUnits","SculptorTool","minSpacing","referencedToolNames","toolShape","referencedToolName","updateCursorSize","registeredShapes","isActive","commonData","activeAnnotationUID","isEditingOpenContour","canvasLocation","configureToolSize","selectFreehandTool","activateModify","updateCursor","endCallback","deactivateModify","activeAnnotation","filterSculptableAnnotationsForElement","calculateStats","HandlesUpdated","dragCallback","sculpt","registerShapes","CircleSculptCursor","shapeName","setToolShape","shapeClass","shape","cursorShape","selectedShape","sculptData","mousePoint","mouseCanvasPoint","deltaWorld","maxSpacing","getMaxSpacing","pushedHandles","pushHandles","first","insertNewHandles","interpolatePointsWithinMaxSpacing","indicesToInsertAfter","nextHandleIndex","contourIndex","currentCanvasPoint","nextCanvasPoint","updateToolSize","sculptableAnnotations","findNewHandleIndices","newIndexModifier","insertHandleRadially","previousIndex","nextIndex","handleData","getInsertPosition","closestAnnotationUID","getClosestFreehandToolOnElement","toolIndex","isLocked","isVisible","distanceFromTool","distancePointToContour","AnnotationStyleStates","Default","Highlighted","renderShape","DIRECTIONS","VolumeRotateTool","ax","ay","az","LabelTool","getTextCallback","changeTextCallback","svgLayer","textGroup","textGroupElement","bbox","getBBox","getAttribute","translateX","translateY","matches","createAnnotation","initialWorldPos","anchorWorldPos","doneEditMemo","getLinkedTextBoxStyle","textBoxUID","hydrate","autoGenerated","_evt","_annotation","_handle","_interactionType","_doneChangingTextCallback","_isInsideVolume","index1","index2","doneChangingTextCallback","prompt","LengthTool","getTextLines","defaultGetTextLines","movingTextBox","canvasPoint1","canvasPoint2","worldPosDelta","unit","_throttledCalculateCachedStats","_calculateCachedStats","showHandlesAlways","textLines","canvasTextBoxCoords","getTextBoxCoordsCanvas","textBoxPosition","boundingBox","drawLinkedTextBox","throttle","trailing","hydrateBase","serializableOptions","_calculateLength","pos1","pos2","worldPos1","worldPos2","targetIds","StatsUpdated","cachedVolumeStats","HeightTool","heightUID","drawHeight","_calculateHeight","outside","ProbeTool","probeDefaults","textCanvasOffset","mergeDefaultProps","createAnnotationForViewport","eventDispatchDetail","getStackViewports","referencedImageURI","currentImageURI","textUID","changeType","pixelUnitsOptions","isViewportPreScaled","isSuvScaled","ijk","modalityUnit","getAtIJKPoint","calibratedResults","hasEnhancedRegionValues","units","getPixelValueUnits","DragProbeTool","postMouseDownCallback","postTouchStartCallback","EllipticalROITool","storePointData","centerPointRadius","statsCalculator","BasicStatsCalculator","w","h","minorEllipse","xRadius","yRadius","majorEllipse","pointInMinorEllipse","_pointInEllipseCanvas","originalHandleCanvas","pointsCanvas","dX","dY","bottomCanvas","topCanvas","leftCanvas","rightCanvas","dYCanvas","newHalfCanvasWidth","canvasRight","dXCanvas","newHalfCanvasHeight","canvasCorners","getCanvasEllipseCorners","areaUnit","area","ellipseUID","_getCanvasEllipseCenter","pos1Index","pos2Index","zRadius","ellipseObj","worldWidth","worldHeight","getWorldWidthAndHeightFromTwoPoints","isEmptyArea","aspect","statsCallback","isInObject","pointInEllipse","fast","getStatistics","statsArray","ellipse","rotLocation","ellipseCanvasPoints","areaLine","CircleROITool","canvasHandles","radiusCanvas","newRadiusCanvas","getCanvasCircleCorners","radiusUnit","perimeter","wasInvalidated","radiusLine","ETDRSGridTool","degrees","diameters","canvasEnd","diametersCanvas","diameter","worldMeasureToCanvas","degreesRad","angleRadians","degree","cos","sin","measurement","p1Canvas","p2Canvas","DEFAULT_SPLINE_CONFIG","controlPointAdditionDistance","controlPointDeletionDistance","showControlPointsConnectors","controlPointAdditionEnabled","controlPointDeletionEnabled","SplineTypesEnum","SplineToolActions","splineToolNames","SplineROITool","ContourSegmentationBaseTool","SplineTypes","simplifiedSpline","contourHoleAdditionModifierKey","epsilon","spline","Cardinal","Class","CatmullRom","Linear","drawPreviewEnabled","enableTwoPointPreview","lastControlPointDeletionKeys","AddControlPoint","Primary","DeleteControlPoint","Ctrl","fireChangeOnUpdate","contourHoleProcessingEnabled","Completed","_keyDownCallback","controlPointIndex","_deleteControlPointByIndex","_mouseMoveCallback","lastCanvasPoint","_mouseDownCallback","doubleClick","MOUSE_DOUBLE_CLICK","closeContour","addNewPoint","moveAnnotation","eventType","ANNOTATION_COMPLETED","ANNOTATION_MODIFIED","triggerChangeEvent","KEY_DOWN","MOUSE_DOWN","_renderStats","textboxStyle","addControlPointCallback","splineType","splineConfig","_getSplineConfig","closestPointInfo","deleteControlPointCallback","originalWorldPoint","deltaXPoint","deltaYPoint","deltaInX","deltaInY","canvasMaxX","canvasMaxY","canvasMinX","canvasMinY","getAABB","topLeftBBWorld","topLeftBBIndex","bottomRightBBWorld","getArea","annotationCompletedBinded","annotationCompleted","sourceAnnotation","isContourSegmentationTool","convertContourSegmentationAnnotation","initializeListeners","removeListeners","getMouseModifier","event","cancelAnnotation","renderAnnotationInstance","renderContext","annotationStyle","locked","annotationLocked","childAnnotations","getChildAnnotations","childAnnotationUIDs","_isSplineROIAnnotation","splinePolylineCanvas","_updateSplineInstance","updateContourPolyline","targetWindingDirection","Clockwise","updateWindingDirection","previewPolylinePoints","drawPolyline","controlPointsConnectors","textbox","createInterpolatedSplineControl","isSplineAnnotation","createSplineObjectFromType","contourAnnotation","createSpline","onInterpolationComplete","splineConfigs","splineInstance","SplineClass","SplineContourSegmentationTool","annotationCutMergeCompletedBinded","annotationCutMergeCompleted","ANNOTATION_CUT_MERGE_PROCESS_COMPLETED","LivewireContourTool","snapHandleNearby","nearestEdge","showInterpolationPolyline","cancelInProgress","proximitySquared","clearAnnotation","clearEditData","triggerContourAnnotationCompleted","worldToSlice","sliceToWorld","worldPosOriginal","currentPath","closestHandlePoint","distSquared","worldControlPoint","canvasControlPoint","snapPoint","scissors","findMinNearby","pathPoints","findPathToPoint","addPoints","prependPath","confirmedPath","lastPoint","getLastPoint","startSearch","updateAnnotation","imgWidth","imgHeight","slicePoint","editHandle","setupBaseEditData","nextPos","viewportImageData","sliceImageData","ijkPoint","startPos","LivewireScissors","createInstanceFromRawPixelData","scissorsNext","currentPathNext","confirmedPathNext","handlePoints","numHandles","previousHandle","nextHandle","findHandlePolylineIndex","slicePos","pathPointsLeft","pathPointsRight","appendPath","contourSegmentationAnnotation","livewirePath","pointArray","imagePoints","LivewireContourSegmentationTool","updateInterpolatedAnnotation","interpolationSources","originalPolyline","queueMicrotask","repeatInterpolation","originalPoints","handleSmoothing","hIndex","testPoint","minPoint","acceptedPath","path","InterpolationUpdated","rendered","polylineCanvasPoints","AnnotationToPointData","register","ArrowAnnotateTool","arrowFirst","arrowHeadStyle","touchTapCallback","taps","doubleClickCallback","clickedAnnotation","stopImmediatePropagation","markerSize","arrowUID","drawArrow","viaMarker","AngleTool","showAngleArc","arcOffset","angleStartedNotYetCompleted","line1","canvasPoint3","line2","angleArcLineDash","anglePoints","temp","segments","worldPos3","fromCharCode","CobbAngleTool","showArcLines","distanceToLines","isNearFirstLine","isNearSecondLine","TOUCH_START","arc1Angle","arc2Angle","arc1Start","arc1End","arc2Start","arc2End","firstLine","secondLine","mid1","midPoint","mid2","arc1TextBoxUID","arc1TextLine","arch1TextPosCanvas","arc2TextBoxUID","arc2TextLine","arch2TextPosCanvas","point4","canvasPoint4","getArcsStartEndPoints","linkLine","arc1Side","arc2Side","midLinkLine","linkLineLength","midFirstLine","midSecondLine","directionVectorStartArc1","magnitudeStartArc1","normalizedDirectionStartArc1","directionVectorEndArc1","magnitudeEndArc1","normalizedDirectionEndArc1","directionVectorStartArc2","magnitudeStartArc2","normalizedDirectionStartArc2","directionVectorEndArc2","magnitudeEndArc2","normalizedDirectionEndArc2","seg1","seg2","minDist","MAX_VALUE","UltrasoundDirectionalTool","displayBothAxesDistances","startedDrawing","xValues","yValues","isHorizontal","isUnitless","drawHandle","canvasDeltaY","canvasDeltaX","projectedPointCanvas","imageIndex1","imageIndex2","values1","units1","values2","units2","dist1","dist2","UltrasoundPleuraBLineTool","USPleuraBLineAnnotationType","BLINE","PLEURA","bLineColor","pleuraColor","drawDepthGuide","depth_ratio","depthGuideColor","depthGuideThickness","depthGuideDashLength","depthGuideDashGap","depthGuideOpacity","fanOpacity","showFanAnnotations","updatePercentageCallback","pleuraAnnotations","bLineAnnotations","annotationType","getActiveAnnotationType","allPointsInsideShape","newPoint","isInsideFanShape","getFanShapeGeometryParameters","fanCenter","indexToCanvasRatio","getIndexToCanvasRatio","unMergedPleuraIntervals","mergedPleuraIntervals","pleuraIntervalsDisplayed","bLineIntervalsDisplayed","drawAnnotation","getColorForLineType","lineInterval","fanNumber","interval","clippedInterval","fanDataId","fanUID","drawFan","pleuraAnnotationsToDraw","bLineAnnotationsToDraw","calculateBLinePleuraPercentage","activeAnnotationType","filterAnnotations","filterFunction","countAnnotations","getImageIdIndex","annotationMapping","counts","bLine","pleura","deleteAnnotations","setActiveAnnotationType","deleteLastAnnotationType","annotationList","updateFanGeometryConfiguration","isFanShapeGeometryParametersValid","deriveFanGeometryFromViewport","pleuraIntervals","bLineIntervals","diffVector","radToDegree","rad","degreeToRad","indexToCanvas","depth_radius","theta_start","theta_range","arc_length","num_dashes","theta_step","theta1","theta2","start_point","end_point","strokeOpacity","KeyImageTool","dataSeries","seriesLevel","dataPoint","isPoint","canvasPosition","updatedText","AnnotationEraserTool","_deleteNearbyAnnotations","toolGroup","tools","_toolInstances","annotationsToRemove","interactableAnnotations","setAnnotationSelected","getAnnotation","createAnnotationMemo","deleting","RegionSegmentTool","GrowCutBaseTool","isPartialVolume","positiveSeedVariance","negativeSeedVariance","currentWorldPoint","growCutData","circleBorderPoint","runGrowCut","circleCenterPoint","getGrowCutLabelmap","segmentation","sphereInfo","growCut","segmentationData","canvasCenterPoint","canvasBorderPoint","vecCenterToBorder","getSegmentStyle","segmentIndex","RegionSegmentPlusTool","subVolumePaddingPercentage","islandRemoval","mouseTimer","allowedToProceed","clearTimeout","onMouseStable","mouseStabilityDelay","refVolume","seeds","positiveSeedIndices","negativeSeedIndices","requestAnimationFrame","worldIslandPoints","getRemoveIslandData","mergedOptions","NEGATIVE_PIXEL_RANGE","POSITIVE_PIXEL_RANGE","ISLAND_PIXEL_RANGE","WholeBodySegmentTool","positivePixelRange","negativePixelRange","islandPixelRange","_getHorizontalLineWorldPoints","horizontalLines","worldLine1P1","worldLine1P2","worldLine2P1","worldLine2P2","worldSquarePoints","worldTopLeft","worldBottomRight","_getWorldBoundingBoxFromProjectedSquare","boundingBoxInfo","ijkBottomRight","positiveSeedValue","negativeSeedValue","labelmapVolumeId","labelmapVolume","referencedVolumeData","labelmapData","islandPointIndexes","pixelValue","_projectWorldPointAcrossSlices","worldEdgePoint","vecDirection","_getViewportVolume","ijkLineP1","ijkLineP2","_getCuboidIJKEdgePointsFromProjectedWorldPoint","_getWorldCuboidCornerPoints","cuboidPoints","worldSquarePoint","worldEdgePoints","worldCuboidPoints","_getHorizontalLineIJKPoints","ijkPoint1","ijkPoint2","RectangleScissorsTool","LabelmapBaseTool","strategies","FILL_INSIDE","ERASE_INSIDE","defaultStrategy","activeStrategy","activeLabelmapSegmentation","activeSegmentation","segmentsLocked","segmentLocking","segmentColor","representationData","getSegmentation","segmentationImageId","getCurrentLabelmapImageIdForViewport","operationData","applyActiveStrategy","toolMetadata","CircleScissorsTool","SphereScissorsTool","activeSegmentationRepresentation","getEditData","CircleROIStartEndThresholdTool","numSlicesToPropagate","calculatePointsInsideVolume","showTextBox","throttleTimeout","spacingInNormal","startCoord","_getStartCoordinate","endCoord","_getEndCoordinate","startCoordinate","endCoordinate","pointsInVolume","projectionPoints","statistics","labelmapUID","_computeProjectionPoints","_computePointsInsideVolume","filterAnnotationsWithinSamePlane","annotationEnabledElement","viewplaneNormal","tempStartCoordinate","tempEndCoordinate","_getCoordinateForViewplaneNormal","roundedStartCoordinate","roundedEndCoordinate","cameraCoordinate","roundedCameraCoordinate","middleCoordinate","isMiddleSlice","_getIndexOfCoordinatesForViewplaneNormal","iteratorVolumeIDs","lineWidthToUse","lineDashToUse","_calculateCachedStatsTool","projectionAxisIndex","startWorld","endWorld","handlesOnStartPlane","handlesToStart","newProjectionPoints","pointsInsideVolume","baseTopLeftCanvas","baseBottomRightCanvas","basePos1","basePos2","measureInfo","modalityUnitOptions","currentCanvasCoordinates","worldPos1Index","worldProjectionPointIndex","indexOfProjection","worldPos2Index","numSlicesToPropagateFromStart","numSlicesToPropagateToEnd","endPos","viewplaneNormalAbs","_context","PaintFillTool","currentSegmentationImageId","fixedDimension","getFixedDimension","floodFillGetter","getLabelValue","getScalarDataPositionFromPlane","inPlaneSeedPoint","fixedDimensionValue","generateHelpers","clickedLabelValue","floodFillResult","flooded","scalarDataIndex","setAtIndex","framesModified","getFramesModified","triggerSegmentationDataModified","boundaries","minJ","maxJ","seedIndex3D","getAtIJK","generateFloodFillGetter","generateGetScalarDataPositionFromPlane","getScalarDataPosition","xDirection","yDirection","zDirection","absoluteOfViewPlaneNormal","absoluteOfXDirection","absoluteOfYDirection","absoluteOfZDirection","OverlayMarkerType","OrientationMarkerTool","CUBE","AXIS","VTPFILE","OVERLAY_MARKER_TYPES","orientationWidget","viewportCorner","Corners","BOTTOM_RIGHT","viewportSize","minPixelSize","maxPixelSize","overlayMarkerType","ANNOTATED_CUBE","overlayConfiguration","faceProperties","xPlus","text","faceColor","faceRotation","xMinus","yPlus","fontColor","yMinus","zPlus","zMinus","defaultStyle","fontStyle","fontSizeScale","res","edgeThickness","edgeColor","AXES","CUSTOM","polyDataURL","initViewports","_subscribeToViewportEvents","cleanUpData","orientationMarker","orientationMarkers","updateViewport","updatingOrientationMarker","unsubscribe","unobserve","setEnabled","getOffscreenMultiRenderWindow","getRenderWindow","widget","getWidget","isDeleted","addAxisActorInViewport","removeActor","createAnnotationCube","createCustomActor","renderWindow","interactor","getInteractor","parentRenderer","setViewportCorner","setViewportSize","setMinPixelSize","setMaxPixelSize","updateMarkerOrientation","addWidget","url","response","fetch","arrayBuffer","vtpReader","parseAsArrayBuffer","shallowCopy","setActiveScalars","setColorModeToDirectScalars","rotateZ","setDefaultStyle","setXPlusFaceProperty","setXMinusFaceProperty","setYPlusFaceProperty","setYMinusFaceProperty","setZPlusFaceProperty","setZMinusFaceProperty","createAnnotatedCubeActor","annotatedCube","methodName","charAt","SegmentSelectTool","SelectMode","Inside","Border","hoverTimeout","searchRadius","hoverTimer","_setActiveSegment","getActiveSegmentation","_setActiveSegmentForType","hoveredSegmentIndex","getSegmentIndexAtWorldPoint","getSegmentIndexAtLabelmapBorder","Contour","getHoveredContourSegmentationAnnotation","Surface","setActiveSegmentIndex","triggerSegmentationModified","SegmentBidirectionalTool","BidirectionalTool","getSegmentIndexColor","dataId1","dataId2","secondLineUID","toolAnnotations","existingAnnotation","majorAxis","minorAxis","major0","major1","minor0","minor1","SegmentLabelTool","_setHoveredSegment","_setHoveredSegmentForType","_editData","hoveredSegmentLabel","LabelMapEditWithContourTool","PlanarFreehandContourSegmentationTool","annotationsToViewportMap","viewportIdsChecked","allowOpenContours","onViewportAddedToToolGroupBinded","onViewportAddedToToolGroup","onSegmentationModifiedBinded","onSegmentationModified","annotationModified","SEGMENTATION_MODIFIED","SEGMENTATION_REPRESENTATION_MODIFIED","cleanUpListeners","checkContourSegmentation","activeSeg","representations","getSegmentationRepresentation","BrushTool","viewportContoursToLabelmap","VideoRedactionTool","toolConfiguration","viewportUIDsToRender","toolDataCanvasCoordinate","rect","_getRectangleImageCoordinates","rectangle","active","drawRedactionRect","point0","viewportUID","renderingEngineUID","sceneUID","targetUIDs","targetUID","_getImageVolumeFromTargetUID","worldToIndexVec3","valueMinusMean","_getTargetVolumeUID","scene","volumeUID","getVolumeActors","coloneIndex","_getTargetStackUID","Dir","visited","DEFAULT_VALUES","publicAPI","model","initialValues","arguments","m","algo","requestData","inData","outData","output","extractContours","traverseLoop","pd","startLineId","startPtId","loopPoints","lineId","lastPtId","terminated","numInserted","cellPointIds","getCellPoints","ptId","lineCell","getPointCells","loops","inLines","setData","li","getNumberOfCells","outLines","insertNextCell","vtkContourLoopExtraction","newInstance","projectTo2D","geometricSurfaceUtils","checkStandardBasis","rotatePoints","getBoundingBoxAroundShapeWorld","isPlaneIntersectingAABB","polySegConverters","polySeg","polySegInitializing","polySegInitializingPromise","initializePolySeg","progressCallback","ICRPolySeg","moduleId","peerImport","default","initialize","updateProgress","convertContourToSurface","args","callbacks","polylines","numPointsArray","convertContourRoiToSurface","convertLabelmapToSurface","results","rotationInfo","isStandard","rotatedPoints","rotationMatrix","convertContourToVolumeLabelmap","segmentIndices","annotationUIDsInSegmentMap","segmentationVoxelManager","createScalarVolumeVoxelManager","setDimensions","setDirection","setSpacing","scalarArray","setScalars","holesPolyline","projectedPolyline","sharedDimensionIndex","holes","hole","projectedHole","firstDim","secondDim","setAtIJKPoint","point2D","convertContourToStackLabelmap","segmentationsInfo","segmentationVoxelManagers","segmentationInfo","manager","convertSurfaceToVolumeLabelmap","convertSurfaceToLabelmap","polys","convertSurfacesToVolumeLabelmap","segmentsInfo","promises","all","targetImageData","totalSize","outputVolumesInfo","extent","roundedIndex","getSurfacesAABBs","surfacesInfo","aabbs","numDimensions","cutSurfacesIntoPlanes","planesInfo","surfacesAABB","updateCacheCallback","numberOfPlanes","cutter","plane1","setCutFunction","surfacePolyData","planeInfo","sliceIndex","polyDataResults","polyDataInfo","aabb3","getPolys","setNormal","getNumberOfPoints","cutterOutput","buildLinks","loopExtraction","loopOutput","numberOfCells","loopError","progress","VIEWPORT_ELEMENT","getSvgNode","canvasHash","cacheKey","svgNodeCache","domRef","appendNode","svgLayerElement","svgNode","touched","setNodeTouched","clearUntouched","cacheEntry","internalDivElement","_getSvgLayer","svgNodeCacheForCanvas","fn","strokeWidth","svgNodeHash","existingCircleElement","attributes","stroke","newCircleElement","createElementNS","existingEllipse","rx","ry","svgEllipseElement","linkUID","annotationAnchorPoints","refPoint","findClosestPoint","boundingBoxPoints","halfWidth","halfHeight","_boundingBoxPoints","centering","canvasBoundingBox","midX","endfirstLine","endsecondLine","threeLine","zIndex","_getHash","existingFanElement","startRad","endRad","centerX","centerY","outerStartX","outerStartY","outerEndX","outerEndY","innerStartX","innerStartY","largeArcFlag","pathData","setAttributesIfNecessary","newFanElement","setNewAttributesIfValid","svgns","headLength","legacyDrawArrow","markerFullId","defs","arrowMarker","arrowPath","markerEndId","_width","existingRect","svgRectElement","Swipe","renderers","planarContourToolName","triggerSegmentationRender","segmentationRenderingEngine","renderSegmentationsForViewport","_needsRender","_pendingRenderQueue","_animationFrameSet","_animationFrameHandle","_getAllViewports","_renderFlaggedSegmentations","_throwIfDestroyed","_triggerRender","nextViewportIds","shift","_setViewportsToBeRenderedNextFrame","_getViewportIdsForSegmentation","renderSegmentation","segmentationRepresentations","_render","segmentationRenderList","representation","_addPlanarFreeHandToolIfAbsent","existingRepresentation","allSettled","segmentationDetails","status","onSegmentationRender","SEGMENTATION_RENDERED","hasTool","addTool","initialDefaultState","colorLUT","segmentations","viewportSegRepresentations","internalComputeVolumeLabelmapFromStack","segmentationImageIds","volumeLoader","internalConvertStackToVolumeLabelmap","defaultSegmentationStateManager","getDefaultRenderingConfig","_stackLabelmapImageIdReferenceMap","_labelmapImageIdReferenceMap","freeze","getState","updateState","updater","newState","getColorLUT","lutIndex","getNextColorLUTIndex","resetState","updateSegmentation","draftState","addSegmentation","newSegmentation","getLabelmapImageIds","removeSegmentation","filteredSegmentations","triggerSegmentationRemoved","addSegmentationRepresentation","renderingConfig","getSegmentationRepresentations","setRenderInactiveSegmentations","addDefaultSegmentationRepresentation","addLabelmapRepresentation","triggerSegmentationRepresentationModified","segmentReps","colorLUTIndex","_setActiveSegmentation","processLabelmapRepresentationAddition","isBaseVolumeSegmentation","updateLabelmapSegmentationImageReferences","_updateLabelmapSegmentationReferences","labelmapImageIds","updateCallback","referenceImageId","viewableLabelmapImageIdFound","labelmapImageId","isReferenceViewable","asOverlay","_updateLabelmapImageIdReferenceMap","_updateAllLabelmapSegmentationImageReferences","withNavigation","getLabelmapImageIdsForImageId","_generateMapKey","getCurrentLabelmapImageIdsForViewport","getStackSegmentationImageIdsForViewport","associatedReferenceImageAndLabelmapImageIds","removeSegmentationRepresentationsInternal","specifier","removedRepresentations","currentRepresentations","activeRepresentationRemoved","shouldRemove","removeSegmentationRepresentations","triggerSegmentationRepresentationRemoved","remainingRepresentations","removeSegmentationRepresentation","suppressEvent","currentValues","newValues","setActiveSegmentation","activeSegRep","segRep","viewportRepresentations","typeMatch","idMatch","getSegmentationRepresentationVisibility","viewportRepresentation","setSegmentationRepresentationVisibility","addColorLUT","removeColorLUT","_getStackIdForImageIds","getAllViewportSegmentationRepresentations","getSegmentationRepresentationsBySegmentationId","viewportReps","filteredReps","segmentationStyle","global","viewportsStyle","setStyle","styles","merge","currentStyles","mergedStyles","updatedStyles","copyActiveToInactiveIfNotProvided","renderInactiveSegmentations","repConfig","perSegment","allSegments","ALL_SEGMENTATIONS_KEY","segConfig","processedStyles","labelmapStyles","renderOutlineInactive","renderOutline","outlineWidthInactive","outlineWidth","renderFillInactive","renderFill","fillAlphaInactive","fillAlpha","outlineOpacityInactive","outlineOpacity","contourStyles","outlineDashInactive","outlineDash","combinedStyle","getDefaultStyle","allSegmentationsKey","getRenderInactiveSegmentations","clearSegmentationStyle","clearAllSegmentationStyles","clearViewportStyle","clearAllViewportStyles","resetToGlobalStyle","hasCustomStyle","segmentationStateManager","indexToUse","colorLUTToUse","missingColorLUTs","segmentationInputArray","segmentationInput","addContourRepresentationToViewport","contourInputArray","inputData","contourData","geometryIds","annotationUIDsMap","normalizedSegments","segmentsConfig","rest","normalizedSegment","geometryId","geometry","getGeometry","normalizeContourSegments","surfaceData","normalizeSurfaceSegments","normalizeSegments","addSegmentations","setColorLUT","colorLUTsIndex","segmentationRepresentation","colorValue","setSegmentIndexColor","colorReference","modifiedSlicesToUse","SEGMENTATION_DATA_MODIFIED","getSegmentations","getViewportSegmentations","getViewportSegmentationRepresentations","convertVolumeToStackLabelmap","segmentationVolume","computeVolumeLabelmapFromStack","internalAddSegmentationRepresentation","representationInput","getColorLUTIndex","getActiveSegmentIndex","firstSegmentIndex","segmentKeys","colorLUTOrIndex","parse","rep","removeAllSegmentations","immediate","_removeSegmentationRepresentations","labelmapDisplay","contourDisplay","removeRepresentation","surfaceDisplay","_removeRepresentationObject","removeAllSegmentationRepresentations","removeLabelmapRepresentation","removeContourRepresentation","removeSurfaceRepresentation","isSegmentIndexLocked","setSegmentIndexLocked","getAnnotationsUIDMapFromSegmentation","annotationUIDs","setAnnotationLocked","_setContourSegmentationSegmentAnnotationsLocked","getLockedSegmentIndices","segmentationListeners","addDefaultSegmentationListener","representationType","updateFunction","getUpdateFunction","listenerMap","removeSegmentationListener","debouncedHandler","eventSegmentationId","createDebouncedSegmentationListener","addSegmentationListener","destroy","contourRepresentationData","re","toolGroupFilteredByIds","tg","firstLineSegmentLength","longAxis","shortAxisPoint0","shortAxisPoint1","longAxisVector","counterClockWisePerpendicularToLongAxis","currentShortAxisVector","shortAxis","canvasCoordPoints","shortAxisDistFromCenter","vectorX","vectorY","xMid","yMid","startX","startY","endX","endY","_dragModifyHandle","movingHandleIndex","canvasCoordHandlesCurrent","firstLineSegment","secondLineSegment","proposedPoint","proposedCanvasCoord","fixedHandleCanvasCoord","fixedHandleToProposedCoordVec","fixedHandleToOldCoordVec","proposedFirstLineSegment","_movingLongAxisWouldPutItThroughShortAxis","centerOfRotation","_getSignedAngle","firstPointX","firstPointY","secondPointX","secondPointY","rotatedFirstPoint","rotatedFirstPointY","rotatedSecondPoint","rotatedSecondPointY","newFirstPoint","newSecondPoint","translateHandleIndex","canvasCoordsCurrent","longLineSegment","shortLineSegment","longLineSegmentVec","longLineSegmentVecNormalized","proposedToCurrentVec","movementLength","movementAlongLineSegmentLength","newTranslatedPoint","vectorInSecondLineDirection","extendedSecondLineSegment","worldPos4","index3","index4","handles1","handles2","scale1","scale2","widthUnit","vector1","vector2","renderResult","pointCanProjectOnLine","PlanarFreehandROITool","alwaysRenderOpenContourHandles","closeContourProximity","checkCanvasEditFallbackProximity","makeClockWise","subPixelResolution","smoothing","smoothOnAdd","smoothOnEdit","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","displayOnePointAsCrosshairs","isEditingClosed","isEditingOpen","activateDraw","activateOpenContourEndEdit","activateClosedContourEdit","activateOpenContourEdit","previousPoint","pStart","pEnd","cancelDrawing","cancelOpenContourEdit","cancelClosedContourEdit","calibratedScale","numPoints","updateClosedCachedStats","updateOpenCachedStats","baseFilteredAnnotations","annotationsToDisplay","filterAnnotationsWithinSlice","filterAnnotationsForDisplay","annotationsWithParallelNormals","td","annotationViewPlaneNormal","vector","annotationsWithinSlice","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","renderPointContourWithMarker","renderContour","_calculateStatsIfActive","worldPosIndex","worldPosIndex2","iDelta","jDelta","kDelta","ceil","worldPosEnd","canvasPosEnd","curRow","intersectionCounter","_pointIJK","getLineSegmentIntersectionsCoordinates","RectangleROITool","FILL_INSIDE_CIRCLE","ERASE_INSIDE_CIRCLE","FILL_INSIDE_SPHERE","ERASE_INSIDE_SPHERE","THRESHOLD_INSIDE_CIRCLE","THRESHOLD_INSIDE_SPHERE","THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL","brushSize","useCenterSegmentIndex","preview","previewColors","previewTimeMs","previewMoveDistance","dragMoveDistance","dragTimeMs","StrategyCallbacks","AcceptPreview","RejectPreview","Interpolate","useBallStructuringElement","noUseDistanceTransform","noUseExtrapolation","interpolateExtrapolation","_lastDragInfo","createEditData","_previewData","isDrag","timerStart","Date","now","hoverData","_hoverData","createHoverData","getOperationData","applyActiveStrategyCallback","OnInteractionStart","timer","time","rejectPreview","previewCallback","strategyData","strategy","Preview","currentCanvas","currentWorld","_calculateCursor","strokePointsWorld","currentCanvasClone","OnInteractionEnd","acceptPreview","viewRight","centerCursorInWorld","bottomCursorInWorld","topCursorInWorld","leftCursorInWorld","rightCursorInWorld","brushCursor","computeInnerCircleRadius","GetStatistics","interpolate","invalidateBrushCursor","getActiveSegmentationData","brushCursorUID","centerSegmentIndexInfo","dynamicRadiusInCanvas","circleUID1","previewData","NaN","memoMap","acceptedMemoIds","hasSegmentIndex","hasPreviewIndex","changedIndices","_historyRedoHandler","memoData","hasPreviewData","shouldResolvePreviewRequests","voxelManagerId","redoVoxelManager","ERROR_EVENT","message","cancelable","actors","volumes","referencedVolumeIdToThreshold","activeRepresentation","configColor","previewColor","previewSegmentIndex","factor","lightenColor","previewOnHover","addPreview","acceptReject","AddPreview","removeContours","viewAnnotations","contourAnnotations","fillInsideCircle","previewVoxels","segmentationVoxels","sourceVoxelManager","bound","activeIndex","startIndex","startValue","hasZeroIndex","hasPositiveIndex","polyPoint","polyIndex","polyValue","isPointInsidePolyline3D","setAtIJK","slices","getArrayOfModifiedSlices","getEllipseCornersFromCanvasCoordinates","initializeCircle","Initialize","segmentationImageData","centerIJK","brushRadius","cornersInWorld","normalizedViewUp","normalizedPlaneNormal","strokeCenters","strokeCornersWorld","centerVec","createCircleCornersForCenter","circleCornersIJK","getBoundingBoxAroundShapeIJK","createPointInEllipse","isInObjectBoundsIJK","majorAxisVec","minorAxisVec","radiusForStroke","strokePredicate","centers","radiusSquared","centerVecs","lengthSquared","projX","projY","projZ","distX","distY","distZ","createStrokePredicate","sphereObj","radius2","pointVec","distToPlane","proj","fromTopLeft","centerToTopLeft","CIRCLE_STRATEGY","regionFill","setValue","determineSegmentIndex","labelmapStatistics","CIRCLE_THRESHOLD_STRATEGY","dynamicThreshold","strategyFunction","thresholdInsideCircle","initializeRectangle","rectangleCornersIJK","coord","axisU","axisV","uLen","vLen","EPS","vproj","createPointInRectangle","RECTANGLE_STRATEGY","RECTANGLE_THRESHOLD_STRATEGY","fillInsideRectangle","getClosestImageIdForStackViewport","ImagePositionPatient","calculateDistanceToImage","numSlicesToProject","sliceNormalIndex","calculateBoundingBox","isWorld","is3D","clipBounds","DEFAULT_CONTOUR_SEG_TOOL_NAME","removeContourSegmentationAnnotation","endPointWorld","originalToolName","interpolationUID","interpolationCompleted","addContourSegmentationAnnotation","closestDistance","testIndex","wait","lastArgs","lastThis","maxWait","timerId","lastCallTime","lastInvokeTime","leading","maxing","useRAF","TypeError","invokeFunc","thisArg","startTimer","pendingFunc","shouldInvoke","timeSinceLastCall","timerExpired","trailingEdge","timeSinceLastInvoke","timeWaiting","remainingWait","debounced","isInvoking","leadingEdge","cancelAnimationFrame","cancelTimer","flush","pending","annotationCanvasPoints","handlesLeftToRight","_compareX","handlesTopToBottom","_compareY","_determineCorners","PIXEL_UNITS","VOXEL_UNITS","SUPPORTED_REGION_DATA_TYPES","SUPPORTED_LENGTH_VARIANT","SUPPORTED_PROBE_VARIANT","UNIT_MAPPING","SQUARE","getCalibratedLengthUnitsAndScale","hasPixelSpacing","volumeUnit","calibrationType","sequenceOfUltrasoundRegions","UNCALIBRATED","regions","region","regionLocationMinX0","regionLocationMaxX1","regionLocationMinY0","regionLocationMaxY1","regionDataType","physicalUnitsXDirection","physicalUnitsYDirection","physicalDeltaX","physicalDeltaY","USER","ERROR","getCalibratedProbeUnitsAndValue","supportedRegionsMetadata","referencePixelX0","referencePixelY0","yValue","getCalibratedAspect","_getSphereBoundsInfo","circlePoints","directionVectors","radiusWorld","rowCosine","columnCosine","vecNormal","topLeftIJK","bottomRightIJK","pointsIJK","_computeBoundsIJK","getSphereBoundsInfo","scanAxis","getSphereBoundsInfoFromViewport","getViewportForAnnotation","pointInSphere","sphere","SegmentStatsCalculator","calculators","indices","statsInit","statsData","calculator","lpad","string","character","seed","onBoundary","equals","startNode","permutations","perms","permutation","permute","perm","countNonZeroes","prunedPermutations","visits","currentArgs","job","getArgs","prevArgs","previousArgs","iKey","markAsVisited","member","markAsFlooded","nextArgs","pushAdjacent","markAsBoundary","getBrushToolInstances","toolInstances","indexIJK","onEdge","getNeighborIndex","deltaI","deltaJ","neighborCanvas","isSegmentOnEdge","isSegmentOnEdgeCanvas","segmentationActorEntry","deltaK","neighborIJK","isSegmentOnEdgeIJK","neighborRange","neighborIndex","desiredRepresentation","getScalarValueFromWorld","getSegmentIndexAtWorldForLabelmap","annotationsSet","getSegmentIndexAtWorldForContour","WEBGPU_MEMORY_LIMIT","DEFAULT_GROWCUT_OPTIONS","windowSize","maxProcessingTime","inspection","numCyclesInterval","numCyclesBelowThreshold","referenceVolumeId","workGroupSize","labelmap","numIterations","volumePixelData","requiredLimits","maxStorageBufferBindingSize","maxBufferSize","adapter","navigator","gpu","requestAdapter","device","requestDevice","BUFFER_SIZE","UPDATED_VOXELS_COUNTER_BUFFER_SIZE","Uint32Array","BYTES_PER_ELEMENT","BOUNDS_BUFFER_SIZE","Int32Array","shaderModule","createShaderModule","code","paramsArrayValues","gpuParamsBuffer","createBuffer","usage","GPUBufferUsage","UNIFORM","COPY_DST","gpuVolumePixelDataBuffer","STORAGE","queue","writeBuffer","gpuLabelmapBuffers","COPY_SRC","gpuStrengthBuffers","gpuCounterBuffer","gpuBoundsBuffer","initialBounds","bindGroupLayout","createBindGroupLayout","binding","GPUShaderStage","COMPUTE","bindGroups","outputLabelmapBuffer","outputStrengthBuffer","previouLabelmapBuffer","previousStrengthBuffer","createBindGroup","layout","resource","pipeline","createComputePipeline","createPipelineLayout","bindGroupLayouts","compute","module","entryPoint","constants","workGroupSizeX","workGroupSizeY","workGroupSizeZ","numWorkGroups","gpuUpdatedVoxelsCounterStagingBuffer","MAP_READ","limitProcessingTime","performance","currentInspectionNumCyclesInterval","belowThresholdCounter","commandEncoder","createCommandEncoder","passEncoder","beginComputePass","setPipeline","setBindGroup","dispatchWorkgroups","copyBufferToBuffer","submit","finish","mapAsync","GPUMapMode","READ","updatedVoxelsCounterResultBuffer","getMappedRange","updatedVoxelsRatio","unmap","outputLabelmapBufferIndex","labelmapStagingBuffer","boundsStagingBuffer","labelmapResultBuffer","labelmapResult","boundsResultBuffer","boundsResult","clearBounds","setBounds","POSITIVE_SEED_VALUE","NEGATIVE_SEED_VALUE","_createAndCacheSegmentationSubVolumeForBoundingBox","subVolPixelData","startSliceIndex","stopSliceIndex","pixelsPerSlice","zOffset","_setPositiveSeedValues","sliceOffset","bfs","slicePixelIndex","volumeVoxelIndex","volumeVoxelValue","scanLine","limitX","incX","_setNegativeSeedValues","runGrowCutForBoundingBox","subVolumeBoundsIJK","POSITIVE_SEED_VARIANCE","NEGATIVE_SEED_VARIANCE","vecColumn","sphereCenterPoint","refVolImageData","topCirclePoint","bottomCirclePoint","sphereBoundsInfo","_getGrowCutSphereBoundsInfo","_createAndCacheSegmentationSubVolumeForSphere","refVolumePixelData","worldStartPos","ijkStartPosition","referencePixelValue","positiveSeedVarianceValue","minPositivePixelValue","maxPositivePixelValue","neighborsCoordDelta","startVoxelIndex","ijkVoxel","neighborCoordDelta","nz","neighborVoxelIndex","neighborPixelValue","ijkSphereCenter","negativeSeedVarianceValue","minNegativePixelValue","maxNegativePixelValue","rotationAngle","worldQuat","vecRotation","worldCircleBorderPoint","ijkCircleBorderPoint","runGrowCutForSphere","vec","sphereBoundsIJK","_createSubVolumeFromSphere","MAX_POSITIVE_SEEDS","calculateGrowCutSeeds","refImageData","referenceVolumeVoxelManager","neighborhoodRadius","initialNeighborhoodRadius","positiveK","positiveStdDevMultiplier","negativeK","negativeStdDevMultiplier","negativeSeedMargin","negativeSeedsTargetPatches","ijkStart","initialStats","positiveIntensityMin","positiveIntensityMax","currentQueueIndex","neighborValue","positiveSum","positiveSumSq","positiveCount","positiveMean","positiveVariance","negativeDiffThreshold","minXm","minYm","minZm","maxXm","maxYm","maxZm","attempts","patchesAdded","maxAttempts","rz","centerValue","patchContributed","runOneClickGrowCut","positiveSeedLabel","negativeSeedLabel","tool","getViewportsInfo","getDeltaPoints","curr","getMeanPoints","_subtractPoints2D","getDeltaDistance","_getDistance2D","_getDistance3D","getDeltaDistanceBetweenIPoints","_getMeanDistanceBetweenAllIPoints","lastDistance","copyPointsList","copyPoints","getMeanTouchPoints","touch","identifier","radiusX","radiusY","force","pairedDistance","triggerAnnotationRenderForToolGroupIds","toolGroupIds","DesiredOutputPrecision","DEFAULT","SINGLE","DOUBLE","Constants","AttributeCopyOperations","COPYTUPLE","INTERPOLATE","PASSDATA","ALLCOPY","AttributeLimitTypes","MAX","EXACT","NOLIMIT","AttributeTypes","SCALARS","VECTORS","NORMALS","TCOORDS","TENSORS","GLOBALIDS","PEDIGREEIDS","EDGEFLAG","NUM_ATTRIBUTES","CellGhostTypes","DUPLICATECELL","HIGHCONNECTIVITYCELL","LOWCONNECTIVITYCELL","REFINEDCELL","EXTERIORCELL","HIDDENCELL","PointGhostTypes","DUPLICATEPOINT","HIDDENPOINT","ghostArrayName","vtkErrorMacro","dataDescription","EMPTY","Float64Array","setGetArray","getArray","classHierarchy","setExtent","deleted","_len","inExtent","_key","extentArray","changeDetected","dims","nCells","SINGLE_POINT","X_LINE","Y_LINE","Z_LINE","XY_PLANE","YZ_PLANE","XZ_PLANE","XYZ_GRID","coords","getSpatialExtent","ex","computeTransforms","ain","aout","indexToWorldVec3","indexToWorldBounds","bin","bout","worldToIndexBounds","onModified","getCenter","computeHistogram","voxelFunction","yStride","zStride","pixels","maximum","minimum","sumOfSquares","isum","inum","average","sigma","computeIncrements","increments","incr","computeOffsetIndex","_ref","getNumberOfComponents","getOffsetIndexFromWorld","offsetIndex","getComponent","vtkImageData$1","ColorSpace","Scale","ScalarMappingTarget","vtkDebugMacro","vtkWarningMacro","vtkColorTransferFunctionLabToMsh","lab","msh","L","M","vtkColorTransferFunctionAdjustHue","unsatM","hueSpin","vtkColorTransferFunctionInterpolateDiverging","rgb1","rgb2","lab1","lab2","msh1","msh2","localS","adiff","vtkColorTransferFunctionAngleDiff","Mmid","mshTmp","labTmp","vtkColorTransferFunctionMshToLab","clamping","colorSpace","RGB","hSVWrap","nanColor","belowRangeColor","aboveRangeColor","useAboveRangeColor","useBelowRangeColor","allowDuplicateScalars","tableSize","buildTime","discretize","numberOfValues","setGet","enum","setArray","addRGBPointLong","sharpness","removePoint","sortAndUpdateRange","addHSVPoint","addHSVPointLong","rgb","hsv","setNodes","before","after","modifiedInvoked","updateRange","oldRange","mappingRange","retVal","movePoint","oldX","newX","addRGBSegment","r1","g1","r2","g2","addHSVSegment","h1","s1","h2","hsv1","hsv2","mapValue","indexedLookup","numNodes","getAnnotatedValueIndexInternal","getNanColorByReference","nodeVal","getRedValue","getGreenValue","getBlueValue","xStart_","xEnd_","xStart","xEnd","lastR","lastG","lastB","tmpVec","usingLogScale","LOG10","logStart","logEnd","logX","log10","tidx","deltaRange","xn","discretizeIndex","getUseAboveRangeColor","getUseBelowRangeColor","HSV","hsvTmp","LAB","DIVERGING","ss","sss","h3","h4","getUint8Table","withAlpha","getMTime","tableWithAlpha","nbChannels","tmpTable","numComponents","getNumberOfTuples","buildFunctionFromTable","getNumberOfAvailableColors","nNodes","getIndexedColor","nodeValue","fillFromDataPointer","nb","ptr","originalRange","adjustRange","functionRange","estimateMinNumberOfSamples","findMinimumXDistance","currentDist","mapScalarsThroughTable","outFormat","inputOffset","mapDataIndexed","alpha","getAlpha","inIncr","outputV","inputV","RGBA","LUMINANCE","LUMINANCE_ALPHA","colorMap","oldColorSpace","isModified","oldNanColor","NanColor","oldNodes","callModified","vtkColorTransferFunction","vtkColorTransferFunction$1","out","fromValues","copy","subtract","multiply","divide","scaleAndAdd","squaredDistance","squaredLength","negate","inverse","normalize","bx","by","bz","lerp","hermite","factorTimes2","factor1","factor2","factor3","factor4","bezier","inverseFactor","inverseFactorTimesTwo","zScale","transformMat4","transformMat3","transformQuat","q","qx","qy","qz","qw","uvx","uvy","uvz","uuvx","uuvy","uuvz","w2","rotateX","rotateY","mag","cosine","zero","exactEquals","a0","b0","mul","div","sqrDist","sqrLen","stride","arg","l","bisector","compare1","compare2","lo","hi","mid","zip","interpolator","samples"],"sourceRoot":""}