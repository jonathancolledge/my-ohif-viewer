{"version":3,"file":"6563.bundle.3080b9779dc74ff37d1e.js","mappings":"kHAGA,QAHA,SAAkBA,EAAeC,EAAoBC,GACjD,MAAO,GAAGF,MAAkBC,MAAuBC,GACvD,C,kDCDA,MA8BA,EA9B6BC,GACrBA,EAAIC,SACAD,EAAIE,QACG,mBAAGC,UAEVH,EAAII,OACG,mBAAGC,SAEVL,EAAIM,QACG,mBAAGC,UAEP,mBAAGC,MAEVR,EAAIE,QACAF,EAAII,OACG,mBAAGK,QAEVT,EAAIM,QACG,mBAAGI,SAEP,mBAAGC,KAEVX,EAAII,OACIJ,EAAIM,SAAW,mBAAGM,SAAY,mBAAGC,IAEzCb,EAAIM,QACG,mBAAGQ,UADd,C,+ECrBJ,MAAMC,EAAiB,IAahB,SAASC,KACZ,IAAAC,sBAAqBF,EACzB,CAJAA,EAAeG,mBAVUC,IAGrB,MAAMC,GADND,ECIsC,CAACA,IAClCA,EAAWE,OACZF,EAAWE,KAAO,CAAC,GAElBF,EAAWE,KAAKC,cACjBH,EAAWE,KAAKC,YAAc,CAAC,GAE5BH,GDXMI,CADbJ,ECPkC,CAACA,IAC9BA,EAAWE,OACZF,EAAWE,KAAO,CAAC,GAElBF,EAAWE,KAAKG,UACjBL,EAAWE,KAAKG,QAAU,CAAC,GAE1BL,EAAWE,KAAKG,QAAQC,UACzBN,EAAWE,KAAKG,QAAQC,QAAU,CAAC,GAEhCN,GDHMO,CAA8BP,KAEpBtB,cACjB8B,GAAW,IAAAC,6BAA4BR,GAC7CD,EAAWQ,SAAWA,EACtB,MAAME,GAAY,IAAAC,iCAAgCV,GAElD,OADAD,EAAWU,UAAYA,EAChBV,KAGX,IAAAF,sBAAqBF,E,6DEfd,SAASgB,EAAyBC,GACrC,MAAMC,EAAc,CAChBD,mBAEJ,IAAAE,cAAa,EAAAC,YAAa,EAAAC,OAAOC,mBAAoBJ,EACzD,C,4DCLO,SAASK,EAA4BN,GACxC,MAAMC,EAAc,CAChBD,mBAEJ,IAAAE,cAAa,EAAAC,YAAa,EAAAC,OAAOG,sBAAuBN,EAC5D,C,4DCLO,SAASO,EAA2BR,GACvC,MAAMC,EAAc,CAChBD,mBAEJ,IAAAE,cAAa,EAAAC,YAAa,EAAAC,OAAOK,qBAAsBR,EAC3D,C,6DCLO,SAASS,EAA0CC,EAAYX,EAAgBY,GAClF,MAAMX,EAAc,CAChBD,iBACAY,OACAD,eAEJ,IAAAT,cAAa,EAAAC,YAAa,EAAAC,OAAOS,qCAAsCZ,EAC3E,C,6DCPO,SAASa,EAAyCH,EAAYX,EAAgBY,GACjF,MAAMX,EAAc,CAChBU,aACAX,iBACAY,SAEJ,IAAAV,cAAa,EAAAC,YAAa,EAAAC,OAAOW,oCAAqCd,EAC1E,C,kDCRO,SAASe,EAAgBhB,GAE5B,OADiC,KACDgB,gBAAgBhB,EACpD,C,kDCHO,SAASiB,EAAgCN,EAAYO,GACxD,MAAMC,GAAiB,QAA8BR,EAAYO,GACjE,IAAKC,EACD,OAAO,IAAIC,IAQf,OANuBC,OAAOC,QAAQH,EAAeI,UAAUC,OAAO,CAACC,GAAMC,EAAcC,MAClFA,EAAQC,SACTH,EAAII,IAAIC,OAAOJ,IAEZD,GACR,IAAIL,IAEX,C,+FCXA,MAAMW,EAAQ,CAAC,EAAAC,UAAUC,OAAQ,EAAAD,UAAUE,QAAS,EAAAF,UAAUG,SAkB9D,QAjBA,SAAmCC,GAC/B,OAAO,KAAMC,WAAWC,OAAO,EAAGC,kBAC9B,MAAMC,EAAqBnB,OAAOoB,KAAKF,GACvC,IAAK,IAAIG,EAAI,EAAGA,EAAIF,EAAmBG,OAAQD,IAC3C,GAAIN,IAAaI,EAAmBE,IAG/BH,EAAYH,IAGbL,EAAMa,SAASL,EAAYH,GAAUS,MACrC,OAAO,EAGf,OAAO,GAEf,C,8JCRA,MAAM,kCAAEC,EAAiC,uBAAEC,EAAsB,QAAEC,GAAY,EAAAC,SAC/E,SAASC,EAA0BlF,EAAKmB,EAAYgE,GAChDC,KAAKC,iBAAkB,EACvB,MAAMpD,EAAcjC,EAAIsF,QAClB,cAAEC,EAAa,QAAEC,GAAYvD,EAC7BwD,EAAYF,EAAcG,OAC1BC,GAAiB,IAAAC,mBAAkBJ,GACzC,IAAKG,EACD,OAEJ,MAAM,SAAEE,GAAaF,EACfG,EAAmB3E,EAAWE,KAAK0E,QAAQd,SAASe,IAAIH,EAASI,gBACjE,QAAEC,EAAO,KAAEC,EAAI,KAAEC,GAAStB,EAAkCe,EAAUT,KAAKiB,cAAcC,oBAC/FlB,KAAKmB,SAAW,CACZT,mBACAU,iBAAkB,CAACf,GACnBgB,wBAAoBC,EACpBC,UAAW,EACXxF,cAEJiE,KAAKwB,WAAa,CACdzF,aACAgE,sBACAe,UACAC,OACAC,OACAS,eAAe,GAEnB,KAAMC,uBAAwB,EAC9BtB,EAAQuB,iBAAiB,EAAA3E,OAAO4E,SAAU5B,KAAK6B,kCAC/CzB,EAAQuB,iBAAiB,EAAA3E,OAAO8E,WAAY9B,KAAK+B,oCACjD3B,EAAQuB,iBAAiB,EAAA3E,OAAOgF,YAAahC,KAAK6B,kCAClDzB,EAAQuB,iBAAiB,EAAA3E,OAAOiF,UAAWjC,KAAK6B,kCAChDzB,EAAQuB,iBAAiB,EAAA3E,OAAOkF,WAAYlC,KAAK+B,oCACjD3B,EAAQuB,iBAAiB,EAAA3E,OAAOmF,UAAWnC,KAAK6B,mCAChD,IAAAO,mBAAkBhC,EACtB,CACA,SAASiC,EAA4BjC,GACjC,KAAMsB,uBAAwB,EAC9BtB,EAAQkC,oBAAoB,EAAAtF,OAAO4E,SAAU5B,KAAK6B,kCAClDzB,EAAQkC,oBAAoB,EAAAtF,OAAO8E,WAAY9B,KAAK+B,oCACpD3B,EAAQkC,oBAAoB,EAAAtF,OAAOgF,YAAahC,KAAK6B,kCACrDzB,EAAQkC,oBAAoB,EAAAtF,OAAOiF,UAAWjC,KAAK6B,kCACnDzB,EAAQkC,oBAAoB,EAAAtF,OAAOkF,WAAYlC,KAAK+B,oCACpD3B,EAAQkC,oBAAoB,EAAAtF,OAAOmF,UAAWnC,KAAK6B,mCACnD,IAAAU,oBAAmBnC,EACvB,CACA,SAAS2B,EAAmCnH,GACxC,MAAMiC,EAAcjC,EAAIsF,QAClB,cAAEC,EAAa,QAAEC,GAAYvD,EAC7B2F,EAAWrC,EAAcsC,MACzBpC,EAAYF,EAAcG,OAC1BC,GAAiB,IAAAC,mBAAkBJ,IACnC,SAAEK,GAAaF,GACf,oBAAER,EAAmB,KAAEgB,EAAI,KAAEC,EAAI,QAAEF,GAAYd,KAAKwB,YACpD,UAAED,EAAS,iBAAEH,EAAgB,mBAAEC,EAAkB,WAAEtF,GAAeiE,KAAKmB,SAC7EnB,KAAK0C,WAAWtC,EAASrE,GACzB,MAAM4G,EAAkBvB,EAAiBA,EAAiB7B,OAAS,GAC7DqD,EAAiBnC,EAASoC,cAAcF,GACxCG,EAAe,cACrB,cAAcA,EAAcN,EAAUI,GACtC,MAAMG,EAAQC,KAAKC,IAAI,SAASH,EAAc/B,IACxCmC,EAAQF,KAAKC,IAAI,SAASH,EAAc9B,IAC9C,GAAI+B,GAASjC,EAAQ,IAAMoC,GAASpC,EAAQ,GACxC,YAEuBQ,IAAvBD,GACArB,KAAKmD,gCAAgCvI,GAEzC,MACMwI,EAAmB7B,EADF5B,EAAuBS,EAASgB,EAAkBf,EAAWL,KAAKwB,YAEzFxB,KAAKmB,SAASI,UAAY6B,OACC9B,IAAvBD,GAAoCD,EAAiB7B,OAAS,GAC9DS,KAAKqD,sBAAsBzI,GAAK,GAEpCoF,KAAKmB,SAASmC,UAAYtD,KAAKuD,iBACE,IAA7BvD,KAAKmB,SAASmC,WAIlBtD,KAAKmB,SAASqC,kBAAoBxD,KAAKyD,gCAAgC7I,QAC5C0G,IAAvBD,GACArB,KAAK0D,uBAAuB9I,GAAK,KACjCoF,KAAK2D,iCAAgC,GACrC3D,KAAK4D,0BAA0BhJ,KAEnC,OAAsCmF,IATlCC,KAAK4D,0BAA0BhJ,EAUvC,CACA,SAASgJ,EAA0BhJ,GAC/B,MAAMiC,EAAcjC,EAAIsF,QAClB,QAAEE,GAAYvD,EACd0D,GAAiB,IAAAC,mBAAkBJ,IACnC,SAAEK,EAAQ,gBAAEoD,GAAoBtD,GAChC,WAAExE,EAAU,oBAAEgE,GAAwBC,KAAKwB,YAC3C,kBAAEgC,EAAiB,iBAAEpC,GAAqBpB,KAAKmB,UACrD,OAAsBpF,EAAY,CAC9B+H,OAAQN,EACRO,QAAQ,EACRC,uBAAwB,IAAwBC,WACjDxD,GACC1E,EAAWmI,gBACXnI,EAAWmI,eAAgB,IAE/B,IAAAC,2BAA0BpI,EAAYqE,GACtC,MAAMgE,EAAsBhD,EAAiBiD,MAC7CrE,KAAKmB,SAAW,CACZT,iBAAkB8C,EAClBpC,iBAAkB,CAACgD,GACnB/C,wBAAoBC,EACpBC,UAAW,EACX+B,eAAWhC,EACXvF,eAEJ,OAAsCgE,EAC1C,CACA,SAAS0D,EAAgC7I,GACrC,MAAM,iBAAE8F,EAAgB,iBAAEU,EAAgB,mBAAEC,EAAkB,UAAEiC,GAActD,KAAKmB,SACnF,QAA2BG,IAAvBD,QAAkDC,IAAdgC,EACpC,OAEJ,MAAMzG,EAAcjC,EAAIsF,QAClB,QAAEE,GAAYvD,EACdyH,EAA4B,IAAIlD,GAKtC,IAAImD,EACAC,EALJ7E,EAAuBS,EAASkE,EAA2B5D,EAAiB4C,GAAYtD,KAAKwB,YACzF8C,EAA0B/E,OAAS6B,EAAiB7B,QACpD+E,EAA0BD,MAI1BhD,EAAqBiC,GACrBiB,EAAWjB,EACXkB,EAAYnD,IAGZkD,EAAWlD,EACXmD,EAAYlB,GAEhB,MAAMmB,EAAkC,cAAc/D,EAAiB6D,GAAWD,EAA0B,IACtGI,EAAiC,cAAchE,EAAiB6D,GAAWD,EAA0BA,EAA0B/E,OAAS,IACxIoF,EAAmC,cAAcjE,EAAiB8D,GAAYF,EAA0B,IACxGM,EAAkC,cAAclE,EAAiB8D,GAAYF,EAA0BA,EAA0B/E,OAAS,IAC1IsF,EAAY,GAClB,IAAK,IAAIvF,EAAI,EAAGA,EAAIiF,EAAUjF,IAAK,CAC/B,MAAMwF,EAAcpE,EAAiBpB,GACrCuF,EAAUE,KAAK,CAACD,EAAY,GAAIA,EAAY,IAChD,CACA,IAAIE,EAAkBP,EAAkCG,EACpDK,EAAkBP,EAAiCC,EACvD,GAAIK,EAAkBC,EAClB,IAAK,IAAI3F,EAAI,EAAGA,EAAIgF,EAA0B/E,OAAQD,IAAK,CACvD,MAAMwF,EAAcR,EAA0BhF,GAC9CuF,EAAUE,KAAK,CAACD,EAAY,GAAIA,EAAY,IAChD,MAGA,IAAK,IAAIxF,EAAIgF,EAA0B/E,OAAS,EAAGD,GAAK,EAAGA,IAAK,CAC5D,MAAMwF,EAAcR,EAA0BhF,GAC9CuF,EAAUE,KAAK,CAACD,EAAY,GAAIA,EAAY,IAChD,CAEJ,IAAK,IAAIxF,EAAIkF,EAAWlF,EAAIoB,EAAiBnB,OAAQD,IAAK,CACtD,MAAMwF,EAAcpE,EAAiBpB,GACrCuF,EAAUE,KAAK,CAACD,EAAY,GAAIA,EAAY,IAChD,CACA,MAAMI,EAAY,GAClB,IAAK,IAAI5F,EAAIiF,EAAUjF,EAAIkF,EAAWlF,IAAK,CACvC,MAAMwF,EAAcpE,EAAiBpB,GACrC4F,EAAUH,KAAK,CAACD,EAAY,GAAIA,EAAY,IAChD,CAKA,GAJAE,EACIL,EAAmCD,EACvCO,EACIL,EAAkCH,EAClCO,EAAkBC,EAClB,IAAK,IAAI3F,EAAI,EAAGA,EAAIgF,EAA0B/E,OAAQD,IAAK,CACvD,MAAMwF,EAAcR,EAA0BhF,GAC9C4F,EAAUH,KAAK,CAACD,EAAY,GAAIA,EAAY,IAChD,MAGA,IAAK,IAAIxF,EAAIgF,EAA0B/E,OAAS,EAAGD,GAAK,EAAGA,IAAK,CAC5D,MAAMwF,EAAcR,EAA0BhF,GAC9C4F,EAAUH,KAAK,CAACD,EAAY,GAAIA,EAAY,IAChD,CAKJ,OAHsBlF,EAAQiF,GACRjF,EAAQsF,GACyBL,EAAYK,CAEvE,CACA,SAASrD,EAAiCjH,GACtC,MAAMiC,EAAcjC,EAAIsF,QAClB,QAAEE,GAAYvD,EACpBmD,KAAKmF,0BAA0B/E,EACnC,CACA,SAAS+E,EAA0B/E,GAC/B,MAAMG,GAAiB,IAAAC,mBAAkBJ,IACnC,SAAEK,GAAaF,GACf,WAAExE,EAAU,oBAAEgE,GAAwBC,KAAKwB,WACjDxB,KAAKoF,eACL,MAAM,kBAAE5B,EAAiB,iBAAE9C,GAAqBV,KAAKmB,SACrD,GAAIqC,EAAmB,CACnB,MAAM6B,GAAgB,OAAarF,KAAKiB,cAAelF,IACjD,OAAsBiE,KAAKiB,cAAeuC,EAAmB9C,GAC7D8C,EACA8B,EAAiBtF,KAAKiB,eAAesE,UAAY,CAAC,GACxD,OAAsBxJ,EAAY,CAC9B+H,OAAQuB,EACRtB,QAAQ,EACRC,uBAAwB,IAAwBC,WACjDxD,EAAU,CACT8E,SAAU,CACNC,UAAWF,EAAeE,QAC1BC,QAASH,EAAeG,WAG5B1J,EAAWmI,gBACXnI,EAAWmI,eAAgB,IAE/B,IAAAC,2BAA0BpI,EAAYqE,EAC1C,CACAJ,KAAKC,iBAAkB,EACvBD,KAAKmB,cAAWG,EAChBtB,KAAKwB,gBAAaF,GAClB,OAAsCvB,GACtCC,KAAKqC,4BAA4BjC,EACrC,CACA,SAASsF,EAAwBtF,GAC7BJ,KAAKmF,0BAA0B/E,EACnC,CAmBA,QAlBA,SAAuCuF,GACnCA,EAAa7F,0BACTA,EAA0B8F,KAAKD,GACnCA,EAAatD,4BACTA,EAA4BuD,KAAKD,GACrCA,EAAa5D,mCACTA,EAAmC6D,KAAKD,GAC5CA,EAAa9D,iCACTA,EAAiC+D,KAAKD,GAC1CA,EAAa/B,0BACTA,EAA0BgC,KAAKD,GACnCA,EAAalC,gCACTA,EAAgCmC,KAAKD,GACzCA,EAAaD,wBACTA,EAAwBE,KAAKD,GACjCA,EAAaR,0BACTA,EAA0BS,KAAKD,EACvC,C,mLCrPA,MAAM,uBAAEhG,EAAsB,qCAAEkG,EAAoC,uCAAEC,EAAsC,kCAAEpG,GAAuC,EAAAG,SACrJ,SAASkG,EAAanL,EAAKmB,EAAYgE,GACnCC,KAAKgG,WAAY,EACjB,MAAMnJ,EAAcjC,EAAIsF,QAClB,cAAEC,EAAa,QAAEC,GAAYvD,EAC7BwD,EAAYF,EAAcG,OAC1BC,GAAiB,IAAAC,mBAAkBJ,IACnC,SAAEK,GAAaF,EACf0F,GAA+B,OAAoBrL,EAAIsF,OAAOgG,SAChElG,KAAKiB,cAAckF,gCACjB,QAAErF,EAAO,KAAEC,EAAI,KAAEC,GAAStB,EAAkCe,EAAUT,KAAKiB,cAAcC,qBAAuB,CAAC,EAClHJ,GAAYC,GAASC,IAG1BhB,KAAKoG,SAAW,CACZC,aAAc,CAAChG,GACfiG,cAAe,EACfL,+BACAM,eAAe,GAEnBvG,KAAKwB,WAAa,CACdzF,aACAgE,sBACAe,UACAC,OACAC,OACAS,eAAe,GAEnB,KAAMC,uBAAwB,EAC9BtB,EAAQuB,iBAAiB,EAAA3E,OAAO4E,SAAU5B,KAAKwG,qBAC/CpG,EAAQuB,iBAAiB,EAAA3E,OAAO8E,WAAY9B,KAAKyG,uBACjDrG,EAAQuB,iBAAiB,EAAA3E,OAAOgF,YAAahC,KAAKwG,qBAClDpG,EAAQuB,iBAAiB,EAAA3E,OAAOiF,UAAWjC,KAAKwG,qBAChDpG,EAAQuB,iBAAiB,EAAA3E,OAAOkF,WAAYlC,KAAKyG,uBACjDrG,EAAQuB,iBAAiB,EAAA3E,OAAOmF,UAAWnC,KAAKwG,sBAChD,IAAApE,mBAAkBhC,GACtB,CACA,SAASsG,EAAetG,GACpB,KAAMsB,uBAAwB,EAC9BtB,EAAQkC,oBAAoB,EAAAtF,OAAO4E,SAAU5B,KAAKwG,qBAClDpG,EAAQkC,oBAAoB,EAAAtF,OAAO8E,WAAY9B,KAAKyG,uBACpDrG,EAAQkC,oBAAoB,EAAAtF,OAAOgF,YAAahC,KAAKwG,qBACrDpG,EAAQkC,oBAAoB,EAAAtF,OAAOiF,UAAWjC,KAAKwG,qBACnDpG,EAAQkC,oBAAoB,EAAAtF,OAAOkF,WAAYlC,KAAKyG,uBACpDrG,EAAQkC,oBAAoB,EAAAtF,OAAOmF,UAAWnC,KAAKwG,sBACnD,IAAAjE,oBAAmBnC,EACvB,CACA,SAASqG,EAAsB7L,GAC3B,MAAMiC,EAAcjC,EAAIsF,QAClB,cAAEC,EAAa,QAAEC,GAAYvD,EAC7B2F,EAAWrC,EAAcsC,MACzBpC,EAAYF,EAAcG,OAC1BC,GAAiB,IAAAC,mBAAkBJ,IACnC,SAAEK,GAAaF,GACf,WAAExE,EAAU,oBAAEgE,EAAmB,KAAEgB,EAAI,KAAEC,EAAI,QAAEF,EAAO,cAAEW,GAAmBzB,KAAKwB,YAChF,cAAE8E,EAAa,aAAED,EAAY,cAAEE,GAAkBvG,KAAKoG,SAC5DpG,KAAK0C,WAAWtC,EAASrE,EAAY,CAAEwK,kBACvC,MAAM5D,EAAkB0D,EAAaA,EAAa9G,OAAS,GACrDqD,EAAiBnC,EAASoC,cAAcF,GACxCG,EAAe,cACrB,cAAcA,EAAcN,EAAUI,GACtC,MAAMG,EAAQC,KAAKC,IAAI,SAASH,EAAc/B,IACxCmC,EAAQF,KAAKC,IAAI,SAASH,EAAc9B,IAC9C,KAAI+B,GAASjC,EAAQ,IAAMoC,GAASpC,EAAQ,IAA5C,CAGA,GAAIW,EAAe,CACfzB,KAAKgG,WAAY,EACjB,MAAM,YAAEW,GAAgB9J,EAClB+J,EAAgBD,EAAYlE,OAC5B,QAAEpG,GAAYN,EAAWE,KAAKG,SAC9B,cAAEyK,GAAkBxK,EAC1BwK,EAAc,IAAMD,EAAc,GAClCC,EAAc,IAAMD,EAAc,GAClCC,EAAc,IAAMD,EAAc,GAClCvK,EAAQyK,UAAW,CACvB,KACK,CACD,MAAMC,EAAgB/G,KAAKgH,8BAA8BpM,GACzD,QAAsB0G,IAAlByF,EACA/G,KAAKiH,mBAAmBrM,EAAKmM,OAE5B,CACD,MAAMG,EAAiBvH,EAAuBS,EAASiG,EAAchG,EAAWL,KAAKwB,YACrFxB,KAAKoG,SAASE,cAAgBA,EAAgBY,CAClD,CACAnL,EAAWoL,aAAc,CAC7B,EACA,OAAsCpH,GAClChE,EAAWoL,cACX,IAAAhD,2BAA0BpI,EAAYqE,EAAS,EAAAgH,YAAYC,eAzB/D,CA2BJ,CACA,SAASb,EAAoB5L,GACzB,MAAM,kBAAE0M,GAAsBtH,KAAKiB,eAC7B,aAAEoF,EAAY,6BAAEJ,GAAiCjG,KAAKoG,SACtDmB,EAAalB,EAAa,GAC1BmB,EAAYnB,EAAaA,EAAa9G,OAAS,GAC/C1C,EAAcjC,EAAIsF,QAClB,QAAEE,GAAYvD,EACpBmD,KAAKoF,eACLpF,KAAKoG,SAASG,eAAgB,EAC1Be,IACCzB,EAAqC0B,EAAYC,EAAWxH,KAAKiB,cAAcwG,uBAChFzH,KAAK0H,wBAAwBtH,EAAS,CAAE6F,iCAGxCjG,KAAK2H,0BAA0BvH,EAAS,CAAE6F,gCAElD,CACA,SAAS0B,EAA0BvH,EAASwH,GACxC5H,KAAK6H,mCACL,MAAM,aAAExB,GAAiBrG,KAAKoG,UACxB,6BAAEH,EAA4B,gBAAE6B,GAAoBF,GAAW,CAAC,EACtE,GAAIE,GAAmBzB,EAAa9G,OAASuI,EACzC,OAAO,EAEX,GAAI9H,KAAK+H,YAAY3H,EAASiG,GAC1B,OAAO,EAEX,MAAM,WAAEtK,EAAU,oBAAEgE,GAAwBC,KAAKwB,WAC3CjB,GAAiB,IAAAC,mBAAkBJ,IACnC,SAAEK,EAAQ,gBAAEoD,GAAoBtD,EACtCZ,EAAuBS,EAASiG,EAAcA,EAAa,GAAIrG,KAAKwB,YACpE6E,EAAahC,MACb,MAAMgB,GAAgB,OAAarF,KAAKiB,cAAelF,IACjD,OAAsBiE,KAAKiB,cAAeoF,GAC1CA,EACNrG,KAAKgI,sBAAsBjM,EAAY,CACnC+H,OAAQuB,EACRtB,QAAQ,EACRC,uBAAwB,IAAwBC,WACjDxD,GACH,MAAM,QAAEpE,GAAYN,EAAWE,KAAKG,QASpC,OARKC,GAASyK,WACV,IAAAmB,mCAAkClM,EAAYkK,GAElDjG,KAAKgG,WAAY,EACjBhG,KAAKoG,cAAW9E,EAChBtB,KAAKwB,gBAAaF,GAClB,OAAsCvB,GACtCC,KAAK0G,eAAetG,IACb,CACX,CACA,SAASyH,IACL,MAAM,aAAExB,GAAiBrG,KAAKoG,SACxB8B,EAAY7B,EAAa9G,OACzB4I,EAAa,CAAC9B,EAAa,GAAIA,EAAa6B,EAAY,IACxDE,EAAwB/B,EAAagC,MAAM,GAAI,GAAGA,MAAM,GACxDC,EAAcxC,EAAuCsC,EAAuBD,EAAW,GAAIA,EAAW,IAAI,GAChH,GAAIG,EAAa,CACb,MAAMC,EAAoBD,EAAY,GAElCtI,KAAKoG,SAASC,aADQ,IAAtBkC,EAC6BlC,EAAamC,OAAO,GAGpBnC,EAAamC,OAAO,EAAGD,EAE5D,CACJ,CACA,SAASb,EAAwBtH,EAASwH,GACtC,MAAM,aAAEvB,GAAiBrG,KAAKoG,UACxB,6BAAEH,GAAiC2B,GAAW,CAAC,EACrD,GAAI5H,KAAK+H,YAAY3H,EAASiG,GAC1B,OAAO,EAEX,MAAM,WAAEtK,EAAU,oBAAEgE,GAAwBC,KAAKwB,WAC3CjB,GAAiB,IAAAC,mBAAkBJ,IACnC,SAAEK,EAAQ,gBAAEoD,GAAoBtD,EAChC8E,GAAgB,OAAarF,KAAKiB,cAAelF,IACjD,OAAsBiE,KAAKiB,cAAeoF,GAC1CA,EACNrG,KAAKgI,sBAAsBjM,EAAY,CACnC+H,OAAQuB,EACRtB,QAAQ,GACTtD,GACH,MAAM,QAAEpE,GAAYN,EAAWE,KAAKG,QAC9BqM,EAAc1M,EAAWE,KAAK0E,QAAQd,SAiB5C,OAhBA9D,EAAWE,KAAKG,QAAQ0H,OAAS,CAC7B2E,EAAY,GACZA,EAAYA,EAAYlJ,OAAS,IAEjCxD,EAAWE,KAAKyM,sBAChB3M,EAAWE,KAAK0M,+BACZ,OAAmCtC,EAAc5F,IAEpDpE,EAAQyK,WACT,IAAAmB,mCAAkClM,EAAYkK,GAElDjG,KAAKgG,WAAY,EACjBhG,KAAKoG,cAAW9E,EAChBtB,KAAKwB,gBAAaF,GAClB,OAAsCvB,GACtCC,KAAK0G,eAAetG,IACb,CACX,CACA,SAAS4G,EAA8BpM,GACnC,MAAMiC,EAAcjC,EAAIsF,QAClB,cAAEC,EAAa,WAAEyI,GAAe/L,EAChCwD,EAAYF,EAAcG,OAC1BqC,EAAkBiG,EAAWtI,QAC7B,aAAE+F,GAAiBrG,KAAKoG,SACxByC,EAAoBxC,EAAagC,MAAM,GAAI,GAC3CC,EAAcxC,EAAuC+C,EAAmBxI,EAAWsC,GAAiB,GAC1G,QAAoBrB,IAAhBgH,EACA,OAGJ,OADsBA,EAAY,EAEtC,CACA,SAASrB,EAAmBrM,EAAKmM,GAC7B,MAAMlK,EAAcjC,EAAIsF,QAClB,QAAEE,GAAYvD,GACd,aAAEwJ,EAAY,6BAAEJ,GAAiCjG,KAAKoG,UACtD,WAAErK,EAAU,oBAAEgE,GAAwBC,KAAKwB,WACjD7B,EAAuBS,EAASiG,EAAcA,EAAaU,GAAgB/G,KAAKwB,YAChF6E,EAAahC,MACb,MAAMyE,EAAkBzC,EAAagC,MAAMtB,GACrCgC,EAAU,EAAAlJ,SAAA,QAAiBiJ,GACjC,GAAI,EAAAE,UAAA,QAAkBD,EAAS,GAE3B,YADA1C,EAAamC,OAAOzB,EAAgB,GAGxCV,EAAamC,OAAO,EAAGzB,GACvB,MAAMa,EAAU,CAAE3B,+BAA8B6B,gBAAiB,GAC7D9H,KAAK2H,0BAA0BvH,EAASwH,IACxC5H,KAAKF,0BAA0BlF,EAAKmB,EAAYgE,EAExD,CACA,SAASkJ,EAAc7I,GACnB,MAAM,kBAAEkH,GAAsBtH,KAAKiB,eAC7B,aAAEoF,EAAY,6BAAEJ,GAAiCjG,KAAKoG,SACtDmB,EAAalB,EAAa,GAC1BmB,EAAYnB,EAAaA,EAAa9G,OAAS,GACjD+H,IACCzB,EAAqC0B,EAAYC,EAAWxH,KAAKiB,cAAcwG,uBAChFzH,KAAK0H,wBAAwBtH,EAAS,CAAE6F,iCAGxCjG,KAAK2H,0BAA0BvH,EAAS,CAAE6F,gCAElD,CAKA,SAAS8B,EAAY3H,EAASiG,GAC1B,MAAM,mBAAEnF,GAAuBlB,KAAKiB,cACpC,GANJ,SAA2BoF,EAAcnF,GACrC,MAAMgI,EAAYlG,KAAKmG,IAAyB,EAArBjI,EAAwB,GACnD,OAAOmF,EAAa9G,OAAS2J,CACjC,CAGQE,CAAkB/C,EAAcnF,GAAqB,CACrD,MAAM,WAAEnF,EAAU,oBAAEgE,GAAwBC,KAAKwB,WAC3CjB,GAAiB,IAAAC,mBAAkBJ,IACnC,gBAAEyD,GAAoBtD,EAO5B,OANA,IAAA8I,kBAAiBtN,EAAWtB,eAC5BuF,KAAKgG,WAAY,EACjBhG,KAAKoG,cAAW9E,EAChBtB,KAAKwB,gBAAaF,GAClB,OAAsCvB,GACtCC,KAAK0G,eAAetG,IACb,CACX,CACA,OAAO,CACX,CAkBA,QAjBA,SAA0BuF,GACtBA,EAAaI,aAAeA,EAAaH,KAAKD,GAC9CA,EAAae,eAAiBA,EAAed,KAAKD,GAClDA,EAAasB,mBAAqBA,EAAmBrB,KAAKD,GAC1DA,EAAaqB,8BACTA,EAA8BpB,KAAKD,GACvCA,EAAa+B,wBACTA,EAAwB9B,KAAKD,GACjCA,EAAakC,iCACTA,EAAiCjC,KAAKD,GAC1CA,EAAac,sBAAwBA,EAAsBb,KAAKD,GAChEA,EAAaa,oBAAsBA,EAAoBZ,KAAKD,GAC5DA,EAAagC,0BACTA,EAA0B/B,KAAKD,GACnCA,EAAasD,cAAgBA,EAAcrD,KAAKD,GAChDA,EAAaoC,YAAcA,EAAYnC,KAAKD,EAChD,C,4DCjSA,MAAM,uBAAEhG,EAAsB,uCAAEmG,GAA2C,EAAAjG,SAC3E,SAASwD,EAAsBzI,EAAK0O,GAChC,MAAMzM,EAAcjC,EAAIsF,QAClB,QAAEE,EAAO,cAAED,EAAa,WAAEyI,GAAe/L,EACzCwD,EAAYF,EAAcG,OAC1BqC,EAAkBiG,EAAWtI,QAC7B,iBAAEc,EAAgB,iBAAEV,GAAqBV,KAAKmB,SAC9CoI,EAAqBzD,EAAuCpF,EAAkBL,EAAWsC,EAAiB2G,GAChH,GAAIC,EACAvJ,KAAKmB,SAASE,mBAAqBkI,EAAmB,GACtDvJ,KAAKwJ,iCAAiCF,QAErC,GAAI5I,EAAiBnB,QAAU,EAChC,GAAI6B,EAAiB7B,OACjBS,KAAKiB,cAAcwI,iCAAkC,CACrD,MAAMC,EAAuBtI,EAAiB,GACxCuI,EAAqB,GAC3B,IAAK,IAAIrK,EAAI,EAAGA,EAAIoB,EAAiBnB,OAAQD,IAAK,CAC9C,MAAMsK,EAAkBlJ,EAAiBpB,GACnCuK,EAAW,cAAcD,EAAiBF,GAChDC,EAAmB5E,KAAK,CAAE8E,WAAUC,MAAOxK,GAC/C,CACAqK,EAAmBI,KAAK,CAACC,EAAGC,IAAMD,EAAEH,SAAWI,EAAEJ,UACjD,MAAMK,EAA+B,CACjCP,EAAmB,GACnBA,EAAmB,IAEjBQ,EAAcnH,KAAKoH,IAAIF,EAA6B,GAAGJ,MAAOI,EAA6B,GAAGJ,OACpG9J,KAAKmB,SAASE,mBAAqB8I,CACvC,KACK,CACD,MAAME,EAAM,cACZ,cAAcA,EAAKjJ,EAAiB,GAAIA,EAAiB,IACzD,eAAeiJ,EAAKA,GACpB,MAAMC,EAAY,EACZC,EAAgB,CAClBnJ,EAAiB,GAAG,GAAKiJ,EAAI,GAAKC,EAClClJ,EAAiB,GAAG,GAAKiJ,EAAI,GAAKC,GAEhCE,EAAsC1E,EAAuCpF,EAAkB6J,EAAenJ,EAAiB,GAAIkI,GACzI,GAAIkB,EAAqC,CACrC,MAAMC,EAAkB,CAACF,GACzB5K,EAAuBS,EAASqK,EAAiBrJ,EAAiB,GAAIpB,KAAKwB,YAC3EJ,EAAiBsJ,WAAWD,GAC5BzK,KAAKwJ,iCAAiCF,GACtCtJ,KAAKmB,SAASI,UAAYH,EAAiB7B,OAAS,EACpDS,KAAKmB,SAASE,mBACVmJ,EAAoC,EAC5C,CACJ,CAER,CACA,SAAShB,EAAiCF,GACtC,MAAM,iBAAElI,EAAgB,iBAAEV,GAAqBV,KAAKmB,SACpD,IAAIwJ,EAAoB,EACxB,IAAK,IAAIrL,EAAI,EAAGA,EAAI8B,EAAiB7B,OAAS,EAAGD,IAAK,CAClD,MAAMsL,EAAY,CAACxJ,EAAiB9B,GAAI8B,EAAiB9B,EAAI,IAG7D,GADAqL,MADuB7E,EAAuCpF,EAAkBkK,EAAU,GAAIA,EAAU,GAAItB,GAGxG,KAER,CACAlI,EAAiBoH,OAAO,EAAGmC,GAC3B3K,KAAKmB,SAASI,UAAYH,EAAiB7B,OAAS,CACxD,CACA,SAASmE,EAAuB9I,EAAK0O,GACjC,MAAMzM,EAAcjC,EAAIsF,QAClB,cAAEC,EAAa,WAAEyI,GAAe/L,EAChCwD,EAAYF,EAAcG,OAC1BqC,EAAkBiG,EAAWtI,QAC7B,iBAAEI,GAAqBV,KAAKmB,SAElC,QAD2B2E,EAAuCpF,EAAkBL,EAAWsC,EAAiB2G,EAKpH,CACA,SAAS3F,EAAgC2F,GACrC,MAAM,iBAAE5I,EAAgB,iBAAEU,GAAqBpB,KAAKmB,SACpD,IAAK,IAAI7B,EAAI8B,EAAiB7B,OAAS,EAAGD,EAAI,EAAGA,IAAK,CAClD,MAAMuL,EAAW,CAACzJ,EAAiB9B,GAAI8B,EAAiB9B,EAAI,IACtDwL,IAAiBhF,EAAuCpF,EAAkBmK,EAAS,GAAIA,EAAS,GAAIvB,GAE1G,GADAlI,EAAiBiD,MACbyG,EACA,KAER,CACJ,CACA,SAASvH,IACL,MAAM,iBAAEnC,EAAgB,iBAAEV,EAAgB,mBAAEW,GAAuBrB,KAAKmB,SACxE,QAA2BG,IAAvBD,EACA,OAEJ,MAAM+C,EAAsBhD,EAAiBA,EAAiB7B,OAAS,GACjEoK,EAAqB,GAC3B,IAAK,IAAIrK,EAAI,EAAGA,EAAIoB,EAAiBnB,OAAQD,IAAK,CAC9C,MAAMsK,EAAkBlJ,EAAiBpB,GACnCuK,EAAW,cAAcD,EAAiBxF,GAChDuF,EAAmB5E,KAAK,CAAE8E,WAAUC,MAAOxK,GAC/C,CACAqK,EAAmBI,KAAK,CAACC,EAAGC,IAAMD,EAAEH,SAAWI,EAAEJ,UACjD,MAAMkB,EAA8B3J,EAAiBiH,MAAM,GAAI,GAC/D,IAAK,IAAI/I,EAAI,EAAGA,EAAIqK,EAAmBpK,OAAQD,IAAK,CAChD,MAAM,MAAEwK,GAAUH,EAAmBrK,GAC/B0L,EAAqBtK,EAAiBoJ,GACtC1F,EAAsBhD,EAAiBA,EAAiB7B,OAAS,GAEvE,IAD2BuG,EAAuCiF,EAA6BC,EAAoB5G,GAAqB,GAEpI,OAAO0F,CAEf,CACA,OAAQ,CACZ,CACA,SAAS3G,EAAgCvI,GACrC,MAAMiC,EAAcjC,EAAIsF,QAClB,cAAEC,EAAa,WAAEyI,GAAe/L,EAChCwD,EAAYF,EAAcG,OAC1BqC,EAAkBiG,EAAWtI,QAC7B,iBAAEc,GAAqBpB,KAAKmB,SAC5B4J,EAA8B3J,EAAiBiH,MAAM,GAAI,GACzDkB,EAAqBzD,EAAuCiF,EAA6B1K,EAAWsC,GAAiB,GAC3H,IAAK4G,EACD,OAEJ,MAAM0B,EAAmB1B,EAAmB,GACtCoB,EAAoBvJ,EAAiB7B,OAAS0L,EACpD,IAAK,IAAI3L,EAAI,EAAGA,EAAIqL,EAAmBrL,IACnC8B,EAAiBiD,KAEzB,CAaA,QAZA,SAAgCsB,GAC5BA,EAAatC,sBAAwBA,EAAsBuC,KAAKD,GAChEA,EAAa6D,iCACTA,EAAiC5D,KAAKD,GAC1CA,EAAajC,uBACTA,EAAuBkC,KAAKD,GAChCA,EAAapC,cAAgBA,EAAcqC,KAAKD,GAChDA,EAAahC,gCACTA,EAAgCiC,KAAKD,GACzCA,EAAaxC,gCACTA,EAAgCyC,KAAKD,EAC7C,C,wDC/Ie,SAASuF,EAAmC7E,EAAc5F,GACrE,MAAM0K,EAAQ9E,EAAa,GACrB+E,EAAO/E,EAAaA,EAAa9G,OAAS,GAC1C8L,EAAwB,cAC9B,SAASA,EAAuBD,EAAK,GAAKD,EAAM,GAAIC,EAAK,GAAKD,EAAM,IACpE,eAAeE,EAAuBA,GACtC,MAAMC,EAAgB,cAChBC,EAAgB,cACtB,SAASD,GAAgBD,EAAsB,GAAIA,EAAsB,IACzE,SAASE,EAAeF,EAAsB,IAAKA,EAAsB,IACzE,MAAMG,EAAsB,EACvBL,EAAM,GAAKC,EAAK,IAAM,GACtBD,EAAM,GAAKC,EAAK,IAAM,GAErBK,EAAW,CACbC,KAAM,EACN5B,MAAO,MAEX,IAAK,IAAIxK,EAAI,EAAGA,EAAI+G,EAAa9G,OAAQD,IAAK,CAC1C,MAAMwF,EAAcuB,EAAa/G,GAC3BuK,EAAW,UAAU/E,EAAa0G,GACpC3B,EAAW4B,EAASC,OACpBD,EAASC,KAAO7B,EAChB4B,EAAS3B,MAAQxK,EAEzB,CAMA,MALmB,CACf+G,EAAaoF,EAAS3B,OACtB0B,GAE+B5K,IAAIH,EAASoC,cAEpD,CACO,SAAS8I,EAA2CpL,EAAgBxE,GACvE,MAAM,SAAE0E,GAAaF,EAErB,OAAO2K,EADcnP,EAAWE,KAAK0E,QAAQd,SAASe,IAAIH,EAASI,eACXJ,EAC5D,C,6JC3BA,MAAM,uBAAEd,EAAsB,kCAAED,GAAsC,EAAAG,SACtE,SAAS+L,EAAwBhR,EAAKmB,EAAYgE,GAC9CC,KAAK6L,eAAgB,EACrB,MAAMhP,EAAcjC,EAAIsF,QAClB,cAAEC,EAAa,QAAEC,GAAYvD,EAC7BwD,EAAYF,EAAcG,OAC1BC,GAAiB,IAAAC,mBAAkBJ,IACnC,SAAEK,GAAaF,EACrBP,KAAKoF,eACL,MAAM1E,EAAmB3E,EAAWE,KAAK0E,QAAQd,SAASe,IAAIH,EAASI,gBACjE,QAAEC,EAAO,KAAEC,EAAI,KAAEC,GAAStB,EAAkCe,EAAUT,KAAKiB,cAAcC,oBAC/FlB,KAAKmB,SAAW,CACZT,mBACAU,iBAAkB,CAACf,GACnBgB,wBAAoBC,EACpBC,UAAW,GAEfvB,KAAKwB,WAAa,CACdzF,aACAgE,sBACAe,UACAC,OACAC,OACAS,eAAe,GAEnB,KAAMC,uBAAwB,EAC9BtB,EAAQuB,iBAAiB,EAAA3E,OAAO4E,SAAU5B,KAAK8L,gCAC/C1L,EAAQuB,iBAAiB,EAAA3E,OAAO8E,WAAY9B,KAAK+L,kCACjD3L,EAAQuB,iBAAiB,EAAA3E,OAAOgF,YAAahC,KAAK8L,gCAClD1L,EAAQuB,iBAAiB,EAAA3E,OAAOiF,UAAWjC,KAAK8L,gCAChD1L,EAAQuB,iBAAiB,EAAA3E,OAAOkF,WAAYlC,KAAK+L,kCACjD3L,EAAQuB,iBAAiB,EAAA3E,OAAOmF,UAAWnC,KAAK8L,iCAChD,IAAA1J,mBAAkBhC,EACtB,CACA,SAAS4L,EAA0B5L,GAC/B,KAAMsB,uBAAwB,EAC9BtB,EAAQkC,oBAAoB,EAAAtF,OAAO4E,SAAU5B,KAAK8L,gCAClD1L,EAAQkC,oBAAoB,EAAAtF,OAAO8E,WAAY9B,KAAK+L,kCACpD3L,EAAQkC,oBAAoB,EAAAtF,OAAOgF,YAAahC,KAAK8L,gCACrD1L,EAAQkC,oBAAoB,EAAAtF,OAAOiF,UAAWjC,KAAK8L,gCACnD1L,EAAQkC,oBAAoB,EAAAtF,OAAOkF,WAAYlC,KAAK+L,kCACpD3L,EAAQkC,oBAAoB,EAAAtF,OAAOmF,UAAWnC,KAAK8L,iCACnD,IAAAvJ,oBAAmBnC,EACvB,CACA,SAAS2L,EAAiCnR,GACtC,MAAMiC,EAAcjC,EAAIsF,QAClB,cAAEC,EAAa,QAAEC,GAAYvD,EAC7B2F,EAAWrC,EAAcsC,MACzBpC,EAAYF,EAAcG,OAC1BC,GAAiB,IAAAC,mBAAkBJ,IACnC,SAAEK,GAAaF,GACf,oBAAER,EAAmB,KAAEgB,EAAI,KAAEC,EAAI,QAAEF,GAAYd,KAAKwB,YACpD,UAAED,EAAS,iBAAEH,EAAgB,mBAAEC,GAAuBrB,KAAKmB,SAC3DwB,EAAkBvB,EAAiBA,EAAiB7B,OAAS,GAC7DqD,EAAiBnC,EAASoC,cAAcF,GACxCG,EAAe,cACrB9C,KAAK0C,WAAWtC,EAASJ,KAAKwB,WAAWzF,YACzC,cAAc+G,EAAcN,EAAUI,GACtC,MAAMG,EAAQC,KAAKC,IAAI,SAASH,EAAc/B,IACxCmC,EAAQF,KAAKC,IAAI,SAASH,EAAc9B,IAC9C,GAAI+B,GAASjC,EAAQ,IAAMoC,GAASpC,EAAQ,GACxC,YAEuBQ,IAAvBD,GACArB,KAAKmD,gCAAgCvI,GAEzC,MACMwI,EAAmB7B,EADF5B,EAAuBS,EAASgB,EAAkBf,EAAWL,KAAKwB,YAEzFxB,KAAKmB,SAASI,UAAY6B,OACC9B,IAAvBD,GAAoCD,EAAiB7B,OAAS,GAC9DS,KAAKqD,sBAAsBzI,GAAK,GAEpCoF,KAAKmB,SAASmC,UAAYtD,KAAKuD,gBAC/BvD,KAAKmB,SAASqC,kBAAoBxD,KAAKiM,8BAA8BrR,QAC1C0G,IAAvBD,GACArB,KAAK0D,uBAAuB9I,GAAK,IACjCoF,KAAK2D,iCAAgC,GACrC3D,KAAKkM,+BAA+BtR,IAE/BoF,KAAKmM,4BAA4BvR,IACtCoF,KAAKoM,4BAA4BxR,IAErC,OAAsCmF,EAC1C,CACA,SAASqM,EAA4BxR,GACjC,MAAMiC,EAAcjC,EAAIsF,QAClB,QAAEE,GAAYvD,EACd0D,GAAiB,IAAAC,mBAAkBJ,IACnC,SAAEK,GAAaF,GACf,WAAExE,EAAU,oBAAEgE,GAAwBC,KAAKwB,WAC3CgC,EAAoBxD,KAAKqM,uCAC/B,OAAsBtQ,EAAY,CAC9B+H,OAAQN,EACRO,QAAQ,GACTtD,GACH,MAAMgI,EAAc1M,EAAWE,KAAK0E,QAAQd,SAC5C9D,EAAWE,KAAKG,QAAQ0H,OAAS,CAC7B2E,EAAY,GACZA,EAAYA,EAAYlJ,OAAS,IAErCxD,EAAWE,KAAKG,QAAQkQ,kBAAoB,GAC5C,IAAAnI,2BAA0BpI,EAAYqE,GACtCJ,KAAK6L,eAAgB,EACrB7L,KAAKmB,cAAWG,EAChBtB,KAAKwB,gBAAaF,EAClBtB,KAAKoF,eACLpF,KAAKgM,0BAA0B5L,GAC/BJ,KAAKuM,2BAA2B3R,EAAKmB,EAAYgE,EAAqB,KAC1E,CACA,SAASoM,EAA4BvR,GACjC,MAAMiC,EAAcjC,EAAIsF,QAClB,cAAEC,EAAa,WAAEyI,GAAe/L,EAChCwD,EAAYF,EAAcG,OAC1BkM,EAAgB5D,EAAWtI,QAC3B,UAAEgD,EAAS,iBAAE5C,EAAgB,mBAAEW,GAAuBrB,KAAKmB,SACjE,QAA2BG,IAAvBD,QAAkDC,IAAdgC,EACpC,OAAO,EAEX,IAAmB,IAAfA,EACA,OAAO,EAEX,GAAkB,IAAdA,GAAmBA,IAAc5C,EAAiBnB,OAAS,EAC3D,OAAO,EAEX,MAAMkN,EAAKpM,EACLqM,EAAKF,EACLG,EAAKjM,EAAiB4C,GACtB0G,EAAI,cACJC,EAAI,cACV,SAASD,EAAGyC,EAAG,GAAKC,EAAG,GAAID,EAAG,GAAKC,EAAG,IACtC,SAASzC,EAAGwC,EAAG,GAAKE,EAAG,GAAIF,EAAG,GAAKE,EAAG,IACtC,MAAMC,EAAQ,SAAS5C,EAAGC,GACpB4C,EAAO7J,KAAK8J,KAAK9C,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IACxC+C,EAAO/J,KAAK8J,KAAK7C,EAAE,GAAKA,EAAE,GAAKA,EAAE,GAAKA,EAAE,IAE9C,OADcjH,KAAKgK,KAAKJ,GAASC,EAAOE,IAC5B/J,KAAKiK,GAAK,CAI1B,CACA,SAASZ,IACL,MAAM,UAAE/I,EAAS,iBAAE5C,EAAgB,iBAAEU,EAAgB,mBAAEC,GAAuBrB,KAAKmB,SAC7E+L,EAAkB,GACxB,GAAkB,IAAd5J,EACA,IAAK,IAAIhE,EAAIoB,EAAiBnB,OAAS,EAAGD,GAAK+B,EAAoB/B,IAAK,CACpE,MAAMwF,EAAcpE,EAAiBpB,GACrC4N,EAAgBnI,KAAK,CAACD,EAAY,GAAIA,EAAY,IACtD,MAGA,IAAK,IAAIxF,EAAI,EAAGA,EAAI+B,EAAoB/B,IAAK,CACzC,MAAMwF,EAAcpE,EAAiBpB,GACrC4N,EAAgBnI,KAAK,CAACD,EAAY,GAAIA,EAAY,IACtD,CAIJ,GAFkD,cAAcpE,EAAiBW,GAAqBD,EAAiB,IACtE,cAAcV,EAAiBW,GAAqBD,EAAiBA,EAAiB7B,OAAS,IAG5I,IAAK,IAAID,EAAI,EAAGA,EAAI8B,EAAiB7B,OAAQD,IAAK,CAC9C,MAAMwF,EAAc1D,EAAiB9B,GACrC4N,EAAgBnI,KAAK,CAACD,EAAY,GAAIA,EAAY,IACtD,MAGA,IAAK,IAAIxF,EAAI8B,EAAiB7B,OAAS,EAAGD,GAAK,EAAGA,IAAK,CACnD,MAAMwF,EAAc1D,EAAiB9B,GACrC4N,EAAgBnI,KAAK,CAACD,EAAY,GAAIA,EAAY,IACtD,CAEJ,OAAOoI,CACX,CACA,SAASjB,EAA8BrR,GACnC,MAAM,iBAAE8F,EAAgB,iBAAEU,EAAgB,mBAAEC,EAAkB,UAAEiC,GAActD,KAAKmB,SACnF,QAA2BG,IAAvBD,QAAkDC,IAAdgC,EACpC,OAEJ,MAAMzG,EAAcjC,EAAIsF,QAClB,QAAEE,GAAYvD,EACdyH,EAA4B,IAAIlD,GAKtC,IAAImD,EACAC,EALJ7E,EAAuBS,EAASkE,EAA2B5D,EAAiB4C,GAAYtD,KAAKwB,YACzF8C,EAA0B/E,OAAS6B,EAAiB7B,QACpD+E,EAA0BD,MAI1BhD,EAAqBiC,GACrBiB,EAAWjB,EACXkB,EAAYnD,IAGZkD,EAAWlD,EACXmD,EAAYlB,GAEhB,MAAMmB,EAAkC,cAAc/D,EAAiB6D,GAAWD,EAA0B,IACtGI,EAAiC,cAAchE,EAAiB6D,GAAWD,EAA0BA,EAA0B/E,OAAS,IACxIoF,EAAmC,cAAcjE,EAAiB8D,GAAYF,EAA0B,IACxGM,EAAkC,cAAclE,EAAiB8D,GAAYF,EAA0BA,EAA0B/E,OAAS,IAC1I4N,EAAiB,GACvB,IAAK,IAAI7N,EAAI,EAAGA,EAAIiF,EAAUjF,IAAK,CAC/B,MAAMwF,EAAcpE,EAAiBpB,GACrC6N,EAAepI,KAAK,CAACD,EAAY,GAAIA,EAAY,IACrD,CAGA,GAFwBL,EAAkCG,EAClCF,EAAiCC,EAErD,IAAK,IAAIrF,EAAI,EAAGA,EAAIgF,EAA0B/E,OAAQD,IAAK,CACvD,MAAMwF,EAAcR,EAA0BhF,GAC9C6N,EAAepI,KAAK,CAACD,EAAY,GAAIA,EAAY,IACrD,MAGA,IAAK,IAAIxF,EAAIgF,EAA0B/E,OAAS,EAAGD,GAAK,EAAGA,IAAK,CAC5D,MAAMwF,EAAcR,EAA0BhF,GAC9C6N,EAAepI,KAAK,CAACD,EAAY,GAAIA,EAAY,IACrD,CAEJ,IAAK,IAAIxF,EAAIkF,EAAWlF,EAAIoB,EAAiBnB,OAAQD,IAAK,CACtD,MAAMwF,EAAcpE,EAAiBpB,GACrC6N,EAAepI,KAAK,CAACD,EAAY,GAAIA,EAAY,IACrD,CACA,OAAOqI,CACX,CACA,SAASjB,EAA+BtR,GACpC,MAAMiC,EAAcjC,EAAIsF,QAClB,QAAEE,GAAYvD,EACd0D,GAAiB,IAAAC,mBAAkBJ,IACnC,SAAEK,EAAQ,gBAAEoD,GAAoBtD,GAChC,WAAExE,EAAU,oBAAEgE,GAAwBC,KAAKwB,YAC3C,kBAAEgC,EAAiB,iBAAEpC,GAAqBpB,KAAKmB,UACrD,OAAsBpF,EAAY,CAC9B+H,OAAQN,EACRO,QAAQ,GACTtD,GACH,MAAMgI,EAAc1M,EAAWE,KAAK0E,QAAQd,SAC5C9D,EAAWE,KAAKG,QAAQ0H,OAAS,CAC7B2E,EAAY,GACZA,EAAYA,EAAYlJ,OAAS,KAErC,IAAA4E,2BAA0BpI,EAAYqE,GACtC,MAAMgE,EAAsBhD,EAAiBiD,MAC7CrE,KAAKmB,SAAW,CACZT,iBAAkB8C,EAClBpC,iBAAkB,CAACgD,GACnB/C,wBAAoBC,EACpBC,UAAW,IAEf,OAAsCxB,EAC1C,CACA,SAAS+L,EAA+BlR,GACpC,MAAMiC,EAAcjC,EAAIsF,QAClB,QAAEE,GAAYvD,EACpBmD,KAAKoN,wBAAwBhN,EACjC,CACA,SAASgN,EAAwBhN,GAC7B,MAAMG,GAAiB,IAAAC,mBAAkBJ,IACnC,SAAEK,GAAaF,GACf,WAAExE,EAAU,oBAAEgE,GAAwBC,KAAKwB,WACjDxB,KAAKoF,eACL,MAAM,kBAAE5B,EAAiB,iBAAE9C,GAAqBV,KAAKmB,SACrD,GAAIqC,EAAmB,CACnB,MAAM6B,GAAgB,OAAarF,KAAKiB,gBAClC,OAAsBjB,KAAKiB,cAAeuC,EAAmB9C,GAC7D8C,EACA8B,EAAiBtF,KAAKiB,eAAesE,UAAY,CAAC,GACxD,OAAsBxJ,EAAY,CAC9B+H,OAAQuB,EACRtB,QAAQ,GACTtD,EAAU,CACT8E,SAAU,CACNC,UAAWF,EAAeE,QAC1BC,QAASH,EAAeG,WAGhC,MAAMgD,EAAc1M,EAAWE,KAAK0E,QAAQd,SAC5C9D,EAAWE,KAAKG,QAAQ0H,OAAS,CAC7B2E,EAAY,GACZA,EAAYA,EAAYlJ,OAAS,IAEjCxD,EAAWE,KAAKyM,sBAChB3M,EAAWE,KAAK0M,+BACZ,OAAmCnF,EAAmB/C,KAE9D,IAAA0D,2BAA0BpI,EAAYqE,EAC1C,CACAJ,KAAK6L,eAAgB,EACrB7L,KAAKmB,cAAWG,EAChBtB,KAAKwB,gBAAaF,GAClB,OAAsCvB,GACtCC,KAAKgM,0BAA0B5L,EACnC,CACA,SAASiN,EAAsBjN,GAC3BJ,KAAKoN,wBAAwBhN,EACjC,CAwBA,QAvBA,SAAqCuF,GACjCA,EAAaiG,wBACTA,EAAwBhG,KAAKD,GACjCA,EAAaqG,0BACTA,EAA0BpG,KAAKD,GACnCA,EAAaoG,iCACTA,EAAiCnG,KAAKD,GAC1CA,EAAamG,+BACTA,EAA+BlG,KAAKD,GACxCA,EAAasG,8BACTA,EAA8BrG,KAAKD,GACvCA,EAAauG,+BACTA,EAA+BtG,KAAKD,GACxCA,EAAawG,4BACTA,EAA4BvG,KAAKD,GACrCA,EAAa0G,oCACTA,EAAoCzG,KAAKD,GAC7CA,EAAayG,4BACTA,EAA4BxG,KAAKD,GACrCA,EAAa0H,sBAAwBA,EAAsBzH,KAAKD,GAChEA,EAAayH,wBACTA,EAAwBxH,KAAKD,EACrC,C,6FClUA,MAAM,kCAAEjG,GAAsC,EAAAG,SAC9C,SAAS0M,EAA2B3R,EAAKmB,EAAYgE,EAAqBuN,GACtEtN,KAAKgG,WAAY,EACjB,MAAMnJ,EAAcjC,EAAIsF,QAClB,QAAEE,GAAYvD,EACd0D,GAAiB,IAAAC,mBAAkBJ,IACnC,SAAEK,GAAaF,GACf,QAAEO,EAAO,KAAEC,EAAI,KAAEC,GAAStB,EAAkCe,EAAUT,KAAKiB,cAAcC,oBACzFmF,EAAetK,EAAWE,KAAK0E,QAAQd,SAASe,IAAIH,EAASI,eAExC,IADA9E,EAAWE,KAAKG,QAAQkQ,mBAE/CjG,EAAakH,UAEjB,IAAI9L,GAAgB,EAChB6L,GAAQzG,gBACRpF,GAAgB,GAEpBzB,KAAKoG,SAAW,CACZC,aAAcA,EACdC,cAAeD,EAAa9G,OAAS,GAEzCS,KAAKwB,WAAa,CACdzF,aACAgE,sBACAe,UACAC,OACAC,OACAS,iBAEJ,KAAMC,uBAAwB,EAC9BtB,EAAQuB,iBAAiB,EAAA3E,OAAO4E,SAAU5B,KAAKwG,qBAC/CpG,EAAQuB,iBAAiB,EAAA3E,OAAO8E,WAAY9B,KAAKyG,uBACjDrG,EAAQuB,iBAAiB,EAAA3E,OAAOgF,YAAahC,KAAKwG,qBAClDpG,EAAQuB,iBAAiB,EAAA3E,OAAOiF,UAAWjC,KAAKwG,qBAChDpG,EAAQuB,iBAAiB,EAAA3E,OAAOkF,WAAYlC,KAAKyG,uBACjDrG,EAAQuB,iBAAiB,EAAA3E,OAAOmF,UAAWnC,KAAKwG,sBAChD,IAAApE,mBAAkBhC,EACtB,CAKA,QAJA,SAAwCuF,GACpCA,EAAa4G,2BACTA,EAA2B3G,KAAKD,EACxC,C,kFC1CA,MAAM,qCAAEE,GAAyC,EAAAhG,SACjD,SAAS2N,EAAqBjN,EAAgBxE,GAC1C,MAAM0R,EAAiB,CACnBC,YAAa1N,KAAK0N,YAClB1O,SAAUgB,KAAK2N,cACfpQ,WAAYgD,EAAeE,SAASmN,GACpCnT,cAAesB,EAAWtB,gBAExB,UAAEoT,EAAS,SAAEC,EAAQ,MAAEC,EAAK,UAAEC,EAAS,YAAEC,GAAgBjO,KAAKkO,mBAAmB,CACnFnS,aACA0R,oBAEI1J,OAAQuF,GAAoBvN,EAAWE,KAAK0E,QASpD,MARgB,CACZoN,QACAI,MAAON,EACPC,WACAE,YACAC,cACAG,UAAW9E,EAGnB,CACA,SAAS+E,EAAc9N,EAAgB+N,EAAkBvS,GAChDwE,GAAgBE,UAAU8N,iBAG3BxS,EAAWE,KAAK0E,QAAQoD,OACxB/D,KAAKwO,oBAAoBjO,EAAgB+N,EAAkBvS,GAGvDA,EAAWE,KAAKyM,sBAS5B,SAAwDnI,EAAgBxE,GAC/DA,EAAWE,KAAK0M,gCACjB5M,EAAWE,KAAK0M,+BACZ,OAA2CpI,EAAgBxE,GAEvE,CAbY0S,CAA+ClO,EAAgBxE,GAC/DiE,KAAK0O,yBAAyBnO,EAAgB+N,EAAkBvS,IAGhEiE,KAAK2O,kBAAkBpO,EAAgB+N,EAAkBvS,GAGrE,CAOA,SAASyS,EAAoBjO,EAAgB+N,EAAkBvS,GAC3D,GAAIA,EAAW6S,oBACX,OAEJ,MAAM,SAAEnO,GAAaF,EACfqH,EAAU5H,KAAKwN,qBAAqBjN,EAAgBxE,GAGpD8S,EAAc,CAFG9S,EAAWE,KAAK0E,QAAQd,SAASe,IAAK4B,GAAa/B,EAASI,cAAc2B,QAC3E,OAA0BzG,EAAY0E,KAG5D,IAAAqO,UAAYR,EAAkBvS,EAAWtB,cADrB,IACiDoU,EAAajH,EACtF,CACA,SAAS+G,EAAkBpO,EAAgB+N,EAAkBvS,GACzD,MAAM,SAAE0E,GAAaF,EACfqH,EAAU5H,KAAKwN,qBAAqBjN,EAAgBxE,GACpDsK,EAAetK,EAAWE,KAAK0E,QAAQd,SAASe,IAAK4B,GAAa/B,EAASI,cAAc2B,KAE/F,IAAAuM,cAAgBT,EAAkBvS,EAAWtB,cADzB,IACqD4L,EAAcuB,GACvF,MAAM0E,EAAoBvQ,EAAWE,KAAKG,QAAQkQ,kBAClD,IAAmE,IAA/DtM,KAAKiB,cAAc+N,gCAAgCxJ,QAAkB,CACrE,MAAMyJ,EAASjP,KAAKiB,cAAc+N,+BAA+BC,OAC3DC,EAAiB,IACjBC,EAAe,CACjB9I,EAAa,GACbA,EAAaA,EAAa9G,OAAS,IAEb,IAAtB+M,EACA6C,EAAaC,QAEc,IAAtB9C,GACL6C,EAAa9K,OAEjB,IAAAgL,aAAef,EAAkBvS,EAAWtB,cAAeyU,EAAgBC,EAAc,CACrFpB,MAAOnG,EAAQmG,MACfuB,aAAcL,GAEtB,CACA,GAA0B,OAAtB3C,EAA4B,CAC5B,MAAM4C,EAAiB,IAEjBK,EAAclJ,EAD8B,IAAtBiG,EAA0B,EAAIjG,EAAa9G,OAAS,IAEhF,IAAA8P,aAAef,EAAkBvS,EAAWtB,cAAeyU,EAAgB,CAACK,GAAc,CAAExB,MAAOnG,EAAQmG,OAC/G,CACJ,CACA,SAASW,EAAyBnO,EAAgB+N,EAAkBvS,GAChE,MAAM,SAAE0E,GAAaF,GACf,8BAAEoI,GAAkC5M,EAAWE,MAC/C,SAAE4D,GAAa9D,EAAWE,KAAK0E,QAErC,GADAX,KAAK2O,kBAAkBpO,EAAgB+N,EAAkBvS,IACpD4M,EACD,OAEJ,MAAM6G,EAAmB/O,EAASI,cAAchB,EAAS,IACnD8C,EAAkBlC,EAASI,cAAchB,EAASA,EAASN,OAAS,IACpEkQ,EAAsC,CACxChP,EAASI,cAAc8H,EAA8B,IACrDlI,EAASI,cAAc8H,EAA8B,KAEnDf,EAAU5H,KAAKwN,qBAAqBjN,EAAgBxE,IAC1D,IAAAgT,cAAgBT,EAAkBvS,EAAWtB,cAAe,gBAAiB,CAAC+U,EAAkB7M,GAAkB,CAC9GoL,MAAOnG,EAAQmG,MACfI,MAAOvG,EAAQuG,MACfC,WAAW,EACXN,SAAU,SAEd,IAAAiB,cAAgBT,EAAkBvS,EAAWtB,cAAe,2BAA4B,CACpFgV,EAAoC,GACpCA,EAAoC,IACrC,CACC1B,MAAOnG,EAAQmG,MACfI,MAAOvG,EAAQuG,MACfC,WAAW,EACXN,SAAU,OAElB,CACA,SAAS4B,EAAwBnP,EAAgB+N,EAAkBvS,GAC/D,MAAM6L,EAAU5H,KAAKwN,qBAAqBjN,EAAgBxE,IACpD,kBAAEuL,GAAsBtH,KAAKiB,eAC7B,aAAEoF,GAAiBrG,KAAKoG,SAG9B,GAFAwB,EAAQwG,WAAY,GACpB,IAAAW,cAAgBT,EAAkBvS,EAAWtB,cAAe,IAAK4L,EAAcuB,GAC3EN,EAAmB,CACnB,MAAMC,EAAalB,EAAa,GAC1BmB,EAAYnB,EAAaA,EAAa9G,OAAS,GACrD,GAAIsG,EAAqC0B,EAAYC,EAAWxH,KAAKiB,cAAcwG,wBAC/E,IAAAsH,cAAgBT,EAAkBvS,EAAWtB,cAAe,IAAK,CAAC+M,EAAWD,GAAaK,OAEzF,CACD,MAAMsH,EAAiB,KACvB,IAAAG,aAAef,EAAkBvS,EAAWtB,cAAeyU,EAAgB,CAAC3H,GAAa,CAAEwG,MAAOnG,EAAQmG,MAAOuB,aAAc,GACnI,CACJ,CACJ,CACA,SAASK,EAA+BpP,EAAgB+N,EAAkBvS,GACtE,MAAM,SAAE0E,GAAaF,GACf,kBAAEiD,GAAsBxD,KAAKmB,SACnC,QAA0BG,IAAtBkC,EAEA,YADAxD,KAAKwO,oBAAoBjO,EAAgB+N,EAAkBvS,GAG/D,MACM8S,EAAc,CAACrL,MADC,OAA0BzH,EAAY0E,IAEtDmH,EAAU5H,KAAKwN,qBAAqBjN,EAAgBxE,GAEtDA,EAAW6S,qBAAuBhH,EAAQqG,cAC1CrG,EAAQqG,YAAc,IAE1B,IAAAa,UAAYR,EAAkBvS,EAAWtB,cAJb,YAIiDoU,EAAajH,EAC9F,CACA,SAASgI,EAA6BrP,EAAgB+N,EAAkBvS,GACpE,MAAM,kBAAEyH,GAAsBxD,KAAKmB,SACnC,QAA0BG,IAAtBkC,EAEA,YADAxD,KAAK2O,kBAAkBpO,EAAgB+N,EAAkBvS,GAG7D,MAAM6L,EAAU5H,KAAKwN,qBAAqBjN,EAAgBxE,IAE1D,IAAAgT,cAAgBT,EAAkBvS,EAAWtB,cADjB,YACqD+I,EAAmBoE,EACxG,CACA,SAASiI,EAA6BtP,EAAgB+N,EAAkBvS,GACpE,GAAIA,EAAW6S,oBACX,OAEJ,MAAM,SAAEnO,GAAaF,EACfqH,EAAU5H,KAAKwN,qBAAqBjN,EAAgBxE,GACpD+T,EAAiB/T,EAAWE,KAAK0E,QAAQd,SAASe,IAAK4B,GAAa/B,EAASI,cAAc2B,IAC3FuN,GAAgB,OAA0BhU,EAAY0E,GAEtDuP,EAASF,EAAe,GAGxBG,EAAe,GACrB,IAAK,IAAI3Q,EAAI,EAAGA,EAFO,IAEaA,IAAK,CACrC,MAAM4Q,EAAS5Q,EAHI,IAGkB,EAAI0D,KAAKiK,GACxCkD,EAAIH,EAAO,GALN,EAKoBhN,KAAKoN,IAAIF,GAClCG,EAAIL,EAAO,GANN,EAMoBhN,KAAKsN,IAAIJ,GACxCD,EAAalL,KAAK,CAACoL,EAAGE,GAC1B,CACA,MAAME,EAAY,CACd,CAACP,EAAO,GAAKf,GAAYe,EAAO,IAChC,CAACA,EAAO,GAAKf,GAAYe,EAAO,IAChC,CAACA,EAAO,GAAIA,EAAO,GAAKf,IACxB,CAACe,EAAO,GAAIA,EAAO,GAAKf,MAE5B,IAAAH,UAAYR,EAAkBvS,EAAWtB,cAAe+V,gBAA8B,CAACD,EAAU,GAAIA,EAAU,IAAK3I,IACpH,IAAAkH,UAAYR,EAAkBvS,EAAWtB,cAAe+V,gBAA8B,CAACD,EAAU,GAAIA,EAAU,IAAK3I,GACpH,MAAMiH,EAAc,CAACoB,KAAiBF,IACtC,IAAAjB,UAAYR,EAAkBvS,EAAWtB,cApBrB,IAoBiDoU,EAAajH,EACtF,CAiBA,QAhBA,SAA+BjC,GAC3BA,EAAa0I,cAAgBA,EAAczI,KAAKD,GAChDA,EAAa6I,oBAAsBA,EAAoB5I,KAAKD,GAC5DA,EAAagJ,kBAAoBA,EAAkB/I,KAAKD,GACxDA,EAAakK,6BACTA,EAA6BjK,KAAKD,GACtCA,EAAa+I,yBACTA,EAAyB9I,KAAKD,GAClCA,EAAa+J,wBACTA,EAAwB9J,KAAKD,GACjCA,EAAagK,+BACTA,EAA+B/J,KAAKD,GACxCA,EAAaiK,6BACTA,EAA6BhK,KAAKD,GACtCA,EAAa6H,qBAAuBA,EAAqB5H,KAAKD,EAClE,C,kJC5MA,MAAM,mBAAE8K,GAAuB,yBACzB,cAAEC,GAAkB,YAC1B,MAAMC,UAAuB,EAAAC,EACzB,kCAAOC,CAA4BpQ,KAAaqQ,GAC5C,OAAO9Q,KAAK+Q,iBAAiB,CAAEC,SAAUvQ,EAASwQ,uBAAyBH,EAC/E,CACA,6BAAOI,CAAuBzQ,KAAaqQ,GACvC,MAAM/U,EAAaiE,KAAK6Q,4BAA4BpQ,KAAaqQ,IACjE,IAAAK,eAAcpV,EAAY0E,EAASL,UACnC,IAAA+D,2BAA0BpI,EAAY0E,EAASL,QACnD,CACA,WAAAgR,CAAYC,EAAWC,GACnBC,MAAMF,EAAWC,GACjBtR,KAAKwR,kBAAoB,CAAC5W,EAAK6W,KAC3B,IAAKA,EACD,OAAO,EAEX,MAAM,QAAErR,EAAO,cAAED,GAAkBvF,EAAIsF,OACjCwR,EAAevR,EAAcG,OACnC,IAAIqR,GAA6B,EACjC,IAAK,MAAM5V,KAAc0V,EAAqB,CAC1C,IAAI,IAAAG,oBAAmB7V,EAAWtB,kBAC7B,IAAAoX,qBAAoB9V,EAAWtB,eAChC,SAEJ,MAAM,KAAEwB,GAASF,EACX+V,EAAsB7V,EAAKG,QAC3BH,EAAKG,QAAQkQ,uBACbhL,EACAyQ,EAAO/R,KAAKgS,4BAA4B5R,EAASrE,EAAY2V,EAAc,GAC3EO,EAA6BF,IAAShW,EAAWmW,YACjDC,GAA8BJ,GAAQhW,EAAWmW,YACnDD,GAA8BE,GAC9BpW,EAAWmW,aAAenW,EAAWmW,YACrCP,GAA6B,GAExB1V,EAAKG,SACVH,EAAKG,QAAQkQ,oBAAsBwF,IACnCH,GAA6B,EAErC,CACA,OAAOA,GAEX3R,KAAKoS,YAAczB,EAAeyB,YAC9Bf,EAAUpQ,eAAeoR,eACzBrS,KAAKiB,cAAcoR,aAAehB,EAAUpQ,cAAcoR,cAE1DhB,EAAUpQ,eAAeqR,kBACzBtS,KAAKiB,cAAcqR,gBACfjB,EAAUpQ,cAAcqR,gBAEpC,CACA,uBAAAC,CAAwBnS,EAASrE,EAAY2V,EAAcpH,GACvD,MAAM/J,GAAiB,IAAAC,mBAAkBJ,IACnC,SAAEK,GAAaF,GACf,KAAEtE,GAASF,GACX,mBAAEyW,GAAuBvW,GACzB,OAAE6H,EAAM,QAAEzH,GAAYJ,EAAKG,QACjC,GAAIC,EAAS,CACT,MAAM,iBAAEoW,GAAqBpW,EAC7B,GAAIoW,EAAkB,CAClB,MAAMC,EAAoB,CACtBC,QAASlS,EAASI,cAAc4R,EAAiBE,SACjDC,SAAUnS,EAASI,cAAc4R,EAAiBG,UAClDC,WAAYpS,EAASI,cAAc4R,EAAiBI,YACpDC,YAAarS,EAASI,cAAc4R,EAAiBK,cAEzD,GAAIpB,EAAa,IAAMgB,EAAkBC,QAAQ,IAC7CjB,EAAa,IAAMgB,EAAkBI,YAAY,IACjDpB,EAAa,IAAMgB,EAAkBC,QAAQ,IAC7CjB,EAAa,IAAMgB,EAAkBI,YAAY,GAEjD,OADA7W,EAAKG,QAAQkQ,kBAAoB,KAC1BjQ,CAEf,CACJ,CACA,IAAK,IAAIiD,EAAI,EAAGA,EAAIwE,GAAQvE,OAAQD,IAAK,CACrC,MAAMyT,EAAQjP,EAAOxE,GACf0T,EAA6BR,EAC7BO,EAAM1K,MAAM,EAAG,GACf5H,EAASI,cAAckS,GAE7B,IAAa,IADA,cAAcrB,EAAcsB,GAA8B1I,EAGnE,OADArO,EAAKG,QAAQkQ,kBAAoBhN,EAC1ByT,CAEf,CACA9W,EAAKG,QAAQkQ,kBAAoB,IACrC,CACA,qBAAA2G,CAAsBC,EAAgBnX,GAClC,MAAO,CACHoX,WAAYnT,KAAKoT,SAAS,oBAAqBF,EAAgBnX,GAC/DsX,WAAYrT,KAAKoT,SAAS,oBAAqBF,EAAgBnX,GAC/DuX,SAAUtT,KAAKoT,SAAS,kBAAmBF,EAAgBnX,GAC3DgS,MAAO/N,KAAKoT,SAAS,eAAgBF,EAAgBnX,GACrDwX,OAAQvT,KAAKoT,SAAS,gBAAiBF,EAAgBnX,GACvDyX,WAAYxT,KAAKoT,SAAS,oBAAqBF,EAAgBnX,GAC/D8R,UAAW7N,KAAKoT,SAAS,uBAAwBF,EAAgBnX,GACjE+R,SAAU9N,KAAKoT,SAAS,sBAAuBF,EAAgBnX,GAEvE,CACA,kBAAOqW,CAAY3R,EAAUgT,EAAUC,GACnC,GAAIjT,aAAoB,EAAAkT,mBAAoB,CACxC,MAAMC,EAAW,wBAAoBH,GAC/BI,EAAS,EAAAC,MAAMC,UAAUH,GAC/B,YAA+BtS,IAAxBuS,GAAQG,SAASC,EAC5B,CACA,MAAMC,EAAgBR,GAAW,EAAAS,SAAA,IAAa,gBAAiBT,GAC/D,MAAuC,iBAAzBQ,GAAeE,KACjC,CACA,kBAAAlG,CAAmBmG,GACf,MAAM,WAAEtY,EAAU,eAAE0R,GAAmB4G,EACjCjB,EAAYkB,GAAatU,KAAKoT,SAASkB,EAAU7G,EAAgB1R,IACjE,cAAEtB,GAAkBsB,EACpBoX,GAAa,IAAAtB,qBAAoBpX,GACjC8Z,GAAS,IAAA3C,oBAAmBnX,GAC5BoT,EAAYuF,EAAS,aACrBtF,EAAWsF,EAAS,YACpBoB,EAAmBpB,EAAS,oBAC5BrF,EAAQqF,EAAS,SACjBqB,EAAarB,EAAS,cAG5B,MAAO,CACHD,aACAoB,SACAxG,QACAF,YACAC,WACA4G,YAAa,EACb1G,UAAWD,EACXE,YAAa,EACbsF,OAXWH,EAAS,UAYpBuB,QAXiB3U,KAAKiT,sBAAsBxF,EAAgB1R,GAY5D0Y,aACAD,mBAER,CACA,2BAAAxC,CAA4B5R,EAASrE,EAAY2V,EAAcpH,GAE3D,GAD6BtK,KAAKuS,wBAAwBnS,EAASrE,EAAY2V,EAAcpH,GAEzF,OAAO,EAGX,QAD0BtK,KAAK4U,gBAAgBxU,EAASrE,EAAY2V,EAAcpH,EAAW,eAC7F,CAGJ,CACA,4BAAOuK,CAAsB9Y,EAAY+Y,GACrC,MAAM,KAAE7Y,EAAI,cAAExB,GAAkBsB,EAC1BgZ,EAAY,IACX9Y,EACHC,YAAa,CAAC,UAEX6Y,EAAUpU,eACVoU,EAAUC,OACjB,MAAMC,EAAQ,CACVxa,gBACAwB,KAAMiZ,gBAAgBH,GACtBD,YAEEnU,EAAU1E,EAAK0E,QAQrB,OAPIA,IACAsU,EAAMhZ,KAAK0E,QAAU,IACdA,EACHd,SAAU,KACVsV,cAAezE,EAAc0E,QAAQzU,EAAQd,SAASN,OAAQoB,EAAQd,YAGvEoV,CACX,CACA,2BAAOI,CAAqBjV,EAASrE,EAAY6L,GAC7C,IAAK7L,EACD,OAEJ,MAAM,cAAEwK,EAAa,SAAEuO,GAAWvO,QAAwBjF,GAAcsG,GAAW,CAAC,GAC9E,cAAEnN,GAAkBsB,EACpBkZ,EAAQtE,EAAekE,sBAAsB9Y,EAAY+Y,GACzDQ,EAAiB,CACnBC,YAAa,KACT,MAAMC,EAAW7E,EAAekE,sBAAsB9Y,EAAY+Y,IAC5D,SAAErU,IAAa,IAAAD,mBAAkBJ,IAAY,CAAC,EAEpD,GADAK,GAAUgV,iBAAiB1Z,EAAWiV,WACf,IAAnBiE,EAAMH,SAAmB,CAGzB,GAFAG,EAAMH,UAAW,EACjB7W,OAAOyX,OAAO3Z,EAAWE,KAAMgZ,EAAMhZ,MACjCF,EAAWE,KAAK0E,QAAS,CACzB,MAAMgV,EAAiB5Z,EAAWE,KAClC0Z,EAAehV,QAAQd,SAAWoV,EAAMhZ,KAAK0E,QAAQwU,cAAcrR,cAC5DmR,EAAMhZ,KAAK0E,QAAQwU,cACtBQ,EAAeC,eACf,IAAAC,kCAAiC9Z,EAEzC,CAKA,OAJAkZ,EAAMhZ,KAAOuZ,EAASvZ,MACtB,IAAAkV,eAAcpV,EAAYqE,IAC1B,IAAA0V,uBAAsB/Z,EAAWtB,eAAe,QAChDgG,GAAUsV,QAEd,CACA,IAAuB,IAAnBd,EAAMH,SAMN,OALAG,EAAMH,UAAW,EACjBG,EAAMhZ,KAAOuZ,EAASvZ,MACtB,IAAA6Z,uBAAsB/Z,EAAWtB,gBACjC,IAAA4O,kBAAiBtN,EAAWtB,oBAC5BgG,GAAUsV,SAGd,MAAMC,GAAoB,IAAAC,eAAcxb,GACnCub,GAIL/X,OAAOyX,OAAOM,EAAkB/Z,KAAMgZ,EAAMhZ,MACxC+Z,EAAkB/Z,KAAK0E,UACvBqV,EAAkB/Z,KACb0E,QAAQd,SAAWoV,EAAMhZ,KAAK0E,QAAQwU,cAAcrR,QAE7DmR,EAAMhZ,KAAOuZ,EAASvZ,KACtB+Z,EAAkB7O,aAAc,GAChC,IAAAhD,2BAA0B6R,EAAmB5V,EAAS,IAAY8V,UAV9DC,QAAQC,KAAK,0BAYrBxI,GAAInT,EACJ4b,cAAe,cAGnB,OADA5F,EAAmB1L,KAAKuQ,GACjBA,CACX,CACA,UAAA5S,CAAWtC,EAASrE,EAAY6L,GAC5B5H,KAAKsW,OAAS3F,EAAe0E,qBAAqBjV,EAASrE,EAAY6L,EAC3E,CACA,mBAAA2O,GACI9F,EAAmB8F,qBACvB,CACA,iBAAAC,GACI/F,EAAmB+F,mBACvB,CACA,kBAAOC,CAAYC,EAAWnW,EAAgBuD,EAAQ8D,EAAU,CAAC,GAC7D,IAAKrH,EACD,OAAO,KAEX,MAAM,SAAEE,GAAaF,EACfoW,EAAsBlW,EAASmW,yBAC/BC,EAASpW,EAASqW,YAClBC,EAAkBnP,EAAQoP,iBAAmBH,EAAOE,gBACpDE,EAASrP,EAAQqP,QAAUJ,EAAOI,OAClCC,EAAWtP,EAAQjC,cAAgB,IAAI+Q,EAC7C,IAAIS,EACAC,EAAuBL,EACvBM,EAAcJ,EAClB,GAAIrP,EAAQuP,kBACRA,EAAoBvP,EAAQuP,kBAC5BC,OAAuB9V,EACvB+V,OAAc/V,OAGd,GAAIb,aAAoB,EAAA6W,cAAe,CACnC,MAAMC,EAAoB,8CAA0CzT,EAAO,GAAIrD,QACrDa,IAAtBiW,IACAJ,EAAoB1W,EAAS+W,cAAcD,GAEnD,KACK,MAAI9W,aAAoB,EAAAkT,oBAIzB,MAAM,IAAI8D,MAAM,6BAHhBN,EAAoBD,EAASQ,qBAAqBjX,EAAUqD,EAAO,GAAIiT,EAAiBE,EAI5F,CAEJ,MAAO,CACHN,sBACAQ,oBACAJ,gBAAiBK,EACjBH,OAAQI,EACRH,WACAzW,WAER,EAEJkQ,EAAe3R,SAAW,iBAC1B,S,oHC5RA,MAAM2Y,UAAwBhH,EAAAC,EAC1B,WAAAQ,CAAYC,EAAWC,GACnBC,MAAMF,EAAWC,EACrB,CACA,gBAAAsG,CAAiBrX,EAAgB+N,GAC7B,IAAIuJ,GAAe,EACnB,MAAM,SAAEpX,GAAaF,GACf,QAAEH,GAAYK,EACpB,IAAKA,EAASqX,qBAEV,OADA3B,QAAQC,KAAK,uCACNyB,EAEX,IAAIE,GAAc,IAAAC,gBAAehY,KAAK2N,cAAevN,GACrD,IAAK2X,GAAaxY,OACd,OAAOsY,EAGX,GADAE,EAAc/X,KAAKiY,wCAAwC7X,EAAS2X,IAC/DA,GAAaxY,OACd,OAAOsY,EAEX,MAAMpE,EAAWzT,KAAKkY,YAAYzX,GAC5BgN,EAAiB,CACnBC,YAAa1N,KAAK0N,YAClB1O,SAAUgB,KAAK2N,cACfpQ,WAAYgD,EAAeE,SAASmN,IAExC,IAAK,IAAItO,EAAI,EAAGA,EAAIyY,EAAYxY,OAAQD,IAAK,CACzC,MAAMvD,EAAagc,EAAYzY,GAC/BmO,EAAehT,cAAgBsB,EAAWtB,cAC1C,MAAM0d,EAAkBnY,KAAKkO,mBAAmB,CAC5CnS,aACA0R,mBAEJ,IAAK0K,EAAgBhF,WACjB,SAEJ,MAAMiF,EAAqBpY,KAAKqY,yBAAyB,CACrD9X,iBACAkT,WACA1X,aACAoc,kBACA7J,qBAEJuJ,IAAiBO,EACjBrc,EAAWoL,aAAc,CAC7B,CACA,OAAO0Q,CACX,CACA,gBAAA9G,CAAiBnW,GACb,MAAMmB,EAAawV,MAAMR,iBAAiBnW,GAW1C,OAVAqD,OAAOyX,OAAO3Z,EAAWE,KAAM,CAC3B0E,QAAS,CACLd,SAAU,GACVkE,QAAQ,KAGhB9F,OAAOyX,OAAO3Z,EAAY,CACtBuc,iBAAkB,GAClBpU,eAAe,IAEZnI,CACX,CACA,aAAAoV,CAAcpV,EAAYqE,GACtB,OAAO,IAAA+Q,eAAcpV,EAAYqE,EACrC,CACA,gBAAAmY,CAAiBxc,GACjB,CACA,cAAAyc,CAAezc,EAAY6K,GACvB,MAAM,OAAE9C,GAAW/H,EAAWE,KAAKG,QACnC,IAAK,IAAIkD,EAAI,EAAG4I,EAAYpE,EAAOvE,OAAQD,EAAI4I,EAAW5I,IAAK,CAC3D,MAAMyT,EAAQjP,EAAOxE,GACrByT,EAAM,IAAMnM,EAAc,GAC1BmM,EAAM,IAAMnM,EAAc,GAC1BmM,EAAM,IAAMnM,EAAc,EAC9B,CACA7K,EAAWoL,aAAc,GACzB,IAAAsR,qBAAoB1c,GAAY2c,QAASC,GAAoB3Y,KAAKwY,eAAeG,EAAiB/R,GACtG,CACA,qBAAAoB,CAAsBjM,EAAY6c,EAAcC,EAAYjR,GACxD,MAAMtC,EAAiBtF,KAAKiB,eAAesE,UAAY,CAAC,GACxD,EAAAyC,EAAA,GAAsBjM,EAAY6c,EAAcC,EAAY,CACxDtT,SAAU,CACNC,UAAWF,EAAeE,QAC1BC,QAASH,EAAeG,SAE5BqT,uBAAwBlR,GAASkR,wBAEzC,CACA,iBAAAC,CAAkBhd,GACd,OAAOA,EAAWE,KAAK0E,SAASd,UAAY9D,EAAWE,KAAK4D,QAChE,CACA,wBAAAwY,CAAyBW,GACrB,MAAM,eAAEzY,EAAc,gBAAE4X,EAAe,iBAAE7J,GAAqB0K,EACxDjd,EAAaid,EAAcjd,WACjC,GAAIA,EAAW6S,oBACX,OAEJ,MAAM,cAAEnU,GAAkBsB,GACpB,SAAE0E,GAAaF,GACf,cAAEM,GAAkBJ,EACpBwY,EAAuBjZ,KAAK+Y,kBAAkBhd,GAAY6E,IAAKmS,GAAUlS,EAAckS,KACvF,UAAElF,EAAS,SAAEC,EAAQ,MAAEC,EAAK,UAAEC,EAAS,YAAEC,GAAgBkK,EAEzDtJ,EAAc,CAACoK,MADC,EAAAC,EAAA,GAA0Bnd,EAAY0E,IAS5D,OAPA,IAAAqO,UAAYR,EAAkB7T,EAAe,kBAAmBoU,EAAa,CACzEd,MAAOA,EACPD,SAAUA,EACVD,UAAW7K,KAAKmG,IAAI,GAAK0E,GACzBG,UAAWA,EACXC,YAAaA,KAEV,CACX,E,wICvGJ,MAAMkL,UAAoCxB,SAC7B3X,KAAKoZ,oBAAsB,GAAK,CACzC,WAAAhI,CAAYC,EAAWC,GACnBC,MAAMF,EAAWC,GACbtR,KAAKiB,cAAcoY,eAAe7T,SAClC8T,EAAA,EAAqBC,QAAQvZ,KAAK2N,cAE1C,CACA,sBAAA6L,GACQxZ,KAAKiB,cAAcoY,eAAe7T,QAClC8T,EAAA,EAAqBC,QAAQvZ,KAAK2N,eAGlC2L,EAAA,EAAqBG,WAAWzZ,KAAK2N,cAE7C,CACA,yBAAA+L,GACI,OAAO,CACX,CACA,gBAAA3I,CAAiBnW,GACb,MAAMiC,EAAcjC,EAAIsF,QAClB,QAAEE,GAAYvD,EACd0D,GAAiB,IAAAC,mBAAkBJ,GACzC,IAAKG,EACD,OAEJ,MAAM,SAAEE,GAAaF,EACfoZ,EAAoBpI,MAAMR,iBAAiBnW,GACjD,IAAKoF,KAAK0Z,4BACN,OAAOC,EAEX,MAAMC,GAAY,EAAAC,EAAA,GAAsBpZ,EAASmN,IACjD,IAAKgM,EACD,MAAM,IAAInC,MAAM,0EAEpB,IAAKmC,EAAUE,mBAAmBC,QAC9B,MAAM,IAAItC,MAAM,yCAEpB,MAAM,eAAE7a,GAAmBgd,EACrBtb,GAAe,EAAA0b,EAAA,GAAsBpd,GAC3C,OAAO,EAAAoM,UAAA,UAAoB2Q,EAAmB,CAC1C1d,KAAM,CACF2Z,aAAc,CACVhZ,iBACA0B,kBAIhB,CACA,aAAA6S,CAAcpV,EAAYqE,GACtB,MAAM3F,EAAgB8W,MAAMJ,cAAcpV,EAAYqE,GACtD,GAAIJ,KAAK0Z,4BAA6B,CAClC,MAAMO,EAAuBle,GAC7B,IAAA8Z,kCAAiCoE,EACrC,CACA,OAAOxf,CACX,CACA,gBAAA8d,CAAiBxc,GACTiE,KAAK0Z,8BACL,IAAAQ,qCAAoCne,GAExCwV,MAAMgH,iBAAiBxc,EAC3B,CACA,kBAAAmS,CAAmBmG,GACf,MAAM8D,EAAkB5G,MAAMrD,mBAAmBmG,GACjD,IAAKrU,KAAK0Z,4BACN,OAAOvB,EAEX,MAAMgC,EAA2Bna,KAAKoa,6BAA6B/F,GACnE,OAAO,EAAArL,UAAA,UAAoBmP,EAAiBgC,EAChD,CACA,wBAAA9B,CAAyBW,GACrB,MAAM,WAAEjd,GAAeid,GACjB,YAAE7R,GAAgBpL,EAClBse,EAAe9I,MAAM8G,yBAAyBW,GACpD,GAAI7R,GAAenH,KAAK0Z,4BAA6B,CACjD,MAAM,eAAE9c,GAAmB,EAAaX,KAAK2Z,cAC7C,IAAA0E,iCAAgC1d,GAChC,MACM2d,GADc,EAAAC,EAAA,GAA+B5d,GAClBgE,IAAKrD,IAChB,IAAAkd,yBAAwBld,GACzBqQ,KAErB,EAAA8M,EAAA,GAAuCH,EAC3C,CACA,OAAOF,CACX,CACA,uCAAApC,CAAwC7X,EAAS2X,GAC7C,IAAKA,IAAgBA,EAAYxY,OAC7B,OAEJ,MAAMob,EAA0BpJ,MAAM0G,wCAAwC7X,EAAS2X,GACvF,IAAK4C,IAA4BA,EAAwBpb,OACrD,OAEJ,MAAMgB,GAAiB,IAAAC,mBAAkBJ,IACnC,SAAEK,GAAaF,EACrB,OAAOoa,EAAwBzb,OAAQnD,IACnC,MAAMa,EAAiBb,GAAYE,MAC7B2Z,cAAchZ,eACpB,OAAKA,KAGI,KAAgCge,8BAA8Bna,EAASmN,GAAI,CAChFhR,iBACAY,KAAM,EAAAqd,4BAA4Bd,WAG9C,CACA,4BAAAK,CAA6B/F,GACzB,MAAMtY,EAAasY,EAAQtY,YACrB,eAAEa,EAAc,aAAE0B,GAAiBvC,EAAWE,KAAK2Z,cACnD,WAAErY,GAAe8W,EAAQ5G,eACzBqN,GAA8B,EAAAF,EAAA,IAA+Brd,EAAY,CAAEX,mBACjF,IAAKke,GAA6Bvb,OAC9B,MAAO,CAAC,EAEZ,IAAIwb,EAEAA,EADAD,EAA4Bvb,OAAS,EACRub,EAA4BE,KAAMC,GAAQA,EAAIre,iBAAmBA,GAC1Fqe,EAAIzd,OAAS,EAAAqd,4BAA4Bd,SAGhBe,EAA4B,GAE7D,MAAM,cAAE5W,GAAkBnI,EAEpBmf,GADiB,IAAAC,yBAAwBve,GACP4C,SAASlB,IAC3C,MAAEyP,EAAK,UAAEC,EAAS,UAAEH,EAAS,YAAEI,EAAW,SAAEH,EAAQ,WAAEqF,IAAe,EAAAiI,EAAA,GAAsB,CAC7Fxe,iBACA0B,eACAf,aACA2G,kBAEJ,MAAO,CACH6J,QACAC,YACAH,YACAI,cACAH,WACA6G,QAAS,CACL5G,SAEJoF,aACAoB,OAAQ2G,EAEhB,E,mCCjKJ,MAAMG,EAAuB,CACzBC,eAAe,EACfC,0BAA2B,EAC3BC,aAAc,EACdC,qBAAsB,EACtBC,eAAgB,EAChBC,uBAAwB,IACxBC,iBAAata,EACbua,yBAAqBva,EACrBwa,yBAA0B,MAC1BC,+BAAgC,EAChCC,YAAY,EACZC,UAAW,GACXC,kBAAmB,GACnBC,uBAAwB,IAK5B,QAHA,WACI,OAAOd,CACX,C,wICXA,SAASe,EAA0B3b,EAAU4b,EAAaC,EAAmBC,GACrED,EAAkBE,KAClB/b,EAASsV,SAMjB,SAAiCtV,EAAU4b,EAAaE,GACpD,MAAM,eAAE3f,GAAmB2f,EACrBE,EAAqB,IAAIC,IAC/BL,EAAY3D,QAASiE,IACjB,MAAMC,EAAW,EAAA9I,MAAM+I,YAAYF,GACnC,IAAKC,EAED,YADAzG,QAAQC,KAAK,oCAAoCuG,uBAGrD,MAAMre,EAAese,EAAS3gB,KAAKqC,cCpBpC,SAA0Bse,GAC7B,IAAKA,EACD,MAAM,IAAInF,MAAM,oCAAoCmF,EAAShP,MAEjE,MAAM+O,EAAaC,EAAShP,GAC5B,GAAIgP,EAASpf,OAAS,EAAAsf,MAAA,aAAmBC,QACrC,MAAM,IAAItF,MAAM,iBAAiBmF,EAASpf,qCAEzCof,EAAS3gB,MACVka,QAAQC,KAAK,oCAAoCuG,sBAGzD,CDSQK,CAAiBJ,GACjB,MAAMK,EAAwB,IAAkB7J,SAAS,CACrD7V,WAAYkD,EAASmN,GACrBhR,iBACAY,KAAM,EAAAqd,4BAA4Bd,QAClCzb,iBAEE4e,EAAaN,EAAS3gB,KACtB8a,EAAkBtW,EAASqW,YAAYC,gBAC7CmG,EAAWC,SAASzE,QAAS/X,IACzB,MAAM,OAAEmD,EAAM,MAAEiK,EAAK,GAAEH,GAAOjN,EACxBwW,GAAoB,OAAkC1W,EAAUqD,EAAO,GAAIiT,GAC3EqG,EAAgC,CAClC3iB,cAAe,EAAAuO,UAAA,SACf/M,KAAM,CACF0E,QAAS,CACLoD,QAAQ,EACRlE,SAAUiE,GAEd8R,aAAc,CACVhZ,iBACA0B,eACAyP,QACAH,MAEJxR,QAAS,CAAC,GAEdA,QAAS,CAAC,EACV8V,aAAa,EACbhO,eAAe,EACfiD,aAAa,EACb5K,UAAU,EACVE,WAAW,EACXuU,SAAU,CACNmG,oBACAnY,SAAU,wCACV2X,oBAAqBlW,EAASmW,yBAC9BG,gBAAiBtW,EAASqW,YAAYC,kBAGxCsG,EAA0B5c,EAASL,SACzC,IAAA+Q,eAAciM,EAA+BC,IAC7C,IAAAxH,kCAAiCuH,KAEjCH,GACAR,EAAmBa,IAAIhf,EAAc2e,KAG7Cxc,EAASsV,QACb,CA9DQwH,CAAwB9c,EAAU4b,EAAaE,EAEvD,C,gIEXA,MAAMiB,EAAgB,IAAId,IACpBe,EAAO,EAAGC,OAAMC,OAAMC,YACxBA,EAAMC,cAAcC,uBAAuB,EAAGJ,GAC9CE,EAAMC,cAAcE,iBAAiB,EAAGJ,ICA5C,MAAM,OAAEK,GAAW,EAAAhV,UAoFnB,QAnFAiV,eAAoC7d,EAAS8d,EAActhB,EAAgBuhB,GACvE,MAAM5d,GAAiB,IAAAC,mBAAkBJ,IACnC,gBAAEyD,EAAe,SAAEpD,GAAaF,GAC9BqN,GAAIrQ,GAAekD,EAI3B,GAAIA,aAAoB,EAAAkT,mBAAoB,CACxC,MACMC,EAmDd,SAAkCsK,EAActhB,GAC5C,IAAI,SAAEgX,GAAasK,EACnB,IAAKtK,EAAU,CACXA,EAAWoK,IACX,MAAMpI,GAAe,EAAAhY,EAAA,GAAgBhB,GACrCgZ,EAAakE,mBAAmBsE,SAAW,IACpCxI,EAAakE,mBAAmBsE,SACnCxK,YAEJsK,EAAatK,SAAWA,GACxB,IAAA1W,6BAA4BN,EAChC,CACA,OAAOgX,CACX,CAhEyByK,CADUH,EACmCthB,GACzD,EAAAkX,MAAMC,UAAUH,UAgE7BqK,eAAoCC,GAChC,MAAMI,EAAYJ,EAElB,KADoBI,EAAUC,SAAShf,OAAS,GAE5C,MAAM,IAAIkY,MAAM,qEAEpB,MAAM5D,QAAe,EAAA2K,aAAA,+BAA4CN,EAAatK,UAAYoK,IAAUM,EAAUC,UAC9G,OAAO1K,CACX,CAvEkB4K,CAAqBP,GAE/B,IAAIQ,EAAYP,GAAQO,WAAa,EAAA5B,MAAA,WAAiB6B,wBAClDC,EAA2BF,IAAc,EAAA5B,MAAA,WAAiB+B,+BAC9D,GAAID,EAA0B,CAC1B,MAAME,EAAoBre,EAASse,cAC7BC,EAAa,EAAAlL,MAAMC,UAAU+K,GAE7BG,EADY,EAAAnL,MAAMC,UAAUH,GACRsL,WACpBC,EAAUH,EAAWE,WACvBD,EAAQ,KAAOE,EAAQ,IACvBF,EAAQ,KAAOE,EAAQ,IACvBF,EAAQ,KAAOE,EAAQ,KACvBP,GAA2B,EAC3BF,EAAY,EAAA5B,MAAA,WAAiB6B,wBAC7BxI,QAAQiJ,MAAM,iEAEtB,CACA,MAAMC,EAAe,CACjB,CACIzL,WACAT,WA5BO,KA6BPmM,kBAAmB,GAAG1iB,KAAkB,EAAAie,4BAA4BuD,WACpEQ,2BACAF,cAGR,GAAKW,EAAa,GAAGT,yBAGhB,CACD,MAAMW,QDzCXtB,gBAAiD,SAAExd,EAAQ,aAAE4e,EAAY,eAAEziB,IAC9E,MAAM4iB,EAAe/e,EAASgf,mBACxB,MAAE7B,GAAU4B,GACZ,IAAExjB,EAAG,SAAE0jB,GAAaF,EACpBV,EAAoBre,EAASse,cACnC,GAAIvB,EAAcmC,IAAI3jB,IAAM4jB,MACxB,MAAO,CACH5jB,MACA4hB,SAGR,MAAMiC,EAAmBR,EACnBS,EAAmB,EAAAhM,MAAMC,UAAU8L,EAAiB,GAAGjM,UAC7D,IAAKkM,EACD,MAAM,IAAIrI,MAAM,wBAAwBqI,EAAiBlM,2BAE7D,MAAM,SAAEA,GAAaiM,EAAiB,GAChCE,QAAuB,EAAAvB,aAAA,WAAwB5K,GACrD,IAAKmM,EACD,MAAM,IAAItI,MAAM,2BAA2BsI,EAAenM,2BAE9D,MACMoM,EADkBD,EAAeE,aACPC,8BACxBC,UAAWC,GAAiBL,EAC9Bf,EAAa,EAAAlL,MAAMC,UAAU+K,GAE7BuB,EADmBrB,EAAWiB,aACFC,6BAE5BI,EAAW,IAAIC,aADL,EAC4BvB,EAAWiB,aAAaO,uBAC9DC,EAAOL,EAAaM,gBAC1B,IAAK,IAAIC,EAAI,EAAGA,EAAIF,EAAK,KAAME,EAC3B,IAAK,IAAItQ,EAAI,EAAGA,EAAIoQ,EAAK,KAAMpQ,EAC3B,IAAK,IAAIF,EAAI,EAAGA,EAAIsQ,EAAK,KAAMtQ,EAAG,CAC9B,MAAMyQ,EAASzQ,EAAIsQ,EAAK,IAAMpQ,EAAIoQ,EAAK,GAAKE,GAC5CL,EAPI,EAOKM,EAAmB,GAAKP,EAASO,GAC1CN,EARI,EAQKM,EAAmB,GAAKZ,EAAQY,EAC7C,CAGRngB,EAASogB,aAAa,CAAC7kB,IACvB,MAAM8kB,EAAYlD,EAAMmD,YAClBC,GAAS,IAAAC,gCAA+BH,GAC9ClD,EAAMsD,UAAUF,GAChBA,EAAOG,aAAa,EAAArE,MAAA,WAAiB+B,gCACrC,MAAMuC,EAAaJ,EAAOK,eAAeC,eAAeC,SAAS,GAqBjE,SAASC,EAA2B5mB,GAChC,MAAM,eAAEgC,GAAmBhC,EAAIsF,QACzB,mBAAE4Z,IAAuB,EAAAlc,EAAA,GAAgBhB,IACvCgX,SAAU6N,GAAgB3H,EAAmBsE,SACrD,GAAIqD,IAAgB1B,EAAenM,SAC/B,OAEJ,MACM8N,EADqB,EAAA5N,MAAMC,UAAU0N,GACAxB,aACrCE,EAAYa,EAAOK,eACnBM,EAAQxB,EAAUmB,eAAeC,SAAS,GAC1ClB,EAAWsB,EAAMC,UAEjBnB,EAAOL,EAAaM,gBACpBmB,EAASC,MAAMC,KAAK,CAAExiB,OAAQkhB,EAAK,IAAM,CAACuB,EAAG1iB,IAAMA,GACzD,IAAK,MAAMqhB,KAAKkB,EACZ,IAAK,IAAIxR,EAAI,EAAGA,EAAIoQ,EAAK,KAAMpQ,EAC3B,IAAK,IAAIF,EAAI,EAAGA,EAAIsQ,EAAK,KAAMtQ,EAAG,CAC9B,MAAMyQ,EAASzQ,EAAIsQ,EAAK,IAAMpQ,EAAIoQ,EAAK,GAAKE,GAC5CN,EAPI,EAOKO,EAAmB,GAAKc,EAAgBO,WAAWrB,EAChE,CAGRe,EAAMO,QAAQ7B,GACdF,EAAUgC,WACV1hB,EAASsV,QACb,CAsBA,OApEAqL,EAAWc,QAAQ5B,GACnBc,EAAWgB,sBAAsB,GACjCxE,EAAMC,cAAcwE,kBAAkB,GACtCzE,EAAMC,cAAcyE,6BAA6B,GAAG,GACpD1E,EAAMC,cAAc0E,0BAAyB,GAC7C9hB,EAAS+hB,SAAS,CACd5E,QACA5hB,MACA0jB,WACA+C,aAAc3D,EACdQ,kBAAmB,GAAG1iB,KAAkB,EAAAie,4BAA4BuD,aAExEZ,EAAcF,IAAIthB,EAAK,CACnB4jB,OAAO,EACP8C,8BAA+B,GAAG9lB,IAClC+lB,kBAAmBliB,EAASmiB,iBAEhChF,EAAMN,IAAI,CACNuF,QAASpF,IA6Bb,EAAA1gB,YAAY+lB,0BAA0B,EAAA9lB,OAAO+lB,2BAA4BvB,EAA4B,KACrG,EAAAzkB,YAAY4E,iBAAiB,EAAA3E,OAAOW,oCAAqCsgB,MAAOrjB,IAC5E,EAAAmC,YAAYuF,oBAAoB,EAAAtF,OAAO+lB,2BAA4BvB,GACnE,MAAMwB,EAAaviB,EAASwiB,SAASjnB,IAC/B,QAAEoE,EAAO,GAAEwN,GAAOnN,EACxBA,EAASogB,aAAa,CAAC7kB,IACvB,MAAM4hB,QAAc,IAAAsF,mBAAkB,CAClCtP,SAAU5X,EACV0iB,UAAW,EAAA5B,MAAA,WAAiB6B,wBAC5Be,SAAU,EAAGyD,kBACLH,EAAWtD,UACXsD,EAAWtD,SAAS,CAChByD,cACAvP,eAIbxT,EAASwN,GACZnN,EAAS+hB,SAAS,CAAE5E,QAAO5hB,QAC3ByE,EAASsV,WAEN,CACH/Z,MACA4hB,QAER,CC5EiCwF,CAAkC,CACnD3iB,WACA4e,eACAziB,mBAEJ,OAAO2iB,CACX,OATU,IAAA8D,uBAAsBxf,EAAiBwb,EAAc,CAAC9hB,GAlC5C,MACD,KA2CvB,KACK,CACD,MACM+lB,GADuB,QAAsC7iB,EAASmN,GAAIhR,GACvCgE,IAAK8S,IAAY,CACtDA,UACA4L,kBAAmB,GAAG1iB,KAAkB,EAAAie,4BAA4BuD,YAAY1K,QAEpF,IAAA6P,2BAA0B1f,EAAiByf,EAAa,CAAC/lB,GAC7D,EACA,IAAA+c,iCAAgC1d,EACpC,C,mCClEA,MAAM4mB,EAAwB,CAC1BlI,eAAe,EACfmI,uBAAuB,EACvBjI,aAAc,EACdC,qBAAsB,EACtBM,+BAAgC,EAChCC,YAAY,EACZ0H,oBAAoB,EACpBzH,UAAW,GACXC,kBAAmB,GACnBR,eAAgB,EAChBC,uBAAwB,KAK5B,QAHA,WACI,OAAO6H,CACX,C,6DCRA,QALA,SAAmCpjB,EAASxD,GACxC,MAAM2D,GAAiB,IAAAC,mBAAkBJ,IACnC,SAAEK,GAAaF,EACrBE,EAASogB,aAAa,EAAC,QAAoBpgB,EAASmN,GAAIhR,IAC5D,C,wGCyDA,QAzDA,SAAqC6D,EAAUkjB,EAAS/mB,GACpD,MAAMgnB,GAAoB,QAAqBnjB,EAASmN,GAAIhR,EAAgB+mB,EAAQrlB,cAC9EulB,EAAeD,GAAmBhG,MAClCnhB,EAAYknB,EAAQnlB,QAC1B,GAAIqlB,EAAc,CAEd,GADAA,EAAaC,cAAcrnB,IACtBA,EACD,OAEJ,MAAMsnB,EAAgBF,EAAa9C,YAC7BiD,EAAkBD,EAAc1C,eAChC4C,EAAYN,EAAQ7f,OACpBogB,EAAWP,EAAQQ,MACnBhkB,EAAgB6jB,EAAgBI,YAAYxC,UAC5CyC,EAAeL,EAAgBM,WAAW1C,UAChD,GAAIqC,EAAU1kB,SAAWY,EAAcZ,QACnC2kB,EAAS3kB,SAAW8kB,EAAa9kB,OACjC,OAEJ,MAAMglB,EAAW,mBACjBA,EAASH,YAAYlC,QAAQ+B,EAAW,GACxC,MAAMO,EAAY,iBAAyB,CACvCC,OAAQlE,aAAawB,KAAKmC,KAM9B,OAJAK,EAASG,SAASF,GAClBT,EAAcY,aAAaJ,GAC3BR,EAAc5B,gBACd1hB,EAASmkB,cAAcC,0BAE3B,CACA,MAAM/gB,EAAS6f,EAAQ7f,OACjBqgB,EAAQR,EAAQQ,MAChBpW,EAAQ4V,EAAQ5V,MAChB+W,EAAkB,mBACxBA,EAAgBV,YAAYlC,QAAQpe,EAAQ,GAC5C,MAAM0gB,EAAY,iBAAyB,CACvCC,OAAQlE,aAAawB,KAAKoC,KAE9BW,EAAgBJ,SAASF,GACzB,MAAMxD,EAAS,iBAAsB,CAAC,GAEtCA,EAAO2D,aAAaG,GACpB,MAAMlH,EAAQ,mBACdA,EAAMsD,UAAUF,GAChBpD,EAAMC,cAAckH,SAAShX,EAAM,GAAK,IAAKA,EAAM,GAAK,IAAKA,EAAM,GAAK,KACxE6P,EAAMC,cAAcmH,aAAa,GACjC,MAAM1F,GAAoB,QAA4B1iB,EAAgB+mB,EAAQrlB,cAC9EmC,EAAS+hB,SAAS,CACdxmB,IAAK,EAAAgN,UAAA,SACL4U,MAAOA,EACPqH,eAVAA,UAWA3F,sBAEJ7e,EAASykB,cACTzkB,EAASmkB,cAAcC,2BACvBpkB,EAASsV,QACb,C,kDCpDA,QATA,SAAkC3V,EAASxD,GACvC,MAAM2D,GAAiB,IAAAC,mBAAkBJ,IACnC,SAAEK,GAAaF,EAEf4kB,EADe1kB,EAAS2kB,YACalmB,OAAQ0e,GAAUA,EAAM0B,mBAC5B,iBAA5B1B,EAAM0B,mBACb1B,EAAM0B,kBAAkB+F,WAAWzoB,IACvC6D,EAASogB,aAAasE,EAAsBvkB,IAAKgd,GAAUA,EAAM5hB,KACrE,C,4FCJe,MAAMspB,SACRtlB,KAAKulB,aAAe,GAAc,QAClCvlB,KAAKwlB,eAAiB,CAC3B,CAAC,EAAAC,kBAAkBC,oBAAqBC,EAAc,EAAAF,kBAAkBC,mBAAoB,EAAAD,kBAAkBG,YAC9G,CAAC,EAAAH,kBAAkBI,kBAAmBF,EAAc,EAAAF,kBAAkBI,iBAAkB,EAAAJ,kBAAkBG,YAC1G,CAAC,EAAAH,kBAAkBK,MAAOH,EAAc,EAAAF,kBAAkBK,MAC1D,CAAC,EAAAL,kBAAkBG,YAAaD,EAAc,EAAAF,kBAAkBG,YAChE,CAAC,EAAAH,kBAAkBM,qBAAsBC,EAAmB,EAAAP,kBAAkBM,qBAC9E,CAAC,EAAAN,kBAAkBQ,aAAcN,EAAc,EAAAF,kBAAkBQ,YAAa,EAAAR,kBAAkBG,YAChG,CAAC,EAAAH,kBAAkBS,eAAgBP,EAAc,EAAAF,kBAAkBS,cAAe,EAAAT,kBAAkBG,YACpG,CAAC,EAAAH,kBAAkBU,eAAgBR,EAAc,EAAAF,kBAAkBU,cAAe,EAAAV,kBAAkBG,YACpG,CAAC,EAAAH,kBAAkBW,mBAAoBJ,EAAmB,EAAAP,kBAAkBW,mBAC5E,CAAC,EAAAX,kBAAkBY,SAAUL,EAAmB,EAAAP,kBAAkBY,SAAS,GAC3E,CAAC,EAAAZ,kBAAkBa,0BAA2BX,EAAc,EAAAF,kBAAkBa,0BAC9E,CAAC,EAAAb,kBAAkBc,2CAA4CZ,EAAc,EAAAF,kBAAkBc,2CAC/F,CAAC,EAAAd,kBAAkBe,oCAAqCb,EAAc,EAAAF,kBAAkBe,oCACxF,CAAC,EAAAf,kBAAkBgB,YAAad,EAAc,EAAAF,kBAAkBgB,YAChE,CAAC,EAAAhB,kBAAkBiB,eAAgBV,EAAmB,EAAAP,kBAAkBiB,eACxEC,aAAc,KACf,CACH,WAAAvV,CAAYwV,KAASC,GACjB7mB,KAAK8mB,YAAc,GACnB9mB,KAAK+mB,MAAQ,GACb/mB,KAAKgnB,oBAAsB,GAC3BhnB,KAAKinB,KAAO,CAAC1mB,EAAgB2mB,KACzB,MAAMC,EAAkBnnB,KAAKonB,WAAW7mB,EAAgB2mB,EAAe,EAAAzB,kBAAkBK,MACzF,IAAKqB,EACD,OAEJnnB,KAAK+mB,MAAMrO,QAAS2O,GAASA,EAAKF,IAClC,MAAM,yBAAEG,EAAwB,aAAEhpB,GAAiB6oB,EAEnD,OADA,IAAA7M,iCAAgC6M,EAAgBvqB,eAAgB0qB,EAAyBC,2BAA4BjpB,GAC9G6oB,GAEXnnB,KAAKwnB,mBAAqB,CAACjnB,EAAgB2mB,KACvC,MAAMC,EAAkBnnB,KAAKonB,WAAW7mB,EAAgB2mB,GACnDC,GAGLnnB,KAAKgnB,oBAAoBtO,QAAS2O,GAASA,EAAKI,KAAKznB,KAAMmnB,KAE/DnnB,KAAK0nB,WAAa,CAACnnB,EAAgB2mB,KAC/B,MAAMC,EAAkBnnB,KAAKonB,WAAW7mB,EAAgB2mB,EAAe,EAAAzB,kBAAkBgB,YACzF,GAAKU,EAGL,OAAOA,GAEXnnB,KAAK2nB,kBAAoBf,EACzB5mB,KAAK2mB,aAAeE,EACpBA,EAAanO,QAASkP,IAClB,MAAMrI,EAAgC,mBAAhBqI,EAA6BA,IAAgBA,EACnE,GAAKrI,EAGL,IAAK,MAAMsI,KAAOtI,EAAQ,CACtB,IAAK+F,EAAcE,eAAeqC,GAC9B,MAAM,IAAIpQ,MAAM,eAAeoQ,yBAEnCvC,EAAcE,eAAeqC,GAAK7nB,KAAMuf,EAAOsI,GACnD,IAEJ7nB,KAAK8nB,iBAAmB,CAACvnB,EAAgB2mB,IAC9BlnB,KAAKinB,KAAK1mB,EAAgB2mB,GAErC,IAAK,MAAMW,KAAO5pB,OAAOoB,KAAKimB,EAAcE,gBACxCxlB,KAAK8nB,iBAAiBD,GAAO7nB,KAAK6nB,EAE1C,CACA,UAAAT,CAAW7mB,EAAgB2mB,EAAea,GACtC,MAAM,SAAEtnB,GAAaF,EACftE,GAAO,OAAgB,CAAEirB,gBAAezmB,WAAUunB,SAAUhoB,OAClE,IAAK/D,EACD,OAAO,KAEX,MAAM,kBAAEgsB,EAAiB,yBAAEX,EAAwB,sBAAEY,GAA2BjsB,EAC1Eqa,EAAO4Q,EAAcxkB,WAAWwkB,EAActqB,eAAgB0qB,GAC9DH,EAAkB,CACpBY,mBACGb,EACH5oB,aAAc4oB,EAAc5oB,aAC5BiC,iBACA0nB,oBACAX,2BACAY,wBACAznB,WACA0nB,YAAa,KACbC,WAAY,KACZC,oBAAqB,KACrBC,cAAetoB,KACfsW,QAGJ,OADAtW,KAAK8mB,YAAYpO,QAAS2O,GAASA,EAAKF,IACjCA,CACX,EAEJ,SAASxB,EAAciB,EAAM2B,GACzB,MAAMC,EAAW,IAAI5B,IACrB,MAAO,CAAC0B,EAAejB,KACnBiB,EAAcE,KAAc,GAC5BF,EAAcE,GAAUzjB,KAAKsiB,GAC7BiB,EAAc1B,KAAU2B,EAClB,CAAChoB,EAAgB2mB,KAAkBuB,KACjC,MAAMtB,EAAkBmB,EAAcC,GAAmBhoB,EAAgB2mB,EAAeN,GACxF,IAAI8B,EAKJ,OAJAJ,EAAcE,GAAU9P,QAAS2O,IAC7B,MAAMsB,EAAQtB,EAAKI,KAAKa,EAAenB,KAAoBsB,GAC3DC,IAAgBC,IAEbD,GAET,CAACxB,KAAkBuB,KACjBH,EAAcE,GAAU9P,QAAS2O,GAASA,EAAKI,KAAKa,EAAepB,KAAkBuB,KAGrG,CACA,SAASzC,EAAmBY,EAAMgC,GAAgB,GAC9C,MAAO,CAACN,EAAejB,KACnB,GAAIiB,EAAc1B,GACd,MAAM,IAAInP,MAAM,wBAAwBmP,oBAE5C0B,EAAc1B,GAAQgC,EAChBvB,EACA,CAAC9mB,EAAgB2mB,KAAkBuB,KACjCvB,EAAc3mB,eAAiBA,EACxB8mB,EAAKI,KAAKa,EAAepB,KAAkBuB,IAGlE,C,kDCpIA,SACI,CAAChD,EAAA,EAAkBC,oBAAsBwB,IACrC,MAAM,aAAE5oB,EAAY,oBAAEuqB,EAAmB,yBAAEvB,EAAwB,UAAEwB,EAAS,gBAAE/R,EAAe,sBAAEmR,EAAqB,cAAEjnB,GAAmBimB,EAC3I,IAAKjmB,GAAe8nB,sBAIhB,OAHA7B,EAAc8B,uBAAuB1qB,aAAe,KACpD4oB,EAAc8B,uBAAuBC,iBAAkB,OACvD/B,EAAc8B,uBAAuBE,iBAAkB,GAG3D,IAAID,GAAkB,EAClBC,GAAkB,EACtB,MAAMC,EAAe,IACd7B,EAAyB8B,gBAE5BpmB,KAAKC,IAAI8T,EAAgB,IAAM,GAC/BoS,EAAa,GAAK,CAACL,EAAU,GAAIA,EAAU,IAEtC9lB,KAAKC,IAAI8T,EAAgB,IAAM,GACpCoS,EAAa,GAAK,CAACL,EAAU,GAAIA,EAAU,IAEtC9lB,KAAKC,IAAI8T,EAAgB,IAAM,KACpCoS,EAAa,GAAK,CAACL,EAAU,GAAIA,EAAU,KAW/C,GALAxB,EAAyB5O,QAJR,EAAGiQ,YAChBM,IAAoBN,IAAUrqB,EAC9B4qB,IAAoBP,IAAUE,GAES,CACvC1I,UAAW+H,EACXE,WAAYlB,EAAckB,WAC1BiB,UAAWF,KAEVF,IAAoBC,EAErB,YADAhC,EAAc8B,uBAAuB1qB,aAAe,MAGxD,MAAMgrB,EAAgBhC,EAAyBiC,cAAcT,GAC7D5B,EAAc8B,uBAAuB1qB,aAAegrB,EACpDpC,EAAc8B,uBAAuBC,gBAAkBA,EACvD/B,EAAc8B,uBAAuBE,gBAAkBA,I,cCtC/D,SACI,CAACzD,EAAA,EAAkBG,YAAcsB,IAC7B,MAAM,cAAEa,EAAa,UAAEe,EAAS,yBAAExB,EAAwB,kBAAEW,EAAiB,cAAEhnB,EAAa,aAAE3C,EAAY,SAAEmC,GAAcymB,EAC1H,IAAKjmB,GAAeuoB,WAAWC,YAAcX,IAAcxqB,EACvD,OAEJ,GAAIypB,IAAkBtC,EAAA,EAAkBU,eACpC4B,IAAkBtC,EAAA,EAAkBI,iBACpC,OAEJ,MAAMwD,EAAY/B,EAAyB8B,gBACnCM,MAAOC,EAAY,cAAEC,EAAgB,GAAM3oB,EAAcuoB,UAC3DK,EAAWF,EAAe,EAAIC,GAC9B,gBAAE7S,GAAoBtW,EAASqW,YAC/BqS,EAAeE,EAAUzoB,IAAI,CAACkpB,EAAKC,KACrC,MAAO3f,EAAKjB,GAAO2gB,EACnB,MAAO,CACH9mB,KAAKmG,IAAIiB,EAAK0e,EAAUiB,GAAOF,GAC/B7mB,KAAKoH,IAAIjB,EAAK2f,EAAUiB,GAAOF,MAGnC7mB,KAAKC,IAAI8T,EAAgB,IAAM,GAC/BoS,EAAa,GAAK,CAACL,EAAU,GAAIA,EAAU,IAEtC9lB,KAAKC,IAAI8T,EAAgB,IAAM,GACpCoS,EAAa,GAAK,CAACL,EAAU,GAAIA,EAAU,IAEtC9lB,KAAKC,IAAI8T,EAAgB,IAAM,KACpCoS,EAAa,GAAK,CAACL,EAAU,GAAIA,EAAU,KAE/C,MAAMU,EAAYG,GAAgB,CAACK,KAAWA,KACxCC,EAAcJ,EAAWA,EAU/B5B,EAAkBvP,QATD,EAAGiQ,QAAOuB,eAEvB,GADiB,aAAapB,EAAWoB,GAC1BD,EACX,OAEJ,MAAME,EAAOrI,MAAMsI,QAAQzB,GAAS,SAASA,GAASA,EACtDa,EAAU,GAAKxmB,KAAKoH,IAAI+f,EAAMX,EAAU,IACxCA,EAAU,GAAKxmB,KAAKmG,IAAIghB,EAAMX,EAAU,KAER,CAAEH,UAAWF,IACjDloB,EAAcuoB,UAAUE,MAAQF,GAEpC,CAAC/D,EAAA,EAAkBC,oBAAsBwB,IACrC,MAAM,cAAEjmB,GAAkBimB,EACrBjmB,GAAeuoB,WAAWC,YAG/BxoB,EAAcuoB,UAAUE,MAAQ,OAEpC,CAACjE,EAAA,EAAkBa,0BAA4BY,IAC3C,MAAM,cAAEjmB,EAAa,SAAER,GAAaymB,GAC9B,cAAE0C,EAAgB,EAAC,UAAEH,GAAcxoB,EAAcuoB,UACvD,IAAKC,EAED,YADAxoB,EAAcuoB,UAAUa,sBAAwB,GAGpD,GAAsB,IAAlBT,EACA,OAEJ,MAAMzJ,EAAY1f,EAAS8N,eAC3B,IAAK4R,EACD,OAEJ,MAAM,QAAErf,GAAYqf,EACdmK,EAAe,CACjB7pB,EAASL,QAAQmqB,YAAc,EAC/B9pB,EAASL,QAAQoqB,aAAe,GAE9BC,EAAgBb,EAAgB9oB,EAAQ,GAExC4pB,EADsBjqB,EAASoC,cAAcynB,GACH1pB,IAAK+pB,GAAUA,EAAQF,GACjEG,EAAqBnqB,EAASI,cAAc6pB,GAC5CL,EAAwBrnB,KAAKC,IAAIqnB,EAAa,GAAKM,EAAmB,IACvE3pB,EAAcuoB,UAAUa,wBACzBppB,EAAcuoB,UAAUa,sBAAwB,GAEpDppB,EAAcuoB,UAAUa,sBAAwB,EAAIA,IC/E5D,GACI,CAAC5E,EAAA,EAAkBG,YAAcsB,IAC7BA,EAAc5oB,aAAe,I,0BCArC,SACI,CAACmnB,EAAA,EAAkBI,kBAAoBqB,IACnC,MAAM,oBAAE2B,EAAmB,aAAEvqB,EAAY,SAAEmC,EAAQ,yBAAE6mB,EAAwB,eAAEuD,EAAc,KAAEvU,GAAU4Q,EACzG,GAAuB,gDAAnB2D,GACiB,OAAjBvsB,EACA,OAEJ,MAAMwsB,EAAgB,IAAI,IACpB7K,EAAe3J,GAAM2J,cAAgBqH,EAC3C,IAAKwD,EAAc1D,WAAW3mB,EAAUwf,EAAc,CAClD4I,sBACAvqB,iBAEA,OAEJwsB,EAAcC,yBACdD,EAAcE,wBACdF,EAAcG,wBACd,MAAMC,EAAgBjL,EAAasH,2BAC9B2D,IAGL,IAAA5Q,iCAAgC4M,EAActqB,eAAgBsuB,EAAerC,K,gDCpBrF,SACI,CAACpD,EAAA,EAAkBY,SAAU,SAAUa,GACnC,MAAM,oBAAE2B,EAAmB,cAAE5nB,EAAa,eAAEV,GAAmB2mB,EAC/D,IAAK2B,IAAwB5nB,EACzB,OAEJjB,KAAKwnB,qBAAqBjnB,EAAgB2mB,GAC1C,MAAMiE,EAAUnrB,KAAKinB,KAAK1mB,EAAgB2mB,GAI1C,OAHIiE,GACAnrB,KAAKorB,mBAAmB7qB,EAAgB2mB,GAErCiE,CACX,EACA,CAAC1F,EAAA,EAAkBG,YAAcsB,IAC7B,MAAM,aAAE5oB,EAAY,aAAE+sB,EAAY,oBAAExC,GAAwB3B,EAE5D,GADAA,EAAc/E,UAAW,EACE,MAAvB0G,GAA+C,MAAhBvqB,EAC/B,OAEJ,MAAMgtB,GAAc,EAAA9Q,EAAA,GAA+B0M,EAActqB,gBACjE0uB,GAAa5S,QAASnb,KAClB,IAAAguB,sBAAqBhuB,EAAY2pB,EAActqB,eAAgBisB,EAAqBwC,KAExFnE,EAAc/E,UAAW,GAE7B,CAACsD,EAAA,EAAkBS,eAAiBgB,IAChC,MAAM,oBAAE2B,EAAmB,yBAAEvB,EAAwB,KAAEhR,EAAI,aAAEhY,EAAY,uBAAE0qB,GAA4B9B,GAAiB,CAAC,GACnH,eAAEsE,GAAmBxC,GAA0B,CAAC,EAChDyC,EAAenV,EAcrBgR,EAAyB5O,QAbR,EAAG5O,YAChB,MAAM4hB,EAAWpE,EAAyBrF,WAAWnY,GACjD0hB,GAAgBjsB,OAAS,EACrBisB,EAAehsB,SAASsK,IACxB2hB,EAAaxL,aAAa0L,WAAW7hB,EAAO,GAI5C4hB,IAAa7C,GACb4C,EAAaxL,aAAa0L,WAAW7hB,EAAOxL,MAKxD,EAAAgc,EAAA,GAAgC4M,EAActqB,eAAgB0qB,EAAyBC,2BAA4BjpB,GACnH4oB,EAAc8B,uBAAuBwC,eAAiB,IAE1D,CAAC/F,EAAA,EAAkBU,eAAiBe,IAC3BA,GAGL,EAAAle,UAAA,+BAAyC4iB,OAAQtV,IAC7C,MAAMmV,EAAenV,EACrB,IAAKmV,GAAcxL,aACf,OAAO,EAEX,MAAM,yBAAEqH,GAA6BmE,EACrC,IAAII,GAAyB,EAO7B,OADAvE,EAAyB5O,QALR,EAAGiQ,YACZA,IAAUzB,EAAc2B,sBACxBgD,GAAyB,KAI1BA,MCnEnB,GACI,CAACpG,EAAA,EAAkBK,MAAQoB,IACvB,MAAM,eAAE4E,EAAc,sBAAE5D,EAAqB,yBAAEZ,EAAwB,cAAEgB,EAAa,UAAEQ,GAAe5B,EACjG6E,EAAoBzD,EAAc0D,sBAAsB9E,IACxD,SAAE+E,GAAa3D,EACf5I,EAAWqM,EACV9vB,IACC,MAAM,MAAE0sB,EAAK,MAAE7e,GAAU7N,GACrB6vB,EAAetsB,SAASmpB,IAAWoD,EAAkBjiB,IAGzDmiB,EAAS/E,EAAejrB,IAEzBA,GAASgwB,EAAS/E,EAAejrB,GACxCqrB,EAAyB5O,QAAQgH,EAAU,CACvCS,UAAW+H,EACXE,WAAYlB,EAAckB,WAC1BiB,UAAWnC,EAAcmB,sBAE7Bf,EAAyB4E,SAASpD,KClB1C,SACI,CAACrD,EAAA,EAAkBW,mBAAoB,CAACc,GAAiByB,QAAO7e,YAC5D,MAAM,eAAEgiB,EAAc,oBAAEjD,EAAmB,KAAEvS,EAAI,yBAAEgR,EAAwB,uBAAE0B,EAAsB,aAAE1qB,GAAkB4oB,EACjHoC,EAAgBhC,EAAyBrF,WAAWnY,GAC1D,IAAIgiB,EAAetsB,SAASmpB,KAGvBK,GAA0BM,IAAkBhrB,KAGJ,IAAzC0qB,GAAwB1qB,cACxBgrB,IAAkBhrB,GAGtB,GAA6C,OAAzC0qB,GAAwB1qB,aAA5B,CAIA,IAAKuqB,EAAqB,CACtB,IAAIsD,EAAkB7tB,EAKtB,OAJI0qB,IACAmD,EAAkBnD,EAAuB1qB,mBAE7CgY,EAAK2J,aAAa0L,WAAW7hB,EAAOqiB,EAExC,EC3BD,UAAqC,cAAEjF,EAAa,cAAEoC,EAAa,MAAExf,IACxE,MAAM,oBAAE+e,EAAmB,KAAEvS,EAAI,uBAAE0S,EAAsB,eAAEoD,EAAc,aAAE9tB,GAAkB4oB,GACvF,gBAAEgC,EAAe,gBAAED,EAAiB3qB,aAAc+tB,GAAwBrD,EAChF,GAA2B,IAAvBqD,GAA4BpD,GAAmBC,EAAiB,CAChE,GAAII,IAAkBhrB,EAClB,OAEJ,GAAI8tB,EACA,OAEJ,OAAI9C,IAAkBT,OAClBvS,EAAK2J,aAAa0L,WAAW7hB,EAAO,QAGxC,CACJ,CACA,GAA2B,IAAvBuiB,GAA4BpD,IAAoBC,EAAiB,CACjE,GAAsB,IAAlBI,GAAuBA,IAAkBhrB,EACzC,OAIJ,OAFAgY,EAAK2J,aAAa0L,WAAW7hB,EAAO+e,QACpCG,EAAuBwC,eAAezmB,KAAK+E,EAE/C,CACA,GAA2B,IAAvBuiB,IAA6BpD,GAAmBC,EAAiB,CACjE,GAAII,IAAkBhrB,EAClB,OAEJ,GAAI8tB,EACA,OAEJ,OAAI9C,IAAkBT,OAClBvS,EAAK2J,aAAa0L,WAAW7hB,EAAO,QAGxC,CACJ,CACA,GAA2B,IAAvBuiB,IAA6BpD,IAAoBC,EAAiB,CAClE,GAAII,IAAkBhrB,EAClB,OAEJ,OAAIgrB,IAAkBT,OAClBvS,EAAK2J,aAAa0L,WAAW7hB,EAAO+e,QAGxC,CACJ,CACA,GAAIwD,IAAuBxD,GACvBI,GACAC,EAFJ,CAGI,GAAII,IAAkBhrB,EAClB,OAEJgY,EAAK2J,aAAa0L,WAAW7hB,EAAO+e,EAExC,MACA,GAAIwD,IAAuBxD,GACtBI,IACDC,EAOJ,GAAImD,IAAuB/tB,GACvB2qB,GACAC,EAFJ,CAGI,GAAII,IAAkBhrB,EAClB,OAEJgY,EAAK2J,aAAa0L,WAAW7hB,EAAO+e,EAExC,MACA,GAAIwD,IAAuB/tB,IACvB2qB,GACCC,OAFL,CAGI,GAAII,IAAkBhrB,EAClB,OAEJgY,EAAK2J,aAAa0L,WAAW7hB,EAAO+e,EAExC,KA1BA,CAGI,GAAIS,IAAkBhrB,EAClB,OAEJgY,EAAK2J,aAAa0L,WAAW7hB,EAAO+e,EAExC,CAmBJ,CDvDQyD,CAA4B,CACxBpF,gBACAoC,gBACAxf,SAZJ,MAFIwM,EAAK2J,aAAa0L,WAAW7hB,EAAO+e,GAAuBvqB,KEfvE,GACI,CAACmnB,EAAA,EAAkBM,qBAAuBmB,IACtC,MAAM,kBAAEe,EAAiB,aAAE3pB,EAAY,cAAE2C,GAAkBimB,EAC3D,GAAKjmB,GAAkB3C,EAGvB,OAAQwL,IACJ,MAAMyiB,EAAatE,EAAkBhG,WAAWnY,GAC1CqgB,EAAOrI,MAAMsI,QAAQmC,GACrB,YAAYA,GACZA,GACA,UAAE/C,GAAcvoB,GAAiB,CAAC,EACxC,OAAKuoB,GAAWE,OAAOnqB,QAGhBiqB,EAAUE,MAAM,IAAMS,GAAQA,GAAQX,EAAUE,MAAM,M,eCfzE,SACI,CAACjE,EAAA,EAAkBiB,eAAgB,SAAUnmB,EAAgB2mB,EAAetf,GACxE,MAAM,QAAE4kB,GAAY5kB,GACd,eAAEhL,EAAc,SAAE6D,GAAaymB,GACrC,EAAAuF,EAAA,GAAc,CACV7vB,iBACA8vB,eAAgBF,GAExB,G,0BCCJ,SACIG,sBAAqB,EACrBC,iBAAgB,EAChBC,MAAK,EACL/B,cAAa,EACbK,QAAO,EACP2B,WAAU,EACVb,SAAQ,EACRzC,UAAS,EACTuD,mBAAkB,EAClBC,0CAAyC,IACzCC,mCAAkC,I,wECnBtC,MACMC,EADwB,IAAI,IAAc,cAAe,IAAaL,SAAU,KAAgBlG,cACtDmB,gB,uECDhD,MACMqF,EADwB,IAAI,IAAc,cAAe,IAAaN,SAAU,KAAgBlG,cACtDmB,gB,8ICEhD,MAAM,sBAAEsF,GAA0B,YAE5BC,EAAoB,CACtB,CAAC,IAAkBzH,YAAcsB,IAC7B,MAAM,OAAEpjB,EAAM,SAAErD,EAAQ,sBAAEynB,GAA0BhB,EACpD,IAAKpjB,EACD,OAEJ,MAAMkM,EAAS,cACXlM,EAAOvE,QAAU,GACjB,SAASyQ,EAAQlM,EAAO,GAAIA,EAAO,IACnC,WAAWkM,EAAQA,EAAQ,KAG3B,UAAUA,EAAQlM,EAAO,IAE7BojB,EAAciB,YAAcnY,EAC5BkX,EAAc4B,UAAYsE,EAAsBlF,EAAuBlY,GACvE,MAAMsd,GAAa,OAAgCxpB,EAAOuE,MAAM,EAAG,GAAI6f,EAAuBznB,GACxF8sB,EAAoBzpB,EAAOlD,IAAK4sB,GAAM/sB,EAASI,cAAc2sB,IAE7DC,GADU,QAAuCF,GACxB3sB,IAAK8sB,GAAWjtB,EAASoC,cAAc6qB,IAChEC,EAAe7pB,EAAOvE,QAAU,EAAI,cAAcuE,EAAO,GAAIA,EAAO,IAAM,OAAIxC,EAC9EssB,EAAgB1G,EAAc2G,mBAChC3G,EAAc2G,kBAAkBtuB,OAAS,EACvC2nB,EAAc2G,kBACd,CAAC3G,EAAciB,aACf2F,EAAaR,EAAWjE,UACxB0E,EAAgB7G,EAAc4B,UAkC9BkF,EAjCkBJ,EAAcxvB,OAAO,CAACC,EAAK4vB,KAC/C,IAAKA,EACD,OAAO5vB,EAEX,MAAM6vB,EAAsBd,EAAsBlF,EAAuB+F,GACnEE,EAAW,CACbD,EAAoB,GAAKH,EAAc,GACvCG,EAAoB,GAAKH,EAAc,GACvCG,EAAoB,GAAKH,EAAc,IAErCK,EAAmB,CACrB,CAACN,EAAW,GAAG,GAAKK,EAAS,GAAIL,EAAW,GAAG,GAAKK,EAAS,IAC7D,CAACL,EAAW,GAAG,GAAKK,EAAS,GAAIL,EAAW,GAAG,GAAKK,EAAS,IAC7D,CAACL,EAAW,GAAG,GAAKK,EAAS,GAAIL,EAAW,GAAG,GAAKK,EAAS,KAEjE,OAAK9vB,EAGE,CACH,CACI2E,KAAKoH,IAAI/L,EAAI,GAAG,GAAI+vB,EAAiB,GAAG,IACxCprB,KAAKmG,IAAI9K,EAAI,GAAG,GAAI+vB,EAAiB,GAAG,KAE5C,CACIprB,KAAKoH,IAAI/L,EAAI,GAAG,GAAI+vB,EAAiB,GAAG,IACxCprB,KAAKmG,IAAI9K,EAAI,GAAG,GAAI+vB,EAAiB,GAAG,KAE5C,CACIprB,KAAKoH,IAAI/L,EAAI,GAAG,GAAI+vB,EAAiB,GAAG,IACxCprB,KAAKmG,IAAI9K,EAAI,GAAG,GAAI+vB,EAAiB,GAAG,MAbrCA,GAgBZ,OACoCd,EAAWjE,UAClD,GAAInB,EAAuB,CACvB,MAAMhJ,EAAagJ,EAAsBxH,gBACzCwG,EAAcmB,oBAAsB,CAChC,CACIrlB,KAAKmG,IAAI,EAAGnG,KAAKoH,IAAI4jB,EAAY,GAAG,GAAI9O,EAAW,GAAK,IACxDlc,KAAKmG,IAAI,EAAGnG,KAAKoH,IAAI4jB,EAAY,GAAG,GAAI9O,EAAW,GAAK,KAE5D,CACIlc,KAAKmG,IAAI,EAAGnG,KAAKoH,IAAI4jB,EAAY,GAAG,GAAI9O,EAAW,GAAK,IACxDlc,KAAKmG,IAAI,EAAGnG,KAAKoH,IAAI4jB,EAAY,GAAG,GAAI9O,EAAW,GAAK,KAE5D,CACIlc,KAAKmG,IAAI,EAAGnG,KAAKoH,IAAI4jB,EAAY,GAAG,GAAI9O,EAAW,GAAK,IACxDlc,KAAKmG,IAAI,EAAGnG,KAAKoH,IAAI4jB,EAAY,GAAG,GAAI9O,EAAW,GAAK,KAGpE,MAEIgI,EAAcmB,oBAAsB2F,EAExC9G,EAAckB,YAAa,QAAqBqF,EAAgB,CAC5DI,kBAAmB3G,EAAc2G,kBACjC3F,wBACAjZ,OAAQ0e,MAIdU,EAAkB,IAAI,IAAc,SAAU,IAAavB,WAAY,IAAab,SAAUoB,EAAmB,IAAaV,sBAAuB,IAAaxB,QAAS,IAAa4B,mBAAoB,IAAaC,2CACzNsB,EAAmBD,EAAgBvG,iBACnCyG,EAA4B,IAAI,IAAc,qBAAsBF,EAAgB1H,aAAc,IAAaiG,iBAAkB,IAAapD,UAAW,IAAawD,0CAA2C,IAAaC,oCAC9NuB,EAAmC,IAAI,IAAc,qBAAsBH,EAAgB1H,aAAc,IAAaiG,iBAAkB,IAAapD,UAAW,IAAasB,cAAe,IAAakC,0CAA2C,IAAaC,oCACjQwB,EAAwBF,EAA0BzG,iBAClD4G,EAA8BF,EAAiC1G,gB,iCCrGrE,MAAM6G,EACF,WAAAvd,GACA,CACA,yBAAOwd,CAAmBC,EAAUC,GAChC,MAAM,KAAE7yB,GAAS4yB,GACX,iBAAEE,EAAgB,yBAAEC,GAA6B/yB,EAAKC,YAC5D,OAAO6yB,EAAiBnuB,IAAI,CAACmS,EAAOjJ,KAChC,MAAMmlB,EAYlB,SAAsBnrB,GAClB,MAAMorB,EAAgB,IACfprB,EAAO,MACPA,EAAO,MACPA,EAAO,MACPA,EAAO,IAGRqrB,EADcD,EAAcE,OACWxuB,IAAKmS,GACvCA,EAAMsc,QAAQ,IAEzB,OAAOF,CACX,CAxBgC7N,CAAavO,GAC3Buc,EAwBlB,SAAiC5b,EAASob,GACtC,MAAMS,EAAYT,EAAiBnP,IAAI,kBAAmBjM,GAC1D,MAAO,CACH8b,sBAAuBD,EAAUE,YACjCC,yBAA0BH,EAAUI,eAE5C,CA9ByCC,CAAwBZ,EAAyBllB,GAAQglB,GACtF,MAAO,CACHe,sBAAuBZ,EAAY1vB,OAAS,EAC5C+vB,uBACAQ,qBAAsB,gBACtBb,gBAGZ,EAEJN,EAA8B3vB,SAAW,gCAqBzC,S,kDCtCA,MAAM+wB,EAA+B,wCACtB,SAASC,EAAqBC,EAAcC,EAAe,IACtE,MAAM,SAAEzvB,EAAQ,UAAE0vB,EAAS,WAAEp0B,GAAek0B,EACtCG,EAAqB,IAAI1T,KACzB,SAAE1d,EAAQ,iBAAEqxB,GAAqBt0B,EAAWiV,SAC5Csf,EAAeD,GAAoBrxB,EACnC+Y,IAAe,IAAAC,gBAAesY,EAAc7vB,EAASL,UAAY,IAAIlB,OAAQnD,IAAgBA,EAAWiV,SAASqf,kBACnHt0B,EAAWiV,SAASqf,mBAAqBC,GAC7C,GAAIA,IAAiBP,EAA8B,CAC/C,MAAMQ,GAAsB,IAAAvY,gBAAe+X,EAA8BtvB,EAASL,SAC9EmwB,GAAqBhxB,QACrBgxB,EAAoB7X,QAAS3c,IACzB,MAAM,SAAEiV,GAAajV,EACjBiV,EAASqf,mBAAqBC,GAC9Btf,EAASqf,mBAAqBrf,EAAShS,UACvC+Y,EAAYhT,KAAKhJ,IAIjC,CACA,IAAKgc,GAAaxY,OACd,OAAO6wB,EAEX,IAAK,IAAI9wB,EAAI,EAAGA,EAAI6wB,EAAUK,eAAgBlxB,IAAK,CAC/C,MAAMmxB,EAAmB1Y,EAAY7Y,OAAQiR,GAAMA,EAAEa,SAAS0f,aAAepxB,GAC7E,IAAKmxB,GAAkBlxB,OACnB,SAEJ,MAAMoxB,EAAkCF,EAAiBvxB,OAAQ0xB,GACtDV,EAAaW,MAAO1gB,IACvB,MAAM2gB,EAAS3gB,EAAE4gB,UACX5gB,EAAE4gB,UAAUH,GACZA,EACAjI,EAAQmI,IAAS3gB,EAAE0X,KACzB,OAAI/F,MAAMsI,QAAQzB,GACPA,EAAMkI,MAAM,CAACG,EAAMlnB,IAAUknB,IAAS7gB,EAAEwY,MAAM7e,IAElD6e,IAAUxY,EAAEwY,SAGvBgI,EAAgCpxB,QAChC6wB,EAAmB9S,IAAIhe,EAAGqxB,EAElC,CACA,OAAOP,CACX,C,kDC7Ce,SAASa,EAA+BhB,EAAcC,GACjE,MAAMO,GAAmB,OAAqBR,EAAcC,GACtDgB,EAA6B,GACnC,IAAKT,GAAkBjU,KACnB,OAAO0U,EAEX,IAAK,MAAMnZ,KAAe0Y,EAAiBhM,SACvC1M,EAAYW,QAAS3c,IACjBm1B,EAA2BnsB,KAAKhJ,KAGxC,OAAOm1B,CACX,C,4DCZe,SAASC,EAAuBtxB,EAAUsP,EAAciiB,GACnE,MAAMr1B,EAAa,sBAAkB,CACjCE,KAAM,CAAC,EACP+U,SAAU,CAAC,GACZogB,GA+BH,OA9BAnzB,OAAOyX,OAAO3Z,EAAY,CACtBmW,aAAa,EACb/K,aAAa,EACbjD,eAAe,EACfzJ,mBAAe6G,EACfpF,YAAa,CAAC,EACdm1B,oBAAqB,GACrBziB,yBAAqBtN,IAEzBrD,OAAOyX,OAAO3Z,EAAWE,KAAM,CAC3BG,QAAS,CACL0H,OAAQqL,EAAarL,QAAUqL,GAAgB,GAC/CmiB,qBAAsBniB,EAAaoiB,QACnCjlB,kBAAmB,KACnBjQ,QAAS,CACLyK,UAAU,EACVD,cAAe,CAAC,EAAG,EAAG,GACtB4L,iBAAkB,CACdE,QAAS,CAAC,EAAG,EAAG,GAChBC,SAAU,CAAC,EAAG,EAAG,GACjBC,WAAY,CAAC,EAAG,EAAG,GACnBC,YAAa,CAAC,EAAG,EAAG,MAIhCnS,QAAS,IACFywB,EAAmBn1B,KAAK0E,QAC3Bd,cAGD9D,CACX,C,eCkBA,SAASy1B,EAAyBC,EAAmBf,GACjD,MAAM3Y,EAAc0Z,EAAkB9R,IAAI+Q,GAC1C,OAAS3Y,GAAaxY,QACM,IAAvBwY,EAAYxY,QAAgBwY,EAAY,GAAG7T,aACpD,CACA,SAASwtB,EAAyBC,EAAaC,EAAmBC,GAC9D,MAAOC,GAAcH,EACrBC,EAAkBE,KAAgB,CAC9BC,KAAMJ,EACNK,KAAM,IAEVJ,EAAkBE,GAAYE,KAAKjtB,KAAK8sB,EAC5C,CACA,SAASI,EAAiBvB,EAAYwB,EAAYT,GAC9C,MAAMU,EAAiB,GACvB,IAAIC,GAAiB,EACrB,IAAK,IAAI9yB,EAAIoxB,EAAa,EAAGpxB,GAAK4yB,EAAW,GAAI5yB,IAAK,CAClD,MAAMyY,EAAc0Z,EAAkB9R,IAAIrgB,GAC1C,GAAIyY,GAAaxY,OAAQ,CACrB,GAAIwY,EAAY,GAAG7T,cACf,SAEA6T,EAAYxY,OAAS,IACrB6yB,GAAiB,GAErBD,EAAeptB,KAAKzF,GACpB,KACJ,CACJ,CACA,GAAK8yB,GAAmBD,EAAe5yB,OAAvC,CAGA,IAAK,IAAID,EAAIoxB,EAAa,EAAGpxB,GAAK4yB,EAAW,GAAI5yB,IAAK,CAClD,MAAMyY,EAAc0Z,EAAkB9R,IAAIrgB,GAC1C,GAAIyY,GAAaxY,OAAQ,CACrB,GAAIwY,EAAY,GAAG7T,cACf,SAEA6T,EAAYxY,OAAS,IACrB6yB,GAAiB,GAErBD,EAAeptB,KAAKzF,GACpB,KACJ,CACJ,CACA,GAAK8yB,KAAkBD,EAAe5yB,OAAS,GAG/C,OAAO4yB,CAjBP,CAkBJ,CACA,QAxGA,SAAyCtD,EAAUoB,GAC/C,MAAMwB,GAAoB,EAAAzB,EAAA,GAAqBC,EAAc,CACzD,CACIpI,IAAK,mBACLc,MAAOsH,EAAa3X,oBAGtB+Z,EAqBV,SAA+BZ,GAC3B,IAAItmB,EAAQ6e,IACR5e,GAAQ4e,IACRsI,GAAQ,EACZ,IAAK,MAAO5B,EAAY3Y,KAAgB0Z,EAAkBvzB,UAClD6Z,EAAYxY,SACZ4L,EAAQnI,KAAKoH,IAAIsmB,EAAYvlB,GAC7BC,EAAOpI,KAAKmG,IAAIunB,EAAYtlB,GAC5BknB,GAAQ,GAGhB,IAAKA,EACD,OAEJ,MAAO,CAACnnB,EAAOC,EACnB,CApC+BmnB,CAAsBd,GACjD,IAAKY,EAED,YADAlc,QAAQC,KAAK,sCAAuCqb,GAGxD,MAAMe,EAgCV,SAAqCf,EAAmBh3B,GACpD,IAAK,MAAOi2B,EAAY3Y,KAAgB0Z,EACpC,IAAK,IAAIgB,EAAI,EAAGA,EAAI1a,EAAYxY,OAAQkzB,IACpC,GAAI1a,EAAY0a,GAAGh4B,gBAAkBA,EACjC,OAAOi2B,EAInB,MACJ,CAzCwBgC,CAA4BjB,EAAmB5C,EAASp0B,eACtEm3B,EAAoB,GAC1B,IAAK,IAAItyB,EAAI+yB,EAAmB,GAAK,EAAG/yB,EAAI+yB,EAAmB,GAAI/yB,IAC/D,GAAIkyB,EAAyBC,EAAmBnyB,GAAI,CAChD,MAAMqyB,EAAcM,EAAiB3yB,EAAG+yB,EAAoBZ,GACxDE,IAAc,KAAOa,GACrBb,IAAc,KAAOa,GACrBd,EAAyBC,EAAaC,EAAmBtyB,EAEjE,CAEJ,MAAO,CACHmyB,oBACAG,oBAER,E,0BC1BA,MAAM,cAAElhB,GAAkB,EAAA1H,UACX,SAAS2pB,EAAc9yB,EAAU+yB,EAAc,IAC1D,MAAMx2B,EAAUsU,EAAc0E,QAAQwd,GACtCx2B,EAAQm1B,QAAU,GAClB,MAAQA,QAASsB,GAAez2B,GAC1B,OAAEmD,EAAQgyB,QAASuB,EAAe,IAAOjzB,EAE/C,GAAIN,EAASsK,GACT,OAAOhK,EAASkzB,UAAUH,GAE9B,MAAMI,EAAWhwB,KAAKiwB,MAAMjwB,KAAKmG,IAAK,EAAI5J,EAAUqzB,EAAa/oB,KACjEipB,EAAapa,QAAQ,IAAMma,EAAW9tB,KAAK2L,EAAc0E,QAAQwd,KACjE,MAAMM,EAwCH,SAAyBrzB,EAAUgK,EAAW,GACjD,MAAM,OAAEtK,GAAWM,EACbszB,EAAW,cACXC,EAAW,cACXF,EAAY,IAAI3S,aAAahhB,GACnC,IAAK,IAAID,EAAI,EAAGA,EAAIC,EAAQD,IAAK,CAC7B,MAAMyT,EAAQlT,EAASwzB,SAAS/zB,GAC1Bg0B,EAAYzzB,EAASwzB,SAAS/zB,EAAIuK,GAClC0pB,EAAY1zB,EAASwzB,UAAU/zB,EAAIuK,GAAYtK,GACrD,SAAS4zB,EAAUpgB,EAAOugB,GAC1B,SAASF,EAAUG,EAAWxgB,GAC9B,MAAMygB,EAAM,SAASL,EAAUC,IAAa,SAASD,GAAY,SAASC,IAC1EF,EAAU5zB,GAAKk0B,CACnB,CACA,OAAON,CACX,CAvDsBO,CAAgB5zB,EANjB,GAOX6zB,EAuDV,SAA4BR,EAAWN,GACnC,MAAM,IAAEzpB,EAAG,UAAEwqB,GAkEjB,SAAkBT,GACd,MAAM,OAAE3zB,GAAW2zB,EACnB,IAAIU,EAAM,EACNxpB,EAAM4f,IACN7gB,GAAO6gB,IACP6J,EAAQ,EACZ,IAAK,IAAIv0B,EAAI,EAAGA,EAAIC,EAAQD,IAAK,CAC7B,MAAMk0B,EAAMN,EAAU5zB,GACtBs0B,GAAOJ,EACPppB,EAAMpH,KAAKoH,IAAIA,EAAKopB,GACpBrqB,EAAMnG,KAAKmG,IAAIA,EAAKqqB,EACxB,CACA,MAAMM,EAAOF,EAAMr0B,EACnB,IAAK,IAAID,EAAI,EAAGA,EAAIC,EAAQD,IAAK,CAC7B,MAAMy0B,EAAYb,EAAU5zB,GAAKw0B,EACjCD,GAASE,EAAYA,CACzB,CACA,MAAO,CACHD,OACA3qB,MACAiB,MACAypB,QACAF,UAAW3wB,KAAK8J,KAAK+mB,EAAQt0B,GAErC,CA1F+By0B,CAASd,IAC9B,OAAE3zB,GAAW2zB,EACnB,GAAIS,EAAY,KAAQp0B,EAAuB,EAAdqzB,EAC7B,MAAO,GAEX,MAAMqB,EAAa,GACnB,IACIC,EADAnC,EAAO,KAEPoC,EAAW,EACf,IAAK,IAAI70B,EAAI,EAAGA,EAAIC,EAAQD,IAAK,CAC7B,MAAMk0B,EAAMN,EAAU5zB,GAClBk0B,EAAMrqB,EAAMwqB,EACR5B,GACAA,EAAK,GAAKzyB,EACNk0B,EAAMU,IACNA,EAAWV,EACXW,EAAW70B,GAEfyyB,EAAK,GAAKoC,IAGVD,EAAWV,EACXW,EAAW70B,EACXyyB,EAAO,CAACzyB,EAAGA,EAAGA,IAIdyyB,IACAkC,EAAWlvB,KAAKgtB,GAChBA,EAAO,KAGnB,CACIA,IACyB,IAArBkC,EAAW,GAAG,GACdA,EAAW,GAAG,GAAKlC,EAAK,IAGxBA,EAAK,GAAKoC,EACVpC,EAAK,GAAKxyB,EAAS,EACnB00B,EAAWlvB,KAAKgtB,KAGxB,OAAOkC,CACX,CApG2BG,CAAmBlB,EAAWN,GAC/CpG,EAAU,GAChB,GAAIkH,GAAgBn0B,OAAS,EAAG,CAC5B,IAAI80B,GAAc,EAClB,MAAMC,EAAgBtB,EAAW,EACjCU,EAAehb,QAAS6b,IACpB,MAAOC,EAAO,CAAEC,GAAOF,EACjBG,EAAW1xB,KAAK2xB,MAAMH,EAAQC,GAAO,GACvCA,EAAMJ,EAAaC,IAGnBI,EAAWF,EAAQ,EAAIF,GACvBM,EAAYpI,EAAS6H,EAAYG,EAAOxB,EAAUzzB,GAClD80B,EAAaO,EAAYpI,EAASgI,EAAOE,EAAU1B,EAAUzzB,IAG7D80B,EAAaO,EAAYpI,EAAS6H,EAAYK,EAAU1B,EAAUzzB,GAElEk1B,EAAMJ,EAAaC,IACnBD,EAAaO,EAAYpI,EAAS6H,EAAYI,EAAKzB,EAAUzzB,OAGrE,MAAMs1B,EAAcrI,EAAQ,GACPsI,EAAWD,EAAct1B,EAAS80B,EAAY90B,GAChD,EAAI+0B,GACnBM,EAAYpI,EAAS6H,EAAYQ,EAAcP,EAAetB,EAAUzzB,EAEhF,KACK,CACD,MAAMyzB,EAAWhwB,KAAKiwB,MAAM1zB,EAASqzB,GACrCgC,EAAYpI,GAAU,EAAGjtB,EAASyzB,EAAUA,EAAUzzB,EAC1D,CAMA,OALAitB,EAAQ9T,QAAS5O,IACb,MAAMiJ,EAAQlT,EAASk1B,cAAcjrB,GACrC1N,EAAQ2I,KAAKgO,GACb+f,EAAapa,QAAQ,CAACsc,EAAQC,IAAoBpC,EAAWoC,GAAiBlwB,KAAKiwB,EAAO3B,SAASvpB,OAEhG1N,CACX,CA+DO,SAASw4B,EAAYpI,EAASgI,EAAOU,EAAQlC,EAAUzzB,GACtD21B,EAASV,IACTU,GAAU31B,GAEd,MAAMsK,EAAWqrB,EAASV,EACpBW,EAAQnyB,KAAK2xB,KAAK9qB,EAAWmpB,GACnC,GAAImC,GAAS,EAIT,OAHI3I,EAAQA,EAAQjtB,OAAS,KAAO21B,GAChC1I,EAAQznB,KAAK+vB,EAAWI,EAAQ31B,IAE7B21B,EAEX,IAAK,IAAI51B,EAAI,EAAGA,GAAK61B,EAAO71B,IAAK,CAC7B,MAAMwK,EAAQgrB,EAAWN,EAASl1B,EAAIuK,EAAYsrB,EAAO51B,GACzDitB,EAAQznB,KAAK+E,EACjB,CACA,OAAO0iB,EAAQA,EAAQjtB,OAAS,EACpC,CACA,SAASu1B,EAAWM,EAAG71B,GACnB,OAAQyD,KAAKqyB,MAAMD,GAAK71B,GAAUA,CACtC,C,eC/HA,MAAQmR,cAAa,GAAK,EAAA1H,UACpBssB,EAAK,GAkDX,SAASC,EAA4B/I,EAAS2F,EAAgBV,EAAmB+D,GAC7E,MAAMC,EAAchE,EAAkB9R,IAAIwS,EAAe,IAAI,GACvDuD,EAAcjE,EAAkB9R,IAAIwS,EAAe,IAAI,GACvDwD,EAAKC,EAAuBH,EAAYx5B,KAAK0E,QAAQd,UACrDg2B,EAAKD,EAAuBF,EAAYz5B,KAAK0E,QAAQd,WACrD,SAAEi2B,EAAQ,SAAEC,GA8FtB,SAA2CJ,EAAIE,GAC3C,MAAMG,EAAYC,EAAwBN,GACpCO,EAAYD,EAAwBJ,GACpCM,EAAcnzB,KAAKmG,IAAInG,KAAK2xB,KAAKqB,EAAUA,EAAUz2B,OAAS,GAAK+1B,GAAKtyB,KAAK2xB,KAAKuB,EAAUA,EAAU32B,OAAS,GAAK+1B,IACpHc,EAAgBC,EAA+BL,GAC/CM,EAAgBD,EAA+BH,GAC/CK,EAAYJ,EAAcN,EAAG1lB,EAAE5Q,OAC/Bi3B,EAAYL,EAAcR,EAAGxlB,EAAE5Q,OAC/Bk3B,EAAeC,EAAsBH,EAAWH,GAChDO,EAAeD,EAAsBF,EAAWF,GAChDM,EAAYC,EAAmBN,EAAY,EAAGZ,EAAGxlB,EAAE5Q,QACnDu3B,EAAYD,EAAmBL,EAAY,EAAGX,EAAG1lB,EAAE5Q,QACnDw3B,EAAmBC,EAAoBP,EAAcG,GACrDK,EAAmBD,EAAoBL,EAAcG,GACrDI,EAAMC,EAAwBxB,EAAIoB,GAClCK,EAAMD,EAAwBtB,EAAIoB,GAExC,OAgCJ,SAA0CC,EAAKE,GAC3C,MAAMC,EAAYH,EAAI/mB,EAAE5Q,OAClB+3B,EAAU,CACZC,aAAc,EACdC,sBAAuBxN,KAE3B,IAAK,IAAIuN,EAAe,EAAGA,EAAeF,EAAWE,IAAgB,CACjE,IAAIE,EAAOF,EACPC,EAAwB,EAC5B,IAAK,IAAIE,EAAY,EAAGA,EAAYL,EAAWK,IAC3CF,IACKN,EAAI/mB,EAAEsnB,GAAQL,EAAIjnB,EAAEunB,KAAe,GAC/BR,EAAI7mB,EAAEonB,GAAQL,EAAI/mB,EAAEqnB,KAAe,GACnCR,EAAIvW,EAAE8W,GAAQL,EAAIzW,EAAE+W,KAAe,EAC5CD,IACIA,IAASJ,IACTI,EAAO,GAGXD,EAAwBF,EAAQE,wBAChCF,EAAQE,sBAAwBA,EAChCF,EAAQC,aAAeA,EAE/B,CACA,MAAME,EAAOH,EAAQC,aACrBI,EAAoBT,EAAI/mB,EAAGsnB,GAC3BE,EAAoBT,EAAI7mB,EAAGonB,GAC3BE,EAAoBT,EAAIvW,EAAG8W,GAC3BE,EAAoBT,EAAIU,EAAGH,EAC/B,CA9DII,CAAiCX,EAAKE,GAG1C,SAAsCF,EAAKE,GACvC,MAAMtB,EAAW,CACb3lB,EAAG,GACHE,EAAG,GACHsQ,EAAG,GACHiX,EAAG,IAED7B,EAAW,CACb5lB,EAAG,GACHE,EAAG,GACHsQ,EAAG,GACHiX,EAAG,IAEP,IAAK,IAAIt4B,EAAI,EAAGA,EAAI43B,EAAI/mB,EAAE5Q,OAAQD,KAC1B43B,EAAIU,EAAEt4B,IAAM83B,EAAIQ,EAAEt4B,MAClBw2B,EAAS3lB,EAAEpL,KAAKmyB,EAAI/mB,EAAE7Q,IACtBw2B,EAASzlB,EAAEtL,KAAKmyB,EAAI7mB,EAAE/Q,IACtBw2B,EAASnV,EAAE5b,KAAKmyB,EAAIvW,EAAErhB,IACtBw2B,EAAS8B,EAAE7yB,KAAKmyB,EAAIU,EAAEt4B,IACtBy2B,EAAS5lB,EAAEpL,KAAKqyB,EAAIjnB,EAAE7Q,IACtBy2B,EAAS1lB,EAAEtL,KAAKqyB,EAAI/mB,EAAE/Q,IACtBy2B,EAASpV,EAAE5b,KAAKqyB,EAAIzW,EAAErhB,IACtBy2B,EAAS6B,EAAE7yB,KAAKqyB,EAAIQ,EAAEt4B,KAG9B,MAAO,CACHw2B,WACAC,WAER,CA/BW+B,CAA6BZ,EAAKE,EAC7C,CAhHmCW,CAAkCpC,EAAIE,GACrEC,EAASkC,OAAS7F,EAAe,GACjC4D,EAASiC,OAAS7F,EAAe,GACjC3F,EAAQ9T,QAAQ,SAAU5O,IAa9B,SAAqCgsB,EAAUC,EAAUrF,EAAYyB,EAAgBV,EAAmBwG,EAAgBzC,GACpH,MAAO1D,EAAYoG,GAAY/F,EACzBgG,GAAWzH,EAAaoB,IAAeoG,EAAWpG,GAClD2D,EAAchE,EAAkB9R,IAAImS,GAAY,GAChD4D,EAAcjE,EAAkB9R,IAAIuY,GAAU,GAC9CE,EAgDV,SAA0CC,EAAMC,EAAMH,EAASF,GAC3D,MAAMzL,EAAUyL,EAAiBI,EAAKT,EAAIU,EAAKV,EACzCjC,EAAK,EAAc4C,QAAQF,GAC3BxC,EAAK,EAAc0C,QAAQD,IAC3B,OAAE/4B,GAAWo2B,EACb6C,EAAU,EAAcpjB,QAAQ7V,GAChCk5B,EAAc,cACdC,EAAY,cACZC,EAAW,EAAcvjB,QAAQ7V,GACvCo5B,EAASX,OAASK,EAAKL,OACvB,MAAMY,EAAW,EAAcxjB,QAAQ7V,GACvCq5B,EAASZ,OAASM,EAAKN,OACvB,IAAK,IAAI14B,EAAI,EAAGA,EAAI+4B,EAAKloB,EAAE5Q,OAAQD,IAC/B,GAAIktB,EAAQltB,GAAI,CACZ,MAAMu5B,EAAUlD,EAAGtC,SAAS/zB,GACtBw5B,EAAUjD,EAAGxC,SAAS/zB,GAC5Bq5B,EAAS5zB,KAAK8zB,GACdD,EAAS7zB,KAAK+zB,GACd,SAASL,EAAaK,EAASD,GAC/BL,EAAQzzB,KAAK,iBAAiB2zB,EAAWG,EAASJ,EAAaN,GACnE,CAGJ,OADAK,EAAQjH,QAAU,CAACoH,EAAUC,GACtBJ,CACX,CAxEiCO,CAAiCjD,EAAUC,EAAUoC,EAASF,GACrFe,EAAoBb,EAAU,GAAMzC,EAAcD,EAClDtmB,EAAewjB,EAAcyF,GAC/B3G,EAAkBwH,IAAIvI,GAoC9B,SAAkC0H,EAAsBjpB,EAAcuhB,EAAYU,EAAoBoE,GAClG,MAAM0D,EAAoBC,EAAwB/H,EAAoBV,EAAY8E,GAC5E1xB,EAASs0B,EAAqBt0B,OAC9Bs1B,EAAyBjI,EAAuBrtB,EAAQqL,EAAc+pB,GAC5Ej7B,OAAOyX,OAAOwjB,EAAmB,CAC7BloB,SAAUooB,EAAuBpoB,SACjC/U,KAAMm9B,EAAuBn9B,MAErC,CA3CQo9B,CAAyBjB,EAAsBjpB,EAAcuhB,EAAYsI,EAAmBxD,GAMpG,SAAiC4C,EAAsBjpB,EAAcuhB,EAAYU,EAAoBoE,GACjG,MAAM1xB,EAASs0B,EAAqBt0B,QAC9B,SAAErD,GAAa+0B,EACf4D,EAAyBjI,EAAuBrtB,EAAQqL,EAAciiB,GACtEkI,EAAU74B,EAASwQ,iBAAiB,CAAEyf,eAC5C,IAAK4I,EACD,MAAM,IAAI7hB,MAAM,oBAAoBiZ,KAExCzyB,OAAOyX,OAAO0jB,EAAuBpoB,SAAUsoB,GAC/C,QAAsBnoB,cAAcioB,EAAwB34B,EAASL,SACrEgxB,EAAmBmI,0BAA0BH,EAAwBhI,GACrE,MAAM,oBAAExiB,GAAwBwiB,EAChC,GAAIxiB,EAAqB,CACrB,MACM4qB,EAAmBL,EADA,QAAsBljB,cAAcrH,GACM8hB,EAAY8E,IAC/E,IAAAiE,oBAAmBh5B,EAAU+4B,EAAkBJ,EACnD,CACJ,CApBQM,CAAwBtB,EAAsBjpB,EAAcuhB,EAAYsI,EAAmBxD,EAEnG,CA1BQmE,CAA4B7D,EAAUC,EAAUjsB,EAAOqoB,EAAgBV,EAAmBkE,EAAGxlB,EAAE5Q,OAASs2B,EAAG1lB,EAAE5Q,OAAQi2B,EACzH,EACJ,CA2CA,SAAS2D,EAAwB/H,EAAoBV,EAAY8E,GAC7D,MAAM,SAAE/0B,GAAa+0B,EACfzd,EAAc,QAAsBC,eAAeoZ,EAAmBpgB,SAAShS,SAAUyB,EAASL,SACxG,IAAK,IAAId,EAAI,EAAGA,EAAIyY,EAAYxY,OAAQD,IAAK,CACzC,MAAMvD,EAAagc,EAAYzY,GAC/B,GAAIvD,EAAWuc,mBAAqB8Y,EAAmB9Y,kBACnDvc,EAAWiV,SAAS0f,aAAeA,EACnC,OAAO30B,CAEf,CACJ,CAkHA,SAAS47B,EAAoBiC,EAAKzE,GAC9BA,GAASyE,EAAIr6B,OAASyD,KAAKiwB,MAAMkC,EAAQyE,EAAIr6B,QAC7C,MAAMs6B,EAAcD,EAAIpxB,OAAO,EAAG2sB,GAElC,OADAyE,EAAI70B,QAAQ80B,GACLD,CACX,CACA,SAASzC,EAAwB2C,EAAGC,GAChC,MAAMC,EAAK,CACP7pB,EAAG,GACHE,EAAG,GACHsQ,EAAG,GACHiX,EAAG,IAEP,IAAK,IAAIqC,EAAI,EAAGA,EAAIH,EAAE3pB,EAAE5Q,OAAS,EAAG06B,IAAK,CACrCD,EAAG7pB,EAAEpL,KAAK+0B,EAAE3pB,EAAE8pB,IACdD,EAAG3pB,EAAEtL,KAAK+0B,EAAEzpB,EAAE4pB,IACdD,EAAGrZ,EAAE5b,KAAK+0B,EAAEnZ,EAAEsZ,IACdD,EAAGpC,EAAE7yB,MAAK,GACV,MAAMm1B,GAAYJ,EAAE3pB,EAAE8pB,EAAI,GAAKH,EAAE3pB,EAAE8pB,KAAOF,EAAgBE,GAAK,GACzDE,GAAYL,EAAEzpB,EAAE4pB,EAAI,GAAKH,EAAEzpB,EAAE4pB,KAAOF,EAAgBE,GAAK,GACzDG,GAAYN,EAAEnZ,EAAEsZ,EAAI,GAAKH,EAAEnZ,EAAEsZ,KAAOF,EAAgBE,GAAK,GAC/D,IAAK,IAAI36B,EAAI,EAAGA,EAAIy6B,EAAgBE,GAAK,EAAG36B,IACxC06B,EAAG7pB,EAAEpL,KAAKi1B,EAAG7pB,EAAE6pB,EAAG7pB,EAAE5Q,OAAS,GAAK26B,GAClCF,EAAG3pB,EAAEtL,KAAKi1B,EAAG3pB,EAAE2pB,EAAG3pB,EAAE9Q,OAAS,GAAK46B,GAClCH,EAAGrZ,EAAE5b,KAAKi1B,EAAGrZ,EAAEqZ,EAAGrZ,EAAEphB,OAAS,GAAK66B,GAClCJ,EAAGpC,EAAE7yB,MAAK,EAElB,CACA,OAAOi1B,CACX,CACA,SAAShD,EAAoBqD,EAAaC,GACtC,MAAMvQ,EAAM,GACZ,IAAK,IAAIzqB,EAAI,EAAGA,EAAI+6B,EAAY96B,SAAUD,EACtCyqB,EAAIzqB,GAAKA,EAEbyqB,EAAIhgB,KAAK,SAAUC,EAAGC,GAClB,OAAOowB,EAAYrwB,GAAKqwB,EAAYpwB,IAAM,EAAI,CAClD,GACA,MAAMswB,EAAiB,GACvB,IAAK,IAAIj7B,EAAI,EAAGA,EAAIg7B,EAAS/6B,OAAQD,IACjCi7B,EAAex1B,KAAKu1B,EAASvQ,EAAIzqB,KAErC,MAAMk7B,EAAuBD,EAAen8B,OAAO,SAAUw7B,EAAKa,EAAcn7B,GAI5E,OAHIm7B,GACAb,EAAI70B,KAAKzF,GAENs6B,CACX,EAAG,IACGG,EAAkB,GACxB,IAAK,IAAIz6B,EAAI,EAAGA,EAAIk7B,EAAqBj7B,OAAS,EAAGD,IACjDy6B,EAAgBh1B,KAAKy1B,EAAqBl7B,EAAI,GAAKk7B,EAAqBl7B,IAE5E,OAAOy6B,CACX,CACA,SAASlD,EAAmB6D,EAAUC,GAClC,MAAML,EAAW,IAAIxY,MAAM4Y,EAAWC,GAGtC,OAFAL,EAASrT,MAAK,EAAO,EAAGyT,GACxBJ,EAASrT,MAAK,EAAMyT,EAAUA,EAAWC,GAClCL,CACX,CACA,SAAS5D,EAAsBkE,EAAUC,GACrC,MAAMC,EAAO,GAAKF,EAAW,GACvBG,EAAW,CAACD,GAClB,IAAK,IAAIx7B,EAAI,EAAGA,EAAIs7B,EAAW,EAAGt7B,IAC9By7B,EAASh2B,KAAKg2B,EAASA,EAASx7B,OAAS,GAAKu7B,GAElD,OAAOC,EAASC,OAAOH,EAC3B,CACA,SAASxE,EAA+B4E,GACpC,MAAMJ,EAAe,GACrB,IAAK,IAAIv7B,EAAI,EAAGA,EAAI27B,EAAS17B,OAAQD,IACjCu7B,EAAa91B,KAAKk2B,EAAS37B,GAAK27B,EAASA,EAAS17B,OAAS,IAE/D,OAAOs7B,CACX,CACA,SAAS5E,EAAwBt1B,GAC7B,MAAMu6B,EAAsB,CAAC,GAC7B,IAAK,IAAI57B,EAAI,EAAGA,EAAIqB,EAAQwP,EAAE5Q,OAAQD,IAAK,CACvC,MAAM67B,EAAkBn4B,KAAK8J,MAAMnM,EAAQwP,EAAE7Q,GAAKqB,EAAQwP,EAAE7Q,EAAI,KAAO,GAClEqB,EAAQ0P,EAAE/Q,GAAKqB,EAAQ0P,EAAE/Q,EAAI,KAAO,GACpCqB,EAAQggB,EAAErhB,GAAKqB,EAAQggB,EAAErhB,EAAI,KAAO,GACzC47B,EAAoBn2B,KAAKm2B,EAAoB57B,EAAI,GAAK67B,EAC1D,CACA,OAAOD,CACX,CACA,SAAStF,EAAuB9xB,GAC5B,MAAMg2B,EAAI,CACN3pB,EAAG,GACHE,EAAG,GACHsQ,EAAG,IAEP,IAAK,IAAIrhB,EAAI,EAAGA,EAAIwE,EAAOvE,OAAQD,IAC/Bw6B,EAAE3pB,EAAE7Q,GAAKwE,EAAOxE,GAAG,GACnBw6B,EAAEzpB,EAAE/Q,GAAKwE,EAAOxE,GAAG,GACnBw6B,EAAEnZ,EAAErhB,GAAKwE,EAAOxE,GAAG,GAKvB,OAHAw6B,EAAE3pB,EAAEpL,KAAK+0B,EAAE3pB,EAAE,IACb2pB,EAAEzpB,EAAEtL,KAAK+0B,EAAEzpB,EAAE,IACbypB,EAAEnZ,EAAE5b,KAAK+0B,EAAEnZ,EAAE,IACNmZ,CACX,CACA,QAxUA,SAAqB7J,GACjB,IAAKA,EAAal0B,WACd,OAEJ,MAAM,sBAAEq/B,EAAqB,WAAEr/B,GAAek0B,EAC9CoL,eAAe,KACX,IACQD,IACAr/B,EAAWq/B,uBAAwB,EACnCr/B,EAAWmI,eAAgB,GAW3C,SAA4B+rB,GACxB,MAAQl0B,WAAY8yB,GAAaoB,GC/BtB,SAAqCl0B,GAChD,MAAM,oBAAE6S,EAAmB,cAAEnU,GAAkBsB,EAC/C,IAAK6S,EACD,OAAO7S,EAAWuc,iBAEtB,MAAMkhB,EAAmB,QAAsBvjB,cAAcrH,IACvD,iBAAE0J,GAAqBkhB,EACvB1vB,EAAQ0vB,EAAiBnI,oBAAoBiK,QAAQ7gC,GAC3DsB,EAAWuc,iBAAmB,GAAGA,KAAoBxO,IAC9C/N,EAAWuc,gBACtB,CDsBIijB,CAA4B1M,GAC5B,MAAM,kBAAE4C,EAAiB,kBAAEG,GAAsB,EAAgC/C,EAAUoB,IAAiB,CAAC,EAC7G,IAAKwB,IAAsBG,EACvB,OAEJ,MAAM4D,EAAY,CACdx2B,SAAU6vB,EAAS7d,SAAShS,SAC5Bw8B,SAAU3M,EAAS7d,SAAShS,SAC5ByB,SAAUwvB,EAAaxvB,UAE3B,IAAK,IAAInB,EAAI,EAAGA,EAAIsyB,EAAkBryB,OAAQD,IACtCsyB,EAAkBtyB,IAClBi2B,EAA4B3D,EAAkBtyB,GAAG0yB,KAAMJ,EAAkBtyB,GAAGyyB,KAAMN,EAAmB+D,GAG7G,MAAM,GAAE5nB,EAAE,kBAAE6tB,EAAiB,QAAEr7B,GAAY6vB,EAAaxvB,SAClDi7B,EAAe,CACjB3/B,WAAY8yB,EACZzuB,UACA7C,WAAYqQ,EACZ6tB,qBAEA7J,EAAkBryB,UAClB,IAAAzC,cAAamzB,EAAaxvB,SAASL,QAAS,IAAWu7B,2CAA4CD,IACnG,IAAA5+B,cAAa,EAAAC,YAAa,IAAW4+B,2CAA4CD,GAEzF,CArCYE,CAAmB3L,EACvB,CACA,QACQmL,IACAr/B,EAAWmI,eAAgB,EAEnC,GAER,C,qEE5BA,MAAM,cAAEwM,GAAkB,EAAA1H,UAC1B,SAAS6yB,EAAsBC,GAC3B,MAAO,CACH3yB,IAAK,EAAE6gB,KACP5f,IAAK,CAAC4f,KACN4J,IAAK,CAAC,GACNuB,MAAO,EACP4G,OAAQ,KACRC,OAAQ,KACRC,OAAQ,KACRC,OAAQ,KACRC,QAAS,CAAC,GACVC,GAAI,CAAC,GACLC,GAAI,CAAC,GACLC,GAAI,CAAC,GACLC,UAAW,CAAC,IACZC,cAAeV,EAAiBprB,EAAc0E,QAAQ,MAAQ,KAC9DqnB,OAAQ,CAAC,EAAG,EAAG,GAEvB,CACA,SAASC,EAAmBznB,EAAO0nB,EAAUC,EAAW,KAAM1S,EAAW,MACjEpI,MAAMsI,QAAQuS,IACdA,EAASp9B,OAAS,GACG,IAArB0V,EAAM9L,IAAI5J,SACV0V,EAAM9L,IAAIpE,KAAKkQ,EAAM9L,IAAI,GAAI8L,EAAM9L,IAAI,IACvC8L,EAAM7K,IAAIrF,KAAKkQ,EAAM7K,IAAI,GAAI6K,EAAM7K,IAAI,IACvC6K,EAAM2e,IAAI7uB,KAAKkQ,EAAM2e,IAAI,GAAI3e,EAAM2e,IAAI,IACvC3e,EAAMknB,QAAQp3B,KAAK,EAAG,GACtBkQ,EAAMmnB,GAAGr3B,KAAKkQ,EAAMmnB,GAAG,GAAInnB,EAAMmnB,GAAG,IACpCnnB,EAAMonB,GAAGt3B,KAAKkQ,EAAMonB,GAAG,GAAIpnB,EAAMonB,GAAG,IACpCpnB,EAAMqnB,GAAGv3B,KAAKkQ,EAAMqnB,GAAG,GAAIrnB,EAAMqnB,GAAG,IACpCrnB,EAAMsnB,UAAUx3B,KAAK,GAAI,KAEzBkQ,GAAOunB,eAAiBI,GACxB3nB,EAAMunB,cAAcz3B,KAAK63B,GAE7B,MAAMC,EAAW/a,MAAMsI,QAAQuS,GAAYA,EAAW,CAACA,GACvD1nB,EAAMkgB,OAAS,EACXyH,IACA3nB,EAAMwnB,OAAO,IAAMG,EAAS,GAC5B3nB,EAAMwnB,OAAO,IAAMG,EAAS,GAC5B3nB,EAAMwnB,OAAO,IAAMG,EAAS,IAEhC3nB,EAAM9L,IAAIuP,QAAQ,CAACokB,EAAI/S,KACnB,MAAMpB,EAAQkU,EAAS9S,GACvB9U,EAAMsnB,UAAUxS,GAAKhlB,KAAK4jB,GAC1B,MAAMsR,EAAIhlB,EAAMkgB,MACV4H,EAAQpU,EAAQ1T,EAAMknB,QAAQpS,GAC9BiT,EAAUD,EAAQ9C,EAClBgD,EAAQF,EAAQC,GAAW/C,EAAI,GACrChlB,EAAM2e,IAAI7J,IAAQpB,EAClB1T,EAAMknB,QAAQpS,IAAQiT,EACtB/nB,EAAMqnB,GAAGvS,IACLkT,EAAQD,EAAUA,GAAW/C,EAAIA,EAAI,EAAIA,EAAI,GACzC,EAAI+C,EAAUA,EAAU/nB,EAAMmnB,GAAGrS,GACjC,EAAIiT,EAAU/nB,EAAMonB,GAAGtS,GAC/B9U,EAAMonB,GAAGtS,IAAQkT,EAAQD,GAAW/C,EAAI,GAAK,EAAI+C,EAAU/nB,EAAMmnB,GAAGrS,GACpE9U,EAAMmnB,GAAGrS,IAAQkT,EACbtU,EAAQ1T,EAAM7K,IAAI2f,KAClB9U,EAAM7K,IAAI2f,GAAOpB,EACL,IAARoB,IACA9U,EAAMgnB,OAAS/R,EAAW,IAAIA,GAAY,KAC1CjV,EAAMinB,OAASU,EAAW,IAAIA,GAAY,OAG9CjU,EAAQ1T,EAAM9L,IAAI4gB,KAClB9U,EAAM9L,IAAI4gB,GAAOpB,EACL,IAARoB,IACA9U,EAAM8mB,OAAS7R,EAAW,IAAIA,GAAY,KAC1CjV,EAAM+mB,OAASY,EAAW,IAAIA,GAAY,QAI1D,CAcA,SAASM,EAAmBjoB,EAAOkoB,GAC/B,MAAMrJ,EAAO7e,EAAM2e,IAAIhzB,IAAKgzB,GAAQA,EAAM3e,EAAMkgB,OAC1CiI,EAASnoB,EAAMmnB,GAAGx7B,IAAKy8B,GAAmBr6B,KAAK8J,KAAKuwB,EAAiBpoB,EAAMkgB,QAC3EnlB,EAASiF,EAAMwnB,OAAO77B,IAAKgzB,GAAQA,EAAM3e,EAAMkgB,OAC/CmI,EAAWroB,EAAMonB,GAAGz7B,IAAI,CAACy7B,EAAItS,KAC/B,MAAMwT,EAAWtoB,EAAMmnB,GAAGrS,GAAO9U,EAAMkgB,MACvC,OAAiB,IAAboI,EACO,EAEJlB,GAAMpnB,EAAMkgB,MAAQnyB,KAAKw6B,IAAID,EAAU,QAE5CE,EAAWxoB,EAAMqnB,GAAG17B,IAAI,CAAC07B,EAAIvS,KAC/B,MAAMwT,EAAWtoB,EAAMmnB,GAAGrS,GAAO9U,EAAMkgB,MACvC,OAAiB,IAAboI,EACO,EAEJjB,GAAMrnB,EAAMkgB,MAAQoI,EAAWA,GAAY,IAEhDG,EAASzoB,EAAMsnB,UAAU37B,IAAK6jB,GA/BxC,SAAyBA,GACrB,GAAsB,IAAlBA,EAAOllB,OACP,OAAO,EAEX,MAAMo+B,EAAS,IAAIlZ,GAAQ1a,KAAK,CAACC,EAAGC,IAAMD,EAAIC,GACxC2zB,EAAM56B,KAAKiwB,MAAM0K,EAAOp+B,OAAS,GACvC,OAAIo+B,EAAOp+B,OAAS,GAAM,GACdo+B,EAAOC,EAAM,GAAKD,EAAOC,IAAQ,EAGlCD,EAAOC,EAEtB,CAmBmDC,CAAgBpZ,IACzDqZ,EAAQ,CACV30B,IAAK,CACDyd,KAAM,MACNmX,MAAO,YACPpV,MAA4B,IAArB1T,EAAM9L,IAAI5J,OAAe0V,EAAM9L,IAAI,GAAK8L,EAAM9L,IACrDg0B,OACAjT,SAAUjV,EAAM8mB,OAAS,IAAI9mB,EAAM8mB,QAAU,KAC7Ca,SAAU3nB,EAAM+mB,OAAS,IAAI/mB,EAAM+mB,QAAU,MAEjD5xB,IAAK,CACDwc,KAAM,MACNmX,MAAO,YACPpV,MAA4B,IAArB1T,EAAM7K,IAAI7K,OAAe0V,EAAM7K,IAAI,GAAK6K,EAAM7K,IACrD+yB,OACAjT,SAAUjV,EAAMgnB,OAAS,IAAIhnB,EAAMgnB,QAAU,KAC7CW,SAAU3nB,EAAMinB,OAAS,IAAIjnB,EAAMinB,QAAU,MAEjDpI,KAAM,CACFlN,KAAM,OACNmX,MAAO,aACPpV,MAAuB,IAAhBmL,EAAKv0B,OAAeu0B,EAAK,GAAKA,EACrCqJ,QAEJC,OAAQ,CACJxW,KAAM,SACNmX,MAAO,qBACPpV,MAAyB,IAAlByU,EAAO79B,OAAe69B,EAAO,GAAKA,EACzCD,QAEJhI,MAAO,CACHvO,KAAM,QACNmX,MAAO,cACPpV,MAAO1T,EAAMkgB,MACbgI,KAAM,MAEVO,OAAQ,CACJ9W,KAAM,SACNmX,MAAO,SACPpV,MAAyB,IAAlB+U,EAAOn+B,OAAem+B,EAAO,GAAKA,EACzCP,QAEJG,SAAU,CACN1W,KAAM,WACNmX,MAAO,WACPpV,MAA2B,IAApB2U,EAAS/9B,OAAe+9B,EAAS,GAAKA,EAC7CH,KAAM,MAEVM,SAAU,CACN7W,KAAM,WACNmX,MAAO,WACPpV,MAA2B,IAApB8U,EAASl+B,OAAek+B,EAAS,GAAKA,EAC7CN,KAAM,MAEVnB,OAAQ,CACJpV,KAAM,SACNmX,MAAO,UACPpV,MAAO1T,EAAM+mB,OAASla,MAAMC,KAAK9M,EAAM+mB,QAAU,KACjDmB,KAAM,MAEVjB,OAAQ,CACJtV,KAAM,SACNmX,MAAO,UACPpV,MAAO1T,EAAMinB,OAASpa,MAAMC,KAAK9M,EAAMinB,QAAU,KACjDiB,KAAM,MAEVX,cAAevnB,EAAMunB,cACrBxsB,OAAQ,CACJ4W,KAAM,SACNmX,MAAO,SACPpV,MAAO3Y,EAAS,IAAIA,GAAU,KAC9BmtB,KAAM,MAEVxb,MAAO,IAEXmc,EAAMnc,MAAM5c,KAAK+4B,EAAM1zB,IAAK0zB,EAAM30B,IAAK20B,EAAMhK,KAAMgK,EAAMV,OAAQU,EAAMJ,OAAQI,EAAMR,SAAUQ,EAAML,SAAUK,EAAM3I,MAAO2I,EAAM9B,OAAQ8B,EAAM5B,QAC5I4B,EAAM9tB,OAAO2Y,OACbmV,EAAMnc,MAAM5c,KAAK+4B,EAAM9tB,QAE3B,MACMguB,EAAanC,EADmB,OAAxB5mB,EAAMunB,eAiBpB,OAfAvnB,EAAM9L,IAAM60B,EAAW70B,IACvB8L,EAAM7K,IAAM4zB,EAAW5zB,IACvB6K,EAAM2e,IAAMoK,EAAWpK,IACvB3e,EAAMkgB,MAAQ6I,EAAW7I,MACzBlgB,EAAM8mB,OAASiC,EAAWjC,OAC1B9mB,EAAM+mB,OAASgC,EAAWhC,OAC1B/mB,EAAMgnB,OAAS+B,EAAW/B,OAC1BhnB,EAAMinB,OAAS8B,EAAW9B,OAC1BjnB,EAAMknB,QAAU6B,EAAW7B,QAC3BlnB,EAAMmnB,GAAK4B,EAAW5B,GACtBnnB,EAAMonB,GAAK2B,EAAW3B,GACtBpnB,EAAMqnB,GAAK0B,EAAW1B,GACtBrnB,EAAMsnB,UAAYyB,EAAWzB,UAC7BtnB,EAAMunB,cAAgBwB,EAAWxB,cACjCvnB,EAAMwnB,OAASuB,EAAWvB,OACnBqB,CACX,CACO,MAAMG,UAA6B,WAC7Bj+B,KAAKiV,MAAQ4mB,GAAsB,EAAO,CACnD,gBAAOqC,CAAUt2B,GACRA,EAAQk0B,iBACT97B,KAAKiV,MAAMunB,cAAgB,MAE/Bx8B,KAAKiV,MAAQ4mB,EAAsBj0B,EAAQk0B,eAC/C,QACS97B,KAAKm+B,cAAgB,EAAGxV,MAAOgU,EAAUC,WAAW,KAAM1S,WAAW,SAC1EwS,EAAmB18B,KAAKiV,MAAO0nB,EAAUC,EAAU1S,GACpD,QACMlqB,KAAKysB,cAAiB7kB,GACpBs1B,EAAmBl9B,KAAKiV,MAAOrN,GAASu1B,KAChD,EAEA,MAAMiB,UAAqC,EAAAxG,EAC9C,WAAAxmB,CAAYxJ,GACR2J,MAAM3J,GACN5H,KAAKiV,MAAQ4mB,EAAsBj0B,EAAQk0B,eAC/C,CACA,SAAAoC,CAAUt2B,GACN5H,KAAKiV,MAAQ4mB,EAAsBj0B,EAAQk0B,eAC/C,CACA,aAAAqC,CAAcliC,GACVygC,EAAmB18B,KAAKiV,MAAOhZ,EAAK0sB,MAAO1sB,EAAK2gC,SAAU3gC,EAAKiuB,SACnE,CACA,aAAAuC,CAAc7kB,GACV,OAAOs1B,EAAmBl9B,KAAKiV,MAAOrN,GAASu1B,KACnD,E,kDCxOW,SAASkB,EAAgBC,EAAWC,EAASxrB,GACxD,GAAyB,IAArBurB,EAAU/+B,QAAmC,IAAnBg/B,EAAQh/B,QAAiC,IAAjBwT,EAAMxT,OACxD,MAAMkY,MAAM,kEAEhB,OAAOzU,KAAK8J,MAAK,OAAuBwxB,EAAWC,EAASxrB,GAChE,C,kBCNA,SAASyrB,EAAKruB,GACV,MAAoB,iBAANA,EACRA,EACIA,EAAI,GACC,EACD,EACJA,GAAMA,EACF,EACAsuB,IACRA,GACV,CACe,SAASC,EAAcC,EAAYC,EAAUC,EAAYC,EAAUC,GAAW,GACzF,MAAOC,EAAIC,GAAMN,GACVO,EAAIC,GAAMP,GACVQ,EAAIC,GAAMR,GACVS,EAAIC,GAAMT,EACjB,GAAIC,EAAU,CACV,MAAMS,GAASR,EAAKE,IAAOG,EAAKE,IAAON,EAAKE,IAAOC,EAAKE,GACxD,GAAIt8B,KAAKC,IAAIu8B,GAAS,MAClB,OAEJ,MAAMC,IAAMT,EAAKI,IAAOC,EAAKE,IAAON,EAAKI,IAAOD,EAAKE,IAAOE,EAG5D,MAAO,CAFGR,EAAKS,GAAKP,EAAKF,GACfC,EAAKQ,GAAKN,EAAKF,GAE7B,CACA,MAAMS,EAAKP,EAAKF,EACVU,EAAKX,EAAKE,EACVvJ,EAAKuJ,EAAKD,EAAKD,EAAKG,EACpBS,EAAKF,EAAKN,EAAKO,EAAKN,EAAK1J,EACzBkK,EAAKH,EAAKJ,EAAKK,EAAKJ,EAAK5J,EAC/B,GAAW,IAAPiK,GAAmB,IAAPC,GAAYrB,EAAKoB,KAAQpB,EAAKqB,GAC1C,OAEJ,MAAMC,EAAKP,EAAKF,EACVU,EAAKX,EAAKE,EACVzJ,EAAKyJ,EAAKD,EAAKD,EAAKG,EACpBS,EAAKF,EAAKd,EAAKe,EAAKd,EAAKpJ,EACzBoK,EAAKH,EAAKZ,EAAKa,EAAKZ,EAAKtJ,EAC/B,GAAW,IAAPmK,GAAmB,IAAPC,GAAYzB,EAAKwB,KAAQxB,EAAKyB,GAC1C,OAEJ,MAAMC,EAAeR,EAAKK,EAAKD,EAAKH,EACpC,IAAIQ,EACJA,EAAMR,EAAK9J,EAAKkK,EAAKpK,EACrB,MAAMxlB,EAAIgwB,EAAMD,EAChBC,EAAML,EAAKnK,EAAK+J,EAAK7J,EAGrB,MAD0B,CAAC1lB,EADjBgwB,EAAMD,EAGpB,C,kEChCe,SAAS7B,EAAgB+B,EAAMrtB,GAC1C,GAAoB,IAAhBqtB,EAAK7gC,QAAiC,IAAjBwT,EAAMxT,OAC3B,MAAMkY,MAAM,8EAEhB,MAAO4oB,EAAMC,EAAKnyB,EAAOoyB,GAAUH,EACnC,IAAII,EAAc,OAClB,MAAMC,EAvBV,SAA4BJ,EAAMC,EAAKnyB,EAAOoyB,GAe1C,MANqB,CACjBD,IAAK,CATY,CAACD,EAAMC,GACT,CAACD,EAAOlyB,EAAOmyB,IAS9BI,MAAO,CARY,CAACL,EAAOlyB,EAAOmyB,GACjB,CAACD,EAAOlyB,EAAOmyB,EAAMC,IAQtCI,OAAQ,CAPY,CAACN,EAAOlyB,EAAOmyB,EAAMC,GACvB,CAACF,EAAMC,EAAMC,IAO/BF,KAAM,CANY,CAACA,EAAMC,EAAMC,GACf,CAACF,EAAMC,IAQ/B,CAOyBM,CAAmBP,EAAMC,EAAKnyB,EAAOoyB,GAQ1D,OAPAtiC,OAAOoB,KAAKohC,GAAc/nB,QAASna,IAC/B,MAAO+/B,EAAWC,GAAWkC,EAAaliC,GACpCsL,EAAW,kBAA4By0B,EAAWC,EAASxrB,GAC7DlJ,EAAW22B,IACXA,EAAc32B,KAGf22B,CACX,C,6DC5BO,SAASK,EAAkBC,EAAgBC,GAC9C,IAAKA,GACuB,IAAxBA,EAAaxhC,QACbwhC,EAAaxhC,SAAWuhC,EAAevhC,OACvC,OAAOuhC,EAEX,MAAM7G,EAAI8G,EAAaA,EAAaxhC,OAAS,GAAKwhC,EAAa,GAAK,EAC9DC,GAAgB,QAAmBD,EAAangC,IAAKqgC,GAAMH,EAAeG,GAAG,KAC7EC,GAAgB,QAAmBH,EAAangC,IAAKqgC,GAAMH,EAAeG,GAAG,KACnF,GAZgBn9B,EAYDg9B,EAXc,IAAtBh9B,EAAO,IAAIvE,OAWc,CAC5B,MAAM4hC,GAAgB,QAAmBJ,EAAangC,IAAKqgC,GAAMH,EAAeG,GAAG,KACnF,OAAQ,SAAM,QAAWD,EAAe/G,IAAI,QAAWiH,EAAejH,IAAI,QAAWkH,EAAelH,GACxG,CAEI,OAAQ,SAAM,QAAW+G,EAAe/G,IAAI,QAAWiH,EAAejH,IAjB9E,IAAoBn2B,CAmBpB,C,qECnBO,SAASs9B,EAAangC,EAAelF,GACxC,GAAIA,GAAYmI,cACZ,OAAO,EAIX,OAF+D,IAA1CjD,GAAeogC,WAAWC,cACA,IAA3CrgC,GAAeogC,WAAWE,YAElC,CAIA,SAASC,EAAQC,EAAQC,GACrB,OAAiD,IAA1C,EAAA3uB,MAAA,gBAAsB0uB,EAAQC,EACzC,CAUA,SAASC,EAAe73B,EAAO0S,EAAMolB,GACjC,OAAQ93B,EAAQ0S,EAAOolB,GAAaplB,CACxC,CACA,SAASqlB,EAAwBC,EAAYC,EAAiBC,EAAUJ,GACpE,MAAO,CAAEK,EAAgBn+B,GAAUg+B,GAC5B,CAAEI,EAAqBC,GAAeJ,EACvCK,EAAet+B,EAAOvE,OACtB8iC,EAAoBF,EAAY5iC,OACtC,IAAIuyB,EAAagQ,EAAW,GACxBQ,EAAkBP,EAAgB,GACtC,KAAKj+B,EAAOguB,IACPqQ,EAAYG,IACZx+B,EAAOm+B,IACPE,EAAYD,IACb,MAAO,MAAC5gC,OAAWA,GAEvB,KAAOwwB,IAAemQ,GAClBK,IAAoBJ,GAAqB,CACzC,GAAIF,EAASG,EAAYG,GAAkBx+B,EAAOguB,IAC9C,MAAO,CAACA,EAAYwQ,GAExBxQ,EAAa6P,EAAe7P,EAAYsQ,EAAcR,GACtDU,EAAkBX,EAAeW,EAAiBD,EAAmBT,EACzE,CACA,MAAO,MAACtgC,OAAWA,EACvB,CACA,SAASihC,EAAmBz+B,EAAQ0+B,GAChC,MAAOC,EAAiBC,GApC5B,SAA0B5+B,EAAQq+B,GAC9B,IAAK,IAAI7iC,EAAI,EAAGA,EAAIwE,EAAOvE,OAAQD,IAC/B,IAAK,IAAImzB,EAAI,EAAGA,EAAI0P,EAAY5iC,OAAQkzB,IACpC,GAAI+O,EAAQ19B,EAAOxE,GAAI6iC,EAAY1P,IAC/B,MAAO,CAACnzB,EAAGmzB,EAI3B,CA4BuDkQ,CAAiB7+B,EAAQ0+B,IAAmB,GACzFI,EAAuB,CAACnB,EAAQC,KAAkD,IA3C5F,SAA4BD,EAAQC,GAChC,OAAO,EAAA3uB,MAAA,gBAAsB0uB,EAAQC,GAAU,IACnD,CAyCqDmB,CAAmBpB,EAAQC,IACrEoB,EAAcC,GAAqBlB,EAAwB,CAC9DF,EAAec,EAAiB3+B,EAAOvE,OAAQ,GAC/CkjC,EACA3+B,GACD,CACC69B,EAAee,EAAyBF,EAAejjC,OAAQ,GAC/DmjC,EACAF,GACDI,EAAsB,IAClBp+B,GAAaq9B,EAAwB,CAACF,EAAemB,EAAch/B,EAAOvE,QAAS,GAAIujC,EAAch/B,GAAS,CACjH69B,EAAeoB,EAAmBP,EAAejjC,QAAS,GAC1DwjC,EACAP,GACDI,GAAuB,GAC1B,MAAO,CAACE,EAAct+B,EAC1B,CACO,SAASw+B,EAAsB/hC,EAAe6C,EAAQm/B,GACzD,MAAM,cAAE5pB,EAAa,UAAEgoB,GAAcpgC,EAC/Bse,EAASzb,EACf,GAAIuV,EAAe,CACf,MAAM,0BAAE6pB,EAAyB,2BAAEC,EAA0B,YAAE7B,GAAc,EAAK,aAAEC,GAAe,GAAWF,EACxG+B,EAAuBH,EACvBE,EACAD,EAEN,GADkBD,EAAoB1B,EAAeD,EACtC,CACX,MAAO+B,EAAiBC,GAAmBL,EACrCV,EAAmBz+B,EAAQm/B,GAC3B,CAAC,EAAGn/B,EAAOvE,OAAS,GAC1B,OAAKuE,EAAOu/B,IAAqBv/B,EAAOw/B,IAGhC,OAAyBx/B,EAAQu/B,EAAiBC,EAAiBF,GAFhEt/B,CAGf,CACJ,CACA,OAAOyb,CACX,C,6DCxFe,SAASgkB,EAA4B9iC,EAAUsX,EAAayrB,EAAgB,CAAC,GACxF,GAAI/iC,aAAoB,EAAAgjC,eAAgB,CACpC,MAAM5sB,EAASpW,EAASqW,aAClB,yBAAE4sB,GAA6B,iDAA6CjjC,EAAUoW,GAC5F,OAAO,OAA6BkB,EAAalB,EAAQ6sB,EAC7D,CACA,GAAIjjC,aAAoB,EAAA6W,cAAe,CACnC,MAAM5D,EAAUjT,EAASkjC,oBACzB,IAAKjwB,EACD,MAAO,GAEX,MAAMkwB,EAAalwB,EAAQ4nB,QAAQ,KACnCkI,EAAcK,SAAWnwB,EAAQowB,UAAUF,EAAa,EAC5D,CACA,OAAO7rB,EAAY7Y,OAAQnD,KAClBA,EAAWU,cAGZV,EAAWE,KAAKuW,oBAGb/R,EAASsjC,oBAAoBhoC,EAAWiV,SAAUwyB,IAEjE,C,4DCvBA,MAAM,QAAEQ,GAAY,EAAAC,UACdC,EAAqB,EAAIF,EACxB,SAASG,EAAiCpsB,EAAalB,GAC1D,MAAM,gBAAEE,GAAoBF,EACtButB,EAAiCrsB,EAAY7Y,OAAQmlC,IACvD,IAAIC,EAA4BD,EAAGrzB,SAAS+F,gBAC5C,IAAKutB,EAA2B,CAC5B,MAAM,kBAAEntB,GAAsBktB,EAAGrzB,UAC3B,wBAAEuzB,GAA4B,EAAApwB,SAAA,IAAa,mBAAoBgD,GAC/DqtB,EAAe,gBAAgBD,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IAC/GE,EAAe,gBAAgBF,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IACrHD,EAA4B,cAC5B,WAAWA,EAA2BE,EAAcC,GACpDJ,EAAGrzB,SAAS+F,gBAAkButB,CAClC,CACA,MAAMI,EAAa1hC,KAAKC,IAAI,SAAS8T,EAAiButB,IAClDJ,EACJ,OAAOI,GAA6BI,IAExC,OAAKN,EAA+B7kC,OAG7B6kC,EAFI,EAGf,C,4DCvBA,MAAM,QAAE5C,GAAY,EAAAx4B,WACd,QAAEg7B,GAAY,EAAAC,UACdC,EAAqB,EAAIF,EAChB,SAASW,EAA6B5sB,EAAalB,EAAQ6sB,GACtE,MAAM,gBAAE3sB,GAAoBF,EACtButB,EAAiCrsB,EAAY7Y,OAAQmlC,IACvD,MAAM,iBAAEO,EAAgB,kBAAEztB,GAAsBktB,EAAGrzB,SACnD,IAAM+F,gBAAiButB,GAA8BD,EAAGrzB,SACxD,GAAI4zB,EAAkB,CAClB,MAAM,eAAEC,EAAc,eAAEC,GAAmBF,EAC3C,QAAIC,IACCrD,EAAQ,EAAG,SAASzqB,EAAiB8tB,QAGtCC,IACCtD,EAAQ,EAAG,SAASzqB,EAAiB+tB,IAI9C,CACA,IAAKT,EAAGrzB,SAASmG,oBACZmtB,GACDD,EAAGrzB,SAAS2F,oBAAqB,CACjC,IAAK,MAAM5D,KAASsxB,EAAGpoC,KAAKG,QAAQ0H,OAAQ,CACxC,MAAMihC,EAAS,SAAS,cAAehyB,EAAO8D,EAAOmuB,YAC/CC,EAAa,SAASF,EAAQhuB,GACpC,IAAKyqB,EAAQyD,EAAY,GACrB,OAAO,CAEf,CAGA,OAFAZ,EAAGrzB,SAAS+F,gBAAkBA,EAC9BstB,EAAGrzB,SAASk0B,iBAAmBruB,EAAOmuB,YAC/B,CACX,CACA,IAAKV,GAA6BntB,EAAmB,CACjD,MAAM,wBAAEotB,GAA4B,EAAApwB,SAAA,IAAa,mBAAoBgD,GAC/DqtB,EAAe,gBAAgBD,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IAC/GE,EAAe,gBAAgBF,EAAwB,GAAIA,EAAwB,GAAIA,EAAwB,IACrHD,EAA4B,cAC5B,WAAWA,EAA2BE,EAAcC,GACpDJ,EAAGrzB,SAAS+F,gBAAkButB,CAClC,CACA,MAAMI,EAAa1hC,KAAKC,IAAI,SAAS8T,EAAiButB,IAClDJ,EACJ,OAAOI,GAA6BI,IAExC,IAAKN,EAA+B7kC,OAChC,MAAO,GAEX,MAAM4lC,EAA+BzB,EAA2B,GAC1D,WAAEsB,GAAenuB,EACjBuuB,EAAyB,GAC/B,IAAK,MAAMrpC,KAAcqoC,EAAgC,CACrD,MAAM,KAAEnoC,EAAI,SAAE+U,EAAQ,UAAEvU,GAAcV,EACtC,IAAKU,EACD,SAEJ,MAAMsW,EAAQ/B,EAAS4zB,kBAAkB7xB,OACrC9W,EAAKG,SAAS0H,SAAS,IACvB7H,EAAK0E,SAASd,SAAS,GAC3B,IAAKkT,EAAO,CACRqyB,EAAuBrgC,KAAKhJ,GAC5B,QACJ,CACA,MAAMsO,EAAM,SAAS,cAAe26B,EAAYjyB,GACpC/P,KAAKC,IAAI,SAASoH,EAAK0M,IACzBouB,GACNC,EAAuBrgC,KAAKhJ,EAEpC,CACA,OAAOqpC,CACX,C,0DCxEO,SAASC,EAAkC5kC,EAAU+B,EAAU8iC,EAAgBC,EAAkBC,EAAW,KAC/G,MAAM1hC,EAAS2hC,EAAuBhlC,EAAU+B,EAAU,CACtD8iC,iBACAE,aAEJ,IAAIE,EACJ,IAAK,MAAM3yB,KAASjP,EAAQ,CACxB,MACM6hC,EAAcJ,EADF9kC,EAASmlC,sBAAsB7yB,GACDA,GAC5C4yB,IACAD,EAAcC,EAEtB,CACA,OAAOD,CACX,CACO,SAASD,EAAuBhlC,EAAU+B,GAAU,eAAE8iC,EAAc,SAAEE,IACzE,MAAM3uB,EAASpW,EAASqW,aAChBC,gBAAiB8uB,GAAoBhvB,GACvC,yBAAE6sB,GAA6B,iDAA6CjjC,EAAUoW,EAAQyuB,GAC9FQ,EAAOpC,EAA2B8B,GAAY,EAC9CO,EAAStlC,EAASulC,YAClBliC,EAAS,GACf,IAAImiC,EAAa,IAAIzjC,GACrB,KAAO0jC,EAAUD,EAAYF,IACzBjiC,EAAOiB,KAAK,IAAIkhC,IAChBA,EAAW,IAAMJ,EAAgB,GAAKC,EACtCG,EAAW,IAAMJ,EAAgB,GAAKC,EACtCG,EAAW,IAAMJ,EAAgB,GAAKC,EAG1C,IADAG,EAAa,IAAIzjC,GACV0jC,EAAUD,EAAYF,IACzBjiC,EAAOiB,KAAK,IAAIkhC,IAChBA,EAAW,IAAMJ,EAAgB,GAAKC,EACtCG,EAAW,IAAMJ,EAAgB,GAAKC,EACtCG,EAAW,IAAMJ,EAAgB,GAAKC,EAE1C,OAAOhiC,CACX,CACA,MAAMoiC,EAAY,SAAUnzB,EAAOgzB,GAC/B,MAAOI,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,GAAQT,EACvCU,EAAU,GAChB,OAAQ1zB,EAAM,GAAKozB,EAAOM,GACtB1zB,EAAM,GAAKqzB,EAAOK,GAClB1zB,EAAM,GAAKszB,EAAOI,GAClB1zB,EAAM,GAAKuzB,EAAOG,GAClB1zB,EAAM,GAAKwzB,EAAOE,GAClB1zB,EAAM,GAAKyzB,EAAOC,CAC1B,C,iDC/Ce,SAASC,EAAkC3vB,EAAiBE,EAAQ0vB,EAAcC,GAC7F,MAAMC,EAAY,cAClB,WAAWA,EAAW5vB,EAAQF,GAC9B,MAAM+vB,EAAO,mBAAmBH,GAC1BI,EAAO,mBAAmBH,GAC1BI,EAAW,cACjB,cAAcA,EAAUF,EAAMC,GAC9B,MAAME,EAAiB,YAAYD,GACnC,GAAIC,EAAiB,KACjB,MAAO,CAAEC,WAAY,EAAGC,YAAa,GAEzC,MAAMC,EAAW,SAASJ,EAAUH,IAAcI,EAAiB,YAAYJ,IAI/E,MAAO,CAAEK,WAHQlkC,KAAK8J,KAAK,EAAIs6B,EAAWA,GACZH,EAETE,YADDC,EAAWH,EAEnC,C,iDChBe,SAASI,EAAoCtwB,EAAiBE,EAAQqwB,EAAWC,GAC5F,MAAMV,EAAY,cAClB,WAAWA,EAAW5vB,EAAQF,GAC9B,MAAM+vB,EAAO,mBAAmBQ,GAC1BP,EAAO,mBAAmBQ,GAC1BP,EAAW,cACjB,cAAcA,EAAUF,EAAMC,GAC9B,MAAME,EAAiB,YAAYD,GACnC,GAAIC,EAAiB,KACjB,MAAO,CAAEC,WAAY,EAAGC,YAAa,GAEzC,MAAMC,EAAW,SAASJ,EAAUH,IAAcI,EAAiB,YAAYJ,IAI/E,MAAO,CAAEK,WAHQlkC,KAAK8J,KAAK,EAAIs6B,EAAWA,GACZH,EAETE,YADDC,EAAWH,EAEnC,C,iDChBO,MAAMO,EAA0B,CAACC,EAAQC,EAAQC,EAAMC,EAAMC,EAAMC,EAAMC,EAAMC,KAClF,MAAMC,EAAW,CACb,gBAAgBN,EAAMC,EAAMC,GAC5B,gBAAgBC,EAAMF,EAAMC,GAC5B,gBAAgBF,EAAMI,EAAMF,GAC5B,gBAAgBC,EAAMC,EAAMF,GAC5B,gBAAgBF,EAAMC,EAAMI,GAC5B,gBAAgBF,EAAMF,EAAMI,GAC5B,gBAAgBL,EAAMI,EAAMC,GAC5B,gBAAgBF,EAAMC,EAAMC,IAE1BE,EAAY,gBAAgBR,EAAO,GAAIA,EAAO,GAAIA,EAAO,IACzDS,EAAY,gBAAgBV,EAAO,GAAIA,EAAO,GAAIA,EAAO,IACzDW,GAAiB,SAASF,EAAWC,GAC3C,IAAIE,EAAc,KAClB,IAAK,MAAMC,KAAUL,EAAU,CAC3B,MAAMp+B,EAAW,SAASq+B,EAAWI,GAAUF,EAC/C,GAAoB,OAAhBC,EACAA,EAAcrlC,KAAKw7B,KAAK30B,QAEvB,GAAI7G,KAAKw7B,KAAK30B,KAAcw+B,EAC7B,OAAO,CAEf,CACA,OAAO,E,8FCpBI,SAASE,EAAyBtY,GAC7C,MAAM,WAAEl0B,GAAek0B,EACjBuY,GAA2B,OAAqBvY,EAAc,CAChE,CAAEpI,IAAK,mBAAoBc,MAAOsH,EAAa3X,oBAE7CmwB,EAAuB1sC,EAAWiV,SAAS0f,WACjD,IAAIgY,GAAoB,EACpBC,EAAmB1Y,EAAaE,UAAUK,eAC9C,IAAK,MAAOE,EAAY3Y,KAAgBywB,EAAyBtqC,UAAW,CACxE,GAAIwyB,IAAe+X,EACf,SAEJ,MAAMG,EAAkB7wB,EAAYiD,KAAMjf,IAAgBA,EAAWmI,eAChE0kC,IAGDlY,EAAa+X,EACbC,EAAmB1lC,KAAKmG,IAAIunB,EAAYgY,GAGxCC,EAAmB3lC,KAAKoH,IAAIsmB,EAAYiY,GAEhD,CACA,MAAME,EAAqB,GAC3B,IAAK,MAAOnY,EAAY3Y,KAAgBywB,EAAyBtqC,UACzDwyB,GAAcgY,GACdhY,GAAciY,GACdjY,IAAe+X,GAGnB1wB,EAAYW,QAASowB,IACbA,EAAmB5kC,gBACnB,QAAgCmF,iBAAiBy/B,EAAmBruC,eACpEouC,EAAmB9jC,KAAK+jC,MAIpC,GAAID,EAAmBtpC,OAAQ,CAC3B,MAAMm8B,EAAe,CACjB3jB,YAAa8wB,EACbzoC,QAAS6vB,EAAaxvB,SAASL,QAC/B7C,WAAY0yB,EAAaxvB,SAASmN,GAClC6tB,kBAAmBxL,EAAaxvB,SAASqX,qBAAqBlK,KAElE,IAAA9Q,cAAamzB,EAAaxvB,SAASL,QAAS,IAAW2oC,iCAAkCrN,EAC7F,CACA,GAAIgN,GAAoB,GACpBC,EAAmB1Y,EAAaE,UAAUK,eAAgB,CAC1D,MAAMwY,EAAiBR,EAAyB7oB,IAAIgpB,GAAkB,GAChEM,EAAkB,CACpBxoC,SAAUwvB,EAAaxvB,SACvB0vB,UAAW,CACPK,eAAgBP,EAAaE,UAAUK,eACvC0Y,WAAYF,EAAeh4B,SAAS0f,YAExC30B,WAAYitC,EACZ1wB,iBAAkB0wB,EAAe1wB,mBAErC,OAAY2wB,EAChB,CACJ,C,8FC5DA,MAAME,EAA0B,IAAIzsB,IACpCuB,eAAemrB,EAA4BxsC,EAAgBY,EAAM6rC,EAAiBC,EAAgBC,GAC9F,MAAMttC,QAAaotC,KACnB,OAAsB,CAClBzsC,iBACAY,OACAvB,SAEJstC,MACKJ,EAAwBlQ,IAAIr8B,IAC7BusC,EAAwB7rB,IAAI1gB,EAAgB,IAEhD,MAAM4sC,EAAkBL,EAAwBxpB,IAAI/iB,GAMpD,OALK4sC,EAAgBhqC,SAAShC,IAC1BgsC,EAAgBzkC,KAAKvH,GAM7B,SAAwC8rC,GACpC,MAAMG,EAA2BvjC,IAC7BwjC,EAA+BxjC,EAAOojC,IAE1CA,EAAeK,yBAA2BF,EAC1C,EAAA1sC,YAAYuF,oBAAoB,EAAAtF,OAAO+lB,2BAA4BumB,EAAeK,0BAClF,EAAA5sC,YAAY4E,iBAAiB,EAAA3E,OAAO+lB,2BAA4BumB,EAAeK,yBACnF,CAXIC,CAA+BN,IAC/B,IAAApsC,6BAA4BN,GACrBX,CACX,CASA,MAAMytC,GAAiC,OAAS,CAACxjC,EAAOojC,KACpD,MAAM1sC,EAAiBsJ,EAAMhG,OAAOtD,eAC9B4sC,EAAkBL,EAAwBxpB,IAAI/iB,GAC/C4sC,GAAoBA,EAAgBjqC,SAGzC+pC,EAAe1sC,GACX4sC,EAAgBjqC,SAChB,IAAArC,6BAA4BN,KAEjC,I,oHCpCI,SAASwe,GAAsB,eAAExe,EAAc,aAAE0B,EAAY,WAAEf,EAAU,cAAE2G,GAAgB,IAC9F,MAAM2lC,GAAe,IAAAC,sBAAqBvsC,EAAYX,EAAgB0B,GAChEyrC,GAAsB,OAAwCxsC,EAAY,CAC5EX,iBACAY,KAAM,EAAAqd,4BAA4Bd,UAEhCiwB,GAAqB,OAAsBzsC,GAC3C0sC,EAAWD,GAAoBptC,iBAAmBA,EAOlDstC,EANQ,IAAkB92B,SAAS,CACrC7V,aACAX,iBACAY,KAAM,EAAAqd,4BAA4Bd,QAClCzb,iBAGJ,IACIwP,EADAD,EAAY,EAEZ6G,EAAc,EACdzG,EAAc,EACd/J,GACA2J,EAAYq8B,EAAa3uB,2BAA6B1N,EACtDC,EAAWo8B,EAAapuB,0BAA4BhO,EACpD4G,EAAcw1B,EAAaxuB,gBAAkBhH,EAC7CzG,EAAci8B,EAAa/tB,wBAA0BlO,GAEhDg8B,GACLp8B,EAAYq8B,EAAa1uB,cAAgB3N,EACzCC,EAAWo8B,EAAatuB,aAAe9N,EACvC4G,EAAcw1B,EAAaxuB,gBAAkBhH,EAC7CzG,EAAci8B,EAAajuB,WAAahO,IAGxCJ,EAAYq8B,EAAazuB,sBAAwB5N,EACjDC,EAAWo8B,EAAaruB,qBAAuB/N,EAC/C4G,EAAcw1B,EAAavuB,wBAA0BjH,EACrDzG,EAAci8B,EAAahuB,mBAAqBjO,IAEhD,OAAsBrR,KAAoB0B,IAC1CuP,GAAaq8B,EAAanuB,gCAE9BlO,EAAYq8B,EAAa5uB,cAAgBzN,EAAY,EACrDI,EAAci8B,EAAaluB,WAAa/N,EAAc,EACtD,MAAMF,EAAQ,QAAQ87B,EAAa,OAAOA,EAAa,OAAOA,EAAa,OAAOn1B,KAC5E1G,EAAY,OAAO67B,EAAa,OAAOA,EAAa,OAAOA,EAAa,MAKxEptC,IAJiB,OAAgCc,EAAY,CAC/DX,iBACAY,KAAM,EAAAqd,4BAA4Bd,UAEJkf,IAAI36B,GACtC,MAAO,CACHyP,QACAC,YACAH,YACAI,cACAH,WACA6G,QAAS,CACL5G,SAEJoF,WAAY42B,GAAuBttC,EAE3C,C,iFC/De,SAAS0tC,EAA+B/pC,EAASpB,EAAUorC,GAAyB,GAC/F,MAAM7pC,GAAiB,IAAAC,mBAAkBJ,IACnC,gBAAEyD,EAAe,oBAAE8S,GAAwBpW,EACjD,IAAI8pC,EAAYxmC,EAAgBymC,eAChCD,GAAY,OAAuCA,EAAW1zB,GAC9D0zB,GAAY,OAA+BA,EAAWrrC,GACtD,MAAMyB,EAAWoD,EAAgB0mC,YAAYhqC,EAAehD,YACxD6sC,IACAC,GAAY,OAAmCA,EAAW5pC,EAASqW,cAGvE,OADoBuzB,EAAUzpC,IAAK4pC,GAAOA,EAAG58B,GAEjD,C","sources":["webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/drawingSvg/_getHash.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/eventDispatchers/shared/getMouseModifier.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/resetAnnotationManager.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/annotation/utilities/defineProperties.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationAdded.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRemoved.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationModified.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/events/triggerSegmentationRepresentationRemoved.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/getSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/store/ToolGroupManager/getToolGroupsWithToolName.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/closedContourEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/drawLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/editLoopCommon.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/findOpenUShapedContourVectorToPeak.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/openContourEndEditLoop.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/annotation/planarFreehandROITool/renderMethods.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/AnnotationTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourBaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/base/ContourSegmentationBaseTool.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourConfig.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/handleContourSegmentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Contour/contourHandler/utils.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addVolumesAsIndependentComponents.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/addLabelmapToElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/labelmapConfig.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Labelmap/removeLabelmapFromElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/addOrUpdateSurfaceToElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/displayTools/Surface/removeSurfaceFromElement.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/BrushStrategy.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/determineSegmentIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/dynamicThreshold.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/erase.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/islandRemovalComposition.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/preview.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/regionFill.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/setValue.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/utils/handleUseSegmentCenterIndex.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/threshold.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/labelmapStatistics.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/compositions/index.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseCircle.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/eraseSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/tools/segmentation/strategies/fillSphere.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/RectangleROIStartEndThreshold.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/getInterpolationDataCollection.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/createPolylineToolData.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/findAnnotationForInterpolation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/selectHandles.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/interpolate.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/contours/interpolation/updateChildInterpolationUID.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/basic/BasicStatsCalculator.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/distanceToPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/line/intersectLine.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/math/rectangle/distanceToPoint.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/interpolation/algorithms/bspline.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planarFreehandROITool/smoothPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsForDisplay.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinPlane.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/filterAnnotationsWithinSlice.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getPointInLineOfSightWithCriteria.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromCorners.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/getWorldWidthAndHeightFromTwoPoints.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/planar/isPlaneIntersectingAABB.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/InterpolationManager/deleteRelatedAnnotations.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/computeAndAddRepresentation.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/segmentation/getSVGStyleForSegment.js","webpack:///../../../node_modules/@cornerstonejs/tools/dist/esm/utilities/viewportFilters/getViewportIdsWithToolToRender.js"],"sourcesContent":["function _getHash(annotationUID, drawingElementType, nodeUID) {\n    return `${annotationUID}::${drawingElementType}::${nodeUID}`;\n}\nexport default _getHash;\n","import { KeyboardBindings as kb } from '../../enums';\nconst getMouseModifierKey = (evt) => {\n    if (evt.shiftKey) {\n        if (evt.ctrlKey) {\n            return kb.ShiftCtrl;\n        }\n        if (evt.altKey) {\n            return kb.ShiftAlt;\n        }\n        if (evt.metaKey) {\n            return kb.ShiftMeta;\n        }\n        return kb.Shift;\n    }\n    if (evt.ctrlKey) {\n        if (evt.altKey) {\n            return kb.CtrlAlt;\n        }\n        if (evt.metaKey) {\n            return kb.CtrlMeta;\n        }\n        return kb.Ctrl;\n    }\n    if (evt.altKey) {\n        return (evt.metaKey && kb.AltMeta) || kb.Alt;\n    }\n    if (evt.metaKey) {\n        return kb.Meta;\n    }\n    return undefined;\n};\nexport default getMouseModifierKey;\n","import { checkAndDefineCachedStatsProperty, checkAndDefineTextBoxProperty, } from './utilities/defineProperties';\nimport { checkAndSetAnnotationLocked } from './annotationLocking';\nimport { checkAndSetAnnotationVisibility } from './annotationVisibility';\nimport { defaultFrameOfReferenceSpecificAnnotationManager } from './FrameOfReferenceSpecificAnnotationManager';\nimport { setAnnotationManager } from './annotationState';\nconst defaultManager = defaultFrameOfReferenceSpecificAnnotationManager;\nconst preprocessingFn = (annotation) => {\n    annotation = checkAndDefineTextBoxProperty(annotation);\n    annotation = checkAndDefineCachedStatsProperty(annotation);\n    const uid = annotation.annotationUID;\n    const isLocked = checkAndSetAnnotationLocked(uid);\n    annotation.isLocked = isLocked;\n    const isVisible = checkAndSetAnnotationVisibility(uid);\n    annotation.isVisible = isVisible;\n    return annotation;\n};\ndefaultManager.setPreprocessingFn(preprocessingFn);\nsetAnnotationManager(defaultManager);\nexport function resetAnnotationManager() {\n    setAnnotationManager(defaultManager);\n}\n","const checkAndDefineTextBoxProperty = (annotation) => {\n    if (!annotation.data) {\n        annotation.data = {};\n    }\n    if (!annotation.data.handles) {\n        annotation.data.handles = {};\n    }\n    if (!annotation.data.handles.textBox) {\n        annotation.data.handles.textBox = {};\n    }\n    return annotation;\n};\nconst checkAndDefineCachedStatsProperty = (annotation) => {\n    if (!annotation.data) {\n        annotation.data = {};\n    }\n    if (!annotation.data.cachedStats) {\n        annotation.data.cachedStats = {};\n    }\n    return annotation;\n};\nexport { checkAndDefineTextBoxProperty, checkAndDefineCachedStatsProperty };\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationAdded(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_ADDED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationModified(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_MODIFIED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRemoved(segmentationId) {\n    const eventDetail = {\n        segmentationId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REMOVED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRepresentationModified(viewportId, segmentationId, type) {\n    const eventDetail = {\n        segmentationId,\n        type,\n        viewportId,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REPRESENTATION_MODIFIED, eventDetail);\n}\n","import { triggerEvent, eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../../enums';\nexport function triggerSegmentationRepresentationRemoved(viewportId, segmentationId, type) {\n    const eventDetail = {\n        viewportId,\n        segmentationId,\n        type,\n    };\n    triggerEvent(eventTarget, Events.SEGMENTATION_REPRESENTATION_REMOVED, eventDetail);\n}\n","import { defaultSegmentationStateManager } from './SegmentationStateManager';\nexport function getSegmentation(segmentationId) {\n    const segmentationStateManager = defaultSegmentationStateManager;\n    return segmentationStateManager.getSegmentation(segmentationId);\n}\n","import { getSegmentationRepresentation } from '../getSegmentationRepresentation';\nexport function internalGetHiddenSegmentIndices(viewportId, specifier) {\n    const representation = getSegmentationRepresentation(viewportId, specifier);\n    if (!representation) {\n        return new Set();\n    }\n    const segmentsHidden = Object.entries(representation.segments).reduce((acc, [segmentIndex, segment]) => {\n        if (!segment.visible) {\n            acc.add(Number(segmentIndex));\n        }\n        return acc;\n    }, new Set());\n    return segmentsHidden;\n}\n","import { state } from '../state';\nimport { ToolModes } from '../../enums';\nconst MODES = [ToolModes.Active, ToolModes.Passive, ToolModes.Enabled];\nfunction getToolGroupsWithToolName(toolName) {\n    return state.toolGroups.filter(({ toolOptions }) => {\n        const toolGroupToolNames = Object.keys(toolOptions);\n        for (let i = 0; i < toolGroupToolNames.length; i++) {\n            if (toolName !== toolGroupToolNames[i]) {\n                continue;\n            }\n            if (!toolOptions[toolName]) {\n                continue;\n            }\n            if (MODES.includes(toolOptions[toolName].mode)) {\n                return true;\n            }\n        }\n        return false;\n    });\n}\nexport default getToolGroupsWithToolName;\n","import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nimport { getInterpolatedPoints, shouldSmooth, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport updateContourPolyline from '../../../utilities/contours/updateContourPolyline';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\nconst { getSubPixelSpacingAndXYDirections, addCanvasPointsToArray, getArea } = polyline;\nfunction activateClosedContourEdit(evt, annotation, viewportIdsToRender) {\n    this.isEditingClosed = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    if (!enabledElement) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const prevCanvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.editData = {\n        prevCanvasPoints,\n        editCanvasPoints: [canvasPos],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n        annotation,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);\n    hideElementCursor(element);\n}\nfunction deactivateClosedContourEdit(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragClosedContourEditCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragClosedContourEditCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpClosedContourEditCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragClosedContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n    const { editIndex, editCanvasPoints, startCrossingIndex, annotation } = this.editData;\n    this.createMemo(element, annotation);\n    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (startCrossingIndex !== undefined) {\n        this.checkAndRemoveCrossesOnEditLine(evt);\n    }\n    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);\n    const currentEditIndex = editIndex + numPointsAdded;\n    this.editData.editIndex = currentEditIndex;\n    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n        this.checkForFirstCrossing(evt, true);\n    }\n    this.editData.snapIndex = this.findSnapIndex();\n    if (this.editData.snapIndex === -1) {\n        this.finishEditAndStartNewEdit(evt);\n        return;\n    }\n    this.editData.fusedCanvasPoints = this.fuseEditPointsWithClosedContour(evt);\n    if (startCrossingIndex !== undefined &&\n        this.checkForSecondCrossing(evt, true)) {\n        this.removePointsAfterSecondCrossing(true);\n        this.finishEditAndStartNewEdit(evt);\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction finishEditAndStartNewEdit(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    if (annotation.autoGenerated) {\n        annotation.autoGenerated = false;\n    }\n    triggerAnnotationModified(annotation, element);\n    const lastEditCanvasPoint = editCanvasPoints.pop();\n    this.editData = {\n        prevCanvasPoints: fusedCanvasPoints,\n        editCanvasPoints: [lastEditCanvasPoint],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n        snapIndex: undefined,\n        annotation,\n    };\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction fuseEditPointsWithClosedContour(evt) {\n    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const augmentedEditCanvasPoints = [...editCanvasPoints];\n    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);\n    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n        augmentedEditCanvasPoints.pop();\n    }\n    let lowIndex;\n    let highIndex;\n    if (startCrossingIndex > snapIndex) {\n        lowIndex = snapIndex;\n        highIndex = startCrossingIndex;\n    }\n    else {\n        lowIndex = startCrossingIndex;\n        highIndex = snapIndex;\n    }\n    const distanceBetweenLowAndFirstPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenLowAndLastPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const distanceBetweenHighAndFirstPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenHighAndLastPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const pointSet1 = [];\n    for (let i = 0; i < lowIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    let inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n    let reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet1.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    const pointSet2 = [];\n    for (let i = lowIndex; i < highIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    inPlaceDistance =\n        distanceBetweenHighAndFirstPoint + distanceBetweenLowAndLastPoint;\n    reverseDistance =\n        distanceBetweenHighAndLastPoint + distanceBetweenLowAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointSet2.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    const areaPointSet1 = getArea(pointSet1);\n    const areaPointSet2 = getArea(pointSet2);\n    const pointsToRender = areaPointSet1 > areaPointSet2 ? pointSet1 : pointSet2;\n    return pointsToRender;\n}\nfunction mouseUpClosedContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.completeClosedContourEdit(element);\n}\nfunction completeClosedContourEdit(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    this.doneEditMemo();\n    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n    if (fusedCanvasPoints) {\n        const updatedPoints = shouldSmooth(this.configuration, annotation)\n            ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints)\n            : fusedCanvasPoints;\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, {\n            points: updatedPoints,\n            closed: true,\n            targetWindingDirection: ContourWindingDirection.Clockwise,\n        }, viewport, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n        });\n        if (annotation.autoGenerated) {\n            annotation.autoGenerated = false;\n        }\n        triggerAnnotationModified(annotation, element);\n    }\n    this.isEditingClosed = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateClosedContourEdit(element);\n}\nfunction cancelClosedContourEdit(element) {\n    this.completeClosedContourEdit(element);\n}\nfunction registerClosedContourEditLoop(toolInstance) {\n    toolInstance.activateClosedContourEdit =\n        activateClosedContourEdit.bind(toolInstance);\n    toolInstance.deactivateClosedContourEdit =\n        deactivateClosedContourEdit.bind(toolInstance);\n    toolInstance.mouseDragClosedContourEditCallback =\n        mouseDragClosedContourEditCallback.bind(toolInstance);\n    toolInstance.mouseUpClosedContourEditCallback =\n        mouseUpClosedContourEditCallback.bind(toolInstance);\n    toolInstance.finishEditAndStartNewEdit =\n        finishEditAndStartNewEdit.bind(toolInstance);\n    toolInstance.fuseEditPointsWithClosedContour =\n        fuseEditPointsWithClosedContour.bind(toolInstance);\n    toolInstance.cancelClosedContourEdit =\n        cancelClosedContourEdit.bind(toolInstance);\n    toolInstance.completeClosedContourEdit =\n        completeClosedContourEdit.bind(toolInstance);\n}\nexport default registerClosedContourEditLoop;\n","import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { ChangeTypes, Events } from '../../../enums';\nimport { state } from '../../../store/state';\nimport { vec3 } from 'gl-matrix';\nimport { shouldSmooth, getInterpolatedPoints, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport getMouseModifierKey from '../../../eventDispatchers/shared/getMouseModifier';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport { triggerAnnotationModified, triggerContourAnnotationCompleted, } from '../../../stateManagement/annotation/helpers/state';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { polyline } from '../../../utilities/math';\nimport { removeAnnotation } from '../../../stateManagement/annotation/annotationState';\nimport { ContourWindingDirection } from '../../../types/ContourAnnotation';\nconst { addCanvasPointsToArray, pointsAreWithinCloseContourProximity, getFirstLineSegmentIntersectionIndexes, getSubPixelSpacingAndXYDirections, } = polyline;\nfunction activateDraw(evt, annotation, viewportIdsToRender) {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const contourHoleProcessingEnabled = getMouseModifierKey(evt.detail.event) ===\n        this.configuration.contourHoleAdditionModifierKey;\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution) || {};\n    if (!spacing || !xDir || !yDir) {\n        return;\n    }\n    this.drawData = {\n        canvasPoints: [canvasPos],\n        polylineIndex: 0,\n        contourHoleProcessingEnabled,\n        newAnnotation: true,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    hideElementCursor(element);\n}\nfunction deactivateDraw(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragDrawCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender, xDir, yDir, spacing, movingTextBox, } = this.commonData;\n    const { polylineIndex, canvasPoints, newAnnotation } = this.drawData;\n    this.createMemo(element, annotation, { newAnnotation });\n    const lastCanvasPoint = canvasPoints[canvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (movingTextBox) {\n        this.isDrawing = false;\n        const { deltaPoints } = eventDetail;\n        const worldPosDelta = deltaPoints.world;\n        const { textBox } = annotation.data.handles;\n        const { worldPosition } = textBox;\n        worldPosition[0] += worldPosDelta[0];\n        worldPosition[1] += worldPosDelta[1];\n        worldPosition[2] += worldPosDelta[2];\n        textBox.hasMoved = true;\n    }\n    else {\n        const crossingIndex = this.findCrossingIndexDuringCreate(evt);\n        if (crossingIndex !== undefined) {\n            this.applyCreateOnCross(evt, crossingIndex);\n        }\n        else {\n            const numPointsAdded = addCanvasPointsToArray(element, canvasPoints, canvasPos, this.commonData);\n            this.drawData.polylineIndex = polylineIndex + numPointsAdded;\n        }\n        annotation.invalidated = true;\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    if (annotation.invalidated) {\n        triggerAnnotationModified(annotation, element, ChangeTypes.HandlesUpdated);\n    }\n}\nfunction mouseUpDrawCallback(evt) {\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.doneEditMemo();\n    this.drawData.newAnnotation = false;\n    if (allowOpenContours &&\n        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n        this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });\n    }\n    else {\n        this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });\n    }\n}\nfunction completeDrawClosedContour(element, options) {\n    this.removeCrossedLinesOnCompleteDraw();\n    const { canvasPoints } = this.drawData;\n    const { contourHoleProcessingEnabled, minPointsToSave } = options ?? {};\n    if (minPointsToSave && canvasPoints.length < minPointsToSave) {\n        return false;\n    }\n    if (this.haltDrawing(element, canvasPoints)) {\n        return false;\n    }\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    addCanvasPointsToArray(element, canvasPoints, canvasPoints[0], this.commonData);\n    canvasPoints.pop();\n    const updatedPoints = shouldSmooth(this.configuration, annotation)\n        ? getInterpolatedPoints(this.configuration, canvasPoints)\n        : canvasPoints;\n    this.updateContourPolyline(annotation, {\n        points: updatedPoints,\n        closed: true,\n        targetWindingDirection: ContourWindingDirection.Clockwise,\n    }, viewport);\n    const { textBox } = annotation.data.handles;\n    if (!textBox?.hasMoved) {\n        triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n    }\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateDraw(element);\n    return true;\n}\nfunction removeCrossedLinesOnCompleteDraw() {\n    const { canvasPoints } = this.drawData;\n    const numPoints = canvasPoints.length;\n    const endToStart = [canvasPoints[0], canvasPoints[numPoints - 1]];\n    const canvasPointsMinusEnds = canvasPoints.slice(0, -1).slice(1);\n    const lineSegment = getFirstLineSegmentIntersectionIndexes(canvasPointsMinusEnds, endToStart[0], endToStart[1], false);\n    if (lineSegment) {\n        const indexToRemoveUpTo = lineSegment[1];\n        if (indexToRemoveUpTo === 1) {\n            this.drawData.canvasPoints = canvasPoints.splice(1);\n        }\n        else {\n            this.drawData.canvasPoints = canvasPoints.splice(0, indexToRemoveUpTo);\n        }\n    }\n}\nfunction completeDrawOpenContour(element, options) {\n    const { canvasPoints } = this.drawData;\n    const { contourHoleProcessingEnabled } = options ?? {};\n    if (this.haltDrawing(element, canvasPoints)) {\n        return false;\n    }\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const updatedPoints = shouldSmooth(this.configuration, annotation)\n        ? getInterpolatedPoints(this.configuration, canvasPoints)\n        : canvasPoints;\n    this.updateContourPolyline(annotation, {\n        points: updatedPoints,\n        closed: false,\n    }, viewport);\n    const { textBox } = annotation.data.handles;\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    if (annotation.data.isOpenUShapeContour) {\n        annotation.data.openUShapeContourVectorToPeak =\n            findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n    }\n    if (!textBox.hasMoved) {\n        triggerContourAnnotationCompleted(annotation, contourHoleProcessingEnabled);\n    }\n    this.isDrawing = false;\n    this.drawData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateDraw(element);\n    return true;\n}\nfunction findCrossingIndexDuringCreate(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { canvasPoints } = this.drawData;\n    const pointsLessLastOne = canvasPoints.slice(0, -1);\n    const lineSegment = getFirstLineSegmentIntersectionIndexes(pointsLessLastOne, canvasPos, lastCanvasPoint, false);\n    if (lineSegment === undefined) {\n        return;\n    }\n    const crossingIndex = lineSegment[0];\n    return crossingIndex;\n}\nfunction applyCreateOnCross(evt, crossingIndex) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    addCanvasPointsToArray(element, canvasPoints, canvasPoints[crossingIndex], this.commonData);\n    canvasPoints.pop();\n    const remainingPoints = canvasPoints.slice(crossingIndex);\n    const newArea = polyline.getArea(remainingPoints);\n    if (utilities.isEqual(newArea, 0)) {\n        canvasPoints.splice(crossingIndex + 1);\n        return;\n    }\n    canvasPoints.splice(0, crossingIndex);\n    const options = { contourHoleProcessingEnabled, minPointsToSave: 3 };\n    if (this.completeDrawClosedContour(element, options)) {\n        this.activateClosedContourEdit(evt, annotation, viewportIdsToRender);\n    }\n}\nfunction cancelDrawing(element) {\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints, contourHoleProcessingEnabled } = this.drawData;\n    const firstPoint = canvasPoints[0];\n    const lastPoint = canvasPoints[canvasPoints.length - 1];\n    if (allowOpenContours &&\n        !pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n        this.completeDrawOpenContour(element, { contourHoleProcessingEnabled });\n    }\n    else {\n        this.completeDrawClosedContour(element, { contourHoleProcessingEnabled });\n    }\n}\nfunction shouldHaltDrawing(canvasPoints, subPixelResolution) {\n    const minPoints = Math.max(subPixelResolution * 3, 3);\n    return canvasPoints.length < minPoints;\n}\nfunction haltDrawing(element, canvasPoints) {\n    const { subPixelResolution } = this.configuration;\n    if (shouldHaltDrawing(canvasPoints, subPixelResolution)) {\n        const { annotation, viewportIdsToRender } = this.commonData;\n        const enabledElement = getEnabledElement(element);\n        const { renderingEngine } = enabledElement;\n        removeAnnotation(annotation.annotationUID);\n        this.isDrawing = false;\n        this.drawData = undefined;\n        this.commonData = undefined;\n        triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n        this.deactivateDraw(element);\n        return true;\n    }\n    return false;\n}\nfunction registerDrawLoop(toolInstance) {\n    toolInstance.activateDraw = activateDraw.bind(toolInstance);\n    toolInstance.deactivateDraw = deactivateDraw.bind(toolInstance);\n    toolInstance.applyCreateOnCross = applyCreateOnCross.bind(toolInstance);\n    toolInstance.findCrossingIndexDuringCreate =\n        findCrossingIndexDuringCreate.bind(toolInstance);\n    toolInstance.completeDrawOpenContour =\n        completeDrawOpenContour.bind(toolInstance);\n    toolInstance.removeCrossedLinesOnCompleteDraw =\n        removeCrossedLinesOnCompleteDraw.bind(toolInstance);\n    toolInstance.mouseDragDrawCallback = mouseDragDrawCallback.bind(toolInstance);\n    toolInstance.mouseUpDrawCallback = mouseUpDrawCallback.bind(toolInstance);\n    toolInstance.completeDrawClosedContour =\n        completeDrawClosedContour.bind(toolInstance);\n    toolInstance.cancelDrawing = cancelDrawing.bind(toolInstance);\n    toolInstance.haltDrawing = haltDrawing.bind(toolInstance);\n}\nexport default registerDrawLoop;\n","import { vec2 } from 'gl-matrix';\nimport { polyline } from '../../../utilities/math';\nconst { addCanvasPointsToArray, getFirstLineSegmentIntersectionIndexes } = polyline;\nfunction checkForFirstCrossing(evt, isClosedContour) {\n    const eventDetail = evt.detail;\n    const { element, currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { editCanvasPoints, prevCanvasPoints } = this.editData;\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);\n    if (crossedLineSegment) {\n        this.editData.startCrossingIndex = crossedLineSegment[0];\n        this.removePointsUpUntilFirstCrossing(isClosedContour);\n    }\n    else if (prevCanvasPoints.length >= 2) {\n        if (editCanvasPoints.length >\n            this.configuration.checkCanvasEditFallbackProximity) {\n            const firstEditCanvasPoint = editCanvasPoints[0];\n            const distanceIndexPairs = [];\n            for (let i = 0; i < prevCanvasPoints.length; i++) {\n                const prevCanvasPoint = prevCanvasPoints[i];\n                const distance = vec2.distance(prevCanvasPoint, firstEditCanvasPoint);\n                distanceIndexPairs.push({ distance, index: i });\n            }\n            distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n            const twoClosestDistanceIndexPairs = [\n                distanceIndexPairs[0],\n                distanceIndexPairs[1],\n            ];\n            const lowestIndex = Math.min(twoClosestDistanceIndexPairs[0].index, twoClosestDistanceIndexPairs[1].index);\n            this.editData.startCrossingIndex = lowestIndex;\n        }\n        else {\n            const dir = vec2.create();\n            vec2.subtract(dir, editCanvasPoints[1], editCanvasPoints[0]);\n            vec2.normalize(dir, dir);\n            const proximity = 6;\n            const extendedPoint = [\n                editCanvasPoints[0][0] - dir[0] * proximity,\n                editCanvasPoints[0][1] - dir[1] * proximity,\n            ];\n            const crossedLineSegmentFromExtendedPoint = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, extendedPoint, editCanvasPoints[0], isClosedContour);\n            if (crossedLineSegmentFromExtendedPoint) {\n                const pointsToPrepend = [extendedPoint];\n                addCanvasPointsToArray(element, pointsToPrepend, editCanvasPoints[0], this.commonData);\n                editCanvasPoints.unshift(...pointsToPrepend);\n                this.removePointsUpUntilFirstCrossing(isClosedContour);\n                this.editData.editIndex = editCanvasPoints.length - 1;\n                this.editData.startCrossingIndex =\n                    crossedLineSegmentFromExtendedPoint[0];\n            }\n        }\n    }\n}\nfunction removePointsUpUntilFirstCrossing(isClosedContour) {\n    const { editCanvasPoints, prevCanvasPoints } = this.editData;\n    let numPointsToRemove = 0;\n    for (let i = 0; i < editCanvasPoints.length - 1; i++) {\n        const firstLine = [editCanvasPoints[i], editCanvasPoints[i + 1]];\n        const didCrossLine = !!getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, firstLine[0], firstLine[1], isClosedContour);\n        numPointsToRemove++;\n        if (didCrossLine) {\n            break;\n        }\n    }\n    editCanvasPoints.splice(0, numPointsToRemove);\n    this.editData.editIndex = editCanvasPoints.length - 1;\n}\nfunction checkForSecondCrossing(evt, isClosedContour) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { prevCanvasPoints } = this.editData;\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, canvasPos, lastCanvasPoint, isClosedContour);\n    if (!crossedLineSegment) {\n        return false;\n    }\n    return true;\n}\nfunction removePointsAfterSecondCrossing(isClosedContour) {\n    const { prevCanvasPoints, editCanvasPoints } = this.editData;\n    for (let i = editCanvasPoints.length - 1; i > 0; i--) {\n        const lastLine = [editCanvasPoints[i], editCanvasPoints[i - 1]];\n        const didCrossLine = !!getFirstLineSegmentIntersectionIndexes(prevCanvasPoints, lastLine[0], lastLine[1], isClosedContour);\n        editCanvasPoints.pop();\n        if (didCrossLine) {\n            break;\n        }\n    }\n}\nfunction findSnapIndex() {\n    const { editCanvasPoints, prevCanvasPoints, startCrossingIndex } = this.editData;\n    if (startCrossingIndex === undefined) {\n        return;\n    }\n    const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const distanceIndexPairs = [];\n    for (let i = 0; i < prevCanvasPoints.length; i++) {\n        const prevCanvasPoint = prevCanvasPoints[i];\n        const distance = vec2.distance(prevCanvasPoint, lastEditCanvasPoint);\n        distanceIndexPairs.push({ distance, index: i });\n    }\n    distanceIndexPairs.sort((a, b) => a.distance - b.distance);\n    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -1);\n    for (let i = 0; i < distanceIndexPairs.length; i++) {\n        const { index } = distanceIndexPairs[i];\n        const snapCanvasPosition = prevCanvasPoints[index];\n        const lastEditCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n        const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(editCanvasPointsLessLastOne, snapCanvasPosition, lastEditCanvasPoint, false);\n        if (!crossedLineSegment) {\n            return index;\n        }\n    }\n    return -1;\n}\nfunction checkAndRemoveCrossesOnEditLine(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPoint = lastPoints.canvas;\n    const { editCanvasPoints } = this.editData;\n    const editCanvasPointsLessLastOne = editCanvasPoints.slice(0, -2);\n    const crossedLineSegment = getFirstLineSegmentIntersectionIndexes(editCanvasPointsLessLastOne, canvasPos, lastCanvasPoint, false);\n    if (!crossedLineSegment) {\n        return;\n    }\n    const editIndexCrossed = crossedLineSegment[0];\n    const numPointsToRemove = editCanvasPoints.length - editIndexCrossed;\n    for (let i = 0; i < numPointsToRemove; i++) {\n        editCanvasPoints.pop();\n    }\n}\nfunction registerEditLoopCommon(toolInstance) {\n    toolInstance.checkForFirstCrossing = checkForFirstCrossing.bind(toolInstance);\n    toolInstance.removePointsUpUntilFirstCrossing =\n        removePointsUpUntilFirstCrossing.bind(toolInstance);\n    toolInstance.checkForSecondCrossing =\n        checkForSecondCrossing.bind(toolInstance);\n    toolInstance.findSnapIndex = findSnapIndex.bind(toolInstance);\n    toolInstance.removePointsAfterSecondCrossing =\n        removePointsAfterSecondCrossing.bind(toolInstance);\n    toolInstance.checkAndRemoveCrossesOnEditLine =\n        checkAndRemoveCrossesOnEditLine.bind(toolInstance);\n}\nexport default registerEditLoopCommon;\n","import { vec2 } from 'gl-matrix';\nexport default function findOpenUShapedContourVectorToPeak(canvasPoints, viewport) {\n    const first = canvasPoints[0];\n    const last = canvasPoints[canvasPoints.length - 1];\n    const firstToLastUnitVector = vec2.create();\n    vec2.set(firstToLastUnitVector, last[0] - first[0], last[1] - first[1]);\n    vec2.normalize(firstToLastUnitVector, firstToLastUnitVector);\n    const normalVector1 = vec2.create();\n    const normalVector2 = vec2.create();\n    vec2.set(normalVector1, -firstToLastUnitVector[1], firstToLastUnitVector[0]);\n    vec2.set(normalVector2, firstToLastUnitVector[1], -firstToLastUnitVector[0]);\n    const centerOfFirstToLast = [\n        (first[0] + last[0]) / 2,\n        (first[1] + last[1]) / 2,\n    ];\n    const furthest = {\n        dist: 0,\n        index: null,\n    };\n    for (let i = 0; i < canvasPoints.length; i++) {\n        const canvasPoint = canvasPoints[i];\n        const distance = vec2.dist(canvasPoint, centerOfFirstToLast);\n        if (distance > furthest.dist) {\n            furthest.dist = distance;\n            furthest.index = i;\n        }\n    }\n    const toFurthest = [\n        canvasPoints[furthest.index],\n        centerOfFirstToLast,\n    ];\n    const toFurthestWorld = toFurthest.map(viewport.canvasToWorld);\n    return toFurthestWorld;\n}\nexport function findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation) {\n    const { viewport } = enabledElement;\n    const canvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    return findOpenUShapedContourVectorToPeak(canvasPoints, viewport);\n}\n","import { vec3, vec2 } from 'gl-matrix';\nimport { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { resetElementCursor, hideElementCursor, } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nimport { shouldSmooth, getInterpolatedPoints, } from '../../../utilities/planarFreehandROITool/smoothPoints';\nimport triggerAnnotationRenderForViewportIds from '../../../utilities/triggerAnnotationRenderForViewportIds';\nimport updateContourPolyline from '../../../utilities/contours/updateContourPolyline';\nimport findOpenUShapedContourVectorToPeak from './findOpenUShapedContourVectorToPeak';\nimport { triggerAnnotationModified } from '../../../stateManagement/annotation/helpers/state';\nconst { addCanvasPointsToArray, getSubPixelSpacingAndXYDirections } = polyline;\nfunction activateOpenContourEdit(evt, annotation, viewportIdsToRender) {\n    this.isEditingOpen = true;\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    this.doneEditMemo();\n    const prevCanvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    this.editData = {\n        prevCanvasPoints,\n        editCanvasPoints: [canvasPos],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox: false,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);\n    hideElementCursor(element);\n}\nfunction deactivateOpenContourEdit(element) {\n    state.isInteractingWithTool = false;\n    element.removeEventListener(Events.MOUSE_UP, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.MOUSE_DRAG, this.mouseDragOpenContourEditCallback);\n    element.removeEventListener(Events.MOUSE_CLICK, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_END, this.mouseUpOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_DRAG, this.mouseDragOpenContourEditCallback);\n    element.removeEventListener(Events.TOUCH_TAP, this.mouseUpOpenContourEditCallback);\n    resetElementCursor(element);\n}\nfunction mouseDragOpenContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, element } = eventDetail;\n    const worldPos = currentPoints.world;\n    const canvasPos = currentPoints.canvas;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { viewportIdsToRender, xDir, yDir, spacing } = this.commonData;\n    const { editIndex, editCanvasPoints, startCrossingIndex } = this.editData;\n    const lastCanvasPoint = editCanvasPoints[editCanvasPoints.length - 1];\n    const lastWorldPoint = viewport.canvasToWorld(lastCanvasPoint);\n    const worldPosDiff = vec3.create();\n    this.createMemo(element, this.commonData.annotation);\n    vec3.subtract(worldPosDiff, worldPos, lastWorldPoint);\n    const xDist = Math.abs(vec3.dot(worldPosDiff, xDir));\n    const yDist = Math.abs(vec3.dot(worldPosDiff, yDir));\n    if (xDist <= spacing[0] && yDist <= spacing[1]) {\n        return;\n    }\n    if (startCrossingIndex !== undefined) {\n        this.checkAndRemoveCrossesOnEditLine(evt);\n    }\n    const numPointsAdded = addCanvasPointsToArray(element, editCanvasPoints, canvasPos, this.commonData);\n    const currentEditIndex = editIndex + numPointsAdded;\n    this.editData.editIndex = currentEditIndex;\n    if (startCrossingIndex === undefined && editCanvasPoints.length > 1) {\n        this.checkForFirstCrossing(evt, false);\n    }\n    this.editData.snapIndex = this.findSnapIndex();\n    this.editData.fusedCanvasPoints = this.fuseEditPointsWithOpenContour(evt);\n    if (startCrossingIndex !== undefined &&\n        this.checkForSecondCrossing(evt, false)) {\n        this.removePointsAfterSecondCrossing(false);\n        this.finishEditOpenOnSecondCrossing(evt);\n    }\n    else if (this.checkIfShouldOverwriteAnEnd(evt)) {\n        this.openContourEditOverwriteEnd(evt);\n    }\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction openContourEditOverwriteEnd(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const fusedCanvasPoints = this.fuseEditPointsForOpenContourEndEdit();\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: false,\n    }, viewport);\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    annotation.data.handles.activeHandleIndex = 1;\n    triggerAnnotationModified(annotation, element);\n    this.isEditingOpen = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    this.doneEditMemo();\n    this.deactivateOpenContourEdit(element);\n    this.activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, null);\n}\nfunction checkIfShouldOverwriteAnEnd(evt) {\n    const eventDetail = evt.detail;\n    const { currentPoints, lastPoints } = eventDetail;\n    const canvasPos = currentPoints.canvas;\n    const lastCanvasPos = lastPoints.canvas;\n    const { snapIndex, prevCanvasPoints, startCrossingIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return false;\n    }\n    if (snapIndex === -1) {\n        return true;\n    }\n    if (snapIndex !== 0 && snapIndex !== prevCanvasPoints.length - 1) {\n        return false;\n    }\n    const p1 = canvasPos;\n    const p2 = lastCanvasPos;\n    const p3 = prevCanvasPoints[snapIndex];\n    const a = vec2.create();\n    const b = vec2.create();\n    vec2.set(a, p1[0] - p2[0], p1[1] - p2[1]);\n    vec2.set(b, p1[0] - p3[0], p1[1] - p3[1]);\n    const aDotb = vec2.dot(a, b);\n    const magA = Math.sqrt(a[0] * a[0] + a[1] * a[1]);\n    const magB = Math.sqrt(b[0] * b[0] + b[1] * b[1]);\n    const theta = Math.acos(aDotb / (magA * magB));\n    if (theta < Math.PI / 2) {\n        return true;\n    }\n    return false;\n}\nfunction fuseEditPointsForOpenContourEndEdit() {\n    const { snapIndex, prevCanvasPoints, editCanvasPoints, startCrossingIndex } = this.editData;\n    const newCanvasPoints = [];\n    if (snapIndex === 0) {\n        for (let i = prevCanvasPoints.length - 1; i >= startCrossingIndex; i--) {\n            const canvasPoint = prevCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = 0; i < startCrossingIndex; i++) {\n            const canvasPoint = prevCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    const distanceBetweenCrossingIndexAndFirstPoint = vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[0]);\n    const distanceBetweenCrossingIndexAndLastPoint = vec2.distance(prevCanvasPoints[startCrossingIndex], editCanvasPoints[editCanvasPoints.length - 1]);\n    if (distanceBetweenCrossingIndexAndFirstPoint <\n        distanceBetweenCrossingIndexAndLastPoint) {\n        for (let i = 0; i < editCanvasPoints.length; i++) {\n            const canvasPoint = editCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = editCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = editCanvasPoints[i];\n            newCanvasPoints.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    return newCanvasPoints;\n}\nfunction fuseEditPointsWithOpenContour(evt) {\n    const { prevCanvasPoints, editCanvasPoints, startCrossingIndex, snapIndex } = this.editData;\n    if (startCrossingIndex === undefined || snapIndex === undefined) {\n        return undefined;\n    }\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const augmentedEditCanvasPoints = [...editCanvasPoints];\n    addCanvasPointsToArray(element, augmentedEditCanvasPoints, prevCanvasPoints[snapIndex], this.commonData);\n    if (augmentedEditCanvasPoints.length > editCanvasPoints.length) {\n        augmentedEditCanvasPoints.pop();\n    }\n    let lowIndex;\n    let highIndex;\n    if (startCrossingIndex > snapIndex) {\n        lowIndex = snapIndex;\n        highIndex = startCrossingIndex;\n    }\n    else {\n        lowIndex = startCrossingIndex;\n        highIndex = snapIndex;\n    }\n    const distanceBetweenLowAndFirstPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenLowAndLastPoint = vec2.distance(prevCanvasPoints[lowIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const distanceBetweenHighAndFirstPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[0]);\n    const distanceBetweenHighAndLastPoint = vec2.distance(prevCanvasPoints[highIndex], augmentedEditCanvasPoints[augmentedEditCanvasPoints.length - 1]);\n    const pointsToRender = [];\n    for (let i = 0; i < lowIndex; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    const inPlaceDistance = distanceBetweenLowAndFirstPoint + distanceBetweenHighAndLastPoint;\n    const reverseDistance = distanceBetweenLowAndLastPoint + distanceBetweenHighAndFirstPoint;\n    if (inPlaceDistance < reverseDistance) {\n        for (let i = 0; i < augmentedEditCanvasPoints.length; i++) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    else {\n        for (let i = augmentedEditCanvasPoints.length - 1; i >= 0; i--) {\n            const canvasPoint = augmentedEditCanvasPoints[i];\n            pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n        }\n    }\n    for (let i = highIndex; i < prevCanvasPoints.length; i++) {\n        const canvasPoint = prevCanvasPoints[i];\n        pointsToRender.push([canvasPoint[0], canvasPoint[1]]);\n    }\n    return pointsToRender;\n}\nfunction finishEditOpenOnSecondCrossing(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport, renderingEngine } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    const { fusedCanvasPoints, editCanvasPoints } = this.editData;\n    updateContourPolyline(annotation, {\n        points: fusedCanvasPoints,\n        closed: false,\n    }, viewport);\n    const worldPoints = annotation.data.contour.polyline;\n    annotation.data.handles.points = [\n        worldPoints[0],\n        worldPoints[worldPoints.length - 1],\n    ];\n    triggerAnnotationModified(annotation, element);\n    const lastEditCanvasPoint = editCanvasPoints.pop();\n    this.editData = {\n        prevCanvasPoints: fusedCanvasPoints,\n        editCanvasPoints: [lastEditCanvasPoint],\n        startCrossingIndex: undefined,\n        editIndex: 0,\n    };\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n}\nfunction mouseUpOpenContourEditCallback(evt) {\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    this.completeOpenContourEdit(element);\n}\nfunction completeOpenContourEdit(element) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { annotation, viewportIdsToRender } = this.commonData;\n    this.doneEditMemo();\n    const { fusedCanvasPoints, prevCanvasPoints } = this.editData;\n    if (fusedCanvasPoints) {\n        const updatedPoints = shouldSmooth(this.configuration)\n            ? getInterpolatedPoints(this.configuration, fusedCanvasPoints, prevCanvasPoints)\n            : fusedCanvasPoints;\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, {\n            points: updatedPoints,\n            closed: false,\n        }, viewport, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n        });\n        const worldPoints = annotation.data.contour.polyline;\n        annotation.data.handles.points = [\n            worldPoints[0],\n            worldPoints[worldPoints.length - 1],\n        ];\n        if (annotation.data.isOpenUShapeContour) {\n            annotation.data.openUShapeContourVectorToPeak =\n                findOpenUShapedContourVectorToPeak(fusedCanvasPoints, viewport);\n        }\n        triggerAnnotationModified(annotation, element);\n    }\n    this.isEditingOpen = false;\n    this.editData = undefined;\n    this.commonData = undefined;\n    triggerAnnotationRenderForViewportIds(viewportIdsToRender);\n    this.deactivateOpenContourEdit(element);\n}\nfunction cancelOpenContourEdit(element) {\n    this.completeOpenContourEdit(element);\n}\nfunction registerOpenContourEditLoop(toolInstance) {\n    toolInstance.activateOpenContourEdit =\n        activateOpenContourEdit.bind(toolInstance);\n    toolInstance.deactivateOpenContourEdit =\n        deactivateOpenContourEdit.bind(toolInstance);\n    toolInstance.mouseDragOpenContourEditCallback =\n        mouseDragOpenContourEditCallback.bind(toolInstance);\n    toolInstance.mouseUpOpenContourEditCallback =\n        mouseUpOpenContourEditCallback.bind(toolInstance);\n    toolInstance.fuseEditPointsWithOpenContour =\n        fuseEditPointsWithOpenContour.bind(toolInstance);\n    toolInstance.finishEditOpenOnSecondCrossing =\n        finishEditOpenOnSecondCrossing.bind(toolInstance);\n    toolInstance.checkIfShouldOverwriteAnEnd =\n        checkIfShouldOverwriteAnEnd.bind(toolInstance);\n    toolInstance.fuseEditPointsForOpenContourEndEdit =\n        fuseEditPointsForOpenContourEndEdit.bind(toolInstance);\n    toolInstance.openContourEditOverwriteEnd =\n        openContourEditOverwriteEnd.bind(toolInstance);\n    toolInstance.cancelOpenContourEdit = cancelOpenContourEdit.bind(toolInstance);\n    toolInstance.completeOpenContourEdit =\n        completeOpenContourEdit.bind(toolInstance);\n}\nexport default registerOpenContourEditLoop;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { state } from '../../../store/state';\nimport { Events } from '../../../enums';\nimport { hideElementCursor } from '../../../cursors/elementCursor';\nimport { polyline } from '../../../utilities/math';\nconst { getSubPixelSpacingAndXYDirections } = polyline;\nfunction activateOpenContourEndEdit(evt, annotation, viewportIdsToRender, handle) {\n    this.isDrawing = true;\n    const eventDetail = evt.detail;\n    const { element } = eventDetail;\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const { spacing, xDir, yDir } = getSubPixelSpacingAndXYDirections(viewport, this.configuration.subPixelResolution);\n    const canvasPoints = annotation.data.contour.polyline.map(viewport.worldToCanvas);\n    const handleIndexGrabbed = annotation.data.handles.activeHandleIndex;\n    if (handleIndexGrabbed === 0) {\n        canvasPoints.reverse();\n    }\n    let movingTextBox = false;\n    if (handle?.worldPosition) {\n        movingTextBox = true;\n    }\n    this.drawData = {\n        canvasPoints: canvasPoints,\n        polylineIndex: canvasPoints.length - 1,\n    };\n    this.commonData = {\n        annotation,\n        viewportIdsToRender,\n        spacing,\n        xDir,\n        yDir,\n        movingTextBox,\n    };\n    state.isInteractingWithTool = true;\n    element.addEventListener(Events.MOUSE_UP, this.mouseUpDrawCallback);\n    element.addEventListener(Events.MOUSE_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.MOUSE_CLICK, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_END, this.mouseUpDrawCallback);\n    element.addEventListener(Events.TOUCH_DRAG, this.mouseDragDrawCallback);\n    element.addEventListener(Events.TOUCH_TAP, this.mouseUpDrawCallback);\n    hideElementCursor(element);\n}\nfunction registerOpenContourEndEditLoop(toolInstance) {\n    toolInstance.activateOpenContourEndEdit =\n        activateOpenContourEndEdit.bind(toolInstance);\n}\nexport default registerOpenContourEndEditLoop;\n","import { drawHandles as drawHandlesSvg, drawPolyline as drawPolylineSvg, drawPath as drawPathSvg, } from '../../../drawingSvg';\nimport { polyline } from '../../../utilities/math';\nimport { findOpenUShapedContourVectorToPeakOnRender } from './findOpenUShapedContourVectorToPeak';\nimport getContourHolesDataCanvas from '../../../utilities/contours/getContourHolesDataCanvas';\nconst { pointsAreWithinCloseContourProximity } = polyline;\nfunction _getRenderingOptions(enabledElement, annotation) {\n    const styleSpecifier = {\n        toolGroupId: this.toolGroupId,\n        toolName: this.getToolName(),\n        viewportId: enabledElement.viewport.id,\n        annotationUID: annotation.annotationUID,\n    };\n    const { lineWidth, lineDash, color, fillColor, fillOpacity } = this.getAnnotationStyle({\n        annotation,\n        styleSpecifier,\n    });\n    const { closed: isClosedContour } = annotation.data.contour;\n    const options = {\n        color,\n        width: lineWidth,\n        lineDash,\n        fillColor,\n        fillOpacity,\n        closePath: isClosedContour,\n    };\n    return options;\n}\nfunction renderContour(enabledElement, svgDrawingHelper, annotation) {\n    if (!enabledElement?.viewport?.getImageData()) {\n        return;\n    }\n    if (annotation.data.contour.closed) {\n        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n    }\n    else {\n        if (annotation.data.isOpenUShapeContour) {\n            calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation);\n            this.renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation);\n        }\n        else {\n            this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n        }\n    }\n}\nfunction calculateUShapeContourVectorToPeakIfNotPresent(enabledElement, annotation) {\n    if (!annotation.data.openUShapeContourVectorToPeak) {\n        annotation.data.openUShapeContourVectorToPeak =\n            findOpenUShapedContourVectorToPeakOnRender(enabledElement, annotation);\n    }\n}\nfunction renderClosedContour(enabledElement, svgDrawingHelper, annotation) {\n    if (annotation.parentAnnotationUID) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPolyline = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const allContours = [canvasPolyline, ...childContours];\n    const polylineUID = '1';\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, allContours, options);\n}\nfunction renderOpenContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPoints = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const polylineUID = '1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, canvasPoints, options);\n    const activeHandleIndex = annotation.data.handles.activeHandleIndex;\n    if (this.configuration.alwaysRenderOpenContourHandles?.enabled === true) {\n        const radius = this.configuration.alwaysRenderOpenContourHandles.radius;\n        const handleGroupUID = '0';\n        const handlePoints = [\n            canvasPoints[0],\n            canvasPoints[canvasPoints.length - 1],\n        ];\n        if (activeHandleIndex === 0) {\n            handlePoints.shift();\n        }\n        else if (activeHandleIndex === 1) {\n            handlePoints.pop();\n        }\n        drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, handlePoints, {\n            color: options.color,\n            handleRadius: radius,\n        });\n    }\n    if (activeHandleIndex !== null) {\n        const handleGroupUID = '1';\n        const indexOfCanvasPoints = activeHandleIndex === 0 ? 0 : canvasPoints.length - 1;\n        const handlePoint = canvasPoints[indexOfCanvasPoints];\n        drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [handlePoint], { color: options.color });\n    }\n}\nfunction renderOpenUShapedContour(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const { openUShapeContourVectorToPeak } = annotation.data;\n    const { polyline } = annotation.data.contour;\n    this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n    if (!openUShapeContourVectorToPeak) {\n        return;\n    }\n    const firstCanvasPoint = viewport.worldToCanvas(polyline[0]);\n    const lastCanvasPoint = viewport.worldToCanvas(polyline[polyline.length - 1]);\n    const openUShapeContourVectorToPeakCanvas = [\n        viewport.worldToCanvas(openUShapeContourVectorToPeak[0]),\n        viewport.worldToCanvas(openUShapeContourVectorToPeak[1]),\n    ];\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, 'first-to-last', [firstCanvasPoint, lastCanvasPoint], {\n        color: options.color,\n        width: options.width,\n        closePath: false,\n        lineDash: '2,2',\n    });\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, 'midpoint-to-open-contour', [\n        openUShapeContourVectorToPeakCanvas[0],\n        openUShapeContourVectorToPeakCanvas[1],\n    ], {\n        color: options.color,\n        width: options.width,\n        closePath: false,\n        lineDash: '2,2',\n    });\n}\nfunction renderContourBeingDrawn(enabledElement, svgDrawingHelper, annotation) {\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const { allowOpenContours } = this.configuration;\n    const { canvasPoints } = this.drawData;\n    options.closePath = false;\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, '1', canvasPoints, options);\n    if (allowOpenContours) {\n        const firstPoint = canvasPoints[0];\n        const lastPoint = canvasPoints[canvasPoints.length - 1];\n        if (pointsAreWithinCloseContourProximity(firstPoint, lastPoint, this.configuration.closeContourProximity)) {\n            drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, '2', [lastPoint, firstPoint], options);\n        }\n        else {\n            const handleGroupUID = '0';\n            drawHandlesSvg(svgDrawingHelper, annotation.annotationUID, handleGroupUID, [firstPoint], { color: options.color, handleRadius: 2 });\n        }\n    }\n}\nfunction renderClosedContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {\n    const { viewport } = enabledElement;\n    const { fusedCanvasPoints } = this.editData;\n    if (fusedCanvasPoints === undefined) {\n        this.renderClosedContour(enabledElement, svgDrawingHelper, annotation);\n        return;\n    }\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const allContours = [fusedCanvasPoints, ...childContours];\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const polylineUIDToRender = 'preview-1';\n    if (annotation.parentAnnotationUID && options.fillOpacity) {\n        options.fillOpacity = 0;\n    }\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, allContours, options);\n}\nfunction renderOpenContourBeingEdited(enabledElement, svgDrawingHelper, annotation) {\n    const { fusedCanvasPoints } = this.editData;\n    if (fusedCanvasPoints === undefined) {\n        this.renderOpenContour(enabledElement, svgDrawingHelper, annotation);\n        return;\n    }\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const polylineUIDToRender = 'preview-1';\n    drawPolylineSvg(svgDrawingHelper, annotation.annotationUID, polylineUIDToRender, fusedCanvasPoints, options);\n}\nfunction renderPointContourWithMarker(enabledElement, svgDrawingHelper, annotation) {\n    if (annotation.parentAnnotationUID) {\n        return;\n    }\n    const { viewport } = enabledElement;\n    const options = this._getRenderingOptions(enabledElement, annotation);\n    const canvasPolyline = annotation.data.contour.polyline.map((worldPos) => viewport.worldToCanvas(worldPos));\n    const childContours = getContourHolesDataCanvas(annotation, viewport);\n    const polylineUID = '1';\n    const center = canvasPolyline[0];\n    const radius = 6;\n    const numberOfPoints = 100;\n    const circlePoints = [];\n    for (let i = 0; i < numberOfPoints; i++) {\n        const angle = (i / numberOfPoints) * 2 * Math.PI;\n        const x = center[0] + radius * Math.cos(angle);\n        const y = center[1] + radius * Math.sin(angle);\n        circlePoints.push([x, y]);\n    }\n    const crosshair = [\n        [center[0] - radius * 2, center[1]],\n        [center[0] + radius * 2, center[1]],\n        [center[0], center[1] - radius * 2],\n        [center[0], center[1] + radius * 2],\n    ];\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID + '-crosshair_v', [crosshair[0], crosshair[1]], options);\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID + '-crosshair_h', [crosshair[2], crosshair[3]], options);\n    const allContours = [circlePoints, ...childContours];\n    drawPathSvg(svgDrawingHelper, annotation.annotationUID, polylineUID, allContours, options);\n}\nfunction registerRenderMethods(toolInstance) {\n    toolInstance.renderContour = renderContour.bind(toolInstance);\n    toolInstance.renderClosedContour = renderClosedContour.bind(toolInstance);\n    toolInstance.renderOpenContour = renderOpenContour.bind(toolInstance);\n    toolInstance.renderPointContourWithMarker =\n        renderPointContourWithMarker.bind(toolInstance);\n    toolInstance.renderOpenUShapedContour =\n        renderOpenUShapedContour.bind(toolInstance);\n    toolInstance.renderContourBeingDrawn =\n        renderContourBeingDrawn.bind(toolInstance);\n    toolInstance.renderClosedContourBeingEdited =\n        renderClosedContourBeingEdited.bind(toolInstance);\n    toolInstance.renderOpenContourBeingEdited =\n        renderOpenContourBeingEdited.bind(toolInstance);\n    toolInstance._getRenderingOptions = _getRenderingOptions.bind(toolInstance);\n}\nexport default registerRenderMethods;\n","import { BaseVolumeViewport, cache, getEnabledElement, metaData, utilities as csUtils, StackViewport, } from '@cornerstonejs/core';\nimport { vec2 } from 'gl-matrix';\nimport AnnotationDisplayTool from './AnnotationDisplayTool';\nimport { isAnnotationLocked } from '../../stateManagement/annotation/annotationLocking';\nimport { isAnnotationVisible } from '../../stateManagement/annotation/annotationVisibility';\nimport { addAnnotation, removeAnnotation, getAnnotation, } from '../../stateManagement/annotation/annotationState';\nimport { triggerAnnotationModified } from '../../stateManagement/annotation/helpers/state';\nimport ChangeTypes from '../../enums/ChangeTypes';\nimport { setAnnotationSelected } from '../../stateManagement/annotation/annotationSelection';\nimport { addContourSegmentationAnnotation } from '../../utilities/contourSegmentation';\nconst { DefaultHistoryMemo } = csUtils.HistoryMemo;\nconst { PointsManager } = csUtils;\nclass AnnotationTool extends AnnotationDisplayTool {\n    static createAnnotationForViewport(viewport, ...annotationBaseData) {\n        return this.createAnnotation({ metadata: viewport.getViewReference() }, ...annotationBaseData);\n    }\n    static createAndAddAnnotation(viewport, ...annotationBaseData) {\n        const annotation = this.createAnnotationForViewport(viewport, ...annotationBaseData);\n        addAnnotation(annotation, viewport.element);\n        triggerAnnotationModified(annotation, viewport.element);\n    }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        this.mouseMoveCallback = (evt, filteredAnnotations) => {\n            if (!filteredAnnotations) {\n                return false;\n            }\n            const { element, currentPoints } = evt.detail;\n            const canvasCoords = currentPoints.canvas;\n            let annotationsNeedToBeRedrawn = false;\n            for (const annotation of filteredAnnotations) {\n                if (isAnnotationLocked(annotation.annotationUID) ||\n                    !isAnnotationVisible(annotation.annotationUID)) {\n                    continue;\n                }\n                const { data } = annotation;\n                const activateHandleIndex = data.handles\n                    ? data.handles.activeHandleIndex\n                    : undefined;\n                const near = this._imagePointNearToolOrHandle(element, annotation, canvasCoords, 6);\n                const nearToolAndNotMarkedActive = near && !annotation.highlighted;\n                const notNearToolAndMarkedActive = !near && annotation.highlighted;\n                if (nearToolAndNotMarkedActive || notNearToolAndMarkedActive) {\n                    annotation.highlighted = !annotation.highlighted;\n                    annotationsNeedToBeRedrawn = true;\n                }\n                else if (data.handles &&\n                    data.handles.activeHandleIndex !== activateHandleIndex) {\n                    annotationsNeedToBeRedrawn = true;\n                }\n            }\n            return annotationsNeedToBeRedrawn;\n        };\n        this.isSuvScaled = AnnotationTool.isSuvScaled;\n        if (toolProps.configuration?.getTextLines) {\n            this.configuration.getTextLines = toolProps.configuration.getTextLines;\n        }\n        if (toolProps.configuration?.statsCalculator) {\n            this.configuration.statsCalculator =\n                toolProps.configuration.statsCalculator;\n        }\n    }\n    getHandleNearImagePoint(element, annotation, canvasCoords, proximity) {\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        const { data } = annotation;\n        const { isCanvasAnnotation } = data;\n        const { points, textBox } = data.handles;\n        if (textBox) {\n            const { worldBoundingBox } = textBox;\n            if (worldBoundingBox) {\n                const canvasBoundingBox = {\n                    topLeft: viewport.worldToCanvas(worldBoundingBox.topLeft),\n                    topRight: viewport.worldToCanvas(worldBoundingBox.topRight),\n                    bottomLeft: viewport.worldToCanvas(worldBoundingBox.bottomLeft),\n                    bottomRight: viewport.worldToCanvas(worldBoundingBox.bottomRight),\n                };\n                if (canvasCoords[0] >= canvasBoundingBox.topLeft[0] &&\n                    canvasCoords[0] <= canvasBoundingBox.bottomRight[0] &&\n                    canvasCoords[1] >= canvasBoundingBox.topLeft[1] &&\n                    canvasCoords[1] <= canvasBoundingBox.bottomRight[1]) {\n                    data.handles.activeHandleIndex = null;\n                    return textBox;\n                }\n            }\n        }\n        for (let i = 0; i < points?.length; i++) {\n            const point = points[i];\n            const annotationCanvasCoordinate = isCanvasAnnotation\n                ? point.slice(0, 2)\n                : viewport.worldToCanvas(point);\n            const near = vec2.distance(canvasCoords, annotationCanvasCoordinate) < proximity;\n            if (near === true) {\n                data.handles.activeHandleIndex = i;\n                return point;\n            }\n        }\n        data.handles.activeHandleIndex = null;\n    }\n    getLinkedTextBoxStyle(specifications, annotation) {\n        return {\n            visibility: this.getStyle('textBoxVisibility', specifications, annotation),\n            fontFamily: this.getStyle('textBoxFontFamily', specifications, annotation),\n            fontSize: this.getStyle('textBoxFontSize', specifications, annotation),\n            color: this.getStyle('textBoxColor', specifications, annotation),\n            shadow: this.getStyle('textBoxShadow', specifications, annotation),\n            background: this.getStyle('textBoxBackground', specifications, annotation),\n            lineWidth: this.getStyle('textBoxLinkLineWidth', specifications, annotation),\n            lineDash: this.getStyle('textBoxLinkLineDash', specifications, annotation),\n        };\n    }\n    static isSuvScaled(viewport, targetId, imageId) {\n        if (viewport instanceof BaseVolumeViewport) {\n            const volumeId = csUtils.getVolumeId(targetId);\n            const volume = cache.getVolume(volumeId);\n            return volume?.scaling?.PT !== undefined;\n        }\n        const scalingModule = imageId && metaData.get('scalingModule', imageId);\n        return typeof scalingModule?.suvbw === 'number';\n    }\n    getAnnotationStyle(context) {\n        const { annotation, styleSpecifier } = context;\n        const getStyle = (property) => this.getStyle(property, styleSpecifier, annotation);\n        const { annotationUID } = annotation;\n        const visibility = isAnnotationVisible(annotationUID);\n        const locked = isAnnotationLocked(annotationUID);\n        const lineWidth = getStyle('lineWidth');\n        const lineDash = getStyle('lineDash');\n        const angleArcLineDash = getStyle('angleArcLineDash');\n        const color = getStyle('color');\n        const markerSize = getStyle('markerSize');\n        const shadow = getStyle('shadow');\n        const textboxStyle = this.getLinkedTextBoxStyle(styleSpecifier, annotation);\n        return {\n            visibility,\n            locked,\n            color,\n            lineWidth,\n            lineDash,\n            lineOpacity: 1,\n            fillColor: color,\n            fillOpacity: 0,\n            shadow,\n            textbox: textboxStyle,\n            markerSize,\n            angleArcLineDash,\n        };\n    }\n    _imagePointNearToolOrHandle(element, annotation, canvasCoords, proximity) {\n        const handleNearImagePoint = this.getHandleNearImagePoint(element, annotation, canvasCoords, proximity);\n        if (handleNearImagePoint) {\n            return true;\n        }\n        const toolNewImagePoint = this.isPointNearTool(element, annotation, canvasCoords, proximity, 'mouse');\n        if (toolNewImagePoint) {\n            return true;\n        }\n    }\n    static createAnnotationState(annotation, deleting) {\n        const { data, annotationUID } = annotation;\n        const cloneData = {\n            ...data,\n            cachedStats: {},\n        };\n        delete cloneData.contour;\n        delete cloneData.spline;\n        const state = {\n            annotationUID,\n            data: structuredClone(cloneData),\n            deleting,\n        };\n        const contour = data.contour;\n        if (contour) {\n            state.data.contour = {\n                ...contour,\n                polyline: null,\n                pointsManager: PointsManager.create3(contour.polyline.length, contour.polyline),\n            };\n        }\n        return state;\n    }\n    static createAnnotationMemo(element, annotation, options) {\n        if (!annotation) {\n            return;\n        }\n        const { newAnnotation, deleting = newAnnotation ? false : undefined } = options || {};\n        const { annotationUID } = annotation;\n        const state = AnnotationTool.createAnnotationState(annotation, deleting);\n        const annotationMemo = {\n            restoreMemo: () => {\n                const newState = AnnotationTool.createAnnotationState(annotation, deleting);\n                const { viewport } = getEnabledElement(element) || {};\n                viewport?.setViewReference(annotation.metadata);\n                if (state.deleting === true) {\n                    state.deleting = false;\n                    Object.assign(annotation.data, state.data);\n                    if (annotation.data.contour) {\n                        const annotationData = annotation.data;\n                        annotationData.contour.polyline = state.data.contour.pointsManager.points;\n                        delete state.data.contour.pointsManager;\n                        if (annotationData.segmentation) {\n                            addContourSegmentationAnnotation(annotation);\n                        }\n                    }\n                    state.data = newState.data;\n                    addAnnotation(annotation, element);\n                    setAnnotationSelected(annotation.annotationUID, true);\n                    viewport?.render();\n                    return;\n                }\n                if (state.deleting === false) {\n                    state.deleting = true;\n                    state.data = newState.data;\n                    setAnnotationSelected(annotation.annotationUID);\n                    removeAnnotation(annotation.annotationUID);\n                    viewport?.render();\n                    return;\n                }\n                const currentAnnotation = getAnnotation(annotationUID);\n                if (!currentAnnotation) {\n                    console.warn('No current annotation');\n                    return;\n                }\n                Object.assign(currentAnnotation.data, state.data);\n                if (currentAnnotation.data.contour) {\n                    currentAnnotation.data\n                        .contour.polyline = state.data.contour.pointsManager.points;\n                }\n                state.data = newState.data;\n                currentAnnotation.invalidated = true;\n                triggerAnnotationModified(currentAnnotation, element, ChangeTypes.History);\n            },\n            id: annotationUID,\n            operationType: 'annotation',\n        };\n        DefaultHistoryMemo.push(annotationMemo);\n        return annotationMemo;\n    }\n    createMemo(element, annotation, options) {\n        this.memo ||= AnnotationTool.createAnnotationMemo(element, annotation, options);\n    }\n    startGroupRecording() {\n        DefaultHistoryMemo.startGroupRecording();\n    }\n    endGroupRecording() {\n        DefaultHistoryMemo.endGroupRecording();\n    }\n    static hydrateBase(ToolClass, enabledElement, points, options = {}) {\n        if (!enabledElement) {\n            return null;\n        }\n        const { viewport } = enabledElement;\n        const FrameOfReferenceUID = viewport.getFrameOfReferenceUID();\n        const camera = viewport.getCamera();\n        const viewPlaneNormal = options.viewplaneNormal ?? camera.viewPlaneNormal;\n        const viewUp = options.viewUp ?? camera.viewUp;\n        const instance = options.toolInstance || new ToolClass();\n        let referencedImageId;\n        let finalViewPlaneNormal = viewPlaneNormal;\n        let finalViewUp = viewUp;\n        if (options.referencedImageId) {\n            referencedImageId = options.referencedImageId;\n            finalViewPlaneNormal = undefined;\n            finalViewUp = undefined;\n        }\n        else {\n            if (viewport instanceof StackViewport) {\n                const closestImageIndex = csUtils.getClosestStackImageIndexForPoint(points[0], viewport);\n                if (closestImageIndex !== undefined) {\n                    referencedImageId = viewport.getImageIds()[closestImageIndex];\n                }\n            }\n            else if (viewport instanceof BaseVolumeViewport) {\n                referencedImageId = instance.getReferencedImageId(viewport, points[0], viewPlaneNormal, viewUp);\n            }\n            else {\n                throw new Error('Unsupported viewport type');\n            }\n        }\n        return {\n            FrameOfReferenceUID,\n            referencedImageId,\n            viewPlaneNormal: finalViewPlaneNormal,\n            viewUp: finalViewUp,\n            instance,\n            viewport,\n        };\n    }\n}\nAnnotationTool.toolName = 'AnnotationTool';\nexport default AnnotationTool;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { addAnnotation, getAnnotations, getChildAnnotations, } from '../../stateManagement/annotation/annotationState';\nimport { drawPath as drawPathSvg } from '../../drawingSvg';\nimport AnnotationTool from './AnnotationTool';\nimport updateContourPolyline from '../../utilities/contours/updateContourPolyline';\nimport getContourHolesDataCanvas from '../../utilities/contours/getContourHolesDataCanvas';\nclass ContourBaseTool extends AnnotationTool {\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n    }\n    renderAnnotation(enabledElement, svgDrawingHelper) {\n        let renderStatus = false;\n        const { viewport } = enabledElement;\n        const { element } = viewport;\n        if (!viewport.getRenderingEngine()) {\n            console.warn('Rendering Engine has been destroyed');\n            return renderStatus;\n        }\n        let annotations = getAnnotations(this.getToolName(), element);\n        if (!annotations?.length) {\n            return renderStatus;\n        }\n        annotations = this.filterInteractableAnnotationsForElement(element, annotations);\n        if (!annotations?.length) {\n            return renderStatus;\n        }\n        const targetId = this.getTargetId(viewport);\n        const styleSpecifier = {\n            toolGroupId: this.toolGroupId,\n            toolName: this.getToolName(),\n            viewportId: enabledElement.viewport.id,\n        };\n        for (let i = 0; i < annotations.length; i++) {\n            const annotation = annotations[i];\n            styleSpecifier.annotationUID = annotation.annotationUID;\n            const annotationStyle = this.getAnnotationStyle({\n                annotation,\n                styleSpecifier,\n            });\n            if (!annotationStyle.visibility) {\n                continue;\n            }\n            const annotationRendered = this.renderAnnotationInstance({\n                enabledElement,\n                targetId,\n                annotation,\n                annotationStyle,\n                svgDrawingHelper,\n            });\n            renderStatus ||= annotationRendered;\n            annotation.invalidated = false;\n        }\n        return renderStatus;\n    }\n    createAnnotation(evt) {\n        const annotation = super.createAnnotation(evt);\n        Object.assign(annotation.data, {\n            contour: {\n                polyline: [],\n                closed: false,\n            },\n        });\n        Object.assign(annotation, {\n            interpolationUID: '',\n            autoGenerated: false,\n        });\n        return annotation;\n    }\n    addAnnotation(annotation, element) {\n        return addAnnotation(annotation, element);\n    }\n    cancelAnnotation(annotation) {\n    }\n    moveAnnotation(annotation, worldPosDelta) {\n        const { points } = annotation.data.handles;\n        for (let i = 0, numPoints = points.length; i < numPoints; i++) {\n            const point = points[i];\n            point[0] += worldPosDelta[0];\n            point[1] += worldPosDelta[1];\n            point[2] += worldPosDelta[2];\n        }\n        annotation.invalidated = true;\n        getChildAnnotations(annotation).forEach((childAnnotation) => this.moveAnnotation(childAnnotation, worldPosDelta));\n    }\n    updateContourPolyline(annotation, polylineData, transforms, options) {\n        const decimateConfig = this.configuration?.decimate || {};\n        updateContourPolyline(annotation, polylineData, transforms, {\n            decimate: {\n                enabled: !!decimateConfig.enabled,\n                epsilon: decimateConfig.epsilon,\n            },\n            updateWindingDirection: options?.updateWindingDirection,\n        });\n    }\n    getPolylinePoints(annotation) {\n        return annotation.data.contour?.polyline ?? annotation.data.polyline;\n    }\n    renderAnnotationInstance(renderContext) {\n        const { enabledElement, annotationStyle, svgDrawingHelper } = renderContext;\n        const annotation = renderContext.annotation;\n        if (annotation.parentAnnotationUID) {\n            return;\n        }\n        const { annotationUID } = annotation;\n        const { viewport } = enabledElement;\n        const { worldToCanvas } = viewport;\n        const polylineCanvasPoints = this.getPolylinePoints(annotation).map((point) => worldToCanvas(point));\n        const { lineWidth, lineDash, color, fillColor, fillOpacity } = annotationStyle;\n        const childContours = getContourHolesDataCanvas(annotation, viewport);\n        const allContours = [polylineCanvasPoints, ...childContours];\n        drawPathSvg(svgDrawingHelper, annotationUID, 'contourPolyline', allContours, {\n            color: color,\n            lineDash: lineDash,\n            lineWidth: Math.max(0.1, lineWidth),\n            fillColor: fillColor,\n            fillOpacity: fillOpacity,\n        });\n        return true;\n    }\n}\nexport { ContourBaseTool as default, ContourBaseTool };\n","import { getEnabledElement, utilities } from '@cornerstonejs/core';\nimport { SegmentationRepresentations } from '../../enums';\nimport ContourBaseTool from './ContourBaseTool';\nimport { triggerSegmentationDataModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport InterpolationManager from '../../utilities/segmentation/InterpolationManager/InterpolationManager';\nimport { addContourSegmentationAnnotation, removeContourSegmentationAnnotation, } from '../../utilities/contourSegmentation';\nimport { triggerAnnotationRenderForToolGroupIds } from '../../utilities/triggerAnnotationRenderForToolGroupIds';\nimport { getToolGroupForViewport } from '../../store/ToolGroupManager';\nimport { getSegmentationRepresentations } from '../../stateManagement/segmentation/getSegmentationRepresentation';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getViewportIdsWithSegmentation } from '../../stateManagement/segmentation/getViewportIdsWithSegmentation';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getLockedSegmentIndices } from '../../stateManagement/segmentation/segmentLocking';\nimport { getSVGStyleForSegment } from '../../utilities/segmentation/getSVGStyleForSegment';\nimport { defaultSegmentationStateManager } from '../../stateManagement/segmentation/SegmentationStateManager';\nclass ContourSegmentationBaseTool extends ContourBaseTool {\n    static { this.PreviewSegmentIndex = 255; }\n    constructor(toolProps, defaultToolProps) {\n        super(toolProps, defaultToolProps);\n        if (this.configuration.interpolation?.enabled) {\n            InterpolationManager.addTool(this.getToolName());\n        }\n    }\n    onSetToolConfiguration() {\n        if (this.configuration.interpolation?.enabled) {\n            InterpolationManager.addTool(this.getToolName());\n        }\n        else {\n            InterpolationManager.removeTool(this.getToolName());\n        }\n    }\n    isContourSegmentationTool() {\n        return true;\n    }\n    createAnnotation(evt) {\n        const eventDetail = evt.detail;\n        const { element } = eventDetail;\n        const enabledElement = getEnabledElement(element);\n        if (!enabledElement) {\n            return;\n        }\n        const { viewport } = enabledElement;\n        const contourAnnotation = super.createAnnotation(evt);\n        if (!this.isContourSegmentationTool()) {\n            return contourAnnotation;\n        }\n        const activeSeg = getActiveSegmentation(viewport.id);\n        if (!activeSeg) {\n            throw new Error('No active segmentation detected, create one before using scissors tool');\n        }\n        if (!activeSeg.representationData.Contour) {\n            throw new Error(`A contour segmentation must be active`);\n        }\n        const { segmentationId } = activeSeg;\n        const segmentIndex = getActiveSegmentIndex(segmentationId);\n        return utilities.deepMerge(contourAnnotation, {\n            data: {\n                segmentation: {\n                    segmentationId,\n                    segmentIndex,\n                },\n            },\n        });\n    }\n    addAnnotation(annotation, element) {\n        const annotationUID = super.addAnnotation(annotation, element);\n        if (this.isContourSegmentationTool()) {\n            const contourSegAnnotation = annotation;\n            addContourSegmentationAnnotation(contourSegAnnotation);\n        }\n        return annotationUID;\n    }\n    cancelAnnotation(annotation) {\n        if (this.isContourSegmentationTool()) {\n            removeContourSegmentationAnnotation(annotation);\n        }\n        super.cancelAnnotation(annotation);\n    }\n    getAnnotationStyle(context) {\n        const annotationStyle = super.getAnnotationStyle(context);\n        if (!this.isContourSegmentationTool()) {\n            return annotationStyle;\n        }\n        const contourSegmentationStyle = this._getContourSegmentationStyle(context);\n        return utilities.deepMerge(annotationStyle, contourSegmentationStyle);\n    }\n    renderAnnotationInstance(renderContext) {\n        const { annotation } = renderContext;\n        const { invalidated } = annotation;\n        const renderResult = super.renderAnnotationInstance(renderContext);\n        if (invalidated && this.isContourSegmentationTool()) {\n            const { segmentationId } = (annotation).data.segmentation;\n            triggerSegmentationDataModified(segmentationId);\n            const viewportIds = getViewportIdsWithSegmentation(segmentationId);\n            const toolGroupIds = viewportIds.map((viewportId) => {\n                const toolGroup = getToolGroupForViewport(viewportId);\n                return toolGroup.id;\n            });\n            triggerAnnotationRenderForToolGroupIds(toolGroupIds);\n        }\n        return renderResult;\n    }\n    filterInteractableAnnotationsForElement(element, annotations) {\n        if (!annotations || !annotations.length) {\n            return;\n        }\n        const baseFilteredAnnotations = super.filterInteractableAnnotationsForElement(element, annotations);\n        if (!baseFilteredAnnotations || !baseFilteredAnnotations.length) {\n            return;\n        }\n        const enabledElement = getEnabledElement(element);\n        const { viewport } = enabledElement;\n        return baseFilteredAnnotations.filter((annotation) => {\n            const segmentationId = annotation?.data\n                ?.segmentation?.segmentationId;\n            if (!segmentationId) {\n                return true;\n            }\n            return !!defaultSegmentationStateManager.getSegmentationRepresentation(viewport.id, {\n                segmentationId,\n                type: SegmentationRepresentations.Contour,\n            });\n        });\n    }\n    _getContourSegmentationStyle(context) {\n        const annotation = context.annotation;\n        const { segmentationId, segmentIndex } = annotation.data.segmentation;\n        const { viewportId } = context.styleSpecifier;\n        const segmentationRepresentations = getSegmentationRepresentations(viewportId, { segmentationId });\n        if (!segmentationRepresentations?.length) {\n            return {};\n        }\n        let segmentationRepresentation;\n        if (segmentationRepresentations.length > 1) {\n            segmentationRepresentation = segmentationRepresentations.find((rep) => rep.segmentationId === segmentationId &&\n                rep.type === SegmentationRepresentations.Contour);\n        }\n        else {\n            segmentationRepresentation = segmentationRepresentations[0];\n        }\n        const { autoGenerated } = annotation;\n        const segmentsLocked = getLockedSegmentIndices(segmentationId);\n        const annotationLocked = segmentsLocked.includes(segmentIndex);\n        const { color, fillColor, lineWidth, fillOpacity, lineDash, visibility } = getSVGStyleForSegment({\n            segmentationId,\n            segmentIndex,\n            viewportId,\n            autoGenerated,\n        });\n        return {\n            color,\n            fillColor,\n            lineWidth,\n            fillOpacity,\n            lineDash,\n            textbox: {\n                color,\n            },\n            visibility,\n            locked: annotationLocked,\n        };\n    }\n}\nexport { ContourSegmentationBaseTool as default, ContourSegmentationBaseTool };\n","const defaultContourConfig = {\n    renderOutline: true,\n    outlineWidthAutoGenerated: 3,\n    outlineWidth: 1,\n    outlineWidthInactive: 1,\n    outlineOpacity: 1,\n    outlineOpacityInactive: 0.85,\n    outlineDash: undefined,\n    outlineDashInactive: undefined,\n    outlineDashAutoGenerated: '5,3',\n    activeSegmentOutlineWidthDelta: 0,\n    renderFill: true,\n    fillAlpha: 0.5,\n    fillAlphaInactive: 0.3,\n    fillAlphaAutoGenerated: 0.3,\n};\nfunction getDefaultContourStyle() {\n    return defaultContourConfig;\n}\nexport default getDefaultContourStyle;\n","import { addAnnotation } from '../../../../stateManagement/annotation/annotationState';\nimport { cache, utilities } from '@cornerstonejs/core';\nimport { getClosestImageIdForStackViewport } from '../../../../utilities/annotationHydration';\nimport { addContourSegmentationAnnotation } from '../../../../utilities/contourSegmentation';\nimport { validateGeometry } from './utils';\nimport { SegmentationRepresentations } from '../../../../enums';\nimport { segmentationStyle } from '../../../../stateManagement/segmentation/SegmentationStyle';\nfunction handleContourSegmentation(viewport, geometryIds, annotationUIDsMap, contourRepresentation) {\n    if (annotationUIDsMap.size) {\n        viewport.render();\n    }\n    else {\n        addContourSetsToElement(viewport, geometryIds, contourRepresentation);\n    }\n}\nfunction addContourSetsToElement(viewport, geometryIds, contourRepresentation) {\n    const { segmentationId } = contourRepresentation;\n    const segmentSpecificMap = new Map();\n    geometryIds.forEach((geometryId) => {\n        const geometry = cache.getGeometry(geometryId);\n        if (!geometry) {\n            console.warn(`No geometry found for geometryId ${geometryId}. Skipping render.`);\n            return;\n        }\n        const segmentIndex = geometry.data.segmentIndex;\n        validateGeometry(geometry);\n        const segmentSpecificConfig = segmentationStyle.getStyle({\n            viewportId: viewport.id,\n            segmentationId,\n            type: SegmentationRepresentations.Contour,\n            segmentIndex,\n        });\n        const contourSet = geometry.data;\n        const viewPlaneNormal = viewport.getCamera().viewPlaneNormal;\n        contourSet.contours.forEach((contour) => {\n            const { points, color, id } = contour;\n            const referencedImageId = getClosestImageIdForStackViewport(viewport, points[0], viewPlaneNormal);\n            const contourSegmentationAnnotation = {\n                annotationUID: utilities.uuidv4(),\n                data: {\n                    contour: {\n                        closed: true,\n                        polyline: points,\n                    },\n                    segmentation: {\n                        segmentationId,\n                        segmentIndex,\n                        color,\n                        id,\n                    },\n                    handles: {},\n                },\n                handles: {},\n                highlighted: false,\n                autoGenerated: false,\n                invalidated: false,\n                isLocked: true,\n                isVisible: true,\n                metadata: {\n                    referencedImageId,\n                    toolName: 'PlanarFreehandContourSegmentationTool',\n                    FrameOfReferenceUID: viewport.getFrameOfReferenceUID(),\n                    viewPlaneNormal: viewport.getCamera().viewPlaneNormal,\n                },\n            };\n            const annotationGroupSelector = viewport.element;\n            addAnnotation(contourSegmentationAnnotation, annotationGroupSelector);\n            addContourSegmentationAnnotation(contourSegmentationAnnotation);\n        });\n        if (segmentSpecificConfig) {\n            segmentSpecificMap.set(segmentIndex, segmentSpecificConfig);\n        }\n    });\n    viewport.render();\n}\nexport { handleContourSegmentation, addContourSetsToElement };\n","import { Enums } from '@cornerstonejs/core';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport vtkPoints from '@kitware/vtk.js/Common/Core/Points';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nexport function validateGeometry(geometry) {\n    if (!geometry) {\n        throw new Error(`No contours found for geometryId ${geometry.id}`);\n    }\n    const geometryId = geometry.id;\n    if (geometry.type !== Enums.GeometryType.CONTOUR) {\n        throw new Error(`Geometry type ${geometry.type} not supported for rendering.`);\n    }\n    if (!geometry.data) {\n        console.warn(`No contours found for geometryId ${geometryId}. Skipping render.`);\n        return;\n    }\n}\nexport function getPolyData(contourSet) {\n    const pointArray = [];\n    const points = vtkPoints.newInstance();\n    const lines = vtkCellArray.newInstance();\n    let pointIndex = 0;\n    contourSet.contours.forEach((contour) => {\n        const pointList = contour.points;\n        const flatPoints = contour.flatPointsArray;\n        const type = contour.type;\n        const pointIndexes = pointList.map((_, pointListIndex) => pointListIndex + pointIndex);\n        if (type === Enums.ContourType.CLOSED_PLANAR) {\n            pointIndexes.push(pointIndexes[0]);\n        }\n        const linePoints = Float32Array.from(flatPoints);\n        pointArray.push(...linePoints);\n        lines.insertNextCell([...pointIndexes]);\n        pointIndex = pointIndex + pointList.length;\n    });\n    points.setData(pointArray, 3);\n    const polygon = vtkPolyData.newInstance();\n    polygon.setPoints(points);\n    polygon.setLines(lines);\n    return polygon;\n}\n","import { cache, Enums, convertMapperToNotSharedMapper, volumeLoader, eventTarget, createVolumeActor, } from '@cornerstonejs/core';\nimport { Events, SegmentationRepresentations } from '../../../enums';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nconst internalCache = new Map();\nconst load = ({ cfun, ofun, actor }) => {\n    actor.getProperty().setRGBTransferFunction(1, cfun);\n    actor.getProperty().setScalarOpacity(1, ofun);\n};\nexport async function addVolumesAsIndependentComponents({ viewport, volumeInputs, segmentationId, }) {\n    const defaultActor = viewport.getDefaultActor();\n    const { actor } = defaultActor;\n    const { uid, callback } = defaultActor;\n    const referenceVolumeId = viewport.getVolumeId();\n    if (internalCache.get(uid)?.added) {\n        return {\n            uid,\n            actor,\n        };\n    }\n    const volumeInputArray = volumeInputs;\n    const firstImageVolume = cache.getVolume(volumeInputArray[0].volumeId);\n    if (!firstImageVolume) {\n        throw new Error(`imageVolume with id: ${firstImageVolume.volumeId} does not exist`);\n    }\n    const { volumeId } = volumeInputArray[0];\n    const segImageVolume = await volumeLoader.loadVolume(volumeId);\n    if (!segImageVolume) {\n        throw new Error(`segImageVolume with id: ${segImageVolume.volumeId} does not exist`);\n    }\n    const segVoxelManager = segImageVolume.voxelManager;\n    const segData = segVoxelManager.getCompleteScalarDataArray();\n    const { imageData: segImageData } = segImageVolume;\n    const baseVolume = cache.getVolume(referenceVolumeId);\n    const baseVoxelManager = baseVolume.voxelManager;\n    const baseData = baseVoxelManager.getCompleteScalarDataArray();\n    const newComp = 2;\n    const cubeData = new Float32Array(newComp * baseVolume.voxelManager.getScalarDataLength());\n    const dims = segImageData.getDimensions();\n    for (let z = 0; z < dims[2]; ++z) {\n        for (let y = 0; y < dims[1]; ++y) {\n            for (let x = 0; x < dims[0]; ++x) {\n                const iTuple = x + dims[0] * (y + dims[1] * z);\n                cubeData[iTuple * newComp + 0] = baseData[iTuple];\n                cubeData[iTuple * newComp + 1] = segData[iTuple];\n            }\n        }\n    }\n    viewport.removeActors([uid]);\n    const oldMapper = actor.getMapper();\n    const mapper = convertMapperToNotSharedMapper(oldMapper);\n    actor.setMapper(mapper);\n    mapper.setBlendMode(Enums.BlendModes.LABELMAP_EDGE_PROJECTION_BLEND);\n    const arrayAgain = mapper.getInputData().getPointData().getArray(0);\n    arrayAgain.setData(cubeData);\n    arrayAgain.setNumberOfComponents(2);\n    actor.getProperty().setColorMixPreset(1);\n    actor.getProperty().setForceNearestInterpolation(1, true);\n    actor.getProperty().setIndependentComponents(true);\n    viewport.addActor({\n        actor,\n        uid,\n        callback,\n        referencedId: referenceVolumeId,\n        representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}`,\n    });\n    internalCache.set(uid, {\n        added: true,\n        segmentationRepresentationUID: `${segmentationId}`,\n        originalBlendMode: viewport.getBlendMode(),\n    });\n    actor.set({\n        preLoad: load,\n    });\n    function onSegmentationDataModified(evt) {\n        const { segmentationId } = evt.detail;\n        const { representationData } = getSegmentation(segmentationId);\n        const { volumeId: segVolumeId } = representationData.Labelmap;\n        if (segVolumeId !== segImageVolume.volumeId) {\n            return;\n        }\n        const segmentationVolume = cache.getVolume(segVolumeId);\n        const segVoxelManager = segmentationVolume.voxelManager;\n        const imageData = mapper.getInputData();\n        const array = imageData.getPointData().getArray(0);\n        const baseData = array.getData();\n        const newComp = 2;\n        const dims = segImageData.getDimensions();\n        const slices = Array.from({ length: dims[2] }, (_, i) => i);\n        for (const z of slices) {\n            for (let y = 0; y < dims[1]; ++y) {\n                for (let x = 0; x < dims[0]; ++x) {\n                    const iTuple = x + dims[0] * (y + dims[1] * z);\n                    baseData[iTuple * newComp + 1] = segVoxelManager.getAtIndex(iTuple);\n                }\n            }\n        }\n        array.setData(baseData);\n        imageData.modified();\n        viewport.render();\n    }\n    eventTarget.addEventListenerDebounced(Events.SEGMENTATION_DATA_MODIFIED, onSegmentationDataModified, 200);\n    eventTarget.addEventListener(Events.SEGMENTATION_REPRESENTATION_REMOVED, async (evt) => {\n        eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, onSegmentationDataModified);\n        const actorEntry = viewport.getActor(uid);\n        const { element, id } = viewport;\n        viewport.removeActors([uid]);\n        const actor = await createVolumeActor({\n            volumeId: uid,\n            blendMode: Enums.BlendModes.MAXIMUM_INTENSITY_BLEND,\n            callback: ({ volumeActor }) => {\n                if (actorEntry.callback) {\n                    actorEntry.callback({\n                        volumeActor,\n                        volumeId,\n                    });\n                }\n            },\n        }, element, id);\n        viewport.addActor({ actor, uid });\n        viewport.render();\n    });\n    return {\n        uid,\n        actor,\n    };\n}\n","import { getEnabledElement, addVolumesToViewports, addImageSlicesToViewports, Enums, cache, BaseVolumeViewport, volumeLoader, utilities, } from '@cornerstonejs/core';\nimport { getCurrentLabelmapImageIdsForViewport } from '../../../stateManagement/segmentation/getCurrentLabelmapImageIdForViewport';\nimport { getSegmentation } from '../../../stateManagement/segmentation/getSegmentation';\nimport { triggerSegmentationDataModified, triggerSegmentationModified, } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport { SegmentationRepresentations } from '../../../enums';\nimport { addVolumesAsIndependentComponents } from './addVolumesAsIndependentComponents';\nconst { uuidv4 } = utilities;\nasync function addLabelmapToElement(element, labelMapData, segmentationId, config) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, viewport } = enabledElement;\n    const { id: viewportId } = viewport;\n    const visibility = true;\n    const immediateRender = false;\n    const suppressEvents = true;\n    if (viewport instanceof BaseVolumeViewport) {\n        const volumeLabelMapData = labelMapData;\n        const volumeId = _ensureVolumeHasVolumeId(volumeLabelMapData, segmentationId);\n        if (!cache.getVolume(volumeId)) {\n            await _handleMissingVolume(labelMapData);\n        }\n        let blendMode = config?.blendMode ?? Enums.BlendModes.MAXIMUM_INTENSITY_BLEND;\n        let useIndependentComponents = blendMode === Enums.BlendModes.LABELMAP_EDGE_PROJECTION_BLEND;\n        if (useIndependentComponents) {\n            const referenceVolumeId = viewport.getVolumeId();\n            const baseVolume = cache.getVolume(referenceVolumeId);\n            const segVolume = cache.getVolume(volumeId);\n            const segDims = segVolume.dimensions;\n            const refDims = baseVolume.dimensions;\n            if (segDims[0] !== refDims[0] ||\n                segDims[1] !== refDims[1] ||\n                segDims[2] !== refDims[2]) {\n                useIndependentComponents = false;\n                blendMode = Enums.BlendModes.MAXIMUM_INTENSITY_BLEND;\n                console.debug('Dimensions mismatch - falling back to regular volume addition');\n            }\n        }\n        const volumeInputs = [\n            {\n                volumeId,\n                visibility,\n                representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}`,\n                useIndependentComponents,\n                blendMode,\n            },\n        ];\n        if (!volumeInputs[0].useIndependentComponents) {\n            await addVolumesToViewports(renderingEngine, volumeInputs, [viewportId], immediateRender, suppressEvents);\n        }\n        else {\n            const result = await addVolumesAsIndependentComponents({\n                viewport,\n                volumeInputs,\n                segmentationId,\n            });\n            return result;\n        }\n    }\n    else {\n        const segmentationImageIds = getCurrentLabelmapImageIdsForViewport(viewport.id, segmentationId);\n        const stackInputs = segmentationImageIds.map((imageId) => ({\n            imageId,\n            representationUID: `${segmentationId}-${SegmentationRepresentations.Labelmap}-${imageId}`,\n        }));\n        addImageSlicesToViewports(renderingEngine, stackInputs, [viewportId]);\n    }\n    triggerSegmentationDataModified(segmentationId);\n}\nfunction _ensureVolumeHasVolumeId(labelMapData, segmentationId) {\n    let { volumeId } = labelMapData;\n    if (!volumeId) {\n        volumeId = uuidv4();\n        const segmentation = getSegmentation(segmentationId);\n        segmentation.representationData.Labelmap = {\n            ...segmentation.representationData.Labelmap,\n            volumeId,\n        };\n        labelMapData.volumeId = volumeId;\n        triggerSegmentationModified(segmentationId);\n    }\n    return volumeId;\n}\nasync function _handleMissingVolume(labelMapData) {\n    const stackData = labelMapData;\n    const hasImageIds = stackData.imageIds.length > 0;\n    if (!hasImageIds) {\n        throw new Error('cannot create labelmap, no imageIds found for the volume labelmap');\n    }\n    const volume = await volumeLoader.createAndCacheVolumeFromImages(labelMapData.volumeId || uuidv4(), stackData.imageIds);\n    return volume;\n}\nexport default addLabelmapToElement;\n","const defaultLabelmapConfig = {\n    renderOutline: true,\n    renderOutlineInactive: true,\n    outlineWidth: 3,\n    outlineWidthInactive: 2,\n    activeSegmentOutlineWidthDelta: 0,\n    renderFill: true,\n    renderFillInactive: true,\n    fillAlpha: 0.5,\n    fillAlphaInactive: 0.4,\n    outlineOpacity: 1,\n    outlineOpacityInactive: 0.85,\n};\nfunction getDefaultLabelmapStyle() {\n    return defaultLabelmapConfig;\n}\nexport default getDefaultLabelmapStyle;\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport { getLabelmapActorUID } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nfunction removeLabelmapFromElement(element, segmentationId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    viewport.removeActors([getLabelmapActorUID(viewport.id, segmentationId)]);\n}\nexport default removeLabelmapFromElement;\n","import { utilities } from '@cornerstonejs/core';\nimport vtkMapper from '@kitware/vtk.js/Rendering/Core/Mapper';\nimport vtkActor from '@kitware/vtk.js/Rendering/Core/Actor';\nimport vtkPolyData from '@kitware/vtk.js/Common/DataModel/PolyData';\nimport vtkCellArray from '@kitware/vtk.js/Common/Core/CellArray';\nimport { getSurfaceActorEntry, getSurfaceRepresentationUID, } from '../../../stateManagement/segmentation/helpers/getSegmentationActor';\nfunction addOrUpdateSurfaceToElement(viewport, surface, segmentationId) {\n    const surfaceActorEntry = getSurfaceActorEntry(viewport.id, segmentationId, surface.segmentIndex);\n    const surfaceActor = surfaceActorEntry?.actor;\n    const isVisible = surface.visible;\n    if (surfaceActor) {\n        surfaceActor.setVisibility(isVisible);\n        if (!isVisible) {\n            return;\n        }\n        const surfaceMapper = surfaceActor.getMapper();\n        const currentPolyData = surfaceMapper.getInputData();\n        const newPoints = surface.points;\n        const newPolys = surface.polys;\n        const currentPoints = currentPolyData.getPoints().getData();\n        const currentPolys = currentPolyData.getPolys().getData();\n        if (newPoints.length === currentPoints.length &&\n            newPolys.length === currentPolys.length) {\n            return;\n        }\n        const polyData = vtkPolyData.newInstance();\n        polyData.getPoints().setData(newPoints, 3);\n        const triangles = vtkCellArray.newInstance({\n            values: Float32Array.from(newPolys),\n        });\n        polyData.setPolys(triangles);\n        surfaceMapper.setInputData(polyData);\n        surfaceMapper.modified();\n        viewport.getRenderer().resetCameraClippingRange();\n        return;\n    }\n    const points = surface.points;\n    const polys = surface.polys;\n    const color = surface.color;\n    const surfacePolyData = vtkPolyData.newInstance();\n    surfacePolyData.getPoints().setData(points, 3);\n    const triangles = vtkCellArray.newInstance({\n        values: Float32Array.from(polys),\n    });\n    surfacePolyData.setPolys(triangles);\n    const mapper = vtkMapper.newInstance({});\n    let clippingFilter;\n    mapper.setInputData(surfacePolyData);\n    const actor = vtkActor.newInstance();\n    actor.setMapper(mapper);\n    actor.getProperty().setColor(color[0] / 255, color[1] / 255, color[2] / 255);\n    actor.getProperty().setLineWidth(2);\n    const representationUID = getSurfaceRepresentationUID(segmentationId, surface.segmentIndex);\n    viewport.addActor({\n        uid: utilities.uuidv4(),\n        actor: actor,\n        clippingFilter,\n        representationUID,\n    });\n    viewport.resetCamera();\n    viewport.getRenderer().resetCameraClippingRange();\n    viewport.render();\n}\nexport default addOrUpdateSurfaceToElement;\n","import { getEnabledElement } from '@cornerstonejs/core';\nfunction removeSurfaceFromElement(element, segmentationId) {\n    const enabledElement = getEnabledElement(element);\n    const { viewport } = enabledElement;\n    const actorEntries = viewport.getActors();\n    const filteredSurfaceActors = actorEntries.filter((actor) => actor.representationUID &&\n        typeof actor.representationUID === 'string' &&\n        actor.representationUID.startsWith(segmentationId));\n    viewport.removeActors(filteredSurfaceActors.map((actor) => actor.uid));\n}\nexport default removeSurfaceFromElement;\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport compositions from './compositions';\nimport { getStrategyData } from './utils/getStrategyData';\nimport { StrategyCallbacks } from '../../../enums';\nexport default class BrushStrategy {\n    static { this.COMPOSITIONS = compositions; }\n    static { this.childFunctions = {\n        [StrategyCallbacks.OnInteractionStart]: addListMethod(StrategyCallbacks.OnInteractionStart, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.OnInteractionEnd]: addListMethod(StrategyCallbacks.OnInteractionEnd, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.Fill]: addListMethod(StrategyCallbacks.Fill),\n        [StrategyCallbacks.Initialize]: addListMethod(StrategyCallbacks.Initialize),\n        [StrategyCallbacks.CreateIsInThreshold]: addSingletonMethod(StrategyCallbacks.CreateIsInThreshold),\n        [StrategyCallbacks.Interpolate]: addListMethod(StrategyCallbacks.Interpolate, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.AcceptPreview]: addListMethod(StrategyCallbacks.AcceptPreview, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.RejectPreview]: addListMethod(StrategyCallbacks.RejectPreview, StrategyCallbacks.Initialize),\n        [StrategyCallbacks.INTERNAL_setValue]: addSingletonMethod(StrategyCallbacks.INTERNAL_setValue),\n        [StrategyCallbacks.Preview]: addSingletonMethod(StrategyCallbacks.Preview, false),\n        [StrategyCallbacks.ComputeInnerCircleRadius]: addListMethod(StrategyCallbacks.ComputeInnerCircleRadius),\n        [StrategyCallbacks.EnsureSegmentationVolumeFor3DManipulation]: addListMethod(StrategyCallbacks.EnsureSegmentationVolumeFor3DManipulation),\n        [StrategyCallbacks.EnsureImageVolumeFor3DManipulation]: addListMethod(StrategyCallbacks.EnsureImageVolumeFor3DManipulation),\n        [StrategyCallbacks.AddPreview]: addListMethod(StrategyCallbacks.AddPreview),\n        [StrategyCallbacks.GetStatistics]: addSingletonMethod(StrategyCallbacks.GetStatistics),\n        compositions: null,\n    }; }\n    constructor(name, ...initializers) {\n        this._initialize = [];\n        this._fill = [];\n        this._onInteractionStart = [];\n        this.fill = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData, StrategyCallbacks.Fill);\n            if (!initializedData) {\n                return;\n            }\n            this._fill.forEach((func) => func(initializedData));\n            const { segmentationVoxelManager, segmentIndex } = initializedData;\n            triggerSegmentationDataModified(initializedData.segmentationId, segmentationVoxelManager.getArrayOfModifiedSlices(), segmentIndex);\n            return initializedData;\n        };\n        this.onInteractionStart = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData);\n            if (!initializedData) {\n                return;\n            }\n            this._onInteractionStart.forEach((func) => func.call(this, initializedData));\n        };\n        this.addPreview = (enabledElement, operationData) => {\n            const initializedData = this.initialize(enabledElement, operationData, StrategyCallbacks.AddPreview);\n            if (!initializedData) {\n                return;\n            }\n            return initializedData;\n        };\n        this.configurationName = name;\n        this.compositions = initializers;\n        initializers.forEach((initializer) => {\n            const result = typeof initializer === 'function' ? initializer() : initializer;\n            if (!result) {\n                return;\n            }\n            for (const key in result) {\n                if (!BrushStrategy.childFunctions[key]) {\n                    throw new Error(`Didn't find ${key} as a brush strategy`);\n                }\n                BrushStrategy.childFunctions[key](this, result[key]);\n            }\n        });\n        this.strategyFunction = (enabledElement, operationData) => {\n            return this.fill(enabledElement, operationData);\n        };\n        for (const key of Object.keys(BrushStrategy.childFunctions)) {\n            this.strategyFunction[key] = this[key];\n        }\n    }\n    initialize(enabledElement, operationData, operationName) {\n        const { viewport } = enabledElement;\n        const data = getStrategyData({ operationData, viewport, strategy: this });\n        if (!data) {\n            return null;\n        }\n        const { imageVoxelManager, segmentationVoxelManager, segmentationImageData, } = data;\n        const memo = operationData.createMemo(operationData.segmentationId, segmentationVoxelManager);\n        const initializedData = {\n            operationName,\n            ...operationData,\n            segmentIndex: operationData.segmentIndex,\n            enabledElement,\n            imageVoxelManager,\n            segmentationVoxelManager,\n            segmentationImageData,\n            viewport,\n            centerWorld: null,\n            isInObject: null,\n            isInObjectBoundsIJK: null,\n            brushStrategy: this,\n            memo,\n        };\n        this._initialize.forEach((func) => func(initializedData));\n        return initializedData;\n    }\n}\nfunction addListMethod(name, createInitialized) {\n    const listName = `_${name}`;\n    return (brushStrategy, func) => {\n        brushStrategy[listName] ||= [];\n        brushStrategy[listName].push(func);\n        brushStrategy[name] ||= createInitialized\n            ? (enabledElement, operationData, ...args) => {\n                const initializedData = brushStrategy[createInitialized](enabledElement, operationData, name);\n                let returnValue;\n                brushStrategy[listName].forEach((func) => {\n                    const value = func.call(brushStrategy, initializedData, ...args);\n                    returnValue ||= value;\n                });\n                return returnValue;\n            }\n            : (operationData, ...args) => {\n                brushStrategy[listName].forEach((func) => func.call(brushStrategy, operationData, ...args));\n            };\n    };\n}\nfunction addSingletonMethod(name, isInitialized = true) {\n    return (brushStrategy, func) => {\n        if (brushStrategy[name]) {\n            throw new Error(`The singleton method ${name} already exists`);\n        }\n        brushStrategy[name] = isInitialized\n            ? func\n            : (enabledElement, operationData, ...args) => {\n                operationData.enabledElement = enabledElement;\n                return func.call(brushStrategy, operationData, ...args);\n            };\n    };\n}\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.OnInteractionStart]: (operationData) => {\n        const { segmentIndex, previewSegmentIndex, segmentationVoxelManager, centerIJK, viewPlaneNormal, segmentationImageData, configuration, } = operationData;\n        if (!configuration?.useCenterSegmentIndex) {\n            operationData.centerSegmentIndexInfo.segmentIndex = null;\n            operationData.centerSegmentIndexInfo.hasSegmentIndex = false;\n            operationData.centerSegmentIndexInfo.hasPreviewIndex = false;\n            return;\n        }\n        let hasSegmentIndex = false;\n        let hasPreviewIndex = false;\n        const nestedBounds = [\n            ...segmentationVoxelManager.getBoundsIJK(),\n        ];\n        if (Math.abs(viewPlaneNormal[0]) > 0.8) {\n            nestedBounds[0] = [centerIJK[0], centerIJK[0]];\n        }\n        else if (Math.abs(viewPlaneNormal[1]) > 0.8) {\n            nestedBounds[1] = [centerIJK[1], centerIJK[1]];\n        }\n        else if (Math.abs(viewPlaneNormal[2]) > 0.8) {\n            nestedBounds[2] = [centerIJK[2], centerIJK[2]];\n        }\n        const callback = ({ value }) => {\n            hasSegmentIndex ||= value === segmentIndex;\n            hasPreviewIndex ||= value === previewSegmentIndex;\n        };\n        segmentationVoxelManager.forEach(callback, {\n            imageData: segmentationImageData,\n            isInObject: operationData.isInObject,\n            boundsIJK: nestedBounds,\n        });\n        if (!hasSegmentIndex && !hasPreviewIndex) {\n            operationData.centerSegmentIndexInfo.segmentIndex = null;\n            return;\n        }\n        const existingValue = segmentationVoxelManager.getAtIJKPoint(centerIJK);\n        operationData.centerSegmentIndexInfo.segmentIndex = existingValue;\n        operationData.centerSegmentIndexInfo.hasSegmentIndex = hasSegmentIndex;\n        operationData.centerSegmentIndexInfo.hasPreviewIndex = hasPreviewIndex;\n    },\n};\n","import { vec3 } from 'gl-matrix';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { operationName, centerIJK, segmentationVoxelManager, imageVoxelManager, configuration, segmentIndex, viewport, } = operationData;\n        if (!configuration?.threshold?.isDynamic || !centerIJK || !segmentIndex) {\n            return;\n        }\n        if (operationName === StrategyCallbacks.RejectPreview ||\n            operationName === StrategyCallbacks.OnInteractionEnd) {\n            return;\n        }\n        const boundsIJK = segmentationVoxelManager.getBoundsIJK();\n        const { range: oldThreshold, dynamicRadius = 0 } = configuration.threshold;\n        const useDelta = oldThreshold ? 0 : dynamicRadius;\n        const { viewPlaneNormal } = viewport.getCamera();\n        const nestedBounds = boundsIJK.map((ijk, idx) => {\n            const [min, max] = ijk;\n            return [\n                Math.max(min, centerIJK[idx] - useDelta),\n                Math.min(max, centerIJK[idx] + useDelta),\n            ];\n        });\n        if (Math.abs(viewPlaneNormal[0]) > 0.8) {\n            nestedBounds[0] = [centerIJK[0], centerIJK[0]];\n        }\n        else if (Math.abs(viewPlaneNormal[1]) > 0.8) {\n            nestedBounds[1] = [centerIJK[1], centerIJK[1]];\n        }\n        else if (Math.abs(viewPlaneNormal[2]) > 0.8) {\n            nestedBounds[2] = [centerIJK[2], centerIJK[2]];\n        }\n        const threshold = oldThreshold || [Infinity, -Infinity];\n        const useDeltaSqr = useDelta * useDelta;\n        const callback = ({ value, pointIJK }) => {\n            const distance = vec3.sqrDist(centerIJK, pointIJK);\n            if (distance > useDeltaSqr) {\n                return;\n            }\n            const gray = Array.isArray(value) ? vec3.len(value) : value;\n            threshold[0] = Math.min(gray, threshold[0]);\n            threshold[1] = Math.max(gray, threshold[1]);\n        };\n        imageVoxelManager.forEach(callback, { boundsIJK: nestedBounds });\n        configuration.threshold.range = threshold;\n    },\n    [StrategyCallbacks.OnInteractionStart]: (operationData) => {\n        const { configuration } = operationData;\n        if (!configuration?.threshold?.isDynamic) {\n            return;\n        }\n        configuration.threshold.range = null;\n    },\n    [StrategyCallbacks.ComputeInnerCircleRadius]: (operationData) => {\n        const { configuration, viewport } = operationData;\n        const { dynamicRadius = 0, isDynamic } = configuration.threshold;\n        if (!isDynamic) {\n            configuration.threshold.dynamicRadiusInCanvas = 0;\n            return;\n        }\n        if (dynamicRadius === 0) {\n            return;\n        }\n        const imageData = viewport.getImageData();\n        if (!imageData) {\n            return;\n        }\n        const { spacing } = imageData;\n        const centerCanvas = [\n            viewport.element.clientWidth / 2,\n            viewport.element.clientHeight / 2,\n        ];\n        const radiusInWorld = dynamicRadius * spacing[0];\n        const centerCursorInWorld = viewport.canvasToWorld(centerCanvas);\n        const offSetCenterInWorld = centerCursorInWorld.map((coord) => coord + radiusInWorld);\n        const offSetCenterCanvas = viewport.worldToCanvas(offSetCenterInWorld);\n        const dynamicRadiusInCanvas = Math.abs(centerCanvas[0] - offSetCenterCanvas[0]);\n        if (!configuration.threshold.dynamicRadiusInCanvas) {\n            configuration.threshold.dynamicRadiusInCanvas = 0;\n        }\n        configuration.threshold.dynamicRadiusInCanvas = 3 + dynamicRadiusInCanvas;\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        operationData.segmentIndex = 0;\n    },\n};\n","import { triggerSegmentationDataModified } from '../../../../stateManagement/segmentation/triggerSegmentationEvents';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport IslandRemoval from '../../../../utilities/segmentation/islandRemoval';\nexport default {\n    [StrategyCallbacks.OnInteractionEnd]: (operationData) => {\n        const { previewSegmentIndex, segmentIndex, viewport, segmentationVoxelManager, activeStrategy, memo, } = operationData;\n        if (activeStrategy !== 'THRESHOLD_INSIDE_SPHERE_WITH_ISLAND_REMOVAL' ||\n            segmentIndex === null) {\n            return;\n        }\n        const islandRemoval = new IslandRemoval();\n        const voxelManager = memo?.voxelManager || segmentationVoxelManager;\n        if (!islandRemoval.initialize(viewport, voxelManager, {\n            previewSegmentIndex,\n            segmentIndex,\n        })) {\n            return;\n        }\n        islandRemoval.floodFillSegmentIsland();\n        islandRemoval.removeExternalIslands();\n        islandRemoval.removeInternalIslands();\n        const arrayOfSlices = voxelManager.getArrayOfModifiedSlices();\n        if (!arrayOfSlices) {\n            return;\n        }\n        triggerSegmentationDataModified(operationData.segmentationId, arrayOfSlices, previewSegmentIndex);\n    },\n};\n","import { utilities } from '@cornerstonejs/core';\nimport { triggerSegmentationDataModified } from '../../../../stateManagement/segmentation/events/triggerSegmentationDataModified';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport { setSegmentIndexColor } from '../../../../stateManagement/segmentation/config/segmentationColor';\nimport { getViewportIdsWithSegmentation } from '../../../../stateManagement/segmentation/getViewportIdsWithSegmentation';\nexport default {\n    [StrategyCallbacks.Preview]: function (operationData) {\n        const { previewSegmentIndex, configuration, enabledElement } = operationData;\n        if (!previewSegmentIndex || !configuration) {\n            return;\n        }\n        this.onInteractionStart?.(enabledElement, operationData);\n        const preview = this.fill(enabledElement, operationData);\n        if (preview) {\n            this.onInteractionEnd?.(enabledElement, operationData);\n        }\n        return preview;\n    },\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { segmentIndex, previewColor, previewSegmentIndex } = operationData;\n        operationData.modified = false;\n        if (previewSegmentIndex == null || segmentIndex == null) {\n            return;\n        }\n        const viewportIds = getViewportIdsWithSegmentation(operationData.segmentationId);\n        viewportIds?.forEach((viewportId) => {\n            setSegmentIndexColor(viewportId, operationData.segmentationId, previewSegmentIndex, previewColor);\n        });\n        operationData.modified = true;\n    },\n    [StrategyCallbacks.AcceptPreview]: (operationData) => {\n        const { previewSegmentIndex, segmentationVoxelManager, memo, segmentIndex, centerSegmentIndexInfo, } = operationData || {};\n        const { changedIndices } = centerSegmentIndexInfo || {};\n        const labelmapMemo = memo;\n        const callback = ({ index }) => {\n            const oldValue = segmentationVoxelManager.getAtIndex(index);\n            if (changedIndices?.length > 0) {\n                if (changedIndices.includes(index)) {\n                    labelmapMemo.voxelManager.setAtIndex(index, 0);\n                }\n            }\n            else {\n                if (oldValue === previewSegmentIndex) {\n                    labelmapMemo.voxelManager.setAtIndex(index, segmentIndex);\n                }\n            }\n        };\n        segmentationVoxelManager.forEach(callback);\n        triggerSegmentationDataModified(operationData.segmentationId, segmentationVoxelManager.getArrayOfModifiedSlices(), segmentIndex);\n        operationData.centerSegmentIndexInfo.changedIndices = [];\n    },\n    [StrategyCallbacks.RejectPreview]: (operationData) => {\n        if (!operationData) {\n            return;\n        }\n        utilities.HistoryMemo.DefaultHistoryMemo.undoIf((memo) => {\n            const labelmapMemo = memo;\n            if (!labelmapMemo?.voxelManager) {\n                return false;\n            }\n            const { segmentationVoxelManager } = labelmapMemo;\n            let hasPreviewSegmentIndex = false;\n            const callback = ({ value }) => {\n                if (value === operationData.previewSegmentIndex) {\n                    hasPreviewSegmentIndex = true;\n                }\n            };\n            segmentationVoxelManager.forEach(callback);\n            return hasPreviewSegmentIndex;\n        });\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.Fill]: (operationData) => {\n        const { segmentsLocked, segmentationImageData, segmentationVoxelManager, brushStrategy, centerIJK, } = operationData;\n        const isWithinThreshold = brushStrategy.createIsInThreshold?.(operationData);\n        const { setValue } = brushStrategy;\n        const callback = isWithinThreshold\n            ? (data) => {\n                const { value, index } = data;\n                if (segmentsLocked.includes(value) || !isWithinThreshold(index)) {\n                    return;\n                }\n                setValue(operationData, data);\n            }\n            : (data) => setValue(operationData, data);\n        segmentationVoxelManager.forEach(callback, {\n            imageData: segmentationImageData,\n            isInObject: operationData.isInObject,\n            boundsIJK: operationData.isInObjectBoundsIJK,\n        });\n        segmentationVoxelManager.addPoint(centerIJK);\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport { handleUseSegmentCenterIndex } from '../utils/handleUseSegmentCenterIndex';\nexport default {\n    [StrategyCallbacks.INTERNAL_setValue]: (operationData, { value, index }) => {\n        const { segmentsLocked, previewSegmentIndex, memo, segmentationVoxelManager, centerSegmentIndexInfo, segmentIndex, } = operationData;\n        const existingValue = segmentationVoxelManager.getAtIndex(index);\n        if (segmentsLocked.includes(value)) {\n            return;\n        }\n        if (!centerSegmentIndexInfo && existingValue === segmentIndex) {\n            return;\n        }\n        if (centerSegmentIndexInfo?.segmentIndex !== 0 &&\n            existingValue === segmentIndex) {\n            return;\n        }\n        if (centerSegmentIndexInfo?.segmentIndex === null) {\n            memo.voxelManager.setAtIndex(index, previewSegmentIndex ?? segmentIndex);\n            return;\n        }\n        if (!previewSegmentIndex) {\n            let useSegmentIndex = segmentIndex;\n            if (centerSegmentIndexInfo) {\n                useSegmentIndex = centerSegmentIndexInfo.segmentIndex;\n            }\n            memo.voxelManager.setAtIndex(index, useSegmentIndex);\n            return;\n        }\n        handleUseSegmentCenterIndex({\n            operationData,\n            existingValue,\n            index,\n        });\n    },\n};\n","export function handleUseSegmentCenterIndex({ operationData, existingValue, index, }) {\n    const { previewSegmentIndex, memo, centerSegmentIndexInfo, previewOnHover, segmentIndex, } = operationData;\n    const { hasPreviewIndex, hasSegmentIndex, segmentIndex: centerSegmentIndex, } = centerSegmentIndexInfo;\n    if (centerSegmentIndex === 0 && hasSegmentIndex && hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (previewOnHover) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, 0);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === 0 && hasSegmentIndex && !hasPreviewIndex) {\n        if (existingValue === 0 || existingValue !== segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        centerSegmentIndexInfo.changedIndices.push(index);\n        return;\n    }\n    if (centerSegmentIndex === 0 && !hasSegmentIndex && hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (previewOnHover) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, 0);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === 0 && !hasSegmentIndex && !hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        if (existingValue === previewSegmentIndex) {\n            memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n            return;\n        }\n        return;\n    }\n    if (centerSegmentIndex === previewSegmentIndex &&\n        hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === previewSegmentIndex &&\n        !hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === segmentIndex &&\n        hasSegmentIndex &&\n        hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n    if (centerSegmentIndex === segmentIndex &&\n        hasSegmentIndex &&\n        !hasPreviewIndex) {\n        if (existingValue === segmentIndex) {\n            return;\n        }\n        memo.voxelManager.setAtIndex(index, previewSegmentIndex);\n        return;\n    }\n}\n","import { vec3 } from 'gl-matrix';\nimport StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nexport default {\n    [StrategyCallbacks.CreateIsInThreshold]: (operationData) => {\n        const { imageVoxelManager, segmentIndex, configuration } = operationData;\n        if (!configuration || !segmentIndex) {\n            return;\n        }\n        return (index) => {\n            const voxelValue = imageVoxelManager.getAtIndex(index);\n            const gray = Array.isArray(voxelValue)\n                ? vec3.length(voxelValue)\n                : voxelValue;\n            const { threshold } = configuration || {};\n            if (!threshold?.range?.length) {\n                return true;\n            }\n            return threshold.range[0] <= gray && gray <= threshold.range[1];\n        };\n    },\n};\n","import StrategyCallbacks from '../../../../enums/StrategyCallbacks';\nimport getStatistics from '../../../../utilities/segmentation/getStatistics';\nexport default {\n    [StrategyCallbacks.GetStatistics]: function (enabledElement, operationData, options) {\n        const { indices } = options;\n        const { segmentationId, viewport } = operationData;\n        getStatistics({\n            segmentationId,\n            segmentIndices: indices,\n        });\n    },\n};\n","import determineSegmentIndex from './determineSegmentIndex';\nimport dynamicThreshold from './dynamicThreshold';\nimport erase from './erase';\nimport islandRemoval from './islandRemovalComposition';\nimport preview from './preview';\nimport regionFill from './regionFill';\nimport setValue from './setValue';\nimport threshold from './threshold';\nimport labelmapStatistics from './labelmapStatistics';\nimport ensureSegmentationVolumeFor3DManipulation from './ensureSegmentationVolume';\nimport ensureImageVolumeFor3DManipulation from './ensureImageVolume';\nexport default {\n    determineSegmentIndex,\n    dynamicThreshold,\n    erase,\n    islandRemoval,\n    preview,\n    regionFill,\n    setValue,\n    threshold,\n    labelmapStatistics,\n    ensureSegmentationVolumeFor3DManipulation,\n    ensureImageVolumeFor3DManipulation,\n};\n","import BrushStrategy from './BrushStrategy';\nimport { CIRCLE_STRATEGY } from './fillCircle';\nimport compositions from './compositions';\nconst ERASE_CIRCLE_STRATEGY = new BrushStrategy('EraseCircle', compositions.erase, ...CIRCLE_STRATEGY.compositions);\nconst eraseInsideCircle = ERASE_CIRCLE_STRATEGY.strategyFunction;\nexport { eraseInsideCircle };\n","import BrushStrategy from './BrushStrategy';\nimport { SPHERE_STRATEGY } from './fillSphere';\nimport compositions from './compositions';\nconst ERASE_SPHERE_STRATEGY = new BrushStrategy('EraseSphere', compositions.erase, ...SPHERE_STRATEGY.compositions);\nconst eraseInsideSphere = ERASE_SPHERE_STRATEGY.strategyFunction;\nexport { eraseInsideSphere };\n","import { utilities as csUtils } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport BrushStrategy from './BrushStrategy';\nimport compositions from './compositions';\nimport StrategyCallbacks from '../../../enums/StrategyCallbacks';\nimport { createEllipseInPoint, getEllipseCornersFromCanvasCoordinates, } from './fillCircle';\nconst { transformWorldToIndex } = csUtils;\nimport { getSphereBoundsInfoFromViewport } from '../../../utilities/getSphereBoundsInfo';\nconst sphereComposition = {\n    [StrategyCallbacks.Initialize]: (operationData) => {\n        const { points, viewport, segmentationImageData } = operationData;\n        if (!points) {\n            return;\n        }\n        const center = vec3.create();\n        if (points.length >= 2) {\n            vec3.add(center, points[0], points[1]);\n            vec3.scale(center, center, 0.5);\n        }\n        else {\n            vec3.copy(center, points[0]);\n        }\n        operationData.centerWorld = center;\n        operationData.centerIJK = transformWorldToIndex(segmentationImageData, center);\n        const baseExtent = getSphereBoundsInfoFromViewport(points.slice(0, 2), segmentationImageData, viewport);\n        const canvasCoordinates = points.map((p) => viewport.worldToCanvas(p));\n        const corners = getEllipseCornersFromCanvasCoordinates(canvasCoordinates);\n        const cornersInWorld = corners.map((corner) => viewport.canvasToWorld(corner));\n        const strokeRadius = points.length >= 2 ? vec3.distance(points[0], points[1]) / 2 : undefined;\n        const strokeCenters = operationData.strokePointsWorld &&\n            operationData.strokePointsWorld.length > 0\n            ? operationData.strokePointsWorld\n            : [operationData.centerWorld];\n        const baseBounds = baseExtent.boundsIJK;\n        const baseCenterIJK = operationData.centerIJK;\n        const boundsForStroke = strokeCenters.reduce((acc, centerPoint) => {\n            if (!centerPoint) {\n                return acc;\n            }\n            const translatedCenterIJK = transformWorldToIndex(segmentationImageData, centerPoint);\n            const deltaIJK = [\n                translatedCenterIJK[0] - baseCenterIJK[0],\n                translatedCenterIJK[1] - baseCenterIJK[1],\n                translatedCenterIJK[2] - baseCenterIJK[2],\n            ];\n            const translatedBounds = [\n                [baseBounds[0][0] + deltaIJK[0], baseBounds[0][1] + deltaIJK[0]],\n                [baseBounds[1][0] + deltaIJK[1], baseBounds[1][1] + deltaIJK[1]],\n                [baseBounds[2][0] + deltaIJK[2], baseBounds[2][1] + deltaIJK[2]],\n            ];\n            if (!acc) {\n                return translatedBounds;\n            }\n            return [\n                [\n                    Math.min(acc[0][0], translatedBounds[0][0]),\n                    Math.max(acc[0][1], translatedBounds[0][1]),\n                ],\n                [\n                    Math.min(acc[1][0], translatedBounds[1][0]),\n                    Math.max(acc[1][1], translatedBounds[1][1]),\n                ],\n                [\n                    Math.min(acc[2][0], translatedBounds[2][0]),\n                    Math.max(acc[2][1], translatedBounds[2][1]),\n                ],\n            ];\n        }, null);\n        const boundsToUse = boundsForStroke ?? baseExtent.boundsIJK;\n        if (segmentationImageData) {\n            const dimensions = segmentationImageData.getDimensions();\n            operationData.isInObjectBoundsIJK = [\n                [\n                    Math.max(0, Math.min(boundsToUse[0][0], dimensions[0] - 1)),\n                    Math.max(0, Math.min(boundsToUse[0][1], dimensions[0] - 1)),\n                ],\n                [\n                    Math.max(0, Math.min(boundsToUse[1][0], dimensions[1] - 1)),\n                    Math.max(0, Math.min(boundsToUse[1][1], dimensions[1] - 1)),\n                ],\n                [\n                    Math.max(0, Math.min(boundsToUse[2][0], dimensions[2] - 1)),\n                    Math.max(0, Math.min(boundsToUse[2][1], dimensions[2] - 1)),\n                ],\n            ];\n        }\n        else {\n            operationData.isInObjectBoundsIJK = boundsToUse;\n        }\n        operationData.isInObject = createEllipseInPoint(cornersInWorld, {\n            strokePointsWorld: operationData.strokePointsWorld,\n            segmentationImageData,\n            radius: strokeRadius,\n        });\n    },\n};\nconst SPHERE_STRATEGY = new BrushStrategy('Sphere', compositions.regionFill, compositions.setValue, sphereComposition, compositions.determineSegmentIndex, compositions.preview, compositions.labelmapStatistics, compositions.ensureSegmentationVolumeFor3DManipulation);\nconst fillInsideSphere = SPHERE_STRATEGY.strategyFunction;\nconst SPHERE_THRESHOLD_STRATEGY = new BrushStrategy('SphereThreshold', ...SPHERE_STRATEGY.compositions, compositions.dynamicThreshold, compositions.threshold, compositions.ensureSegmentationVolumeFor3DManipulation, compositions.ensureImageVolumeFor3DManipulation);\nconst SPHERE_THRESHOLD_STRATEGY_ISLAND = new BrushStrategy('SphereThreshold', ...SPHERE_STRATEGY.compositions, compositions.dynamicThreshold, compositions.threshold, compositions.islandRemoval, compositions.ensureSegmentationVolumeFor3DManipulation, compositions.ensureImageVolumeFor3DManipulation);\nconst thresholdInsideSphere = SPHERE_THRESHOLD_STRATEGY.strategyFunction;\nconst thresholdInsideSphereIsland = SPHERE_THRESHOLD_STRATEGY_ISLAND.strategyFunction;\nexport function fillOutsideSphere() {\n    throw new Error('fill outside sphere not implemented');\n}\nexport { fillInsideSphere, thresholdInsideSphere, SPHERE_STRATEGY, thresholdInsideSphereIsland, };\n","class RectangleROIStartEndThreshold {\n    constructor() {\n    }\n    static getContourSequence(toolData, metadataProvider) {\n        const { data } = toolData;\n        const { projectionPoints, projectionPointsImageIds } = data.cachedStats;\n        return projectionPoints.map((point, index) => {\n            const ContourData = getPointData(point);\n            const ContourImageSequence = getContourImageSequence(projectionPointsImageIds[index], metadataProvider);\n            return {\n                NumberOfContourPoints: ContourData.length / 3,\n                ContourImageSequence,\n                ContourGeometricType: 'CLOSED_PLANAR',\n                ContourData,\n            };\n        });\n    }\n}\nRectangleROIStartEndThreshold.toolName = 'RectangleROIStartEndThreshold';\nfunction getPointData(points) {\n    const orderedPoints = [\n        ...points[0],\n        ...points[1],\n        ...points[3],\n        ...points[2],\n    ];\n    const pointsArray = orderedPoints.flat();\n    const pointsArrayWithPrecision = pointsArray.map((point) => {\n        return point.toFixed(2);\n    });\n    return pointsArrayWithPrecision;\n}\nfunction getContourImageSequence(imageId, metadataProvider) {\n    const sopCommon = metadataProvider.get('sopCommonModule', imageId);\n    return {\n        ReferencedSOPClassUID: sopCommon.sopClassUID,\n        ReferencedSOPInstanceUID: sopCommon.sopInstanceUID,\n    };\n}\nexport default RectangleROIStartEndThreshold;\n","import { getAnnotations } from '../../../stateManagement/annotation/annotationState';\nconst DEFAULT_CONTOUR_SEG_TOOLNAME = 'PlanarFreehandContourSegmentationTool';\nexport default function getInterpolationData(viewportData, filterParams = []) {\n    const { viewport, sliceData, annotation } = viewportData;\n    const interpolationDatas = new Map();\n    const { toolName, originalToolName } = annotation.metadata;\n    const testToolName = originalToolName || toolName;\n    const annotations = (getAnnotations(testToolName, viewport.element) || []).filter((annotation) => !annotation.metadata.originalToolName ||\n        annotation.metadata.originalToolName === testToolName);\n    if (testToolName !== DEFAULT_CONTOUR_SEG_TOOLNAME) {\n        const modifiedAnnotations = getAnnotations(DEFAULT_CONTOUR_SEG_TOOLNAME, viewport.element);\n        if (modifiedAnnotations?.length) {\n            modifiedAnnotations.forEach((annotation) => {\n                const { metadata } = annotation;\n                if (metadata.originalToolName === testToolName &&\n                    metadata.originalToolName !== metadata.toolName) {\n                    annotations.push(annotation);\n                }\n            });\n        }\n    }\n    if (!annotations?.length) {\n        return interpolationDatas;\n    }\n    for (let i = 0; i < sliceData.numberOfSlices; i++) {\n        const imageAnnotations = annotations.filter((x) => x.metadata.sliceIndex === i);\n        if (!imageAnnotations?.length) {\n            continue;\n        }\n        const filteredInterpolatedAnnotations = imageAnnotations.filter((imageAnnotation) => {\n            return filterParams.every((x) => {\n                const parent = x.parentKey\n                    ? x.parentKey(imageAnnotation)\n                    : imageAnnotation;\n                const value = parent?.[x.key];\n                if (Array.isArray(value)) {\n                    return value.every((item, index) => item === x.value[index]);\n                }\n                return value === x.value;\n            });\n        });\n        if (filteredInterpolatedAnnotations.length) {\n            interpolationDatas.set(i, filteredInterpolatedAnnotations);\n        }\n    }\n    return interpolationDatas;\n}\n","import getInterpolationData from './getInterpolationData';\nexport default function getInterpolationDataCollection(viewportData, filterParams) {\n    const imageAnnotations = getInterpolationData(viewportData, filterParams);\n    const interpolatedDataCollection = [];\n    if (!imageAnnotations?.size) {\n        return interpolatedDataCollection;\n    }\n    for (const annotations of imageAnnotations.values()) {\n        annotations.forEach((annotation) => {\n            interpolatedDataCollection.push(annotation);\n        });\n    }\n    return interpolatedDataCollection;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nexport default function createPolylineToolData(polyline, handlePoints, referencedToolData) {\n    const annotation = csUtils.deepMerge({\n        data: {},\n        metadata: {},\n    }, referencedToolData);\n    Object.assign(annotation, {\n        highlighted: false,\n        invalidated: true,\n        autoGenerated: true,\n        annotationUID: undefined,\n        cachedStats: {},\n        childAnnotationUIDs: [],\n        parentAnnotationUID: undefined,\n    });\n    Object.assign(annotation.data, {\n        handles: {\n            points: handlePoints.points || handlePoints || [],\n            interpolationSources: handlePoints.sources,\n            activeHandleIndex: null,\n            textBox: {\n                hasMoved: false,\n                worldPosition: [0, 0, 0],\n                worldBoundingBox: {\n                    topLeft: [0, 0, 0],\n                    topRight: [0, 0, 0],\n                    bottomLeft: [0, 0, 0],\n                    bottomRight: [0, 0, 0],\n                },\n            },\n        },\n        contour: {\n            ...referencedToolData.data.contour,\n            polyline,\n        },\n    });\n    return annotation;\n}\n","import getInterpolationData from './getInterpolationData';\nfunction findAnnotationsForInterpolation(toolData, viewportData) {\n    const interpolationData = getInterpolationData(viewportData, [\n        {\n            key: 'interpolationUID',\n            value: viewportData.interpolationUID,\n        },\n    ]);\n    const rangeToInterpolate = getRangeToInterpolate(interpolationData);\n    if (!rangeToInterpolate) {\n        console.warn('No annotations found to interpolate', interpolationData);\n        return;\n    }\n    const sliceEdited = _getSlicePositionOfToolData(interpolationData, toolData.annotationUID);\n    const interpolationList = [];\n    for (let i = rangeToInterpolate[0] + 1; i < rangeToInterpolate[1]; i++) {\n        if (_sliceNeedsInterpolating(interpolationData, i)) {\n            const contourPair = _getBoundingPair(i, rangeToInterpolate, interpolationData);\n            if (contourPair?.[0] === sliceEdited ||\n                contourPair?.[1] === sliceEdited) {\n                _appendInterpolationList(contourPair, interpolationList, i);\n            }\n        }\n    }\n    return {\n        interpolationData,\n        interpolationList,\n    };\n}\nfunction getRangeToInterpolate(interpolationData) {\n    let first = Infinity;\n    let last = -Infinity;\n    let found = false;\n    for (const [sliceIndex, annotations] of interpolationData.entries()) {\n        if (annotations.length) {\n            first = Math.min(sliceIndex, first);\n            last = Math.max(sliceIndex, last);\n            found = true;\n        }\n    }\n    if (!found) {\n        return;\n    }\n    return [first, last];\n}\nfunction _getSlicePositionOfToolData(interpolationData, annotationUID) {\n    for (const [sliceIndex, annotations] of interpolationData) {\n        for (let j = 0; j < annotations.length; j++) {\n            if (annotations[j].annotationUID === annotationUID) {\n                return sliceIndex;\n            }\n        }\n    }\n    return;\n}\nfunction _sliceNeedsInterpolating(interpolationData, sliceIndex) {\n    const annotations = interpolationData.get(sliceIndex);\n    return (!annotations?.length ||\n        (annotations.length === 1 && annotations[0].autoGenerated));\n}\nfunction _appendInterpolationList(contourPair, interpolationList, itemIndex) {\n    const [startIndex] = contourPair;\n    interpolationList[startIndex] ||= {\n        pair: contourPair,\n        list: [],\n    };\n    interpolationList[startIndex].list.push(itemIndex);\n}\nfunction _getBoundingPair(sliceIndex, sliceRange, interpolationData) {\n    const annotationPair = [];\n    let canInterpolate = true;\n    for (let i = sliceIndex - 1; i >= sliceRange[0]; i--) {\n        const annotations = interpolationData.get(i);\n        if (annotations?.length) {\n            if (annotations[0].autoGenerated) {\n                continue;\n            }\n            if (annotations.length > 1) {\n                canInterpolate = false;\n            }\n            annotationPair.push(i);\n            break;\n        }\n    }\n    if (!canInterpolate || !annotationPair.length) {\n        return;\n    }\n    for (let i = sliceIndex + 1; i <= sliceRange[1]; i++) {\n        const annotations = interpolationData.get(i);\n        if (annotations?.length) {\n            if (annotations[0].autoGenerated) {\n                continue;\n            }\n            if (annotations.length > 1) {\n                canInterpolate = false;\n            }\n            annotationPair.push(i);\n            break;\n        }\n    }\n    if (!canInterpolate || annotationPair.length < 2) {\n        return;\n    }\n    return annotationPair;\n}\nexport default findAnnotationsForInterpolation;\n","import { vec3 } from 'gl-matrix';\nimport { utilities } from '@cornerstonejs/core';\nconst { PointsManager } = utilities;\nexport default function selectHandles(polyline, handleCount = 12) {\n    const handles = PointsManager.create3(handleCount);\n    handles.sources = [];\n    const { sources: destPoints } = handles;\n    const { length, sources: sourcePoints = [] } = polyline;\n    const distance = 5;\n    if (length < distance * 3) {\n        return polyline.subselect(handleCount);\n    }\n    const interval = Math.floor(Math.max((2 * length) / handleCount, distance * 2));\n    sourcePoints.forEach(() => destPoints.push(PointsManager.create3(handleCount)));\n    const dotValues = createDotValues(polyline, distance);\n    const minimumRegions = findMinimumRegions(dotValues, handleCount);\n    const indices = [];\n    if (minimumRegions?.length > 2) {\n        let lastHandle = -1;\n        const thirdInterval = interval / 3;\n        minimumRegions.forEach((region) => {\n            const [start, , end] = region;\n            const midIndex = Math.ceil((start + end) / 2);\n            if (end - lastHandle < thirdInterval) {\n                return;\n            }\n            if (midIndex - start > 2 * thirdInterval) {\n                addInterval(indices, lastHandle, start, interval, length);\n                lastHandle = addInterval(indices, start, midIndex, interval, length);\n            }\n            else {\n                lastHandle = addInterval(indices, lastHandle, midIndex, interval, length);\n            }\n            if (end - lastHandle > thirdInterval) {\n                lastHandle = addInterval(indices, lastHandle, end, interval, length);\n            }\n        });\n        const firstHandle = indices[0];\n        const lastDistance = indexValue(firstHandle + length - lastHandle, length);\n        if (lastDistance > 2 * thirdInterval) {\n            addInterval(indices, lastHandle, firstHandle - thirdInterval, interval, length);\n        }\n    }\n    else {\n        const interval = Math.floor(length / handleCount);\n        addInterval(indices, -1, length - interval, interval, length);\n    }\n    indices.forEach((index) => {\n        const point = polyline.getPointArray(index);\n        handles.push(point);\n        sourcePoints.forEach((source, destSourceIndex) => destPoints[destSourceIndex].push(source.getPoint(index)));\n    });\n    return handles;\n}\nexport function createDotValues(polyline, distance = 6) {\n    const { length } = polyline;\n    const prevVec3 = vec3.create();\n    const nextVec3 = vec3.create();\n    const dotValues = new Float32Array(length);\n    for (let i = 0; i < length; i++) {\n        const point = polyline.getPoint(i);\n        const prevPoint = polyline.getPoint(i - distance);\n        const nextPoint = polyline.getPoint((i + distance) % length);\n        vec3.sub(prevVec3, point, prevPoint);\n        vec3.sub(nextVec3, nextPoint, point);\n        const dot = vec3.dot(prevVec3, nextVec3) / (vec3.len(prevVec3) * vec3.len(nextVec3));\n        dotValues[i] = dot;\n    }\n    return dotValues;\n}\nfunction findMinimumRegions(dotValues, handleCount) {\n    const { max, deviation } = getStats(dotValues);\n    const { length } = dotValues;\n    if (deviation < 0.01 || length < handleCount * 3) {\n        return [];\n    }\n    const inflection = [];\n    let pair = null;\n    let minValue;\n    let minIndex = 0;\n    for (let i = 0; i < length; i++) {\n        const dot = dotValues[i];\n        if (dot < max - deviation) {\n            if (pair) {\n                pair[2] = i;\n                if (dot < minValue) {\n                    minValue = dot;\n                    minIndex = i;\n                }\n                pair[1] = minIndex;\n            }\n            else {\n                minValue = dot;\n                minIndex = i;\n                pair = [i, i, i];\n            }\n        }\n        else {\n            if (pair) {\n                inflection.push(pair);\n                pair = null;\n            }\n        }\n    }\n    if (pair) {\n        if (inflection[0][0] === 0) {\n            inflection[0][0] = pair[0];\n        }\n        else {\n            pair[1] = minIndex;\n            pair[2] = length - 1;\n            inflection.push(pair);\n        }\n    }\n    return inflection;\n}\nexport function addInterval(indices, start, finish, interval, length) {\n    if (finish < start) {\n        finish += length;\n    }\n    const distance = finish - start;\n    const count = Math.ceil(distance / interval);\n    if (count <= 0) {\n        if (indices[indices.length - 1] !== finish) {\n            indices.push(indexValue(finish, length));\n        }\n        return finish;\n    }\n    for (let i = 1; i <= count; i++) {\n        const index = indexValue(start + (i * distance) / count, length);\n        indices.push(index);\n    }\n    return indices[indices.length - 1];\n}\nfunction indexValue(v, length) {\n    return (Math.round(v) + length) % length;\n}\nfunction getStats(dotValues) {\n    const { length } = dotValues;\n    let sum = 0;\n    let min = Infinity;\n    let max = -Infinity;\n    let sumSq = 0;\n    for (let i = 0; i < length; i++) {\n        const dot = dotValues[i];\n        sum += dot;\n        min = Math.min(min, dot);\n        max = Math.max(max, dot);\n    }\n    const mean = sum / length;\n    for (let i = 0; i < length; i++) {\n        const valueDiff = dotValues[i] - mean;\n        sumSq += valueDiff * valueDiff;\n    }\n    return {\n        mean,\n        max,\n        min,\n        sumSq,\n        deviation: Math.sqrt(sumSq / length),\n    };\n}\n","import { eventTarget, triggerEvent, utilities } from '@cornerstonejs/core';\nimport { vec3 } from 'gl-matrix';\nimport createPolylineToolData from './createPolylineToolData';\nimport findAnnotationsForInterpolation from './findAnnotationForInterpolation';\nimport EventTypes from '../../../enums/Events';\nimport * as annotationState from '../../../stateManagement/annotation';\nimport selectHandles from './selectHandles';\nimport updateChildInterpolationUID from './updateChildInterpolationUID';\nimport { createPolylineHole } from '../../contourSegmentation';\nconst { PointsManager } = utilities;\nconst dP = 0.2;\nfunction interpolate(viewportData) {\n    if (!viewportData.annotation) {\n        return;\n    }\n    const { isInterpolationUpdate, annotation } = viewportData;\n    queueMicrotask(() => {\n        try {\n            if (isInterpolationUpdate) {\n                annotation.isInterpolationUpdate = true;\n                annotation.autoGenerated = false;\n            }\n            startInterpolation(viewportData);\n        }\n        finally {\n            if (isInterpolationUpdate) {\n                annotation.autoGenerated = true;\n            }\n        }\n    });\n}\nfunction startInterpolation(viewportData) {\n    const { annotation: toolData } = viewportData;\n    updateChildInterpolationUID(toolData);\n    const { interpolationData, interpolationList } = findAnnotationsForInterpolation(toolData, viewportData) || {};\n    if (!interpolationData || !interpolationList) {\n        return;\n    }\n    const eventData = {\n        toolName: toolData.metadata.toolName,\n        toolType: toolData.metadata.toolName,\n        viewport: viewportData.viewport,\n    };\n    for (let i = 0; i < interpolationList.length; i++) {\n        if (interpolationList[i]) {\n            _linearlyInterpolateBetween(interpolationList[i].list, interpolationList[i].pair, interpolationData, eventData);\n        }\n    }\n    const { id, renderingEngineId, element } = viewportData.viewport;\n    const eventDetails = {\n        annotation: toolData,\n        element,\n        viewportId: id,\n        renderingEngineId,\n    };\n    if (interpolationList.length) {\n        triggerEvent(viewportData.viewport.element, EventTypes.ANNOTATION_INTERPOLATION_PROCESS_COMPLETED, eventDetails);\n        triggerEvent(eventTarget, EventTypes.ANNOTATION_INTERPOLATION_PROCESS_COMPLETED, eventDetails);\n    }\n}\nfunction _linearlyInterpolateBetween(indices, annotationPair, interpolationData, eventData) {\n    const annotation0 = interpolationData.get(annotationPair[0])[0];\n    const annotation1 = interpolationData.get(annotationPair[1])[0];\n    const c1 = _generateClosedContour(annotation0.data.contour.polyline);\n    const c2 = _generateClosedContour(annotation1.data.contour.polyline);\n    const { c1Interp, c2Interp } = _generateInterpolationContourPair(c1, c2);\n    c1Interp.kIndex = annotationPair[0];\n    c2Interp.kIndex = annotationPair[1];\n    indices.forEach(function (index) {\n        _linearlyInterpolateContour(c1Interp, c2Interp, index, annotationPair, interpolationData, c1.x.length > c2.x.length, eventData);\n    });\n}\nfunction getPointCount(pointArray) {\n    let sum = 0;\n    for (let i = 0; i < pointArray.I.length; i++) {\n        if (pointArray.I[i]) {\n            sum++;\n        }\n    }\n    return sum;\n}\nfunction _linearlyInterpolateContour(c1Interp, c2Interp, sliceIndex, annotationPair, interpolationData, c1HasMoreNodes, eventData) {\n    const [startIndex, endIndex] = annotationPair;\n    const zInterp = (sliceIndex - startIndex) / (endIndex - startIndex);\n    const annotation0 = interpolationData.get(startIndex)[0];\n    const annotation1 = interpolationData.get(endIndex)[0];\n    const interpolated3DPoints = _generateInterpolatedOpenContour(c1Interp, c2Interp, zInterp, c1HasMoreNodes);\n    const nearestAnnotation = zInterp > 0.5 ? annotation1 : annotation0;\n    const handlePoints = selectHandles(interpolated3DPoints);\n    if (interpolationData.has(sliceIndex)) {\n        _editInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, nearestAnnotation, eventData);\n    }\n    else {\n        _addInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, nearestAnnotation, eventData);\n    }\n}\nfunction _addInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, referencedToolData, eventData) {\n    const points = interpolated3DPoints.points;\n    const { viewport } = eventData;\n    const interpolatedAnnotation = createPolylineToolData(points, handlePoints, referencedToolData);\n    const viewRef = viewport.getViewReference({ sliceIndex });\n    if (!viewRef) {\n        throw new Error(`Can't find slice ${sliceIndex}`);\n    }\n    Object.assign(interpolatedAnnotation.metadata, viewRef);\n    annotationState.state.addAnnotation(interpolatedAnnotation, viewport.element);\n    referencedToolData.onInterpolationComplete?.(interpolatedAnnotation, referencedToolData);\n    const { parentAnnotationUID } = referencedToolData;\n    if (parentAnnotationUID) {\n        const parentReferenced = annotationState.state.getAnnotation(parentAnnotationUID);\n        const parentAnnotation = _findExistingAnnotation(parentReferenced, sliceIndex, eventData);\n        createPolylineHole(viewport, parentAnnotation, interpolatedAnnotation);\n    }\n}\nfunction _findExistingAnnotation(referencedToolData, sliceIndex, eventData) {\n    const { viewport } = eventData;\n    const annotations = annotationState.state.getAnnotations(referencedToolData.metadata.toolName, viewport.element);\n    for (let i = 0; i < annotations.length; i++) {\n        const annotation = annotations[i];\n        if (annotation.interpolationUID === referencedToolData.interpolationUID &&\n            annotation.metadata.sliceIndex === sliceIndex) {\n            return annotation;\n        }\n    }\n}\nfunction _editInterpolatedContour(interpolated3DPoints, handlePoints, sliceIndex, referencedToolData, eventData) {\n    const oldAnnotationData = _findExistingAnnotation(referencedToolData, sliceIndex, eventData);\n    const points = interpolated3DPoints.points;\n    const interpolatedAnnotation = createPolylineToolData(points, handlePoints, oldAnnotationData);\n    Object.assign(oldAnnotationData, {\n        metadata: interpolatedAnnotation.metadata,\n        data: interpolatedAnnotation.data,\n    });\n}\nfunction _generateInterpolatedOpenContour(c1ir, c2ir, zInterp, c1HasMoreNodes) {\n    const indices = c1HasMoreNodes ? c1ir.I : c2ir.I;\n    const c1 = PointsManager.fromXYZ(c1ir);\n    const c2 = PointsManager.fromXYZ(c2ir);\n    const { length } = c1;\n    const cInterp = PointsManager.create3(length);\n    const vecSubtract = vec3.create();\n    const vecResult = vec3.create();\n    const c1Source = PointsManager.create3(length);\n    c1Source.kIndex = c1ir.kIndex;\n    const c2Source = PointsManager.create3(length);\n    c2Source.kIndex = c2ir.kIndex;\n    for (let i = 0; i < c1ir.x.length; i++) {\n        if (indices[i]) {\n            const c1point = c1.getPoint(i);\n            const c2point = c2.getPoint(i);\n            c1Source.push(c1point);\n            c2Source.push(c2point);\n            vec3.sub(vecSubtract, c2point, c1point);\n            cInterp.push(vec3.scaleAndAdd(vecResult, c1point, vecSubtract, zInterp));\n        }\n    }\n    cInterp.sources = [c1Source, c2Source];\n    return cInterp;\n}\nfunction _generateInterpolationContourPair(c1, c2) {\n    const cumPerim1 = _getCumulativePerimeter(c1);\n    const cumPerim2 = _getCumulativePerimeter(c2);\n    const interpNodes = Math.max(Math.ceil(cumPerim1[cumPerim1.length - 1] / dP), Math.ceil(cumPerim2[cumPerim2.length - 1] / dP));\n    const cumPerim1Norm = _normalisedCumulativePerimeter(cumPerim1);\n    const cumPerim2Norm = _normalisedCumulativePerimeter(cumPerim2);\n    const numNodes1 = interpNodes + c2.x.length;\n    const numNodes2 = interpNodes + c1.x.length;\n    const perim1Interp = _getInterpolatedPerim(numNodes1, cumPerim1Norm);\n    const perim2Interp = _getInterpolatedPerim(numNodes2, cumPerim2Norm);\n    const perim1Ind = _getIndicatorArray(numNodes1 - 2, c1.x.length);\n    const perim2Ind = _getIndicatorArray(numNodes2 - 2, c2.x.length);\n    const nodesPerSegment1 = _getNodesPerSegment(perim1Interp, perim1Ind);\n    const nodesPerSegment2 = _getNodesPerSegment(perim2Interp, perim2Ind);\n    const c1i = _getSuperSampledContour(c1, nodesPerSegment1);\n    const c2i = _getSuperSampledContour(c2, nodesPerSegment2);\n    _shiftSuperSampledContourInPlace(c1i, c2i);\n    return _reduceContoursToOriginNodes(c1i, c2i);\n}\nfunction _reduceContoursToOriginNodes(c1i, c2i) {\n    const c1Interp = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    const c2Interp = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    for (let i = 0; i < c1i.x.length; i++) {\n        if (c1i.I[i] || c2i.I[i]) {\n            c1Interp.x.push(c1i.x[i]);\n            c1Interp.y.push(c1i.y[i]);\n            c1Interp.z.push(c1i.z[i]);\n            c1Interp.I.push(c1i.I[i]);\n            c2Interp.x.push(c2i.x[i]);\n            c2Interp.y.push(c2i.y[i]);\n            c2Interp.z.push(c2i.z[i]);\n            c2Interp.I.push(c2i.I[i]);\n        }\n    }\n    return {\n        c1Interp,\n        c2Interp,\n    };\n}\nfunction _shiftSuperSampledContourInPlace(c1i, c2i) {\n    const c1iLength = c1i.x.length;\n    const optimal = {\n        startingNode: 0,\n        totalSquaredXYLengths: Infinity,\n    };\n    for (let startingNode = 0; startingNode < c1iLength; startingNode++) {\n        let node = startingNode;\n        let totalSquaredXYLengths = 0;\n        for (let iteration = 0; iteration < c1iLength; iteration++) {\n            totalSquaredXYLengths +=\n                (c1i.x[node] - c2i.x[iteration]) ** 2 +\n                    (c1i.y[node] - c2i.y[iteration]) ** 2 +\n                    (c1i.z[node] - c2i.z[iteration]) ** 2;\n            node++;\n            if (node === c1iLength) {\n                node = 0;\n            }\n        }\n        if (totalSquaredXYLengths < optimal.totalSquaredXYLengths) {\n            optimal.totalSquaredXYLengths = totalSquaredXYLengths;\n            optimal.startingNode = startingNode;\n        }\n    }\n    const node = optimal.startingNode;\n    _shiftCircularArray(c1i.x, node);\n    _shiftCircularArray(c1i.y, node);\n    _shiftCircularArray(c1i.z, node);\n    _shiftCircularArray(c1i.I, node);\n}\nfunction _shiftCircularArray(arr, count) {\n    count -= arr.length * Math.floor(count / arr.length);\n    const slicedArray = arr.splice(0, count);\n    arr.push(...slicedArray);\n    return arr;\n}\nfunction _getSuperSampledContour(c, nodesPerSegment) {\n    const ci = {\n        x: [],\n        y: [],\n        z: [],\n        I: [],\n    };\n    for (let n = 0; n < c.x.length - 1; n++) {\n        ci.x.push(c.x[n]);\n        ci.y.push(c.y[n]);\n        ci.z.push(c.z[n]);\n        ci.I.push(true);\n        const xSpacing = (c.x[n + 1] - c.x[n]) / (nodesPerSegment[n] + 1);\n        const ySpacing = (c.y[n + 1] - c.y[n]) / (nodesPerSegment[n] + 1);\n        const zSpacing = (c.z[n + 1] - c.z[n]) / (nodesPerSegment[n] + 1);\n        for (let i = 0; i < nodesPerSegment[n] - 1; i++) {\n            ci.x.push(ci.x[ci.x.length - 1] + xSpacing);\n            ci.y.push(ci.y[ci.y.length - 1] + ySpacing);\n            ci.z.push(ci.z[ci.z.length - 1] + zSpacing);\n            ci.I.push(false);\n        }\n    }\n    return ci;\n}\nfunction _getNodesPerSegment(perimInterp, perimInd) {\n    const idx = [];\n    for (let i = 0; i < perimInterp.length; ++i) {\n        idx[i] = i;\n    }\n    idx.sort(function (a, b) {\n        return perimInterp[a] < perimInterp[b] ? -1 : 1;\n    });\n    const perimIndSorted = [];\n    for (let i = 0; i < perimInd.length; i++) {\n        perimIndSorted.push(perimInd[idx[i]]);\n    }\n    const indicesOfOriginNodes = perimIndSorted.reduce(function (arr, elementValue, i) {\n        if (elementValue) {\n            arr.push(i);\n        }\n        return arr;\n    }, []);\n    const nodesPerSegment = [];\n    for (let i = 0; i < indicesOfOriginNodes.length - 1; i++) {\n        nodesPerSegment.push(indicesOfOriginNodes[i + 1] - indicesOfOriginNodes[i]);\n    }\n    return nodesPerSegment;\n}\nfunction _getIndicatorArray(numFalse, numTrue) {\n    const perimInd = new Array(numFalse + numTrue);\n    perimInd.fill(false, 0, numFalse);\n    perimInd.fill(true, numFalse, numFalse + numTrue);\n    return perimInd;\n}\nfunction _getInterpolatedPerim(numNodes, cumPerimNorm) {\n    const diff = 1 / (numNodes - 1);\n    const linspace = [diff];\n    for (let i = 1; i < numNodes - 2; i++) {\n        linspace.push(linspace[linspace.length - 1] + diff);\n    }\n    return linspace.concat(cumPerimNorm);\n}\nfunction _normalisedCumulativePerimeter(cumPerim) {\n    const cumPerimNorm = [];\n    for (let i = 0; i < cumPerim.length; i++) {\n        cumPerimNorm.push(cumPerim[i] / cumPerim[cumPerim.length - 1]);\n    }\n    return cumPerimNorm;\n}\nfunction _getCumulativePerimeter(contour) {\n    const cumulativePerimeter = [0];\n    for (let i = 1; i < contour.x.length; i++) {\n        const lengthOfSegment = Math.sqrt((contour.x[i] - contour.x[i - 1]) ** 2 +\n            (contour.y[i] - contour.y[i - 1]) ** 2 +\n            (contour.z[i] - contour.z[i - 1]) ** 2);\n        cumulativePerimeter.push(cumulativePerimeter[i - 1] + lengthOfSegment);\n    }\n    return cumulativePerimeter;\n}\nfunction _generateClosedContour(points) {\n    const c = {\n        x: [],\n        y: [],\n        z: [],\n    };\n    for (let i = 0; i < points.length; i++) {\n        c.x[i] = points[i][0];\n        c.y[i] = points[i][1];\n        c.z[i] = points[i][2];\n    }\n    c.x.push(c.x[0]);\n    c.y.push(c.y[0]);\n    c.z.push(c.z[0]);\n    return c;\n}\nexport default interpolate;\n","import * as annotationState from '../../../stateManagement/annotation';\nexport default function updateChildInterpolationUID(annotation) {\n    const { parentAnnotationUID, annotationUID } = annotation;\n    if (!parentAnnotationUID) {\n        return annotation.interpolationUID;\n    }\n    const parentAnnotation = annotationState.state.getAnnotation(parentAnnotationUID);\n    const { interpolationUID } = parentAnnotation;\n    const index = parentAnnotation.childAnnotationUIDs.indexOf(annotationUID);\n    annotation.interpolationUID = `${interpolationUID}-${index}`;\n    return annotation.interpolationUID;\n}\n","import { utilities } from '@cornerstonejs/core';\nimport { Calculator, InstanceCalculator } from './Calculator';\nconst { PointsManager } = utilities;\nfunction createBasicStatsState(storePointData) {\n    return {\n        max: [-Infinity],\n        min: [Infinity],\n        sum: [0],\n        count: 0,\n        maxIJK: null,\n        maxLPS: null,\n        minIJK: null,\n        minLPS: null,\n        runMean: [0],\n        m2: [0],\n        m3: [0],\n        m4: [0],\n        allValues: [[]],\n        pointsInShape: storePointData ? PointsManager.create3(1024) : null,\n        sumLPS: [0, 0, 0],\n    };\n}\nfunction basicStatsCallback(state, newValue, pointLPS = null, pointIJK = null) {\n    if (Array.isArray(newValue) &&\n        newValue.length > 1 &&\n        state.max.length === 1) {\n        state.max.push(state.max[0], state.max[0]);\n        state.min.push(state.min[0], state.min[0]);\n        state.sum.push(state.sum[0], state.sum[0]);\n        state.runMean.push(0, 0);\n        state.m2.push(state.m2[0], state.m2[0]);\n        state.m3.push(state.m3[0], state.m3[0]);\n        state.m4.push(state.m4[0], state.m4[0]);\n        state.allValues.push([], []);\n    }\n    if (state?.pointsInShape && pointLPS) {\n        state.pointsInShape.push(pointLPS);\n    }\n    const newArray = Array.isArray(newValue) ? newValue : [newValue];\n    state.count += 1;\n    if (pointLPS) {\n        state.sumLPS[0] += pointLPS[0];\n        state.sumLPS[1] += pointLPS[1];\n        state.sumLPS[2] += pointLPS[2];\n    }\n    state.max.forEach((it, idx) => {\n        const value = newArray[idx];\n        state.allValues[idx].push(value);\n        const n = state.count;\n        const delta = value - state.runMean[idx];\n        const delta_n = delta / n;\n        const term1 = delta * delta_n * (n - 1);\n        state.sum[idx] += value;\n        state.runMean[idx] += delta_n;\n        state.m4[idx] +=\n            term1 * delta_n * delta_n * (n * n - 3 * n + 3) +\n                6 * delta_n * delta_n * state.m2[idx] -\n                4 * delta_n * state.m3[idx];\n        state.m3[idx] += term1 * delta_n * (n - 2) - 3 * delta_n * state.m2[idx];\n        state.m2[idx] += term1;\n        if (value < state.min[idx]) {\n            state.min[idx] = value;\n            if (idx === 0) {\n                state.minIJK = pointIJK ? [...pointIJK] : null;\n                state.minLPS = pointLPS ? [...pointLPS] : null;\n            }\n        }\n        if (value > state.max[idx]) {\n            state.max[idx] = value;\n            if (idx === 0) {\n                state.maxIJK = pointIJK ? [...pointIJK] : null;\n                state.maxLPS = pointLPS ? [...pointLPS] : null;\n            }\n        }\n    });\n}\nfunction calculateMedian(values) {\n    if (values.length === 0) {\n        return 0;\n    }\n    const sorted = [...values].sort((a, b) => a - b);\n    const mid = Math.floor(sorted.length / 2);\n    if (sorted.length % 2 === 0) {\n        return (sorted[mid - 1] + sorted[mid]) / 2;\n    }\n    else {\n        return sorted[mid];\n    }\n}\nfunction basicGetStatistics(state, unit) {\n    const mean = state.sum.map((sum) => sum / state.count);\n    const stdDev = state.m2.map((squaredDiffSum) => Math.sqrt(squaredDiffSum / state.count));\n    const center = state.sumLPS.map((sum) => sum / state.count);\n    const skewness = state.m3.map((m3, idx) => {\n        const variance = state.m2[idx] / state.count;\n        if (variance === 0) {\n            return 0;\n        }\n        return m3 / (state.count * Math.pow(variance, 1.5));\n    });\n    const kurtosis = state.m4.map((m4, idx) => {\n        const variance = state.m2[idx] / state.count;\n        if (variance === 0) {\n            return 0;\n        }\n        return m4 / (state.count * variance * variance) - 3;\n    });\n    const median = state.allValues.map((values) => calculateMedian(values));\n    const named = {\n        max: {\n            name: 'max',\n            label: 'Max Pixel',\n            value: state.max.length === 1 ? state.max[0] : state.max,\n            unit,\n            pointIJK: state.maxIJK ? [...state.maxIJK] : null,\n            pointLPS: state.maxLPS ? [...state.maxLPS] : null,\n        },\n        min: {\n            name: 'min',\n            label: 'Min Pixel',\n            value: state.min.length === 1 ? state.min[0] : state.min,\n            unit,\n            pointIJK: state.minIJK ? [...state.minIJK] : null,\n            pointLPS: state.minLPS ? [...state.minLPS] : null,\n        },\n        mean: {\n            name: 'mean',\n            label: 'Mean Pixel',\n            value: mean.length === 1 ? mean[0] : mean,\n            unit,\n        },\n        stdDev: {\n            name: 'stdDev',\n            label: 'Standard Deviation',\n            value: stdDev.length === 1 ? stdDev[0] : stdDev,\n            unit,\n        },\n        count: {\n            name: 'count',\n            label: 'Voxel Count',\n            value: state.count,\n            unit: null,\n        },\n        median: {\n            name: 'median',\n            label: 'Median',\n            value: median.length === 1 ? median[0] : median,\n            unit,\n        },\n        skewness: {\n            name: 'skewness',\n            label: 'Skewness',\n            value: skewness.length === 1 ? skewness[0] : skewness,\n            unit: null,\n        },\n        kurtosis: {\n            name: 'kurtosis',\n            label: 'Kurtosis',\n            value: kurtosis.length === 1 ? kurtosis[0] : kurtosis,\n            unit: null,\n        },\n        maxLPS: {\n            name: 'maxLPS',\n            label: 'Max LPS',\n            value: state.maxLPS ? Array.from(state.maxLPS) : null,\n            unit: null,\n        },\n        minLPS: {\n            name: 'minLPS',\n            label: 'Min LPS',\n            value: state.minLPS ? Array.from(state.minLPS) : null,\n            unit: null,\n        },\n        pointsInShape: state.pointsInShape,\n        center: {\n            name: 'center',\n            label: 'Center',\n            value: center ? [...center] : null,\n            unit: null,\n        },\n        array: [],\n    };\n    named.array.push(named.min, named.max, named.mean, named.stdDev, named.median, named.skewness, named.kurtosis, named.count, named.maxLPS, named.minLPS);\n    if (named.center.value) {\n        named.array.push(named.center);\n    }\n    const store = state.pointsInShape !== null;\n    const freshState = createBasicStatsState(store);\n    state.max = freshState.max;\n    state.min = freshState.min;\n    state.sum = freshState.sum;\n    state.count = freshState.count;\n    state.maxIJK = freshState.maxIJK;\n    state.maxLPS = freshState.maxLPS;\n    state.minIJK = freshState.minIJK;\n    state.minLPS = freshState.minLPS;\n    state.runMean = freshState.runMean;\n    state.m2 = freshState.m2;\n    state.m3 = freshState.m3;\n    state.m4 = freshState.m4;\n    state.allValues = freshState.allValues;\n    state.pointsInShape = freshState.pointsInShape;\n    state.sumLPS = freshState.sumLPS;\n    return named;\n}\nexport class BasicStatsCalculator extends Calculator {\n    static { this.state = createBasicStatsState(true); }\n    static statsInit(options) {\n        if (!options.storePointData) {\n            this.state.pointsInShape = null;\n        }\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    static { this.statsCallback = ({ value: newValue, pointLPS = null, pointIJK = null, }) => {\n        basicStatsCallback(this.state, newValue, pointLPS, pointIJK);\n    }; }\n    static { this.getStatistics = (options) => {\n        return basicGetStatistics(this.state, options?.unit);\n    }; }\n}\nexport class InstanceBasicStatsCalculator extends InstanceCalculator {\n    constructor(options) {\n        super(options);\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    statsInit(options) {\n        this.state = createBasicStatsState(options.storePointData);\n    }\n    statsCallback(data) {\n        basicStatsCallback(this.state, data.value, data.pointLPS, data.pointIJK);\n    }\n    getStatistics(options) {\n        return basicGetStatistics(this.state, options?.unit);\n    }\n}\n","import distanceToPointSquared from './distanceToPointSquared';\nexport default function distanceToPoint(lineStart, lineEnd, point) {\n    if (lineStart.length !== 2 || lineEnd.length !== 2 || point.length !== 2) {\n        throw Error('lineStart, lineEnd, and point should have 2 elements of [x, y]');\n    }\n    return Math.sqrt(distanceToPointSquared(lineStart, lineEnd, point));\n}\n","function sign(x) {\n    return typeof x === 'number'\n        ? x\n            ? x < 0\n                ? -1\n                : 1\n            : x === x\n                ? 0\n                : NaN\n        : NaN;\n}\nexport default function intersectLine(line1Start, line1End, line2Start, line2End, infinite = false) {\n    const [x1, y1] = line1Start;\n    const [x2, y2] = line1End;\n    const [x3, y3] = line2Start;\n    const [x4, y4] = line2End;\n    if (infinite) {\n        const denom = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\n        if (Math.abs(denom) < 1e-10) {\n            return undefined;\n        }\n        const t = ((x1 - x3) * (y3 - y4) - (y1 - y3) * (x3 - x4)) / denom;\n        const x = x1 + t * (x2 - x1);\n        const y = y1 + t * (y2 - y1);\n        return [x, y];\n    }\n    const a1 = y2 - y1;\n    const b1 = x1 - x2;\n    const c1 = x2 * y1 - x1 * y2;\n    const r3 = a1 * x3 + b1 * y3 + c1;\n    const r4 = a1 * x4 + b1 * y4 + c1;\n    if (r3 !== 0 && r4 !== 0 && sign(r3) === sign(r4)) {\n        return undefined;\n    }\n    const a2 = y4 - y3;\n    const b2 = x3 - x4;\n    const c2 = x4 * y3 - x3 * y4;\n    const r1 = a2 * x1 + b2 * y1 + c2;\n    const r2 = a2 * x2 + b2 * y2 + c2;\n    if (r1 !== 0 && r2 !== 0 && sign(r1) === sign(r2)) {\n        return undefined;\n    }\n    const denomSegment = a1 * b2 - a2 * b1;\n    let num;\n    num = b1 * c2 - b2 * c1;\n    const x = num / denomSegment;\n    num = a2 * c1 - a1 * c2;\n    const y = num / denomSegment;\n    const intersectionPoint = [x, y];\n    return intersectionPoint;\n}\n","import * as lineSegment from '../line';\nfunction rectToLineSegments(left, top, width, height) {\n    const topLineStart = [left, top];\n    const topLineEnd = [left + width, top];\n    const rightLineStart = [left + width, top];\n    const rightLineEnd = [left + width, top + height];\n    const bottomLineStart = [left + width, top + height];\n    const bottomLineEnd = [left, top + height];\n    const leftLineStart = [left, top + height];\n    const leftLineEnd = [left, top];\n    const lineSegments = {\n        top: [topLineStart, topLineEnd],\n        right: [rightLineStart, rightLineEnd],\n        bottom: [bottomLineStart, bottomLineEnd],\n        left: [leftLineStart, leftLineEnd],\n    };\n    return lineSegments;\n}\nexport default function distanceToPoint(rect, point) {\n    if (rect.length !== 4 || point.length !== 2) {\n        throw Error('rectangle:[left, top, width, height] or point: [x,y] not defined correctly');\n    }\n    const [left, top, width, height] = rect;\n    let minDistance = 655535;\n    const lineSegments = rectToLineSegments(left, top, width, height);\n    Object.keys(lineSegments).forEach((segment) => {\n        const [lineStart, lineEnd] = lineSegments[segment];\n        const distance = lineSegment.distanceToPoint(lineStart, lineEnd, point);\n        if (distance < minDistance) {\n            minDistance = distance;\n        }\n    });\n    return minDistance;\n}\n","import { interpolateBasis as d3InterpolateBasis, quantize as d3Quantize, } from 'd3-interpolate';\nimport { zip as d3Zip } from 'd3-array';\nfunction isPoints3D(points) {\n    return points[0]?.length === 3;\n}\nexport function interpolatePoints(originalPoints, knotsIndexes) {\n    if (!knotsIndexes ||\n        knotsIndexes.length === 0 ||\n        knotsIndexes.length === originalPoints.length) {\n        return originalPoints;\n    }\n    const n = knotsIndexes[knotsIndexes.length - 1] - knotsIndexes[0] + 1;\n    const xInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][0]));\n    const yInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][1]));\n    if (isPoints3D(originalPoints)) {\n        const zInterpolator = d3InterpolateBasis(knotsIndexes.map((k) => originalPoints[k][2]));\n        return (d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n), d3Quantize(zInterpolator, n)));\n    }\n    else {\n        return (d3Zip(d3Quantize(xInterpolator, n), d3Quantize(yInterpolator, n)));\n    }\n}\n","import { point } from '../math';\nimport interpolateSegmentPoints from './interpolation/interpolateSegmentPoints';\nexport function shouldSmooth(configuration, annotation) {\n    if (annotation?.autoGenerated) {\n        return false;\n    }\n    const shouldSmooth = configuration?.smoothing?.smoothOnAdd === true ||\n        configuration?.smoothing?.smoothOnEdit === true;\n    return shouldSmooth;\n}\nfunction isEqualByProximity(pointA, pointB) {\n    return point.distanceToPoint(pointA, pointB) < 0.001;\n}\nfunction isEqual(pointA, pointB) {\n    return point.distanceToPoint(pointA, pointB) === 0;\n}\nfunction findMatchIndexes(points, otherPoints) {\n    for (let i = 0; i < points.length; i++) {\n        for (let j = 0; j < otherPoints.length; j++) {\n            if (isEqual(points[i], otherPoints[j])) {\n                return [i, j];\n            }\n        }\n    }\n}\nfunction followingIndex(index, size, direction) {\n    return (index + size + direction) % size;\n}\nfunction circularFindNextIndexBy(listParams, otherListParams, criteria, direction) {\n    const [, indexDelimiter, points] = listParams;\n    const [, otherIndexDelimiter, otherPoints] = otherListParams;\n    const pointsLength = points.length;\n    const otherPointsLength = otherPoints.length;\n    let startIndex = listParams[0];\n    let otherStartIndex = otherListParams[0];\n    if (!points[startIndex] ||\n        !otherPoints[otherStartIndex] ||\n        !points[indexDelimiter] ||\n        !otherPoints[otherIndexDelimiter]) {\n        return [undefined, undefined];\n    }\n    while (startIndex !== indexDelimiter &&\n        otherStartIndex !== otherIndexDelimiter) {\n        if (criteria(otherPoints[otherStartIndex], points[startIndex])) {\n            return [startIndex, otherStartIndex];\n        }\n        startIndex = followingIndex(startIndex, pointsLength, direction);\n        otherStartIndex = followingIndex(otherStartIndex, otherPointsLength, direction);\n    }\n    return [undefined, undefined];\n}\nfunction findChangedSegment(points, previousPoints) {\n    const [firstMatchIndex, previousFirstMatchIndex] = findMatchIndexes(points, previousPoints) || [];\n    const toBeNotEqualCriteria = (pointA, pointB) => isEqualByProximity(pointA, pointB) === false;\n    const [lowDiffIndex, lowOtherDiffIndex] = circularFindNextIndexBy([\n        followingIndex(firstMatchIndex, points.length, 1),\n        firstMatchIndex,\n        points,\n    ], [\n        followingIndex(previousFirstMatchIndex, previousPoints.length, 1),\n        previousFirstMatchIndex,\n        previousPoints,\n    ], toBeNotEqualCriteria, 1);\n    const [highIndex] = circularFindNextIndexBy([followingIndex(lowDiffIndex, points.length, -1), lowDiffIndex, points], [\n        followingIndex(lowOtherDiffIndex, previousPoints.length, -1),\n        lowOtherDiffIndex,\n        previousPoints,\n    ], toBeNotEqualCriteria, -1);\n    return [lowDiffIndex, highIndex];\n}\nexport function getInterpolatedPoints(configuration, points, pointsOfReference) {\n    const { interpolation, smoothing } = configuration;\n    const result = points;\n    if (interpolation) {\n        const { knotsRatioPercentageOnAdd, knotsRatioPercentageOnEdit, smoothOnAdd = false, smoothOnEdit = false, } = smoothing;\n        const knotsRatioPercentage = pointsOfReference\n            ? knotsRatioPercentageOnEdit\n            : knotsRatioPercentageOnAdd;\n        const isEnabled = pointsOfReference ? smoothOnEdit : smoothOnAdd;\n        if (isEnabled) {\n            const [changedIniIndex, changedEndIndex] = pointsOfReference\n                ? findChangedSegment(points, pointsOfReference)\n                : [0, points.length - 1];\n            if (!points[changedIniIndex] || !points[changedEndIndex]) {\n                return points;\n            }\n            return (interpolateSegmentPoints(points, changedIniIndex, changedEndIndex, knotsRatioPercentage));\n        }\n    }\n    return result;\n}\n","import { StackViewport, VolumeViewport, utilities as csUtils, } from '@cornerstonejs/core';\nimport filterAnnotationsWithinSlice from './filterAnnotationsWithinSlice';\nexport default function filterAnnotationsForDisplay(viewport, annotations, filterOptions = {}) {\n    if (viewport instanceof VolumeViewport) {\n        const camera = viewport.getCamera();\n        const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera);\n        return filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection);\n    }\n    if (viewport instanceof StackViewport) {\n        const imageId = viewport.getCurrentImageId();\n        if (!imageId) {\n            return [];\n        }\n        const colonIndex = imageId.indexOf(':');\n        filterOptions.imageURI = imageId.substring(colonIndex + 1);\n    }\n    return annotations.filter((annotation) => {\n        if (!annotation.isVisible) {\n            return false;\n        }\n        if (annotation.data.isCanvasAnnotation) {\n            return true;\n        }\n        return viewport.isReferenceViewable(annotation.metadata, filterOptions);\n    });\n}\n","import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData } from '@cornerstonejs/core';\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nexport function filterAnnotationsWithinSamePlane(annotations, camera) {\n    const { viewPlaneNormal } = camera;\n    const annotationsWithParallelNormals = annotations.filter((td) => {\n        let annotationViewPlaneNormal = td.metadata.viewPlaneNormal;\n        if (!annotationViewPlaneNormal) {\n            const { referencedImageId } = td.metadata;\n            const { imageOrientationPatient } = metaData.get('imagePlaneModule', referencedImageId);\n            const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n            const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n            annotationViewPlaneNormal = vec3.create();\n            vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n            td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n        }\n        const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n            PARALLEL_THRESHOLD;\n        return annotationViewPlaneNormal && isParallel;\n    });\n    if (!annotationsWithParallelNormals.length) {\n        return [];\n    }\n    return annotationsWithParallelNormals;\n}\n","import { vec3 } from 'gl-matrix';\nimport { CONSTANTS, metaData, utilities } from '@cornerstonejs/core';\nconst { isEqual } = utilities;\nconst { EPSILON } = CONSTANTS;\nconst PARALLEL_THRESHOLD = 1 - EPSILON;\nexport default function filterAnnotationsWithinSlice(annotations, camera, spacingInNormalDirection) {\n    const { viewPlaneNormal } = camera;\n    const annotationsWithParallelNormals = annotations.filter((td) => {\n        const { planeRestriction, referencedImageId } = td.metadata;\n        let { viewPlaneNormal: annotationViewPlaneNormal } = td.metadata;\n        if (planeRestriction) {\n            const { inPlaneVector1, inPlaneVector2 } = planeRestriction;\n            if (inPlaneVector1 &&\n                !isEqual(0, vec3.dot(viewPlaneNormal, inPlaneVector1))) {\n                return false;\n            }\n            if (inPlaneVector2 &&\n                !isEqual(0, vec3.dot(viewPlaneNormal, inPlaneVector2))) {\n                return false;\n            }\n            return true;\n        }\n        if (!td.metadata.referencedImageId &&\n            !annotationViewPlaneNormal &&\n            td.metadata.FrameOfReferenceUID) {\n            for (const point of td.data.handles.points) {\n                const vector = vec3.sub(vec3.create(), point, camera.focalPoint);\n                const dotProduct = vec3.dot(vector, viewPlaneNormal);\n                if (!isEqual(dotProduct, 0)) {\n                    return false;\n                }\n            }\n            td.metadata.viewPlaneNormal = viewPlaneNormal;\n            td.metadata.cameraFocalPoint = camera.focalPoint;\n            return true;\n        }\n        if (!annotationViewPlaneNormal && referencedImageId) {\n            const { imageOrientationPatient } = metaData.get('imagePlaneModule', referencedImageId);\n            const rowCosineVec = vec3.fromValues(imageOrientationPatient[0], imageOrientationPatient[1], imageOrientationPatient[2]);\n            const colCosineVec = vec3.fromValues(imageOrientationPatient[3], imageOrientationPatient[4], imageOrientationPatient[5]);\n            annotationViewPlaneNormal = vec3.create();\n            vec3.cross(annotationViewPlaneNormal, rowCosineVec, colCosineVec);\n            td.metadata.viewPlaneNormal = annotationViewPlaneNormal;\n        }\n        const isParallel = Math.abs(vec3.dot(viewPlaneNormal, annotationViewPlaneNormal)) >\n            PARALLEL_THRESHOLD;\n        return annotationViewPlaneNormal && isParallel;\n    });\n    if (!annotationsWithParallelNormals.length) {\n        return [];\n    }\n    const halfSpacingInNormalDirection = spacingInNormalDirection / 2;\n    const { focalPoint } = camera;\n    const annotationsWithinSlice = [];\n    for (const annotation of annotationsWithParallelNormals) {\n        const { data, metadata, isVisible } = annotation;\n        if (!isVisible) {\n            continue;\n        }\n        const point = metadata.planeRestriction?.point ||\n            data.handles?.points?.[0] ||\n            data.contour?.polyline[0];\n        if (!point) {\n            annotationsWithinSlice.push(annotation);\n            continue;\n        }\n        const dir = vec3.sub(vec3.create(), focalPoint, point);\n        const dot = Math.abs(vec3.dot(dir, viewPlaneNormal));\n        if (dot < halfSpacingInNormalDirection) {\n            annotationsWithinSlice.push(annotation);\n        }\n    }\n    return annotationsWithinSlice;\n}\n","import { utilities as csUtils } from '@cornerstonejs/core';\nexport function getPointInLineOfSightWithCriteria(viewport, worldPos, targetVolumeId, criteriaFunction, stepSize = 0.25) {\n    const points = getPointsInLineOfSight(viewport, worldPos, {\n        targetVolumeId,\n        stepSize,\n    });\n    let pickedPoint;\n    for (const point of points) {\n        const intensity = viewport.getIntensityFromWorld(point);\n        const pointToPick = criteriaFunction(intensity, point);\n        if (pointToPick) {\n            pickedPoint = pointToPick;\n        }\n    }\n    return pickedPoint;\n}\nexport function getPointsInLineOfSight(viewport, worldPos, { targetVolumeId, stepSize }) {\n    const camera = viewport.getCamera();\n    const { viewPlaneNormal: normalDirection } = camera;\n    const { spacingInNormalDirection } = csUtils.getTargetVolumeAndSpacingInNormalDir(viewport, camera, targetVolumeId);\n    const step = spacingInNormalDirection * stepSize || 1;\n    const bounds = viewport.getBounds();\n    const points = [];\n    let currentPos = [...worldPos];\n    while (_inBounds(currentPos, bounds)) {\n        points.push([...currentPos]);\n        currentPos[0] += normalDirection[0] * step;\n        currentPos[1] += normalDirection[1] * step;\n        currentPos[2] += normalDirection[2] * step;\n    }\n    currentPos = [...worldPos];\n    while (_inBounds(currentPos, bounds)) {\n        points.push([...currentPos]);\n        currentPos[0] -= normalDirection[0] * step;\n        currentPos[1] -= normalDirection[1] * step;\n        currentPos[2] -= normalDirection[2] * step;\n    }\n    return points;\n}\nconst _inBounds = function (point, bounds) {\n    const [xMin, xMax, yMin, yMax, zMin, zMax] = bounds;\n    const padding = 10;\n    return (point[0] > xMin + padding &&\n        point[0] < xMax - padding &&\n        point[1] > yMin + padding &&\n        point[1] < yMax - padding &&\n        point[2] > zMin + padding &&\n        point[2] < zMax - padding);\n};\n","import { vec3 } from 'gl-matrix';\nexport default function getWorldWidthAndHeightFromCorners(viewPlaneNormal, viewUp, topLeftWorld, bottomRightWorld) {\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const pos1 = vec3.fromValues(...topLeftWorld);\n    const pos2 = vec3.fromValues(...bottomRightWorld);\n    const diagonal = vec3.create();\n    vec3.subtract(diagonal, pos1, pos2);\n    const diagonalLength = vec3.length(diagonal);\n    if (diagonalLength < 0.0001) {\n        return { worldWidth: 0, worldHeight: 0 };\n    }\n    const cosTheta = vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n    const worldWidth = sinTheta * diagonalLength;\n    const worldHeight = cosTheta * diagonalLength;\n    return { worldWidth, worldHeight };\n}\n","import { vec3 } from 'gl-matrix';\nexport default function getWorldWidthAndHeightFromTwoPoints(viewPlaneNormal, viewUp, worldPos1, worldPos2) {\n    const viewRight = vec3.create();\n    vec3.cross(viewRight, viewUp, viewPlaneNormal);\n    const pos1 = vec3.fromValues(...worldPos1);\n    const pos2 = vec3.fromValues(...worldPos2);\n    const diagonal = vec3.create();\n    vec3.subtract(diagonal, pos1, pos2);\n    const diagonalLength = vec3.length(diagonal);\n    if (diagonalLength < 0.0001) {\n        return { worldWidth: 0, worldHeight: 0 };\n    }\n    const cosTheta = vec3.dot(diagonal, viewRight) / (diagonalLength * vec3.length(viewRight));\n    const sinTheta = Math.sqrt(1 - cosTheta * cosTheta);\n    const worldWidth = sinTheta * diagonalLength;\n    const worldHeight = cosTheta * diagonalLength;\n    return { worldWidth, worldHeight };\n}\n","import { vec3 } from 'gl-matrix';\nexport const isPlaneIntersectingAABB = (origin, normal, minX, minY, minZ, maxX, maxY, maxZ) => {\n    const vertices = [\n        vec3.fromValues(minX, minY, minZ),\n        vec3.fromValues(maxX, minY, minZ),\n        vec3.fromValues(minX, maxY, minZ),\n        vec3.fromValues(maxX, maxY, minZ),\n        vec3.fromValues(minX, minY, maxZ),\n        vec3.fromValues(maxX, minY, maxZ),\n        vec3.fromValues(minX, maxY, maxZ),\n        vec3.fromValues(maxX, maxY, maxZ),\n    ];\n    const normalVec = vec3.fromValues(normal[0], normal[1], normal[2]);\n    const originVec = vec3.fromValues(origin[0], origin[1], origin[2]);\n    const planeDistance = -vec3.dot(normalVec, originVec);\n    let initialSign = null;\n    for (const vertex of vertices) {\n        const distance = vec3.dot(normalVec, vertex) + planeDistance;\n        if (initialSign === null) {\n            initialSign = Math.sign(distance);\n        }\n        else if (Math.sign(distance) !== initialSign) {\n            return true;\n        }\n    }\n    return false;\n};\n","import { triggerEvent } from '@cornerstonejs/core';\nimport * as annotationStateManagement from '../../../stateManagement/annotation';\nimport interpolate from '../../contours/interpolation/interpolate';\nimport getInterpolationData from '../../contours/interpolation/getInterpolationData';\nimport EventTypes from '../../../enums/Events';\nexport default function deleteRelatedAnnotations(viewportData) {\n    const { annotation } = viewportData;\n    const interpolationAnnotations = getInterpolationData(viewportData, [\n        { key: 'interpolationUID', value: viewportData.interpolationUID },\n    ]);\n    const referencedSliceIndex = annotation.metadata.sliceIndex;\n    let minInterpolation = -1;\n    let maxInterpolation = viewportData.sliceData.numberOfSlices;\n    for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {\n        if (sliceIndex === referencedSliceIndex) {\n            continue;\n        }\n        const nonInterpolated = annotations.find((annotation) => !annotation.autoGenerated);\n        if (!nonInterpolated) {\n            continue;\n        }\n        if (sliceIndex < referencedSliceIndex) {\n            minInterpolation = Math.max(sliceIndex, minInterpolation);\n        }\n        else {\n            maxInterpolation = Math.min(sliceIndex, maxInterpolation);\n        }\n    }\n    const removedAnnotations = [];\n    for (const [sliceIndex, annotations] of interpolationAnnotations.entries()) {\n        if (sliceIndex <= minInterpolation ||\n            sliceIndex >= maxInterpolation ||\n            sliceIndex === referencedSliceIndex) {\n            continue;\n        }\n        annotations.forEach((annotationToDelete) => {\n            if (annotationToDelete.autoGenerated) {\n                annotationStateManagement.state.removeAnnotation(annotationToDelete.annotationUID);\n                removedAnnotations.push(annotationToDelete);\n            }\n        });\n    }\n    if (removedAnnotations.length) {\n        const eventDetails = {\n            annotations: removedAnnotations,\n            element: viewportData.viewport.element,\n            viewportId: viewportData.viewport.id,\n            renderingEngineId: viewportData.viewport.getRenderingEngine().id,\n        };\n        triggerEvent(viewportData.viewport.element, EventTypes.INTERPOLATED_ANNOTATIONS_REMOVED, eventDetails);\n    }\n    if (minInterpolation >= 0 &&\n        maxInterpolation < viewportData.sliceData.numberOfSlices) {\n        const nextAnnotation = interpolationAnnotations.get(maxInterpolation)[0];\n        const viewportNewData = {\n            viewport: viewportData.viewport,\n            sliceData: {\n                numberOfSlices: viewportData.sliceData.numberOfSlices,\n                imageIndex: nextAnnotation.metadata.sliceIndex,\n            },\n            annotation: nextAnnotation,\n            interpolationUID: nextAnnotation.interpolationUID,\n        };\n        interpolate(viewportNewData);\n    }\n}\n","import { eventTarget } from '@cornerstonejs/core';\nimport { Events } from '../../enums';\nimport addRepresentationData from '../../stateManagement/segmentation/internalAddRepresentationData';\nimport { triggerSegmentationModified } from '../../stateManagement/segmentation/triggerSegmentationEvents';\nimport debounce from '../debounce';\nconst computedRepresentations = new Map();\nasync function computeAndAddRepresentation(segmentationId, type, computeFunction, updateFunction, onComputationComplete) {\n    const data = await computeFunction();\n    addRepresentationData({\n        segmentationId,\n        type,\n        data,\n    });\n    onComputationComplete?.();\n    if (!computedRepresentations.has(segmentationId)) {\n        computedRepresentations.set(segmentationId, []);\n    }\n    const representations = computedRepresentations.get(segmentationId);\n    if (!representations.includes(type)) {\n        representations.push(type);\n    }\n    subscribeToSegmentationChanges(updateFunction);\n    triggerSegmentationModified(segmentationId);\n    return data;\n}\nfunction subscribeToSegmentationChanges(updateFunction) {\n    const debouncedUpdateFunction = (event) => {\n        _debouncedSegmentationModified(event, updateFunction);\n    };\n    updateFunction._debouncedUpdateFunction = debouncedUpdateFunction;\n    eventTarget.removeEventListener(Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);\n    eventTarget.addEventListener(Events.SEGMENTATION_DATA_MODIFIED, updateFunction._debouncedUpdateFunction);\n}\nconst _debouncedSegmentationModified = debounce((event, updateFunction) => {\n    const segmentationId = event.detail.segmentationId;\n    const representations = computedRepresentations.get(segmentationId);\n    if (!representations || !representations.length) {\n        return;\n    }\n    updateFunction(segmentationId);\n    if (representations.length) {\n        triggerSegmentationModified(segmentationId);\n    }\n}, 300);\nexport { computeAndAddRepresentation };\n","import { SegmentationRepresentations } from '../../enums';\nimport { getSegmentIndexColor } from '../../stateManagement/segmentation/config/segmentationColor';\nimport { getActiveSegmentation } from '../../stateManagement/segmentation/getActiveSegmentation';\nimport { getActiveSegmentIndex } from '../../stateManagement/segmentation/getActiveSegmentIndex';\nimport { getSegmentationRepresentationVisibility } from '../../stateManagement/segmentation/getSegmentationRepresentationVisibility';\nimport { internalGetHiddenSegmentIndices } from '../../stateManagement/segmentation/helpers/internalGetHiddenSegmentIndices';\nimport { segmentationStyle } from '../../stateManagement/segmentation/SegmentationStyle';\nexport function getSVGStyleForSegment({ segmentationId, segmentIndex, viewportId, autoGenerated = false, }) {\n    const segmentColor = getSegmentIndexColor(viewportId, segmentationId, segmentIndex);\n    const segmentationVisible = getSegmentationRepresentationVisibility(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n    });\n    const activeSegmentation = getActiveSegmentation(viewportId);\n    const isActive = activeSegmentation?.segmentationId === segmentationId;\n    const style = segmentationStyle.getStyle({\n        viewportId,\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n        segmentIndex,\n    });\n    const mergedConfig = style;\n    let lineWidth = 1;\n    let lineDash = undefined;\n    let lineOpacity = 1;\n    let fillOpacity = 0;\n    if (autoGenerated) {\n        lineWidth = mergedConfig.outlineWidthAutoGenerated ?? lineWidth;\n        lineDash = mergedConfig.outlineDashAutoGenerated ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlphaAutoGenerated ?? fillOpacity;\n    }\n    else if (isActive) {\n        lineWidth = mergedConfig.outlineWidth ?? lineWidth;\n        lineDash = mergedConfig.outlineDash ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacity ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlpha ?? fillOpacity;\n    }\n    else {\n        lineWidth = mergedConfig.outlineWidthInactive ?? lineWidth;\n        lineDash = mergedConfig.outlineDashInactive ?? lineDash;\n        lineOpacity = mergedConfig.outlineOpacityInactive ?? lineOpacity;\n        fillOpacity = mergedConfig.fillAlphaInactive ?? fillOpacity;\n    }\n    if (getActiveSegmentIndex(segmentationId) === segmentIndex) {\n        lineWidth += mergedConfig.activeSegmentOutlineWidthDelta;\n    }\n    lineWidth = mergedConfig.renderOutline ? lineWidth : 0;\n    fillOpacity = mergedConfig.renderFill ? fillOpacity : 0;\n    const color = `rgba(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]}, ${lineOpacity})`;\n    const fillColor = `rgb(${segmentColor[0]}, ${segmentColor[1]}, ${segmentColor[2]})`;\n    const hiddenSegments = internalGetHiddenSegmentIndices(viewportId, {\n        segmentationId,\n        type: SegmentationRepresentations.Contour,\n    });\n    const isVisible = !hiddenSegments.has(segmentIndex);\n    return {\n        color,\n        fillColor,\n        lineWidth,\n        fillOpacity,\n        lineDash,\n        textbox: {\n            color,\n        },\n        visibility: segmentationVisible && isVisible,\n    };\n}\n","import { getEnabledElement } from '@cornerstonejs/core';\nimport filterViewportsWithFrameOfReferenceUID from './filterViewportsWithFrameOfReferenceUID';\nimport filterViewportsWithToolEnabled from './filterViewportsWithToolEnabled';\nimport filterViewportsWithParallelNormals from './filterViewportsWithParallelNormals';\nexport default function getViewportIdsWithToolToRender(element, toolName, requireParallelNormals = true) {\n    const enabledElement = getEnabledElement(element);\n    const { renderingEngine, FrameOfReferenceUID } = enabledElement;\n    let viewports = renderingEngine.getViewports();\n    viewports = filterViewportsWithFrameOfReferenceUID(viewports, FrameOfReferenceUID);\n    viewports = filterViewportsWithToolEnabled(viewports, toolName);\n    const viewport = renderingEngine.getViewport(enabledElement.viewportId);\n    if (requireParallelNormals) {\n        viewports = filterViewportsWithParallelNormals(viewports, viewport.getCamera());\n    }\n    const viewportIds = viewports.map((vp) => vp.id);\n    return viewportIds;\n}\n"],"names":["annotationUID","drawingElementType","nodeUID","evt","shiftKey","ctrlKey","ShiftCtrl","altKey","ShiftAlt","metaKey","ShiftMeta","Shift","CtrlAlt","CtrlMeta","Ctrl","AltMeta","Alt","Meta","defaultManager","resetAnnotationManager","setAnnotationManager","setPreprocessingFn","annotation","uid","data","cachedStats","checkAndDefineCachedStatsProperty","handles","textBox","checkAndDefineTextBoxProperty","isLocked","checkAndSetAnnotationLocked","isVisible","checkAndSetAnnotationVisibility","triggerSegmentationAdded","segmentationId","eventDetail","triggerEvent","eventTarget","Events","SEGMENTATION_ADDED","triggerSegmentationModified","SEGMENTATION_MODIFIED","triggerSegmentationRemoved","SEGMENTATION_REMOVED","triggerSegmentationRepresentationModified","viewportId","type","SEGMENTATION_REPRESENTATION_MODIFIED","triggerSegmentationRepresentationRemoved","SEGMENTATION_REPRESENTATION_REMOVED","getSegmentation","internalGetHiddenSegmentIndices","specifier","representation","Set","Object","entries","segments","reduce","acc","segmentIndex","segment","visible","add","Number","MODES","ToolModes","Active","Passive","Enabled","toolName","toolGroups","filter","toolOptions","toolGroupToolNames","keys","i","length","includes","mode","getSubPixelSpacingAndXYDirections","addCanvasPointsToArray","getArea","polyline","activateClosedContourEdit","viewportIdsToRender","this","isEditingClosed","detail","currentPoints","element","canvasPos","canvas","enabledElement","getEnabledElement","viewport","prevCanvasPoints","contour","map","worldToCanvas","spacing","xDir","yDir","configuration","subPixelResolution","editData","editCanvasPoints","startCrossingIndex","undefined","editIndex","commonData","movingTextBox","isInteractingWithTool","addEventListener","MOUSE_UP","mouseUpClosedContourEditCallback","MOUSE_DRAG","mouseDragClosedContourEditCallback","MOUSE_CLICK","TOUCH_END","TOUCH_DRAG","TOUCH_TAP","hideElementCursor","deactivateClosedContourEdit","removeEventListener","resetElementCursor","worldPos","world","createMemo","lastCanvasPoint","lastWorldPoint","canvasToWorld","worldPosDiff","xDist","Math","abs","yDist","checkAndRemoveCrossesOnEditLine","currentEditIndex","checkForFirstCrossing","snapIndex","findSnapIndex","fusedCanvasPoints","fuseEditPointsWithClosedContour","checkForSecondCrossing","removePointsAfterSecondCrossing","finishEditAndStartNewEdit","renderingEngine","points","closed","targetWindingDirection","Clockwise","autoGenerated","triggerAnnotationModified","lastEditCanvasPoint","pop","augmentedEditCanvasPoints","lowIndex","highIndex","distanceBetweenLowAndFirstPoint","distanceBetweenLowAndLastPoint","distanceBetweenHighAndFirstPoint","distanceBetweenHighAndLastPoint","pointSet1","canvasPoint","push","inPlaceDistance","reverseDistance","pointSet2","completeClosedContourEdit","doneEditMemo","updatedPoints","decimateConfig","decimate","enabled","epsilon","cancelClosedContourEdit","toolInstance","bind","pointsAreWithinCloseContourProximity","getFirstLineSegmentIntersectionIndexes","activateDraw","isDrawing","contourHoleProcessingEnabled","event","contourHoleAdditionModifierKey","drawData","canvasPoints","polylineIndex","newAnnotation","mouseUpDrawCallback","mouseDragDrawCallback","deactivateDraw","deltaPoints","worldPosDelta","worldPosition","hasMoved","crossingIndex","findCrossingIndexDuringCreate","applyCreateOnCross","numPointsAdded","invalidated","ChangeTypes","HandlesUpdated","allowOpenContours","firstPoint","lastPoint","closeContourProximity","completeDrawOpenContour","completeDrawClosedContour","options","removeCrossedLinesOnCompleteDraw","minPointsToSave","haltDrawing","updateContourPolyline","triggerContourAnnotationCompleted","numPoints","endToStart","canvasPointsMinusEnds","slice","lineSegment","indexToRemoveUpTo","splice","worldPoints","isOpenUShapeContour","openUShapeContourVectorToPeak","lastPoints","pointsLessLastOne","remainingPoints","newArea","utilities","cancelDrawing","minPoints","max","shouldHaltDrawing","removeAnnotation","isClosedContour","crossedLineSegment","removePointsUpUntilFirstCrossing","checkCanvasEditFallbackProximity","firstEditCanvasPoint","distanceIndexPairs","prevCanvasPoint","distance","index","sort","a","b","twoClosestDistanceIndexPairs","lowestIndex","min","dir","proximity","extendedPoint","crossedLineSegmentFromExtendedPoint","pointsToPrepend","unshift","numPointsToRemove","firstLine","lastLine","didCrossLine","editCanvasPointsLessLastOne","snapCanvasPosition","editIndexCrossed","findOpenUShapedContourVectorToPeak","first","last","firstToLastUnitVector","normalVector1","normalVector2","centerOfFirstToLast","furthest","dist","findOpenUShapedContourVectorToPeakOnRender","activateOpenContourEdit","isEditingOpen","mouseUpOpenContourEditCallback","mouseDragOpenContourEditCallback","deactivateOpenContourEdit","fuseEditPointsWithOpenContour","finishEditOpenOnSecondCrossing","checkIfShouldOverwriteAnEnd","openContourEditOverwriteEnd","fuseEditPointsForOpenContourEndEdit","activeHandleIndex","activateOpenContourEndEdit","lastCanvasPos","p1","p2","p3","aDotb","magA","sqrt","magB","acos","PI","newCanvasPoints","pointsToRender","completeOpenContourEdit","cancelOpenContourEdit","handle","reverse","_getRenderingOptions","styleSpecifier","toolGroupId","getToolName","id","lineWidth","lineDash","color","fillColor","fillOpacity","getAnnotationStyle","width","closePath","renderContour","svgDrawingHelper","getImageData","renderClosedContour","calculateUShapeContourVectorToPeakIfNotPresent","renderOpenUShapedContour","renderOpenContour","parentAnnotationUID","allContours","drawPath","drawPolyline","alwaysRenderOpenContourHandles","radius","handleGroupUID","handlePoints","shift","drawHandles","handleRadius","handlePoint","firstCanvasPoint","openUShapeContourVectorToPeakCanvas","renderContourBeingDrawn","renderClosedContourBeingEdited","renderOpenContourBeingEdited","renderPointContourWithMarker","canvasPolyline","childContours","center","circlePoints","angle","x","cos","y","sin","crosshair","polylineUID","DefaultHistoryMemo","PointsManager","AnnotationTool","A","createAnnotationForViewport","annotationBaseData","createAnnotation","metadata","getViewReference","createAndAddAnnotation","addAnnotation","constructor","toolProps","defaultToolProps","super","mouseMoveCallback","filteredAnnotations","canvasCoords","annotationsNeedToBeRedrawn","isAnnotationLocked","isAnnotationVisible","activateHandleIndex","near","_imagePointNearToolOrHandle","nearToolAndNotMarkedActive","highlighted","notNearToolAndMarkedActive","isSuvScaled","getTextLines","statsCalculator","getHandleNearImagePoint","isCanvasAnnotation","worldBoundingBox","canvasBoundingBox","topLeft","topRight","bottomLeft","bottomRight","point","annotationCanvasCoordinate","getLinkedTextBoxStyle","specifications","visibility","getStyle","fontFamily","fontSize","shadow","background","targetId","imageId","BaseVolumeViewport","volumeId","volume","cache","getVolume","scaling","PT","scalingModule","metaData","suvbw","context","property","locked","angleArcLineDash","markerSize","lineOpacity","textbox","isPointNearTool","createAnnotationState","deleting","cloneData","spline","state","structuredClone","pointsManager","create3","createAnnotationMemo","annotationMemo","restoreMemo","newState","setViewReference","assign","annotationData","segmentation","addContourSegmentationAnnotation","setAnnotationSelected","render","currentAnnotation","getAnnotation","History","console","warn","operationType","memo","startGroupRecording","endGroupRecording","hydrateBase","ToolClass","FrameOfReferenceUID","getFrameOfReferenceUID","camera","getCamera","viewPlaneNormal","viewplaneNormal","viewUp","instance","referencedImageId","finalViewPlaneNormal","finalViewUp","StackViewport","closestImageIndex","getImageIds","Error","getReferencedImageId","ContourBaseTool","renderAnnotation","renderStatus","getRenderingEngine","annotations","getAnnotations","filterInteractableAnnotationsForElement","getTargetId","annotationStyle","annotationRendered","renderAnnotationInstance","interpolationUID","cancelAnnotation","moveAnnotation","getChildAnnotations","forEach","childAnnotation","polylineData","transforms","updateWindingDirection","getPolylinePoints","renderContext","polylineCanvasPoints","getContourHolesDataCanvas","ContourSegmentationBaseTool","PreviewSegmentIndex","interpolation","InterpolationManager","addTool","onSetToolConfiguration","removeTool","isContourSegmentationTool","contourAnnotation","activeSeg","getActiveSegmentation","representationData","Contour","getActiveSegmentIndex","contourSegAnnotation","removeContourSegmentationAnnotation","contourSegmentationStyle","_getContourSegmentationStyle","renderResult","triggerSegmentationDataModified","toolGroupIds","getViewportIdsWithSegmentation","getToolGroupForViewport","triggerAnnotationRenderForToolGroupIds","baseFilteredAnnotations","getSegmentationRepresentation","SegmentationRepresentations","segmentationRepresentations","segmentationRepresentation","find","rep","annotationLocked","getLockedSegmentIndices","getSVGStyleForSegment","defaultContourConfig","renderOutline","outlineWidthAutoGenerated","outlineWidth","outlineWidthInactive","outlineOpacity","outlineOpacityInactive","outlineDash","outlineDashInactive","outlineDashAutoGenerated","activeSegmentOutlineWidthDelta","renderFill","fillAlpha","fillAlphaInactive","fillAlphaAutoGenerated","handleContourSegmentation","geometryIds","annotationUIDsMap","contourRepresentation","size","segmentSpecificMap","Map","geometryId","geometry","getGeometry","Enums","CONTOUR","validateGeometry","segmentSpecificConfig","contourSet","contours","contourSegmentationAnnotation","annotationGroupSelector","set","addContourSetsToElement","internalCache","load","cfun","ofun","actor","getProperty","setRGBTransferFunction","setScalarOpacity","uuidv4","async","labelMapData","config","Labelmap","_ensureVolumeHasVolumeId","stackData","imageIds","volumeLoader","_handleMissingVolume","blendMode","MAXIMUM_INTENSITY_BLEND","useIndependentComponents","LABELMAP_EDGE_PROJECTION_BLEND","referenceVolumeId","getVolumeId","baseVolume","segDims","dimensions","refDims","debug","volumeInputs","representationUID","result","defaultActor","getDefaultActor","callback","get","added","volumeInputArray","firstImageVolume","segImageVolume","segData","voxelManager","getCompleteScalarDataArray","imageData","segImageData","baseData","cubeData","Float32Array","getScalarDataLength","dims","getDimensions","z","iTuple","removeActors","oldMapper","getMapper","mapper","convertMapperToNotSharedMapper","setMapper","setBlendMode","arrayAgain","getInputData","getPointData","getArray","onSegmentationDataModified","segVolumeId","segVoxelManager","array","getData","slices","Array","from","_","getAtIndex","setData","modified","setNumberOfComponents","setColorMixPreset","setForceNearestInterpolation","setIndependentComponents","addActor","referencedId","segmentationRepresentationUID","originalBlendMode","getBlendMode","preLoad","addEventListenerDebounced","SEGMENTATION_DATA_MODIFIED","actorEntry","getActor","createVolumeActor","volumeActor","addVolumesAsIndependentComponents","addVolumesToViewports","stackInputs","addImageSlicesToViewports","defaultLabelmapConfig","renderOutlineInactive","renderFillInactive","surface","surfaceActorEntry","surfaceActor","setVisibility","surfaceMapper","currentPolyData","newPoints","newPolys","polys","getPoints","currentPolys","getPolys","polyData","triangles","values","setPolys","setInputData","getRenderer","resetCameraClippingRange","surfacePolyData","setColor","setLineWidth","clippingFilter","resetCamera","filteredSurfaceActors","getActors","startsWith","BrushStrategy","COMPOSITIONS","childFunctions","StrategyCallbacks","OnInteractionStart","addListMethod","Initialize","OnInteractionEnd","Fill","CreateIsInThreshold","addSingletonMethod","Interpolate","AcceptPreview","RejectPreview","INTERNAL_setValue","Preview","ComputeInnerCircleRadius","EnsureSegmentationVolumeFor3DManipulation","EnsureImageVolumeFor3DManipulation","AddPreview","GetStatistics","compositions","name","initializers","_initialize","_fill","_onInteractionStart","fill","operationData","initializedData","initialize","func","segmentationVoxelManager","getArrayOfModifiedSlices","onInteractionStart","call","addPreview","configurationName","initializer","key","strategyFunction","operationName","strategy","imageVoxelManager","segmentationImageData","centerWorld","isInObject","isInObjectBoundsIJK","brushStrategy","createInitialized","listName","args","returnValue","value","isInitialized","previewSegmentIndex","centerIJK","useCenterSegmentIndex","centerSegmentIndexInfo","hasSegmentIndex","hasPreviewIndex","nestedBounds","getBoundsIJK","boundsIJK","existingValue","getAtIJKPoint","threshold","isDynamic","range","oldThreshold","dynamicRadius","useDelta","ijk","idx","Infinity","useDeltaSqr","pointIJK","gray","isArray","dynamicRadiusInCanvas","centerCanvas","clientWidth","clientHeight","radiusInWorld","offSetCenterInWorld","coord","offSetCenterCanvas","activeStrategy","islandRemoval","floodFillSegmentIsland","removeExternalIslands","removeInternalIslands","arrayOfSlices","preview","onInteractionEnd","previewColor","viewportIds","setSegmentIndexColor","changedIndices","labelmapMemo","oldValue","setAtIndex","undoIf","hasPreviewSegmentIndex","segmentsLocked","isWithinThreshold","createIsInThreshold","setValue","addPoint","useSegmentIndex","previewOnHover","centerSegmentIndex","handleUseSegmentCenterIndex","voxelValue","indices","getStatistics","segmentIndices","determineSegmentIndex","dynamicThreshold","erase","regionFill","labelmapStatistics","ensureSegmentationVolumeFor3DManipulation","ensureImageVolumeFor3DManipulation","eraseInsideCircle","eraseInsideSphere","transformWorldToIndex","sphereComposition","baseExtent","canvasCoordinates","p","cornersInWorld","corner","strokeRadius","strokeCenters","strokePointsWorld","baseBounds","baseCenterIJK","boundsToUse","centerPoint","translatedCenterIJK","deltaIJK","translatedBounds","SPHERE_STRATEGY","fillInsideSphere","SPHERE_THRESHOLD_STRATEGY","SPHERE_THRESHOLD_STRATEGY_ISLAND","thresholdInsideSphere","thresholdInsideSphereIsland","RectangleROIStartEndThreshold","getContourSequence","toolData","metadataProvider","projectionPoints","projectionPointsImageIds","ContourData","orderedPoints","pointsArrayWithPrecision","flat","toFixed","ContourImageSequence","sopCommon","ReferencedSOPClassUID","sopClassUID","ReferencedSOPInstanceUID","sopInstanceUID","getContourImageSequence","NumberOfContourPoints","ContourGeometricType","DEFAULT_CONTOUR_SEG_TOOLNAME","getInterpolationData","viewportData","filterParams","sliceData","interpolationDatas","originalToolName","testToolName","modifiedAnnotations","numberOfSlices","imageAnnotations","sliceIndex","filteredInterpolatedAnnotations","imageAnnotation","every","parent","parentKey","item","getInterpolationDataCollection","interpolatedDataCollection","createPolylineToolData","referencedToolData","childAnnotationUIDs","interpolationSources","sources","_sliceNeedsInterpolating","interpolationData","_appendInterpolationList","contourPair","interpolationList","itemIndex","startIndex","pair","list","_getBoundingPair","sliceRange","annotationPair","canInterpolate","rangeToInterpolate","found","getRangeToInterpolate","sliceEdited","j","_getSlicePositionOfToolData","selectHandles","handleCount","destPoints","sourcePoints","subselect","interval","floor","dotValues","prevVec3","nextVec3","getPoint","prevPoint","nextPoint","dot","createDotValues","minimumRegions","deviation","sum","sumSq","mean","valueDiff","getStats","inflection","minValue","minIndex","findMinimumRegions","lastHandle","thirdInterval","region","start","end","midIndex","ceil","addInterval","firstHandle","indexValue","getPointArray","source","destSourceIndex","finish","count","v","round","dP","_linearlyInterpolateBetween","eventData","annotation0","annotation1","c1","_generateClosedContour","c2","c1Interp","c2Interp","cumPerim1","_getCumulativePerimeter","cumPerim2","interpNodes","cumPerim1Norm","_normalisedCumulativePerimeter","cumPerim2Norm","numNodes1","numNodes2","perim1Interp","_getInterpolatedPerim","perim2Interp","perim1Ind","_getIndicatorArray","perim2Ind","nodesPerSegment1","_getNodesPerSegment","nodesPerSegment2","c1i","_getSuperSampledContour","c2i","c1iLength","optimal","startingNode","totalSquaredXYLengths","node","iteration","_shiftCircularArray","I","_shiftSuperSampledContourInPlace","_reduceContoursToOriginNodes","_generateInterpolationContourPair","kIndex","c1HasMoreNodes","endIndex","zInterp","interpolated3DPoints","c1ir","c2ir","fromXYZ","cInterp","vecSubtract","vecResult","c1Source","c2Source","c1point","c2point","_generateInterpolatedOpenContour","nearestAnnotation","has","oldAnnotationData","_findExistingAnnotation","interpolatedAnnotation","_editInterpolatedContour","viewRef","onInterpolationComplete","parentAnnotation","createPolylineHole","_addInterpolatedContour","_linearlyInterpolateContour","arr","slicedArray","c","nodesPerSegment","ci","n","xSpacing","ySpacing","zSpacing","perimInterp","perimInd","perimIndSorted","indicesOfOriginNodes","elementValue","numFalse","numTrue","numNodes","cumPerimNorm","diff","linspace","concat","cumPerim","cumulativePerimeter","lengthOfSegment","isInterpolationUpdate","queueMicrotask","indexOf","updateChildInterpolationUID","toolType","renderingEngineId","eventDetails","ANNOTATION_INTERPOLATION_PROCESS_COMPLETED","startInterpolation","createBasicStatsState","storePointData","maxIJK","maxLPS","minIJK","minLPS","runMean","m2","m3","m4","allValues","pointsInShape","sumLPS","basicStatsCallback","newValue","pointLPS","newArray","it","delta","delta_n","term1","basicGetStatistics","unit","stdDev","squaredDiffSum","skewness","variance","pow","kurtosis","median","sorted","mid","calculateMedian","named","label","freshState","BasicStatsCalculator","statsInit","statsCallback","InstanceBasicStatsCalculator","distanceToPoint","lineStart","lineEnd","sign","NaN","intersectLine","line1Start","line1End","line2Start","line2End","infinite","x1","y1","x2","y2","x3","y3","x4","y4","denom","t","a1","b1","r3","r4","a2","b2","r1","r2","denomSegment","num","rect","left","top","height","minDistance","lineSegments","right","bottom","rectToLineSegments","interpolatePoints","originalPoints","knotsIndexes","xInterpolator","k","yInterpolator","zInterpolator","shouldSmooth","smoothing","smoothOnAdd","smoothOnEdit","isEqual","pointA","pointB","followingIndex","direction","circularFindNextIndexBy","listParams","otherListParams","criteria","indexDelimiter","otherIndexDelimiter","otherPoints","pointsLength","otherPointsLength","otherStartIndex","findChangedSegment","previousPoints","firstMatchIndex","previousFirstMatchIndex","findMatchIndexes","toBeNotEqualCriteria","isEqualByProximity","lowDiffIndex","lowOtherDiffIndex","getInterpolatedPoints","pointsOfReference","knotsRatioPercentageOnAdd","knotsRatioPercentageOnEdit","knotsRatioPercentage","changedIniIndex","changedEndIndex","filterAnnotationsForDisplay","filterOptions","VolumeViewport","spacingInNormalDirection","getCurrentImageId","colonIndex","imageURI","substring","isReferenceViewable","EPSILON","CONSTANTS","PARALLEL_THRESHOLD","filterAnnotationsWithinSamePlane","annotationsWithParallelNormals","td","annotationViewPlaneNormal","imageOrientationPatient","rowCosineVec","colCosineVec","isParallel","filterAnnotationsWithinSlice","planeRestriction","inPlaneVector1","inPlaneVector2","vector","focalPoint","dotProduct","cameraFocalPoint","halfSpacingInNormalDirection","annotationsWithinSlice","getPointInLineOfSightWithCriteria","targetVolumeId","criteriaFunction","stepSize","getPointsInLineOfSight","pickedPoint","pointToPick","getIntensityFromWorld","normalDirection","step","bounds","getBounds","currentPos","_inBounds","xMin","xMax","yMin","yMax","zMin","zMax","padding","getWorldWidthAndHeightFromCorners","topLeftWorld","bottomRightWorld","viewRight","pos1","pos2","diagonal","diagonalLength","worldWidth","worldHeight","cosTheta","getWorldWidthAndHeightFromTwoPoints","worldPos1","worldPos2","isPlaneIntersectingAABB","origin","normal","minX","minY","minZ","maxX","maxY","maxZ","vertices","normalVec","originVec","planeDistance","initialSign","vertex","deleteRelatedAnnotations","interpolationAnnotations","referencedSliceIndex","minInterpolation","maxInterpolation","nonInterpolated","removedAnnotations","annotationToDelete","INTERPOLATED_ANNOTATIONS_REMOVED","nextAnnotation","viewportNewData","imageIndex","computedRepresentations","computeAndAddRepresentation","computeFunction","updateFunction","onComputationComplete","representations","debouncedUpdateFunction","_debouncedSegmentationModified","_debouncedUpdateFunction","subscribeToSegmentationChanges","segmentColor","getSegmentIndexColor","segmentationVisible","activeSegmentation","isActive","mergedConfig","getViewportIdsWithToolToRender","requireParallelNormals","viewports","getViewports","getViewport","vp"],"sourceRoot":""}